[{"original_method":"/**\n     * Creates a child {@ling Agent} witht the given name.\n     *\n     *\n     * @param name The name of the child {@ling Agent}.\n     * @param parent\n     * @return\n     */\n    protected Container createChildContainer(String name, String parent, String profileName) throws Exception {\n        FabricService fabricService = getFabricService();\n\n        Thread.sleep(DEFAULT_WAIT);\n\n        Container parentContainer = fabricService.getContainer(parent);\n        assertNotNull(parentContainer);\n\n\n        CreateContainerOptions args = CreateContainerOptionsBuilder.child().name(name).parent(parent).jvmOpts(\"-Xms1024m -Xmx1024m\").zookeeperPassword(fabricService.getZookeeperPassword());\n        CreateContainerMetadata[] metadata = fabricService.createContainers(args);\n        if (metadata.length > 0) {\n            if (metadata[0].getFailure() != null) {\n                throw new Exception(\"Error creating child container:\"+name, metadata[0].getFailure());\n            }\n            Container container =  metadata[0].getContainer();\n            Version version = fabricService.getDefaultVersion();\n            Profile profile  = fabricService.getProfile(version.getName(),profileName);\n            assertNotNull(\"Expected to find profile with name:\" + profileName, profile);\n            container.setProfiles(new Profile[]{profile});\n            waitForProvisionSuccess(container, PROVISION_TIMEOUT);\n            return container;\n        }\n        throw new Exception(\"Could container not created\");\n    }","id":89000,"modified_method":"/**\n     * Creates a child {@ling Agent} witht the given name.\n     *\n     *\n     * @param name The name of the child {@ling Agent}.\n     * @param parent\n     * @return\n     */\n    protected Container createChildContainer(String name, String parent, String profileName) throws Exception {\n        FabricService fabricService = getFabricService();\n\n        Thread.sleep(DEFAULT_WAIT);\n\n        Container parentContainer = fabricService.getContainer(parent);\n        assertNotNull(parentContainer);\n\n\n        CreateContainerOptions args = CreateContainerOptionsBuilder.child().name(name).parent(parent).jvmOpts(\"-Xms1024m -Xmx1024m\").zookeeperPassword(fabricService.getZookeeperPassword()).jmxUser(\"admin\").jmxPassword(\"admin\");\n        CreateContainerMetadata[] metadata = fabricService.createContainers(args);\n        if (metadata.length > 0) {\n            if (metadata[0].getFailure() != null) {\n                throw new Exception(\"Error creating child container:\"+name, metadata[0].getFailure());\n            }\n            Container container =  metadata[0].getContainer();\n            Version version = fabricService.getDefaultVersion();\n            Profile profile  = fabricService.getProfile(version.getName(),profileName);\n            assertNotNull(\"Expected to find profile with name:\" + profileName, profile);\n            container.setProfiles(new Profile[]{profile});\n            waitForProvisionSuccess(container, PROVISION_TIMEOUT);\n            return container;\n        }\n        throw new Exception(\"Could container not created\");\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testManipulatePid() throws Exception {\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid/key=value default\"));\n\n        //Check that my.pid has been added to the default profile        \n        Profile profile = fabricService.getProfile(fabricService.getDefaultVersion().getName(), \"default\");\n        Assert.assertNotNull(profile);\n        Map<String, Map<String, String>> configurations = profile.getConfigurations();\n        Assert.assertNotNull(configurations);\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        Map<String, String> myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"value\", myPid.get(\"key\"));\n        \n        \n        //Check append options for a pid.\n        System.err.println(executeCommand(\"fabric:profile-edit --append --pid my.pid/key=othervalue default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"value,othervalue\", myPid.get(\"key\"));\n        \n        System.err.println(executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=value default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"othervalue\", myPid.get(\"key\"));\n        \n        //Check append options for a pid.\n        System.err.println(executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=othervalue default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"\", myPid.get(\"key\"));\n        \n        //Check assign option with '='.\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid/key=prop1=value1 default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"prop1=value1\", myPid.get(\"key\"));\n        \n        //Check multiple properties\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid/key1=value1 --pid my.pid/key2=value2 default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key1\"));\n        Assert.assertEquals(\"value1\", myPid.get(\"key1\"));\n        Assert.assertTrue(myPid.containsKey(\"key2\"));\n        Assert.assertEquals(\"value2\", myPid.get(\"key2\"));\n    }","id":89001,"modified_method":"@Test\n    public void testManipulatePid() throws Exception {\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        waitForFabricCommands();\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid/key=value default\"));\n\n        //Check that my.pid has been added to the default profile        \n        Profile profile = fabricService.getProfile(fabricService.getDefaultVersion().getName(), \"default\");\n        Assert.assertNotNull(profile);\n        Map<String, Map<String, String>> configurations = profile.getConfigurations();\n        Assert.assertNotNull(configurations);\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        Map<String, String> myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"value\", myPid.get(\"key\"));\n        \n        \n        //Check append options for a pid.\n        System.err.println(executeCommand(\"fabric:profile-edit --append --pid my.pid/key=othervalue default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"value,othervalue\", myPid.get(\"key\"));\n        \n        System.err.println(executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=value default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"othervalue\", myPid.get(\"key\"));\n        \n        //Check append options for a pid.\n        System.err.println(executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=othervalue default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"\", myPid.get(\"key\"));\n        \n        //Check assign option with '='.\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid/key=prop1=value1 default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key\"));\n        Assert.assertEquals(\"prop1=value1\", myPid.get(\"key\"));\n        \n        //Check multiple properties\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid/key1=value1 --pid my.pid/key2=value2 default\"));\n        configurations = profile.getConfigurations();\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key1\"));\n        Assert.assertEquals(\"value1\", myPid.get(\"key1\"));\n        Assert.assertTrue(myPid.containsKey(\"key2\"));\n        Assert.assertEquals(\"value2\", myPid.get(\"key2\"));\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testImportPid() throws Exception {\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n        System.err.println(executeCommands(\"config:edit my.pid\",\"config:propset key1 value1\",\"config:propset key2 value2\", \"config:update\"));        \n        System.err.println(executeCommand(\"fabric:create -n\"));\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid --import-pid default\"));\n\n        Thread.sleep(DEFAULT_WAIT);\n        //Check that my.pid has been added to the default profile        \n        Profile profile = fabricService.getProfile(fabricService.getDefaultVersion().getName(), \"default\");\n        Assert.assertNotNull(profile);\n        Map<String, Map<String, String>> configurations = profile.getConfigurations();\n        Assert.assertNotNull(configurations);\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        Map<String, String> myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key1\"));\n        Assert.assertEquals(\"value1\", myPid.get(\"key1\"));\n        Assert.assertTrue(myPid.containsKey(\"key2\"));\n        Assert.assertEquals(\"value2\", myPid.get(\"key2\"));\n    }","id":89002,"modified_method":"@Test\n    public void testImportPid() throws Exception {\n        FabricService fabricService = getOsgiService(FabricService.class);\n        assertNotNull(fabricService);\n        System.err.println(executeCommands(\"config:edit my.pid\",\"config:propset key1 value1\",\"config:propset key2 value2\", \"config:update\"));        \n        System.err.println(executeCommand(\"fabric:create -n\"));\n        waitForFabricCommands();\n        System.err.println(executeCommand(\"fabric:profile-edit --pid my.pid --import-pid default\"));\n\n        Thread.sleep(DEFAULT_WAIT);\n        //Check that my.pid has been added to the default profile        \n        Profile profile = fabricService.getProfile(fabricService.getDefaultVersion().getName(), \"default\");\n        Assert.assertNotNull(profile);\n        Map<String, Map<String, String>> configurations = profile.getConfigurations();\n        Assert.assertNotNull(configurations);\n        Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n        Map<String, String> myPid = configurations.get(\"my.pid\");\n        Assert.assertNotNull(myPid);\n        Assert.assertTrue(myPid.containsKey(\"key1\"));\n        Assert.assertEquals(\"value1\", myPid.get(\"key1\"));\n        Assert.assertTrue(myPid.containsKey(\"key2\"));\n        Assert.assertEquals(\"value2\", myPid.get(\"key2\"));\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testResolverInheritanceOnChild() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n -g localip -r manualip --manual-ip localhost\"));\n        IZKClient zookeeper = getOsgiService(IZKClient.class);\n        try {\n            createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n\n            Assert.assertEquals(\"manualip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            Assert.assertEquals(\"manualip\", getFabricService().getCurrentContainer().getResolver());\n\n            //We want to make sure that the child points to the parent, so we change the parent resolvers and assert.\n            getOsgiService(BlueprintContainer.class, \"(osgi.blueprint.container.symbolicname=org.fusesource.fabric.fabric-commands)\", DEFAULT_TIMEOUT);\n            System.err.println(executeCommand(\"fabric:container-resolver-set --container root localip\"));\n            Assert.assertEquals(\"localip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n\n        } finally {\n            destroyChildContainer(\"child1\");\n        }\n    }","id":89003,"modified_method":"@Test\n    public void testResolverInheritanceOnChild() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n -g localip -r manualip --manual-ip localhost\"));\n        IZKClient zookeeper = getOsgiService(IZKClient.class);\n        try {\n            createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n\n            Assert.assertEquals(\"manualip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            Assert.assertEquals(\"manualip\", getFabricService().getCurrentContainer().getResolver());\n\n            //We want to make sure that the child points to the parent, so we change the parent resolvers and assert.\n            waitForFabricCommands();\n            System.err.println(executeCommand(\"fabric:container-resolver-set --container root localip\"));\n            Assert.assertEquals(\"localip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n\n        } finally {\n            destroyChildContainer(\"child1\");\n        }\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@After\n    public void tearDown() throws InterruptedException {\n        for (Container container : containers) {\n            System.out.println(\"destroying \" + container.getId());\n            destroyChildContainer(container.getId());\n        }\n        ContainerBuilder.destroy();\n    }","id":89004,"modified_method":"@After\n    public void tearDown() throws InterruptedException {\n        for (Container container : containers.values()) {\n            System.out.println(\"destroying \" + container.getId());\n            destroyChildContainer(container.getId());\n        }\n    }","commit_id":"bf53b07874e16c2aa7572c8675ace14b9847ee66","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testMQCreateMS() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n\n        Thread.sleep(10000);\n\n        executeCommand(\"mq-create --create-container broker --jmx-user admin --jmx-password admin ms-broker\");\n        Container container1 = getFabricService().getContainer(\"broker1\");\n        Container container2 = getFabricService().getContainer(\"broker2\");\n        containers.add(container1);\n        containers.add(container2);\n\n        Provision.containersStatus(containers, \"success\", PROVISION_TIMEOUT);\n        installAndCheckFeature(\"activemq\");\n        Thread.sleep(10000);\n\n        BrokerViewMBean broker1 = (BrokerViewMBean)getMBean(container1, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=ms-broker\"), BrokerViewMBean.class);\n\n        assertEquals(\"ms-broker\", broker1.getBrokerName());\n        destroyChildContainer(\"broker1\");\n        containers.remove(container1);\n        Thread.sleep(10000); // TODO implement wait for condition with timeout\n\n        BrokerViewMBean broker2 = (BrokerViewMBean)getMBean(container2, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=ms-broker\"), BrokerViewMBean.class);\n        assertEquals(\"ms-broker\", broker2.getBrokerName());\n\n        //TODO add example to verify failover\n\n    }","id":89005,"modified_method":"@Test\n    public void testMQCreateMS() throws Exception {\n\n        System.err.println(executeCommand(\"fabric:create -n\"));\n\n        CuratorFramework curator = getCurator();\n\n        executeCommand(\"mq-create --create-container broker --jmx-user admin --jmx-password admin ms-broker\");\n        Container container1 = getFabricService().getContainer(\"broker1\");\n        Container container2 = getFabricService().getContainer(\"broker2\");\n        containers.put(\"broker1\", container1);\n        containers.put(\"broker2\", container2);\n\n        Provision.containersStatus(containers.values(), \"success\", PROVISION_TIMEOUT);\n\n        final ZooKeeperMultiGroup group = new ZooKeeperMultiGroup<ActiveMQNode>(curator, \"/fabric/registry/clusters/fusemq/default\", ActiveMQNode.class);\n        group.start();\n        ActiveMQNode master = null;\n        Provision.waitForCondition(new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                while ((ActiveMQNode)group.master() == null) {\n                    Thread.sleep(1000);\n                }\n                return true;\n            }\n        }, 30000L);\n        master = (ActiveMQNode)group.master();\n        final String masterContainer = master.getContainer();\n        System.err.println(\"master=\" + masterContainer);\n\n        BrokerViewMBean broker1 = (BrokerViewMBean)Provision.getMBean(getFabricService().getContainer(masterContainer), new ObjectName(\"org.apache.activemq:type=Broker,brokerName=ms-broker\"), BrokerViewMBean.class, 30000);\n\n        assertEquals(\"ms-broker\", broker1.getBrokerName());\n\n        destroyChildContainer(masterContainer);\n        containers.remove(containers.get(masterContainer));\n\n        Provision.waitForCondition(new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                while (group.master() == null || group.master().getContainer() == masterContainer) {\n                    Thread.sleep(1000);\n                }\n                return true;\n            }\n        }, 30000L);\n        master = (ActiveMQNode)group.master();\n        System.err.println(\"new master=\" + master.getContainer());\n\n        BrokerViewMBean broker2 = (BrokerViewMBean)Provision.getMBean(getFabricService().getContainer(master.getContainer()), new ObjectName(\"org.apache.activemq:type=Broker,brokerName=ms-broker\"), BrokerViewMBean.class, 30000);\n        assertEquals(\"ms-broker\", broker2.getBrokerName());\n\n        //TODO add example to verify failover\n\n    }","commit_id":"bf53b07874e16c2aa7572c8675ace14b9847ee66","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testMQCreateNetwork() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        addStagingRepoToDefaultProfile();\n\n        Thread.sleep(10000);\n\n        executeCommand(\"mq-create --group us-east --networks us-west --create-container us-east --jmx-user admin --jmx-password admin --networks-username admin --networks-password admin --minimumInstances 1 us-east\");\n        executeCommand(\"mq-create --group us-west --networks us-east --create-container us-west --jmx-user admin --jmx-password admin --networks-username admin --networks-password admin --minimumInstances 1 us-west\");\n        Container container1 = getFabricService().getContainer(\"us-east1\");\n        containers.add(container1);\n        Container container2 = getFabricService().getContainer(\"us-west1\");\n        containers.add(container2);\n\n        Provision.containersStatus(containers, \"success\", PROVISION_TIMEOUT);\n\n        containers.addAll(ContainerBuilder.create().withName(\"example-producer\").withProfiles(\"example-mq-producer\").withProfiles(\"mq-client-us-east\").assertProvisioningResult().build());\n        containers.addAll(ContainerBuilder.create().withName(\"example-consumer\").withProfiles(\"example-mq-consumer\").withProfiles(\"mq-client-us-west\").assertProvisioningResult().build());\n        // give it a bit time\n        Thread.sleep(10000);\n\n        installAndCheckFeature(\"activemq\");\n\n        BrokerViewMBean brokerEast = (BrokerViewMBean)getMBean(container1, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=us-east\"), BrokerViewMBean.class);\n        BrokerViewMBean brokerWest = (BrokerViewMBean)getMBean(container2, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=us-west\"), BrokerViewMBean.class);\n\n        assertFalse(\"Messages not sent\", brokerEast.getTotalEnqueueCount() == 0);\n\n        assertFalse(\"Messages not received\", brokerWest.getTotalDequeueCount() == 0);\n\n    }","id":89006,"modified_method":"@Test\n    public void testMQCreateNetwork() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n\n        executeCommand(\"mq-create --group us-east --networks us-west --create-container us-east --jmx-user admin --jmx-password admin --networks-username admin --networks-password admin --minimumInstances 1 us-east\");\n        executeCommand(\"mq-create --group us-west --networks us-east --create-container us-west --jmx-user admin --jmx-password admin --networks-username admin --networks-password admin --minimumInstances 1 us-west\");\n        Container container1 = getFabricService().getContainer(\"us-east1\");\n        containers.put(\"us-east1\", container1);\n        Container container2 = getFabricService().getContainer(\"us-west1\");\n        containers.put(\"us-west1\", container2);\n\n        Provision.containersStatus(containers.values(), \"success\", PROVISION_TIMEOUT);\n\n        final BrokerViewMBean brokerEast = (BrokerViewMBean)Provision.getMBean(container1, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=us-east\"), BrokerViewMBean.class, 30000);\n        final BrokerViewMBean brokerWest = (BrokerViewMBean)Provision.getMBean(container2, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=us-west\"), BrokerViewMBean.class, 30000);\n\n        addAll(containers, ContainerBuilder.create().withName(\"example-producer\").withProfiles(\"example-mq-producer\").withProfiles(\"mq-client-us-east\").assertProvisioningResult().build());\n        addAll(containers, ContainerBuilder.create().withName(\"example-consumer\").withProfiles(\"example-mq-consumer\").withProfiles(\"mq-client-us-west\").assertProvisioningResult().build());\n\n        Provision.waitForCondition(new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                while(brokerEast.getTotalEnqueueCount() == 0 && brokerWest.getTotalDequeueCount() == 0) {\n                    Thread.sleep(1000);\n                }\n                return true;\n            }\n        }, 30000L);\n\n        assertFalse(\"Messages not sent\", brokerEast.getTotalEnqueueCount() == 0);\n\n        assertFalse(\"Messages not received\", brokerWest.getTotalDequeueCount() == 0);\n\n    }","commit_id":"bf53b07874e16c2aa7572c8675ace14b9847ee66","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return fabricDistributionConfiguration();\n    }","id":89007,"modified_method":"@Configuration\n   \tpublic Option[] config() {\n   \t\treturn new Option[]{\n   \t\t\t\tnew DefaultCompositeOption(fabricDistributionConfiguration()),\n                scanFeatures(\"default\", \"mq-fabric\").start()\n   \t\t};\n   \t}","commit_id":"bf53b07874e16c2aa7572c8675ace14b9847ee66","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testLocalChildCreation() throws Exception {\n\n        System.err.println(executeCommand(\"fabric:create -n\"));\n\n        Set<Container> containers = ContainerBuilder.create().withName(\"mq\").withProfiles(\"mq-default\").assertProvisioningResult().build();\n\n        installAndCheckFeature(\"activemq\");\n\n\n        Container container = getFabricService().getContainer(\"mq1\");\n\n        // give it a bit time\n        Thread.sleep(5000);\n\n        // check jmx stats\n        BrokerViewMBean bean = (BrokerViewMBean)getMBean(container, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=mq1\"), BrokerViewMBean.class);\n        assertEquals(\"Producer not present\", 0, bean.getTotalProducerCount());\n        assertEquals(\"Consumer not present\", 0, bean.getTotalConsumerCount());\n\n\n        containers.addAll(ContainerBuilder.create().withName(\"example\").withProfiles(\"example-mq\").assertProvisioningResult().build());\n        // give it a bit time\n        Thread.sleep(10000);\n        assertEquals(\"Producer not present\", 1, bean.getTotalProducerCount());\n        assertEquals(\"Consumer not present\", 1, bean.getTotalConsumerCount());\n    }","id":89008,"modified_method":"@Test\n    public void testLocalChildCreation() throws Exception {\n\n        System.err.println(executeCommand(\"fabric:create -n\"));\n\n        addAll(containers, ContainerBuilder.create().withName(\"mq\").withProfiles(\"mq-default\").assertProvisioningResult().build());\n\n\n        Container container = getFabricService().getContainer(\"mq1\");\n\n        // check jmx stats\n        final BrokerViewMBean bean = (BrokerViewMBean)Provision.getMBean(container, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=mq1\"), BrokerViewMBean.class, 30000);\n        assertEquals(\"Producer not present\", 0, bean.getTotalProducerCount());\n        assertEquals(\"Consumer not present\", 0, bean.getTotalConsumerCount());\n\n\n        addAll(containers, ContainerBuilder.create().withName(\"example\").withProfiles(\"example-mq\").assertProvisioningResult().build());\n\n        Provision.waitForCondition(new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                while(bean.getTotalProducerCount() == 0 && bean.getTotalConsumerCount() == 0) {\n                    Thread.sleep(1000);\n                }\n                return true;\n            }\n        }, 30000L);\n        assertEquals(\"Producer not present\", 1, bean.getTotalProducerCount());\n        assertEquals(\"Consumer not present\", 1, bean.getTotalConsumerCount());\n    }","commit_id":"bf53b07874e16c2aa7572c8675ace14b9847ee66","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testMQCreateBasic() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        //addStagingRepoToDefaultProfile();\n\n        Thread.sleep(10000);\n\n        System.out.println(executeCommand(\"mq-create --create-container mq --jmx-user admin --jmx-password admin --minimumInstances 1 mq\"));\n        // give it a bit time\n        Thread.sleep(5000);\n\n        installAndCheckFeature(\"activemq\");\n\n        Container container = getFabricService().getContainer(\"mq1\");\n        containers.add(container);\n        Provision.containersStatus(Arrays.asList(container), \"success\", PROVISION_TIMEOUT);\n\n        BrokerViewMBean bean = (BrokerViewMBean)getMBean(container, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=mq\"), BrokerViewMBean.class);\n\n        System.out.println(executeCommand(\"container-list\"));\n\n\n        containers.addAll(ContainerBuilder.create().withName(\"example\").withProfiles(\"example-mq\").assertProvisioningResult().build());\n        // give it a bit time\n        Thread.sleep(10000);\n\n        installAndCheckFeature(\"activemq\");\n\n        // check jmx stats\n        assertEquals(\"Producer not present\", 1, bean.getTotalProducerCount());\n        assertEquals(\"Consumer not present\", 1, bean.getTotalConsumerCount());\n    }","id":89009,"modified_method":"@Test\n    public void testMQCreateBasic() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n\n        System.err.println(executeCommand(\"mq-create --create-container mq --jmx-user admin --jmx-password admin --minimumInstances 1 mq\"));\n\n        Provision.waitForCondition(new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                while(getFabricService().getContainer(\"mq1\") == null) {\n                    Thread.sleep(1000);\n                }\n                return true;\n            }\n        }, 30000L);\n\n        Container container = getFabricService().getContainer(\"mq1\");\n        containers.put(\"mq1\", container);\n        Provision.containersStatus(Arrays.asList(container), \"success\", PROVISION_TIMEOUT);\n\n        final BrokerViewMBean bean = (BrokerViewMBean)Provision.getMBean(container, new ObjectName(\"org.apache.activemq:type=Broker,brokerName=mq\"), BrokerViewMBean.class, 30000);\n\n        System.err.println(executeCommand(\"container-list\"));\n\n\n        addAll(containers, ContainerBuilder.create().withName(\"example\").withProfiles(\"example-mq\").assertProvisioningResult().build());\n\n        Provision.waitForCondition(new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                while(bean.getTotalProducerCount() == 0 && bean.getTotalConsumerCount() == 0) {\n                    Thread.sleep(1000);\n                }\n                return true;\n            }\n        }, 30000L);\n\n        // check jmx stats\n        assertEquals(\"Producer not present\", 1, bean.getTotalProducerCount());\n        assertEquals(\"Consumer not present\", 1, bean.getTotalConsumerCount());\n    }","commit_id":"bf53b07874e16c2aa7572c8675ace14b9847ee66","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void tune() {\n      // TODO check if we can increase the memory boundaries\n      // while remaining in the limits\n      long curEvictCount;\n      long curCacheMisCount;\n      curEvictCount = blockCache.getStats().getEvictedCount();\n      tunerContext.setEvictCount(curEvictCount - evictCount);\n      evictCount = curEvictCount;\n      curCacheMisCount = blockCache.getStats().getMissCachingCount();\n      tunerContext.setCacheMissCount(curCacheMisCount-cacheMissCount);\n      cacheMissCount = curCacheMisCount;\n      tunerContext.setBlockedFlushCount(blockedFlushCount.getAndSet(0));\n      tunerContext.setUnblockedFlushCount(unblockedFlushCount.getAndSet(0));\n      tunerContext.setCurBlockCacheUsed((float)blockCache.getCurrentSize() / maxHeapSize);\n      tunerContext.setCurMemStoreUsed(\n                 (float)regionServerAccounting.getGlobalMemstoreSize() / maxHeapSize);\n      tunerContext.setCurBlockCacheSize(blockCachePercent);\n      tunerContext.setCurMemStoreSize(globalMemStorePercent);\n      TunerResult result = null;\n      try {\n        result = this.heapMemTuner.tune(tunerContext);\n      } catch (Throwable t) {\n        LOG.error(\"Exception thrown from the HeapMemoryTuner implementation\", t);\n      }\n      if (result != null && result.needsTuning()) {\n        float memstoreSize = result.getMemstoreSize();\n        float blockCacheSize = result.getBlockCacheSize();\n        LOG.debug(\"From HeapMemoryTuner new memstoreSize: \" + memstoreSize\n            + \". new blockCacheSize: \" + blockCacheSize);\n        if (memstoreSize < globalMemStorePercentMinRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is below min level \"\n              + globalMemStorePercentMinRange + \". Resetting memstoreSize to min size\");\n          memstoreSize = globalMemStorePercentMinRange;\n        } else if (memstoreSize > globalMemStorePercentMaxRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is above max level \"\n              + globalMemStorePercentMaxRange + \". Resetting memstoreSize to max size\");\n          memstoreSize = globalMemStorePercentMaxRange;\n        }\n        if (blockCacheSize < blockCachePercentMinRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is below min level \" + blockCachePercentMinRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMinRange;\n        } else if (blockCacheSize > blockCachePercentMaxRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is above max level \" + blockCachePercentMaxRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMaxRange;\n        }\n        int gml = (int) (memstoreSize * CONVERT_TO_PERCENTAGE);\n        int bcul = (int) ((blockCacheSize + l2BlockCachePercent) * CONVERT_TO_PERCENTAGE);\n        if (CONVERT_TO_PERCENTAGE - (gml + bcul) < CLUSTER_MINIMUM_MEMORY_THRESHOLD) {\n          LOG.info(\"Current heap configuration from HeapMemoryTuner exceeds \"\n              + \"the threshold required for successful cluster operation. \"\n              + \"The combined value cannot exceed 0.8. \" + HeapMemorySizeUtil.MEMSTORE_SIZE_KEY\n              + \" is \" + memstoreSize + \" and \" + HFILE_BLOCK_CACHE_SIZE_KEY + \" is \"\n              + blockCacheSize);\n          // TODO can adjust the value so as not exceed 80%. Is that correct? may be.\n        } else {\n          long newBlockCacheSize = (long) (maxHeapSize * blockCacheSize);\n          long newMemstoreSize = (long) (maxHeapSize * memstoreSize);\n          LOG.info(\"Setting block cache heap size to \" + newBlockCacheSize\n              + \" and memstore heap size to \" + newMemstoreSize);\n          blockCachePercent = blockCacheSize;\n          blockCache.setMaxSize(newBlockCacheSize);\n          globalMemStorePercent = memstoreSize;\n          memStoreFlusher.setGlobalMemstoreLimit(newMemstoreSize);\n        }\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No changes made by HeapMemoryTuner.\");\n      }\n    }","id":89010,"modified_method":"private void tune() {\n      // TODO check if we can increase the memory boundaries\n      // while remaining in the limits\n      long curEvictCount;\n      long curCacheMisCount;\n      long blockedFlushCnt;\n      long unblockedFlushCnt;\n      curEvictCount = blockCache.getStats().getEvictedCount();\n      tunerContext.setEvictCount(curEvictCount - evictCount);\n      evictCount = curEvictCount;\n      curCacheMisCount = blockCache.getStats().getMissCachingCount();\n      tunerContext.setCacheMissCount(curCacheMisCount-cacheMissCount);\n      cacheMissCount = curCacheMisCount;\n      blockedFlushCnt = blockedFlushCount.getAndSet(0);\n      tunerContext.setBlockedFlushCount(blockedFlushCnt);\n      metricsHeapMemoryManager.updateBlockedFlushCount(blockedFlushCnt);\n      unblockedFlushCnt = unblockedFlushCount.getAndSet(0);\n      tunerContext.setUnblockedFlushCount(unblockedFlushCnt);\n      metricsHeapMemoryManager.updateUnblockedFlushCount(unblockedFlushCnt);\n      tunerContext.setCurBlockCacheUsed((float) blockCache.getCurrentSize() / maxHeapSize);\n      metricsHeapMemoryManager.setCurBlockCacheSizeGauge(blockCache.getCurrentSize());\n      tunerContext.setCurMemStoreUsed((float)regionServerAccounting.getGlobalMemstoreSize() / maxHeapSize);\n      metricsHeapMemoryManager.setCurMemStoreSizeGauge(regionServerAccounting.getGlobalMemstoreSize());\n      tunerContext.setCurBlockCacheSize(blockCachePercent);\n      tunerContext.setCurMemStoreSize(globalMemStorePercent);\n      TunerResult result = null;\n      try {\n        result = this.heapMemTuner.tune(tunerContext);\n      } catch (Throwable t) {\n        LOG.error(\"Exception thrown from the HeapMemoryTuner implementation\", t);\n      }\n      if (result != null && result.needsTuning()) {\n        float memstoreSize = result.getMemstoreSize();\n        float blockCacheSize = result.getBlockCacheSize();\n        LOG.debug(\"From HeapMemoryTuner new memstoreSize: \" + memstoreSize\n            + \". new blockCacheSize: \" + blockCacheSize);\n        if (memstoreSize < globalMemStorePercentMinRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is below min level \"\n              + globalMemStorePercentMinRange + \". Resetting memstoreSize to min size\");\n          memstoreSize = globalMemStorePercentMinRange;\n        } else if (memstoreSize > globalMemStorePercentMaxRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is above max level \"\n              + globalMemStorePercentMaxRange + \". Resetting memstoreSize to max size\");\n          memstoreSize = globalMemStorePercentMaxRange;\n        }\n        if (blockCacheSize < blockCachePercentMinRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is below min level \" + blockCachePercentMinRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMinRange;\n        } else if (blockCacheSize > blockCachePercentMaxRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is above max level \" + blockCachePercentMaxRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMaxRange;\n        }\n        int gml = (int) (memstoreSize * CONVERT_TO_PERCENTAGE);\n        int bcul = (int) ((blockCacheSize + l2BlockCachePercent) * CONVERT_TO_PERCENTAGE);\n        if (CONVERT_TO_PERCENTAGE - (gml + bcul) < CLUSTER_MINIMUM_MEMORY_THRESHOLD) {\n          LOG.info(\"Current heap configuration from HeapMemoryTuner exceeds \"\n              + \"the threshold required for successful cluster operation. \"\n              + \"The combined value cannot exceed 0.8. \" + HeapMemorySizeUtil.MEMSTORE_SIZE_KEY\n              + \" is \" + memstoreSize + \" and \" + HFILE_BLOCK_CACHE_SIZE_KEY + \" is \"\n              + blockCacheSize);\n          // TODO can adjust the value so as not exceed 80%. Is that correct? may be.\n        } else {\n          int memStoreDeltaSize =\n              (int) ((memstoreSize - globalMemStorePercent) * CONVERT_TO_PERCENTAGE);\n          int blockCacheDeltaSize =\n              (int) ((blockCacheSize - blockCachePercent) * CONVERT_TO_PERCENTAGE);\n          metricsHeapMemoryManager.updateMemStoreDeltaSizeHistogram(memStoreDeltaSize);\n          metricsHeapMemoryManager.updateBlockCacheDeltaSizeHistogram(blockCacheDeltaSize);\n          long newBlockCacheSize = (long) (maxHeapSize * blockCacheSize);\n          long newMemstoreSize = (long) (maxHeapSize * memstoreSize);\n          LOG.info(\"Setting block cache heap size to \" + newBlockCacheSize\n              + \" and memstore heap size to \" + newMemstoreSize);\n          blockCachePercent = blockCacheSize;\n          blockCache.setMaxSize(newBlockCacheSize);\n          globalMemStorePercent = memstoreSize;\n          memStoreFlusher.setGlobalMemstoreLimit(newMemstoreSize);\n        }\n      } else {\n        metricsHeapMemoryManager.increaseTunerDoNothingCounter();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No changes made by HeapMemoryTuner.\");\n        }\n      }\n    }","commit_id":"abfd584fe646951a9d0b43602052bbe2b82c3364","url":"https://github.com/apache/hbase"},{"original_method":"@VisibleForTesting\n  HeapMemoryManager(ResizableBlockCache blockCache, FlushRequester memStoreFlusher,\n                Server server, RegionServerAccounting regionServerAccounting) {\n    Configuration conf = server.getConfiguration();\n    this.blockCache = blockCache;\n    this.memStoreFlusher = memStoreFlusher;\n    this.server = server;\n    this.regionServerAccounting = regionServerAccounting;\n    this.tunerOn = doInit(conf);\n    this.defaultChorePeriod = conf.getInt(HBASE_RS_HEAP_MEMORY_TUNER_PERIOD,\n      HBASE_RS_HEAP_MEMORY_TUNER_DEFAULT_PERIOD);\n    this.heapOccupancyLowWatermark = conf.getFloat(HConstants.HEAP_OCCUPANCY_LOW_WATERMARK_KEY,\n      HConstants.DEFAULT_HEAP_OCCUPANCY_LOW_WATERMARK);\n  }","id":89011,"modified_method":"@VisibleForTesting\n  HeapMemoryManager(ResizableBlockCache blockCache, FlushRequester memStoreFlusher,\n                Server server, RegionServerAccounting regionServerAccounting) {\n    Configuration conf = server.getConfiguration();\n    this.blockCache = blockCache;\n    this.memStoreFlusher = memStoreFlusher;\n    this.server = server;\n    this.regionServerAccounting = regionServerAccounting;\n    this.tunerOn = doInit(conf);\n    this.defaultChorePeriod = conf.getInt(HBASE_RS_HEAP_MEMORY_TUNER_PERIOD,\n      HBASE_RS_HEAP_MEMORY_TUNER_DEFAULT_PERIOD);\n    this.heapOccupancyLowWatermark = conf.getFloat(HConstants.HEAP_OCCUPANCY_LOW_WATERMARK_KEY,\n      HConstants.DEFAULT_HEAP_OCCUPANCY_LOW_WATERMARK);\n    metricsHeapMemoryManager = new MetricsHeapMemoryManager();\n  }","commit_id":"abfd584fe646951a9d0b43602052bbe2b82c3364","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    protected void chore() {\n      // Sample heap occupancy\n      MemoryUsage memUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n      heapOccupancyPercent = (float)memUsage.getUsed() / (float)memUsage.getCommitted();\n      // If we are above the heap occupancy alarm low watermark, switch to short\n      // sleeps for close monitoring. Stop autotuning, we are in a danger zone.\n      if (heapOccupancyPercent >= heapOccupancyLowWatermark) {\n        if (!alarming) {\n          LOG.warn(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is above heap occupancy alarm watermark (\" + heapOccupancyLowWatermark + \")\");\n          alarming = true;\n        }\n        triggerNow();\n        try {\n          // Need to sleep ourselves since we've told the chore's sleeper\n          // to skip the next sleep cycle.\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          // Interrupted, propagate\n          Thread.currentThread().interrupt();\n        }\n      } else {\n        if (alarming) {\n          LOG.info(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is now below the heap occupancy alarm watermark (\" +\n            heapOccupancyLowWatermark + \")\");\n          alarming = false;\n        }\n      }\n      // Autotune if tuning is enabled and allowed\n      if (tunerOn && !alarming) {\n        tune();\n      }\n    }","id":89012,"modified_method":"@Override\n    protected void chore() {\n      // Sample heap occupancy\n      MemoryUsage memUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n      heapOccupancyPercent = (float)memUsage.getUsed() / (float)memUsage.getCommitted();\n      // If we are above the heap occupancy alarm low watermark, switch to short\n      // sleeps for close monitoring. Stop autotuning, we are in a danger zone.\n      if (heapOccupancyPercent >= heapOccupancyLowWatermark) {\n        if (!alarming) {\n          LOG.warn(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is above heap occupancy alarm watermark (\" + heapOccupancyLowWatermark + \")\");\n          alarming = true;\n        }\n        metricsHeapMemoryManager.increaseAboveHeapOccupancyLowWatermarkCounter();\n        triggerNow();\n        try {\n          // Need to sleep ourselves since we've told the chore's sleeper\n          // to skip the next sleep cycle.\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          // Interrupted, propagate\n          Thread.currentThread().interrupt();\n        }\n      } else {\n        if (alarming) {\n          LOG.info(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is now below the heap occupancy alarm watermark (\" +\n            heapOccupancyLowWatermark + \")\");\n          alarming = false;\n        }\n      }\n      // Autotune if tuning is enabled and allowed\n      if (tunerOn && !alarming) {\n        tune();\n      }\n    }","commit_id":"abfd584fe646951a9d0b43602052bbe2b82c3364","url":"https://github.com/apache/hbase"},{"original_method":"@VisibleForTesting\n  HeapMemoryManager(ResizableBlockCache blockCache, FlushRequester memStoreFlusher,\n                Server server, RegionServerAccounting regionServerAccounting) {\n    Configuration conf = server.getConfiguration();\n    this.blockCache = blockCache;\n    this.memStoreFlusher = memStoreFlusher;\n    this.server = server;\n    this.regionServerAccounting = regionServerAccounting;\n    this.tunerOn = doInit(conf);\n    this.defaultChorePeriod = conf.getInt(HBASE_RS_HEAP_MEMORY_TUNER_PERIOD,\n      HBASE_RS_HEAP_MEMORY_TUNER_DEFAULT_PERIOD);\n    this.heapOccupancyLowWatermark = conf.getFloat(HConstants.HEAP_OCCUPANCY_LOW_WATERMARK_KEY,\n      HConstants.DEFAULT_HEAP_OCCUPANCY_LOW_WATERMARK);\n    metricsHeapMemoryManager = new MetricsHeapMemoryManager();\n  }","id":89013,"modified_method":"@VisibleForTesting\n  HeapMemoryManager(ResizableBlockCache blockCache, FlushRequester memStoreFlusher,\n                Server server, RegionServerAccounting regionServerAccounting) {\n    Configuration conf = server.getConfiguration();\n    this.blockCache = blockCache;\n    this.memStoreFlusher = memStoreFlusher;\n    this.server = server;\n    this.regionServerAccounting = regionServerAccounting;\n    this.tunerOn = doInit(conf);\n    this.defaultChorePeriod = conf.getInt(HBASE_RS_HEAP_MEMORY_TUNER_PERIOD,\n      HBASE_RS_HEAP_MEMORY_TUNER_DEFAULT_PERIOD);\n    this.heapOccupancyLowWatermark = conf.getFloat(HConstants.HEAP_OCCUPANCY_LOW_WATERMARK_KEY,\n      HConstants.DEFAULT_HEAP_OCCUPANCY_LOW_WATERMARK);\n  }","commit_id":"eff38ccf8cf9c61f1bda1005bd19b58c960e3fd2","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    protected void chore() {\n      // Sample heap occupancy\n      MemoryUsage memUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n      heapOccupancyPercent = (float)memUsage.getUsed() / (float)memUsage.getCommitted();\n      // If we are above the heap occupancy alarm low watermark, switch to short\n      // sleeps for close monitoring. Stop autotuning, we are in a danger zone.\n      if (heapOccupancyPercent >= heapOccupancyLowWatermark) {\n        if (!alarming) {\n          LOG.warn(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is above heap occupancy alarm watermark (\" + heapOccupancyLowWatermark + \")\");\n          alarming = true;\n        }\n        metricsHeapMemoryManager.increaseAboveHeapOccupancyLowWatermarkCounter();\n        triggerNow();\n        try {\n          // Need to sleep ourselves since we've told the chore's sleeper\n          // to skip the next sleep cycle.\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          // Interrupted, propagate\n          Thread.currentThread().interrupt();\n        }\n      } else {\n        if (alarming) {\n          LOG.info(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is now below the heap occupancy alarm watermark (\" +\n            heapOccupancyLowWatermark + \")\");\n          alarming = false;\n        }\n      }\n      // Autotune if tuning is enabled and allowed\n      if (tunerOn && !alarming) {\n        tune();\n      }\n    }","id":89014,"modified_method":"@Override\n    protected void chore() {\n      // Sample heap occupancy\n      MemoryUsage memUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n      heapOccupancyPercent = (float)memUsage.getUsed() / (float)memUsage.getCommitted();\n      // If we are above the heap occupancy alarm low watermark, switch to short\n      // sleeps for close monitoring. Stop autotuning, we are in a danger zone.\n      if (heapOccupancyPercent >= heapOccupancyLowWatermark) {\n        if (!alarming) {\n          LOG.warn(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is above heap occupancy alarm watermark (\" + heapOccupancyLowWatermark + \")\");\n          alarming = true;\n        }\n        triggerNow();\n        try {\n          // Need to sleep ourselves since we've told the chore's sleeper\n          // to skip the next sleep cycle.\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          // Interrupted, propagate\n          Thread.currentThread().interrupt();\n        }\n      } else {\n        if (alarming) {\n          LOG.info(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is now below the heap occupancy alarm watermark (\" +\n            heapOccupancyLowWatermark + \")\");\n          alarming = false;\n        }\n      }\n      // Autotune if tuning is enabled and allowed\n      if (tunerOn && !alarming) {\n        tune();\n      }\n    }","commit_id":"eff38ccf8cf9c61f1bda1005bd19b58c960e3fd2","url":"https://github.com/apache/hbase"},{"original_method":"private void tune() {\n      // TODO check if we can increase the memory boundaries\n      // while remaining in the limits\n      long curEvictCount;\n      long curCacheMisCount;\n      long blockedFlushCnt;\n      long unblockedFlushCnt;\n      curEvictCount = blockCache.getStats().getEvictedCount();\n      tunerContext.setEvictCount(curEvictCount - evictCount);\n      evictCount = curEvictCount;\n      curCacheMisCount = blockCache.getStats().getMissCachingCount();\n      tunerContext.setCacheMissCount(curCacheMisCount-cacheMissCount);\n      cacheMissCount = curCacheMisCount;\n      blockedFlushCnt = blockedFlushCount.getAndSet(0);\n      tunerContext.setBlockedFlushCount(blockedFlushCnt);\n      metricsHeapMemoryManager.updateBlockedFlushCount(blockedFlushCnt);\n      unblockedFlushCnt = unblockedFlushCount.getAndSet(0);\n      tunerContext.setUnblockedFlushCount(unblockedFlushCnt);\n      metricsHeapMemoryManager.updateUnblockedFlushCount(unblockedFlushCnt);\n      tunerContext.setCurBlockCacheUsed((float) blockCache.getCurrentSize() / maxHeapSize);\n      metricsHeapMemoryManager.setCurBlockCacheSizeGauge(blockCache.getCurrentSize());\n      tunerContext.setCurMemStoreUsed((float)regionServerAccounting.getGlobalMemstoreSize() / maxHeapSize);\n      metricsHeapMemoryManager.setCurMemStoreSizeGauge(regionServerAccounting.getGlobalMemstoreSize());\n      tunerContext.setCurBlockCacheSize(blockCachePercent);\n      tunerContext.setCurMemStoreSize(globalMemStorePercent);\n      TunerResult result = null;\n      try {\n        result = this.heapMemTuner.tune(tunerContext);\n      } catch (Throwable t) {\n        LOG.error(\"Exception thrown from the HeapMemoryTuner implementation\", t);\n      }\n      if (result != null && result.needsTuning()) {\n        float memstoreSize = result.getMemstoreSize();\n        float blockCacheSize = result.getBlockCacheSize();\n        LOG.debug(\"From HeapMemoryTuner new memstoreSize: \" + memstoreSize\n            + \". new blockCacheSize: \" + blockCacheSize);\n        if (memstoreSize < globalMemStorePercentMinRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is below min level \"\n              + globalMemStorePercentMinRange + \". Resetting memstoreSize to min size\");\n          memstoreSize = globalMemStorePercentMinRange;\n        } else if (memstoreSize > globalMemStorePercentMaxRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is above max level \"\n              + globalMemStorePercentMaxRange + \". Resetting memstoreSize to max size\");\n          memstoreSize = globalMemStorePercentMaxRange;\n        }\n        if (blockCacheSize < blockCachePercentMinRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is below min level \" + blockCachePercentMinRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMinRange;\n        } else if (blockCacheSize > blockCachePercentMaxRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is above max level \" + blockCachePercentMaxRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMaxRange;\n        }\n        int gml = (int) (memstoreSize * CONVERT_TO_PERCENTAGE);\n        int bcul = (int) ((blockCacheSize + l2BlockCachePercent) * CONVERT_TO_PERCENTAGE);\n        if (CONVERT_TO_PERCENTAGE - (gml + bcul) < CLUSTER_MINIMUM_MEMORY_THRESHOLD) {\n          LOG.info(\"Current heap configuration from HeapMemoryTuner exceeds \"\n              + \"the threshold required for successful cluster operation. \"\n              + \"The combined value cannot exceed 0.8. \" + HeapMemorySizeUtil.MEMSTORE_SIZE_KEY\n              + \" is \" + memstoreSize + \" and \" + HFILE_BLOCK_CACHE_SIZE_KEY + \" is \"\n              + blockCacheSize);\n          // TODO can adjust the value so as not exceed 80%. Is that correct? may be.\n        } else {\n          int memStoreDeltaSize =\n              (int) ((memstoreSize - globalMemStorePercent) * CONVERT_TO_PERCENTAGE);\n          int blockCacheDeltaSize =\n              (int) ((blockCacheSize - blockCachePercent) * CONVERT_TO_PERCENTAGE);\n          metricsHeapMemoryManager.updateMemStoreDeltaSizeHistogram(memStoreDeltaSize);\n          metricsHeapMemoryManager.updateBlockCacheDeltaSizeHistogram(blockCacheDeltaSize);\n          long newBlockCacheSize = (long) (maxHeapSize * blockCacheSize);\n          long newMemstoreSize = (long) (maxHeapSize * memstoreSize);\n          LOG.info(\"Setting block cache heap size to \" + newBlockCacheSize\n              + \" and memstore heap size to \" + newMemstoreSize);\n          blockCachePercent = blockCacheSize;\n          blockCache.setMaxSize(newBlockCacheSize);\n          globalMemStorePercent = memstoreSize;\n          memStoreFlusher.setGlobalMemstoreLimit(newMemstoreSize);\n        }\n      } else {\n        metricsHeapMemoryManager.increaseTunerDoNothingCounter();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No changes made by HeapMemoryTuner.\");\n        }\n      }\n    }","id":89015,"modified_method":"private void tune() {\n      // TODO check if we can increase the memory boundaries\n      // while remaining in the limits\n      long curEvictCount;\n      long curCacheMisCount;\n      curEvictCount = blockCache.getStats().getEvictedCount();\n      tunerContext.setEvictCount(curEvictCount - evictCount);\n      evictCount = curEvictCount;\n      curCacheMisCount = blockCache.getStats().getMissCachingCount();\n      tunerContext.setCacheMissCount(curCacheMisCount-cacheMissCount);\n      cacheMissCount = curCacheMisCount;\n      tunerContext.setBlockedFlushCount(blockedFlushCount.getAndSet(0));\n      tunerContext.setUnblockedFlushCount(unblockedFlushCount.getAndSet(0));\n      tunerContext.setCurBlockCacheUsed((float)blockCache.getCurrentSize() / maxHeapSize);\n      tunerContext.setCurMemStoreUsed(\n                 (float)regionServerAccounting.getGlobalMemstoreSize() / maxHeapSize);\n      tunerContext.setCurBlockCacheSize(blockCachePercent);\n      tunerContext.setCurMemStoreSize(globalMemStorePercent);\n      TunerResult result = null;\n      try {\n        result = this.heapMemTuner.tune(tunerContext);\n      } catch (Throwable t) {\n        LOG.error(\"Exception thrown from the HeapMemoryTuner implementation\", t);\n      }\n      if (result != null && result.needsTuning()) {\n        float memstoreSize = result.getMemstoreSize();\n        float blockCacheSize = result.getBlockCacheSize();\n        LOG.debug(\"From HeapMemoryTuner new memstoreSize: \" + memstoreSize\n            + \". new blockCacheSize: \" + blockCacheSize);\n        if (memstoreSize < globalMemStorePercentMinRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is below min level \"\n              + globalMemStorePercentMinRange + \". Resetting memstoreSize to min size\");\n          memstoreSize = globalMemStorePercentMinRange;\n        } else if (memstoreSize > globalMemStorePercentMaxRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is above max level \"\n              + globalMemStorePercentMaxRange + \". Resetting memstoreSize to max size\");\n          memstoreSize = globalMemStorePercentMaxRange;\n        }\n        if (blockCacheSize < blockCachePercentMinRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is below min level \" + blockCachePercentMinRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMinRange;\n        } else if (blockCacheSize > blockCachePercentMaxRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is above max level \" + blockCachePercentMaxRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMaxRange;\n        }\n        int gml = (int) (memstoreSize * CONVERT_TO_PERCENTAGE);\n        int bcul = (int) ((blockCacheSize + l2BlockCachePercent) * CONVERT_TO_PERCENTAGE);\n        if (CONVERT_TO_PERCENTAGE - (gml + bcul) < CLUSTER_MINIMUM_MEMORY_THRESHOLD) {\n          LOG.info(\"Current heap configuration from HeapMemoryTuner exceeds \"\n              + \"the threshold required for successful cluster operation. \"\n              + \"The combined value cannot exceed 0.8. \" + HeapMemorySizeUtil.MEMSTORE_SIZE_KEY\n              + \" is \" + memstoreSize + \" and \" + HFILE_BLOCK_CACHE_SIZE_KEY + \" is \"\n              + blockCacheSize);\n          // TODO can adjust the value so as not exceed 80%. Is that correct? may be.\n        } else {\n          long newBlockCacheSize = (long) (maxHeapSize * blockCacheSize);\n          long newMemstoreSize = (long) (maxHeapSize * memstoreSize);\n          LOG.info(\"Setting block cache heap size to \" + newBlockCacheSize\n              + \" and memstore heap size to \" + newMemstoreSize);\n          blockCachePercent = blockCacheSize;\n          blockCache.setMaxSize(newBlockCacheSize);\n          globalMemStorePercent = memstoreSize;\n          memStoreFlusher.setGlobalMemstoreLimit(newMemstoreSize);\n        }\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No changes made by HeapMemoryTuner.\");\n      }\n    }","commit_id":"eff38ccf8cf9c61f1bda1005bd19b58c960e3fd2","url":"https://github.com/apache/hbase"},{"original_method":"private void tune() {\n      // TODO check if we can increase the memory boundaries\n      // while remaining in the limits\n      long curEvictCount;\n      long curCacheMisCount;\n      curEvictCount = blockCache.getStats().getEvictedCount();\n      tunerContext.setEvictCount(curEvictCount - evictCount);\n      evictCount = curEvictCount;\n      curCacheMisCount = blockCache.getStats().getMissCachingCount();\n      tunerContext.setCacheMissCount(curCacheMisCount-cacheMissCount);\n      cacheMissCount = curCacheMisCount;\n      tunerContext.setBlockedFlushCount(blockedFlushCount.getAndSet(0));\n      tunerContext.setUnblockedFlushCount(unblockedFlushCount.getAndSet(0));\n      tunerContext.setCurBlockCacheUsed((float)blockCache.getCurrentSize() / maxHeapSize);\n      tunerContext.setCurMemStoreUsed(\n                 (float)regionServerAccounting.getGlobalMemstoreSize() / maxHeapSize);\n      tunerContext.setCurBlockCacheSize(blockCachePercent);\n      tunerContext.setCurMemStoreSize(globalMemStorePercent);\n      TunerResult result = null;\n      try {\n        result = this.heapMemTuner.tune(tunerContext);\n      } catch (Throwable t) {\n        LOG.error(\"Exception thrown from the HeapMemoryTuner implementation\", t);\n      }\n      if (result != null && result.needsTuning()) {\n        float memstoreSize = result.getMemstoreSize();\n        float blockCacheSize = result.getBlockCacheSize();\n        LOG.debug(\"From HeapMemoryTuner new memstoreSize: \" + memstoreSize\n            + \". new blockCacheSize: \" + blockCacheSize);\n        if (memstoreSize < globalMemStorePercentMinRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is below min level \"\n              + globalMemStorePercentMinRange + \". Resetting memstoreSize to min size\");\n          memstoreSize = globalMemStorePercentMinRange;\n        } else if (memstoreSize > globalMemStorePercentMaxRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is above max level \"\n              + globalMemStorePercentMaxRange + \". Resetting memstoreSize to max size\");\n          memstoreSize = globalMemStorePercentMaxRange;\n        }\n        if (blockCacheSize < blockCachePercentMinRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is below min level \" + blockCachePercentMinRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMinRange;\n        } else if (blockCacheSize > blockCachePercentMaxRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is above max level \" + blockCachePercentMaxRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMaxRange;\n        }\n        int gml = (int) (memstoreSize * CONVERT_TO_PERCENTAGE);\n        int bcul = (int) ((blockCacheSize + l2BlockCachePercent) * CONVERT_TO_PERCENTAGE);\n        if (CONVERT_TO_PERCENTAGE - (gml + bcul) < CLUSTER_MINIMUM_MEMORY_THRESHOLD) {\n          LOG.info(\"Current heap configuration from HeapMemoryTuner exceeds \"\n              + \"the threshold required for successful cluster operation. \"\n              + \"The combined value cannot exceed 0.8. \" + HeapMemorySizeUtil.MEMSTORE_SIZE_KEY\n              + \" is \" + memstoreSize + \" and \" + HFILE_BLOCK_CACHE_SIZE_KEY + \" is \"\n              + blockCacheSize);\n          // TODO can adjust the value so as not exceed 80%. Is that correct? may be.\n        } else {\n          long newBlockCacheSize = (long) (maxHeapSize * blockCacheSize);\n          long newMemstoreSize = (long) (maxHeapSize * memstoreSize);\n          LOG.info(\"Setting block cache heap size to \" + newBlockCacheSize\n              + \" and memstore heap size to \" + newMemstoreSize);\n          blockCachePercent = blockCacheSize;\n          blockCache.setMaxSize(newBlockCacheSize);\n          globalMemStorePercent = memstoreSize;\n          memStoreFlusher.setGlobalMemstoreLimit(newMemstoreSize);\n        }\n      } else if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No changes made by HeapMemoryTuner.\");\n      }\n    }","id":89016,"modified_method":"private void tune() {\n      // TODO check if we can increase the memory boundaries\n      // while remaining in the limits\n      long curEvictCount;\n      long curCacheMisCount;\n      long blockedFlushCnt;\n      long unblockedFlushCnt;\n      curEvictCount = blockCache.getStats().getEvictedCount();\n      tunerContext.setEvictCount(curEvictCount - evictCount);\n      evictCount = curEvictCount;\n      curCacheMisCount = blockCache.getStats().getMissCachingCount();\n      tunerContext.setCacheMissCount(curCacheMisCount-cacheMissCount);\n      cacheMissCount = curCacheMisCount;\n      blockedFlushCnt = blockedFlushCount.getAndSet(0);\n      tunerContext.setBlockedFlushCount(blockedFlushCnt);\n      metricsHeapMemoryManager.updateBlockedFlushCount(blockedFlushCnt);\n      unblockedFlushCnt = unblockedFlushCount.getAndSet(0);\n      tunerContext.setUnblockedFlushCount(unblockedFlushCnt);\n      metricsHeapMemoryManager.updateUnblockedFlushCount(unblockedFlushCnt);\n      tunerContext.setCurBlockCacheUsed((float) blockCache.getCurrentSize() / maxHeapSize);\n      metricsHeapMemoryManager.setCurBlockCacheSizeGauge(blockCache.getCurrentSize());\n      tunerContext.setCurMemStoreUsed((float)regionServerAccounting.getGlobalMemstoreSize() / maxHeapSize);\n      metricsHeapMemoryManager.setCurMemStoreSizeGauge(regionServerAccounting.getGlobalMemstoreSize());\n      tunerContext.setCurBlockCacheSize(blockCachePercent);\n      tunerContext.setCurMemStoreSize(globalMemStorePercent);\n      TunerResult result = null;\n      try {\n        result = this.heapMemTuner.tune(tunerContext);\n      } catch (Throwable t) {\n        LOG.error(\"Exception thrown from the HeapMemoryTuner implementation\", t);\n      }\n      if (result != null && result.needsTuning()) {\n        float memstoreSize = result.getMemstoreSize();\n        float blockCacheSize = result.getBlockCacheSize();\n        LOG.debug(\"From HeapMemoryTuner new memstoreSize: \" + memstoreSize\n            + \". new blockCacheSize: \" + blockCacheSize);\n        if (memstoreSize < globalMemStorePercentMinRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is below min level \"\n              + globalMemStorePercentMinRange + \". Resetting memstoreSize to min size\");\n          memstoreSize = globalMemStorePercentMinRange;\n        } else if (memstoreSize > globalMemStorePercentMaxRange) {\n          LOG.info(\"New memstoreSize from HeapMemoryTuner \" + memstoreSize + \" is above max level \"\n              + globalMemStorePercentMaxRange + \". Resetting memstoreSize to max size\");\n          memstoreSize = globalMemStorePercentMaxRange;\n        }\n        if (blockCacheSize < blockCachePercentMinRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is below min level \" + blockCachePercentMinRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMinRange;\n        } else if (blockCacheSize > blockCachePercentMaxRange) {\n          LOG.info(\"New blockCacheSize from HeapMemoryTuner \" + blockCacheSize\n              + \" is above max level \" + blockCachePercentMaxRange\n              + \". Resetting blockCacheSize to min size\");\n          blockCacheSize = blockCachePercentMaxRange;\n        }\n        int gml = (int) (memstoreSize * CONVERT_TO_PERCENTAGE);\n        int bcul = (int) ((blockCacheSize + l2BlockCachePercent) * CONVERT_TO_PERCENTAGE);\n        if (CONVERT_TO_PERCENTAGE - (gml + bcul) < CLUSTER_MINIMUM_MEMORY_THRESHOLD) {\n          LOG.info(\"Current heap configuration from HeapMemoryTuner exceeds \"\n              + \"the threshold required for successful cluster operation. \"\n              + \"The combined value cannot exceed 0.8. \" + HeapMemorySizeUtil.MEMSTORE_SIZE_KEY\n              + \" is \" + memstoreSize + \" and \" + HFILE_BLOCK_CACHE_SIZE_KEY + \" is \"\n              + blockCacheSize);\n          // TODO can adjust the value so as not exceed 80%. Is that correct? may be.\n        } else {\n          int memStoreDeltaSize =\n              (int) ((memstoreSize - globalMemStorePercent) * CONVERT_TO_PERCENTAGE);\n          int blockCacheDeltaSize =\n              (int) ((blockCacheSize - blockCachePercent) * CONVERT_TO_PERCENTAGE);\n          metricsHeapMemoryManager.updateMemStoreDeltaSizeHistogram(memStoreDeltaSize);\n          metricsHeapMemoryManager.updateBlockCacheDeltaSizeHistogram(blockCacheDeltaSize);\n          long newBlockCacheSize = (long) (maxHeapSize * blockCacheSize);\n          long newMemstoreSize = (long) (maxHeapSize * memstoreSize);\n          LOG.info(\"Setting block cache heap size to \" + newBlockCacheSize\n              + \" and memstore heap size to \" + newMemstoreSize);\n          blockCachePercent = blockCacheSize;\n          blockCache.setMaxSize(newBlockCacheSize);\n          globalMemStorePercent = memstoreSize;\n          memStoreFlusher.setGlobalMemstoreLimit(newMemstoreSize);\n        }\n      } else {\n        metricsHeapMemoryManager.increaseTunerDoNothingCounter();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No changes made by HeapMemoryTuner.\");\n        }\n      }\n    }","commit_id":"064271da16efd3e5d9d4787d778fa711b7f9f6ab","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    protected void chore() {\n      // Sample heap occupancy\n      MemoryUsage memUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n      heapOccupancyPercent = (float)memUsage.getUsed() / (float)memUsage.getCommitted();\n      // If we are above the heap occupancy alarm low watermark, switch to short\n      // sleeps for close monitoring. Stop autotuning, we are in a danger zone.\n      if (heapOccupancyPercent >= heapOccupancyLowWatermark) {\n        if (!alarming) {\n          LOG.warn(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is above heap occupancy alarm watermark (\" + heapOccupancyLowWatermark + \")\");\n          alarming = true;\n        }\n        triggerNow();\n        try {\n          // Need to sleep ourselves since we've told the chore's sleeper\n          // to skip the next sleep cycle.\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          // Interrupted, propagate\n          Thread.currentThread().interrupt();\n        }\n      } else {\n        if (alarming) {\n          LOG.info(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is now below the heap occupancy alarm watermark (\" +\n            heapOccupancyLowWatermark + \")\");\n          alarming = false;\n        }\n      }\n      // Autotune if tuning is enabled and allowed\n      if (tunerOn && !alarming) {\n        tune();\n      }\n    }","id":89017,"modified_method":"@Override\n    protected void chore() {\n      // Sample heap occupancy\n      MemoryUsage memUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();\n      heapOccupancyPercent = (float)memUsage.getUsed() / (float)memUsage.getCommitted();\n      // If we are above the heap occupancy alarm low watermark, switch to short\n      // sleeps for close monitoring. Stop autotuning, we are in a danger zone.\n      if (heapOccupancyPercent >= heapOccupancyLowWatermark) {\n        if (!alarming) {\n          LOG.warn(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is above heap occupancy alarm watermark (\" + heapOccupancyLowWatermark + \")\");\n          alarming = true;\n        }\n        metricsHeapMemoryManager.increaseAboveHeapOccupancyLowWatermarkCounter();\n        triggerNow();\n        try {\n          // Need to sleep ourselves since we've told the chore's sleeper\n          // to skip the next sleep cycle.\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          // Interrupted, propagate\n          Thread.currentThread().interrupt();\n        }\n      } else {\n        if (alarming) {\n          LOG.info(\"heapOccupancyPercent \" + heapOccupancyPercent +\n            \" is now below the heap occupancy alarm watermark (\" +\n            heapOccupancyLowWatermark + \")\");\n          alarming = false;\n        }\n      }\n      // Autotune if tuning is enabled and allowed\n      if (tunerOn && !alarming) {\n        tune();\n      }\n    }","commit_id":"064271da16efd3e5d9d4787d778fa711b7f9f6ab","url":"https://github.com/apache/hbase"},{"original_method":"@VisibleForTesting\n  HeapMemoryManager(ResizableBlockCache blockCache, FlushRequester memStoreFlusher,\n                Server server, RegionServerAccounting regionServerAccounting) {\n    Configuration conf = server.getConfiguration();\n    this.blockCache = blockCache;\n    this.memStoreFlusher = memStoreFlusher;\n    this.server = server;\n    this.regionServerAccounting = regionServerAccounting;\n    this.tunerOn = doInit(conf);\n    this.defaultChorePeriod = conf.getInt(HBASE_RS_HEAP_MEMORY_TUNER_PERIOD,\n      HBASE_RS_HEAP_MEMORY_TUNER_DEFAULT_PERIOD);\n    this.heapOccupancyLowWatermark = conf.getFloat(HConstants.HEAP_OCCUPANCY_LOW_WATERMARK_KEY,\n      HConstants.DEFAULT_HEAP_OCCUPANCY_LOW_WATERMARK);\n  }","id":89018,"modified_method":"@VisibleForTesting\n  HeapMemoryManager(ResizableBlockCache blockCache, FlushRequester memStoreFlusher,\n                Server server, RegionServerAccounting regionServerAccounting) {\n    Configuration conf = server.getConfiguration();\n    this.blockCache = blockCache;\n    this.memStoreFlusher = memStoreFlusher;\n    this.server = server;\n    this.regionServerAccounting = regionServerAccounting;\n    this.tunerOn = doInit(conf);\n    this.defaultChorePeriod = conf.getInt(HBASE_RS_HEAP_MEMORY_TUNER_PERIOD,\n      HBASE_RS_HEAP_MEMORY_TUNER_DEFAULT_PERIOD);\n    this.heapOccupancyLowWatermark = conf.getFloat(HConstants.HEAP_OCCUPANCY_LOW_WATERMARK_KEY,\n      HConstants.DEFAULT_HEAP_OCCUPANCY_LOW_WATERMARK);\n    metricsHeapMemoryManager = new MetricsHeapMemoryManager();\n  }","commit_id":"064271da16efd3e5d9d4787d778fa711b7f9f6ab","url":"https://github.com/apache/hbase"},{"original_method":"public boolean isMatch(\n\t\tHttpServletRequest request, Dispatcher dispatcher, String uri) {\n\n\t\tif (!isMatchDispatcher(dispatcher)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean matchURLPattern = false;\n\n\t\tfor (String urlPattern : _urlPatterns) {\n\t\t\tif (isMatchURLPattern(uri, urlPattern)) {\n\t\t\t\tmatchURLPattern = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (matchURLPattern) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" has a pattern match with \" + uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() +\n\t\t\t\t\t\t\" does not have a pattern match with \" + uri);\n\t\t\t}\n\t\t}\n\n\t\tif (!matchURLPattern) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isMatchURLRegexPattern(request)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":89019,"modified_method":"public boolean isMatch(\n\t\tHttpServletRequest request, Dispatcher dispatcher, String uri) {\n\n\t\tif (!isMatchDispatcher(dispatcher)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean matchURLPattern = false;\n\n\t\tfor (String urlPattern : _urlPatterns) {\n\t\t\tif (isMatchURLPattern(uri, urlPattern)) {\n\t\t\t\tmatchURLPattern = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (matchURLPattern) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" has a pattern match with \" + uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() +\n\t\t\t\t\t\t\" does not have a pattern match with \" + uri);\n\t\t\t}\n\t\t}\n\n\t\tif (!matchURLPattern) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isMatchURLRegexPattern(request, uri)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"704beaa34af481a2b8cfc297d166f67ca5cdd075","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isMatchURLRegexPattern(HttpServletRequest request) {\n\t\tString requestPath = ThemeHelper.getRequestPath(request);\n\n\t\tif (Validator.isNull(requestPath)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((_urlRegexPattern == null) && (_urlRegexIgnorePattern == null)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (Validator.isNotNull(queryString)) {\n\t\t\trequestPath = requestPath.concat(StringPool.QUESTION).concat(\n\t\t\t\tqueryString);\n\t\t}\n\n\t\tboolean matchURLRegexPattern = true;\n\n\t\tif (_urlRegexPattern != null) {\n\t\t\tMatcher matcher = _urlRegexPattern.matcher(requestPath);\n\n\t\t\tmatchURLRegexPattern = matcher.find();\n\t\t}\n\n\t\tif (matchURLRegexPattern && (_urlRegexIgnorePattern != null)) {\n\t\t\tMatcher matcher = _urlRegexIgnorePattern.matcher(requestPath);\n\n\t\t\tmatchURLRegexPattern = !matcher.find();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (matchURLRegexPattern) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" has a regex match with \" +\n\t\t\t\t\t\trequestPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" does not have a regex match with \" +\n\t\t\t\t\t\trequestPath);\n\t\t\t}\n\t\t}\n\n\t\treturn matchURLRegexPattern;\n\t}","id":89020,"modified_method":"protected boolean isMatchURLRegexPattern(\n\t\tHttpServletRequest request, String uri) {\n\n\t\tString url = uri;\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (Validator.isNotNull(queryString)) {\n\t\t\turl = url.concat(StringPool.QUESTION).concat(queryString);\n\t\t}\n\n\t\tboolean matchURLRegexPattern = true;\n\n\t\tif (_urlRegexPattern != null) {\n\t\t\tMatcher matcher = _urlRegexPattern.matcher(url);\n\n\t\t\tmatchURLRegexPattern = matcher.find();\n\t\t}\n\n\t\tif (matchURLRegexPattern && (_urlRegexIgnorePattern != null)) {\n\t\t\tMatcher matcher = _urlRegexIgnorePattern.matcher(url);\n\n\t\t\tmatchURLRegexPattern = !matcher.find();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (matchURLRegexPattern) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" has a regex match with \" + url);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" does not have a regex match with \" +\n\t\t\t\t\t\turl);\n\t\t\t}\n\t\t}\n\n\t\treturn matchURLRegexPattern;\n\t}","commit_id":"704beaa34af481a2b8cfc297d166f67ca5cdd075","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doFilter(\n\t\t\tServletRequest servletRequest, ServletResponse servletResponse,\n\t\t\tFilterChain filterChain)\n\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest request = (HttpServletRequest)servletRequest;\n\n\t\tDispatcher dispatcher = Dispatcher.REQUEST;\n\t\tString uri = request.getRequestURI();\n\n\t\tString errorRequestURI = (String)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_SERVLET_ERROR_REQUEST_URI);\n\t\tString forwardRequestURI = (String)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_SERVLET_FORWARD_REQUEST_URI);\n\t\tString includeRequestURI = (String)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_SERVLET_INCLUDE_REQUEST_URI);\n\n\t\tif (Validator.isNotNull(errorRequestURI)) {\n\t\t\tdispatcher = Dispatcher.ERROR;\n\t\t\turi = errorRequestURI;\n\t\t}\n\t\telse if (Validator.isNotNull(forwardRequestURI)) {\n\t\t\tdispatcher = Dispatcher.FORWARD;\n\t\t}\n\t\telse if (Validator.isNotNull(includeRequestURI)) {\n\t\t\tdispatcher = Dispatcher.INCLUDE;\n\t\t\turi = includeRequestURI;\n\t\t}\n\n\t\tInvokerFilterChain invokerFilterChain = new InvokerFilterChain(\n\t\t\tfilterChain);\n\n\t\tfor (FilterMapping filterMapping : _filterMappings) {\n\t\t\tif (filterMapping.isMatch(request, dispatcher, uri)) {\n\t\t\t\tFilter filter = filterMapping.getFilter();\n\n\t\t\t\tinvokerFilterChain.addFilter(filter);\n\t\t\t}\n\t\t}\n\n\t\tinvokerFilterChain.doFilter(servletRequest, servletResponse);\n\t}","id":89021,"modified_method":"public void doFilter(\n\t\t\tServletRequest servletRequest, ServletResponse servletResponse,\n\t\t\tFilterChain filterChain)\n\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest request = (HttpServletRequest)servletRequest;\n\n\t\tDispatcher dispatcher = Dispatcher.REQUEST;\n\t\tString uri = request.getRequestURI();\n\n\t\tString errorRequestURI = (String)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_SERVLET_ERROR_REQUEST_URI);\n\t\tString forwardRequestURI = (String)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_SERVLET_FORWARD_REQUEST_URI);\n\t\tString includeRequestURI = (String)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_SERVLET_INCLUDE_REQUEST_URI);\n\n\t\tif (Validator.isNotNull(errorRequestURI)) {\n\t\t\tdispatcher = Dispatcher.ERROR;\n\t\t\turi = errorRequestURI;\n\t\t}\n\t\telse if (Validator.isNotNull(forwardRequestURI)) {\n\t\t\tdispatcher = Dispatcher.FORWARD;\n\t\t}\n\t\telse if (Validator.isNotNull(includeRequestURI)) {\n\t\t\tdispatcher = Dispatcher.INCLUDE;\n\t\t\turi = includeRequestURI;\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.INVOKER_FILTER_URI, uri);\n\n\t\tInvokerFilterChain invokerFilterChain = new InvokerFilterChain(\n\t\t\tfilterChain);\n\n\t\tfor (FilterMapping filterMapping : _filterMappings) {\n\t\t\tif (filterMapping.isMatch(request, dispatcher, uri)) {\n\t\t\t\tFilter filter = filterMapping.getFilter();\n\n\t\t\t\tinvokerFilterChain.addFilter(filter);\n\t\t\t}\n\t\t}\n\n\t\tinvokerFilterChain.doFilter(servletRequest, servletResponse);\n\t}","commit_id":"704beaa34af481a2b8cfc297d166f67ca5cdd075","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tFilterConfig filterConfig = getFilterConfig();\n\n\t\tServletContext servletContext = filterConfig.getServletContext();\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\tservletContext.getRequestDispatcher(\n\t\t\t\t\"/WEB-INF/jsp/_servlet_context_include.jsp\");\n\n\t\tString requestPath = ThemeHelper.getRequestPath(\n\t\t\tservletContext, request);\n\n\t\tTheme theme = (Theme)request.getAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME);\n\n\t\tif (!ThemeHelper.resourceExists(servletContext, theme, requestPath)) {\n\t\t\treturn;\n\t\t}\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH, requestPath);\n\n\t\trequest.setAttribute(WebKeys.THEME, theme);\n\n\t\trequestDispatcher.include(request, response);\n\t}","id":89022,"modified_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tTheme theme = (Theme)request.getAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME);\n\n\t\trequest.setAttribute(WebKeys.THEME, theme);\n\n\t\tFilterConfig filterConfig = getFilterConfig();\n\n\t\tServletContext servletContext = filterConfig.getServletContext();\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\tservletContext.getRequestDispatcher(\n\t\t\t\t\"/WEB-INF/jsp/_servlet_context_include.jsp\");\n\n\t\trequestDispatcher.include(request, response);\n\t}","commit_id":"704beaa34af481a2b8cfc297d166f67ca5cdd075","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isFilterEnabled(\n\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\ttry {\n\t\t\tString requestPath = ThemeHelper.getRequestPath(\n\t\t\t\tgetFilterConfig().getServletContext(), request);\n\n\t\t\tif (!requestPath.endsWith(\".jsp\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tString servletContextIncludePath = (String)request.getAttribute(\n\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH);\n\n\t\t\tif ((servletContextIncludePath != null) &&\n\t\t\t\tservletContextIncludePath.equals(requestPath)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tTheme theme = (Theme)request.getAttribute(\n\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME);\n\n\t\t\tif (theme == null) {\n\t\t\t\ttheme = getTheme(request);\n\t\t\t}\n\n\t\t\tboolean resourceExists = ThemeHelper.resourceExists(\n\t\t\t\tgetFilterConfig().getServletContext(), theme, requestPath);\n\n\t\t\tif ((theme != null) && resourceExists) {\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME, theme);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn false;\n\t}","id":89023,"modified_method":"public boolean isFilterEnabled(\n\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\ttry {\n\t\t\tTheme theme = getTheme(request);\n\n\t\t\tif (theme == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tFilterConfig filterConfig = getFilterConfig();\n\n\t\t\tServletContext servletContext = filterConfig.getServletContext();\n\n\t\t\tString uri = (String)request.getAttribute(\n\t\t\t\tWebKeys.INVOKER_FILTER_URI);\n\n\t\t\tif (ThemeHelper.resourceExists(servletContext, theme, uri)) {\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME, theme);\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH, uri);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"704beaa34af481a2b8cfc297d166f67ca5cdd075","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isMatchURLRegexPattern(HttpServletRequest request) {\n\t\tStringBuffer requestURL = request.getRequestURL();\n\n\t\tif (requestURL == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((_urlRegexPattern == null) && (_urlRegexIgnorePattern == null)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString url = requestURL.toString();\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (Validator.isNotNull(queryString)) {\n\t\t\turl = url.concat(StringPool.QUESTION).concat(queryString);\n\t\t}\n\n\t\tboolean matchURLRegexPattern = true;\n\n\t\tif (_urlRegexPattern != null) {\n\t\t\tMatcher matcher = _urlRegexPattern.matcher(url);\n\n\t\t\tmatchURLRegexPattern = matcher.find();\n\t\t}\n\n\t\tif (matchURLRegexPattern && (_urlRegexIgnorePattern != null)) {\n\t\t\tMatcher matcher = _urlRegexIgnorePattern.matcher(url);\n\n\t\t\tmatchURLRegexPattern = !matcher.find();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (matchURLRegexPattern) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" has a regex match with \" + url);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" does not have a regex match with \" +\n\t\t\t\t\t\turl);\n\t\t\t}\n\t\t}\n\n\t\treturn matchURLRegexPattern;\n\t}","id":89024,"modified_method":"protected boolean isMatchURLRegexPattern(HttpServletRequest request) {\n\t\tString requestPath = ThemeHelper.getRequestPath(request);\n\n\t\tif (Validator.isNull(requestPath)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((_urlRegexPattern == null) && (_urlRegexIgnorePattern == null)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString queryString = request.getQueryString();\n\n\t\tif (Validator.isNotNull(queryString)) {\n\t\t\trequestPath = requestPath.concat(StringPool.QUESTION).concat(\n\t\t\t\tqueryString);\n\t\t}\n\n\t\tboolean matchURLRegexPattern = true;\n\n\t\tif (_urlRegexPattern != null) {\n\t\t\tMatcher matcher = _urlRegexPattern.matcher(requestPath);\n\n\t\t\tmatchURLRegexPattern = matcher.find();\n\t\t}\n\n\t\tif (matchURLRegexPattern && (_urlRegexIgnorePattern != null)) {\n\t\t\tMatcher matcher = _urlRegexIgnorePattern.matcher(requestPath);\n\n\t\t\tmatchURLRegexPattern = !matcher.find();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (matchURLRegexPattern) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" has a regex match with \" +\n\t\t\t\t\t\trequestPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\n\t\t\t\t\t_filter.getClass() + \" does not have a regex match with \" +\n\t\t\t\t\t\trequestPath);\n\t\t\t}\n\t\t}\n\n\t\treturn matchURLRegexPattern;\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tServletContext servletContext = getServletContext();\n\t\t\tHttpServletRequest request = getServletRequest();\n\t\t\tHttpServletResponse response = getServletResponse();\n\n\t\t\tString page = getCustomPage(servletContext, request);\n\n\t\t\tif (Validator.isNull(page)) {\n\t\t\t\tpage = getPage();\n\t\t\t}\n\n\t\t\tif (Validator.isNull(page)) {\n\t\t\t\tpage = getEndPage();\n\t\t\t}\n\n\t\t\tcallSetAttributes();\n\n\t\t\tTheme theme = (Theme)request.getAttribute(WebKeys.THEME);\n\n\t\t\tif (_log.isDebugEnabled() && Validator.isNotNull(page)) {\n\t\t\t\tString resourcePath = ThemeUtil.getResourcePath(\n\t\t\t\t\tservletContext, theme, page);\n\n\t\t\t\t_log.debug(resourcePath);\n\t\t\t}\n\n\t\t\tif (ThemeUtil.resourceExists(servletContext, theme, page)) {\n\t\t\t\tThemeUtil.include(\n\t\t\t\t\tservletContext, request, response, pageContext,\n\t\t\t\t\tpage, theme);\n\n\t\t\t\treturn EVAL_PAGE;\n\t\t\t}\n\t\t\telse if (!FileAvailabilityUtil.isAvailable(servletContext, page)) {\n\t\t\t\treturn processEndTag();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_doInclude(page);\n\n\t\t\t\treturn EVAL_PAGE;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\t_dynamicAttributes.clear();\n\n\t\t\tclearParams();\n\t\t\tclearProperties();\n\n\t\t\tcleanUpSetAttributes();\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\tsetPage(null);\n\n\t\t\t\tcleanUp();\n\t\t\t}\n\t\t}\n\t}","id":89025,"modified_method":"public int doEndTag() throws JspException {\n\t\ttry {\n\t\t\tServletContext servletContext = getServletContext();\n\t\t\tHttpServletRequest request = getServletRequest();\n\t\t\tHttpServletResponse response = getServletResponse();\n\n\t\t\tString page = getCustomPage(servletContext, request);\n\n\t\t\tif (Validator.isNull(page)) {\n\t\t\t\tpage = getPage();\n\t\t\t}\n\n\t\t\tif (Validator.isNull(page)) {\n\t\t\t\tpage = getEndPage();\n\t\t\t}\n\n\t\t\tcallSetAttributes();\n\n\t\t\tTheme theme = (Theme)request.getAttribute(WebKeys.THEME);\n\n\t\t\tif (_log.isDebugEnabled() && Validator.isNotNull(page)) {\n\t\t\t\tString resourcePath = ThemeHelper.getResourcePath(\n\t\t\t\t\tservletContext, theme, page);\n\n\t\t\t\t_log.debug(resourcePath);\n\t\t\t}\n\n\t\t\tif (ThemeHelper.resourceExists(servletContext, theme, page)) {\n\t\t\t\tThemeUtil.include(\n\t\t\t\t\tservletContext, request, response, pageContext,\n\t\t\t\t\tpage, theme);\n\n\t\t\t\treturn EVAL_PAGE;\n\t\t\t}\n\t\t\telse if (!FileAvailabilityUtil.isAvailable(servletContext, page)) {\n\t\t\t\treturn processEndTag();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_doInclude(page);\n\n\t\t\t\treturn EVAL_PAGE;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\t_dynamicAttributes.clear();\n\n\t\t\tclearParams();\n\t\t\tclearProperties();\n\n\t\t\tcleanUpSetAttributes();\n\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\tsetPage(null);\n\n\t\t\t\tcleanUp();\n\t\t\t}\n\t\t}\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tServletContext servletContext = getServletContext();\n\t\t\tHttpServletRequest request = getServletRequest();\n\t\t\tHttpServletResponse response = getServletResponse();\n\n\t\t\tString page = getStartPage();\n\n\t\t\tcallSetAttributes();\n\n\t\t\tTheme theme = (Theme)request.getAttribute(WebKeys.THEME);\n\n\t\t\tif (_log.isDebugEnabled() && Validator.isNotNull(page)) {\n\t\t\t\t_log.debug(\n\t\t\t\t\tThemeUtil.getResourcePath(servletContext, theme, page));\n\t\t\t}\n\n\t\t\tif (ThemeUtil.resourceExists(servletContext, theme, page)) {\n\t\t\t\tThemeUtil.include(\n\t\t\t\t\tservletContext, request, response, pageContext, page,\n\t\t\t\t\ttheme);\n\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\t\t\telse if (!FileAvailabilityUtil.isAvailable(servletContext, page)) {\n\t\t\t\treturn processStartTag();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_doInclude(page);\n\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t}","id":89026,"modified_method":"public int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tServletContext servletContext = getServletContext();\n\t\t\tHttpServletRequest request = getServletRequest();\n\t\t\tHttpServletResponse response = getServletResponse();\n\n\t\t\tString page = getStartPage();\n\n\t\t\tcallSetAttributes();\n\n\t\t\tTheme theme = (Theme)request.getAttribute(WebKeys.THEME);\n\n\t\t\tif (_log.isDebugEnabled() && Validator.isNotNull(page)) {\n\t\t\t\t_log.debug(\n\t\t\t\t\tThemeHelper.getResourcePath(servletContext, theme, page));\n\t\t\t}\n\n\t\t\tif (ThemeHelper.resourceExists(servletContext, theme, page)) {\n\t\t\t\tThemeUtil.include(\n\t\t\t\t\tservletContext, request, response, pageContext, page,\n\t\t\t\t\ttheme);\n\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\t\t\telse if (!FileAvailabilityUtil.isAvailable(servletContext, page)) {\n\t\t\t\treturn processStartTag();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_doInclude(page);\n\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void include(\n\t\t\tString path, PortletRequest portletRequest,\n\t\t\tPortletResponse portletResponse, String lifecycle)\n\t\tthrows IOException, PortletException {\n\n\t\tcheckJSPPath(path);\n\n\t\tPortletContext portletContext = getPortletContext();\n\n\t\tPortletRequestDispatcher portletRequestDispatcher = null;\n\n\t\tif (path.endsWith(\".jsp\")) {\n\t\t\tportletRequest.setAttribute(\n\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH, path);\n\n\t\t\tportletRequestDispatcher = portletContext.getRequestDispatcher(\n\t\t\t\t\"/WEB-INF/jsp/_servlet_context_include.jsp\");\n\t\t}\n\t\telse {\n\t\t\tportletRequestDispatcher = portletContext.getRequestDispatcher(\n\t\t\t\tpath);\n\t\t}\n\n\t\tif (portletRequestDispatcher == null) {\n\t\t\t_log.error(path + \" is not a valid include\");\n\t\t}\n\t\telse {\n\t\t\tportletRequestDispatcher.include(portletRequest, portletResponse);\n\t\t}\n\n\t\tif (clearRequestParameters) {\n\t\t\tif (lifecycle.equals(PortletRequest.RENDER_PHASE)) {\n\t\t\t\tportletResponse.setProperty(\"clear-request-parameters\", \"true\");\n\t\t\t}\n\t\t}\n\t}","id":89027,"modified_method":"protected void include(\n\t\t\tString path, PortletRequest portletRequest,\n\t\t\tPortletResponse portletResponse, String lifecycle)\n\t\tthrows IOException, PortletException {\n\n\t\tcheckJSPPath(path);\n\n\t\tPortletContext portletContext = getPortletContext();\n\n\t\tPortletRequestDispatcher portletRequestDispatcher =\n\t\t\tportletContext.getRequestDispatcher(path);\n\n\t\tif (portletRequestDispatcher == null) {\n\t\t\t_log.error(path + \" is not a valid include\");\n\t\t}\n\t\telse {\n\t\t\tportletRequestDispatcher.include(portletRequest, portletResponse);\n\t\t}\n\n\t\tif (clearRequestParameters) {\n\t\t\tif (lifecycle.equals(PortletRequest.RENDER_PHASE)) {\n\t\t\t\tportletResponse.setProperty(\"clear-request-parameters\", \"true\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isFilterEnabled(\n\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\ttry {\n\t\t\tif (request.getAttribute(\n\t\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME) != null) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tTheme theme = getTheme(request);\n\n\t\t\tif (theme != null) {\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME, theme);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn false;\n\t}","id":89028,"modified_method":"public boolean isFilterEnabled(\n\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\ttry {\n\t\t\tString requestPath = ThemeHelper.getRequestPath(\n\t\t\t\tgetFilterConfig().getServletContext(), request);\n\n\t\t\tString servletContextIncludePath = (String)request.getAttribute(\n\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH);\n\n\t\t\tif ((servletContextIncludePath != null) &&\n\t\t\t\tservletContextIncludePath.equals(requestPath)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tTheme theme = (Theme)request.getAttribute(\n\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME);\n\n\t\t\tif (theme == null) {\n\t\t\t\ttheme = getTheme(request);\n\t\t\t}\n\n\t\t\tif (!ThemeHelper.resourceExists(\n\t\t\t\t\tgetFilterConfig().getServletContext(),\n\t\t\t\t\ttheme, requestPath)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (theme != null) {\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME, theme);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tFilterConfig filterConfig = getFilterConfig();\n\n\t\tServletContext servletContext = filterConfig.getServletContext();\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\tservletContext.getRequestDispatcher(\n\t\t\t\t\"/WEB-INF/jsp/_servlet_context_include.jsp\");\n\n\t\tString path = request.getRequestURI();\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH, path);\n\n\t\tTheme theme = (Theme)request.getAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME);\n\n\t\trequest.setAttribute(WebKeys.THEME, theme);\n\n\t\trequestDispatcher.include(request, response);\n\t}","id":89029,"modified_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tFilterConfig filterConfig = getFilterConfig();\n\n\t\tServletContext servletContext = filterConfig.getServletContext();\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\tservletContext.getRequestDispatcher(\n\t\t\t\t\"/WEB-INF/jsp/_servlet_context_include.jsp\");\n\n\t\tString requestPath = ThemeHelper.getRequestPath(\n\t\t\tservletContext, request);\n\n\t\tTheme theme = (Theme)request.getAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_THEME);\n\n\t\tif (!ThemeHelper.resourceExists(servletContext, theme, requestPath)) {\n\t\t\treturn;\n\t\t}\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.SERVLET_CONTEXT_INCLUDE_FILTER_PATH, requestPath);\n\n\t\trequest.setAttribute(WebKeys.THEME, theme);\n\n\t\trequestDispatcher.include(request, response);\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String includeFTL(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String path, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the FreeMarker template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString resourcePath = getResourcePath(servletContext, theme, path);\n\n\t\tif (!FreeMarkerEngineUtil.resourceExists(resourcePath)) {\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tFreeMarkerContext freeMarkerContext =\n\t\t\tFreeMarkerEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// FreeMarker variables\n\n\t\tFreeMarkerVariablesUtil.insertVariables(freeMarkerContext, request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\tfreeMarkerContext.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\n\t\t\t// Wrapping is needed because of a bug in FreeMarker\n\n\t\t\twriter = new UnsyncPrintWriter(pageContext.getOut());\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tfreeMarkerContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tfreeMarkerContext.put(\"theme\", velocityTaglib);\n\n\t\t// Portal JSP tag library factory\n\n\t\tTaglibFactory portalTaglib = new TaglibFactory(servletContext);\n\n\t\tfreeMarkerContext.put(\"PortalJspTagLibs\", portalTaglib);\n\n\t\t// Theme JSP tag library factory\n\n\t\tTaglibFactory themeTaglib = new TaglibFactory(themeServletContext);\n\n\t\tfreeMarkerContext.put(\"ThemeJspTaglibs\", themeTaglib);\n\n\t\t// FreeMarker JSP tag library support\n\n\t\tServletContextHashModel servletContextHashModel =\n\t\t\tnew ServletContextHashModel(\n\t\t\t\t(GenericServlet)pageContext.getPage(),\n\t\t\t\tObjectWrapper.DEFAULT_WRAPPER);\n\n\t\tfreeMarkerContext.put(\"Application\", servletContextHashModel);\n\n\t\tHttpRequestHashModel httpRequestHashModel = new HttpRequestHashModel(\n\t\t\trequest, response, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\tfreeMarkerContext.put(\"Request\", httpRequestHashModel);\n\n\t\t// Merge templates\n\n\t\tFreeMarkerEngineUtil.mergeTemplate(\n\t\t\tresourcePath, freeMarkerContext, writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn ((UnsyncStringWriter)writer).toString();\n\t\t}\n\t}","id":89030,"modified_method":"public static String includeFTL(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String path, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the FreeMarker template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString resourcePath = ThemeHelper.getResourcePath(\n\t\t\tservletContext, theme, path);\n\n\t\tif (!FreeMarkerEngineUtil.resourceExists(resourcePath)) {\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tFreeMarkerContext freeMarkerContext =\n\t\t\tFreeMarkerEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// FreeMarker variables\n\n\t\tFreeMarkerVariablesUtil.insertVariables(freeMarkerContext, request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\tfreeMarkerContext.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\n\t\t\t// Wrapping is needed because of a bug in FreeMarker\n\n\t\t\twriter = new UnsyncPrintWriter(pageContext.getOut());\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tfreeMarkerContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tfreeMarkerContext.put(\"theme\", velocityTaglib);\n\n\t\t// Portal JSP tag library factory\n\n\t\tTaglibFactory portalTaglib = new TaglibFactory(servletContext);\n\n\t\tfreeMarkerContext.put(\"PortalJspTagLibs\", portalTaglib);\n\n\t\t// Theme JSP tag library factory\n\n\t\tTaglibFactory themeTaglib = new TaglibFactory(themeServletContext);\n\n\t\tfreeMarkerContext.put(\"ThemeJspTaglibs\", themeTaglib);\n\n\t\t// FreeMarker JSP tag library support\n\n\t\tServletContextHashModel servletContextHashModel =\n\t\t\tnew ServletContextHashModel(\n\t\t\t\t(GenericServlet)pageContext.getPage(),\n\t\t\t\tObjectWrapper.DEFAULT_WRAPPER);\n\n\t\tfreeMarkerContext.put(\"Application\", servletContextHashModel);\n\n\t\tHttpRequestHashModel httpRequestHashModel = new HttpRequestHashModel(\n\t\t\trequest, response, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\tfreeMarkerContext.put(\"Request\", httpRequestHashModel);\n\n\t\t// Merge templates\n\n\t\tFreeMarkerEngineUtil.mergeTemplate(\n\t\t\tresourcePath, freeMarkerContext, writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn ((UnsyncStringWriter)writer).toString();\n\t\t}\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String includeVM(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the Velocity template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString resourcePath = getResourcePath(servletContext, theme, page);\n\n\t\tif (!VelocityEngineUtil.resourceExists(resourcePath)) {\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tVelocityContext velocityContext =\n\t\t\tVelocityEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// Velocity variables\n\n\t\tVelocityVariablesUtil.insertVariables(velocityContext, request);\n\n\t\t// Page context\n\n\t\tvelocityContext.put(\"pageContext\", pageContext);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\tvelocityContext.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\t\t\twriter = pageContext.getOut();\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tvelocityContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tvelocityContext.put(\"theme\", velocityTaglib);\n\t\tvelocityContext.put(\"writer\", writer);\n\n\t\t// Merge templates\n\n\t\tVelocityEngineUtil.mergeTemplate(resourcePath, velocityContext, writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn ((UnsyncStringWriter)writer).toString();\n\t\t}\n\t}","id":89031,"modified_method":"public static String includeVM(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the Velocity template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString resourcePath = ThemeHelper.getResourcePath(\n\t\t\tservletContext, theme, page);\n\n\t\tif (!VelocityEngineUtil.resourceExists(resourcePath)) {\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tVelocityContext velocityContext =\n\t\t\tVelocityEngineUtil.getWrappedStandardToolsContext();\n\n\t\t// Velocity variables\n\n\t\tVelocityVariablesUtil.insertVariables(velocityContext, request);\n\n\t\t// Page context\n\n\t\tvelocityContext.put(\"pageContext\", pageContext);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\tvelocityContext.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\t\t\twriter = pageContext.getOut();\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext);\n\n\t\trequest.setAttribute(WebKeys.VELOCITY_TAGLIB, velocityTaglib);\n\n\t\tvelocityContext.put(\"taglibLiferay\", velocityTaglib);\n\t\tvelocityContext.put(\"theme\", velocityTaglib);\n\t\tvelocityContext.put(\"writer\", writer);\n\n\t\t// Merge templates\n\n\t\tVelocityEngineUtil.mergeTemplate(resourcePath, velocityContext, writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn ((UnsyncStringWriter)writer).toString();\n\t\t}\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void include(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tHttpServletResponse response, PageContext pageContext, String page,\n\t\t\tTheme theme)\n\t\tthrows Exception {\n\n\t\tString extension = theme.getTemplateExtension();\n\n\t\tif (extension.equals(_TEMPLATE_EXTENSION_FTL)) {\n\t\t\tincludeFTL(servletContext, request, pageContext, page, theme, true);\n\t\t}\n\t\telse if (extension.equals(_TEMPLATE_EXTENSION_VM)) {\n\t\t\tincludeVM(servletContext, request, pageContext, page, theme, true);\n\t\t}\n\t\telse {\n\t\t\tString path =\n\t\t\t\ttheme.getTemplatesPath() + StringPool.SLASH + page;\n\n\t\t\tincludeJSP(servletContext, request, response, path, theme);\n\t\t}\n\t}","id":89032,"modified_method":"public static void include(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tHttpServletResponse response, PageContext pageContext, String page,\n\t\t\tTheme theme)\n\t\tthrows Exception {\n\n\t\tString extension = theme.getTemplateExtension();\n\n\t\tif (extension.equals(ThemeHelper.TEMPLATE_EXTENSION_FTL)) {\n\t\t\tincludeFTL(servletContext, request, pageContext, page, theme, true);\n\t\t}\n\t\telse if (extension.equals(ThemeHelper.TEMPLATE_EXTENSION_VM)) {\n\t\t\tincludeVM(servletContext, request, pageContext, page, theme, true);\n\t\t}\n\t\telse {\n\t\t\tString path =\n\t\t\t\ttheme.getTemplatesPath() + StringPool.SLASH + page;\n\n\t\t\tincludeJSP(servletContext, request, response, path, theme);\n\t\t}\n\t}","commit_id":"322ff9fc18815177676713ccda2fb0cd12ebe38c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void makeConsistent() {\n    for (SNode conceptDeclaration : myDependencies.keySet()) {\n      if (conceptDeclaration == null) {\n        continue;\n      }\n      Set<IDependency_Runtime> rules = myDependencies.get(conceptDeclaration);\n      if (rules == null) continue;\n      if (!(SNodeUtil.isInstanceOfConceptDeclaration(conceptDeclaration))) continue;\n      SNode parent = SNodeUtil.getConceptDeclaration_Extends(conceptDeclaration);\n      while (parent != null) {\n        Set<IDependency_Runtime> parentRules = myDependencies.get(parent);\n        if (parentRules != null) {\n          rules.addAll(parentRules);\n        }\n        parent = SNodeUtil.getConceptDeclaration_Extends(parent);\n      }\n    }\n  }","id":89033,"modified_method":"public void makeConsistent() {\n    for (String conceptDeclaration : myDependencies.keySet()) {\n      if (conceptDeclaration == null) {\n        continue;\n      }\n      Set<IDependency_Runtime> rules = myDependencies.get(conceptDeclaration);\n      if (rules == null) continue;\n      if (isInterfaceConcept(conceptDeclaration)) continue;\n      String parent = getSuperConcept(conceptDeclaration);\n      while (parent != null) {\n        Set<IDependency_Runtime> parentRules = myDependencies.get(parent);\n        if (parentRules != null) {\n          Set<IDependency_Runtime> clone;\n          synchronized (parentRules) {\n            clone = new THashSet<IDependency_Runtime>(parentRules);\n          }\n          rules.addAll(clone);\n        }\n        parent = getSuperConcept(parent);\n      }\n    }\n    myDependenciesCache.clear();\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<SNode> getDependencies(SNode node) {\n    if (node == null) return new THashSet<SNode>(1);\n    Set<IDependency_Runtime> dependencies;\n    synchronized (RulesManager.RULES_LOCK) {\n      SNode conceptDeclaration = node.getConceptDeclarationNode();\n      dependencies = get(conceptDeclaration);\n    }\n    Set<SNode> result = new THashSet<SNode>(1);\n    for (IDependency_Runtime dependency_runtime : dependencies) {\n      Set<SNode> sourceNodes = dependency_runtime.getSourceNodes(node);\n      for (SNode sourceNode : sourceNodes) {\n        if (sourceNode == null) continue;\n        if (SModelUtil.isAssignableConcept(sourceNode.getConceptFqName(), dependency_runtime.getSourceConceptFQName())) {\n          result.add(sourceNode);\n        }\n      }\n    }\n    return result;\n  }","id":89034,"modified_method":"public Set<SNode> getDependencies(SNode node) {\n    if (node == null) return Collections.emptySet();\n    String conceptDeclaration = node.getConceptFqName();\n    Set<SNode> result = new THashSet<SNode>(1);\n    for (IDependency_Runtime dependency_runtime : get(conceptDeclaration)) {\n      Set<SNode> sourceNodes = dependency_runtime.getSourceNodes(node);\n      for (SNode sourceNode : sourceNodes) {\n        if (sourceNode == null) continue;\n        if (SModelUtil.isAssignableConcept(sourceNode.getConceptFqName(), dependency_runtime.getSourceConceptFQName())) {\n          result.add(sourceNode);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addDependencies(Set<IDependency_Runtime> dependencies) {\n    for (IDependency_Runtime dependency : dependencies) {\n      SNode concept = SModelUtil.findConceptDeclaration(dependency.getTargetConceptFQName(), GlobalScope.getInstance());\n      Set<IDependency_Runtime> existingRules = myDependencies.get(concept);\n      if (existingRules == null) {\n        existingRules = new THashSet<IDependency_Runtime>(1);\n        myDependencies.put(concept,\n          existingRules);\n      }\n      existingRules.add(dependency);\n    }\n  }","id":89035,"modified_method":"public void addDependencies(Set<IDependency_Runtime> dependencies) {\n    for (IDependency_Runtime dependency : dependencies) {\n      String concept = dependency.getTargetConceptFQName();\n      if(concept == null) continue;\n\n      Set<IDependency_Runtime> existingRules = myDependencies.get(concept);\n      while (existingRules == null) {\n        myDependencies.putIfAbsent(concept, Collections.synchronizedSet(new THashSet<IDependency_Runtime>(1)));\n        existingRules = myDependencies.get(concept);\n      }\n      existingRules.add(dependency);\n    }\n    myDependenciesCache.clear();\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void clear() {\n    myDependencies.clear();\n  }","id":89036,"modified_method":"public void clear() {\n    myDependencies.clear();\n    myDependenciesCache.clear();\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addRuleSetItem(Set<T> rules) {\n    for (T rule : rules) {\n      String concept1 = rule.getApplicableConceptFQName1();\n      String concept2 = rule.getApplicableConceptFQName2();\n      Pair<String, String> pair = new Pair<String, String>(concept1, concept2);\n      Set<T> existingRules = myRules.get(pair);\n      if (existingRules == null) {\n        existingRules = Collections.synchronizedSet(new HashSet<T>(1));\n        myRules.put(pair, existingRules);\n      }\n      existingRules.add(rule);\n    }\n    myRulesCache.clear();\n  }","id":89037,"modified_method":"public void addRuleSetItem(Set<T> rules) {\n    for (T rule : rules) {\n      String concept1 = rule.getApplicableConceptFQName1();\n      String concept2 = rule.getApplicableConceptFQName2();\n      Pair<String, String> pair = new Pair<String, String>(concept1, concept2);\n      Set<T> existingRules = myRules.get(pair);\n      while (existingRules == null) {\n        myRules.putIfAbsent(pair, Collections.synchronizedSet(new HashSet<T>(1)));\n        existingRules = myRules.get(pair);\n      }\n      existingRules.add(rule);\n    }\n    myRulesCache.clear();\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void makeConsistent() {\n    for (Pair<String, String> pair : myRules.keySet()) {\n      if (pair == null) {\n        continue;\n      }\n      Set<T> rules = myRules.get(pair);\n      if (rules == null) continue;\n      if (isInterfaceConcept(pair.o1) || isInterfaceConcept(pair.o2)) continue;\n\n      for (String conceptDeclaration1 = pair.o1; conceptDeclaration1 != null; conceptDeclaration1 = getSuperConcept(conceptDeclaration1)) {\n        for (String conceptDeclaration2 = pair.o2; conceptDeclaration2 != null; conceptDeclaration2 = getSuperConcept(conceptDeclaration2)) {\n          Set<T> parentRules = myRules.get(new Pair<String, String>(conceptDeclaration1, conceptDeclaration2));\n          if (parentRules != null) {\n            if (conceptDeclaration1 != pair.o1 || conceptDeclaration2 != pair.o2) {\n              rules.addAll(parentRules);\n            }\n          }\n        }\n      }\n    }\n  }","id":89038,"modified_method":"public void makeConsistent() {\n    for (Pair<String, String> pair : myRules.keySet()) {\n      if (pair == null) {\n        continue;\n      }\n      Set<T> rules = myRules.get(pair);\n      if (rules == null) continue;\n      if (isInterfaceConcept(pair.o1) || isInterfaceConcept(pair.o2)) continue;\n\n      for (String conceptDeclaration1 = pair.o1; conceptDeclaration1 != null; conceptDeclaration1 = getSuperConcept(conceptDeclaration1)) {\n        for (String conceptDeclaration2 = pair.o2; conceptDeclaration2 != null; conceptDeclaration2 = getSuperConcept(conceptDeclaration2)) {\n          Set<T> parentRules = myRules.get(new Pair<String, String>(conceptDeclaration1, conceptDeclaration2));\n          if (parentRules != null) {\n            if (conceptDeclaration1 != pair.o1 || conceptDeclaration2 != pair.o2) {\n              Set<T> clone;\n              synchronized (parentRules) {\n                clone = new THashSet<T>(parentRules);\n              }\n              rules.addAll(clone);\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<T> get(@NotNull final Pair<String, String> key) {\n    Set<T> result = myRulesCache.get(key);\n    if(result != null) {\n      return result;\n    }\n\n    String c1 = key.o1;\n    String c2 = key.o2;\n    if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {\n      for (String conceptDeclaration1 = c1; conceptDeclaration1 != null; conceptDeclaration1 = getSuperConcept(conceptDeclaration1)) {\n        for (String conceptDeclaration2 = c2; conceptDeclaration2 != null; conceptDeclaration2 = getSuperConcept(conceptDeclaration2)) {\n          Pair<String, String> newKey =\n            new Pair<String, String>(conceptDeclaration1, conceptDeclaration2);\n          result = myRules.get(newKey);\n          if (result != null) {\n            if (conceptDeclaration1 != key.o1 || conceptDeclaration2 != key.o2) {\n              myRules.putIfAbsent(key, result);\n            }\n            // synchronized collection (result) requires external synchronization for iteration/clone\n            synchronized (result) {\n              Set<T> clone = Collections.unmodifiableSet(new THashSet<T>(result));\n              myRulesCache.putIfAbsent(key, clone);\n            }\n            return Collections.unmodifiableSet(result);\n          }\n        }\n      }\n    }\n    myRules.putIfAbsent(key, Collections.synchronizedSet(new HashSet<T>(1)));\n    myRulesCache.putIfAbsent(key, Collections.<T>emptySet());\n    return Collections.emptySet();\n  }","id":89039,"modified_method":"protected Set<T> get(@NotNull final Pair<String, String> key) {\n    Set<T> result = myRulesCache.get(key);\n    if(result != null) {\n      return result;\n    }\n\n    String c1 = key.o1;\n    String c2 = key.o2;\n    if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {\n      for (String conceptDeclaration1 = c1; conceptDeclaration1 != null; conceptDeclaration1 = getSuperConcept(conceptDeclaration1)) {\n        for (String conceptDeclaration2 = c2; conceptDeclaration2 != null; conceptDeclaration2 = getSuperConcept(conceptDeclaration2)) {\n          Pair<String, String> newKey =\n            new Pair<String, String>(conceptDeclaration1, conceptDeclaration2);\n          result = myRules.get(newKey);\n          if (result != null) {\n            if (conceptDeclaration1 != key.o1 || conceptDeclaration2 != key.o2) {\n              myRules.putIfAbsent(key, result);\n            }\n            // synchronized collection (result) requires external synchronization for iteration/clone\n            synchronized (result) {\n              Set<T> clone = Collections.unmodifiableSet(new THashSet<T>(result));\n              myRulesCache.putIfAbsent(key, clone);\n              return clone;\n            }\n          }\n        }\n      }\n    }\n    myRules.putIfAbsent(key, Collections.synchronizedSet(new HashSet<T>(1)));\n    myRulesCache.putIfAbsent(key, Collections.<T>emptySet());\n    return Collections.emptySet();\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addRuleSetItem(Set<T> rules) {\n    for (T rule : rules) {\n      addRule(rule);\n    }\n    myRulesCache.clear();\n  }","id":89040,"modified_method":"public void addRuleSetItem(Set<T> rules) {\n    for (T rule : rules) {\n      addRule_internal(rule);\n    }\n    myRulesCache.clear();\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addRule_internal(T rule) {\n    String concept = rule.getApplicableConceptFQName();\n    Set<T> existingRules = myRules.get(concept);\n    if (existingRules == null) {\n      existingRules = Collections.synchronizedSet(new THashSet<T>(2));\n      myRules.put(concept, existingRules);\n    }\n    existingRules.add(rule);\n  }","id":89041,"modified_method":"private void addRule_internal(T rule) {\n    String concept = rule.getApplicableConceptFQName();\n    Set<T> existingRules = myRules.get(concept);\n    while (existingRules == null) {\n      myRules.putIfAbsent(concept, Collections.synchronizedSet(new THashSet<T>(2)));\n      existingRules = myRules.get(concept);\n    }\n    existingRules.add(rule);\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Set<T> computeRuleSet(String concept) {\n    Set<T> result = new THashSet<T>();\n    Set<String> frontier = new THashSet<String>();\n    Set<String> newFrontier = new THashSet<String>();\n    frontier.add(concept);\n\n    while (!frontier.isEmpty()) {\n      for (String abstractConcept : frontier) {\n        Set<T> rules = myRules.get(abstractConcept);\n        boolean overrides = false;\n        if (rules != null) {\n          result.addAll(rules);\n          for (T rule : rules) {\n            if (rule instanceof ICheckingRule_Runtime && ((ICheckingRule_Runtime) rule).overrides()) {\n              overrides = true;\n            }\n          }\n        }\n        //else {\n        if (overrides) {\n          continue;\n        }\n\n        newFrontier.addAll(LanguageHierarchyCache.getParentsNames(abstractConcept));\n        //}\n\n      }\n      frontier = newFrontier;\n      newFrontier = new THashSet<String>();\n    }\n    return result;\n  }","id":89042,"modified_method":"private Set<T> computeRuleSet(String concept) {\n    Set<T> result = new THashSet<T>();\n    Set<String> frontier = new THashSet<String>();\n    Set<String> newFrontier = new THashSet<String>();\n    frontier.add(concept);\n\n    while (!frontier.isEmpty()) {\n      for (String abstractConcept : frontier) {\n        Set<T> rules = myRules.get(abstractConcept);\n        boolean overrides = false;\n        if (rules != null) {\n          synchronized (rules) {\n            result.addAll(rules);\n            for (T rule : rules) {\n              if (rule instanceof ICheckingRule_Runtime && ((ICheckingRule_Runtime) rule).overrides()) {\n                overrides = true;\n              }\n            }\n          }\n        }\n        //else {\n        if (overrides) {\n          continue;\n        }\n\n        newFrontier.addAll(LanguageHierarchyCache.getParentsNames(abstractConcept));\n        //}\n\n      }\n      frontier = newFrontier;\n      newFrontier = new THashSet<String>();\n    }\n    return result;\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<T> get(String key) {\n    Set<T> cachedResult = myRulesCache.get(key);\n    if (cachedResult != null) {\n      return Collections.unmodifiableSet(cachedResult);\n    }\n\n    Set<T> result = computeRuleSet(key);\n    myRulesCache.put(key, result);\n    return Collections.unmodifiableSet(result);\n  }","id":89043,"modified_method":"protected Set<T> get(String key) {\n    Set<T> cachedResult = myRulesCache.get(key);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n\n    Set<T> result = Collections.unmodifiableSet(computeRuleSet(key));\n    myRulesCache.put(key, result);\n    return result;\n  }","commit_id":"09b715d479290e2eccec7060507d3fc8fbebdd6f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<T> get(@NotNull final Pair<String, String> key) {\n    Set<T> result = myRulesCache.get(key);\n    if(result != null) {\n      return Collections.unmodifiableSet(result);\n    }\n\n    String c1 = key.o1;\n    String c2 = key.o2;\n    if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {\n      for (String conceptDeclaration1 = c1; conceptDeclaration1 != null; conceptDeclaration1 = getSuperConcept(conceptDeclaration1)) {\n        for (String conceptDeclaration2 = c2; conceptDeclaration2 != null; conceptDeclaration2 = getSuperConcept(conceptDeclaration2)) {\n          Pair<String, String> newKey =\n            new Pair<String, String>(conceptDeclaration1, conceptDeclaration2);\n          result = myRules.get(newKey);\n          if (result != null) {\n            if (conceptDeclaration1 != key.o1 || conceptDeclaration2 != key.o2) {\n              myRules.putIfAbsent(key, result);\n            }\n            myRulesCache.putIfAbsent(key, new THashSet<T>(result));\n            return Collections.unmodifiableSet(result);\n          }\n        }\n      }\n    }\n    result = Collections.synchronizedSet(new HashSet<T>(1));\n    myRules.putIfAbsent(key, result);\n    myRulesCache.putIfAbsent(key, new HashSet<T>(1));\n    return Collections.unmodifiableSet(result);\n  }","id":89044,"modified_method":"protected Set<T> get(@NotNull final Pair<String, String> key) {\n    Set<T> result = myRulesCache.get(key);\n    if(result != null) {\n      return result;\n    }\n\n    String c1 = key.o1;\n    String c2 = key.o2;\n    if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {\n      for (String conceptDeclaration1 = c1; conceptDeclaration1 != null; conceptDeclaration1 = getSuperConcept(conceptDeclaration1)) {\n        for (String conceptDeclaration2 = c2; conceptDeclaration2 != null; conceptDeclaration2 = getSuperConcept(conceptDeclaration2)) {\n          Pair<String, String> newKey =\n            new Pair<String, String>(conceptDeclaration1, conceptDeclaration2);\n          result = myRules.get(newKey);\n          if (result != null) {\n            if (conceptDeclaration1 != key.o1 || conceptDeclaration2 != key.o2) {\n              myRules.putIfAbsent(key, result);\n            }\n            // synchronized collection (result) requires external synchronization for iteration/clone\n            synchronized (result) {\n              Set<T> clone = Collections.unmodifiableSet(new THashSet<T>(result));\n              myRulesCache.putIfAbsent(key, clone);\n            }\n            return Collections.unmodifiableSet(result);\n          }\n        }\n      }\n    }\n    myRules.putIfAbsent(key, Collections.synchronizedSet(new HashSet<T>(1)));\n    myRulesCache.putIfAbsent(key, Collections.<T>emptySet());\n    return Collections.emptySet();\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void clear() {\n    myRules.clear();\n  }","id":89045,"modified_method":"public void clear() {\n    myRules.clear();\n    myRulesCache.clear();\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<AbstractDependentComputation_Runtime> getDependentComputations(final SNode node) {\n    Set<AbstractDependentComputation_Runtime> rules;\n    synchronized (RULES_LOCK) {\n      rules = myDependentComputations.getRules(node);\n    }\n    return CollectionUtil.filter(rules, new Condition<AbstractDependentComputation_Runtime>() {\n      @Override\n      public boolean met(AbstractDependentComputation_Runtime dependentComputation) {\n        return dependentComputation.isApplicable(node);\n      }\n    });\n  }","id":89046,"modified_method":"public Set<AbstractDependentComputation_Runtime> getDependentComputations(final SNode node) {\n    Set<AbstractDependentComputation_Runtime> rules;\n    //synchronized (RULES_LOCK) {\n      rules = myDependentComputations.getRules(node);\n    //}\n    return CollectionUtil.filter(rules, new Condition<AbstractDependentComputation_Runtime>() {\n      @Override\n      public boolean met(AbstractDependentComputation_Runtime dependentComputation) {\n        return dependentComputation.isApplicable(node);\n      }\n    });\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> getSubtypingRules(final SNode node, final boolean isWeak) {\n    List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> result = new LinkedList<Pair<SubtypingRule_Runtime, IsApplicableStatus>>();\n    Set<SubtypingRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      //loadLanguage(node.getLanguageNamespace());\n      ruleSet = mySubtypingRules.getRules(node);\n    }\n    for (SubtypingRule_Runtime rule : ruleSet) {\n      if ((isWeak || !rule.isWeak())) {\n        IsApplicableStatus status = rule.isApplicableAndPattern(node);\n        if (status.isApplicable()) {\n          result.add(new Pair<SubtypingRule_Runtime, IsApplicableStatus>(rule, status));\n        }\n      }\n    }\n    return result;\n  }","id":89047,"modified_method":"public List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> getSubtypingRules(final SNode node, final boolean isWeak) {\n    List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> result = new LinkedList<Pair<SubtypingRule_Runtime, IsApplicableStatus>>();\n    Set<SubtypingRule_Runtime> ruleSet;\n    //synchronized (RULES_LOCK) {\n      //loadLanguage(node.getLanguageNamespace());\n      ruleSet = mySubtypingRules.getRules(node);\n    //}\n    for (SubtypingRule_Runtime rule : ruleSet) {\n      if ((isWeak || !rule.isWeak())) {\n        IsApplicableStatus status = rule.isApplicableAndPattern(node);\n        if (status.isApplicable()) {\n          result.add(new Pair<SubtypingRule_Runtime, IsApplicableStatus>(rule, status));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> getReplacementRules(final SNode node1, final SNode node2) {\n    List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>>();\n    Set<InequationReplacementRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      ruleSet = myReplacementRules.getRules(node1, node2);\n    }\n    for (InequationReplacementRule_Runtime rule : ruleSet) {\n      IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n      if (status.isApplicable()) {\n        result.add(new Pair<InequationReplacementRule_Runtime, IsApplicable2Status>(rule, status));\n      }\n    }\n    return result;\n  }","id":89048,"modified_method":"public List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> getReplacementRules(final SNode node1, final SNode node2) {\n    List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>>();\n    Set<InequationReplacementRule_Runtime> ruleSet;\n    //synchronized (RULES_LOCK) {\n      ruleSet = myReplacementRules.getRules(node1, node2);\n    //}\n    for (InequationReplacementRule_Runtime rule : ruleSet) {\n      IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n      if (status.isApplicable()) {\n        result.add(new Pair<InequationReplacementRule_Runtime, IsApplicable2Status>(rule, status));\n      }\n    }\n    return result;\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isBlockingDependentComputationNode(SNode node) {\n    Set<DependentComputationWrapper> set;\n    synchronized (RULES_LOCK) {\n      set = myDependentComputationsBlockedNodes.getRules(node);\n    }\n    if (set == null) return false;\n    for (DependentComputationWrapper wrapper : set) {\n      if (wrapper.isBlocking(node)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":89049,"modified_method":"public boolean isBlockingDependentComputationNode(SNode node) {\n    Set<DependentComputationWrapper> set;\n    //synchronized (RULES_LOCK) {\n      set = myDependentComputationsBlockedNodes.getRules(node);\n    //}\n    if (set == null) return false;\n    for (DependentComputationWrapper wrapper : set) {\n      if (wrapper.isBlocking(node)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> getNonTypesystemRules(final SNode node) {\n    List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> result =\n      new LinkedList<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>>();\n    Set<NonTypesystemRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      ruleSet = myNonTypesystemRules.getRules(node);\n    }\n    for (NonTypesystemRule_Runtime rule : ruleSet) {\n      IsApplicableStatus status = rule.isApplicableAndPattern(node);\n      if (status.isApplicable()) {\n        result.add(new Pair<NonTypesystemRule_Runtime, IsApplicableStatus>(rule, status));\n      }\n    }\n    return result;\n  }","id":89050,"modified_method":"public List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> getNonTypesystemRules(final SNode node) {\n    List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> result =\n      new LinkedList<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>>();\n    Set<NonTypesystemRule_Runtime> ruleSet;\n    //synchronized (RULES_LOCK) {\n      ruleSet = myNonTypesystemRules.getRules(node);\n    //}\n    for (NonTypesystemRule_Runtime rule : ruleSet) {\n      IsApplicableStatus status = rule.isApplicableAndPattern(node);\n      if (status.isApplicable()) {\n        result.add(new Pair<NonTypesystemRule_Runtime, IsApplicableStatus>(rule, status));\n      }\n    }\n    return result;\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<InferenceRule_Runtime, IsApplicableStatus>> getInferenceRules(final SNode node) {\n    List<Pair<InferenceRule_Runtime, IsApplicableStatus>> result = new LinkedList<Pair<InferenceRule_Runtime, IsApplicableStatus>>();\n    Set<InferenceRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      ruleSet = myInferenceRules.getRules(node);\n    }\n    for (InferenceRule_Runtime rule : ruleSet) {\n      IsApplicableStatus status = rule.isApplicableAndPattern(node);\n      if (status.isApplicable()) {\n        result.add(new Pair<InferenceRule_Runtime, IsApplicableStatus>(rule, status));\n      }\n    }\n    return result;\n  }","id":89051,"modified_method":"public List<Pair<InferenceRule_Runtime, IsApplicableStatus>> getInferenceRules(final SNode node) {\n    List<Pair<InferenceRule_Runtime, IsApplicableStatus>> result = new LinkedList<Pair<InferenceRule_Runtime, IsApplicableStatus>>();\n    Set<InferenceRule_Runtime> ruleSet;\n    //synchronized (RULES_LOCK) {\n      ruleSet = myInferenceRules.getRules(node);\n    //}\n    for (InferenceRule_Runtime rule : ruleSet) {\n      IsApplicableStatus status = rule.isApplicableAndPattern(node);\n      if (status.isApplicable()) {\n        result.add(new Pair<InferenceRule_Runtime, IsApplicableStatus>(rule, status));\n      }\n    }\n    return result;\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> getComparisonRules(final SNode node1, final SNode node2, final boolean isWeak) {\n    List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<ComparisonRule_Runtime, IsApplicable2Status>>();\n    Set<ComparisonRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      // loadLanguage(node1.getLanguageNamespace());\n      // loadLanguage(node2.getLanguageNamespace());\n      ruleSet = myComparisonRules.getRules(node1, node2);\n    }\n    for (ComparisonRule_Runtime rule : ruleSet) {\n      if (isWeak || !rule.isWeak()) {\n        IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n        if (status.isApplicable()) {\n          result.add(new Pair<ComparisonRule_Runtime, IsApplicable2Status>(rule, status));\n        }\n      }\n    }\n    return result;\n  }","id":89052,"modified_method":"public List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> getComparisonRules(final SNode node1, final SNode node2, final boolean isWeak) {\n    List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<ComparisonRule_Runtime, IsApplicable2Status>>();\n    Set<ComparisonRule_Runtime> ruleSet;\n    //synchronized (RULES_LOCK) {\n      // loadLanguage(node1.getLanguageNamespace());\n      // loadLanguage(node2.getLanguageNamespace());\n      ruleSet = myComparisonRules.getRules(node1, node2);\n    //}\n    for (ComparisonRule_Runtime rule : ruleSet) {\n      if (isWeak || !rule.isWeak()) {\n        IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n        if (status.isApplicable()) {\n          result.add(new Pair<ComparisonRule_Runtime, IsApplicable2Status>(rule, status));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"e52fbf0e79796e44daec3f6c50722edb4cdd696d","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\r\n     * Test if an url shall be accepted for crawl using attributes that are consistent for the whole crawl\r\n     * These tests are incomplete and must be followed with an checkAcceptanceChangeable - test.\r\n     * @param url\r\n     * @param profile\r\n     * @return null if the url is accepted, an error string in case if the url is not accepted with an error description\r\n     */\r\n    public String checkAcceptanceInitially(final DigestURL url, final CrawlProfile profile) {\r\n\r\n        final String urlstring = url.toString();\r\n        // check if the url is double registered\r\n        String urlhash = ASCII.String(url.hash());\r\n        final HarvestProcess dbocc = this.nextQueue.exists(url.hash()); // returns the name of the queue if entry exists\r\n        final long oldTime = this.indexSegment.fulltext().getLoadTime(urlhash);\r\n        if (oldTime < 0) {\r\n            if (dbocc != null) {\r\n                // do double-check\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    return \"double in: errors (\" + errorEntry.getFailReason() + \")\";\r\n                }\r\n                return \"double in: \" + dbocc.toString();\r\n            }\r\n        } else {\r\n            final boolean recrawl = profile.recrawlIfOlder() > oldTime;\r\n            if (recrawl) {\r\n                if (CrawlStacker.log.isInfo())\r\n                    CrawlStacker.log.info(\"RE-CRAWL of URL '\" + urlstring + \"': this url was crawled \" +\r\n                        ((System.currentTimeMillis() - oldTime) / 60000 / 60 / 24) + \" days ago.\");\r\n            } else {\r\n                Date oldDate = new Date(oldTime);\r\n                if (dbocc == null) {\r\n                    return \"double in: LURL-DB, oldDate = \" + oldDate.toString();\r\n                }\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"', previous cause: \" + errorEntry.getFailReason());\r\n                    return \"double in: errors (\" + errorEntry.getFailReason() + \"), oldDate = \" + oldDate.toString();\r\n                }\r\n                if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"'. \");\r\n                return \"double in: \" + dbocc.toString() + \", oldDate = \" + oldDate.toString();\r\n            }\r\n        }\r\n\r\n        // deny urls that exceed allowed number of occurrences\r\n        final int maxAllowedPagesPerDomain = profile.domMaxPages();\r\n        if (maxAllowedPagesPerDomain < Integer.MAX_VALUE && maxAllowedPagesPerDomain > 0) {\r\n            final AtomicInteger dp = profile.getCount(url.getHost());\r\n            if (dp != null && dp.get() >= maxAllowedPagesPerDomain) {\r\n                if (CrawlStacker.log.isFine()) CrawlStacker.log.fine(\"URL '\" + urlstring + \"' appeared too often in crawl stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"crawl stack domain counter exceeded (test by profile)\";\r\n            }\r\n\r\n            /*\r\n            if (ResultURLs.domainCount(EventOrigin.LOCAL_CRAWLING, url.getHost()) >= maxAllowedPagesPerDomain) {\r\n                if (this.log.isFine()) this.log.fine(\"URL '\" + urlstring + \"' appeared too often in result stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"result stack domain counter exceeded (test by domainCount)\";\r\n            }\r\n            */\r\n        }\r\n\r\n        return null;\r\n    }","id":89053,"modified_method":"/**\r\n     * Test if an url shall be accepted for crawl using attributes that are consistent for the whole crawl\r\n     * These tests are incomplete and must be followed with an checkAcceptanceChangeable - test.\r\n     * @param url\r\n     * @param profile\r\n     * @return null if the url is accepted, an error string in case if the url is not accepted with an error description\r\n     */\r\n    public String checkAcceptanceInitially(final DigestURL url, final CrawlProfile profile) {\r\n\r\n        final String urlstring = url.toString();\r\n        // check if the url is double registered\r\n        String urlhash = ASCII.String(url.hash());\r\n        final HarvestProcess dbocc = this.nextQueue.exists(url.hash()); // returns the name of the queue if entry exists\r\n        final long oldTime = this.indexSegment.fulltext().getLoadTime(urlhash);\r\n        if (oldTime < 0) {\r\n            if (dbocc != null) {\r\n                // do double-check\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    return \"double in: errors (\" + (errorEntry == null ? \"NULL\" : errorEntry.getFailReason()) + \")\";\r\n                }\r\n                return \"double in: \" + dbocc.toString();\r\n            }\r\n        } else {\r\n            final boolean recrawl = profile.recrawlIfOlder() > oldTime;\r\n            if (recrawl) {\r\n                if (CrawlStacker.log.isInfo())\r\n                    CrawlStacker.log.info(\"RE-CRAWL of URL '\" + urlstring + \"': this url was crawled \" +\r\n                        ((System.currentTimeMillis() - oldTime) / 60000 / 60 / 24) + \" days ago.\");\r\n            } else {\r\n                Date oldDate = new Date(oldTime);\r\n                if (dbocc == null) {\r\n                    return \"double in: LURL-DB, oldDate = \" + oldDate.toString();\r\n                }\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"', previous cause: \" + errorEntry.getFailReason());\r\n                    return \"double in: errors (\" + errorEntry.getFailReason() + \"), oldDate = \" + oldDate.toString();\r\n                }\r\n                if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"'. \");\r\n                return \"double in: \" + dbocc.toString() + \", oldDate = \" + oldDate.toString();\r\n            }\r\n        }\r\n\r\n        // deny urls that exceed allowed number of occurrences\r\n        final int maxAllowedPagesPerDomain = profile.domMaxPages();\r\n        if (maxAllowedPagesPerDomain < Integer.MAX_VALUE && maxAllowedPagesPerDomain > 0) {\r\n            final AtomicInteger dp = profile.getCount(url.getHost());\r\n            if (dp != null && dp.get() >= maxAllowedPagesPerDomain) {\r\n                if (CrawlStacker.log.isFine()) CrawlStacker.log.fine(\"URL '\" + urlstring + \"' appeared too often in crawl stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"crawl stack domain counter exceeded (test by profile)\";\r\n            }\r\n\r\n            /*\r\n            if (ResultURLs.domainCount(EventOrigin.LOCAL_CRAWLING, url.getHost()) >= maxAllowedPagesPerDomain) {\r\n                if (this.log.isFine()) this.log.fine(\"URL '\" + urlstring + \"' appeared too often in result stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"result stack domain counter exceeded (test by domainCount)\";\r\n            }\r\n            */\r\n        }\r\n\r\n        return null;\r\n    }","commit_id":"a878c7982c04b42bec9d4e26e5bfeb2102e8bc4f","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Test if an url shall be accepted for crawl using attributes that are consistent for the whole crawl\r\n     * These tests are incomplete and must be followed with an checkAcceptanceChangeable - test.\r\n     * @param url\r\n     * @param profile\r\n     * @return null if the url is accepted, an error string in case if the url is not accepted with an error description\r\n     */\r\n    public String checkAcceptanceInitially(final DigestURL url, final CrawlProfile profile) {\r\n\r\n        final String urlstring = url.toString();\r\n        // check if the url is double registered\r\n        String urlhash = ASCII.String(url.hash());\r\n        final HarvestProcess dbocc = this.nextQueue.exists(url.hash()); // returns the name of the queue if entry exists\r\n        final long oldTime = this.indexSegment.fulltext().getLoadTime(urlhash);\r\n        if (oldTime < 0) {\r\n            if (dbocc != null) {\r\n                // do double-check\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    return \"double in: errors (\" + (errorEntry == null ? \"NULL\" : errorEntry.getFailReason()) + \")\";\r\n                }\r\n                return \"double in: \" + dbocc.toString();\r\n            }\r\n        } else {\r\n            final boolean recrawl = profile.recrawlIfOlder() > oldTime;\r\n            if (recrawl) {\r\n                if (CrawlStacker.log.isInfo())\r\n                    CrawlStacker.log.info(\"RE-CRAWL of URL '\" + urlstring + \"': this url was crawled \" +\r\n                        ((System.currentTimeMillis() - oldTime) / 60000 / 60 / 24) + \" days ago.\");\r\n            } else {\r\n                Date oldDate = new Date(oldTime);\r\n                if (dbocc == null) {\r\n                    return \"double in: LURL-DB, oldDate = \" + oldDate.toString();\r\n                }\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"', previous cause: \" + errorEntry.getFailReason());\r\n                    return \"double in: errors (\" + errorEntry.getFailReason() + \"), oldDate = \" + oldDate.toString();\r\n                }\r\n                if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"'. \");\r\n                return \"double in: \" + dbocc.toString() + \", oldDate = \" + oldDate.toString();\r\n            }\r\n        }\r\n\r\n        // deny urls that exceed allowed number of occurrences\r\n        final int maxAllowedPagesPerDomain = profile.domMaxPages();\r\n        if (maxAllowedPagesPerDomain < Integer.MAX_VALUE && maxAllowedPagesPerDomain > 0) {\r\n            final AtomicInteger dp = profile.getCount(url.getHost());\r\n            if (dp != null && dp.get() >= maxAllowedPagesPerDomain) {\r\n                if (CrawlStacker.log.isFine()) CrawlStacker.log.fine(\"URL '\" + urlstring + \"' appeared too often in crawl stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"crawl stack domain counter exceeded (test by profile)\";\r\n            }\r\n\r\n            /*\r\n            if (ResultURLs.domainCount(EventOrigin.LOCAL_CRAWLING, url.getHost()) >= maxAllowedPagesPerDomain) {\r\n                if (this.log.isFine()) this.log.fine(\"URL '\" + urlstring + \"' appeared too often in result stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"result stack domain counter exceeded (test by domainCount)\";\r\n            }\r\n            */\r\n        }\r\n\r\n        return null;\r\n    }","id":89054,"modified_method":"/**\r\n     * Test if an url shall be accepted for crawl using attributes that are consistent for the whole crawl\r\n     * These tests are incomplete and must be followed with an checkAcceptanceChangeable - test.\r\n     * @param url\r\n     * @param profile\r\n     * @return null if the url is accepted, an error string in case if the url is not accepted with an error description\r\n     */\r\n    public String checkAcceptanceInitially(final DigestURL url, final CrawlProfile profile) {\r\n\r\n        final String urlstring = url.toString();\r\n        // check if the url is double registered\r\n        String urlhash = ASCII.String(url.hash());\r\n        final HarvestProcess dbocc = this.nextQueue.exists(url.hash()); // returns the name of the queue if entry exists\r\n        final long oldTime = this.indexSegment.fulltext().getLoadTime(urlhash);\r\n        if (oldTime < 0) {\r\n            if (dbocc != null) {\r\n                // do double-check\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    return \"double in: errors (\" + (errorEntry == null ? \"NULL\" : errorEntry.getFailReason()) + \")\";\r\n                }\r\n                return \"double in: \" + dbocc.toString();\r\n            }\r\n        } else {\r\n            final boolean recrawl = profile.recrawlIfOlder() > oldTime;\r\n            if (recrawl) {\r\n                if (CrawlStacker.log.isInfo())\r\n                    CrawlStacker.log.info(\"RE-CRAWL of URL '\" + urlstring + \"': this url was crawled \" +\r\n                        ((System.currentTimeMillis() - oldTime) / 60000 / 60 / 24) + \" days ago.\");\r\n            } else {\r\n                Date oldDate = new Date(oldTime);\r\n                if (dbocc == null) {\r\n                    return \"double in: LURL-DB, oldDate = \" + oldDate.toString();\r\n                }\r\n                if (dbocc == HarvestProcess.ERRORS) {\r\n                    final CollectionConfiguration.FailDoc errorEntry = this.nextQueue.errorURL.get(urlhash);\r\n                    if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"', previous cause: \" + (errorEntry == null ? \"NULL\" : errorEntry.getFailReason()));\r\n                    return \"double in: errors (\" + (errorEntry == null ? \"NULL\" : errorEntry.getFailReason()) + \"), oldDate = \" + oldDate.toString();\r\n                }\r\n                if (CrawlStacker.log.isInfo()) CrawlStacker.log.info(\"URL '\" + urlstring + \"' is double registered in '\" + dbocc.toString() + \"'. \");\r\n                return \"double in: \" + dbocc.toString() + \", oldDate = \" + oldDate.toString();\r\n            }\r\n        }\r\n\r\n        // deny urls that exceed allowed number of occurrences\r\n        final int maxAllowedPagesPerDomain = profile.domMaxPages();\r\n        if (maxAllowedPagesPerDomain < Integer.MAX_VALUE && maxAllowedPagesPerDomain > 0) {\r\n            final AtomicInteger dp = profile.getCount(url.getHost());\r\n            if (dp != null && dp.get() >= maxAllowedPagesPerDomain) {\r\n                if (CrawlStacker.log.isFine()) CrawlStacker.log.fine(\"URL '\" + urlstring + \"' appeared too often in crawl stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"crawl stack domain counter exceeded (test by profile)\";\r\n            }\r\n\r\n            /*\r\n            if (ResultURLs.domainCount(EventOrigin.LOCAL_CRAWLING, url.getHost()) >= maxAllowedPagesPerDomain) {\r\n                if (this.log.isFine()) this.log.fine(\"URL '\" + urlstring + \"' appeared too often in result stack, a maximum of \" + maxAllowedPagesPerDomain + \" is allowed.\");\r\n                return \"result stack domain counter exceeded (test by domainCount)\";\r\n            }\r\n            */\r\n        }\r\n\r\n        return null;\r\n    }","commit_id":"da5d4128bfbee8c06ea9f1921c9414b6f2471ddf","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@SuppressWarnings({ \"unchecked\" })\n    public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        final Switchboard sb = (Switchboard) env;\n        Fulltext fulltext = sb.index.fulltext();\n        final boolean admin = sb.verifyAuthentication(header);\n        final boolean autoload = admin && sb.getConfigBool(\"browser.autoload\", true);\n        final boolean load4everyone = sb.getConfigBool(\"browser.load4everyone\", false);\n        final boolean loadRight = autoload || load4everyone; // add config later\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || admin;\n\n        final serverObjects prop = new serverObjects();\n        \n        // set default values\n        prop.put(\"path\", \"\");\n        prop.put(\"result\", \"\");\n        prop.put(\"hosts\", 0);\n        prop.put(\"files\", 0);\n        prop.put(\"admin\", admin ? 1 : 0);\n\n        if (admin) { // show top nav to admins\n            prop.put(\"topmenu\",1);\n        } else { // for other respect setting in Search Design Configuration\n            prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n        }\n        \n        if (!searchAllowed) {\n            prop.put(\"result\", \"You are not allowed to use this page. Please ask an administrator for permission.\");\n            prop.putNum(\"ucount\", 0);\n            return prop;\n        }\n\n        String path = post == null ? \"\" : post.get(\"path\", \"\").trim();\n        if (admin) sb.index.fulltext().commit(true);\n        if (post == null || env == null) {\n            prop.putNum(\"ucount\", fulltext.collectionSize());\n            return prop;\n        }\n\n        int p = path.lastIndexOf('/');\n        if (p < 0 && path.length() > 0) path = path + \"/\"; else if (p > 7) path = path.substring(0, p + 1); // the search path shall always end with \"/\"\n        if (path.length() > 0 && (\n            !path.startsWith(\"http://\") &&\n            !path.startsWith(\"https://\") &&\n            !path.startsWith(\"ftp://\") &&\n            !path.startsWith(\"smb://\") &&\n            !path.startsWith(\"file://\"))) { path = \"http://\" + path; }\n        prop.putHTML(\"path\", path);\n        prop.put(\"delete\", admin && path.length() > 0 ? 1 : 0);\n        \n        DigestURL pathURI = null;\n        try {pathURI = new DigestURL(path);} catch (final MalformedURLException e) {}\n\n        String load = post.get(\"load\", \"\");\n        boolean wait = false;\n        if (loadRight && autoload && path.length() != 0 && pathURI != null && load.length() == 0 && sb.index.getLoadTime(ASCII.String(pathURI.hash())) < 0) {\n            // in case that the url does not exist and loading is wanted turn this request into a loading request\n            load = path;\n            wait = true;\n        }\n        if (load.length() > 0 && loadRight) {\n            // stack URL\n            DigestURL url;\n            if (sb.crawlStacker.size() > 2) wait = false;\n            try {\n                url = new DigestURL(load);\n                String reasonString = sb.crawlStacker.stackCrawl(new Request(\n                        sb.peers.mySeed().hash.getBytes(),\n                        url, null, load, new Date(),\n                        sb.crawler.defaultProxyProfile.handle(),\n                        0, 0, 0, 0\n                    ));\n                prop.putHTML(\"result\", reasonString == null ? (\"added url to indexer: \" + load) : (\"not indexed url '\" + load + \"': \" + reasonString));\n                if (wait) for (int i = 0; i < 30; i++) {\n                    if (sb.index.getLoadTime(ASCII.String(url.hash())) >= 0) break;\n                    try {Thread.sleep(100);} catch (final InterruptedException e) {}\n                }\n            } catch (final MalformedURLException e) {\n                prop.putHTML(\"result\", \"bad url '\" + load + \"'\");\n            }\n        }\n\n        if (admin && post.containsKey(\"deleteLoadErrors\")) {\n            try {\n                fulltext.getDefaultConnector().deleteByQuery(\"-\" + CollectionSchema.httpstatus_i.getSolrFieldName() + \":200 AND \" \n                        + CollectionSchema.httpstatus_i.getSolrFieldName() + \":[* TO *]\"); // make sure field exists\n                ConcurrentLog.info (\"HostBrowser:\", \"delete documents with httpstatus_i <> 200\");\n                fulltext.getDefaultConnector().deleteByQuery(CollectionSchema.failtype_s.getSolrFieldName() + \":\\\"\" + FailType.fail.name() + \"\\\"\" );\n                ConcurrentLog.info (\"HostBrowser:\", \"delete documents with failtype_s = fail\");\n                fulltext.getDefaultConnector().deleteByQuery(CollectionSchema.failtype_s.getSolrFieldName() + \":\\\"\" + FailType.excl.name() + \"\\\"\" );\n                ConcurrentLog.info (\"HostBrowser:\", \"delete documents with failtype_s = excl\");\n                prop.putNum(\"ucount\", fulltext.collectionSize());\n                return prop;\n            } catch (final IOException ex) {\n                ConcurrentLog.logException(ex);\n            }\n        }\n        \n        if (post.containsKey(\"hosts\")) {\n            // generate host list\n            try {\n                boolean onlyCrawling = \"crawling\".equals(post.get(\"hosts\", \"\"));\n                boolean onlyErrors = \"error\".equals(post.get(\"hosts\", \"\"));\n                \n                int maxcount = admin ? 2 * 3 * 2 * 5 * 7 * 2 * 3 : 360; // which makes nice matrixes for 2, 3, 4, 5, 6, 7, 8, 9 rows/colums\n                \n                // collect hosts from index\n                ReversibleScoreMap<String> hostscore = fulltext.getDefaultConnector().getFacets(AbstractSolrConnector.CATCHALL_TERM, maxcount, CollectionSchema.host_s.getSolrFieldName()).get(CollectionSchema.host_s.getSolrFieldName());\n                if (hostscore == null) hostscore = new ClusteredScoreMap<String>();\n                \n                // collect hosts from crawler\n                final Map<String, Integer[]> crawler = (admin) ? sb.crawlQueues.noticeURL.getDomainStackHosts(StackType.LOCAL, sb.robots) : new HashMap<String, Integer[]>();\n                \n                // collect the errorurls\n                Map<String, ReversibleScoreMap<String>> exclfacets = admin ? fulltext.getDefaultConnector().getFacets(CollectionSchema.failtype_s.getSolrFieldName() + \":\" + FailType.excl.name(), maxcount, CollectionSchema.host_s.getSolrFieldName()) : null;\n                ReversibleScoreMap<String> exclscore = exclfacets == null ? new ClusteredScoreMap<String>() : exclfacets.get(CollectionSchema.host_s.getSolrFieldName());\n                Map<String, ReversibleScoreMap<String>> failfacets = admin ? fulltext.getDefaultConnector().getFacets(CollectionSchema.failtype_s.getSolrFieldName() + \":\" + FailType.fail.name(), maxcount, CollectionSchema.host_s.getSolrFieldName()) : null;\n                ReversibleScoreMap<String> failscore = failfacets == null ? new ClusteredScoreMap<String>() : failfacets.get(CollectionSchema.host_s.getSolrFieldName());\n                \n                int c = 0;\n                Iterator<String> i = hostscore.keys(false);\n                String host;\n                while (i.hasNext() && c < maxcount) {\n                    host = i.next();\n                    prop.putHTML(\"hosts_list_\" + c + \"_host\", host);\n                    boolean inCrawler = crawler.containsKey(host);\n                    int exclcount = exclscore.get(host);\n                    int failcount = failscore.get(host);\n                    int errors = exclcount + failcount;\n                    prop.put(\"hosts_list_\" + c + \"_count\", hostscore.get(host) - errors);\n                    prop.put(\"hosts_list_\" + c + \"_crawler\", inCrawler ? 1 : 0);\n                    if (inCrawler) prop.put(\"hosts_list_\" + c + \"_crawler_pending\", crawler.get(host)[0]);\n                    prop.put(\"hosts_list_\" + c + \"_errors\", errors > 0 ? 1 : 0);\n                    if (errors > 0) {\n                        prop.put(\"hosts_list_\" + c + \"_errors_exclcount\", exclcount);\n                        prop.put(\"hosts_list_\" + c + \"_errors_failcount\", failcount);\n                    }\n                    prop.put(\"hosts_list_\" + c + \"_type\", inCrawler ? 2 : errors > 0 ? 1 : 0);\n                    if (onlyCrawling) {\n                        if (inCrawler) c++;\n                    } else if (onlyErrors) {\n                        if (errors > 0) c++;\n                    } else {\n                        c++;\n                    }\n                }\n                prop.put(\"hosts_list\", c);\n                prop.put(\"hosts\", 1);\n            } catch (final IOException e) {\n                ConcurrentLog.logException(e);\n            }\n        }\n        \n        if (path.length() > 0) {\n            boolean delete = false;\n            boolean reload404 = false;\n            if (admin && post.containsKey(\"delete\")) {\n                // delete the complete path!! That includes everything that matches with this prefix.\n                delete = true;\n            }\n            if (admin && post.containsKey(\"reload404\")) {\n                // try to re-load all urls that have load errors and matches with this prefix.\n                reload404 = true;\n            }\n            int facetcount=post.getInt(\"facetcount\", 0);\n            boolean complete = post.getBoolean(\"complete\");\n            if (complete) { // we want only root paths for complete lists\n                p = path.indexOf('/', 10);\n                if (p > 0) path = path.substring(0, p + 1);\n            }\n            prop.put(\"files_complete\", complete ? 1 : 0);\n            prop.putHTML(\"files_complete_path\", path);\n            p = path.substring(0, path.length() - 1).lastIndexOf('/');\n            if (p < 8) {\n                prop.put(\"files_root\", 1);\n            } else {\n                prop.put(\"files_root\", 0);\n                prop.putHTML(\"files_root_path\", path.substring(0, p + 1));\n            }\n            try {\n                // generate file list from path\n                DigestURL uri = new DigestURL(path);\n                String host = uri.getHost();\n                prop.putHTML(\"outbound_host\", host);\n                if (admin) prop.putHTML(\"outbound_admin_host\", host); //used for WebStructurePicture_p link\n                prop.putHTML(\"inbound_host\", host);\n                String hosthash = ASCII.String(uri.hash(), 6, 6);\n                String[] pathparts = uri.getPaths();\n                \n                // get all files for a specific host from the index\n                StringBuilder q = new StringBuilder();\n                q.append(CollectionSchema.host_s.getSolrFieldName()).append(':').append(host);\n                if (pathparts.length > 0 && pathparts[0].length() > 0) {\n                    for (String pe: pathparts) {\n                        if (pe.length() > 0) q.append(\" AND \").append(CollectionSchema.url_paths_sxt.getSolrFieldName()).append(\":\\\"\").append(pe).append('\\\"');\n                    }\n                } else {\n                    if (facetcount > 1000 || post.containsKey(\"nepr\")) {\n                        q.append(\" AND \").append(CollectionSchema.url_paths_sxt.getSolrFieldName()).append(\":[* TO *]\");\n                    }\n                }\n                BlockingQueue<SolrDocument> docs = fulltext.getDefaultConnector().concurrentDocumentsByQuery(q.toString(), 0, 100000, TIMEOUT, 100,\n                        CollectionSchema.id.getSolrFieldName(),\n                        CollectionSchema.sku.getSolrFieldName(),\n                        CollectionSchema.failreason_s.getSolrFieldName(),\n                        CollectionSchema.failtype_s.getSolrFieldName(),\n                        CollectionSchema.inboundlinks_protocol_sxt.getSolrFieldName(),\n                        CollectionSchema.inboundlinks_urlstub_sxt.getSolrFieldName(),\n                        CollectionSchema.outboundlinks_protocol_sxt.getSolrFieldName(),\n                        CollectionSchema.outboundlinks_urlstub_sxt.getSolrFieldName(),\n                        CollectionSchema.clickdepth_i.getSolrFieldName(),\n                        CollectionSchema.references_i.getSolrFieldName(),\n                        CollectionSchema.references_internal_i.getSolrFieldName(),\n                        CollectionSchema.references_external_i.getSolrFieldName(),\n                        CollectionSchema.references_exthosts_i.getSolrFieldName(),\n                        CollectionSchema.cr_host_chance_d.getSolrFieldName(),\n                        CollectionSchema.cr_host_norm_i.getSolrFieldName()   \n                        );\n                SolrDocument doc;\n                Set<String> storedDocs = new HashSet<String>();\n                Map<String, FailType> errorDocs = new HashMap<String, FailType>();\n                Set<String> inboundLinks = new HashSet<String>();\n                Map<String, ReversibleScoreMap<String>> outboundHosts = new HashMap<String, ReversibleScoreMap<String>>();\n                Map<String, InfoCacheEntry> infoCache = new HashMap<String, InfoCacheEntry>();\n                int hostsize = 0;\n                final List<String> deleteIDs = new ArrayList<String>();\n                final Collection<String> reloadURLs = new ArrayList<String>();\n                final Set<String> reloadURLCollection = new HashSet<String>();\n                long timeoutList = System.currentTimeMillis() + TIMEOUT;\n                long timeoutReferences = System.currentTimeMillis() + 6000;\n                ReferenceReportCache rrCache = sb.index.getReferenceReportCache();\n                while ((doc = docs.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                    String u = (String) doc.getFieldValue(CollectionSchema.sku.getSolrFieldName());\n                    String errortype = (String) doc.getFieldValue(CollectionSchema.failtype_s.getSolrFieldName());\n                    FailType error = errortype == null ? null : FailType.valueOf(errortype);\n                    String ids = (String) doc.getFieldValue(CollectionSchema.id.getSolrFieldName());\n                    infoCache.put(ids, new InfoCacheEntry(sb.index.fulltext(), rrCache, doc, ids, System.currentTimeMillis() < timeoutReferences));\n                    if (u.startsWith(path)) {\n                        if (delete) {\n                            deleteIDs.add(ids);\n                        } else {\n                            if (error == null) storedDocs.add(u); else {\n                                if (reload404 && error == FailType.fail) {\n                                    ArrayList<String> collections = (ArrayList<String>) doc.getFieldValue(CollectionSchema.collection_sxt.getSolrFieldName());\n                                    if (collections != null) reloadURLCollection.addAll(collections);\n                                    reloadURLs.add(u);\n                                }\n                                if (admin) errorDocs.put(u, error);\n                            }\n                        }\n                    } else if (complete) {\n                        if (error == null) storedDocs.add(u); else {\n                            if (admin) errorDocs.put(u, error);\n                        }\n                    }\n                    if ((complete || u.startsWith(path)) && !storedDocs.contains(u)) inboundLinks.add(u); // add the current link\n                    if (error == null) {\n                        hostsize++;\n                        // collect inboundlinks to browse the host\n                        Iterator<String> links = URIMetadataNode.getLinks(doc, true);\n                        while (links.hasNext()) {\n                            u = links.next();\n                            if ((complete || u.startsWith(path)) && !storedDocs.contains(u)) inboundLinks.add(u);\n                        }\n                        \n                        // collect referrer links\n                        links = URIMetadataNode.getLinks(doc, false);\n                        while (links.hasNext()) {\n                            u = links.next();\n                            try {\n                                MultiProtocolURL mu = new MultiProtocolURL(u);\n                                if (mu.getHost() != null) {\n                                    ReversibleScoreMap<String> lks = outboundHosts.get(mu.getHost());\n                                    if (lks == null) {\n                                        lks = new ClusteredScoreMap<String>(UTF8.insensitiveUTF8Comparator);\n                                        outboundHosts.put(mu.getHost(), lks);\n                                    }\n                                    lks.set(u, u.length());\n                                }\n                            } catch (final MalformedURLException e) {}\n                        }\n                    }\n                    if (System.currentTimeMillis() > timeoutList) break;\n                }\n                if (deleteIDs.size() > 0) sb.remove(deleteIDs);\n                if (reloadURLs.size() > 0) {\n                    final Map<String, Pattern> cm = new LinkedHashMap<String, Pattern>();\n                    for (String collection: reloadURLCollection) cm.put(collection, QueryParams.catchall_pattern);\n                    sb.reload(reloadURLs, cm.size() > 0 ? cm : CrawlProfile.collectionParser(\"user\"), false);\n                }\n                \n                // collect from crawler\n                List<Request> domainStackReferences = (admin) ? sb.crawlQueues.noticeURL.getDomainStackReferences(StackType.LOCAL, host, 1000, 3000) : new ArrayList<Request>(0);\n                Set<String> loadingLinks = new HashSet<String>();\n                for (Request crawlEntry: domainStackReferences) loadingLinks.add(crawlEntry.url().toNormalform(true));\n                \n                // now combine all lists into one\n                Map<String, StoreType> files = new HashMap<String, StoreType>();\n                for (String u: storedDocs) files.put(u, StoreType.INDEX);\n                for (Map.Entry<String, FailType> e: errorDocs.entrySet()) files.put(e.getKey(), e.getValue() == FailType.fail ? StoreType.FAILED : StoreType.EXCLUDED);\n                for (String u: inboundLinks) if (!files.containsKey(u)) files.put(u, StoreType.LINK);\n                for (String u: loadingLinks) if (u.startsWith(path) && !files.containsKey(u)) files.put(u, StoreType.LINK);\n                ConcurrentLog.info(\"HostBrowser\", \"collected \" + files.size() + \" urls for path \" + path);\n\n                // distinguish files and folders\n                Map<String, Object> list = new TreeMap<String, Object>(); // a directory list; if object is boolean, its a file; if its a int[], then its a folder\n                int pl = path.length();\n                String file;\n                for (Map.Entry<String, StoreType> entry: files.entrySet()) {\n                    if (entry.getKey().length() < pl) continue; // this is not inside the path\n                    if (!entry.getKey().startsWith(path)) continue;\n                    file = entry.getKey().substring(pl);\n                    StoreType type = entry.getValue();\n                    p = file.indexOf('/');\n                    if (p < 0) {\n                        // this is a file\n                        list.put(entry.getKey(), type); // StoreType value: this is a file; true -> file is in index; false -> not in index, maybe in crawler\n                    } else {\n                        // this is a directory path or a file in a subdirectory\n                        String remainingPath = file.substring(0, p + 1);\n                        if (complete && remainingPath.indexOf('.') > 0) {\n                            list.put(entry.getKey(), type); // StoreType value: this is a file\n                        } else {\n                            String dir = path + remainingPath;\n                            Object c = list.get(dir);\n                            if (c == null) {\n                                int[] linkedStoredIncrawlerError = new int[]{0,0,0,0,0};\n                                if (type == StoreType.LINK) linkedStoredIncrawlerError[0]++;\n                                if (type == StoreType.INDEX) linkedStoredIncrawlerError[1]++;\n                                if (loadingLinks.contains(entry.getKey())) linkedStoredIncrawlerError[2]++;\n                                if (errorDocs.containsKey(entry.getKey())) linkedStoredIncrawlerError[errorDocs.get(entry.getKey()) == FailType.excl ? 3 : 4]++;\n                                list.put(dir, linkedStoredIncrawlerError);\n                            } else if (c instanceof int[]) {\n                                if (type == StoreType.LINK) ((int[]) c)[0]++;\n                                if (type == StoreType.INDEX) ((int[]) c)[1]++;\n                                if (loadingLinks.contains(entry.getKey())) ((int[]) c)[2]++;\n                                if (errorDocs.containsKey(entry.getKey())) ((int[]) c)[errorDocs.get(entry.getKey()) == FailType.excl ? 3 : 4]++;\n                            }\n                        }\n                    }\n                }\n                \n                int maxcount = 1000;\n                int c = 0;\n                // first list only folders\n                int filecounter = 0;\n                for (Map.Entry<String, Object> entry: list.entrySet()) {\n                    if ((entry.getValue() instanceof StoreType)) {\n                        filecounter++;\n                    } else {\n                        // this is a folder\n                        prop.put(\"files_list_\" + c + \"_type\", 1);\n                        prop.putHTML(\"files_list_\" + c + \"_type_url\", entry.getKey());\n                        int linked = ((int[]) entry.getValue())[0];\n                        int stored = ((int[]) entry.getValue())[1];\n                        int crawler = ((int[]) entry.getValue())[2];\n                        int excl = ((int[]) entry.getValue())[3];\n                        int error = ((int[]) entry.getValue())[4];\n                        prop.put(\"files_list_\" + c + \"_type_stored\", stored);\n                        prop.put(\"files_list_\" + c + \"_type_linked\", linked);\n                        prop.put(\"files_list_\" + c + \"_type_pendingVisible\", crawler > 0 ? 1 : 0);\n                        prop.put(\"files_list_\" + c + \"_type_pending\", crawler);\n                        prop.put(\"files_list_\" + c + \"_type_excludedVisible\", excl > 0 ? 1 : 0);\n                        prop.put(\"files_list_\" + c + \"_type_excluded\", excl);\n                        prop.put(\"files_list_\" + c + \"_type_failedVisible\", error > 0 ? 1 : 0);\n                        prop.put(\"files_list_\" + c + \"_type_failed\", error);\n                        if (++c >= maxcount) break;\n                    }\n                }\n                // then list files\n                for (Map.Entry<String, Object> entry: list.entrySet()) {\n                    if (entry.getValue() instanceof StoreType) {\n                        // this is a file\n                        prop.put(\"files_list_\" + c + \"_type\", 0);\n                        prop.putHTML(\"files_list_\" + c + \"_type_url\", entry.getKey());\n                        StoreType type = (StoreType) entry.getValue();\n                        try {uri = new DigestURL(entry.getKey());} catch (final MalformedURLException e) {uri = null;}\n                        HarvestProcess process = uri == null ? null : sb.crawlQueues.exists(uri.hash());\n                        boolean loading = load.equals(entry.getKey()) || (process != null && process != HarvestProcess.ERRORS);\n                        boolean error =  process == HarvestProcess.ERRORS || type == StoreType.EXCLUDED || type == StoreType.FAILED;\n                        boolean dc = type != StoreType.INDEX && !error && !loading && list.containsKey(entry.getKey() + \"/\");\n                        if (!dc) {\n                            prop.put(\"files_list_\" + c + \"_type_stored\", type == StoreType.INDEX ? 1 : error ? 3 : loading ? 2 : 0 /*linked*/);\n                            if (type == StoreType.INDEX) {\n                                String ids = ASCII.String(uri.hash());\n                                InfoCacheEntry ice = infoCache.get(ids);\n                                prop.put(\"files_list_\" + c + \"_type_stored_comment\", ice.toString()); // ice.toString() contains html, therefore do not use putHTML here\n                            }\n                            prop.put(\"files_list_\" + c + \"_type_stored_load\", loadRight ? 1 : 0);\n                            if (error) {\n                                FailType failType = errorDocs.get(entry.getKey());\n                                if (failType == null) {\n                                    // maybe this is only in the errorURL\n                                    prop.putHTML(\"files_list_\" + c + \"_type_stored_error\", process == HarvestProcess.ERRORS ? sb.crawlQueues.errorURL.get(ASCII.String(uri.hash())).getFailReason() : \"unknown error\");\n                                } else {\n                                    String ids = ASCII.String(uri.hash());\n                                    InfoCacheEntry ice = infoCache.get(ids);\n                                    prop.put(\"files_list_\" + c + \"_type_stored_error\", failType == FailType.excl ? \"excluded from indexing\" : \"load fail\" + (ice == null ? \"\" : \"; \" + ice.toString()));\n                                }\n                            }\n                            if (loadRight) {\n                                prop.putHTML(\"files_list_\" + c + \"_type_stored_load_url\", entry.getKey());\n                                prop.putHTML(\"files_list_\" + c + \"_type_stored_load_path\", path);\n                            }\n                            if (++c >= maxcount) break;\n                        }\n                    }\n                }\n                prop.put(\"files_list\", c);\n                prop.putHTML(\"files_path\", path);\n                prop.put(\"files_hostsize\", hostsize);\n                prop.put(\"files_subpathloadsize\", storedDocs.size());\n                prop.put(\"files_subpathdetectedsize\", filecounter - storedDocs.size());\n                prop.put(\"files\", 1);\n\n                // generate inbound-links table\n                StructureEntry struct = sb.webStructure.incomingReferences(hosthash);\n                if (struct != null && struct.references.size() > 0) {\n                    maxcount = 200;\n                    ReversibleScoreMap<String> score = new ClusteredScoreMap<String>(UTF8.insensitiveUTF8Comparator);\n                    for (Map.Entry<String, Integer> entry: struct.references.entrySet()) score.set(entry.getKey(), entry.getValue());\n                    c = 0;\n                    Iterator<String> i = score.keys(false);\n                    while (i.hasNext() && c < maxcount) {\n                        host = i.next();\n                        prop.putHTML(\"inbound_list_\" + c + \"_host\", sb.webStructure.hostHash2hostName(host));\n                        prop.put(\"inbound_list_\" + c + \"_count\", score.get(host));\n                        c++;\n                    }\n                    prop.put(\"inbound_list\", c);\n                    prop.put(\"inbound\", 1);\n                } else {\n                    prop.put(\"inbound\", 0);\n                }\n                \n                // generate outbound-links table\n                if (outboundHosts.size() > 0) {\n                    maxcount = 200;\n                    ReversibleScoreMap<String> score = new ClusteredScoreMap<String>(UTF8.insensitiveUTF8Comparator);\n                    for (Map.Entry<String, ReversibleScoreMap<String>> entry: outboundHosts.entrySet()) score.set(entry.getKey(), entry.getValue().size());\n                    c = 0;\n                    Iterator<String> i = score.keys(false);\n                    while (i.hasNext() && c < maxcount) {\n                        host = i.next();\n                        prop.putHTML(\"outbound_list_\" + c + \"_host\", host);\n                        prop.put(\"outbound_list_\" + c + \"_count\", score.get(host));\n                        prop.put(\"outbound_list_\" + c + \"_link\", outboundHosts.get(host).getMinKey());\n                        c++;\n                    }\n                    prop.put(\"outbound_list\", c);\n                    prop.put(\"outbound\", 1);\n                } else {\n                    prop.put(\"outbound\", 0);\n                }\n                \n            } catch (final Throwable e) {\n                ConcurrentLog.logException(e);\n            }\n        }\n\n        // return rewrite properties\n        prop.putNum(\"ucount\", fulltext.collectionSize());\n        return prop;\n    }","id":89055,"modified_method":"@SuppressWarnings({ \"unchecked\" })\n    public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        final Switchboard sb = (Switchboard) env;\n        Fulltext fulltext = sb.index.fulltext();\n        final boolean admin = sb.verifyAuthentication(header);\n        final boolean autoload = admin && sb.getConfigBool(\"browser.autoload\", true);\n        final boolean load4everyone = sb.getConfigBool(\"browser.load4everyone\", false);\n        final boolean loadRight = autoload || load4everyone; // add config later\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || admin;\n\n        final serverObjects prop = new serverObjects();\n        \n        // set default values\n        prop.put(\"path\", \"\");\n        prop.put(\"result\", \"\");\n        prop.put(\"hosts\", 0);\n        prop.put(\"files\", 0);\n        prop.put(\"admin\", admin ? 1 : 0);\n\n        if (admin) { // show top nav to admins\n            prop.put(\"topmenu\",1);\n        } else { // for other respect setting in Search Design Configuration\n            prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n        }\n        \n        if (!searchAllowed) {\n            prop.put(\"result\", \"You are not allowed to use this page. Please ask an administrator for permission.\");\n            prop.putNum(\"ucount\", 0);\n            return prop;\n        }\n\n        String path = post == null ? \"\" : post.get(\"path\", \"\").trim();\n        if (admin) sb.index.fulltext().commit(true);\n        if (post == null || env == null) {\n            prop.putNum(\"ucount\", fulltext.collectionSize());\n            return prop;\n        }\n\n        int p = path.lastIndexOf('/');\n        if (p < 0 && path.length() > 0) path = path + \"/\"; else if (p > 7) path = path.substring(0, p + 1); // the search path shall always end with \"/\"\n        if (path.length() > 0 && (\n            !path.startsWith(\"http://\") &&\n            !path.startsWith(\"https://\") &&\n            !path.startsWith(\"ftp://\") &&\n            !path.startsWith(\"smb://\") &&\n            !path.startsWith(\"file://\"))) { path = \"http://\" + path; }\n        prop.putHTML(\"path\", path);\n        prop.put(\"delete\", admin && path.length() > 0 ? 1 : 0);\n        \n        DigestURL pathURI = null;\n        try {pathURI = new DigestURL(path);} catch (final MalformedURLException e) {}\n\n        String load = post.get(\"load\", \"\");\n        boolean wait = false;\n        if (loadRight && autoload && path.length() != 0 && pathURI != null && load.length() == 0 && sb.index.getLoadTime(ASCII.String(pathURI.hash())) < 0) {\n            // in case that the url does not exist and loading is wanted turn this request into a loading request\n            load = path;\n            wait = true;\n        }\n        if (load.length() > 0 && loadRight) {\n            // stack URL\n            DigestURL url;\n            if (sb.crawlStacker.size() > 2) wait = false;\n            try {\n                url = new DigestURL(load);\n                String reasonString = sb.crawlStacker.stackCrawl(new Request(\n                        sb.peers.mySeed().hash.getBytes(),\n                        url, null, load, new Date(),\n                        sb.crawler.defaultProxyProfile.handle(),\n                        0, 0, 0, 0\n                    ));\n                prop.putHTML(\"result\", reasonString == null ? (\"added url to indexer: \" + load) : (\"not indexed url '\" + load + \"': \" + reasonString));\n                if (wait) for (int i = 0; i < 30; i++) {\n                    if (sb.index.getLoadTime(ASCII.String(url.hash())) >= 0) break;\n                    try {Thread.sleep(100);} catch (final InterruptedException e) {}\n                }\n            } catch (final MalformedURLException e) {\n                prop.putHTML(\"result\", \"bad url '\" + load + \"'\");\n            }\n        }\n\n        if (admin && post.containsKey(\"deleteLoadErrors\")) {\n            try {\n                fulltext.getDefaultConnector().deleteByQuery(\"-\" + CollectionSchema.httpstatus_i.getSolrFieldName() + \":200 AND \" \n                        + CollectionSchema.httpstatus_i.getSolrFieldName() + \":[* TO *]\"); // make sure field exists\n                ConcurrentLog.info (\"HostBrowser:\", \"delete documents with httpstatus_i <> 200\");\n                fulltext.getDefaultConnector().deleteByQuery(CollectionSchema.failtype_s.getSolrFieldName() + \":\\\"\" + FailType.fail.name() + \"\\\"\" );\n                ConcurrentLog.info (\"HostBrowser:\", \"delete documents with failtype_s = fail\");\n                fulltext.getDefaultConnector().deleteByQuery(CollectionSchema.failtype_s.getSolrFieldName() + \":\\\"\" + FailType.excl.name() + \"\\\"\" );\n                ConcurrentLog.info (\"HostBrowser:\", \"delete documents with failtype_s = excl\");\n                prop.putNum(\"ucount\", fulltext.collectionSize());\n                return prop;\n            } catch (final IOException ex) {\n                ConcurrentLog.logException(ex);\n            }\n        }\n        \n        if (post.containsKey(\"hosts\")) {\n            // generate host list\n            try {\n                boolean onlyCrawling = \"crawling\".equals(post.get(\"hosts\", \"\"));\n                boolean onlyErrors = \"error\".equals(post.get(\"hosts\", \"\"));\n                \n                int maxcount = admin ? 2 * 3 * 2 * 5 * 7 * 2 * 3 : 360; // which makes nice matrixes for 2, 3, 4, 5, 6, 7, 8, 9 rows/colums\n                \n                // collect hosts from index\n                ReversibleScoreMap<String> hostscore = fulltext.getDefaultConnector().getFacets(AbstractSolrConnector.CATCHALL_TERM, maxcount, CollectionSchema.host_s.getSolrFieldName()).get(CollectionSchema.host_s.getSolrFieldName());\n                if (hostscore == null) hostscore = new ClusteredScoreMap<String>();\n                \n                // collect hosts from crawler\n                final Map<String, Integer[]> crawler = (admin) ? sb.crawlQueues.noticeURL.getDomainStackHosts(StackType.LOCAL, sb.robots) : new HashMap<String, Integer[]>();\n                \n                // collect the errorurls\n                Map<String, ReversibleScoreMap<String>> exclfacets = admin ? fulltext.getDefaultConnector().getFacets(CollectionSchema.failtype_s.getSolrFieldName() + \":\" + FailType.excl.name(), maxcount, CollectionSchema.host_s.getSolrFieldName()) : null;\n                ReversibleScoreMap<String> exclscore = exclfacets == null ? new ClusteredScoreMap<String>() : exclfacets.get(CollectionSchema.host_s.getSolrFieldName());\n                Map<String, ReversibleScoreMap<String>> failfacets = admin ? fulltext.getDefaultConnector().getFacets(CollectionSchema.failtype_s.getSolrFieldName() + \":\" + FailType.fail.name(), maxcount, CollectionSchema.host_s.getSolrFieldName()) : null;\n                ReversibleScoreMap<String> failscore = failfacets == null ? new ClusteredScoreMap<String>() : failfacets.get(CollectionSchema.host_s.getSolrFieldName());\n                \n                int c = 0;\n                Iterator<String> i = hostscore.keys(false);\n                String host;\n                while (i.hasNext() && c < maxcount) {\n                    host = i.next();\n                    prop.putHTML(\"hosts_list_\" + c + \"_host\", host);\n                    boolean inCrawler = crawler.containsKey(host);\n                    int exclcount = exclscore.get(host);\n                    int failcount = failscore.get(host);\n                    int errors = exclcount + failcount;\n                    prop.put(\"hosts_list_\" + c + \"_count\", hostscore.get(host) - errors);\n                    prop.put(\"hosts_list_\" + c + \"_crawler\", inCrawler ? 1 : 0);\n                    if (inCrawler) prop.put(\"hosts_list_\" + c + \"_crawler_pending\", crawler.get(host)[0]);\n                    prop.put(\"hosts_list_\" + c + \"_errors\", errors > 0 ? 1 : 0);\n                    if (errors > 0) {\n                        prop.put(\"hosts_list_\" + c + \"_errors_exclcount\", exclcount);\n                        prop.put(\"hosts_list_\" + c + \"_errors_failcount\", failcount);\n                    }\n                    prop.put(\"hosts_list_\" + c + \"_type\", inCrawler ? 2 : errors > 0 ? 1 : 0);\n                    if (onlyCrawling) {\n                        if (inCrawler) c++;\n                    } else if (onlyErrors) {\n                        if (errors > 0) c++;\n                    } else {\n                        c++;\n                    }\n                }\n                prop.put(\"hosts_list\", c);\n                prop.put(\"hosts\", 1);\n            } catch (final IOException e) {\n                ConcurrentLog.logException(e);\n            }\n        }\n        \n        if (path.length() > 0) {\n            boolean delete = false;\n            boolean reload404 = false;\n            if (admin && post.containsKey(\"delete\")) {\n                // delete the complete path!! That includes everything that matches with this prefix.\n                delete = true;\n            }\n            if (admin && post.containsKey(\"reload404\")) {\n                // try to re-load all urls that have load errors and matches with this prefix.\n                reload404 = true;\n            }\n            int facetcount=post.getInt(\"facetcount\", 0);\n            boolean complete = post.getBoolean(\"complete\");\n            if (complete) { // we want only root paths for complete lists\n                p = path.indexOf('/', 10);\n                if (p > 0) path = path.substring(0, p + 1);\n            }\n            prop.put(\"files_complete\", complete ? 1 : 0);\n            prop.putHTML(\"files_complete_path\", path);\n            p = path.substring(0, path.length() - 1).lastIndexOf('/');\n            if (p < 8) {\n                prop.put(\"files_root\", 1);\n            } else {\n                prop.put(\"files_root\", 0);\n                prop.putHTML(\"files_root_path\", path.substring(0, p + 1));\n            }\n            try {\n                // generate file list from path\n                DigestURL uri = new DigestURL(path);\n                String host = uri.getHost();\n                prop.putHTML(\"outbound_host\", host);\n                if (admin) prop.putHTML(\"outbound_admin_host\", host); //used for WebStructurePicture_p link\n                prop.putHTML(\"inbound_host\", host);\n                String hosthash = ASCII.String(uri.hash(), 6, 6);\n                String[] pathparts = uri.getPaths();\n                \n                // get all files for a specific host from the index\n                StringBuilder q = new StringBuilder();\n                q.append(CollectionSchema.host_s.getSolrFieldName()).append(':').append(host);\n                if (pathparts.length > 0 && pathparts[0].length() > 0) {\n                    for (String pe: pathparts) {\n                        if (pe.length() > 0) q.append(\" AND \").append(CollectionSchema.url_paths_sxt.getSolrFieldName()).append(\":\\\"\").append(pe).append('\\\"');\n                    }\n                } else {\n                    if (facetcount > 1000 || post.containsKey(\"nepr\")) {\n                        q.append(\" AND \").append(CollectionSchema.url_paths_sxt.getSolrFieldName()).append(\":[* TO *]\");\n                    }\n                }\n                BlockingQueue<SolrDocument> docs = fulltext.getDefaultConnector().concurrentDocumentsByQuery(q.toString(), 0, 100000, TIMEOUT, 100,\n                        CollectionSchema.id.getSolrFieldName(),\n                        CollectionSchema.sku.getSolrFieldName(),\n                        CollectionSchema.failreason_s.getSolrFieldName(),\n                        CollectionSchema.failtype_s.getSolrFieldName(),\n                        CollectionSchema.inboundlinks_protocol_sxt.getSolrFieldName(),\n                        CollectionSchema.inboundlinks_urlstub_sxt.getSolrFieldName(),\n                        CollectionSchema.outboundlinks_protocol_sxt.getSolrFieldName(),\n                        CollectionSchema.outboundlinks_urlstub_sxt.getSolrFieldName(),\n                        CollectionSchema.clickdepth_i.getSolrFieldName(),\n                        CollectionSchema.references_i.getSolrFieldName(),\n                        CollectionSchema.references_internal_i.getSolrFieldName(),\n                        CollectionSchema.references_external_i.getSolrFieldName(),\n                        CollectionSchema.references_exthosts_i.getSolrFieldName(),\n                        CollectionSchema.cr_host_chance_d.getSolrFieldName(),\n                        CollectionSchema.cr_host_norm_i.getSolrFieldName()   \n                        );\n                SolrDocument doc;\n                Set<String> storedDocs = new HashSet<String>();\n                Map<String, FailType> errorDocs = new HashMap<String, FailType>();\n                Set<String> inboundLinks = new HashSet<String>();\n                Map<String, ReversibleScoreMap<String>> outboundHosts = new HashMap<String, ReversibleScoreMap<String>>();\n                Map<String, InfoCacheEntry> infoCache = new HashMap<String, InfoCacheEntry>();\n                int hostsize = 0;\n                final List<String> deleteIDs = new ArrayList<String>();\n                final Collection<String> reloadURLs = new ArrayList<String>();\n                final Set<String> reloadURLCollection = new HashSet<String>();\n                long timeoutList = System.currentTimeMillis() + TIMEOUT;\n                long timeoutReferences = System.currentTimeMillis() + 6000;\n                ReferenceReportCache rrCache = sb.index.getReferenceReportCache();\n                while ((doc = docs.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                    String u = (String) doc.getFieldValue(CollectionSchema.sku.getSolrFieldName());\n                    String errortype = (String) doc.getFieldValue(CollectionSchema.failtype_s.getSolrFieldName());\n                    FailType error = errortype == null ? null : FailType.valueOf(errortype);\n                    String ids = (String) doc.getFieldValue(CollectionSchema.id.getSolrFieldName());\n                    infoCache.put(ids, new InfoCacheEntry(sb.index.fulltext(), rrCache, doc, ids, System.currentTimeMillis() < timeoutReferences));\n                    if (u.startsWith(path)) {\n                        if (delete) {\n                            deleteIDs.add(ids);\n                        } else {\n                            if (error == null) storedDocs.add(u); else {\n                                if (reload404 && error == FailType.fail) {\n                                    ArrayList<String> collections = (ArrayList<String>) doc.getFieldValue(CollectionSchema.collection_sxt.getSolrFieldName());\n                                    if (collections != null) reloadURLCollection.addAll(collections);\n                                    reloadURLs.add(u);\n                                }\n                                if (admin) errorDocs.put(u, error);\n                            }\n                        }\n                    } else if (complete) {\n                        if (error == null) storedDocs.add(u); else {\n                            if (admin) errorDocs.put(u, error);\n                        }\n                    }\n                    if ((complete || u.startsWith(path)) && !storedDocs.contains(u)) inboundLinks.add(u); // add the current link\n                    if (error == null) {\n                        hostsize++;\n                        // collect inboundlinks to browse the host\n                        Iterator<String> links = URIMetadataNode.getLinks(doc, true);\n                        while (links.hasNext()) {\n                            u = links.next();\n                            if ((complete || u.startsWith(path)) && !storedDocs.contains(u)) inboundLinks.add(u);\n                        }\n                        \n                        // collect referrer links\n                        links = URIMetadataNode.getLinks(doc, false);\n                        while (links.hasNext()) {\n                            u = links.next();\n                            try {\n                                MultiProtocolURL mu = new MultiProtocolURL(u);\n                                if (mu.getHost() != null) {\n                                    ReversibleScoreMap<String> lks = outboundHosts.get(mu.getHost());\n                                    if (lks == null) {\n                                        lks = new ClusteredScoreMap<String>(UTF8.insensitiveUTF8Comparator);\n                                        outboundHosts.put(mu.getHost(), lks);\n                                    }\n                                    lks.set(u, u.length());\n                                }\n                            } catch (final MalformedURLException e) {}\n                        }\n                    }\n                    if (System.currentTimeMillis() > timeoutList) break;\n                }\n                if (deleteIDs.size() > 0) sb.remove(deleteIDs);\n                if (reloadURLs.size() > 0) {\n                    final Map<String, Pattern> cm = new LinkedHashMap<String, Pattern>();\n                    for (String collection: reloadURLCollection) cm.put(collection, QueryParams.catchall_pattern);\n                    sb.reload(reloadURLs, cm.size() > 0 ? cm : CrawlProfile.collectionParser(\"user\"), false);\n                }\n                \n                // collect from crawler\n                List<Request> domainStackReferences = (admin) ? sb.crawlQueues.noticeURL.getDomainStackReferences(StackType.LOCAL, host, 1000, 3000) : new ArrayList<Request>(0);\n                Set<String> loadingLinks = new HashSet<String>();\n                for (Request crawlEntry: domainStackReferences) loadingLinks.add(crawlEntry.url().toNormalform(true));\n                \n                // now combine all lists into one\n                Map<String, StoreType> files = new HashMap<String, StoreType>();\n                for (String u: storedDocs) files.put(u, StoreType.INDEX);\n                for (Map.Entry<String, FailType> e: errorDocs.entrySet()) files.put(e.getKey(), e.getValue() == FailType.fail ? StoreType.FAILED : StoreType.EXCLUDED);\n                for (String u: inboundLinks) if (!files.containsKey(u)) files.put(u, StoreType.LINK);\n                for (String u: loadingLinks) if (u.startsWith(path) && !files.containsKey(u)) files.put(u, StoreType.LINK);\n                ConcurrentLog.info(\"HostBrowser\", \"collected \" + files.size() + \" urls for path \" + path);\n\n                // distinguish files and folders\n                Map<String, Object> list = new TreeMap<String, Object>(); // a directory list; if object is boolean, its a file; if its a int[], then its a folder\n                int pl = path.length();\n                String file;\n                for (Map.Entry<String, StoreType> entry: files.entrySet()) {\n                    if (entry.getKey().length() < pl) continue; // this is not inside the path\n                    if (!entry.getKey().startsWith(path)) continue;\n                    file = entry.getKey().substring(pl);\n                    StoreType type = entry.getValue();\n                    p = file.indexOf('/');\n                    if (p < 0) {\n                        // this is a file\n                        list.put(entry.getKey(), type); // StoreType value: this is a file; true -> file is in index; false -> not in index, maybe in crawler\n                    } else {\n                        // this is a directory path or a file in a subdirectory\n                        String remainingPath = file.substring(0, p + 1);\n                        if (complete && remainingPath.indexOf('.') > 0) {\n                            list.put(entry.getKey(), type); // StoreType value: this is a file\n                        } else {\n                            String dir = path + remainingPath;\n                            Object c = list.get(dir);\n                            if (c == null) {\n                                int[] linkedStoredIncrawlerError = new int[]{0,0,0,0,0};\n                                if (type == StoreType.LINK) linkedStoredIncrawlerError[0]++;\n                                if (type == StoreType.INDEX) linkedStoredIncrawlerError[1]++;\n                                if (loadingLinks.contains(entry.getKey())) linkedStoredIncrawlerError[2]++;\n                                if (errorDocs.containsKey(entry.getKey())) linkedStoredIncrawlerError[errorDocs.get(entry.getKey()) == FailType.excl ? 3 : 4]++;\n                                list.put(dir, linkedStoredIncrawlerError);\n                            } else if (c instanceof int[]) {\n                                if (type == StoreType.LINK) ((int[]) c)[0]++;\n                                if (type == StoreType.INDEX) ((int[]) c)[1]++;\n                                if (loadingLinks.contains(entry.getKey())) ((int[]) c)[2]++;\n                                if (errorDocs.containsKey(entry.getKey())) ((int[]) c)[errorDocs.get(entry.getKey()) == FailType.excl ? 3 : 4]++;\n                            }\n                        }\n                    }\n                }\n                \n                int maxcount = 1000;\n                int c = 0;\n                // first list only folders\n                int filecounter = 0;\n                for (Map.Entry<String, Object> entry: list.entrySet()) {\n                    if ((entry.getValue() instanceof StoreType)) {\n                        filecounter++;\n                    } else {\n                        // this is a folder\n                        prop.put(\"files_list_\" + c + \"_type\", 1);\n                        prop.putHTML(\"files_list_\" + c + \"_type_url\", entry.getKey());\n                        int linked = ((int[]) entry.getValue())[0];\n                        int stored = ((int[]) entry.getValue())[1];\n                        int crawler = ((int[]) entry.getValue())[2];\n                        int excl = ((int[]) entry.getValue())[3];\n                        int error = ((int[]) entry.getValue())[4];\n                        prop.put(\"files_list_\" + c + \"_type_stored\", stored);\n                        prop.put(\"files_list_\" + c + \"_type_linked\", linked);\n                        prop.put(\"files_list_\" + c + \"_type_pendingVisible\", crawler > 0 ? 1 : 0);\n                        prop.put(\"files_list_\" + c + \"_type_pending\", crawler);\n                        prop.put(\"files_list_\" + c + \"_type_excludedVisible\", excl > 0 ? 1 : 0);\n                        prop.put(\"files_list_\" + c + \"_type_excluded\", excl);\n                        prop.put(\"files_list_\" + c + \"_type_failedVisible\", error > 0 ? 1 : 0);\n                        prop.put(\"files_list_\" + c + \"_type_failed\", error);\n                        if (++c >= maxcount) break;\n                    }\n                }\n                // then list files\n                for (Map.Entry<String, Object> entry: list.entrySet()) {\n                    if (entry.getValue() instanceof StoreType) {\n                        // this is a file\n                        prop.put(\"files_list_\" + c + \"_type\", 0);\n                        prop.putHTML(\"files_list_\" + c + \"_type_url\", entry.getKey());\n                        StoreType type = (StoreType) entry.getValue();\n                        try {uri = new DigestURL(entry.getKey());} catch (final MalformedURLException e) {uri = null;}\n                        HarvestProcess process = uri == null ? null : sb.crawlQueues.exists(uri.hash());\n                        boolean loading = load.equals(entry.getKey()) || (process != null && process != HarvestProcess.ERRORS);\n                        boolean error =  process == HarvestProcess.ERRORS || type == StoreType.EXCLUDED || type == StoreType.FAILED;\n                        boolean dc = type != StoreType.INDEX && !error && !loading && list.containsKey(entry.getKey() + \"/\");\n                        if (!dc) {\n                            prop.put(\"files_list_\" + c + \"_type_stored\", type == StoreType.INDEX ? 1 : error ? 3 : loading ? 2 : 0 /*linked*/);\n                            if (type == StoreType.INDEX) {\n                                String ids = ASCII.String(uri.hash());\n                                InfoCacheEntry ice = infoCache.get(ids);\n                                prop.put(\"files_list_\" + c + \"_type_stored_comment\", ice.toString()); // ice.toString() contains html, therefore do not use putHTML here\n                            }\n                            prop.put(\"files_list_\" + c + \"_type_stored_load\", loadRight ? 1 : 0);\n                            if (error) {\n                                FailType failType = errorDocs.get(entry.getKey());\n                                if (failType == null) {\n                                    // maybe this is only in the errorURL\n                                    FailDoc faildoc = sb.crawlQueues.errorURL.get(ASCII.String(uri.hash()));\n                                    prop.putHTML(\"files_list_\" + c + \"_type_stored_error\", process == HarvestProcess.ERRORS && faildoc != null ? faildoc.getFailReason() : \"unknown error\");\n                                } else {\n                                    String ids = ASCII.String(uri.hash());\n                                    InfoCacheEntry ice = infoCache.get(ids);\n                                    prop.put(\"files_list_\" + c + \"_type_stored_error\", failType == FailType.excl ? \"excluded from indexing\" : \"load fail\" + (ice == null ? \"\" : \"; \" + ice.toString()));\n                                }\n                            }\n                            if (loadRight) {\n                                prop.putHTML(\"files_list_\" + c + \"_type_stored_load_url\", entry.getKey());\n                                prop.putHTML(\"files_list_\" + c + \"_type_stored_load_path\", path);\n                            }\n                            if (++c >= maxcount) break;\n                        }\n                    }\n                }\n                prop.put(\"files_list\", c);\n                prop.putHTML(\"files_path\", path);\n                prop.put(\"files_hostsize\", hostsize);\n                prop.put(\"files_subpathloadsize\", storedDocs.size());\n                prop.put(\"files_subpathdetectedsize\", filecounter - storedDocs.size());\n                prop.put(\"files\", 1);\n\n                // generate inbound-links table\n                StructureEntry struct = sb.webStructure.incomingReferences(hosthash);\n                if (struct != null && struct.references.size() > 0) {\n                    maxcount = 200;\n                    ReversibleScoreMap<String> score = new ClusteredScoreMap<String>(UTF8.insensitiveUTF8Comparator);\n                    for (Map.Entry<String, Integer> entry: struct.references.entrySet()) score.set(entry.getKey(), entry.getValue());\n                    c = 0;\n                    Iterator<String> i = score.keys(false);\n                    while (i.hasNext() && c < maxcount) {\n                        host = i.next();\n                        prop.putHTML(\"inbound_list_\" + c + \"_host\", sb.webStructure.hostHash2hostName(host));\n                        prop.put(\"inbound_list_\" + c + \"_count\", score.get(host));\n                        c++;\n                    }\n                    prop.put(\"inbound_list\", c);\n                    prop.put(\"inbound\", 1);\n                } else {\n                    prop.put(\"inbound\", 0);\n                }\n                \n                // generate outbound-links table\n                if (outboundHosts.size() > 0) {\n                    maxcount = 200;\n                    ReversibleScoreMap<String> score = new ClusteredScoreMap<String>(UTF8.insensitiveUTF8Comparator);\n                    for (Map.Entry<String, ReversibleScoreMap<String>> entry: outboundHosts.entrySet()) score.set(entry.getKey(), entry.getValue().size());\n                    c = 0;\n                    Iterator<String> i = score.keys(false);\n                    while (i.hasNext() && c < maxcount) {\n                        host = i.next();\n                        prop.putHTML(\"outbound_list_\" + c + \"_host\", host);\n                        prop.put(\"outbound_list_\" + c + \"_count\", score.get(host));\n                        prop.put(\"outbound_list_\" + c + \"_link\", outboundHosts.get(host).getMinKey());\n                        c++;\n                    }\n                    prop.put(\"outbound_list\", c);\n                    prop.put(\"outbound\", 1);\n                } else {\n                    prop.put(\"outbound\", 0);\n                }\n                \n            } catch (final Throwable e) {\n                ConcurrentLog.logException(e);\n            }\n        }\n\n        // return rewrite properties\n        prop.putNum(\"ucount\", fulltext.collectionSize());\n        return prop;\n    }","commit_id":"da5d4128bfbee8c06ea9f1921c9414b6f2471ddf","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public List list() {\n        if (hibernateProjectionList != null) {\n            this.criteria.setProjection(hibernateProjectionList.getHibernateProjectionList());\n        }\n        criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);\n        return criteria.list();\n    }","id":89056,"modified_method":"@Override\n    public List list() {\n        int projectionLength = 0;\n        if (hibernateProjectionList != null) {\n            org.hibernate.criterion.ProjectionList projectionList = hibernateProjectionList.getHibernateProjectionList();\n            projectionLength = projectionList.getLength();\n            this.criteria.setProjection(projectionList);\n        }\n\n\n        if(projectionLength<2)\n            criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);\n        return criteria.list();\n    }","commit_id":"8598e2d423c425acdc18025e99531ff6d0c71330","url":"https://github.com/grails/grails-core"},{"original_method":"@SuppressWarnings(\"hiding\")\n    @Override\n    protected List executeQuery(PersistentEntity entity, Junction criteria) {\n        if (hibernateProjectionList != null) {\n            this.criteria.setProjection(hibernateProjectionList.getHibernateProjectionList());\n        }\n        this.criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);\n        return this.criteria.list();\n    }","id":89057,"modified_method":"@SuppressWarnings(\"hiding\")\n    @Override\n    protected List executeQuery(PersistentEntity entity, Junction criteria) {\n        return list();\n    }","commit_id":"8598e2d423c425acdc18025e99531ff6d0c71330","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public List list() {\n        if (hibernateProjectionList != null) {\n            this.criteria.setProjection(hibernateProjectionList.getHibernateProjectionList());\n        }\n        criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);\n        return criteria.list();\n    }","id":89058,"modified_method":"@Override\n    public List list() {\n        int projectionLength = 0;\n        if (hibernateProjectionList != null) {\n            org.hibernate.criterion.ProjectionList projectionList = hibernateProjectionList.getHibernateProjectionList();\n            projectionLength = projectionList.getLength();\n            this.criteria.setProjection(projectionList);\n        }\n\n\n        if(projectionLength<2)\n            criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);\n        return criteria.list();\n    }","commit_id":"42fb5566b21d8235b0814dc27885946917586a11","url":"https://github.com/grails/grails-core"},{"original_method":"@SuppressWarnings(\"hiding\")\n    @Override\n    protected List executeQuery(PersistentEntity entity, Junction criteria) {\n        if (hibernateProjectionList != null) {\n            this.criteria.setProjection(hibernateProjectionList.getHibernateProjectionList());\n        }\n        this.criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);\n        return this.criteria.list();\n    }","id":89059,"modified_method":"@SuppressWarnings(\"hiding\")\n    @Override\n    protected List executeQuery(PersistentEntity entity, Junction criteria) {\n        return list();\n    }","commit_id":"42fb5566b21d8235b0814dc27885946917586a11","url":"https://github.com/grails/grails-core"},{"original_method":"public Object invokeMethod(String name, Object obj) {\n        Object[] args = obj.getClass().isArray() ? (Object[])obj : new Object[]{obj};\n\n        \n        if(isCriteriaConstructionMethod(name, args)) {\n\n            if(this.criteria != null) {\n                throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n            }\n\n\n            if (name.equals(GET_CALL)) {\n                this.uniqueResult = true;\n            }\n            else if (name.equals(SCROLL_CALL)) {\n                this.scroll = true;\n            }\n            else if (name.equals(COUNT_CALL)) {\n                this.count = true;\n            }\n            else if (name.equals(LIST_DISTINCT_CALL)) {\n                this.resultTransformer = CriteriaSpecification.DISTINCT_ROOT_ENTITY;\n            }\n\n            createCriteriaInstance();\n\n            // Check for pagination params\n            if(name.equals(LIST_CALL) && args.length == 2) {\n            \tpaginationEnabledList = true;\n\t\t\t\torderEntries = new ArrayList<Order>();\n                invokeClosureNode(args[1]);\n            } else {\n                invokeClosureNode(args[0]);\n            }\n\n\n           if(resultTransformer != null) {\n                this.criteria.setResultTransformer(resultTransformer);\n            }\n            Object result;\n            if(!uniqueResult) {\n                if(scroll) {\n                    result = this.criteria.scroll();\n                }\n                else if(count) {\n                    this.criteria.setProjection(Projections.rowCount());\n                    result = this.criteria.uniqueResult();\n                } else if(paginationEnabledList) {\n                    // Calculate how many results there are in total. This has been\n                    // moved to before the 'list()' invocation to avoid any \"ORDER\n                    // BY\" clause added by 'populateArgumentsForCriteria()', otherwise\n                    // an exception is thrown for non-string sort fields (GRAILS-2690).\n                    this.criteria.setFirstResult(0);\n                    this.criteria.setMaxResults(Integer.MAX_VALUE);\n                    this.criteria.setProjection(Projections.rowCount());\n                    int totalCount = ((Integer)this.criteria.uniqueResult()).intValue();\n\n                    // Drop the projection, add settings for the pagination parameters,\n                    // and then execute the query.\n                    this.criteria.setProjection(null);\n\t\t\t\t\tfor(Iterator<Order> it = orderEntries.iterator();it.hasNext();){\n\t\t\t\t\t\tthis.criteria.addOrder(it.next());\n\t\t\t\t\t}\n                    this.criteria.setResultTransformer(CriteriaSpecification.ROOT_ENTITY);\n                    GrailsHibernateUtil.populateArgumentsForCriteria(targetClass, this.criteria, (Map)args[0]);\n                    PagedResultList pagedRes = new PagedResultList(this.criteria.list());\n\n                    // Updated the paged results with the total number of records\n                    // calculated previously.\n                    pagedRes.setTotalCount(totalCount);\n                    result = pagedRes;\n                } else {\n                    result = this.criteria.list();\n                }\n            }\n            else {\n                result = GrailsHibernateUtil.unwrapIfProxy(this.criteria.uniqueResult());\n            }\n            if(!this.participate) {\n                this.hibernateSession.close();\n            }\n            return result;\n\n        }\n        else {\n            if(criteria==null) createCriteriaInstance();\n\n            MetaMethod metaMethod = getMetaClass().getMetaMethod(name, args);\n            if(metaMethod != null) {\n                 return metaMethod.invoke(this, args);\n            }\n\n            metaMethod = criteriaMetaClass.getMetaMethod(name, args);\n            if(metaMethod != null) {\n                 return metaMethod.invoke(criteria, args);\n            }\n            metaMethod = criteriaMetaClass.getMetaMethod(GrailsClassUtils.getSetterName(name), args);\n            if(metaMethod != null) {\n                 return metaMethod.invoke(criteria, args);\n            }\n           else if(args.length == 1 && args[0] instanceof Closure) {\n                if(name.equals( AND ) ||\n                        name.equals( OR ) ||\n                        name.equals( NOT ) ) {\n                    if(this.criteria == null)\n                        throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n\n                    this.logicalExpressionStack.add(new LogicalExpression(name));\n                    invokeClosureNode(args[0]);\n\n                    LogicalExpression logicalExpression = logicalExpressionStack.remove(logicalExpressionStack.size()-1);\n                    addToCriteria(logicalExpression.toCriterion());\n\n                    return name;\n                } else if(name.equals( PROJECTIONS ) && args.length == 1 && (args[0] instanceof Closure)) {\n                    if(this.criteria == null)\n                        throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n\n                    this.projectionList = Projections.projectionList();\n                    invokeClosureNode(args[0]);\n\n                    if(this.projectionList != null && this.projectionList.getLength() > 0) {\n                        this.criteria.setProjection(this.projectionList);\n                    }\n\n\n                    return name;\n                }\n                else if(targetBean.isReadableProperty(name.toString())) {\n                    ClassMetadata meta = sessionFactory.getClassMetadata(targetBean.getWrappedClass());\n                    Type type = meta.getPropertyType(name.toString());\n                    if (type.isAssociationType()) {\n                        String otherSideEntityName =\n                                ((AssociationType) type).getAssociatedEntityName((SessionFactoryImplementor) sessionFactory);\n                        Class oldTargetClass = targetClass;\n                        targetClass = sessionFactory.getClassMetadata(otherSideEntityName).getMappedClass(EntityMode.POJO);\n                        BeanWrapper oldTargetBean = targetBean;\n                        targetBean = new BeanWrapperImpl(BeanUtils.instantiateClass(targetClass));\n                        associationStack.add(name.toString());\n                        final String associationPath = getAssociationPath();\n                        createAliasIfNeccessary(name, associationPath);\n                        // the criteria within an association node are grouped with an implicit AND\n                        logicalExpressionStack.add(new LogicalExpression(AND));\n                        invokeClosureNode(args[0]);\n                        aliasStack.remove(aliasStack.size() - 1);\n                        if(!aliasInstanceStack.isEmpty()) {\n                            aliasInstanceStack.remove(aliasInstanceStack.size() - 1);\n                        }\n                        LogicalExpression logicalExpression = logicalExpressionStack.remove(logicalExpressionStack.size()-1);\n                        if (!logicalExpression.args.isEmpty()) {\n                            addToCriteria(logicalExpression.toCriterion());\n                        }\n                        associationStack.remove(associationStack.size()-1);\n                        targetClass = oldTargetClass;\n                        targetBean = oldTargetBean;\n                        return name;\n                    }\n                }\n            }\n            else if(args.length == 1 && args[0] != null) {\n                if(this.criteria == null)\n                    throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n\n                Object value = args[0];\n                Criterion c = null;\n                if(name.equals(ID_EQUALS)) {\n                    return eq(\"id\", value);\n                }\n                else {\n\n                    if(\tname.equals( IS_NULL ) ||\n                            name.equals( IS_NOT_NULL ) ||\n                            name.equals( IS_EMPTY ) ||\n                            name.equals( IS_NOT_EMPTY )) {\n                        if(!(value instanceof String))\n                            throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] with value [\"+value+\"] requires a String value.\"));\n                        String propertyName = calculatePropertyName((String)value);\n                        if(name.equals( IS_NULL )) {\n                            c = Restrictions.isNull( propertyName ) ;\n                        }\n                        else if(name.equals( IS_NOT_NULL )) {\n                            c = Restrictions.isNotNull( propertyName );\n                        }\n                        else if(name.equals( IS_EMPTY )) {\n                            c = Restrictions.isEmpty( propertyName );\n                        }\n                        else if(name.equals( IS_NOT_EMPTY )) {\n                            c = Restrictions.isNotEmpty(propertyName );\n                        }\n                    }\n                }\n                if(c != null) {\n                    return addToCriteria(c);\n                }\n\n            }\n        }\n\n        throw new MissingMethodException(name, getClass(), args) ;\n    }","id":89060,"modified_method":"public Object invokeMethod(String name, Object obj) {\n        Object[] args = obj.getClass().isArray() ? (Object[])obj : new Object[]{obj};\n\n        if(paginationEnabledList && SET_RESULT_TRANSFORMER_CALL.equals(name) && args.length == 1 && args[0] instanceof ResultTransformer) {\n    \t\tresultTransformer = (ResultTransformer) args[0];\n    \t\treturn null;\n    \t}\n\n        if(isCriteriaConstructionMethod(name, args)) {\n\n            if(this.criteria != null) {\n                throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n            }\n\n\n            if (name.equals(GET_CALL)) {\n                this.uniqueResult = true;\n            }\n            else if (name.equals(SCROLL_CALL)) {\n                this.scroll = true;\n            }\n            else if (name.equals(COUNT_CALL)) {\n                this.count = true;\n            }\n            else if (name.equals(LIST_DISTINCT_CALL)) {\n                this.resultTransformer = CriteriaSpecification.DISTINCT_ROOT_ENTITY;\n            }\n\n            createCriteriaInstance();\n\n            // Check for pagination params\n            if(name.equals(LIST_CALL) && args.length == 2) {\n            \tpaginationEnabledList = true;\n\t\t\t\torderEntries = new ArrayList<Order>();\n                invokeClosureNode(args[1]);\n            } else {\n                invokeClosureNode(args[0]);\n            }\n\n\n           if(resultTransformer != null) {\n                this.criteria.setResultTransformer(resultTransformer);\n            }\n            Object result;\n            if(!uniqueResult) {\n                if(scroll) {\n                    result = this.criteria.scroll();\n                }\n                else if(count) {\n                    this.criteria.setProjection(Projections.rowCount());\n                    result = this.criteria.uniqueResult();\n                } else if(paginationEnabledList) {\n                    // Calculate how many results there are in total. This has been\n                    // moved to before the 'list()' invocation to avoid any \"ORDER\n                    // BY\" clause added by 'populateArgumentsForCriteria()', otherwise\n                    // an exception is thrown for non-string sort fields (GRAILS-2690).\n                    this.criteria.setFirstResult(0);\n                    this.criteria.setMaxResults(Integer.MAX_VALUE);\n                    this.criteria.setProjection(Projections.rowCount());\n                    int totalCount = ((Integer)this.criteria.uniqueResult()).intValue();\n\n                    // Drop the projection, add settings for the pagination parameters,\n                    // and then execute the query.\n                    this.criteria.setProjection(null);\n\t\t\t\t\tfor(Iterator<Order> it = orderEntries.iterator();it.hasNext();){\n\t\t\t\t\t\tthis.criteria.addOrder(it.next());\n\t\t\t\t\t}\n\t\t\t\t\tif(resultTransformer == null) {\n\t\t\t\t\t\tthis.criteria.setResultTransformer(CriteriaSpecification.ROOT_ENTITY);\n\t\t\t\t\t} else if(paginationEnabledList) {\n\t\t\t\t\t\t// relevant to GRAILS-5692\n\t\t\t\t\t\tthis.criteria.setResultTransformer(resultTransformer);\n\t\t\t\t\t}\n                    GrailsHibernateUtil.populateArgumentsForCriteria(targetClass, this.criteria, (Map)args[0]);\n                    PagedResultList pagedRes = new PagedResultList(this.criteria.list());\n\n                    // Updated the paged results with the total number of records\n                    // calculated previously.\n                    pagedRes.setTotalCount(totalCount);\n                    result = pagedRes;\n                } else {\n                    result = this.criteria.list();\n                }\n            }\n            else {\n                result = GrailsHibernateUtil.unwrapIfProxy(this.criteria.uniqueResult());\n            }\n            if(!this.participate) {\n                this.hibernateSession.close();\n            }\n            return result;\n\n        }\n        else {\n            if(criteria==null) createCriteriaInstance();\n\n            MetaMethod metaMethod = getMetaClass().getMetaMethod(name, args);\n            if(metaMethod != null) {\n                 return metaMethod.invoke(this, args);\n            }\n\n            metaMethod = criteriaMetaClass.getMetaMethod(name, args);\n            if(metaMethod != null) {\n                 return metaMethod.invoke(criteria, args);\n            }\n            metaMethod = criteriaMetaClass.getMetaMethod(GrailsClassUtils.getSetterName(name), args);\n            if(metaMethod != null) {\n                 return metaMethod.invoke(criteria, args);\n            }\n           else if(args.length == 1 && args[0] instanceof Closure) {\n                if(name.equals( AND ) ||\n                        name.equals( OR ) ||\n                        name.equals( NOT ) ) {\n                    if(this.criteria == null)\n                        throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n\n                    this.logicalExpressionStack.add(new LogicalExpression(name));\n                    invokeClosureNode(args[0]);\n\n                    LogicalExpression logicalExpression = logicalExpressionStack.remove(logicalExpressionStack.size()-1);\n                    addToCriteria(logicalExpression.toCriterion());\n\n                    return name;\n                } else if(name.equals( PROJECTIONS ) && args.length == 1 && (args[0] instanceof Closure)) {\n                    if(this.criteria == null)\n                        throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n\n                    this.projectionList = Projections.projectionList();\n                    invokeClosureNode(args[0]);\n\n                    if(this.projectionList != null && this.projectionList.getLength() > 0) {\n                        this.criteria.setProjection(this.projectionList);\n                    }\n\n\n                    return name;\n                }\n                else if(targetBean.isReadableProperty(name.toString())) {\n                    ClassMetadata meta = sessionFactory.getClassMetadata(targetBean.getWrappedClass());\n                    Type type = meta.getPropertyType(name.toString());\n                    if (type.isAssociationType()) {\n                        String otherSideEntityName =\n                                ((AssociationType) type).getAssociatedEntityName((SessionFactoryImplementor) sessionFactory);\n                        Class oldTargetClass = targetClass;\n                        targetClass = sessionFactory.getClassMetadata(otherSideEntityName).getMappedClass(EntityMode.POJO);\n                        BeanWrapper oldTargetBean = targetBean;\n                        targetBean = new BeanWrapperImpl(BeanUtils.instantiateClass(targetClass));\n                        associationStack.add(name.toString());\n                        final String associationPath = getAssociationPath();\n                        createAliasIfNeccessary(name, associationPath);\n                        // the criteria within an association node are grouped with an implicit AND\n                        logicalExpressionStack.add(new LogicalExpression(AND));\n                        invokeClosureNode(args[0]);\n                        aliasStack.remove(aliasStack.size() - 1);\n                        if(!aliasInstanceStack.isEmpty()) {\n                            aliasInstanceStack.remove(aliasInstanceStack.size() - 1);\n                        }\n                        LogicalExpression logicalExpression = logicalExpressionStack.remove(logicalExpressionStack.size()-1);\n                        if (!logicalExpression.args.isEmpty()) {\n                            addToCriteria(logicalExpression.toCriterion());\n                        }\n                        associationStack.remove(associationStack.size()-1);\n                        targetClass = oldTargetClass;\n                        targetBean = oldTargetBean;\n                        return name;\n                    }\n                }\n            }\n            else if(args.length == 1 && args[0] != null) {\n                if(this.criteria == null)\n                    throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] not supported here\"));\n\n                Object value = args[0];\n                Criterion c = null;\n                if(name.equals(ID_EQUALS)) {\n                    return eq(\"id\", value);\n                }\n                else {\n\n                    if(\tname.equals( IS_NULL ) ||\n                            name.equals( IS_NOT_NULL ) ||\n                            name.equals( IS_EMPTY ) ||\n                            name.equals( IS_NOT_EMPTY )) {\n                        if(!(value instanceof String))\n                            throwRuntimeException( new IllegalArgumentException(\"call to [\" + name + \"] with value [\"+value+\"] requires a String value.\"));\n                        String propertyName = calculatePropertyName((String)value);\n                        if(name.equals( IS_NULL )) {\n                            c = Restrictions.isNull( propertyName ) ;\n                        }\n                        else if(name.equals( IS_NOT_NULL )) {\n                            c = Restrictions.isNotNull( propertyName );\n                        }\n                        else if(name.equals( IS_EMPTY )) {\n                            c = Restrictions.isEmpty( propertyName );\n                        }\n                        else if(name.equals( IS_NOT_EMPTY )) {\n                            c = Restrictions.isNotEmpty(propertyName );\n                        }\n                    }\n                }\n                if(c != null) {\n                    return addToCriteria(c);\n                }\n\n            }\n        }\n\n        throw new MissingMethodException(name, getClass(), args) ;\n    }","commit_id":"215fa6ce54814db5de189dabb658db20fd4f8499","url":"https://github.com/grails/grails-core"},{"original_method":"public void chartDot(final int dimension_x, final int dimension_y, final float coord_x, final int coord_y, final int dotsize, final String anot, final int anotAngle) {\n        final int x = (int) ((coord_x - this.offsets[dimension_x]) * this.pixels[dimension_x] / this.scales[dimension_x]);\n        final int y = (coord_y - this.offsets[dimension_y]) * this.pixels[dimension_y] / this.scales[dimension_y];\n        if (dotsize == 1) plot(this.leftborder + x, this.height - this.bottomborder - y, 100);\n                      else dot(this.leftborder + x, this.height - this.bottomborder - y, dotsize, true, 100);\n        if (anot != null) PrintTool.print(this, this.leftborder + x + dotsize + 2 + ((anotAngle == 315) ? -9 : 0), this.height - this.bottomborder - y + ((anotAngle == 315) ? -3 : 0), anotAngle, anot, (anotAngle == 0) ? (anot.length() * 6 + x > this.width ? 1 : -1) : ((anotAngle == 315) ? 1 : 0));\n    }","id":89061,"modified_method":"public void chartDot(final int dimension_x, final int dimension_y, final float coord_x, final int coord_y, final int dotsize, final String anot, final int anotAngle) {\n        final int x = (int) ((coord_x - this.offsets[dimension_x]) * this.pixels[dimension_x] / this.scales[dimension_x]);\n        assert this.scales[dimension_y] != 0;\n        final int y = (coord_y - this.offsets[dimension_y]) * this.pixels[dimension_y] / this.scales[dimension_y];\n        if (dotsize == 1) plot(this.leftborder + x, this.height - this.bottomborder - y, 100);\n                      else dot(this.leftborder + x, this.height - this.bottomborder - y, dotsize, true, 100);\n        if (anot != null) PrintTool.print(this, this.leftborder + x + dotsize + 2 + ((anotAngle == 315) ? -9 : 0), this.height - this.bottomborder - y + ((anotAngle == 315) ? -3 : 0), anotAngle, anot, (anotAngle == 0) ? (anot.length() * 6 + x > this.width ? 1 : -1) : ((anotAngle == 315) ? 1 : 0));\n    }","commit_id":"35c24608cc217913aee9dd2919f16b2b8610b079","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void chartLine(final int dimension_x, final int dimension_y, final int coord_x1, final int coord_y1, final int coord_x2, final int coord_y2) {\n        final int x1 = (coord_x1 - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y1 = (coord_y1 - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        final int x2 = (coord_x2 - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y2 = (coord_y2 - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        line(leftborder + x1, height - bottomborder - y1, leftborder + x2, height - bottomborder - y2, 100);\n    }","id":89062,"modified_method":"public void chartLine(final int dimension_x, final int dimension_y, final int coord_x1, final int coord_y1, final int coord_x2, final int coord_y2) {\n        final int x1 = (coord_x1 - this.offsets[dimension_x]) * this.pixels[dimension_x] / this.scales[dimension_x];\n        final int y1 = (coord_y1 - this.offsets[dimension_y]) * this.pixels[dimension_y] / this.scales[dimension_y];\n        final int x2 = (coord_x2 - this.offsets[dimension_x]) * this.pixels[dimension_x] / this.scales[dimension_x];\n        final int y2 = (coord_y2 - this.offsets[dimension_y]) * this.pixels[dimension_y] / this.scales[dimension_y];\n        line(this.leftborder + x1, this.height - this.bottomborder - y1, this.leftborder + x2, this.height - this.bottomborder - y2, 100);\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void drawVerticalScale(final boolean left, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int x = (left) ? leftborder : width - rightborder;\n        int y = height - bottomborder;\n        int s = offset;\n        String s1;\n        int s1max = 0;\n        while (y > topborder) {\n            if ((colorScale != null) && (y > topborder) && (y < (height - bottomborder))) {\n                setColor(colorScale);\n                line(leftborder, y, width - rightborder, y, 100);\n            }\n            setColor(colorNaming);\n            line(x - 3, y, x + 3, y, 100);\n            s1 = (s >= 1000000 && s % 10000 == 0) ? Integer.toString(s / 1000000) + \"M\" : (s >= 1000 && s % 1000 == 0) ? Integer.toString(s / 1000) + \"K\" : Integer.toString(s);\n            if (s1.length() > s1max) s1max = s1.length();\n            PrintTool.print(this, (left) ? leftborder - 4 : width - rightborder + 4, y, 0, s1, (left) ? 1 : -1);\n            y -= pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, (left) ? x - s1max * 6 - 6 : x + s1max * 6 + 9, topborder, 90, name, 1);\n        line(x, topborder - 4, x, height - bottomborder + 4, 100);\n    }","id":89063,"modified_method":"private void drawVerticalScale(final boolean left, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        assert pixelperscale > 0;\n        assert scale > 0;\n        final int x = (left) ? this.leftborder : this.width - this.rightborder;\n        int y = this.height - this.bottomborder;\n        int s = offset;\n        String s1;\n        int s1max = 0;\n        while (y > this.topborder) {\n            if ((colorScale != null) && (y > this.topborder) && (y < (this.height - this.bottomborder))) {\n                setColor(colorScale);\n                line(this.leftborder, y, this.width - this.rightborder, y, 100);\n            }\n            setColor(colorNaming);\n            line(x - 3, y, x + 3, y, 100);\n            s1 = (s >= 1000000 && s % 10000 == 0) ? Integer.toString(s / 1000000) + \"M\" : (s >= 1000 && s % 1000 == 0) ? Integer.toString(s / 1000) + \"K\" : Integer.toString(s);\n            if (s1.length() > s1max) s1max = s1.length();\n            PrintTool.print(this, (left) ? this.leftborder - 4 : this.width - this.rightborder + 4, y, 0, s1, (left) ? 1 : -1);\n            y -= pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, (left) ? x - s1max * 6 - 6 : x + s1max * 6 + 9, this.topborder, 90, name, 1);\n        line(x, this.topborder - 4, x, this.height - this.bottomborder + 4, 100);\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void chartDot(final int dimension_x, final int dimension_y, final int coord_x, final int coord_y, final int dotsize, String anot, int anotAngle) {\n        final int x = (coord_x - offsets[dimension_x]) * pixels[dimension_x] / scales[dimension_x];\n        final int y = (coord_y - offsets[dimension_y]) * pixels[dimension_y] / scales[dimension_y];\n        if (dotsize == 1) plot(leftborder + x, height - bottomborder - y, 100);\n                      else dot(leftborder + x, height - bottomborder - y, dotsize, true, 100);\n        if (anot != null) PrintTool.print(this, leftborder + x + dotsize + 2 + ((anotAngle == 315) ? -9 : 0), height - bottomborder - y + ((anotAngle == 315) ? -3 : 0), anotAngle, anot, (anotAngle == 0) ? -1 : ((anotAngle == 315) ? 1 : 0));\n    }","id":89064,"modified_method":"public void chartDot(final int dimension_x, final int dimension_y, final int coord_x, final int coord_y, final int dotsize, final String anot, final int anotAngle) {\n        final int x = (coord_x - this.offsets[dimension_x]) * this.pixels[dimension_x] / this.scales[dimension_x];\n        final int y = (coord_y - this.offsets[dimension_y]) * this.pixels[dimension_y] / this.scales[dimension_y];\n        if (dotsize == 1) plot(this.leftborder + x, this.height - this.bottomborder - y, 100);\n                      else dot(this.leftborder + x, this.height - this.bottomborder - y, dotsize, true, 100);\n        if (anot != null) PrintTool.print(this, this.leftborder + x + dotsize + 2 + ((anotAngle == 315) ? -9 : 0), this.height - this.bottomborder - y + ((anotAngle == 315) ? -3 : 0), anotAngle, anot, (anotAngle == 0) ? -1 : ((anotAngle == 315) ? 1 : 0));\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void drawHorizontalScale(final boolean top, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int y = (top) ? topborder : height - bottomborder;\n        int x = leftborder;\n        int s = offset;\n        while (x < width - rightborder) {\n            if ((colorScale != null) && (x > leftborder) && (x < (width - rightborder))) {\n                setColor(colorScale);\n                line(x, topborder, x, height - bottomborder, 100);\n            }\n            setColor(colorNaming);\n            line(x, y - 3, x, y + 3, 100);\n            PrintTool.print(this, x, (top) ? y - 3 : y + 9, 0, Integer.toString(s), -1);\n            x += pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, width - rightborder, (top) ? y - 9 : y + 15, 0, name, 1);\n        line(leftborder - 4, y, width - rightborder + 4, y, 100);\n    }","id":89065,"modified_method":"private void drawHorizontalScale(final boolean top, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        final int y = (top) ? this.topborder : this.height - this.bottomborder;\n        int x = this.leftborder;\n        int s = offset;\n        while (x < this.width - this.rightborder) {\n            if ((colorScale != null) && (x > this.leftborder) && (x < (this.width - this.rightborder))) {\n                setColor(colorScale);\n                line(x, this.topborder, x, this.height - this.bottomborder, 100);\n            }\n            setColor(colorNaming);\n            line(x, y - 3, x, y + 3, 100);\n            PrintTool.print(this, x, (top) ? y - 3 : y + 9, 0, Integer.toString(s), -1);\n            x += pixelperscale;\n            s += scale;\n        }\n        setColor(colorNaming);\n        PrintTool.print(this, this.width - this.rightborder, (top) ? y - 9 : y + 15, 0, name, 1);\n        line(this.leftborder - 4, y, this.width - this.rightborder + 4, y, 100);\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void declareDimension(final int dimensionType, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        if ((dimensionType == DIMENSION_LEFT) || (dimensionType == DIMENSION_RIGHT)) {\n            drawVerticalScale((dimensionType == DIMENSION_LEFT), scale, pixelperscale, offset, colorNaming, colorScale, name);\n        }\n        if ((dimensionType == DIMENSION_TOP) || (dimensionType == DIMENSION_BOTTOM)) {\n            drawHorizontalScale((dimensionType == DIMENSION_TOP), scale, pixelperscale, offset, colorNaming, colorScale, name);\n        }\n        scales[dimensionType] = scale;\n        pixels[dimensionType] = pixelperscale;\n        offsets[dimensionType] = offset;\n        colnames[dimensionType] = colorNaming;\n        colscale[dimensionType] = colorScale;\n        tablenames[dimensionType] = name;\n    }","id":89066,"modified_method":"public void declareDimension(final int dimensionType, final int scale, final int pixelperscale, final int offset, final String colorNaming, final String colorScale, final String name) {\n        if ((dimensionType == DIMENSION_LEFT) || (dimensionType == DIMENSION_RIGHT)) {\n            drawVerticalScale((dimensionType == DIMENSION_LEFT), scale, pixelperscale, offset, colorNaming, colorScale, name);\n        }\n        if ((dimensionType == DIMENSION_TOP) || (dimensionType == DIMENSION_BOTTOM)) {\n            drawHorizontalScale((dimensionType == DIMENSION_TOP), scale, pixelperscale, offset, colorNaming, colorScale, name);\n        }\n        this.scales[dimensionType] = scale;\n        this.pixels[dimensionType] = pixelperscale;\n        this.offsets[dimensionType] = offset;\n        this.colnames[dimensionType] = colorNaming;\n        this.colscale[dimensionType] = colorScale;\n        this.tablenames[dimensionType] = name;\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static RasterPlotter respond(final RequestHeader header, serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        \n        if (post == null) post = new serverObjects();\n        \n        final int width = post.getInt(\"width\", 660);\n        final int height = post.getInt(\"height\", 240);\n        \n        return ProfilingGraph.performanceGraph(width, height, sb.indexSegments.URLCount() + \" URLS / \" + sb.indexSegments.RWICount() + \" WORDS IN INDEX / \" + sb.indexSegments.RWIBufferCount() + \" WORDS IN CACHE\");\n    }","id":89067,"modified_method":"public static RasterPlotter respond(final RequestHeader header, serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n\n        if (post == null) post = new serverObjects();\n\n        final int width = post.getInt(\"width\", 660);\n        final int height = post.getInt(\"height\", 240);\n        final boolean showMemory = !post.containsKey(\"nomem\");\n\n        return ProfilingGraph.performanceGraph(width, height, sb.indexSegments.URLCount() + \" URLS / \" + sb.indexSegments.RWICount() + \" WORDS IN INDEX / \" + sb.indexSegments.RWIBufferCount() + \" WORDS IN CACHE\", showMemory);\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static RasterPlotter performanceGraph(final int width, final int height, final String subline) {        \n        // find maximum values for automatic graph dimension adoption\n        final int maxppm = (int) maxPayload(EventTracker.EClass.PPM, 25);\n        final int maxwords = (int) maxPayload(EventTracker.EClass.WORDCACHE, 12000);\n        final long maxbytes = maxPayload(EventTracker.EClass.MEMORY, 110 * 1024 * 1024);\n        final int maxmbytes = (int)(maxbytes / 1024 / 1024);\n        \n        // declare graph and set dimensions\n        final int leftborder = 30;\n        final int rightborder = 30;\n        final int topborder = 20;\n        final int bottomborder = 20;\n        final int leftscale; if(maxwords > 150000) leftscale = maxwords / 150000 * 20000; else leftscale  = 10000;\n        final int rightscale; if (maxmbytes > 1500) rightscale = maxmbytes / 1500 * 200; else rightscale = 100;\n        final int anotscale = 1000;\n        final int bottomscale = 60;\n        final int vspace = height - topborder - bottomborder;\n        final int hspace = width - leftborder - rightborder;\n        final int maxtime = 600;\n        ChartPlotter chart = new ChartPlotter(width, height, \"FFFFFF\", \"000000\", \"AAAAAA\", leftborder, rightborder, topborder, bottomborder, \"YACY PEER PERFORMANCE: MAIN MEMORY, WORD CACHE AND PAGES/MINUTE (PPM)\", subline);\n        chart.declareDimension(ChartPlotter.DIMENSION_BOTTOM, bottomscale, hspace / (maxtime / bottomscale), -maxtime, \"000000\", \"CCCCCC\", \"TIME/SECONDS\");\n        chart.declareDimension(ChartPlotter.DIMENSION_LEFT, leftscale, vspace * leftscale / maxwords, 0, \"008800\", null , \"INDEXING, WORDS IN CACHE\");\n        chart.declareDimension(ChartPlotter.DIMENSION_RIGHT, rightscale, vspace * rightscale / maxmbytes, 0, \"0000FF\", \"CCCCCC\", \"MEMORY/MEGABYTE\");\n        chart.declareDimension(ChartPlotter.DIMENSION_ANOT0, anotscale, vspace * anotscale / maxppm, 0, \"008800\", null , \"PPM [PAGES/MINUTE]\");\n        chart.declareDimension(ChartPlotter.DIMENSION_ANOT1, vspace / 6, vspace / 6, 0, \"888800\", null , \"URL\");\n        \n        // draw chart\n        long time;\n        final long now = System.currentTimeMillis();\n        long bytes;\n        int x0, x1, y0, y1, ppm, words;\n        try {\n            // draw urls\n            /*\n            Iterator<Event> i = serverProfiling.history(\"indexed\");\n            x0 = 1; y0 = 0;\n            while (i.hasNext()) {\n                event = i.next();\n                time = event.time - now;\n                x1 = (int) (time/1000);\n                y1 = ppm;\n                chart.setColor(\"AA8888\");\n                if (x0 < 0) chart.chartLine(ymageChart.DIMENSION_BOTTOM, ymageChart.DIMENSION_ANOT0, x0, y0, x1, y1);\n                chart.setColor(\"AA2222\");\n                chart.chartDot(ymageChart.DIMENSION_BOTTOM, ymageChart.DIMENSION_ANOT0, x1, y1, 2, ((String) event.payload), 315);\n                x0 = x1; y0 = y1;\n            }\n            */\n            // draw memory\n            Iterator<Event> events = EventTracker.getHistory(EventTracker.EClass.MEMORY);\n            x0 = 1; y0 = 0;\n            if (events != null) {\n                EventTracker.Event event;\n                while (events.hasNext()) {\n                    event = events.next();\n                    time = event.time - now;\n                    bytes = ((Long) event.payload).longValue();\n                    x1 = (int) (time/1000);\n                    y1 = (int) (bytes / 1024 / 1024);\n                    chart.setColor(\"AAAAFF\");\n                    chart.chartDot(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_RIGHT, x1, y1, 2, null, 0);\n                    chart.setColor(\"0000FF\");\n                    if (x0 < 0) chart.chartLine(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_RIGHT, x0, y0, x1, y1);\n                    x0 = x1; y0 = y1;\n                }\n            }\n            \n            // draw wordcache\n            events = EventTracker.getHistory(EventTracker.EClass.WORDCACHE);\n            x0 = 1; y0 = 0;\n            if (events != null) {\n                EventTracker.Event event;\n                while (events.hasNext()) {\n                    event = events.next();\n                    time = event.time - now;\n                    words = (int) ((Long) event.payload).longValue();\n                    x1 = (int) (time/1000);\n                    y1 = words;\n                    chart.setColor(\"228822\");\n                    chart.chartDot(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_LEFT, x1, y1, 2, null, 315);\n                    chart.setColor(\"008800\");\n                    if (x0 < 0) chart.chartLine(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_LEFT, x0, y0, x1, y1);\n                    x0 = x1; y0 = y1;\n                }\n            }\n            \n            // draw ppm\n            events = EventTracker.getHistory(EventTracker.EClass.PPM);\n            x0 = 1; y0 = 0;\n            if (events != null) {\n                EventTracker.Event event;\n                while (events.hasNext()) {\n                    event = events.next();\n                    time = event.time - now;\n                    ppm = (int) ((Long) event.payload).longValue();\n                    x1 = (int) (time/1000);\n                    y1 = ppm;\n                    chart.setColor(\"AA8888\");\n                    if (x0 < 0) chart.chartLine(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_ANOT0, x0, y0, x1, y1);\n                    chart.setColor(\"AA2222\");\n                    chart.chartDot(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_ANOT0, x1, y1, 2, ppm + \" PPM\", 0);\n                    x0 = x1; y0 = y1;\n                }\n            }\n            \n            bufferChart = chart;\n        } catch (final ConcurrentModificationException cme) {\n            chart = bufferChart;\n        }\n        \n        return chart;\n    }","id":89068,"modified_method":"public static RasterPlotter performanceGraph(final int width, final int height, final String subline, final boolean showMemory) {\n        // find maximum values for automatic graph dimension adoption\n        final int maxppm = (int) maxPayload(EventTracker.EClass.PPM, 25);\n        final int maxwords = (int) maxPayload(EventTracker.EClass.WORDCACHE, 12000);\n        final long maxbytes = maxPayload(EventTracker.EClass.MEMORY, 110 * 1024 * 1024);\n        final int maxmbytes = (int)(maxbytes / 1024 / 1024);\n\n        // declare graph and set dimensions\n        final int leftborder = 30;\n        final int rightborder = 30;\n        final int topborder = 20;\n        final int bottomborder = 20;\n        final int leftscale = (maxwords > 150000) ? maxwords / 150000 * 20000 : 10000;\n        final int rightscale = showMemory ? ((maxmbytes > 1500) ? maxmbytes / 1500 * 200 : 100) : Math.max(100, maxppm / 100 * 100);\n        final int anotscale = 1000;\n        final int bottomscale = 60;\n        final int vspace = height - topborder - bottomborder;\n        final int hspace = width - leftborder - rightborder;\n        final int maxtime = 600;\n        ChartPlotter chart = new ChartPlotter(width, height, \"FFFFFF\", \"000000\", \"AAAAAA\", leftborder, rightborder, topborder, bottomborder, \"YACY PEER PERFORMANCE: MAIN MEMORY, WORD CACHE AND PAGES/MINUTE (PPM)\", subline);\n        chart.declareDimension(ChartPlotter.DIMENSION_BOTTOM, bottomscale, hspace / (maxtime / bottomscale), -maxtime, \"000000\", \"CCCCCC\", \"TIME/SECONDS\");\n        chart.declareDimension(ChartPlotter.DIMENSION_LEFT, leftscale, vspace * leftscale / maxwords, 0, \"008800\", null , \"WORDS IN INDEXING CACHE\");\n        if (showMemory) {\n            chart.declareDimension(ChartPlotter.DIMENSION_RIGHT, rightscale, vspace * rightscale / maxmbytes, 0, \"0000FF\", \"CCCCCC\", \"MEMORY/MEGABYTE\");\n        } else {\n            chart.declareDimension(ChartPlotter.DIMENSION_RIGHT, rightscale, vspace * rightscale / Math.max(1, maxppm), 0, \"FF0000\", \"CCCCCC\", \"INDEXING SPEED/PAGES PER MINUTE\");\n        }\n        chart.declareDimension(ChartPlotter.DIMENSION_ANOT0, anotscale, vspace * anotscale / maxppm, 0, \"008800\", null , \"PPM [PAGES/MINUTE]\");\n        chart.declareDimension(ChartPlotter.DIMENSION_ANOT1, vspace / 6, vspace / 6, 0, \"888800\", null , \"URL\");\n\n        // draw chart\n        long time;\n        final long now = System.currentTimeMillis();\n        long bytes;\n        int x0, x1, y0, y1, ppm, words;\n        try {\n            // draw urls\n            /*\n            Iterator<Event> i = serverProfiling.history(\"indexed\");\n            x0 = 1; y0 = 0;\n            while (i.hasNext()) {\n                event = i.next();\n                time = event.time - now;\n                x1 = (int) (time/1000);\n                y1 = ppm;\n                chart.setColor(\"AA8888\");\n                if (x0 < 0) chart.chartLine(ymageChart.DIMENSION_BOTTOM, ymageChart.DIMENSION_ANOT0, x0, y0, x1, y1);\n                chart.setColor(\"AA2222\");\n                chart.chartDot(ymageChart.DIMENSION_BOTTOM, ymageChart.DIMENSION_ANOT0, x1, y1, 2, ((String) event.payload), 315);\n                x0 = x1; y0 = y1;\n            }\n            */\n            Iterator<Event> events;\n            // draw memory\n            if (showMemory) {\n                events = EventTracker.getHistory(EventTracker.EClass.MEMORY);\n                x0 = 1; y0 = 0;\n                if (events != null) {\n                    EventTracker.Event event;\n                    while (events.hasNext()) {\n                        event = events.next();\n                        time = event.time - now;\n                        bytes = ((Long) event.payload).longValue();\n                        x1 = (int) (time/1000);\n                        y1 = (int) (bytes / 1024 / 1024);\n                        chart.setColor(\"AAAAFF\");\n                        chart.chartDot(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_RIGHT, x1, y1, 2, null, 0);\n                        chart.setColor(\"0000FF\");\n                        if (x0 < 0) chart.chartLine(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_RIGHT, x0, y0, x1, y1);\n                        x0 = x1; y0 = y1;\n                    }\n                }\n            }\n\n            // draw wordcache\n            events = EventTracker.getHistory(EventTracker.EClass.WORDCACHE);\n            x0 = 1; y0 = 0;\n            if (events != null) {\n                EventTracker.Event event;\n                while (events.hasNext()) {\n                    event = events.next();\n                    time = event.time - now;\n                    words = (int) ((Long) event.payload).longValue();\n                    x1 = (int) (time/1000);\n                    y1 = words;\n                    chart.setColor(\"228822\");\n                    chart.chartDot(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_LEFT, x1, y1, 2, null, 315);\n                    chart.setColor(\"008800\");\n                    if (x0 < 0) chart.chartLine(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_LEFT, x0, y0, x1, y1);\n                    x0 = x1; y0 = y1;\n                }\n            }\n\n            // draw ppm\n            events = EventTracker.getHistory(EventTracker.EClass.PPM);\n            x0 = 1; y0 = 0;\n            if (events != null) {\n                EventTracker.Event event;\n                while (events.hasNext()) {\n                    event = events.next();\n                    time = event.time - now;\n                    ppm = (int) ((Long) event.payload).longValue();\n                    x1 = (int) (time/1000);\n                    y1 = ppm;\n                    chart.setColor(\"AA8888\");\n                    if (x0 < 0) chart.chartLine(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_ANOT0, x0, y0, x1, y1);\n                    chart.setColor(\"AA2222\");\n                    chart.chartDot(ChartPlotter.DIMENSION_BOTTOM, ChartPlotter.DIMENSION_ANOT0, x1, y1, 2, ppm + \" PPM\", 0);\n                    x0 = x1; y0 = y1;\n                }\n            }\n\n            bufferChart = chart;\n        } catch (final ConcurrentModificationException cme) {\n            chart = bufferChart;\n        }\n\n        return chart;\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static SearchEvent getDummyEvent(final WorkTables workTables, final LoaderDispatcher loader, final Segment indexSegment) {\r\n        if (dummyEvent != null) return dummyEvent;\r\n        final QueryParams query = new QueryParams(\"\", 0, null, indexSegment, new RankingProfile(ContentDomain.TEXT), \"\");\r\n        dummyEvent = new SearchEvent(query, null, workTables, null, false, loader, 0, 0, 0, 0, false);\r\n        return dummyEvent;\r\n    }","id":89069,"modified_method":"private static SearchEvent getDummyEvent(final WorkTables workTables, final LoaderDispatcher loader, final Segment indexSegment) {\r\n        Log.logWarning(\"SearchEventCache\", \"returning dummy event\");\r\n        if (dummyEvent != null) return dummyEvent;\r\n        final QueryParams query = new QueryParams(\"\", 0, null, indexSegment, new RankingProfile(ContentDomain.TEXT), \"\");\r\n        dummyEvent = new SearchEvent(query, null, workTables, null, false, loader, 0, 0, 0, 0, false);\r\n        return dummyEvent;\r\n    }","commit_id":"3a191cdf14c57a9d2e31e644436b57b35c0592ff","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public AudioBackAction() {\n        super(tr(\"Back\"), \"audio-back\", tr(\"Jump back.\"),\n        Shortcut.registerShortcut(\"audio:back\", tr(\"Audio: {0}\", tr(\"Back\")), KeyEvent.VK_F6, Shortcut.GROUP_DIRECT), true);\n        try {\n            amount = - Double.parseDouble(Main.pref.get(\"audio.forwardbackamount\",\"10.0\"));\n        } catch (NumberFormatException e) {\n            amount = 10.0;\n        }\n        this.putValue(\"help\", \"Action/Back\");\n    }","id":89070,"modified_method":"public AudioBackAction() {\n        super(tr(\"Back\"), \"audio-back\", tr(\"Jump back.\"),\n        Shortcut.registerShortcut(\"audio:back\", tr(\"Audio: {0}\", tr(\"Back\")), KeyEvent.VK_F6, Shortcut.GROUP_DIRECT), true);\n        amount = -Main.pref.getDouble(\"audio.forwardbackamount\",10.0);\n        this.putValue(\"help\", \"Action/Back\");\n    }","commit_id":"94d8698fe86fba64f981a345737bfd71c3a52883","url":"https://github.com/openstreetmap/josm"},{"original_method":"public AudioFwdAction() {\n        super(tr(\"Forward\"), \"audio-fwd\", tr(\"Jump forward\"),\n        Shortcut.registerShortcut(\"audio:forward\", tr(\"Audio: {0}\", tr(\"Forward\")), KeyEvent.VK_F7, Shortcut.GROUP_DIRECT), true);\n        try {\n            amount = Double.parseDouble(Main.pref.get(\"audio.forwardbackamount\",\"10.0\"));\n        } catch (NumberFormatException e) {\n            amount = 10.0;\n        }\n    }","id":89071,"modified_method":"public AudioFwdAction() {\n        super(tr(\"Forward\"), \"audio-fwd\", tr(\"Jump forward\"),\n        Shortcut.registerShortcut(\"audio:forward\", tr(\"Audio: {0}\", tr(\"Forward\")), KeyEvent.VK_F7, Shortcut.GROUP_DIRECT), true);\n        amount = Main.pref.getDouble(\"audio.forwardbackamount\",10.0);\n    }","commit_id":"94d8698fe86fba64f981a345737bfd71c3a52883","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Fill the given panel by adding all necessary components to the different\n     * locations.\n     *\n     * @param panel The container to fill. Must have an BorderLayout.\n     */\n    public void fillPanel(Container panel) {\n        panel.add(this, BorderLayout.CENTER);\n        JToolBar jb = new JToolBar(JToolBar.VERTICAL);\n        jb.setFloatable(false);\n        jb.add(toolBarActions);\n        jb.addSeparator();\n        jb.add(toolBarToggle);\n        panel.add(new ScrollViewport(jb, ScrollViewport.VERTICAL_DIRECTION),\n        BorderLayout.WEST);\n        if (statusLine != null)\n            panel.add(statusLine, BorderLayout.SOUTH);\n    }","id":89072,"modified_method":"/**\n     * Fill the given panel by adding all necessary components to the different\n     * locations.\n     *\n     * @param panel The container to fill. Must have an BorderLayout.\n     */\n    public void fillPanel(Container panel) {\n        panel.add(this, BorderLayout.CENTER);\n        JToolBar jb = new JToolBar(JToolBar.VERTICAL);\n        jb.setFloatable(false);\n        jb.add(toolBarActions);\n        jb.addSeparator();\n        jb.add(toolBarToggle);\n        if(Main.pref.getBoolean(\"sidetoolbar.visible\", true))\n        {\n            if(Main.pref.getBoolean(\"sidetoolbar.scrollable\", true))\n                panel.add(new ScrollViewport(jb, ScrollViewport.VERTICAL_DIRECTION),\n                BorderLayout.WEST);\n            else\n                panel.add(jb, BorderLayout.WEST);\n        }\n        if (statusLine != null && Main.pref.getBoolean(\"statusline.visible\", true))\n            panel.add(statusLine, BorderLayout.SOUTH);\n    }","commit_id":"94d8698fe86fba64f981a345737bfd71c3a52883","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void updateSizeCheck() {\n\t\tdouble squareDegrees = (maxlon-minlon)*(maxlat-minlat);\n\t\tdouble maxBboxSize = 0.25;\n\t\ttry {\n\t\t\tDouble.parseDouble(Main.pref.get(\"osm-server.max-request-area\", \"0.25\"));\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tmaxBboxSize = 0.25;\n\t\t}\n\t\tif (squareDegrees > maxBboxSize) {\n\t\t\tsizeCheck.setText(tr(\"Download area too large; will probably be rejected by server\"));\n\t\t\tsizeCheck.setForeground(Color.red);\n\t\t} else {\n\t\t\tsizeCheck.setText(tr(\"Download area ok, size probably acceptable to server\"));\n\t\t\tsizeCheck.setForeground(Color.darkGray);\n\t\t}\n\t}","id":89073,"modified_method":"private void updateSizeCheck() {\n\t\tif ((maxlon-minlon)*(maxlat-minlat) > Main.pref.getDouble(\"osm-server.max-request-area\", 0.25)) {\n\t\t\tsizeCheck.setText(tr(\"Download area too large; will probably be rejected by server\"));\n\t\t\tsizeCheck.setForeground(Color.red);\n\t\t} else {\n\t\t\tsizeCheck.setText(tr(\"Download area ok, size probably acceptable to server\"));\n\t\t\tsizeCheck.setForeground(Color.darkGray);\n\t\t}\n\t}","commit_id":"6a80117fda706fdf9a8015336a8029bf0da64843","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void checkInitializationInSetup(PsiField field,\n                                                PsiClass aClass) {\n            final PsiMethod setupMethod = getSetupMethod(aClass);\n            if (InitializationUtils.methodAssignsVariableOrFails(setupMethod,\n                    field)) {\n                return;\n            }\n            registerFieldError(field, Boolean.TRUE);\n        }","id":89074,"modified_method":"private boolean isInitializatedInSetup(PsiField field,\n                                               PsiClass aClass){\n            final PsiMethod setupMethod = getSetupMethod(aClass);\n            return InitializationUtils.methodAssignsVariableOrFails(setupMethod,\n                    field);\n        }","commit_id":"da26bb7447a7250a06fb5b144b525a071e86bae6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkInitializationInConstructors(PsiField field,\n                                                       PsiClass aClass) {\n            if(isInitializedInInitializer(field)){\n                return;\n            }\n            final PsiMethod[] constructors = aClass.getConstructors();\n            if(constructors.length == 0){\n                registerFieldError(field, Boolean.FALSE);\n                return;\n            }\n            for(final PsiMethod constructor : constructors){\n                if(!InitializationUtils.methodAssignsVariableOrFails(\n                        constructor, field)) {\n                    registerFieldError(field, Boolean.FALSE);\n                    return;\n                }\n            }\n        }","id":89075,"modified_method":"private boolean isInitializatedInConstructors(PsiField field,\n                                                      PsiClass aClass){\n            final PsiMethod[] constructors = aClass.getConstructors();\n            if(constructors.length == 0){\n                return false;\n            }\n            for(final PsiMethod constructor : constructors){\n                if(!InitializationUtils.methodAssignsVariableOrFails(\n                        constructor, field)){\n                    return false;\n                }\n            }\n            return true;\n        }","commit_id":"da26bb7447a7250a06fb5b144b525a071e86bae6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitField(@NotNull PsiField field){\n            if(field.hasModifierProperty(PsiModifier.STATIC)){\n                return;\n            }\n            if(field.getInitializer() != null){\n                return;\n            }\n            if(m_ignorePrimitives){\n                final PsiType fieldType = field.getType();\n                if(ClassUtils.isPrimitive(fieldType)){\n                    return;\n                }\n            }\n            final PsiClass aClass = field.getContainingClass();\n            if(aClass == null){\n                return;\n            }\n            final PsiManager manager = field.getManager();\n            final PsiSearchHelper searchHelper = manager.getSearchHelper();\n            if(searchHelper.isFieldBoundToForm(field)){\n                return;\n            }\n            if (TestUtils.isJUnitTestClass(aClass)) {\n                checkInitializationInSetup(field, aClass);\n            } else {\n                checkInitializationInConstructors(field, aClass);\n            }\n        }","id":89076,"modified_method":"public void visitField(@NotNull PsiField field){\n            if(field.hasModifierProperty(PsiModifier.STATIC) ||\n                    field.hasModifierProperty(PsiModifier.FINAL)){\n                return;\n            }\n            if(field.getInitializer() != null){\n                return;\n            }\n            if(m_ignorePrimitives){\n                final PsiType fieldType = field.getType();\n                if(ClassUtils.isPrimitive(fieldType)){\n                    return;\n                }\n            }\n            final PsiClass aClass = field.getContainingClass();\n            if(aClass == null){\n                return;\n            }\n            final PsiManager manager = field.getManager();\n            final PsiSearchHelper searchHelper = manager.getSearchHelper();\n            if(searchHelper.isFieldBoundToForm(field)){\n                return;\n            }\n            final boolean isTestClass = TestUtils.isJUnitTestClass(aClass);\n            if(isTestClass){\n                if(isInitializatedInSetup(field, aClass)){\n                    return;\n                }\n            }\n            if(isInitializedInInitializer(field)){\n                return;\n            }\n            if(isInitializatedInConstructors(field, aClass)){\n                return;\n            }\n            if (isTestClass) {\n                registerFieldError(field, Boolean.TRUE);\n            } else {\n                registerFieldError(field, Boolean.FALSE);\n            }\n        }","commit_id":"da26bb7447a7250a06fb5b144b525a071e86bae6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Specifics isMoreSpecific(@NotNull MethodCandidateInfo info1,\n                                   @NotNull MethodCandidateInfo info2,\n                                   @MethodCandidateInfo.ApplicabilityLevelConstant int applicabilityLevel,\n                                   @NotNull LanguageLevel languageLevel) {\n    PsiMethod method1 = info1.getElement();\n    PsiMethod method2 = info2.getElement();\n    final PsiClass class1 = method1.getContainingClass();\n    final PsiClass class2 = method2.getContainingClass();\n\n    final PsiParameter[] params1 = method1.getParameterList().getParameters();\n    final PsiParameter[] params2 = method2.getParameterList().getParameters();\n\n    final PsiTypeParameter[] typeParameters1 = method1.getTypeParameters();\n    final PsiTypeParameter[] typeParameters2 = method2.getTypeParameters();\n    final PsiSubstitutor classSubstitutor1 = info1.getSubstitutor(false); //substitutions for method type parameters will be ignored\n    final PsiSubstitutor classSubstitutor2 = info2.getSubstitutor(false);\n\n    final int max = Math.max(params1.length, params2.length);\n    PsiType[] types1 = PsiType.createArray(max);\n    PsiType[] types2 = PsiType.createArray(max);\n    final boolean varargsPosition = applicabilityLevel == MethodCandidateInfo.ApplicabilityLevel.VARARGS;\n    for (int i = 0; i < max; i++) {\n      ProgressManager.checkCanceled();\n      PsiType type1 = params1.length > 0 ? params1[Math.min(i, params1.length - 1)].getType() : null;\n      PsiType type2 = params2.length > 0 ? params2[Math.min(i, params2.length - 1)].getType() : null;\n      if (varargsPosition) {\n        if (type1 instanceof PsiEllipsisType && type2 instanceof PsiEllipsisType &&\n            params1.length == params2.length &&\n            class1 != null && (!JavaVersionService.getInstance().isAtLeast(class1, JavaSdkVersion.JDK_1_7) || ((PsiArrayType)type1).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT) || ((PsiArrayType)type2).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT))) {\n          type1 = ((PsiEllipsisType)type1).toArrayType();\n          type2 = ((PsiEllipsisType)type2).toArrayType();\n        }\n        else {\n          type1 = type1 instanceof PsiEllipsisType ? ((PsiArrayType)type1).getComponentType() : type1;\n          type2 = type2 instanceof PsiEllipsisType ? ((PsiArrayType)type2).getComponentType() : type2;\n        }\n      }\n\n      types1[i] = type1;\n      types2[i] = type2;\n    }\n\n    boolean sameBoxing = true;\n    int[] boxingHappened = new int[2];\n    for (int i = 0; i < types1.length; i++) {\n      ProgressManager.checkCanceled();\n      PsiType type1 = classSubstitutor1.substitute(types1[i]);\n      PsiType type2 = classSubstitutor2.substitute(types2[i]);\n      PsiType argType = i < getActualParameterTypes().length ? getActualParameterTypes()[i] : null;\n\n      boolean boxingInFirst = false;\n      if (isBoxingHappened(argType, type1, languageLevel)) {\n        boxingHappened[0] += 1;\n        boxingInFirst = true;\n      }\n\n      boolean boxingInSecond = false;\n      if (isBoxingHappened(argType, type2, languageLevel)) {\n        boxingHappened[1] += 1;\n        boxingInSecond = true;\n      }\n      sameBoxing &= boxingInFirst == boxingInSecond;\n    }\n    if (boxingHappened[0] == 0 && boxingHappened[1] > 0) return Specifics.FIRST;\n    if (boxingHappened[0] > 0 && boxingHappened[1] == 0) return Specifics.SECOND;\n\n    if (sameBoxing) {\n      final PsiSubstitutor siteSubstitutor1 = info1.getSiteSubstitutor();\n      final PsiSubstitutor siteSubstitutor2 = info2.getSiteSubstitutor();\n\n      final PsiType[] types2AtSite = typesAtSite(types2, siteSubstitutor2);\n      final PsiType[] types1AtSite = typesAtSite(types1, siteSubstitutor1);\n\n      final PsiSubstitutor methodSubstitutor1 = calculateMethodSubstitutor(typeParameters1, method1, siteSubstitutor1, types1, types2AtSite,\n                                                                           languageLevel);\n      boolean applicable12 = isApplicableTo(types2AtSite, method1, languageLevel, varargsPosition, methodSubstitutor1, method2);\n\n      final PsiSubstitutor methodSubstitutor2 = calculateMethodSubstitutor(typeParameters2, method2, siteSubstitutor2, types2, types1AtSite, languageLevel);\n      boolean applicable21 = isApplicableTo(types1AtSite, method2, languageLevel, varargsPosition, methodSubstitutor2, method1);\n\n      if (!myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_8)) {\n        final boolean typeArgsApplicable12 = GenericsUtil.isTypeArgumentsApplicable(typeParameters1, methodSubstitutor1, myArgumentsList, !applicable21);\n        final boolean typeArgsApplicable21 = GenericsUtil.isTypeArgumentsApplicable(typeParameters2, methodSubstitutor2, myArgumentsList, !applicable12);\n\n        if (!typeArgsApplicable12) {\n          applicable12 = false;\n        }\n\n        if (!typeArgsApplicable21) {\n          applicable21 = false;\n        }\n      }\n\n      if (applicable12 || applicable21) {\n\n        if (applicable12 && !applicable21) return Specifics.SECOND;\n        if (applicable21 && !applicable12) return Specifics.FIRST;\n\n        final boolean abstract1 = method1.hasModifierProperty(PsiModifier.ABSTRACT);\n        final boolean abstract2 = method2.hasModifierProperty(PsiModifier.ABSTRACT);\n        if (abstract1 && !abstract2) {\n          return Specifics.SECOND;\n        }\n        if (abstract2 && !abstract1) {\n          return Specifics.FIRST;\n        }\n\n      }\n\n      if (languageLevel.isAtLeast(LanguageLevel.JDK_1_8) && myArgumentsList instanceof PsiExpressionList && (typeParameters1.length == 0 || typeParameters2.length == 0)) {\n        boolean toCompareFunctional = false;\n        if (types1.length > 0 && types2.length > 0) {\n          for (int i = 0; i < getActualParametersLength(); i++) {\n            final PsiType type1 = types1[Math.min(i, types1.length - 1)];\n            final PsiType type2 = types2[Math.min(i, types2.length - 1)];\n            //from 15.12.2.5 Choosing the Most Specific Method\n            //In addition, a functional interface type S is more specific than a functional interface type T for an expression exp \n            // if T is not a subtype of S and one of the following conditions apply.\n            if (LambdaUtil.isFunctionalType(type1) && !TypeConversionUtil.erasure(type1).isAssignableFrom(type2) &&\n                LambdaUtil.isFunctionalType(type2) && !TypeConversionUtil.erasure(type2).isAssignableFrom(type1)) {\n              types1AtSite[Math.min(i, types1.length - 1)] = PsiType.NULL;\n              types2AtSite[Math.min(i, types2.length - 1)] = PsiType.NULL;\n              toCompareFunctional = true;\n            }\n          }\n        }\n\n        if (toCompareFunctional) {\n          final boolean applicable12ignoreFunctionalType = isApplicableTo(types2AtSite, method1, languageLevel, varargsPosition,\n                                                                          calculateMethodSubstitutor(typeParameters1, method1, siteSubstitutor1, types1, types2AtSite, languageLevel), null);\n          final boolean applicable21ignoreFunctionalType = isApplicableTo(types1AtSite, method2, languageLevel, varargsPosition,\n                                                                          calculateMethodSubstitutor(typeParameters2, method2, siteSubstitutor2, types2, types1AtSite, languageLevel), null);\n\n          if (applicable12ignoreFunctionalType || applicable21ignoreFunctionalType) {\n            Specifics specifics = null;\n            for (int i = 0; i < getActualParametersLength(); i++) {\n              if (types1AtSite[Math.min(i, types1.length - 1)] == PsiType.NULL && \n                  types2AtSite[Math.min(i, types2.length - 1)] == PsiType.NULL) {\n                Specifics specific = isFunctionalTypeMoreSpecific(info1, info2, ((PsiExpressionList)myArgumentsList).getExpressions()[i], i);\n                if (specific == Specifics.NEITHER) {\n                  specifics = Specifics.NEITHER;\n                  break;\n                }\n  \n                if (specifics == null) {\n                  specifics = specific;\n                } else if (specifics != specific) {\n                  specifics = Specifics.NEITHER;\n                  break;\n                }\n              }\n            }\n  \n            if (!applicable12ignoreFunctionalType && applicable21ignoreFunctionalType) {\n              return specifics == Specifics.FIRST ? Specifics.FIRST : Specifics.NEITHER;\n            }\n  \n            if (!applicable21ignoreFunctionalType && applicable12ignoreFunctionalType) {\n              return specifics == Specifics.SECOND ? Specifics.SECOND : Specifics.NEITHER;\n            }\n  \n            return specifics;\n          }\n        }\n      }\n    } \n    else if (varargsPosition) {\n      final PsiType lastParamType1 = classSubstitutor1.substitute(types1[types1.length - 1]);\n      final PsiType lastParamType2 = classSubstitutor2.substitute(types2[types1.length - 1]);\n      final boolean assignable1 = TypeConversionUtil.isAssignable(lastParamType2, lastParamType1);\n      final boolean assignable2 = TypeConversionUtil.isAssignable(lastParamType1, lastParamType2);\n      if (assignable1 && !assignable2) {\n        return Specifics.FIRST;\n      }\n      if (assignable2 && !assignable1) {\n        return Specifics.SECOND;\n      }\n    }\n\n    if (class1 != class2) {\n      if (class2.isInheritor(class1, true) || class1.isInterface() && !class2.isInterface()) {\n        if (MethodSignatureUtil.isSubsignature(method1.getSignature(info1.getSubstitutor(false)), method2.getSignature(info2.getSubstitutor(false)))) {\n          return Specifics.SECOND;\n        }\n        else if (method1.hasModifierProperty(PsiModifier.STATIC) && method2.hasModifierProperty(PsiModifier.STATIC) && boxingHappened[0] == 0) {\n          return Specifics.SECOND;\n        }\n      }\n      else if (MethodSignatureUtil.areErasedParametersEqual(method1.getSignature(PsiSubstitutor.EMPTY), method2.getSignature(PsiSubstitutor.EMPTY)) &&\n               MethodSignatureUtil.isSubsignature(method2.getSignature(info2.getSubstitutor(false)), method1.getSignature(info1.getSubstitutor(false)))) {\n        return Specifics.FIRST;\n      }\n      else if (class1.isInheritor(class2, true) || class2.isInterface()) {\n        if (method1.hasModifierProperty(PsiModifier.STATIC) && method2.hasModifierProperty(PsiModifier.STATIC) && boxingHappened[0] == 0) {\n          return Specifics.FIRST;\n        }\n      }\n    }\n\n    final boolean raw1 = PsiUtil.isRawSubstitutor(method1, classSubstitutor1);\n    final boolean raw2 = PsiUtil.isRawSubstitutor(method2, classSubstitutor2);\n    if (raw1 ^ raw2) {\n      return raw1 ? Specifics.SECOND : Specifics.FIRST;\n    }\n\n    final boolean varargs1 = info1.isVarargs();\n    final boolean varargs2 = info2.isVarargs();\n    if (varargs1 ^ varargs2) {\n      return varargs1 ? Specifics.SECOND : Specifics.FIRST;\n    }\n\n    return Specifics.NEITHER;\n  }","id":89077,"modified_method":"private Specifics isMoreSpecific(@NotNull MethodCandidateInfo info1,\n                                   @NotNull MethodCandidateInfo info2,\n                                   @MethodCandidateInfo.ApplicabilityLevelConstant int applicabilityLevel,\n                                   @NotNull LanguageLevel languageLevel) {\n    PsiMethod method1 = info1.getElement();\n    PsiMethod method2 = info2.getElement();\n    final PsiClass class1 = method1.getContainingClass();\n    final PsiClass class2 = method2.getContainingClass();\n\n    final PsiParameter[] params1 = method1.getParameterList().getParameters();\n    final PsiParameter[] params2 = method2.getParameterList().getParameters();\n\n    final PsiTypeParameter[] typeParameters1 = method1.getTypeParameters();\n    final PsiTypeParameter[] typeParameters2 = method2.getTypeParameters();\n    final PsiSubstitutor classSubstitutor1 = info1.getSubstitutor(false); //substitutions for method type parameters will be ignored\n    final PsiSubstitutor classSubstitutor2 = info2.getSubstitutor(false);\n\n    final int max = Math.max(params1.length, params2.length);\n    PsiType[] types1 = PsiType.createArray(max);\n    PsiType[] types2 = PsiType.createArray(max);\n    final boolean varargsPosition = applicabilityLevel == MethodCandidateInfo.ApplicabilityLevel.VARARGS;\n    for (int i = 0; i < max; i++) {\n      ProgressManager.checkCanceled();\n      PsiType type1 = params1.length > 0 ? params1[Math.min(i, params1.length - 1)].getType() : null;\n      PsiType type2 = params2.length > 0 ? params2[Math.min(i, params2.length - 1)].getType() : null;\n      if (varargsPosition) {\n        if (type1 instanceof PsiEllipsisType && type2 instanceof PsiEllipsisType &&\n            params1.length == params2.length &&\n            class1 != null && (!JavaVersionService.getInstance().isAtLeast(class1, JavaSdkVersion.JDK_1_7) || ((PsiArrayType)type1).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT) || ((PsiArrayType)type2).getComponentType().equalsToText(CommonClassNames.JAVA_LANG_OBJECT))) {\n          type1 = ((PsiEllipsisType)type1).toArrayType();\n          type2 = ((PsiEllipsisType)type2).toArrayType();\n        }\n        else {\n          type1 = type1 instanceof PsiEllipsisType ? ((PsiArrayType)type1).getComponentType() : type1;\n          type2 = type2 instanceof PsiEllipsisType ? ((PsiArrayType)type2).getComponentType() : type2;\n        }\n      }\n\n      types1[i] = type1;\n      types2[i] = type2;\n    }\n\n    boolean sameBoxing = true;\n    int[] boxingHappened = new int[2];\n    for (int i = 0; i < types1.length; i++) {\n      ProgressManager.checkCanceled();\n      PsiType type1 = classSubstitutor1.substitute(types1[i]);\n      PsiType type2 = classSubstitutor2.substitute(types2[i]);\n      PsiType argType = i < getActualParameterTypes().length ? getActualParameterTypes()[i] : null;\n\n      boolean boxingInFirst = false;\n      if (isBoxingHappened(argType, type1, languageLevel)) {\n        boxingHappened[0] += 1;\n        boxingInFirst = true;\n      }\n\n      boolean boxingInSecond = false;\n      if (isBoxingHappened(argType, type2, languageLevel)) {\n        boxingHappened[1] += 1;\n        boxingInSecond = true;\n      }\n      sameBoxing &= boxingInFirst == boxingInSecond;\n    }\n    if (boxingHappened[0] == 0 && boxingHappened[1] > 0) return Specifics.FIRST;\n    if (boxingHappened[0] > 0 && boxingHappened[1] == 0) return Specifics.SECOND;\n\n    if (sameBoxing) {\n      final PsiSubstitutor siteSubstitutor1 = info1.getSiteSubstitutor();\n      final PsiSubstitutor siteSubstitutor2 = info2.getSiteSubstitutor();\n\n      final PsiType[] types2AtSite = typesAtSite(types2, siteSubstitutor2);\n      final PsiType[] types1AtSite = typesAtSite(types1, siteSubstitutor1);\n\n      final PsiSubstitutor methodSubstitutor1 = calculateMethodSubstitutor(typeParameters1, method1, siteSubstitutor1, types1, types2AtSite,\n                                                                           languageLevel);\n      boolean applicable12 = isApplicableTo(types2AtSite, method1, languageLevel, varargsPosition, methodSubstitutor1, method2);\n\n      final PsiSubstitutor methodSubstitutor2 = calculateMethodSubstitutor(typeParameters2, method2, siteSubstitutor2, types2, types1AtSite, languageLevel);\n      boolean applicable21 = isApplicableTo(types1AtSite, method2, languageLevel, varargsPosition, methodSubstitutor2, method1);\n\n      if (!myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_8)) {\n        final boolean typeArgsApplicable12 = GenericsUtil.isTypeArgumentsApplicable(typeParameters1, methodSubstitutor1, myArgumentsList, !applicable21);\n        final boolean typeArgsApplicable21 = GenericsUtil.isTypeArgumentsApplicable(typeParameters2, methodSubstitutor2, myArgumentsList, !applicable12);\n\n        if (!typeArgsApplicable12) {\n          applicable12 = false;\n        }\n\n        if (!typeArgsApplicable21) {\n          applicable21 = false;\n        }\n      }\n\n      if (applicable12 || applicable21) {\n\n        if (applicable12 && !applicable21) return Specifics.SECOND;\n        if (applicable21 && !applicable12) return Specifics.FIRST;\n\n        final boolean abstract1 = method1.hasModifierProperty(PsiModifier.ABSTRACT);\n        final boolean abstract2 = method2.hasModifierProperty(PsiModifier.ABSTRACT);\n        if (abstract1 && !abstract2) {\n          return Specifics.SECOND;\n        }\n        if (abstract2 && !abstract1) {\n          return Specifics.FIRST;\n        }\n\n        if (method1.hasModifierProperty(PsiModifier.DEFAULT) && method2.hasModifierProperty(PsiModifier.STATIC)) {\n          return Specifics.FIRST;\n        }\n\n        if (method2.hasModifierProperty(PsiModifier.DEFAULT) && method1.hasModifierProperty(PsiModifier.STATIC)) {\n          return Specifics.SECOND;\n        }\n      }\n\n      if (languageLevel.isAtLeast(LanguageLevel.JDK_1_8) && myArgumentsList instanceof PsiExpressionList && (typeParameters1.length == 0 || typeParameters2.length == 0)) {\n        boolean toCompareFunctional = false;\n        if (types1.length > 0 && types2.length > 0) {\n          for (int i = 0; i < getActualParametersLength(); i++) {\n            final PsiType type1 = types1[Math.min(i, types1.length - 1)];\n            final PsiType type2 = types2[Math.min(i, types2.length - 1)];\n            //from 15.12.2.5 Choosing the Most Specific Method\n            //In addition, a functional interface type S is more specific than a functional interface type T for an expression exp \n            // if T is not a subtype of S and one of the following conditions apply.\n            if (LambdaUtil.isFunctionalType(type1) && !TypeConversionUtil.erasure(type1).isAssignableFrom(type2) &&\n                LambdaUtil.isFunctionalType(type2) && !TypeConversionUtil.erasure(type2).isAssignableFrom(type1)) {\n              types1AtSite[Math.min(i, types1.length - 1)] = PsiType.NULL;\n              types2AtSite[Math.min(i, types2.length - 1)] = PsiType.NULL;\n              toCompareFunctional = true;\n            }\n          }\n        }\n\n        if (toCompareFunctional) {\n          final boolean applicable12ignoreFunctionalType = isApplicableTo(types2AtSite, method1, languageLevel, varargsPosition,\n                                                                          calculateMethodSubstitutor(typeParameters1, method1, siteSubstitutor1, types1, types2AtSite, languageLevel), null);\n          final boolean applicable21ignoreFunctionalType = isApplicableTo(types1AtSite, method2, languageLevel, varargsPosition,\n                                                                          calculateMethodSubstitutor(typeParameters2, method2, siteSubstitutor2, types2, types1AtSite, languageLevel), null);\n\n          if (applicable12ignoreFunctionalType || applicable21ignoreFunctionalType) {\n            Specifics specifics = null;\n            for (int i = 0; i < getActualParametersLength(); i++) {\n              if (types1AtSite[Math.min(i, types1.length - 1)] == PsiType.NULL && \n                  types2AtSite[Math.min(i, types2.length - 1)] == PsiType.NULL) {\n                Specifics specific = isFunctionalTypeMoreSpecific(info1, info2, ((PsiExpressionList)myArgumentsList).getExpressions()[i], i);\n                if (specific == Specifics.NEITHER) {\n                  specifics = Specifics.NEITHER;\n                  break;\n                }\n  \n                if (specifics == null) {\n                  specifics = specific;\n                } else if (specifics != specific) {\n                  specifics = Specifics.NEITHER;\n                  break;\n                }\n              }\n            }\n  \n            if (!applicable12ignoreFunctionalType && applicable21ignoreFunctionalType) {\n              return specifics == Specifics.FIRST ? Specifics.FIRST : Specifics.NEITHER;\n            }\n  \n            if (!applicable21ignoreFunctionalType && applicable12ignoreFunctionalType) {\n              return specifics == Specifics.SECOND ? Specifics.SECOND : Specifics.NEITHER;\n            }\n  \n            return specifics;\n          }\n        }\n      }\n    } \n    else if (varargsPosition) {\n      final PsiType lastParamType1 = classSubstitutor1.substitute(types1[types1.length - 1]);\n      final PsiType lastParamType2 = classSubstitutor2.substitute(types2[types1.length - 1]);\n      final boolean assignable1 = TypeConversionUtil.isAssignable(lastParamType2, lastParamType1);\n      final boolean assignable2 = TypeConversionUtil.isAssignable(lastParamType1, lastParamType2);\n      if (assignable1 && !assignable2) {\n        return Specifics.FIRST;\n      }\n      if (assignable2 && !assignable1) {\n        return Specifics.SECOND;\n      }\n    }\n\n    if (class1 != class2) {\n      if (class2.isInheritor(class1, true) || class1.isInterface() && !class2.isInterface()) {\n        if (MethodSignatureUtil.isSubsignature(method1.getSignature(info1.getSubstitutor(false)), method2.getSignature(info2.getSubstitutor(false)))) {\n          return Specifics.SECOND;\n        }\n        else if (method1.hasModifierProperty(PsiModifier.STATIC) && method2.hasModifierProperty(PsiModifier.STATIC) && boxingHappened[0] == 0) {\n          return Specifics.SECOND;\n        }\n      }\n      else if (MethodSignatureUtil.areErasedParametersEqual(method1.getSignature(PsiSubstitutor.EMPTY), method2.getSignature(PsiSubstitutor.EMPTY)) &&\n               MethodSignatureUtil.isSubsignature(method2.getSignature(info2.getSubstitutor(false)), method1.getSignature(info1.getSubstitutor(false)))) {\n        return Specifics.FIRST;\n      }\n      else if (class1.isInheritor(class2, true) || class2.isInterface()) {\n        if (method1.hasModifierProperty(PsiModifier.STATIC) && method2.hasModifierProperty(PsiModifier.STATIC) && boxingHappened[0] == 0) {\n          return Specifics.FIRST;\n        }\n      }\n    }\n\n    final boolean raw1 = PsiUtil.isRawSubstitutor(method1, classSubstitutor1);\n    final boolean raw2 = PsiUtil.isRawSubstitutor(method2, classSubstitutor2);\n    if (raw1 ^ raw2) {\n      return raw1 ? Specifics.SECOND : Specifics.FIRST;\n    }\n\n    final boolean varargs1 = info1.isVarargs();\n    final boolean varargs2 = info2.isVarargs();\n    if (varargs1 ^ varargs2) {\n      return varargs1 ? Specifics.SECOND : Specifics.FIRST;\n    }\n\n    return Specifics.NEITHER;\n  }","commit_id":"a6ef814ce8f8587331b73ec09836badb9ff80748","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isSuperMethod(@NotNull PsiClass aClass,\n                                       @NotNull HierarchicalMethodSignature hierarchicalMethodSignature,\n                                       @NotNull HierarchicalMethodSignature superSignatureHierarchical) {\n    PsiMethod superMethod = superSignatureHierarchical.getMethod();\n    PsiClass superClass = superMethod.getContainingClass();\n    PsiClass containingClass = hierarchicalMethodSignature.getMethod().getContainingClass();\n    if (!superMethod.isConstructor()) {\n      if (!aClass.equals(superClass)) {\n        if (PsiUtil.isAccessible(aClass.getProject(), superMethod, aClass, aClass)) {\n          if (MethodSignatureUtil.isSubsignature(superSignatureHierarchical, hierarchicalMethodSignature)) {\n            if (superClass != null) {\n              if (superClass.isInterface() ||\n                  CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName())) {\n                if (superMethod.hasModifierProperty(PsiModifier.STATIC)) {\n                  return false;\n                }\n                if (superMethod.hasModifierProperty(PsiModifier.DEFAULT) ||\n                    hierarchicalMethodSignature.getMethod().hasModifierProperty(PsiModifier.DEFAULT)) {\n                  return !InheritanceUtil.isInheritorOrSelf(superClass, containingClass, true);\n                }\n                return true;\n              }\n\n              if (containingClass != null) {\n                if (containingClass.isInterface()) {\n                  return false;\n                }\n\n                if (!aClass.isInterface() && !InheritanceUtil.isInheritorOrSelf(superClass, containingClass, true)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }","id":89078,"modified_method":"private static boolean isSuperMethod(@NotNull PsiClass aClass,\n                                       @NotNull HierarchicalMethodSignature hierarchicalMethodSignature,\n                                       @NotNull HierarchicalMethodSignature superSignatureHierarchical) {\n    PsiMethod superMethod = superSignatureHierarchical.getMethod();\n    PsiClass superClass = superMethod.getContainingClass();\n    PsiClass containingClass = hierarchicalMethodSignature.getMethod().getContainingClass();\n    if (!superMethod.isConstructor()) {\n      if (!aClass.equals(superClass)) {\n        if (PsiUtil.isAccessible(aClass.getProject(), superMethod, aClass, aClass)) {\n          if (MethodSignatureUtil.isSubsignature(superSignatureHierarchical, hierarchicalMethodSignature)) {\n            if (superClass != null) {\n              if (superClass.isInterface() ||\n                  CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName())) {\n                if (superMethod.hasModifierProperty(PsiModifier.STATIC) ||\n                    superMethod.hasModifierProperty(PsiModifier.DEFAULT) && hierarchicalMethodSignature.getMethod().hasModifierProperty(PsiModifier.STATIC)) {\n                  return false;\n                }\n\n                if (superMethod.hasModifierProperty(PsiModifier.DEFAULT) ||\n                    hierarchicalMethodSignature.getMethod().hasModifierProperty(PsiModifier.DEFAULT)) {\n                  return !InheritanceUtil.isInheritorOrSelf(superClass, containingClass, true);\n                }\n                return true;\n              }\n\n              if (containingClass != null) {\n                if (containingClass.isInterface()) {\n                  return false;\n                }\n\n                if (!aClass.isInterface() && !InheritanceUtil.isInheritorOrSelf(superClass, containingClass, true)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"a6ef814ce8f8587331b73ec09836badb9ff80748","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static HighlightInfo checkUnrelatedDefaultMethods(@NotNull PsiClass aClass,\n                                                            @NotNull Collection<HierarchicalMethodSignature> signaturesWithSupers,\n                                                            @NotNull PsiIdentifier classIdentifier) {\n    for (HierarchicalMethodSignature methodSignature : signaturesWithSupers) {\n      final PsiMethod method = methodSignature.getMethod();\n      if (method.hasModifierProperty(PsiModifier.DEFAULT)) {\n        final PsiClass containingClass = method.getContainingClass();\n        List<HierarchicalMethodSignature> superSignatures = methodSignature.getSuperSignatures();\n        if (!superSignatures.isEmpty()) {\n          for (HierarchicalMethodSignature signature : superSignatures) {\n            final PsiMethod superMethod = signature.getMethod();\n            final PsiClass superContainingClass = superMethod.getContainingClass();\n            if (containingClass != null && superContainingClass != null && !InheritanceUtil\n              .isInheritorOrSelf(containingClass, superContainingClass, true)) {\n              final boolean isDefault = superMethod.hasModifierProperty(PsiModifier.DEFAULT);\n              if (!aClass.hasModifierProperty(PsiModifier.ABSTRACT) && !isDefault) {\n                final String message = JavaErrorMessages.message(\n                  aClass instanceof PsiEnumConstantInitializer ? \"enum.constant.should.implement.method\" : \"class.must.be.abstract\",\n                  HighlightUtil.formatClass(superContainingClass),\n                  JavaHighlightUtil.formatMethod(superMethod),\n                  HighlightUtil.formatClass(superContainingClass, false));\n                return HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR)\n                  .range(classIdentifier).descriptionAndTooltip(message)\n                  .create();\n              }\n\n              if (isDefault || superMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {\n                final String message = isDefault\n                                       ? \" inherits unrelated defaults for \"\n                                       : \" inherits abstract and default for \";\n                final String inheritUnrelatedDefaultsMessage = HighlightUtil.formatClass(aClass) +\n                                                               message +\n                                                               JavaHighlightUtil.formatMethod(method) +\n                                                               \" from types \" +\n                                                               HighlightUtil.formatClass(containingClass) +\n                                                               \" and \" +\n                                                               HighlightUtil.formatClass(superContainingClass);\n                return HighlightInfo\n                  .newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(inheritUnrelatedDefaultsMessage)\n                  .create();\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }","id":89079,"modified_method":"static HighlightInfo checkUnrelatedDefaultMethods(@NotNull PsiClass aClass,\n                                                            @NotNull Collection<HierarchicalMethodSignature> signaturesWithSupers,\n                                                            @NotNull PsiIdentifier classIdentifier) {\n    for (HierarchicalMethodSignature methodSignature : signaturesWithSupers) {\n      final PsiMethod method = methodSignature.getMethod();\n      final boolean isAbstract = method.hasModifierProperty(PsiModifier.ABSTRACT);\n      if (method.hasModifierProperty(PsiModifier.DEFAULT) || isAbstract) {\n        final PsiClass containingClass = method.getContainingClass();\n        List<HierarchicalMethodSignature> superSignatures = methodSignature.getSuperSignatures();\n        if (!superSignatures.isEmpty()) {\n          for (HierarchicalMethodSignature signature : superSignatures) {\n            final PsiMethod superMethod = signature.getMethod();\n            final PsiClass superContainingClass = superMethod.getContainingClass();\n            if (containingClass != null && superContainingClass != null && !InheritanceUtil.isInheritorOrSelf(containingClass, superContainingClass, true)) {\n              final boolean isDefault = superMethod.hasModifierProperty(PsiModifier.DEFAULT);\n              if (!aClass.hasModifierProperty(PsiModifier.ABSTRACT) && !isDefault && !isAbstract) {\n                final String message = JavaErrorMessages.message(\n                  aClass instanceof PsiEnumConstantInitializer ? \"enum.constant.should.implement.method\" : \"class.must.be.abstract\",\n                  HighlightUtil.formatClass(superContainingClass),\n                  JavaHighlightUtil.formatMethod(superMethod),\n                  HighlightUtil.formatClass(superContainingClass, false));\n                return HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR)\n                  .range(classIdentifier).descriptionAndTooltip(message)\n                  .create();\n              }\n\n              if (isDefault || !isAbstract && superMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {\n                final String message = isDefault\n                                       ? \" inherits unrelated defaults for \"\n                                       : \" inherits abstract and default for \";\n                final String inheritUnrelatedDefaultsMessage = HighlightUtil.formatClass(aClass) +\n                                                               message +\n                                                               JavaHighlightUtil.formatMethod(method) +\n                                                               \" from types \" +\n                                                               HighlightUtil.formatClass(containingClass) +\n                                                               \" and \" +\n                                                               HighlightUtil.formatClass(superContainingClass);\n                return HighlightInfo\n                  .newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(inheritUnrelatedDefaultsMessage)\n                  .create();\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"0d6694186630cbe543a87acb209de181dcc31b47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitClass(@NotNull PsiClass aClass) {\n      // no call to super, so that it doesn't drill down to inner classes\n      if (!UtilityClassUtil.isUtilityClass(aClass)) {\n        return;\n      }\n      if (aClass.hasModifierProperty(PsiModifier.FINAL)) {\n        return;\n      }\n      registerClassError(aClass, aClass);\n    }","id":89080,"modified_method":"@Override\n    public void visitClass(@NotNull PsiClass aClass) {\n      // no call to super, so that it doesn't drill down to inner classes\n      if (!UtilityClassUtil.isUtilityClass(aClass)) {\n        return;\n      }\n      if (aClass.hasModifierProperty(PsiModifier.FINAL) ||\n        aClass.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        return;\n      }\n      registerClassError(aClass, aClass);\n    }","commit_id":"9a5eff6eb2dd4aa79d1e9f53e839199ad61d882e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected UsageInfo[] findUsages() {\n    final ArrayList<UsageInfo> result = new ArrayList<UsageInfo>();\n    final PsiClass containingClass = getMethod().getContainingClass();\n    final SearchScope scope = PsiUtilCore.getVirtualFile(containingClass) == null\n                              ? new LocalSearchScope(containingClass)\n                              : GlobalSearchScope.projectScope(myProject);\n    PsiReference[] refs =\n        ReferencesSearch.search(getMethod(), scope, false).toArray(PsiReference.EMPTY_ARRAY);\n    for (PsiReference ref : refs) {\n      final PsiElement element = ref.getElement();\n      if (element != null && element.isValid()) {\n        result.add(new UsageInfo(element));\n      }\n    }\n    if (isCreateInnerClass()) {\n      final Set<PsiMethod> usedMethods = new LinkedHashSet<PsiMethod>();\n      getMethod().accept(new JavaRecursiveElementWalkingVisitor() {\n        @Override\n        public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n          super.visitMethodCallExpression(expression);\n          final PsiMethod method = expression.resolveMethod();\n          if (method != null) {\n            usedMethods.add(method);\n          }\n        }\n      });\n\n\n      for (PsiMethod usedMethod : usedMethods) {\n        if (usedMethod.getModifierList().hasModifierProperty(PsiModifier.PRIVATE)) {\n          PsiMethod toMove = usedMethod;\n          for (PsiReference reference : ReferencesSearch.search(usedMethod)) {\n            if (!PsiTreeUtil.isAncestor(getMethod(), reference.getElement(), false)) {\n              toMove = null;\n              break;\n            }\n          }\n          if (toMove != null) {\n            myUsages.add(new MethodToMoveUsageInfo(toMove));\n          }\n        }\n      }\n    }\n    UsageInfo[] usageInfos = result.toArray(new UsageInfo[result.size()]);\n    return UsageViewUtil.removeDuplicatedUsages(usageInfos);\n  }","id":89081,"modified_method":"@NotNull\n  protected UsageInfo[] findUsages() {\n    final ArrayList<UsageInfo> result = new ArrayList<UsageInfo>();\n    final PsiClass containingClass = getMethod().getContainingClass();\n    final SearchScope scope = PsiUtilCore.getVirtualFile(containingClass) == null\n                              ? new LocalSearchScope(containingClass)\n                              : GlobalSearchScope.projectScope(myProject);\n    PsiReference[] refs =\n        ReferencesSearch.search(getMethod(), scope, false).toArray(PsiReference.EMPTY_ARRAY);\n    for (PsiReference ref : refs) {\n      final PsiElement element = ref.getElement();\n      if (element != null && element.isValid()) {\n        result.add(new UsageInfo(element));\n      }\n    }\n    if (isCreateInnerClass()) {\n      final Set<PsiMethod> usedMethods = new LinkedHashSet<PsiMethod>();\n      getMethod().accept(new JavaRecursiveElementWalkingVisitor() {\n        @Override\n        public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n          super.visitMethodCallExpression(expression);\n          final PsiMethod method = expression.resolveMethod();\n          if (method != null) {\n            usedMethods.add(method);\n          }\n        }\n      });\n\n\n      for (PsiMethod usedMethod : usedMethods) {\n        PsiModifierList modifiers = usedMethod.getModifierList();\n        if (modifiers.hasModifierProperty(PsiModifier.PRIVATE) && !modifiers.hasModifierProperty(PsiModifier.STATIC)) {\n          PsiMethod toMove = usedMethod;\n          for (PsiReference reference : ReferencesSearch.search(usedMethod)) {\n            if (!PsiTreeUtil.isAncestor(getMethod(), reference.getElement(), false)) {\n              toMove = null;\n              break;\n            }\n          }\n          if (toMove != null) {\n            myUsages.add(new MethodToMoveUsageInfo(toMove));\n          }\n        }\n      }\n    }\n    UsageInfo[] usageInfos = result.toArray(new UsageInfo[result.size()]);\n    return UsageViewUtil.removeDuplicatedUsages(usageInfos);\n  }","commit_id":"bcfc1fe10fccb6aa05f762cc66cc4199de3b72a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      //no call to super, so we don't drill into anonymous classes\n      if (method.isConstructor()) {\n        return;\n      }\n      final PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (containingClass.isInterface() ||\n          containingClass.isAnnotationType()) {\n        return;\n      }\n      if (!containingClass.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        return;\n      }\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        return;\n      }\n      if (!MethodUtils.isEmpty(method)) {\n        return;\n      }\n      registerMethodError(method);\n    }","id":89082,"modified_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      if (method.isConstructor()) {\n        return;\n      }\n      final PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (containingClass.isInterface() || containingClass.isAnnotationType()) {\n        return;\n      }\n      if (!containingClass.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        return;\n      }\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT) || method.hasModifierProperty(PsiModifier.NATIVE)) {\n        return;\n      }\n      if (!MethodUtils.isEmpty(method)) {\n        return;\n      }\n      registerMethodError(method);\n    }","commit_id":"149159c6cfc45f99b11010482b3a148d5c8d7f37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean classHasNoArgConstructor(PsiClass ancestor) {\n            boolean hasConstructor = false;\n            boolean hasNoArgConstructor = false;\n            final PsiMethod[] methods = ancestor.getMethods();\n            for (int i = 0; i < methods.length; i++) {\n                final PsiMethod method = methods[i];\n                if (method.isConstructor()) {\n                    hasConstructor = true;\n                    final PsiParameterList params = method.getParameterList();\n                    if (params != null) {\n                        if (params.getParameters().length == 0\n                                && method.hasModifierProperty(PsiModifier.PUBLIC)) {\n                            hasNoArgConstructor = true;\n                        }\n                    }\n                }\n\n            }\n            return hasNoArgConstructor || !hasConstructor;\n        }","id":89083,"modified_method":"private static boolean classHasNoArgConstructor(PsiClass ancestor) {\n            boolean hasConstructor = false;\n            boolean hasNoArgConstructor = false;\n            final PsiMethod[] methods = ancestor.getMethods();\n            for (int i = 0; i < methods.length; i++) {\n                final PsiMethod method = methods[i];\n                if (method.isConstructor()) {\n                    hasConstructor = true;\n                    final PsiParameterList params = method.getParameterList();\n                    if (params != null) {\n                        if (params.getParameters().length == 0\n                                && (method.hasModifierProperty(PsiModifier.PUBLIC) ||\n                                    method.hasModifierProperty(PsiModifier.PROTECTED))) {\n                            hasNoArgConstructor = true;\n                        }\n                    }\n                }\n\n            }\n            return hasNoArgConstructor || !hasConstructor;\n        }","commit_id":"0180cb945f6be2c82a8f1be4bf38437191f8cdd9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public List<ClassDescriptor> resolveInnerClasses(DeclarationDescriptor owner, PsiClass psiClass, boolean staticMembers) {\n        return innerClassResolver.resolveInnerClasses(owner, psiClass, staticMembers);\n    }","id":89084,"modified_method":"@NotNull\n    public List<ClassDescriptor> resolveInnerClasses(\n            @NotNull DeclarationDescriptor owner,\n            @NotNull ClassPsiDeclarationProvider declarationProvider)\n    {\n        return innerClassResolver.resolveInnerClasses(owner, declarationProvider);\n    }","commit_id":"737b246b0182fd69c27075a9a4589f1d543a1ff1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<ClassDescriptor> resolveInnerClasses(@NotNull DeclarationDescriptor owner, @NotNull PsiClass psiClass, boolean staticMembers) {\n        if (staticMembers) {\n            return resolveInnerClassesOfClassObject(owner, psiClass);\n        }\n\n        return resolveInnerClasses(owner, psiClass);\n    }","id":89085,"modified_method":"@NotNull\n    private List<ClassDescriptor> resolveInnerClasses(@NotNull DeclarationDescriptor owner, @NotNull PsiClass psiClass, boolean isStatic) {\n        PsiClass[] innerPsiClasses = psiClass.getInnerClasses();\n        List<ClassDescriptor> result = new ArrayList<ClassDescriptor>(innerPsiClasses.length);\n        for (PsiClass innerPsiClass : innerPsiClasses) {\n            if (shouldBeIgnored(owner, innerPsiClass, isStatic)) {\n                continue;\n            }\n            ClassDescriptor classDescriptor = resolveInnerClass(innerPsiClass);\n            result.add(classDescriptor);\n        }\n        return result;\n    }","commit_id":"737b246b0182fd69c27075a9a4589f1d543a1ff1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private List<ClassDescriptor> resolveInnerClasses(@NotNull DeclarationDescriptor owner, @NotNull PsiClass psiClass) {\n        PsiClass[] innerPsiClasses = psiClass.getInnerClasses();\n        List<ClassDescriptor> result = new ArrayList<ClassDescriptor>(innerPsiClasses.length);\n        for (PsiClass innerPsiClass : innerPsiClasses) {\n            if (shouldBeIgnored(owner, innerPsiClass)) {\n                continue;\n            }\n            ClassDescriptor classDescriptor = resolveInnerClass(innerPsiClass);\n            result.add(classDescriptor);\n        }\n        return result;\n    }","id":89086,"modified_method":"@NotNull\n    public List<ClassDescriptor> resolveInnerClasses(@NotNull DeclarationDescriptor owner,\n            @NotNull ClassPsiDeclarationProvider declarationProvider) {\n        if (declarationProvider.isStaticMembers() && declarationProvider.getDeclarationOrigin() == KOTLIN) {\n            return resolveInnerClassesOfClassObject(owner, declarationProvider.getPsiClass());\n        }\n\n        return resolveInnerClasses(owner, declarationProvider.getPsiClass(), declarationProvider.isStaticMembers());\n    }","commit_id":"737b246b0182fd69c27075a9a4589f1d543a1ff1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean shouldBeIgnored(DeclarationDescriptor owner, PsiClass innerPsiClass) {\n        // TODO: hack against inner classes\n        return innerPsiClass.hasModifierProperty(PsiModifier.PRIVATE)\n                || innerPsiClass.getName().equals(JvmAbi.CLASS_OBJECT_CLASS_NAME)\n                || DescriptorResolverUtils.isInnerEnum(innerPsiClass, owner);\n    }","id":89087,"modified_method":"private static boolean shouldBeIgnored(DeclarationDescriptor owner, PsiClass innerPsiClass, boolean isStatic) {\n        // TODO: hack against inner classes\n        return innerPsiClass.hasModifierProperty(PsiModifier.PRIVATE)\n                || innerPsiClass.hasModifierProperty(PsiModifier.STATIC) != isStatic\n                || innerPsiClass.getName().equals(JvmAbi.CLASS_OBJECT_CLASS_NAME)\n                || DescriptorResolverUtils.isInnerEnum(innerPsiClass, owner);\n    }","commit_id":"737b246b0182fd69c27075a9a4589f1d543a1ff1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    protected Collection<ClassDescriptor> computeInnerClasses() {\n        return getResolver().resolveInnerClasses(descriptor, declarationProvider.getPsiClass(), false);\n    }","id":89088,"modified_method":"@NotNull\n    @Override\n    protected Collection<ClassDescriptor> computeInnerClasses() {\n        return getResolver().resolveInnerClasses(descriptor, declarationProvider);\n    }","commit_id":"737b246b0182fd69c27075a9a4589f1d543a1ff1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  public InspectionGadgetsFix[] buildFixes(Object... infos) {\n    final List<InspectionGadgetsFix> fixes = new ArrayList();\n    final PsiMethod constructor = (PsiMethod)infos[0];\n    final PsiClass aClass = constructor.getContainingClass();\n    if (aClass.hasModifierProperty(PsiModifier.PROTECTED)) {\n      fixes.add(new SetConstructorModifierFix(PsiModifier.PROTECTED));\n    }\n    else if (aClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n      fixes.add(new SetConstructorModifierFix(PsiModifier.PRIVATE));\n    }\n    fixes.add(new RemoveModifierFix(PsiModifier.PUBLIC));\n    return fixes.toArray(new InspectionGadgetsFix[fixes.size()]);\n  }","id":89089,"modified_method":"@NotNull\n  public InspectionGadgetsFix[] buildFixes(Object... infos) {\n    final List<InspectionGadgetsFix> fixes = new ArrayList();\n    final PsiMethod constructor = (PsiMethod)infos[0];\n    final PsiClass aClass = constructor.getContainingClass();\n    if (aClass != null && aClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n      fixes.add(new SetConstructorModifierFix(PsiModifier.PRIVATE));\n    }\n    fixes.add(new RemoveModifierFix(PsiModifier.PUBLIC));\n    return fixes.toArray(new InspectionGadgetsFix[fixes.size()]);\n  }","commit_id":"ea497a192c28ccd6638466e3c3f7f6205bb8b4f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      //no call to super, so we don't drill into anonymous classes\n      if (!method.isConstructor()) {\n        return;\n      }\n      if (!method.hasModifierProperty(PsiModifier.PUBLIC)) {\n        return;\n      }\n      final PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (containingClass.hasModifierProperty(PsiModifier.PUBLIC)) {\n        return;\n      }\n      if (SerializationUtils.isExternalizable(containingClass)) {\n        final PsiParameterList parameterList =\n          method.getParameterList();\n        if (parameterList.getParametersCount() == 0) {\n          return;\n        }\n      }\n      registerModifierError(PsiModifier.PUBLIC, method, method);\n    }","id":89090,"modified_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      //no call to super, so we don't drill into anonymous classes\n      if (!method.isConstructor()) {\n        return;\n      }\n      if (!method.hasModifierProperty(PsiModifier.PUBLIC)) {\n        return;\n      }\n      final PsiClass containingClass = method.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (containingClass.hasModifierProperty(PsiModifier.PUBLIC) ||\n        containingClass.hasModifierProperty(PsiModifier.PROTECTED)) {\n        return;\n      }\n      if (SerializationUtils.isExternalizable(containingClass)) {\n        final PsiParameterList parameterList = method.getParameterList();\n        if (parameterList.getParametersCount() == 0) {\n          return;\n        }\n      }\n      registerModifierError(PsiModifier.PUBLIC, method, method);\n    }","commit_id":"ea497a192c28ccd6638466e3c3f7f6205bb8b4f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isAppletClass(final PsiClass aClass, final PsiManager manager) {\n    if (!ExecutionUtil.isRunnableClass(aClass)) return false;\n\n    final Module module = ExecutionUtil.findModule(aClass);\n    final GlobalSearchScope scope = module != null\n                              ? GlobalSearchScope.moduleWithLibrariesScope(module)\n                              : GlobalSearchScope.projectScope(manager.getProject());\n    PsiClass appletClass = manager.findClass(\"java.applet.Applet\", scope);\n    if (appletClass != null) {\n      if (aClass.isInheritor(appletClass, true)) return true;\n    }\n    appletClass = manager.findClass(\"javax.swing.JApplet\", scope);\n    if (appletClass != null) {\n      if (aClass.isInheritor(appletClass, true)) return true;\n    }\n    return false;\n  }","id":89091,"modified_method":"private static boolean isAppletClass(final PsiClass aClass, final PsiManager manager) {\n    if (!ExecutionUtil.isRunnableClass(aClass, true)) return false;\n\n    final Module module = ExecutionUtil.findModule(aClass);\n    final GlobalSearchScope scope = module != null\n                              ? GlobalSearchScope.moduleWithLibrariesScope(module)\n                              : GlobalSearchScope.projectScope(manager.getProject());\n    PsiClass appletClass = manager.findClass(\"java.applet.Applet\", scope);\n    if (appletClass != null) {\n      if (aClass.isInheritor(appletClass, true)) return true;\n    }\n    appletClass = manager.findClass(\"javax.swing.JApplet\", scope);\n    if (appletClass != null) {\n      if (aClass.isInheritor(appletClass, true)) return true;\n    }\n    return false;\n  }","commit_id":"b2a351779030f119cf0dfa20990272703d31257a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int getClassKindImpl(PsiClass aClass) {\n    if (!aClass.isValid()) return CLASS_KIND_CLASS;\n\n    if (aClass.isAnnotationType()) {\n      return CLASS_KIND_ANNOTATION;\n    }\n    if (aClass.isEnum()) {\n      return CLASS_KIND_ENUM;\n    }\n    if (aClass.isInterface()) {\n      return CLASS_KIND_INTERFACE;\n    }\n    if (aClass instanceof JspClass) {\n      return CLASS_KIND_JSP;\n    }\n    if (aClass instanceof PsiAnonymousClass) {\n      return CLASS_KIND_ANONYMOUS;\n    }\n\n    final PsiManager manager = aClass.getManager();\n    final PsiClass javaLangTrowable = manager.findClass(\"java.lang.Throwable\", aClass.getResolveScope());\n    final boolean isException = javaLangTrowable != null && InheritanceUtil.isInheritorOrSelf(aClass, javaLangTrowable, true);\n    if (isException) {\n      return CLASS_KIND_EXCEPTION;\n    }\n\n    if (JUnitUtil.isTestClass(aClass)) {\n      return CLASS_KIND_JUNIT_TEST;\n    }\n    if (ExecutionUtil.isRunnableClass(aClass) && ApplicationConfigurationType.findMainMethod(aClass) != null) {\n      return CLASS_KIND_RUNNABLE;\n    }\n    return CLASS_KIND_CLASS;\n  }","id":89092,"modified_method":"private static int getClassKindImpl(PsiClass aClass) {\n    if (!aClass.isValid()) return CLASS_KIND_CLASS;\n\n    if (aClass.isAnnotationType()) {\n      return CLASS_KIND_ANNOTATION;\n    }\n    if (aClass.isEnum()) {\n      return CLASS_KIND_ENUM;\n    }\n    if (aClass.isInterface()) {\n      return CLASS_KIND_INTERFACE;\n    }\n    if (aClass instanceof JspClass) {\n      return CLASS_KIND_JSP;\n    }\n    if (aClass instanceof PsiAnonymousClass) {\n      return CLASS_KIND_ANONYMOUS;\n    }\n\n    final PsiManager manager = aClass.getManager();\n    final PsiClass javaLangTrowable = manager.findClass(\"java.lang.Throwable\", aClass.getResolveScope());\n    final boolean isException = javaLangTrowable != null && InheritanceUtil.isInheritorOrSelf(aClass, javaLangTrowable, true);\n    if (isException) {\n      return CLASS_KIND_EXCEPTION;\n    }\n\n    if (JUnitUtil.isTestClass(aClass)) {\n      return CLASS_KIND_JUNIT_TEST;\n    }\n    if (ExecutionUtil.isRunnableClass(aClass, false) && ApplicationConfigurationType.findMainMethod(aClass) != null) {\n      return CLASS_KIND_RUNNABLE;\n    }\n    return CLASS_KIND_CLASS;\n  }","commit_id":"b2a351779030f119cf0dfa20990272703d31257a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isRunnableClass(final PsiClass aClass) {\n    if (aClass instanceof PsiAnonymousClass) return false;\n    if (aClass.isInterface()) return false;\n    if (!aClass.hasModifierProperty(PsiModifier.PUBLIC)) return false;\n    if (aClass.hasModifierProperty(PsiModifier.ABSTRACT)) return false;\n    return aClass.getContainingClass() == null || aClass.hasModifierProperty(PsiModifier.STATIC);\n  }","id":89093,"modified_method":"public static boolean isRunnableClass(final PsiClass aClass, final boolean mustBePublic) {\n    if (aClass instanceof PsiAnonymousClass) return false;\n    if (aClass.isInterface()) return false;\n    if (mustBePublic && !aClass.hasModifierProperty(PsiModifier.PUBLIC)) return false;\n    if (aClass.hasModifierProperty(PsiModifier.ABSTRACT) || aClass.hasModifierProperty(PsiModifier.PRIVATE)) return false;\n    return aClass.getContainingClass() == null || aClass.hasModifierProperty(PsiModifier.STATIC);\n  }","commit_id":"b2a351779030f119cf0dfa20990272703d31257a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass)) return false;\n    if (isTestCaseInheritor(psiClass)) return true;\n    if (psiClass.getModifierList().findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isSuiteMethod(method)) return true;\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","id":89094,"modified_method":"public static boolean isTestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass, true)) return false;\n    if (isTestCaseInheritor(psiClass)) return true;\n    if (psiClass.getModifierList().findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isSuiteMethod(method)) return true;\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","commit_id":"b2a351779030f119cf0dfa20990272703d31257a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isJUnit4TestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass)) return false;\n\n    if (psiClass.getModifierList().findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","id":89095,"modified_method":"public static boolean isJUnit4TestClass(final PsiClass psiClass) {\n    if (!ExecutionUtil.isRunnableClass(psiClass, true)) return false;\n\n    if (psiClass.getModifierList().findAnnotation(\"org.junit.runner.RunWith\") != null) return true;\n    for (final PsiMethod method : psiClass.getMethods()) {\n      if (isTestAnnotated(method)) return true;\n    }\n    return false;\n  }","commit_id":"b2a351779030f119cf0dfa20990272703d31257a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitField(@NotNull PsiField field) {\n      if (field.hasModifierProperty(PsiModifier.STATIC)) {\n        return;\n      }\n      if (field.getInitializer() != null) {\n        return;\n      }\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(field, annotationNames);\n      if (annotation != null) {\n        return;\n      }\n      if (m_ignorePrimitives) {\n        final PsiType fieldType = field.getType();\n        if (ClassUtils.isPrimitive(fieldType)) {\n          return;\n        }\n      }\n      final PsiClass aClass = field.getContainingClass();\n      if (aClass == null) {\n        return;\n      }\n      for (ImplicitUsageProvider provider :\n        Extensions.getExtensions(ImplicitUsageProvider.EP_NAME)) {\n        if (provider.isImplicitWrite(field)) {\n          return;\n        }\n      }\n      final UninitializedReadCollector uninitializedReadsCollector = new UninitializedReadCollector();\n      if (!isInitializedInInitializer(field, uninitializedReadsCollector)) {\n        final PsiMethod[] constructors = aClass.getConstructors();\n        for (final PsiMethod constructor : constructors) {\n          final PsiCodeBlock body = constructor.getBody();\n          uninitializedReadsCollector.blockAssignsVariable(body, field);\n        }\n      }\n      final PsiExpression[] badReads = uninitializedReadsCollector.getUninitializedReads();\n      for (PsiExpression expression : badReads) {\n        registerError(expression, field);\n      }\n    }","id":89096,"modified_method":"@Override\n    public void visitField(@NotNull PsiField field) {\n      if (field.hasModifierProperty(PsiModifier.STATIC) || field.hasModifierProperty(PsiModifier.FINAL)) {\n        return;\n      }\n      if (field.getInitializer() != null) {\n        return;\n      }\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(field, annotationNames);\n      if (annotation != null) {\n        return;\n      }\n      if (m_ignorePrimitives) {\n        final PsiType fieldType = field.getType();\n        if (ClassUtils.isPrimitive(fieldType)) {\n          return;\n        }\n      }\n      final PsiClass aClass = field.getContainingClass();\n      if (aClass == null) {\n        return;\n      }\n      for (ImplicitUsageProvider provider :\n        Extensions.getExtensions(ImplicitUsageProvider.EP_NAME)) {\n        if (provider.isImplicitWrite(field)) {\n          return;\n        }\n      }\n      final UninitializedReadCollector uninitializedReadsCollector = new UninitializedReadCollector();\n      if (!isInitializedInInitializer(field, uninitializedReadsCollector)) {\n        final PsiMethod[] constructors = aClass.getConstructors();\n        for (final PsiMethod constructor : constructors) {\n          final PsiCodeBlock body = constructor.getBody();\n          uninitializedReadsCollector.blockAssignsVariable(body, field);\n        }\n      }\n      final PsiExpression[] badReads = uninitializedReadsCollector.getUninitializedReads();\n      for (PsiExpression expression : badReads) {\n        registerError(expression, field);\n      }\n    }","commit_id":"c27b4f50fbcb2a71ca2c7f2d85e67debfea58f27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitField(@NotNull PsiField field) {\n      if (!field.hasModifierProperty(PsiModifier.STATIC)) {\n        return;\n      }\n      if (field.getInitializer() != null) {\n        return;\n      }\n      final PsiClass containingClass = field.getContainingClass();\n      if (containingClass == null) {\n        return;\n      }\n      if (containingClass.isEnum()) {\n        return;\n      }\n      if (m_ignorePrimitives) {\n        final PsiType type = field.getType();\n        if (ClassUtils.isPrimitive(type)) {\n          return;\n        }\n      }\n      final PsiClassInitializer[] initializers =\n        containingClass.getInitializers();\n      for (final PsiClassInitializer initializer : initializers) {\n        if (initializer.hasModifierProperty(PsiModifier.STATIC)) {\n          final PsiCodeBlock body = initializer.getBody();\n          if (InitializationUtils.blockAssignsVariableOrFails(body,\n                                                              field)) {\n            return;\n          }\n        }\n      }\n      registerFieldError(field);\n    }","id":89097,"modified_method":"@Override\n    public void visitField(@NotNull PsiField field) {\n      if (!field.hasModifierProperty(PsiModifier.STATIC) || field.hasModifierProperty(PsiModifier.FINAL)) {\n        return;\n      }\n      if (field.getInitializer() != null) {\n        return;\n      }\n      final PsiClass containingClass = field.getContainingClass();\n      if (containingClass == null || containingClass.isEnum()) {\n        return;\n      }\n      if (m_ignorePrimitives) {\n        final PsiType type = field.getType();\n        if (ClassUtils.isPrimitive(type)) {\n          return;\n        }\n      }\n      final PsiClassInitializer[] initializers = containingClass.getInitializers();\n      for (final PsiClassInitializer initializer : initializers) {\n        if (!initializer.hasModifierProperty(PsiModifier.STATIC)) {\n          continue;\n        }\n        final PsiCodeBlock body = initializer.getBody();\n        if (InitializationUtils.blockAssignsVariableOrFails(body, field)) {\n          return;\n        }\n      }\n      registerFieldError(field);\n    }","commit_id":"c27b4f50fbcb2a71ca2c7f2d85e67debfea58f27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Pair<PsiMethod, PsiClass> getSiblingInfoInheritedViaSubClass(@NotNull final PsiMethod method) {\n    if (!method.hasModifierProperty(PsiModifier.PUBLIC)) return null;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return null;\n    final PsiClass containingClass = method.getContainingClass();\n    if (containingClass == null || containingClass.isInterface()) {\n      return null;\n    }\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(containingClass.getQualifiedName())) {\n      return null;\n    }\n    final Collection<PsiAnchor> checkedInterfaces = new THashSet<>();\n    checkedInterfaces.add(PsiAnchor.create(containingClass));\n    final Ref<Pair<PsiMethod, PsiClass>> result = Ref.create();\n    ClassInheritorsSearch.search(containingClass, containingClass.getUseScope(), true, true, false).forEach(\n    inheritor -> {\n      ProgressManager.checkCanceled();\n      for (PsiClassType interfaceType : inheritor.getImplementsListTypes()) {\n        ProgressManager.checkCanceled();\n        PsiClassType.ClassResolveResult resolved = interfaceType.resolveGenerics();\n        PsiClass anInterface = resolved.getElement();\n        if (anInterface == null || !checkedInterfaces.add(PsiAnchor.create(anInterface))) continue;\n        for (PsiMethod superMethod : anInterface.findMethodsByName(method.getName(), true)) {\n          PsiElement navigationElement = superMethod.getNavigationElement();\n          if (!(navigationElement instanceof PsiMethod)) continue; // Kotlin\n          superMethod = (PsiMethod)navigationElement;\n          ProgressManager.checkCanceled();\n          PsiClass superInterface = superMethod.getContainingClass();\n          if (superInterface == null) {\n            continue;\n          }\n          if (containingClass.isInheritor(superInterface, true)) {\n            // if containingClass implements the superInterface then it's not a sibling inheritance but a pretty boring the usual one\n            continue;\n          }\n\n          // calculate substitutor of containingClass --> inheritor\n          PsiSubstitutor substitutor = TypeConversionUtil.getSuperClassSubstitutor(containingClass, inheritor, PsiSubstitutor.EMPTY);\n          // calculate substitutor of inheritor --> superInterface\n          substitutor = TypeConversionUtil.getSuperClassSubstitutor(superInterface, inheritor, substitutor);\n\n          final MethodSignature superSignature = superMethod.getSignature(substitutor);\n          final MethodSignature derivedSignature = method.getSignature(PsiSubstitutor.EMPTY);\n          boolean isOverridden = MethodSignatureUtil.isSubsignature(superSignature, derivedSignature);\n\n          if (!isOverridden) {\n            continue;\n          }\n          result.set(Pair.create(superMethod, inheritor));\n          return false;\n        }\n      }\n      return true;\n    });\n    return result.get();\n  }","id":89098,"modified_method":"public static Pair<PsiMethod, PsiClass> getSiblingInfoInheritedViaSubClass(@NotNull final PsiMethod method) {\n    boolean canHaveSiblingSuper = !method.hasModifierProperty(PsiModifier.ABSTRACT) &&\n                                  !method.hasModifierProperty(PsiModifier.STATIC) &&\n                                  method.hasModifierProperty(PsiModifier.PUBLIC) &&\n                                  !method.hasModifierProperty(PsiModifier.FINAL) &&\n                                  !method.hasModifierProperty(PsiModifier.NATIVE);\n    if (!canHaveSiblingSuper) return null;\n    final PsiClass containingClass = method.getContainingClass();\n    if (containingClass == null || containingClass.isInterface() || containingClass.hasModifierProperty(PsiModifier.FINAL)) {\n      return null;\n    }\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(containingClass.getQualifiedName())) {\n      return null;\n    }\n    final Collection<PsiAnchor> checkedInterfaces = new THashSet<>();\n    checkedInterfaces.add(PsiAnchor.create(containingClass));\n    final Ref<Pair<PsiMethod, PsiClass>> result = Ref.create();\n    ClassInheritorsSearch.search(containingClass, containingClass.getUseScope(), true, true, false).forEach(\n    inheritor -> {\n      ProgressManager.checkCanceled();\n      for (PsiClassType interfaceType : inheritor.getImplementsListTypes()) {\n        ProgressManager.checkCanceled();\n        PsiClassType.ClassResolveResult resolved = interfaceType.resolveGenerics();\n        PsiClass anInterface = resolved.getElement();\n        if (anInterface == null || !checkedInterfaces.add(PsiAnchor.create(anInterface))) continue;\n        for (PsiMethod superMethod : anInterface.findMethodsByName(method.getName(), true)) {\n          PsiElement navigationElement = superMethod.getNavigationElement();\n          if (!(navigationElement instanceof PsiMethod)) continue; // Kotlin\n          superMethod = (PsiMethod)navigationElement;\n          ProgressManager.checkCanceled();\n          PsiClass superInterface = superMethod.getContainingClass();\n          if (superInterface == null) {\n            continue;\n          }\n          if (containingClass.isInheritor(superInterface, true)) {\n            // if containingClass implements the superInterface then it's not a sibling inheritance but a pretty boring the usual one\n            continue;\n          }\n\n          // calculate substitutor of containingClass --> inheritor\n          PsiSubstitutor substitutor = TypeConversionUtil.getSuperClassSubstitutor(containingClass, inheritor, PsiSubstitutor.EMPTY);\n          // calculate substitutor of inheritor --> superInterface\n          substitutor = TypeConversionUtil.getSuperClassSubstitutor(superInterface, inheritor, substitutor);\n\n          final MethodSignature superSignature = superMethod.getSignature(substitutor);\n          final MethodSignature derivedSignature = method.getSignature(PsiSubstitutor.EMPTY);\n          boolean isOverridden = MethodSignatureUtil.isSubsignature(superSignature, derivedSignature);\n\n          if (!isOverridden) {\n            continue;\n          }\n          result.set(Pair.create(superMethod, inheritor));\n          return false;\n        }\n      }\n      return true;\n    });\n    return result.get();\n  }","commit_id":"67e5371da15549e5da147fdf772b84ef5e6eeede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void collectSiblingInheritedMethods(@NotNull final Collection<PsiMethod> methods,\n                                                     @NotNull Collection<LineMarkerInfo> result) {\n    for (PsiMethod method : methods) {\n      ProgressManager.checkCanceled();\n      PsiClass aClass = method.getContainingClass();\n      if (aClass == null || aClass.hasModifierProperty(PsiModifier.FINAL) || aClass.isInterface()) continue;\n\n      boolean canHaveSiblingSuper = !method.hasModifierProperty(PsiModifier.ABSTRACT) && !method.hasModifierProperty(PsiModifier.STATIC) && method.hasModifierProperty(PsiModifier.PUBLIC)&& !method.hasModifierProperty(PsiModifier.FINAL)&& !method.hasModifierProperty(PsiModifier.NATIVE);\n      if (!canHaveSiblingSuper) continue;\n\n      PsiMethod siblingInheritedViaSubClass = FindSuperElementsHelper.getSiblingInheritedViaSubClass(method);\n      if (siblingInheritedViaSubClass == null) {\n        continue;\n      }\n      PsiElement range = getMethodRange(method);\n      ArrowUpLineMarkerInfo upInfo = new ArrowUpLineMarkerInfo(range, AllIcons.Gutter.ImplementingMethod, MarkerType.SIBLING_OVERRIDING_METHOD,\n                                                              Pass.UPDATE_OVERRIDDEN_MARKERS);\n      LineMarkerInfo info = NavigateAction.setNavigateAction(upInfo, \"Go to super method\", IdeActions.ACTION_GOTO_SUPER);\n      result.add(info);\n    }\n  }","id":89099,"modified_method":"private static void collectSiblingInheritedMethods(@NotNull final Collection<PsiMethod> methods,\n                                                     @NotNull Collection<LineMarkerInfo> result) {\n    for (PsiMethod method : methods) {\n      ProgressManager.checkCanceled();\n\n      PsiMethod siblingInheritedViaSubClass = FindSuperElementsHelper.getSiblingInheritedViaSubClass(method);\n      if (siblingInheritedViaSubClass == null) {\n        continue;\n      }\n      PsiElement range = getMethodRange(method);\n      ArrowUpLineMarkerInfo upInfo = new ArrowUpLineMarkerInfo(range, AllIcons.Gutter.ImplementingMethod, MarkerType.SIBLING_OVERRIDING_METHOD,\n                                                              Pass.UPDATE_OVERRIDDEN_MARKERS);\n      LineMarkerInfo info = NavigateAction.setNavigateAction(upInfo, \"Go to super method\", IdeActions.ACTION_GOTO_SUPER);\n      result.add(info);\n    }\n  }","commit_id":"67e5371da15549e5da147fdf772b84ef5e6eeede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void collectSlowLineMarkers(@NotNull final List<PsiElement> elements, @NotNull final Collection<LineMarkerInfo> result) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    Collection<PsiMethod> methods = new THashSet<>();\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0; i < elements.size(); i++) {\n      PsiElement element = elements.get(i);\n      ProgressManager.checkCanceled();\n      if (!(element instanceof PsiIdentifier)) continue;\n      PsiElement parent = element.getParent();\n      if (parent instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)parent;\n        if (PsiUtil.canBeOverriden(method)) {\n          methods.add(method);\n        }\n      }\n      else if (parent instanceof PsiClass && !(parent instanceof PsiTypeParameter)) {\n        collectInheritingClasses((PsiClass)parent, result);\n      }\n    }\n    if (!methods.isEmpty()) {\n      collectOverridingMethods(methods, result);\n      collectSiblingInheritedMethods(methods, result);\n    }\n  }","id":89100,"modified_method":"@Override\n  public void collectSlowLineMarkers(@NotNull final List<PsiElement> elements, @NotNull final Collection<LineMarkerInfo> result) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    Collection<PsiMethod> methods = new THashSet<>();\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0; i < elements.size(); i++) {\n      PsiElement element = elements.get(i);\n      ProgressManager.checkCanceled();\n      if (!(element instanceof PsiIdentifier)) continue;\n      PsiElement parent = element.getParent();\n      if (parent instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)parent;\n        if (PsiUtil.canBeOverriden(method)) {\n          methods.add(method);\n        }\n      }\n      else if (parent instanceof PsiClass && !(parent instanceof PsiTypeParameter)) {\n        collectInheritingClasses((PsiClass)parent, result);\n      }\n    }\n    if (!methods.isEmpty()) {\n      collectSiblingInheritedMethods(methods, result);\n      collectOverridingMethods(methods, result);\n    }\n  }","commit_id":"67e5371da15549e5da147fdf772b84ef5e6eeede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDoNotGoToSiblingInheritanceIfInLibrary() throws Throwable {\n    configureByFile(getBasePath() + \"OverridingLibrary.java\");\n    PsiJavaFile file = (PsiJavaFile)getFile();\n\n    PsiClass aThread = getJavaFacade().findClass(\"java.lang.Thread\");\n    PsiMethod startMethod = aThread.findMethodsByName(\"start\", false)[0];\n    PsiMethod sibling = FindSuperElementsHelper.getSiblingInheritedViaSubClass(startMethod);\n    assertNotNull(sibling);\n\n    Collection<PsiMethod> superMethods = SuperMethodWarningUtil.getSuperMethods(startMethod, aThread, Collections.emptyList());\n    assertEmpty(superMethods);\n  }","id":89101,"modified_method":"public void testDoNotGoToSiblingInheritanceIfInLibrary() throws Throwable {\n    configureByFile(getBasePath() + \"OverridingLibrary.java\");\n\n    PsiClass aThread = getJavaFacade().findClass(\"java.lang.Thread\");\n    PsiMethod startMethod = aThread.findMethodsByName(\"start\", false)[0];\n    PsiMethod sibling = FindSuperElementsHelper.getSiblingInheritedViaSubClass(startMethod);\n    assertNotNull(sibling);\n\n    Collection<PsiMethod> superMethods = SuperMethodWarningUtil.getSuperMethods(startMethod, aThread, Collections.emptyList());\n    assertEmpty(superMethods);\n  }","commit_id":"67e5371da15549e5da147fdf772b84ef5e6eeede","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean hasConstructors() {\n        return constructors.isEmpty();\n    }","id":89102,"modified_method":"@Override\n    public boolean hasConstructors() {\n        return !constructors.isEmpty();\n    }","commit_id":"7e5021d746274c4a7d4260b2617c5d170f35c611","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private ClassDescriptor createJavaClassDescriptor(@NotNull final PsiClass psiClass) {\n        assert !classDescriptorCache.containsKey(psiClass.getQualifiedName()) : psiClass.getQualifiedName();\n        classDescriptorCache.put(psiClass.getQualifiedName(), null); // TODO\n\n        String name = psiClass.getName();\n        PsiModifierList modifierList = psiClass.getModifierList();\n        JavaClassDescriptor classDescriptor = new JavaClassDescriptor(\n                JAVA_ROOT\n        );\n        classDescriptor.setName(name);\n\n        WritableFunctionGroup constructors = new WritableFunctionGroup(\"<init>\");\n        List<JetType> supertypes = new ArrayList<JetType>();\n        classDescriptor.setTypeConstructor(new TypeConstructorImpl(\n                classDescriptor,\n                Collections.<Annotation>emptyList(), // TODO\n                // TODO\n                modifierList == null ? false : modifierList.hasModifierProperty(PsiModifier.FINAL),\n                name,\n                resolveTypeParameters(psiClass.getTypeParameters()),\n                supertypes\n\n        ));\n        classDescriptorCache.put(psiClass.getQualifiedName(), classDescriptor);\n        classDescriptor.setUnsubstitutedMemberScope(new JavaClassMembersScope(classDescriptor, psiClass, semanticServices, false));\n        // UGLY HACK\n        supertypes.addAll(getSupertypes(psiClass));\n\n        // NOTE: this writes into constructors after it is remembered by the classDescriptor\n        PsiMethod[] psiConstructors = psiClass.getConstructors();\n        for (PsiMethod constructor : psiConstructors) {\n            ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(\n                    classDescriptor,\n                    Collections.<Annotation>emptyList(), // TODO\n                    false);\n            constructorDescriptor.initialize(resolveParameterDescriptors(constructorDescriptor, constructor.getParameterList().getParameters()));\n            classDescriptor.addConstructor(constructorDescriptor);\n            semanticServices.getTrace().recordDeclarationResolution(constructor, constructorDescriptor);\n        }\n\n        semanticServices.getTrace().recordDeclarationResolution(psiClass, classDescriptor);\n        return classDescriptor;\n    }","id":89103,"modified_method":"private ClassDescriptor createJavaClassDescriptor(@NotNull final PsiClass psiClass) {\n        assert !classDescriptorCache.containsKey(psiClass.getQualifiedName()) : psiClass.getQualifiedName();\n        classDescriptorCache.put(psiClass.getQualifiedName(), null); // TODO\n\n        String name = psiClass.getName();\n        PsiModifierList modifierList = psiClass.getModifierList();\n        JavaClassDescriptor classDescriptor = new JavaClassDescriptor(\n                JAVA_ROOT\n        );\n        classDescriptor.setName(name);\n\n        List<JetType> supertypes = new ArrayList<JetType>();\n        classDescriptor.setTypeConstructor(new TypeConstructorImpl(\n                classDescriptor,\n                Collections.<Annotation>emptyList(), // TODO\n                // TODO\n                psiClass.hasModifierProperty(PsiModifier.FINAL),\n                name,\n                resolveTypeParameters(psiClass.getTypeParameters()),\n                supertypes\n\n        ));\n        classDescriptorCache.put(psiClass.getQualifiedName(), classDescriptor);\n        classDescriptor.setUnsubstitutedMemberScope(new JavaClassMembersScope(classDescriptor, psiClass, semanticServices, false));\n        // UGLY HACK\n        supertypes.addAll(getSupertypes(psiClass));\n\n        PsiMethod[] psiConstructors = psiClass.getConstructors();\n\n        if (psiConstructors.length == 0) {\n            if (!psiClass.hasModifierProperty(PsiModifier.ABSTRACT) && !psiClass.isInterface()) {\n                ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(\n                        classDescriptor,\n                        Collections.<Annotation>emptyList(),\n                        false);\n                constructorDescriptor.initialize(Collections.<ValueParameterDescriptor>emptyList());\n                classDescriptor.addConstructor(constructorDescriptor);\n                semanticServices.getTrace().recordDeclarationResolution(psiClass, constructorDescriptor);\n            }\n        }\n        else {\n            for (PsiMethod constructor : psiConstructors) {\n                ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(\n                        classDescriptor,\n                        Collections.<Annotation>emptyList(), // TODO\n                        false);\n                constructorDescriptor.initialize(resolveParameterDescriptors(constructorDescriptor, constructor.getParameterList().getParameters()));\n                classDescriptor.addConstructor(constructorDescriptor);\n                semanticServices.getTrace().recordDeclarationResolution(constructor, constructorDescriptor);\n            }\n        }\n\n        semanticServices.getTrace().recordDeclarationResolution(psiClass, classDescriptor);\n        return classDescriptor;\n    }","commit_id":"7e5021d746274c4a7d4260b2617c5d170f35c611","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    final PsiMethod method = findMethod(file, offset);\n\n    if (method == null || !method.isValid()) return false;\n    setText(getIntentionName(method));\n\n    if (!method.getManager().isInProject(method)) return false;\n\n    PsiClass containingClass = method.getContainingClass();\n    if (containingClass == null) return false;\n    if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n      MyElementProcessor processor = new MyElementProcessor(method);\n      if (containingClass.isEnum()) {\n        for (PsiField field : containingClass.getFields()) {\n          if (field instanceof PsiEnumConstant) {\n            final PsiEnumConstantInitializer initializingClass = ((PsiEnumConstant)field).getInitializingClass();\n            if (initializingClass == null) {\n              processor.myHasMissingImplementations = true;\n            } else {\n              if (!processor.execute(initializingClass)){\n                break;\n              }\n            }\n          }\n        }\n      }\n      ClassInheritorsSearch.search(containingClass, false).forEach(new PsiElementProcessorAdapter<PsiClass>(\n        processor));\n      return isAvailable(processor);\n    }\n\n    return false;\n  }","id":89104,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    final PsiMethod method = findMethod(file, offset);\n\n    if (method == null || !method.isValid()) return false;\n    setText(getIntentionName(method));\n\n    if (!method.getManager().isInProject(method)) return false;\n\n    PsiClass containingClass = method.getContainingClass();\n    if (containingClass == null) return false;\n    if (method.hasModifierProperty(PsiModifier.ABSTRACT) || !method.hasModifierProperty(PsiModifier.PRIVATE)) {\n      MyElementProcessor processor = new MyElementProcessor(method);\n      if (containingClass.isEnum()) {\n        for (PsiField field : containingClass.getFields()) {\n          if (field instanceof PsiEnumConstant) {\n            final PsiEnumConstantInitializer initializingClass = ((PsiEnumConstant)field).getInitializingClass();\n            if (initializingClass == null) {\n              processor.myHasMissingImplementations = true;\n            } else {\n              if (!processor.execute(initializingClass)){\n                break;\n              }\n            }\n          }\n        }\n      }\n      ClassInheritorsSearch.search(containingClass, false).forEach(new PsiElementProcessorAdapter<PsiClass>(\n        processor));\n      return isAvailable(processor);\n    }\n\n    return false;\n  }","commit_id":"d6fbbdfe30084a3deb45c554d8f1246323d489f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(@NotNull PsiMethod method) {\n            //note: no call to super;\n            final String methodName = method.getName();\n            if (!\"clone\".equals(methodName)) {\n                return;\n            }\n            if(method.hasModifierProperty(PsiModifier.ABSTRACT))\n            {\n                return;\n            }\n            final PsiParameterList parameterList = method.getParameterList();\n            if (parameterList.getParameters().length != 0) {\n                return;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if (containingClass.isInterface() || containingClass.isAnnotationType()) {\n                return;\n            }\n            final CallToSuperCloneVisitor visitor = new CallToSuperCloneVisitor();\n            method.accept(visitor);\n            if (visitor.isCallToSuperCloneFound()) {\n                return;\n            }\n            registerMethodError(method);\n        }","id":89105,"modified_method":"public void visitMethod(@NotNull PsiMethod method) {\n            //note: no call to super;\n            final String methodName = method.getName();\n            if (!\"clone\".equals(methodName)) {\n                return;\n            }\n            if(method.hasModifierProperty(PsiModifier.ABSTRACT) ||\n                    method.hasModifierProperty(PsiModifier.NATIVE))\n            {\n                return;\n            }\n            final PsiParameterList parameterList = method.getParameterList();\n            if (parameterList.getParameters().length != 0) {\n                return;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if (containingClass.isInterface() || containingClass.isAnnotationType()) {\n                return;\n            }\n            final CallToSuperCloneVisitor visitor = new CallToSuperCloneVisitor();\n            method.accept(visitor);\n            if (visitor.isCallToSuperCloneFound()) {\n                return;\n            }\n            registerMethodError(method);\n        }","commit_id":"1d59b95aad9c712d65d003bb9d0834893ad8a7b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(@NotNull PsiMethod method){\n            //note: no call to super;\n            final String methodName = method.getName();\n            if(!\"finalize\".equals(methodName)){\n                return;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if(containingClass == null){\n                return;\n            }\n            if(m_ignoreForObjectSubclasses){\n                final PsiClass superClass = containingClass.getSuperClass();\n                if(superClass != null){\n                    final String superClassName = superClass.getQualifiedName();\n                    if(\"java.lang.Object\".equals(superClassName)){\n                        return;\n                    }\n                }\n            }\n            final PsiParameterList parameterList = method.getParameterList();\n            if(parameterList.getParameters().length != 0){\n                return;\n            }\n            final CallToSuperFinalizeVisitor visitor = new CallToSuperFinalizeVisitor();\n            method.accept(visitor);\n            if(visitor.isCallToSuperFinalizeFound()){\n                return;\n            }\n            registerMethodError(method);\n        }","id":89106,"modified_method":"public void visitMethod(@NotNull PsiMethod method){\n            //note: no call to super;\n            final String methodName = method.getName();\n            if(!\"finalize\".equals(methodName)){\n                return;\n            }\n            if(method.hasModifierProperty(PsiModifier.NATIVE) ||\n                    method.hasModifierProperty(PsiModifier.ABSTRACT))\n            {\n                return;\n            }\n            final PsiClass containingClass = method.getContainingClass();\n            if(containingClass == null){\n                return;\n            }\n            if(m_ignoreForObjectSubclasses){\n                final PsiClass superClass = containingClass.getSuperClass();\n                if(superClass != null){\n                    final String superClassName = superClass.getQualifiedName();\n                    if(\"java.lang.Object\".equals(superClassName)){\n                        return;\n                    }\n                }\n            }\n            final PsiParameterList parameterList = method.getParameterList();\n            if(parameterList.getParameters().length != 0){\n                return;\n            }\n            final CallToSuperFinalizeVisitor visitor = new CallToSuperFinalizeVisitor();\n            method.accept(visitor);\n            if(visitor.isCallToSuperFinalizeFound()){\n                return;\n            }\n            registerMethodError(method);\n        }","commit_id":"1d59b95aad9c712d65d003bb9d0834893ad8a7b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private URL getURL() {\n        if (url == null) {\n            try {\n                url = new URL(BundleResourceURLStreamHandler.PROTOCOL, null,\n                    -1, path, new BundleResourceURLStreamHandler(bundle,\n                        mappedPath.getEntryPath(path)));\n            } catch (MalformedURLException mue) {\n                log.error(\"getURL: Cannot get URL for \" + this, mue);\n            }\n        }\n\n        return url;\n    }","id":89107,"modified_method":"private URL getURL() {\n        if (url == null) {\n            try {\n                url = new URL(BundleResourceURLStreamHandler.PROTOCOL, null,\n                    -1, path, new BundleResourceURLStreamHandler(\n                        bundle.getBundle(), mappedPath.getEntryPath(path)));\n            } catch (MalformedURLException mue) {\n                log.error(\"getURL: Cannot get URL for \" + this, mue);\n            }\n        }\n\n        return url;\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"Bundle getBundle() {\n        return bundle;\n    }","id":89108,"modified_method":"BundleResourceCache getBundle() {\n        return bundle;\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"public BundleResource(ResourceResolver resourceResolver, Bundle bundle,\n            MappedPath mappedPath, String resourcePath) {\n\n        this.resourceResolver = resourceResolver;\n        this.bundle = bundle;\n        this.mappedPath = mappedPath;\n\n        metadata = new ResourceMetadata();\n        metadata.setResolutionPath(resourcePath);\n        metadata.setCreationTime(bundle.getLastModified());\n        metadata.setModificationTime(bundle.getLastModified());\n\n        if (resourcePath.endsWith(\"/\")) {\n\n            this.path = resourcePath.substring(0, resourcePath.length() - 1);\n            this.resourceType = NT_FOLDER;\n\n        } else {\n\n            this.path = resourcePath;\n            this.resourceType = NT_FILE;\n\n            try {\n                URL url = bundle.getEntry(mappedPath.getEntryPath(resourcePath));\n                metadata.setContentLength(url.openConnection().getContentLength());\n            } catch (Exception e) {\n                // don't care, we just have no content length\n            }\n        }\n    }","id":89109,"modified_method":"public BundleResource(ResourceResolver resourceResolver,\n            BundleResourceCache bundle, MappedPath mappedPath,\n            String resourcePath) {\n\n        this.resourceResolver = resourceResolver;\n        this.bundle = bundle;\n        this.mappedPath = mappedPath;\n\n        metadata = new ResourceMetadata();\n        metadata.setResolutionPath(resourcePath);\n        metadata.setCreationTime(bundle.getBundle().getLastModified());\n        metadata.setModificationTime(bundle.getBundle().getLastModified());\n\n        if (resourcePath.endsWith(\"/\")) {\n\n            this.path = resourcePath.substring(0, resourcePath.length() - 1);\n            this.resourceType = NT_FOLDER;\n\n        } else {\n\n            this.path = resourcePath;\n            this.resourceType = NT_FILE;\n\n            try {\n                URL url = bundle.getEntry(mappedPath.getEntryPath(resourcePath));\n                metadata.setContentLength(url.openConnection().getContentLength());\n            } catch (Exception e) {\n                // don't care, we just have no content length\n            }\n        }\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"public static BundleResource getResource(ResourceResolver resourceResolver,\n            Bundle bundle, MappedPath mappedPath, String resourcePath) {\n\n        String entryPath = mappedPath.getEntryPath(resourcePath);\n\n        // first try, whether the bundle has an entry with a trailing slash\n        // which would be a folder. In this case we check whether the\n        // repository contains an item with the same path. If so, we\n        // don't create a BundleResource but instead return null to be\n        // able to return an item-based resource\n        URL entry = bundle.getEntry(entryPath.concat(\"/\"));\n        if (entry != null) {\n            Session session = resourceResolver.adaptTo(Session.class);\n            if (session != null) {\n                try {\n                    if (session.itemExists(resourcePath)) {\n                        return null;\n                    }\n                } catch (RepositoryException re) {\n                    // don't care\n                }\n            }\n\n            // append the slash to path for next steps\n            resourcePath = resourcePath.concat(\"/\");\n        }\n\n        // if there is no entry with a trailing slash, try plain name\n        // which would then of course be a file\n        if (entry == null) {\n            entry = bundle.getEntry(entryPath);\n        }\n\n        // here we either have a folder for which no same-named item exists\n        // or a bundle file\n        if (entry != null) {\n            return new BundleResource(resourceResolver, bundle, mappedPath,\n                resourcePath);\n        }\n\n        // the bundle does not contain the path\n        return null;\n    }","id":89110,"modified_method":"public static BundleResource getResource(ResourceResolver resourceResolver,\n            BundleResourceCache bundle, MappedPath mappedPath,\n            String resourcePath) {\n\n        String entryPath = mappedPath.getEntryPath(resourcePath);\n\n        // first try, whether the bundle has an entry with a trailing slash\n        // which would be a folder. In this case we check whether the\n        // repository contains an item with the same path. If so, we\n        // don't create a BundleResource but instead return null to be\n        // able to return an item-based resource\n        URL entry = bundle.getEntry(entryPath.concat(\"/\"));\n        if (entry != null) {\n            Session session = resourceResolver.adaptTo(Session.class);\n            if (session != null) {\n                try {\n                    if (session.itemExists(resourcePath)) {\n                        return null;\n                    }\n                } catch (RepositoryException re) {\n                    // don't care\n                }\n            }\n\n            // append the slash to path for next steps\n            resourcePath = resourcePath.concat(\"/\");\n        }\n\n        // if there is no entry with a trailing slash, try plain name\n        // which would then of course be a file\n        if (entry == null) {\n            entry = bundle.getEntry(entryPath);\n        }\n\n        // here we either have a folder for which no same-named item exists\n        // or a bundle file\n        if (entry != null) {\n            return new BundleResource(resourceResolver, bundle, mappedPath,\n                resourcePath);\n        }\n\n        // the bundle does not contain the path\n        return null;\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    BundleResourceIterator(ResourceResolver resourceResolver, Bundle bundle,\n            MappedPath mappedPath, String parentPath) {\n        \n        // trailing slash to enumerate children\n        if (!parentPath.endsWith(\"/\")) {\n            parentPath = parentPath.concat(\"/\");\n        }\n\n        this.resourceResolver = resourceResolver;\n        this.bundle = bundle;\n        this.mappedPath = mappedPath;\n        \n        // unchecked cast\n        this.entries = bundle.getEntryPaths(parentPath);\n        this.prefixLength = parentPath.length();\n\n        this.nextResult = (entries != null) ? seek() : null;\n    }","id":89111,"modified_method":"BundleResourceIterator(ResourceResolver resourceResolver, BundleResourceCache bundle,\n            MappedPath mappedPath, String parentPath) {\n        \n        // trailing slash to enumerate children\n        if (!parentPath.endsWith(\"/\")) {\n            parentPath = parentPath.concat(\"/\");\n        }\n\n        this.resourceResolver = resourceResolver;\n        this.bundle = bundle;\n        this.mappedPath = mappedPath;\n        this.entries = bundle.getEntryPaths(parentPath);\n        this.prefixLength = parentPath.length();\n\n        this.nextResult = (entries != null) ? seek() : null;\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Creates an instance using the given parent bundle resource.\n     */\n    @SuppressWarnings(\"unchecked\")\n    BundleResourceIterator(BundleResource parent) {\n\n        if (parent.isFile()) {\n\n            // if the parent is a file, the iterator is empty\n            this.resourceResolver = null;\n            this.bundle = null;\n            this.entries = null;\n            this.prefixLength = 0;\n            this.mappedPath = null;\n            this.nextResult = null;\n\n        } else {\n            // trailing slash to enumerate children\n            String parentPath = parent.getPath().concat(\"/\");\n\n            this.resourceResolver = parent.getResourceResolver();\n            this.bundle = parent.getBundle();\n            this.mappedPath = parent.getMappedPath();\n            \n            // unchecked cast\n            this.entries = parent.getBundle().getEntryPaths(parentPath);\n            this.prefixLength = parentPath.length();\n            \n            this.nextResult = seek();\n        }\n    }","id":89112,"modified_method":"/**\n     * Creates an instance using the given parent bundle resource.\n     */\n    BundleResourceIterator(BundleResource parent) {\n\n        if (parent.isFile()) {\n\n            // if the parent is a file, the iterator is empty\n            this.resourceResolver = null;\n            this.bundle = null;\n            this.entries = null;\n            this.prefixLength = 0;\n            this.mappedPath = null;\n            this.nextResult = null;\n\n        } else {\n            // trailing slash to enumerate children\n            String parentPath = parent.getPath().concat(\"/\");\n\n            this.resourceResolver = parent.getResourceResolver();\n            this.bundle = parent.getBundle();\n            this.mappedPath = parent.getMappedPath();\n            this.entries = parent.getBundle().getEntryPaths(parentPath);\n            this.prefixLength = parentPath.length();\n\n            this.nextResult = (entries != null) ? seek() : null;\n        }\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Scans the entry path enumeration looking for the next entry being a\n     * direct child of the parent resource.\n     */\n    private Resource seek() {\n        while (entries.hasMoreElements()) {\n            String entry = entries.nextElement();\n\n            // require leading slash\n            if (!entry.startsWith(\"/\")) {\n                entry = \"/\" + entry;\n            }\n\n            int slash = entry.indexOf('/', prefixLength);\n            if (slash < 0 || slash == entry.length() - 1) {\n                log.debug(\"seek: Using entry {}\", entry);\n                return new BundleResource(resourceResolver, bundle, mappedPath,\n                    entry);\n            }\n\n            log.debug(\"seek: Ignoring entry {}\", entry);\n        }\n\n        // no more results\n        log.debug(\"seek: No more nodes, iterator exhausted\");\n        return null;\n    }","id":89113,"modified_method":"/**\n     * Scans the entry path enumeration looking for the next entry being a\n     * direct child of the parent resource.\n     */\n    private Resource seek() {\n        while (entries.hasNext()) {\n            String entry = entries.next();\n\n            // require leading slash\n            if (!entry.startsWith(\"/\")) {\n                entry = \"/\" + entry;\n            }\n\n            int slash = entry.indexOf('/', prefixLength);\n            if (slash < 0 || slash == entry.length() - 1) {\n                log.debug(\"seek: Using entry {}\", entry);\n                return new BundleResource(resourceResolver, bundle, mappedPath,\n                    entry);\n            }\n\n            log.debug(\"seek: Ignoring entry {}\", entry);\n        }\n\n        // no more results\n        log.debug(\"seek: No more nodes, iterator exhausted\");\n        return null;\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Creates Bundle resource provider accessing entries in the given Bundle an\n     * supporting resources below root paths given by the rootList which is a\n     * comma (and whitespace) separated list of absolute paths.\n     */\n    public BundleResourceProvider(Bundle bundle, String rootList) {\n        this.bundle = bundle;\n\n        StringTokenizer pt = new StringTokenizer(rootList, \", \\t\\n\\r\\f\");\n        List<MappedPath> prefixList = new ArrayList<MappedPath>();\n        while (pt.hasMoreTokens()) {\n            String resourceRoot = pt.nextToken();\n            if (resourceRoot.length() > 0) {\n                prefixList.add(MappedPath.create(resourceRoot));\n            }\n        }\n        this.roots = prefixList.toArray(new MappedPath[prefixList.size()]);\n    }","id":89114,"modified_method":"/**\n     * Creates Bundle resource provider accessing entries in the given Bundle an\n     * supporting resources below root paths given by the rootList which is a\n     * comma (and whitespace) separated list of absolute paths.\n     */\n    public BundleResourceProvider(Bundle bundle, String rootList) {\n        this.bundle = new BundleResourceCache(bundle);\n\n        StringTokenizer pt = new StringTokenizer(rootList, \", \\t\\n\\r\\f\");\n        List<MappedPath> prefixList = new ArrayList<MappedPath>();\n        while (pt.hasMoreTokens()) {\n            String resourceRoot = pt.nextToken();\n            if (resourceRoot.length() > 0) {\n                prefixList.add(MappedPath.create(resourceRoot));\n            }\n        }\n        this.roots = prefixList.toArray(new MappedPath[prefixList.size()]);\n    }","commit_id":"e255dcb96c9655e2ad98fe592de884d7619ef88d","url":"https://github.com/apache/sling"},{"original_method":"/**\n   * @return the current block id based on mPos, -1 if at the end of the file\n   */\n  private long getCurrentBlockId() {\n    if (!validPosition(mPos)) {\n      return -1;\n    }\n    int index = (int) (mPos / mBlockSize);\n    Preconditions\n        .checkState(index < mStatus.getBlockIds().size(), PreconditionMessage.ERR_BLOCK_INDEX);\n    return mStatus.getBlockIds().get(index);\n  }","id":89115,"modified_method":"/**\n   * @return the current block id based on mPos, -1 if at the end of the file\n   */\n  private long getCurrentBlockId() {\n    if (remaining() <= 0) {\n      return -1;\n    }\n    int index = (int) (mPos / mBlockSize);\n    Preconditions\n        .checkState(index < mStatus.getBlockIds().size(), PreconditionMessage.ERR_BLOCK_INDEX);\n    return mStatus.getBlockIds().get(index);\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int read() throws IOException {\n    if (!validPosition(mPos)) {\n      return -1;\n    }\n    updateStreams();\n    Preconditions.checkState(mCurrentBlockInStream != null, \"Reached EOF unexpectedly.\");\n\n    int data = mCurrentBlockInStream.read();\n\n    // This should not happen?\n    if (data == -1) {\n      // The underlying stream is done.\n      return -1;\n    }\n\n    mPos++;\n    if (mCurrentCacheStream != null) {\n      try {\n        mCurrentCacheStream.write(data);\n      } catch (IOException e) {\n        handleCacheStreamIOException(e);\n      }\n    }\n    return data;\n  }","id":89116,"modified_method":"@Override\n  public int read() throws IOException {\n    if (remaining() <= 0) {\n      return -1;\n    }\n    updateStreams();\n    Preconditions.checkState(mCurrentBlockInStream != null, \"Reached EOF unexpectedly.\");\n\n    int data = mCurrentBlockInStream.read();\n\n    // This should not happen?\n    if (data == -1) {\n      // The underlying stream is done.\n      return -1;\n    }\n\n    mPos++;\n    if (mCurrentCacheStream != null) {\n      try {\n        mCurrentCacheStream.write(data);\n      } catch (IOException e) {\n        handleCacheStreamIOException(e);\n      }\n    }\n    return data;\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public long skip(long n) throws IOException {\n    if (n <= 0) {\n      return 0;\n    }\n\n    long toSkip = Math.min(n, remaining());\n    closeOrCancelCacheStream();\n    mPos = mPos + toSkip;\n    updateStreams();\n    mCurrentBlockInStream.seek(mPos % mBlockSize);\n    return toSkip;\n  }","id":89117,"modified_method":"@Override\n  public long skip(long n) throws IOException {\n    if (n <= 0) {\n      return 0;\n    }\n\n    long toSkip = Math.min(n, remaining());\n    seekInternal(mPos + toSkip);\n    return toSkip;\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Seeks to a file position. Blocks are cached even if they are not fully read. This is only\n   * called by {@link FileInStream#seek}.\n   * Invariant: if the current block is to be cached, [0, mPos) should have been cached already.\n   *\n   * @param pos The position to seek to. It is guaranteed to be valid (pos >= 0 && pos != mPos &&\n   *            pos <= mFileLength).\n   * @throws IOException if the seek fails due to an error accessing the stream at the position\n   */\n  private void seekInternalWithCachingPartiallyReadBlock(long pos) throws IOException {\n    // Precompute this because mPos will be updated several times in this function.\n    boolean isInCurrentBlock = pos / mBlockSize == mPos / mBlockSize;\n\n    // Make sure that mCurrentBlockInStream and mCurrentCacheStream is updated.\n    // mPos is not updated here.\n    updateStreams();\n\n    if (mCurrentCacheStream != null) {\n      // Cache till pos if seeking forward within the current block. Otheriwse cache the whole\n      // block.\n      readCurrentBlockToPos(pos > mPos ? pos : mFileLength);\n\n      // Early return if we are at pos already. This happens if we seek forward with caching\n      // enabled for this block.\n      if (mPos == pos) {\n        return;\n      }\n      // The early return above guarantees that we won't close an incomplete cache stream.\n      Preconditions.checkState(mCurrentCacheStream == null || mCurrentCacheStream.remaining() == 0);\n      closeOrCancelCacheStream();\n    }\n\n    // If seeks within the current block, directly seeks to pos if we are not yet there.\n    // If seeks outside the current block, seek to the beginning of that block first, then\n    // cache the prefix (pos % mBlockSize) of that block.\n    if (isInCurrentBlock) {\n      mPos = pos;\n      // updateStreams is necessary when pos = mFileLength.\n      updateStreams();\n      mCurrentBlockInStream.seek(mPos % mBlockSize);\n    } else {\n      mPos = pos / mBlockSize * mBlockSize;\n      updateStreams();\n      if (mCurrentCacheStream != null) {\n        readCurrentBlockToPos(pos);\n      } else {\n        mPos = pos;\n        // We are not allowed to seek to EOF, which guarantees mCurrentBlockInStream to be not null.\n        Preconditions.checkNotNull(mCurrentBlockInStream);\n        mCurrentBlockInStream.seek(mPos % mBlockSize);\n      }\n    }\n  }","id":89118,"modified_method":"/**\n   * Seeks to a file position. Blocks are cached even if they are not fully read. This is only\n   * called by {@link FileInStream#seek}.\n   * Invariant: if the current block is to be cached, [0, mPos) should have been cached already.\n   *\n   * @param pos The position to seek to. It is guaranteed to be valid (pos >= 0 && pos != mPos &&\n   *            pos <= mFileLength).\n   * @throws IOException if the seek fails due to an error accessing the stream at the position\n   */\n  private void seekInternalWithCachingPartiallyReadBlock(long pos) throws IOException {\n    // Precompute this because mPos will be updated several times in this function.\n    boolean isInCurrentBlock = pos / mBlockSize == mPos / mBlockSize;\n\n    // Make sure that mCurrentBlockInStream and mCurrentCacheStream is updated.\n    // mPos is not updated here.\n    updateStreams();\n\n    if (mCurrentCacheStream != null) {\n      // Cache till pos if seeking forward within the current block. Otheriwse cache the whole\n      // block.\n      readCurrentBlockToPos(pos > mPos ? pos : Long.MAX_VALUE);\n\n      // Early return if we are at pos already. This happens if we seek forward with caching\n      // enabled for this block.\n      if (mPos == pos) {\n        return;\n      }\n      // The early return above guarantees that we won't close an incomplete cache stream.\n      Preconditions.checkState(mCurrentCacheStream == null || mCurrentCacheStream.remaining() == 0);\n      closeOrCancelCacheStream();\n    }\n\n    // If seeks within the current block, directly seeks to pos if we are not yet there.\n    // If seeks outside the current block, seek to the beginning of that block first, then\n    // cache the prefix (pos % mBlockSize) of that block.\n    if (isInCurrentBlock) {\n      mPos = pos;\n      // updateStreams is necessary when pos = mFileLength.\n      updateStreams();\n      if (mCurrentBlockInStream != null) {\n        mCurrentBlockInStream.seek(mPos % mBlockSize);\n      } else {\n        Preconditions.checkState(remaining() == 0);\n      }\n    } else {\n      mPos = pos / mBlockSize * mBlockSize;\n      updateStreams();\n      if (mCurrentCacheStream != null) {\n        readCurrentBlockToPos(pos);\n      } else if (mCurrentBlockInStream != null){\n        mPos = pos;\n        mCurrentBlockInStream.seek(mPos % mBlockSize);\n      } else {\n        Preconditions.checkState(remaining() == 0);\n      }\n    }\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void close() throws IOException {\n    if (mClosed) {\n      return;\n    }\n    updateStreams();\n    if (mCurrentCacheStream != null && mShouldCachePartiallyReadBlock) {\n      readCurrentBlockToPos(mFileLength);\n    }\n    if (mCurrentBlockInStream != null) {\n      mCurrentBlockInStream.close();\n    }\n    closeOrCancelCacheStream();\n    mClosed = true;\n  }","id":89119,"modified_method":"@Override\n  public void close() throws IOException {\n    if (mClosed) {\n      return;\n    }\n    updateStreams();\n    if (mCurrentCacheStream != null && mShouldCachePartiallyReadBlock) {\n      readCurrentBlockToPos(Long.MAX_VALUE);\n    }\n    if (mCurrentBlockInStream != null) {\n      mCurrentBlockInStream.close();\n    }\n    closeOrCancelCacheStream();\n    mClosed = true;\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Seeks to a file position. Blocks are not cached unless they are fully read. This is only called\n   * by {@link FileInStream#seek}.\n   *\n   * @param pos The position to seek to. It is guaranteed to be valid (pos >= 0 && pos != mPos &&\n   *            pos <= mFileLength)\n   * @throws IOException if the seek fails due to an error accessing the stream at the position\n   */\n  private void seekInternal(long pos) throws IOException {\n    closeOrCancelCacheStream();\n    mPos = pos;\n    updateStreams();\n    mCurrentBlockInStream.seek(mPos % mBlockSize);\n  }","id":89120,"modified_method":"/**\n   * Seeks to a file position. Blocks are not cached unless they are fully read. This is only called\n   * by {@link FileInStream#seek}.\n   *\n   * @param pos The position to seek to. It is guaranteed to be valid (pos >= 0 && pos != mPos &&\n   *            pos <= mFileLength)\n   * @throws IOException if the seek fails due to an error accessing the stream at the position\n   */\n  private void seekInternal(long pos) throws IOException {\n    closeOrCancelCacheStream();\n    mPos = pos;\n    updateStreams();\n    if (mCurrentBlockInStream != null) {\n      mCurrentBlockInStream.seek(mPos % mBlockSize);\n    } else {\n      Preconditions.checkState(remaining() == 0);\n    }\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void seek(long pos) throws IOException {\n    if (mPos == pos) {\n      return;\n    }\n    Preconditions.checkArgument(pos >= 0, PreconditionMessage.ERR_SEEK_NEGATIVE, pos);\n    // Why cannot I seek to the end of a file?\n    Preconditions.checkArgument(validPosition(pos), PreconditionMessage.ERR_SEEK_PAST_END_OF_FILE,\n        pos);\n    if (!mShouldCachePartiallyReadBlock) {\n      seekInternal(pos);\n    } else {\n      seekInternalWithCachingPartiallyReadBlock(pos);\n    }\n  }","id":89121,"modified_method":"@Override\n  public void seek(long pos) throws IOException {\n    if (mPos == pos) {\n      return;\n    }\n    Preconditions.checkArgument(pos >= 0, PreconditionMessage.ERR_SEEK_NEGATIVE, pos);\n    Preconditions\n        .checkArgument(pos <= maxSeekPosition(), PreconditionMessage.ERR_SEEK_PAST_END_OF_FILE, pos);\n    if (!mShouldCachePartiallyReadBlock) {\n      seekInternal(pos);\n    } else {\n      seekInternalWithCachingPartiallyReadBlock(pos);\n    }\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    Preconditions.checkArgument(b != null, PreconditionMessage.ERR_READ_BUFFER_NULL);\n    Preconditions.checkArgument(off >= 0 && len >= 0 && len + off <= b.length,\n        PreconditionMessage.ERR_BUFFER_STATE, b.length, off, len);\n    if (len == 0) {\n      return 0;\n    } else if (!validPosition(mPos)) {\n      return -1;\n    }\n\n    int currentOffset = off;\n    int bytesLeftToRead = len;\n\n    while (bytesLeftToRead > 0 && validPosition(mPos)) {\n      updateStreams();\n      if (mCurrentBlockInStream == null) {\n        // EOF is reached.\n        break;\n      }\n      int bytesToRead = (int) Math.min(bytesLeftToRead, mCurrentBlockInStream.remaining());\n      Preconditions.checkState(bytesToRead > 0);\n\n      int bytesRead = mCurrentBlockInStream.read(b, currentOffset, bytesToRead);\n      if (bytesRead > 0) {\n        if (mCurrentCacheStream != null) {\n          try {\n            mCurrentCacheStream.write(b, currentOffset, bytesRead);\n          } catch (IOException e) {\n            handleCacheStreamIOException(e);\n          }\n        }\n        mPos += bytesRead;\n        bytesLeftToRead -= bytesRead;\n        currentOffset += bytesRead;\n      }\n    }\n\n    if (bytesLeftToRead == len && mCurrentBlockInStream.remaining() == 0) {\n      // Nothing was read, and the underlying stream is done.\n      return -1;\n    }\n\n    return len - bytesLeftToRead;\n  }","id":89122,"modified_method":"@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    Preconditions.checkArgument(b != null, PreconditionMessage.ERR_READ_BUFFER_NULL);\n    Preconditions.checkArgument(off >= 0 && len >= 0 && len + off <= b.length,\n        PreconditionMessage.ERR_BUFFER_STATE, b.length, off, len);\n    if (len == 0) {\n      return 0;\n    } else if (remaining() <= 0) {\n      return -1;\n    }\n\n    int currentOffset = off;\n    int bytesLeftToRead = len;\n\n    while (bytesLeftToRead > 0 && remaining() > 0) {\n      updateStreams();\n      if (mCurrentBlockInStream == null) {\n        // EOF is reached.\n        break;\n      }\n      int bytesToRead = (int) Math.min(bytesLeftToRead, mCurrentBlockInStream.remaining());\n      Preconditions.checkState(bytesToRead > 0);\n\n      int bytesRead = mCurrentBlockInStream.read(b, currentOffset, bytesToRead);\n      if (bytesRead > 0) {\n        if (mCurrentCacheStream != null) {\n          try {\n            mCurrentCacheStream.write(b, currentOffset, bytesRead);\n          } catch (IOException e) {\n            handleCacheStreamIOException(e);\n          }\n        }\n        mPos += bytesRead;\n        bytesLeftToRead -= bytesRead;\n        currentOffset += bytesRead;\n      }\n    }\n\n    if (bytesLeftToRead == len && mCurrentBlockInStream.remaining() == 0) {\n      // Nothing was read, and the underlying stream is done.\n      return -1;\n    }\n\n    return len - bytesLeftToRead;\n  }","commit_id":"9aca81e3712ff41f6945208ae08c50dc6d96efa6","url":"https://github.com/amplab/tachyon"},{"original_method":"protected void stream() throws IOException\n    {\n        assert header.file.compressionInfo != null;\n\n        SocketChannel sc = socket.getChannel();\n        byte[] transferBuffer = null;\n\n        // write header\n        ByteBuffer headerBuffer = MessagingService.instance().constructStreamHeader(header, false, MessagingService.instance().getVersion(to));\n        socket.getOutputStream().write(ByteBufferUtil.getArray(headerBuffer));\n\n        RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()), true);\n        FileChannel fc = file.getChannel();\n\n        StreamingMetrics.activeStreamsOutbound.inc();\n        // calculate chunks to transfer. we want to send continuous chunks altogether.\n        List<Pair<Long, Long>> sections = getTransferSections(header.file.compressionInfo.chunks);\n        try\n        {\n            long totalBytesTransferred = 0;\n            // stream each of the required sections of the file\n            for (Pair<Long, Long> section : sections)\n            {\n                // length of the section to stream\n                long length = section.right - section.left;\n                // tracks write progress\n                long bytesTransferred = 0;\n                while (bytesTransferred < length)\n                {\n                    int toTransfer = (int) Math.min(CHUNK_SIZE, length - bytesTransferred);\n                    long lastWrite;\n                    if (sc != null)\n                    {\n                        lastWrite = fc.transferTo(section.left + bytesTransferred, toTransfer, sc);\n                        throttle.throttleDelta(lastWrite);\n                    }\n                    else\n                    {\n                        file.seek(section.left);\n                        // NIO is not available. Fall back to normal streaming.\n                        // This happens when inter-node encryption is turned on.\n                        if (transferBuffer == null)\n                            transferBuffer = new byte[CHUNK_SIZE];\n                        file.readFully(transferBuffer, 0, toTransfer);\n                        socket.getOutputStream().write(transferBuffer, 0, toTransfer);\n                        throttle.throttleDelta(toTransfer);\n                        lastWrite = toTransfer;\n                    }\n                    totalBytesTransferred += lastWrite;\n                    bytesTransferred += lastWrite;\n                    header.file.progress += lastWrite;\n                }\n\n                if (sc == null)\n                    socket.getOutputStream().flush();\n\n                logger.debug(\"Bytes transferred \" + bytesTransferred + \"/\" + header.file.size);\n            }\n            StreamingMetrics.totalOutgoingBytes.inc(totalBytesTransferred);\n            metrics.outgoingBytes.inc(totalBytesTransferred);\n            // receive reply confirmation\n            receiveReply();\n        }\n        finally\n        {\n            StreamingMetrics.activeStreamsOutbound.dec();\n\n            // no matter what happens close file\n            FileUtils.closeQuietly(file);\n        }\n    }","id":89123,"modified_method":"protected void stream() throws IOException\n    {\n        assert header.file.compressionInfo != null;\n\n        SocketChannel sc = socket.getChannel();\n        byte[] transferBuffer = null;\n\n        // write header\n        ByteBuffer headerBuffer = MessagingService.instance().constructStreamHeader(header, false, MessagingService.instance().getVersion(to));\n        socket.getOutputStream().write(ByteBufferUtil.getArray(headerBuffer));\n\n        RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()), true);\n        FileChannel fc = file.getChannel();\n\n        StreamingMetrics.activeStreamsOutbound.inc();\n        // calculate chunks to transfer. we want to send continuous chunks altogether.\n        List<Pair<Long, Long>> sections = getTransferSections(header.file.compressionInfo.chunks);\n        try\n        {\n            long totalBytesTransferred = 0;\n            // stream each of the required sections of the file\n            for (Pair<Long, Long> section : sections)\n            {\n                // seek to the beginning of the section when socket channel is not available\n                if (sc == null)\n                    file.seek(section.left);\n                // length of the section to stream\n                long length = section.right - section.left;\n                // tracks write progress\n                long bytesTransferred = 0;\n                while (bytesTransferred < length)\n                {\n                    int toTransfer = (int) Math.min(CHUNK_SIZE, length - bytesTransferred);\n                    long lastWrite;\n                    if (sc != null)\n                    {\n                        lastWrite = fc.transferTo(section.left + bytesTransferred, toTransfer, sc);\n                        throttle.throttleDelta(lastWrite);\n                    }\n                    else\n                    {\n                        // NIO is not available. Fall back to normal streaming.\n                        // This happens when inter-node encryption is turned on.\n                        if (transferBuffer == null)\n                            transferBuffer = new byte[CHUNK_SIZE];\n                        file.readFully(transferBuffer, 0, toTransfer);\n                        socket.getOutputStream().write(transferBuffer, 0, toTransfer);\n                        throttle.throttleDelta(toTransfer);\n                        lastWrite = toTransfer;\n                    }\n                    totalBytesTransferred += lastWrite;\n                    bytesTransferred += lastWrite;\n                    header.file.progress += lastWrite;\n                }\n\n                if (sc == null)\n                    socket.getOutputStream().flush();\n\n                logger.debug(\"Bytes transferred \" + bytesTransferred + \"/\" + header.file.size);\n            }\n            StreamingMetrics.totalOutgoingBytes.inc(totalBytesTransferred);\n            metrics.outgoingBytes.inc(totalBytesTransferred);\n            // receive reply confirmation\n            receiveReply();\n        }\n        finally\n        {\n            StreamingMetrics.activeStreamsOutbound.dec();\n\n            // no matter what happens close file\n            FileUtils.closeQuietly(file);\n        }\n    }","commit_id":"128177c41248734e76499ef382152fd3c40378bd","url":"https://github.com/apache/cassandra"},{"original_method":"private ArrayList<TestCase> makeTestCasesList() {\n    String[] algorithms = filterForAlgos(testCasesFilterString);\n    String[] testCases = filterForTestCases(testCasesFilterString);\n    List<String> testCaseEntries = null;\n\n    try {\n      summaryLog.println(\"Reading test cases from: \" + testCasesCSVPath);\n      File testCasesFile = AccuracyTestingUtil.find_test_file_static(this.testCasesCSVPath);\n      testCaseEntries = Files.readAllLines(testCasesFile.toPath(), Charset.defaultCharset());\n    }\n    catch (Exception e) {\n      summaryLog.println(\"Cannot read the test cases from: \" + testCasesCSVPath);\n      writeStackTrace(e,summaryLog);\n      System.exit(-1);\n    }\n\n    testCaseEntries.remove(0); // remove header line\n    ArrayList<TestCase> testCaseArray = new ArrayList<>();\n    String[] testCaseEntry;\n    for (String t : testCaseEntries) {\n      testCaseEntry = t.trim().split(\",\", -1);\n\n      // If algorithms are specified in the testCaseFilterString, load all test cases for these algorithms. Otherwise,\n      // if specific test cases are specified, then only load those. Else, load all the test cases.\n      if (null != algorithms) {\n        if (!Arrays.asList(algorithms).contains(testCaseEntry[1])) { continue; }\n      }\n      else if (null != testCases) {\n        if (!Arrays.asList(testCases).contains(testCaseEntry[0])) { continue; }\n      }\n      summaryLog.println(\"Creating test case: \" + t);\n      try {\n        testCaseArray.add(\n                          new TestCase(Integer.parseInt(testCaseEntry[0]), testCaseEntry[1], testCaseEntry[2],\n                                       testCaseEntry[3].equals(\"1\"), testCaseEntry[4].equals(\"1\"), Integer.parseInt(testCaseEntry[5]),\n                                       Integer.parseInt(testCaseEntry[6]), testCaseEntry[7])\n                          );\n      } catch (Exception e) {\n        summaryLog.println(\"Couldn't create test case: \" + t);\n        writeStackTrace(e, summaryLog);\n        System.exit(-1);\n      }\n    }\n    return testCaseArray;\n  }","id":89124,"modified_method":"private ArrayList<TestCase> makeTestCasesList() {\n    String[] algorithms = filterForAlgos(testCasesFilterString);\n    String[] testCases = filterForTestCases(testCasesFilterString);\n    List<String> testCaseEntries = null;\n\n    try {\n      summaryLog.println(\"Reading test cases from: \" + testCasesCSVPath);\n      File testCasesFile = AccuracyTestingUtil.find_test_file_static(this.testCasesCSVPath);\n      testCaseEntries = Files.readAllLines(testCasesFile.toPath(), Charset.defaultCharset());\n    }\n    catch (Exception e) {\n      summaryLog.println(\"Cannot read the test cases from: \" + testCasesCSVPath);\n      writeStackTrace(e,summaryLog);\n      System.exit(-1);\n    }\n\n    testCaseEntries.remove(0); // remove header line\n    ArrayList<TestCase> testCaseArray = new ArrayList<>();\n    String[] testCaseEntry;\n    for (String t : testCaseEntries) {\n      testCaseEntry = t.trim().split(\",\", -1);\n\n      // If algorithms are specified in the testCaseFilterString, load all test cases for these algorithms. Otherwise,\n      // if specific test cases are specified, then only load those. Else, load all the test cases.\n      if (null != algorithms) {\n        if (!Arrays.asList(algorithms).contains(testCaseEntry[1])) { continue; }\n      }\n      else if (null != testCases) {\n        if (!Arrays.asList(testCases).contains(testCaseEntry[0])) { continue; }\n      }\n      summaryLog.println(\"Creating test case: \" + t);\n      try {\n        testCaseArray.add(\n                          new TestCase(Integer.parseInt(testCaseEntry[0]), testCaseEntry[1], testCaseEntry[2],\n                                  testCaseEntry[3].equals(\"1\"), testCaseEntry[4], testCaseEntry[5],\n                                  testCaseEntry[6].equals(\"1\"), Integer.parseInt(testCaseEntry[7]),\n                                  Integer.parseInt(testCaseEntry[8]), testCaseEntry[9])\n                          );\n      } catch (Exception e) {\n        summaryLog.println(\"Couldn't create test case: \" + t);\n        writeStackTrace(e, summaryLog);\n        System.exit(-1);\n      }\n    }\n    return testCaseArray;\n  }","commit_id":"a6a53648add5636fa2fdcb1d57f7ab9624abaed7","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public TestCaseResult execute() throws Exception, AssertionError {\n    loadTestCaseDataSets();\n\n    makeModelParameters();\n\n    Model.Output modelOutput = null;\n\n    DRF drfJob = null;\n    DRFModel drfModel = null;\n    GLM glmJob = null;\n    GLMModel glmModel = null;\n    GBM gbmJob = null;\n    GBMModel gbmModel = null;\n    DeepLearning dlJob = null;\n    DeepLearningModel dlModel = null;\n\n    double modelStartTime = 0, modelStopTime = 0;\n\n    try {\n      Scope.enter();\n      switch (algo) {\n        case \"drf\":\n          drfJob = new DRF((DRFModel.DRFParameters) params);\n          AccuracyTestingSuite.summaryLog.println(\"Training DRF model.\");\n          modelStartTime = System.currentTimeMillis();\n          drfModel = drfJob.trainModel().get();\n          modelStopTime = System.currentTimeMillis();\n          modelOutput = drfModel._output;\n          break;\n        case \"glm\":\n          glmJob = new GLM((GLMModel.GLMParameters) params,Key.<GLMModel>make(\"GLMModel\"));\n          AccuracyTestingSuite.summaryLog.println(\"Training GLM model.\");\n          modelStartTime = System.currentTimeMillis();\n          glmModel = glmJob.trainModel().get();\n          modelStopTime = System.currentTimeMillis();\n          modelOutput = glmModel._output;\n          break;\n        case \"gbm\":\n          gbmJob = new GBM((GBMModel.GBMParameters) params);\n          AccuracyTestingSuite.summaryLog.println(\"Training GBM model.\");\n          modelStartTime = System.currentTimeMillis();\n          gbmModel = gbmJob.trainModel().get();\n          modelStopTime = System.currentTimeMillis();\n          modelOutput = gbmModel._output;\n          break;\n        case \"dl\":\n          dlJob = new DeepLearning((DeepLearningModel.DeepLearningParameters) params);\n          AccuracyTestingSuite.summaryLog.println(\"Training DL model.\");\n          modelStartTime = System.currentTimeMillis();\n          dlModel = dlJob.trainModel().get();\n          modelStopTime = System.currentTimeMillis();\n          modelOutput = dlModel._output;\n          break;\n      }\n    } catch (Exception e) {\n      throw new Exception(e);\n    } finally {\n      if (drfModel != null) { drfModel.delete(); }\n      if (glmModel != null) { glmModel.delete(); }\n      if (gbmModel != null) { gbmModel.delete(); }\n      if (dlModel != null)  { dlModel.delete(); }\n      Scope.exit();\n    }\n\n    removeTestCaseDataSetFrames();\n\n    return new TestCaseResult(testCaseId, getMetrics(modelOutput._training_metrics),\n      getMetrics(modelOutput._validation_metrics), modelStopTime - modelStartTime);\n  }","id":89125,"modified_method":"public TestCaseResult execute() throws Exception, AssertionError {\n    loadTestCaseDataSets();\n    makeModelParameters();\n\n    double startTime = 0, stopTime = 0;\n    if (!grid) {\n      Model.Output modelOutput = null;\n      DRF drfJob;\n      DRFModel drfModel = null;\n      GLM glmJob;\n      GLMModel glmModel = null;\n      GBM gbmJob;\n      GBMModel gbmModel = null;\n      DeepLearning dlJob;\n      DeepLearningModel dlModel = null;\n\n      try {\n        switch (algo) {\n          case \"drf\":\n            drfJob = new DRF((DRFModel.DRFParameters) params);\n            AccuracyTestingSuite.summaryLog.println(\"Training DRF model.\");\n            startTime = System.currentTimeMillis();\n            drfModel = drfJob.trainModel().get();\n            stopTime = System.currentTimeMillis();\n            modelOutput = drfModel._output;\n            break;\n          case \"glm\":\n            glmJob = new GLM((GLMModel.GLMParameters) params, Key.<GLMModel>make(\"GLMModel\"));\n            AccuracyTestingSuite.summaryLog.println(\"Training GLM model.\");\n            startTime = System.currentTimeMillis();\n            glmModel = glmJob.trainModel().get();\n            stopTime = System.currentTimeMillis();\n            modelOutput = glmModel._output;\n            break;\n          case \"gbm\":\n            gbmJob = new GBM((GBMModel.GBMParameters) params);\n            AccuracyTestingSuite.summaryLog.println(\"Training GBM model.\");\n            startTime = System.currentTimeMillis();\n            gbmModel = gbmJob.trainModel().get();\n            stopTime = System.currentTimeMillis();\n            modelOutput = gbmModel._output;\n            break;\n          case \"dl\":\n            dlJob = new DeepLearning((DeepLearningModel.DeepLearningParameters) params);\n            AccuracyTestingSuite.summaryLog.println(\"Training DL model.\");\n            startTime = System.currentTimeMillis();\n            dlModel = dlJob.trainModel().get();\n            stopTime = System.currentTimeMillis();\n            modelOutput = dlModel._output;\n            break;\n        }\n      } catch (Exception e) {\n        throw new Exception(e);\n      } finally {\n        if (drfModel != null) {\n          drfModel.delete();\n        }\n        if (glmModel != null) {\n          glmModel.delete();\n        }\n        if (gbmModel != null) {\n          gbmModel.delete();\n        }\n        if (dlModel != null) {\n          dlModel.delete();\n        }\n      }\n      removeTestCaseDataSetFrames();\n      return new TestCaseResult(testCaseId, getMetrics(modelOutput._training_metrics),\n              getMetrics(modelOutput._validation_metrics), stopTime - startTime);\n    } else {\n      makeGridParameters();\n      Grid grid = null;\n      Model bestModel = null;\n      try {\n        switch (algo) {  // TODO: Hack for PUBDEV-2812\n          case \"drf\":\n            new DRF(true);\n            break;\n          case \"glm\":\n            new GLM(true);\n            break;\n          case \"gbm\":\n            new GBM(true);\n            break;\n          case \"dl\":\n            new DeepLearning(true);\n            break;\n        }\n        startTime = System.currentTimeMillis();\n        Job<Grid> gs = GridSearch.startGridSearch(null, params, hyperParms);\n        grid = gs.get();\n        stopTime = System.currentTimeMillis();\n\n        boolean higherIsBetter = higherIsBetter(gridCriteria);\n        double bestScore = higherIsBetter ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        for (Model m : grid.getModels()) {\n          double validationMetricScore = getMetrics(m._output._validation_metrics).get(gridCriteria);\n          AccuracyTestingSuite.summaryLog.println(gridCriteria + \" for model \" + m._key.toString() + \" is \" +\n                  validationMetricScore);\n          if (higherIsBetter ? validationMetricScore > bestScore : validationMetricScore < bestScore) {\n            bestScore = validationMetricScore;\n            bestModel = m;\n          }\n        }\n        AccuracyTestingSuite.summaryLog.println(\"Best model: \" + bestModel._key.toString());\n      } catch (Exception e) {\n        throw new Exception(e);\n      } finally {\n        if (grid != null) {\n          grid.delete();\n        }\n      }\n      removeTestCaseDataSetFrames();\n      return new TestCaseResult(testCaseId, getMetrics(bestModel._output._training_metrics),\n              getMetrics(bestModel._output._validation_metrics), stopTime - startTime);\n    }\n  }","commit_id":"a6a53648add5636fa2fdcb1d57f7ab9624abaed7","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public TestCase(int testCaseId, String algo, String algoParameters, boolean tuned, boolean regression, int\n    trainingDataSetId, int testingDataSetId, String testCaseDescription) throws Exception {\n    this.testCaseId = testCaseId;\n    this.algo = algo;\n    this.algoParameters = algoParameters;\n    this.tuned = tuned;\n    this.regression = regression;\n    this.trainingDataSetId = trainingDataSetId;\n    this.testingDataSetId = testingDataSetId;\n    this.testCaseDescription = testCaseDescription;\n\n    trainingDataSet = new DataSet(this.trainingDataSetId);\n    testingDataSet = new DataSet(this.testingDataSetId);\n  }","id":89126,"modified_method":"public TestCase(int testCaseId, String algo, String algoParameters, boolean grid, String gridParameters,\n                  String gridCriteria, boolean regression, int trainingDataSetId, int testingDataSetId,\n                  String testCaseDescription) throws Exception {\n    this.testCaseId = testCaseId;\n    this.algo = algo;\n    this.algoParameters = algoParameters;\n    this.grid = grid;\n    this.gridParameters = gridParameters;\n    this.gridCriteria = gridCriteria;\n    this.regression = regression;\n    this.trainingDataSetId = trainingDataSetId;\n    this.testingDataSetId = testingDataSetId;\n    this.testCaseDescription = testCaseDescription;\n\n    trainingDataSet = new DataSet(this.trainingDataSetId);\n    testingDataSet = new DataSet(this.testingDataSetId);\n  }","commit_id":"a6a53648add5636fa2fdcb1d57f7ab9624abaed7","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   *    <p>First line starts \"List of devices\"\n\n        <p>When an emulator is started with a debug port, then it shows up\n        in the list of devices.\n\n        <p>List of devices attached\n        <br>HT91MLC00031 device\n        <br>emulator-5554 offline\n\n        <p>List of devices attached\n        <br>HT91MLC00031 device\n        <br>emulator-5554 device\n\n   * @return list of device identifiers\n   * @throws IOException\n   */\n  public static List<String> listDevices() {\n    ProcessResult result;\n    try {\n//      System.out.println(\"listing devices 00\");\n      result = AndroidSDK.runADB(\"devices\");\n//      System.out.println(\"listing devices 05\");\n    } catch (InterruptedException e) {\n      return Collections.emptyList();\n    } catch (IOException e) {\n      e.printStackTrace();\n//      System.err.println(e);\n//      System.err.println(\"checking devices\");\n//      e.printStackTrace(EditorConsole.systemErr);\n      return Collections.emptyList();\n    }\n//    System.out.println(\"listing devices 10\");\n    if (!result.succeeded()) {\n      if (result.getStderr().contains(\"protocol fault (no status)\")) {\n        System.err.println(\"bleh: \" + result);  // THIS IS WORKING\n      } else {\n        System.err.println(\"nope: \" + result);\n      }\n      return Collections.emptyList();\n    }\n//    System.out.println(\"listing devices 20\");\n\n    // might read \"List of devices attached\"\n    final String stdout = result.getStdout();\n    if (!(stdout.startsWith(\"List of devices\") || stdout.trim().length() == 0)) {\n      System.err.println(ADB_DEVICES_ERROR);\n      return Collections.emptyList();\n    }\n\n//    System.out.println(\"listing devices 30\");\n    final List<String> devices = new ArrayList<String>();\n    for (final String line : result) {\n      if (!line.contains(\"\\t\")) {\n        continue;\n      }\n      final String[] fields = line.split(\"\\t\");\n      if (fields[1].equals(\"device\")) {\n        devices.add(fields[0]);\n      }\n    }\n    return devices;\n  }","id":89127,"modified_method":"/**\n   *    <p>First line starts \"List of devices\"\n\n        <p>When an emulator is started with a debug port, then it shows up\n        in the list of devices.\n\n        <p>List of devices attached\n        <br>HT91MLC00031 device\n        <br>emulator-5554 offline\n\n        <p>List of devices attached\n        <br>HT91MLC00031 device\n        <br>emulator-5554 device\n\n   * @return list of device identifiers\n   * @throws IOException\n   */\n  public static List<String> listDevices() {\n    ProcessResult result;\n    try {\n//      System.out.println(\"listing devices 00\");\n      result = AndroidSDK.runADB(\"devices\");\n//      System.out.println(\"listing devices 05\");\n    } catch (InterruptedException e) {\n      return Collections.emptyList();\n    } catch (IOException e) {\n      System.err.println(\"AndroidEnvironment.listDevices() did this to me\");\n      e.printStackTrace();\n//      System.err.println(e);\n//      System.err.println(\"checking devices\");\n//      e.printStackTrace(EditorConsole.systemErr);\n      return Collections.emptyList();\n    }\n//    System.out.println(\"listing devices 10\");\n    if (!result.succeeded()) {\n      if (result.getStderr().contains(\"protocol fault (no status)\")) {\n        System.err.println(\"bleh: \" + result);  // THIS IS WORKING\n      } else {\n        System.err.println(\"nope: \" + result);\n      }\n      return Collections.emptyList();\n    }\n//    System.out.println(\"listing devices 20\");\n\n    // might read \"List of devices attached\"\n    final String stdout = result.getStdout();\n    if (!(stdout.startsWith(\"List of devices\") || stdout.trim().length() == 0)) {\n      System.err.println(ADB_DEVICES_ERROR);\n      return Collections.emptyList();\n    }\n\n//    System.out.println(\"listing devices 30\");\n    final List<String> devices = new ArrayList<String>();\n    for (final String line : result) {\n      if (!line.contains(\"\\t\")) {\n        continue;\n      }\n      final String[] fields = line.split(\"\\t\");\n      if (fields[1].equals(\"device\")) {\n        devices.add(fields[0]);\n      }\n    }\n    return devices;\n  }","commit_id":"e38c2e2f717d76669881deee217845aab31c3233","url":"https://github.com/processing/processing"},{"original_method":"public static ProcessResult runADB(final String... cmd)\n  throws InterruptedException, IOException {\n    final String[] adbCmd;\n    if (!cmd[0].equals(\"adb\")) {\n      adbCmd = PApplet.splice(cmd, \"adb\", 0);\n    } else {\n      adbCmd = cmd;\n    }\n//    PApplet.println(adbCmd);\n//    try {\n    ProcessResult adbResult = new ProcessHelper(adbCmd).execute();\n    // Ignore messages about starting up an adb daemon\n    String out = adbResult.getStdout();\n    if (out.contains(ADB_DAEMON_MSG_1) && out.contains(ADB_DAEMON_MSG_2)) {\n      StringBuilder sb = new StringBuilder();\n      for (String line : out.split(\"\\n\")) {\n        if (!out.contains(ADB_DAEMON_MSG_1) &&\n            !out.contains(ADB_DAEMON_MSG_2)) {\n          sb.append(line).append(\"\\n\");\n        }\n      }\n      return new ProcessResult(adbResult.getCmd(), \n                               adbResult.getResult(), \n                               sb.toString(), \n                               adbResult.getStderr(), \n                               adbResult.getTime());\n    }\n    return adbResult;\n//    } catch (IOException ioe) {\n//      ioe.printStackTrace();\n//      throw ioe;\n//    }\n  }","id":89128,"modified_method":"public static ProcessResult runADB(final String... cmd)\n  throws InterruptedException, IOException {\n    final String[] adbCmd;\n    if (!cmd[0].equals(\"adb\")) {\n      adbCmd = PApplet.splice(cmd, \"adb\", 0);\n    } else {\n      adbCmd = cmd;\n    }\n    // printing this here to see if anyone else is killing the adb server\n    PApplet.println(adbCmd);\n//    try {\n    ProcessResult adbResult = new ProcessHelper(adbCmd).execute();\n    // Ignore messages about starting up an adb daemon\n    String out = adbResult.getStdout();\n    if (out.contains(ADB_DAEMON_MSG_1) && out.contains(ADB_DAEMON_MSG_2)) {\n      StringBuilder sb = new StringBuilder();\n      for (String line : out.split(\"\\n\")) {\n        if (!out.contains(ADB_DAEMON_MSG_1) &&\n            !out.contains(ADB_DAEMON_MSG_2)) {\n          sb.append(line).append(\"\\n\");\n        }\n      }\n      return new ProcessResult(adbResult.getCmd(), \n                               adbResult.getResult(), \n                               sb.toString(), \n                               adbResult.getStderr(), \n                               adbResult.getTime());\n    }\n    return adbResult;\n//    } catch (IOException ioe) {\n//      ioe.printStackTrace();\n//      throw ioe;\n//    }\n  }","commit_id":"e38c2e2f717d76669881deee217845aab31c3233","url":"https://github.com/processing/processing"},{"original_method":"public PreprocessResult write(Writer out, String program, String codeFolderPackages[])\n    throws RunnerException, RecognitionException, TokenStreamException {\n      if (sketchSize != null) {\n        int start = program.indexOf(sketchSize);\n        program = program.substring(0, start) + \n          program.substring(start + sketchSize.length());\n      }\n      return super.write(out, program, codeFolderPackages);\n    }","id":89129,"modified_method":"public PreprocessResult write(Writer out, String program, String codeFolderPackages[])\n    throws RunnerException, RecognitionException, TokenStreamException {\n      if (sizeStatement != null) {\n        int start = program.indexOf(sizeStatement);\n        program = program.substring(0, start) + \n          program.substring(start + sizeStatement.length());\n      }\n      return super.write(out, program, codeFolderPackages);\n    }","commit_id":"e38c2e2f717d76669881deee217845aab31c3233","url":"https://github.com/processing/processing"},{"original_method":"protected boolean calcSketchSize() {\n    // This matches against any uses of the size() function, whether numbers\n    // or variables or whatever. This way, no warning is shown if size() isn't\n    // actually used in the applet, which is the case especially for anyone\n    // who is cutting/pasting from the reference.\n    final String sizeRegex =\n      \"(?:^|\\\\s|;)size\\\\s*\\\\(\\\\s*(\\\\S+)\\\\s*,\\\\s*(\\\\d+),?\\\\s*([^\\\\)]*)\\\\s*\\\\)\\\\s*\\\\;\";\n//      \"(?:^|\\\\s|;)size\\\\s*\\\\(\\\\s*(\\\\S+)\\\\s*,\\\\s*(\\\\d+),?\\\\s*([^\\\\)]*)\\\\s*\\\\)\";\n    // This is identical to the version in Sketch.java, but adds the semicolon\n\n    Sketch sketch = editor.getSketch();\n    String scrubbed = Sketch.scrubComments(sketch.getCode(0).getProgram());\n    String[] matches = PApplet.match(scrubbed, sizeRegex);\n\n    if (matches != null) {\n      try {\n        // these are ignored, just checking for the exception\n        Integer.parseInt(matches[1]);\n        Integer.parseInt(matches[2]);\n      } catch (final NumberFormatException e) {\n        // found a reference to size, but it didn't\n        // seem to contain numbers\n        final String message = \n          \"The size of this applet could not automatically be\\n\" +\n          \"determined from your code.\\n\" +\n          \"Use only numeric values (not variables) for the size()\\n\" +\n          \"command. See the size() reference for an explanation.\";\n        Base.showWarning(\"Could not find sketch size\", message, null);\n        return false;\n      }\n      sketchSize = matches[0];\n      sketchWidth = matches[1];\n      sketchHeight = matches[2];\n      if (matches[3].trim().length() != 0) {\n        sketchRenderer = matches[3];\n      }\n    }\n    return true;\n  }","id":89130,"modified_method":"protected boolean calcSketchSize() {\n    // This matches against any uses of the size() function, whether numbers\n    // or variables or whatever. This way, no warning is shown if size() isn't\n    // actually used in the applet, which is the case especially for anyone\n    // who is cutting/pasting from the reference.\n\n    Sketch sketch = editor.getSketch();\n    String scrubbed = Sketch.scrubComments(sketch.getCode(0).getProgram());\n    String[] matches = PApplet.match(scrubbed, Sketch.SIZE_REGEX);\n//    PApplet.println(\"matches: \");\n//    PApplet.println(matches);\n\n    if (matches != null) {\n      boolean badSize = false;\n      \n      if (!matches[1].equals(\"screenWidth\") &&\n          !matches[1].equals(\"screenHeight\") &&\n          PApplet.parseInt(matches[1], -1) == -1) {\n        badSize = true;\n      }\n      if (!matches[2].equals(\"screenWidth\") &&\n          !matches[2].equals(\"screenHeight\") &&\n          PApplet.parseInt(matches[2], -1) == -1) {\n        badSize = true;\n      }\n\n      if (badSize) {\n        // found a reference to size, but it didn't seem to contain numbers\n        final String message = \n          \"The size of this applet could not automatically be determined\\n\" +\n          \"from your code. Use only numeric values (not variables) for the\\n\" +\n          \"size() command. See the size() reference for more information.\";\n        Base.showWarning(\"Could not find sketch size\", message, null);\n        System.out.println(\"More about the size() command on Android can be\");\n        System.out.println(\"found here: http://wiki.processing.org/w/Android\");\n        return false;\n      }\n\n//      PApplet.println(matches);\n      sizeStatement = matches[0];  // the full method to be removed from the source\n      sketchWidth = matches[1];\n      sketchHeight = matches[2];\n      sketchRenderer = matches[3].trim();\n      if (sketchRenderer.length() == 0) {\n        sketchRenderer = null;\n      }\n    } else {\n      sizeStatement = null;\n      sketchWidth = null;\n      sketchHeight = null;\n      sketchRenderer = null;\n    }\n    return true;\n  }","commit_id":"e38c2e2f717d76669881deee217845aab31c3233","url":"https://github.com/processing/processing"},{"original_method":"protected void writeFooter(PrintWriter out, String className) {\n      if (mode == Mode.STATIC) {\n        // close off draw() definition\n        out.println(\"noLoop();\");\n        out.println(indent + \"}\");\n      }\n\n      if ((mode == Mode.STATIC) || (mode == Mode.ACTIVE)) {\n        out.println();\n        out.println(indent + \"public int sketchWidth() { return \" + sketchWidth + \"; }\");\n        out.println(indent + \"public int sketchHeight() { return \" + sketchHeight + \"; }\");\n        out.println(indent + \"public String sketchRenderer() { return \" + sketchRenderer + \"; }\");\n\n        // close off the class definition\n        out.println(\"}\");\n      }\n    }","id":89131,"modified_method":"protected void writeFooter(PrintWriter out, String className) {\n      if (mode == Mode.STATIC) {\n        // close off draw() definition\n        out.println(\"noLoop();\");\n        out.println(indent + \"}\");\n      }\n\n      if ((mode == Mode.STATIC) || (mode == Mode.ACTIVE)) {\n        out.println();\n        if (sketchWidth != null) {\n          out.println(indent + \"public int sketchWidth() { return \" + sketchWidth + \"; }\");\n        }\n        if (sketchHeight != null) {\n          out.println(indent + \"public int sketchHeight() { return \" + sketchHeight + \"; }\");\n        }\n        if (sketchRenderer != null) {\n          out.println(indent + \"public String sketchRenderer() { return \" + sketchRenderer + \"; }\");\n        }\n\n        // close off the class definition\n        out.println(\"}\");\n      }\n    }","commit_id":"e38c2e2f717d76669881deee217845aab31c3233","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Blocks until emulator is running, or some catastrophe happens.\n   * @throws IOException\n   */\n  synchronized public void launch() throws IOException {\n    if (state != State.NOT_RUNNING) {\n      String illegal = \"You can't launch an emulator whose state is \" + state;\n      throw new IllegalStateException(illegal);\n    }\n\n    String portString = Preferences.get(\"android.emulator.port\");\n    if (portString == null) {\n      portString = \"5566\";\n      Preferences.set(\"android.emulator.port\", portString);\n    }\n\n    // See http://developer.android.com/guide/developing/tools/emulator.html\n    final String[] cmd = new String[] {\n      \"emulator\", \n      \"-avd\", AVD.defaultAVD.name, \n      \"-port\", portString, \n      \"-no-boot-anim\" \n    };\n    //System.err.println(\"EmulatorController: Launching emulator\");\n    final Process p = Runtime.getRuntime().exec(cmd);\n    ProcessRegistry.watch(p);\n\n    // if we've gotten this far, then we've at least succeeded in finding and\n    // beginning execution of the emulator, so we are now officially \"Launched\"\n    setState(State.WAITING_FOR_BOOT);\n\n    // TODO need to suppress this warning on OS X\n    // 2010-04-13 15:26:56.380 emulator[91699:903] Warning once: This \n    // application, or a library it uses, is using NSQuickDrawView, which has \n    // been deprecated. Apps should cease use of QuickDraw and move to Quartz.\n    final String title = PApplet.join(cmd, ' ');\n    new StreamPump(p.getInputStream(), \"out: \" + title).addTarget(System.out)\n        .start();\n    new StreamPump(p.getErrorStream(), \"err: \" + title).addTarget(System.err)\n        .start();\n    final CountDownLatch latch = new CountDownLatch(1);\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          //          System.err.println(\"EmulatorController: Waiting for boot.\");\n          while (state == State.WAITING_FOR_BOOT) {\n            System.out.println(\"sleeping for 2 seconds \" + new java.util.Date().toString());\n            Thread.sleep(2000);\n            System.out.println(\"done sleeping\");\n            for (final String device : AndroidEnvironment.listDevices()) {\n              if (device.contains(\"emulator\")) {\n                //                System.err.println(\"EmulatorController: Emulator booted.\");\n                setState(State.RUNNING);\n                return;\n              }\n            }\n          }\n          System.err.println(\"EmulatorController: Emulator never booted. \" + state);\n        } catch (final Exception e) {\n          System.err.println(\"While waiting for emulator to boot \" + e);\n          p.destroy();\n        } finally {\n          latch.countDown();\n        }\n      }\n    }, \"EmulatorController: Wait for emulator to boot\").start();\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          try {\n            p.waitFor();\n            //            final int result = p.waitFor();\n            //            System.err\n            //                .println(\"Emulator process exited \"\n            //                    + ((result == 0) ? \"normally\" : \" with status \" + result)\n            //                    + \".\");\n          } catch (final InterruptedException e) {\n            System.err.println(\"Emulator was interrupted.\");\n          } finally {\n            p.destroy();\n            ProcessRegistry.unwatch(p);\n          }\n        } finally {\n          setState(State.NOT_RUNNING);\n        }\n      }\n    }, \"EmulatorController: Process manager\").start();\n    try {\n      latch.await();\n    } catch (final InterruptedException drop) {\n      System.err.println(\"Interrupted while waiting for emulator to launch.\");\n    }\n  }","id":89132,"modified_method":"/**\n   * Blocks until emulator is running, or some catastrophe happens.\n   * @throws IOException\n   */\n  synchronized public void launch() throws IOException {\n    if (state != State.NOT_RUNNING) {\n      String illegal = \"You can't launch an emulator whose state is \" + state;\n      throw new IllegalStateException(illegal);\n    }\n\n    String portString = Preferences.get(\"android.emulator.port\");\n    if (portString == null) {\n      portString = \"5566\";\n      Preferences.set(\"android.emulator.port\", portString);\n    }\n\n    // See http://developer.android.com/guide/developing/tools/emulator.html\n    final String[] cmd = new String[] {\n      \"emulator\", \n      \"-avd\", AVD.defaultAVD.name, \n      \"-port\", portString, \n      \"-no-boot-anim\" \n    };\n    //System.err.println(\"EmulatorController: Launching emulator\");\n    final Process p = Runtime.getRuntime().exec(cmd);\n    ProcessRegistry.watch(p);\n\n    // if we've gotten this far, then we've at least succeeded in finding and\n    // beginning execution of the emulator, so we are now officially \"Launched\"\n    setState(State.WAITING_FOR_BOOT);\n\n    final String title = PApplet.join(cmd, ' ');\n    \n    // when this shows up on stdout:\n    // emulator: ERROR: the cache image is used by another emulator. aborting\n    // need to reset adb and try again, since it's running but adb is hosed\n    StreamPump outie = new StreamPump(p.getInputStream(), \"out: \" + title);\n    outie.addTarget(new LineProcessor() {\n      public void processLine(String line) {\n        if (line.contains(\"the cache image is used by another emulator\")) {\n          \n        } else {\n//          System.out.println(line);\n          System.out.println(title + \": \" + line);\n        }\n      }      \n    });    \n    //new StreamPump(p.getInputStream(), \"out: \" + title).addTarget(System.out).start();\n    \n    // suppress this warning on OS X, otherwise we're gonna get a lot of reports:\n    // 2010-04-13 15:26:56.380 emulator[91699:903] Warning once: This \n    // application, or a library it uses, is using NSQuickDrawView, which has \n    // been deprecated. Apps should cease use of QuickDraw and move to Quartz.\n    StreamPump errie = new StreamPump(p.getErrorStream(), \"err: \" + title);\n    errie.addTarget(new LineProcessor() {\n      public void processLine(String line) {\n        if (line.contains(\"This application, or a library it uses, is using NSQuickDrawView\")) {\n          // i don't really care\n        } else {\n//          System.err.println(line);\n          System.err.println(title + \": \" + line);\n        }\n      }      \n    });    \n    //new StreamPump(p.getErrorStream(), \"err: \" + title).addTarget(System.err).start();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          //          System.err.println(\"EmulatorController: Waiting for boot.\");\n          while (state == State.WAITING_FOR_BOOT) {\n            System.out.println(\"sleeping for 2 seconds \" + new java.util.Date().toString());\n            Thread.sleep(2000);\n//            System.out.println(\"done sleeping\");\n            for (final String device : AndroidEnvironment.listDevices()) {\n              if (device.contains(\"emulator\")) {\n                //                System.err.println(\"EmulatorController: Emulator booted.\");\n                setState(State.RUNNING);\n                return;\n              }\n            }\n          }\n          System.err.println(\"EmulatorController: Emulator never booted. \" + state);\n        } catch (final Exception e) {\n          System.err.println(\"While waiting for emulator to boot \" + e);\n          p.destroy();\n        } finally {\n          latch.countDown();\n        }\n      }\n    }, \"EmulatorController: Wait for emulator to boot\").start();\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          try {\n            p.waitFor();\n            //            final int result = p.waitFor();\n            //            System.err\n            //                .println(\"Emulator process exited \"\n            //                    + ((result == 0) ? \"normally\" : \" with status \" + result)\n            //                    + \".\");\n          } catch (final InterruptedException e) {\n            System.err.println(\"Emulator was interrupted.\");\n          } finally {\n            p.destroy();\n            ProcessRegistry.unwatch(p);\n          }\n        } finally {\n          setState(State.NOT_RUNNING);\n        }\n      }\n    }, \"EmulatorController: Process manager\").start();\n    try {\n      latch.await();\n    } catch (final InterruptedException drop) {\n      System.err.println(\"Interrupted while waiting for emulator to launch.\");\n    }\n  }","commit_id":"e38c2e2f717d76669881deee217845aab31c3233","url":"https://github.com/processing/processing"},{"original_method":"@Override\n    public void visitMethodCallExpression(\n      @NotNull PsiMethodCallExpression expression) {\n      super.visitMethodCallExpression(expression);\n      final PsiReferenceExpression methodExpression =\n        expression.getMethodExpression();\n      final String methodName = methodExpression.getReferenceName();\n      @NonNls final String exit = \"exit\";\n      @NonNls final String halt = \"halt\";\n      if (!exit.equals(methodName) && !halt.equals(methodName)) {\n        return;\n      }\n      final PsiMethod method = expression.resolveMethod();\n      if (method == null) {\n        return;\n      }\n\n      final PsiParameterList parameterList = method.getParameterList();\n      if (parameterList.getParametersCount() != 1) {\n        return;\n      }\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiType parameterType = parameters[0].getType();\n      if (!parameterType.equals(PsiType.INT)) {\n        return;\n      }\n      final PsiClass aClass = method.getContainingClass();\n      if (aClass == null) {\n        return;\n      }\n      final String className = aClass.getQualifiedName();\n      if (className == null) {\n        return;\n      }\n      if (\"java.lang.System\".equals(className)) {\n        registerMethodCallError(expression, \"System\");\n      }\n      else if (\"java.lang.Runtime\".equals(className)) {\n        registerMethodCallError(expression, \"Runtime\");\n      }\n    }","id":89133,"modified_method":"@Override\n    public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {\n      super.visitMethodCallExpression(expression);\n      final PsiReferenceExpression methodExpression = expression.getMethodExpression();\n      @NonNls final String methodName = methodExpression.getReferenceName();\n      if (!\"exit\".equals(methodName) && !\"halt\".equals(methodName)) {\n        return;\n      }\n      final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(expression, PsiMethod.class, true, PsiClass.class);\n      if (ignoreInMainMethod && PsiMethodUtil.isMainMethod(containingMethod)) {\n        return;\n      }\n      final PsiMethod method = expression.resolveMethod();\n      if (method == null) {\n        return;\n      }\n      final PsiParameterList parameterList = method.getParameterList();\n      if (parameterList.getParametersCount() != 1) {\n        return;\n      }\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiType parameterType = parameters[0].getType();\n      if (!parameterType.equals(PsiType.INT)) {\n        return;\n      }\n      final PsiClass aClass = method.getContainingClass();\n      if (aClass == null) {\n        return;\n      }\n      final String className = aClass.getQualifiedName();\n      if (!\"java.lang.System\".equals(className) && !\"java.lang.Runtime\".equals(className)) {\n        return;\n      }\n      registerMethodCallError(expression, \"System\");\n    }","commit_id":"efbeb6ea9966330a3e0e91456cccf5b781e39cbe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethodCallExpression(\n      @NotNull PsiMethodCallExpression expression) {\n      super.visitMethodCallExpression(expression);\n      if (!isJUnitAssertion(expression)) {\n        return;\n      }\n      final PsiReferenceExpression methodExpression =\n        expression.getMethodExpression();\n      final PsiMethod method = (PsiMethod)methodExpression.resolve();\n      if (method == null) {\n        return;\n      }\n      final PsiParameterList parameterList = method.getParameterList();\n      @NonNls final String methodName = method.getName();\n      final int parameterCount = parameterList.getParametersCount();\n      if (parameterCount < 2 && methodName.startsWith(\"assert\")) {\n        registerMethodCallError(expression);\n        return;\n      }\n      if (parameterCount < 1) {\n        registerMethodCallError(expression);\n        return;\n      }\n      final PsiManager psiManager = expression.getManager();\n      final Project project = psiManager.getProject();\n      final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n      final PsiType stringType = PsiType.getJavaLangString(psiManager,\n                                                           scope);\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiType parameterType1 = parameters[0].getType();\n      if (parameterType1.equals(stringType)) {\n        if (parameters.length == 2) {\n          final PsiType parameterType2 = parameters[1].getType();\n          if (parameterType2.equals(stringType)) {\n            registerMethodCallError(expression);\n          }\n        }\n      }\n      else {\n        registerMethodCallError(expression);\n      }\n    }","id":89134,"modified_method":"@Override\n    public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression) {\n      super.visitMethodCallExpression(expression);\n      final PsiReferenceExpression methodExpression = expression.getMethodExpression();\n      final String methodName = methodExpression.getReferenceName();\n      if (methodName == null || !s_assertMethods.contains(methodName)) {\n        return;\n      }\n      final PsiMethod method = expression.resolveMethod();\n      if (method == null) {\n        return;\n      }\n      final PsiClass containingClass = method.getContainingClass();\n      if (!InheritanceUtil.isInheritor(containingClass, \"junit.framework.Assert\") &&\n          !InheritanceUtil.isInheritor(containingClass, \"org.junit.Assert\")) {\n        return;\n      }\n      final PsiParameterList parameterList = method.getParameterList();\n      final int parameterCount = parameterList.getParametersCount();\n      if (parameterCount < 2 && methodName.startsWith(\"assert\")) {\n        registerMethodCallError(expression);\n        return;\n      }\n      if (parameterCount < 1) {\n        registerMethodCallError(expression);\n        return;\n      }\n      final PsiManager psiManager = expression.getManager();\n      final Project project = psiManager.getProject();\n      final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n      final PsiType stringType = PsiType.getJavaLangString(psiManager, scope);\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiType parameterType1 = parameters[0].getType();\n      if (!parameterType1.equals(stringType)) {\n        registerMethodCallError(expression);\n        return;\n      }\n      if (parameters.length != 2) {\n        return;\n      }\n      final PsiType parameterType2 = parameters[1].getType();\n      if (!parameterType2.equals(stringType)) {\n        return;\n      }\n      registerMethodCallError(expression);\n    }","commit_id":"075c4981cd3f7b9fd55b88d464a40a8692fec0db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void formatCallCheckString(){\n        final StringBuilder buffer = new StringBuilder();\n        synchronized(lock){\n\n            boolean first=true;\n            for(ReturnCheckSpecification returnCheckSpecification :\n                    callsToCheck){\n                if(first){\n                    first = false;\n                } else{\n                    buffer.append(',');\n                }\n                final String methodName =\n                        returnCheckSpecification.getMethodName();\n                final String className =\n                        returnCheckSpecification.getClassName();\n                buffer.append(className);\n                buffer.append(',');\n                buffer.append(methodName);\n            }\n        }\n        callCheckString = buffer.toString();\n    }","id":89135,"modified_method":"private void formatCallCheckString(){\n        final StringBuilder buffer = new StringBuilder();\n        final int size = methodNamePatterns.size();\n        if (size > 0) {\n            buffer.append(classNames.get(0));\n            buffer.append(',');\n            buffer.append(methodNamePatterns.get(0));\n            for (int i = 1; i < size; i++) {\n                buffer.append(classNames.get(i));\n                buffer.append(',');\n                buffer.append(methodNamePatterns.get(0));\n            }\n        }\n        callCheckString = buffer.toString();\n    }","commit_id":"dfb9ae6f102b8fefd54b9230a9edb62617645881","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Form(){\n            super();\n            table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n            table.setRowSelectionAllowed(true);\n            table.setSelectionMode(\n                    ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n            final ReturnCheckSpecificationTableModel model =\n                    new ReturnCheckSpecificationTableModel();\n            table.setModel(model);\n            addButton.addActionListener(new ActionListener(){\n                public void actionPerformed(ActionEvent e){\n                    final int listSize;\n                    synchronized(lock){\n                        listSize = callsToCheck.size();\n                        callsToCheck.add(new ReturnCheckSpecification());\n                    }\n                    model.fireTableStructureChanged();\n\n                    EventQueue.invokeLater(new Runnable() {\n                        public void run() {\n                            final Rectangle rect =\n                                    table.getCellRect(listSize, 0, true);\n                            table.scrollRectToVisible(rect);\n                            table.editCellAt(listSize, 0);\n                            final TableCellEditor editor =\n                                    table.getCellEditor();\n                            final Component component =\n                                    editor.getTableCellEditorComponent(table,\n                                            null, true, listSize, 0);\n                            component.requestFocus();\n                        }\n                    });\n                }\n            });\n            deleteButton.addActionListener(new ActionListener(){\n                public void actionPerformed(ActionEvent e){\n                    final int[] selectedRows = table.getSelectedRows();\n                    if (selectedRows.length == 0) {\n                        return;\n                    }\n                    final int row = selectedRows[selectedRows.length - 1] - 1;\n                    Arrays.sort(selectedRows);\n                    synchronized(lock){\n                        for(int i = selectedRows.length - 1; i >= 0; i--){\n                            callsToCheck.remove(selectedRows[i]);\n                        }\n                    }\n                    model.fireTableStructureChanged();\n                    final int count = table.getRowCount();\n                    if (count <= row) {\n                        table.setRowSelectionInterval(count - 1, count - 1);\n                    } else {\n                        table.setRowSelectionInterval(row, row);\n                    }\n                }\n            });\n            nonLibraryCheckbox.setEnabled(true);\n            nonLibraryCheckbox.setSelected(m_reportAllNonLibraryCalls);\n            final ButtonModel buttonModel = nonLibraryCheckbox.getModel();\n            buttonModel.addChangeListener(new ChangeListener(){\n                public void stateChanged(ChangeEvent e){\n                    m_reportAllNonLibraryCalls = buttonModel.isSelected();\n                }\n            });\n        }","id":89136,"modified_method":"Form(){\n            super();\n            addButton.setAction(new AddAction(table));\n            removeButton.setAction(new RemoveAction(table));\n            nonLibraryCheckbox.setAction(new ToggleAction(\n                    InspectionGadgetsBundle.message(\n                            \"result.of.method.call.ignored.non.library.option\"),\n                    IgnoreResultOfCallInspection.this,\n                    \"m_reportAllNonLibraryCalls\"));\n        }","commit_id":"dfb9ae6f102b8fefd54b9230a9edb62617645881","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitExpressionStatement(\n                @NotNull PsiExpressionStatement statement){\n            super.visitExpressionStatement(statement);\n            final PsiExpression expression = statement.getExpression();\n            if(!(expression instanceof PsiMethodCallExpression)){\n                return;\n            }\n            final PsiMethodCallExpression call =\n                    (PsiMethodCallExpression) expression;\n            final PsiMethod method = call.resolveMethod();\n            if(method == null){\n                return;\n            }\n            if(method.isConstructor()){\n                return;\n            }\n            final PsiType retType = method.getReturnType();\n            if(PsiType.VOID.equals(retType)){\n                return;\n            }\n            final PsiClass aClass = method.getContainingClass();\n            if(aClass == null){\n                return;\n            }\n            if(m_reportAllNonLibraryCalls &&\n                       !LibraryUtil.classIsInLibrary(aClass)){\n                registerMethodCallError(call, aClass);\n                return;\n            }\n            final PsiReferenceExpression methodExpression =\n                    call.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if(methodName == null){\n                return;\n            }\n            final List<ReturnCheckSpecification> callsToCheckCopy;\n            synchronized(lock){\n                callsToCheckCopy =\n                        new ArrayList<ReturnCheckSpecification>(callsToCheck);\n            }\n            for(ReturnCheckSpecification spec : callsToCheckCopy){\n                final Pattern methodNamePattern = spec.getMethodNamePattern();\n                if(methodNamePattern != null &&\n                        methodNamesMatch(methodName, methodNamePattern)){\n                    final String classNameToCompare = spec.getClassName();\n                    if(ClassUtils.isSubclass(aClass, classNameToCompare)){\n                        registerMethodCallError(call, aClass);\n                        return;\n                    }\n                }\n            }\n        }","id":89137,"modified_method":"public void visitExpressionStatement(\n                @NotNull PsiExpressionStatement statement){\n            super.visitExpressionStatement(statement);\n            final PsiExpression expression = statement.getExpression();\n            if(!(expression instanceof PsiMethodCallExpression)){\n                return;\n            }\n            final PsiMethodCallExpression call =\n                    (PsiMethodCallExpression) expression;\n            final PsiMethod method = call.resolveMethod();\n            if (method == null || method.isConstructor()) {\n                return;\n            }\n            final PsiType returnType = method.getReturnType();\n            if(PsiType.VOID.equals(returnType)){\n                return;\n            }\n            final PsiClass aClass = method.getContainingClass();\n            if(aClass == null){\n                return;\n            }\n            if(m_reportAllNonLibraryCalls &&\n                       !LibraryUtil.classIsInLibrary(aClass)){\n                registerMethodCallError(call, aClass);\n                return;\n            }\n            final PsiReferenceExpression methodExpression =\n                    call.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if(methodName == null){\n                return;\n            }\n            for (int i = 0; i < methodNamePatterns.size(); i++) {\n                final String methodNamePattern = methodNamePatterns.get(i);\n                if (!methodNamesMatch(methodName, methodNamePattern)) {\n                    continue;\n                }\n                final String className = classNames.get(i);\n                if (!ClassUtils.isSubclass(aClass, className)) {\n                    continue;\n                }\n                registerMethodCallError(call, aClass);\n                return;\n            }\n        }","commit_id":"dfb9ae6f102b8fefd54b9230a9edb62617645881","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseCallCheckString(){\n        final String[] strings = callCheckString.split(\",\");\n        synchronized(lock){\n            callsToCheck.clear();\n            for(int i = 0; i < strings.length-1; i += 2){\n                final String className = strings[i];\n                final String methodName = strings[i + 1];\n                callsToCheck.add(\n                        new ReturnCheckSpecification(className, methodName));\n            }\n        }\n    }","id":89138,"modified_method":"private void parseCallCheckString(){\n        final String[] strings = callCheckString.split(\",\");\n        methodNamePatterns.clear();\n        classNames.clear();\n        patternCache = null;\n        for (int i = 0; i < strings.length - 1; i += 2){\n            final String className = strings[i];\n            classNames.add(className);\n            final String methodNamePattern = strings[i + 1];\n            methodNamePatterns.add(methodNamePattern);\n        }\n    }","commit_id":"dfb9ae6f102b8fefd54b9230a9edb62617645881","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean methodNamesMatch(String methodName,\n                                         Pattern methodNamePattern){\n            final Matcher matcher = methodNamePattern.matcher(methodName);\n            return matcher.matches();\n        }","id":89139,"modified_method":"private boolean methodNamesMatch(String methodName,\n                                         String methodNamePattern){\n            Pattern pattern;\n            if (patternCache != null) {\n                pattern = patternCache.get(methodNamePattern);\n            } else {\n                patternCache = new HashMap(methodNamePatterns.size());\n                pattern = null;\n            }\n            if (pattern == null) {\n                try {\n                    pattern = Pattern.compile(methodNamePattern);\n                    patternCache.put(methodNamePattern, pattern);\n                } catch (PatternSyntaxException ignore) {\n                    return false;\n                } catch (NullPointerException ignore) {\n                    return false;\n                }\n            }\n            if (pattern == null) {\n                return false;\n            }\n            final Matcher matcher = pattern.matcher(methodName);\n            return matcher.matches();\n        }","commit_id":"dfb9ae6f102b8fefd54b9230a9edb62617645881","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void run() {\n        Object implementor = new SwAServiceImpl();\n        String address = \"http://localhost:9036/swa\";\n        try {\n            EndpointImpl ep = (EndpointImpl) Endpoint.create(implementor);\n            ep.setWsdlLocation(\"classpath:wsdl/swa-mime.wsdl\");\n            ep.publish(address);\n        } catch (Exception e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        }\n    }","id":89140,"modified_method":"protected void run() {\n        Object implementor = new SwAServiceImpl();\n        String address = \"http://localhost:9036/swa\";\n        EndpointImpl ep;\n        try {\n            ep = (EndpointImpl) Endpoint.create(new SwANoMimeServiceImpl());\n            ep.setWsdlLocation(\"classpath:wsdl/swa-mime-nomime.wsdl\");\n            ep.publish(address + \"-nomime\");\n            \n            \n            ep = (EndpointImpl) Endpoint.create(implementor);\n            ep.setWsdlLocation(\"classpath:wsdl/swa-mime.wsdl\");\n            ep.publish(address);\n        } catch (Exception e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        }\n    }","commit_id":"dd2b395bf99a69fa7299a63f22dfa2b0423a82d4","url":"https://github.com/apache/cxf"},{"original_method":"private static boolean isDeclared(Element e, String namespaceURI, String prefix) {\n        Attr att;\n        if (prefix != null && prefix.length() > 0) {\n            att = e.getAttributeNodeNS(XML_NS, \"xmlns:\" + prefix);\n        } else {\n            att = e.getAttributeNode(\"xmlns\");\n        }\n\n        if (att != null && att.getNodeValue().equals(namespaceURI)) {\n            return true;\n        }\n\n        if (e.getParentNode() instanceof Element) {\n            return isDeclared((Element)e.getParentNode(), namespaceURI, prefix);\n        }\n\n        return false;\n    }","id":89141,"modified_method":"private static boolean isDeclared(Element e, String namespaceURI, String prefix) {\n        Attr att;\n        if (prefix != null && prefix.length() > 0) {\n            att = e.getAttributeNodeNS(XML_NS, prefix);\n        } else {\n            att = e.getAttributeNode(\"xmlns\");\n        }\n\n        if (att != null && att.getNodeValue().equals(namespaceURI)) {\n            return true;\n        }\n\n        if (e.getParentNode() instanceof Element) {\n            return isDeclared((Element)e.getParentNode(), namespaceURI, prefix);\n        }\n\n        return false;\n    }","commit_id":"dd2b395bf99a69fa7299a63f22dfa2b0423a82d4","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(SoapMessage message) throws Fault {\n        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);\n        if (bop == null) {\n            return;\n        }\n        \n        if (bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n        \n        boolean client = isRequestor(message);\n        BindingMessageInfo bmi = client ? bop.getOutput() : bop.getInput();\n        \n        if (bmi == null) {\n            return;\n        }\n        \n        SoapBodyInfo sbi = bmi.getExtensor(SoapBodyInfo.class);\n        \n        if (sbi == null || sbi.getAttachments() == null || sbi.getAttachments().size() == 0) {\n            return;\n        }\n        \n        Set<Integer> foundAtts = new HashSet<Integer>();\n        MessageContentsList inObjects = MessageContentsList.getContentsList(message);\n\n        for (MessagePartInfo mpi : sbi.getAttachments()) {\n            String partName = mpi.getConcreteName().getLocalPart();\n            \n            String start = partName + \"=\";\n            boolean found = false;\n            \n            if (foundAtts.contains(mpi.getIndex())) {\n                continue;\n            }\n            foundAtts.add(mpi.getIndex());\n            \n            for (Attachment a : message.getAttachments()) {\n                if (a.getId().startsWith(start)) {\n                    DataHandler dh = a.getDataHandler();\n                    String ct = dh.getContentType();\n                    Object o = null;\n                    \n                    if (DataHandler.class.isAssignableFrom(mpi.getTypeClass())) {\n                        o = dh;\n                    } else if (ct.startsWith(\"image/\")) {\n                        try {\n                            o = ImageIO.read(dh.getInputStream());\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    } else if (ct.startsWith(\"text/xml\") || ct.startsWith(\"application/xml\")) {\n                        try {\n                            o = new StreamSource(dh.getInputStream());\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    } else {\n                        o = dh;\n                    }\n                    \n                    inObjects.put(mpi, o);\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) {\n                inObjects.put(mpi, null);\n            }\n        }\n    }","id":89142,"modified_method":"public void handleMessage(SoapMessage message) throws Fault {\n        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);\n        if (bop == null) {\n            return;\n        }\n        \n        if (bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n        \n        boolean client = isRequestor(message);\n        BindingMessageInfo bmi = client ? bop.getOutput() : bop.getInput();\n        \n        if (bmi == null) {\n            return;\n        }\n        \n        SoapBodyInfo sbi = bmi.getExtensor(SoapBodyInfo.class);\n        \n        if (sbi == null || sbi.getAttachments() == null || sbi.getAttachments().size() == 0) {\n            return;\n        }\n        \n        Set<Integer> foundAtts = new HashSet<Integer>();\n        MessageContentsList inObjects = MessageContentsList.getContentsList(message);\n\n        for (MessagePartInfo mpi : sbi.getAttachments()) {\n            String partName = mpi.getConcreteName().getLocalPart();\n            \n            String start = partName + \"=\";\n            boolean found = false;\n            \n            if (foundAtts.contains(mpi.getIndex())) {\n                continue;\n            }\n            foundAtts.add(mpi.getIndex());\n            \n            for (Attachment a : message.getAttachments()) {\n                if (a.getId().startsWith(start)) {\n                    DataHandler dh = a.getDataHandler();\n                    String ct = dh.getContentType();\n                    Object o = null;\n                    Class<?> typeClass = mpi.getTypeClass();\n                    if (DataHandler.class.isAssignableFrom(typeClass)) {\n                        o = dh;\n                    } else if (String.class.isAssignableFrom(typeClass)) {\n                        try {\n                            //o = IOUtils.readBytesFromStream(dh.getInputStream());\n                            o = dh.getContent();\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    } else if (byte[].class.isAssignableFrom(typeClass)) {\n                        try {\n                            o = IOUtils.readBytesFromStream(dh.getInputStream());\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    } else if (ct.startsWith(\"image/\")) {\n                        try {\n                            o = ImageIO.read(dh.getInputStream());\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    } else if (ct.startsWith(\"text/xml\") || ct.startsWith(\"application/xml\")) {\n                        try {\n                            o = new StreamSource(dh.getInputStream());\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    } else {\n                        o = dh;\n                    }\n                    \n                    inObjects.put(mpi, o);\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) {\n                inObjects.put(mpi, null);\n            }\n        }\n    }","commit_id":"dd2b395bf99a69fa7299a63f22dfa2b0423a82d4","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(SoapMessage message) throws Fault {\n        Exchange ex = message.getExchange();\n        BindingOperationInfo bop = ex.get(BindingOperationInfo.class);\n        if (bop == null) {\n            return;\n        }\n        \n        if (bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n        \n        boolean client = isRequestor(message);\n        BindingMessageInfo bmi = client ? bop.getInput() : bop.getOutput();\n        \n        if (bmi == null) {\n            return;\n        }\n        \n        SoapBodyInfo sbi = bmi.getExtensor(SoapBodyInfo.class);\n        \n        if (sbi == null || sbi.getAttachments() == null || sbi.getAttachments().size() == 0) {\n            Service s = ex.get(Service.class);\n            DataBinding db = s.getDataBinding();\n            if (db instanceof JAXBDataBinding\n                && hasSwaRef((JAXBDataBinding) db)) {\n                setupAttachmentOutput(message);\n            }\n            return;\n        }\n        \n        Collection<Attachment> atts = setupAttachmentOutput(message);\n\n        List<Object> outObjects = CastUtils.cast(message.getContent(List.class));\n        \n        for (MessagePartInfo mpi : sbi.getAttachments()) {\n            String partName = mpi.getConcreteName().getLocalPart();\n            String ct = (String) mpi.getProperty(Message.CONTENT_TYPE);\n            \n            String id = new StringBuilder().append(partName)\n                .append(\"=\")\n                .append(UUID.randomUUID())\n                .append(\"@apache.org\").toString();\n            \n            // this assumes things are in order...\n            int idx = mpi.getIndex();\n            Object o = outObjects.get(idx);\n            \n            if (o == null) {\n                continue;\n            }\n            outObjects.set(idx, null);\n            DataHandler dh = null;\n            \n            // This code could probably be refactored out somewhere...\n            if (o instanceof Source) {\n                dh = new DataHandler(createDataSource((Source)o, ct));\n            } else if (o instanceof Image) {\n                // TODO: make this streamable. This is one of my pet\n                // peeves in JAXB RI as well, so if you fix this, submit the \n                // code to the JAXB RI as well (see RuntimeBuiltinLeafInfoImpl)! - DD\n                ByteArrayOutputStream bos = new ByteArrayOutputStream(2048);\n                Iterator<ImageWriter> writers = ImageIO.getImageWritersByMIMEType(ct);\n                if (writers.hasNext()) {\n                    ImageWriter writer = writers.next();\n                    \n                    try {\n                        BufferedImage bimg = convertToBufferedImage((Image) o);\n                        ImageOutputStream out = ImageIO.createImageOutputStream(bos); \n                        writer.setOutput(out);\n                        writer.write(bimg);\n                        writer.dispose();\n                        out.flush();\n                        out.close();\n                        bos.close();\n                    } catch (IOException e) {\n                        throw new Fault(e);\n                    }\n                } else {\n                    throw new Fault(new org.apache.cxf.common.i18n.Message(\"ATTACHMENT_NOT_SUPPORTED\", \n                                     LOG, ct));                    \n                }\n                \n                dh = new DataHandler(new ByteArrayDataSource(bos.toByteArray(), ct));\n            } else if (o instanceof DataHandler) {\n                dh = (DataHandler) o;\n                ct = dh.getContentType();\n                \n                try {\n                    if (\"text/xml\".equals(ct)\n                        && dh.getContent() instanceof Source) {\n                        dh = new DataHandler(createDataSource((Source)dh.getContent(), ct));\n                    }\n                } catch (IOException e) {\n                    //ignore, use same dh\n                }\n            } else if (o instanceof byte[]) {\n                if (ct == null) {\n                    ct = \"application/octet-stream\";\n                }\n                dh = new DataHandler(new ByteArrayDataSource((byte[])o, ct));                \n            } else {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"ATTACHMENT_NOT_SUPPORTED\", \n                                                                       LOG, o.getClass()));\n            }\n            \n            AttachmentImpl att = new AttachmentImpl(id);\n            att.setDataHandler(dh);\n            att.setHeader(\"Content-Type\", ct);\n            atts.add(att);\n        }\n    }","id":89143,"modified_method":"public void handleMessage(SoapMessage message) throws Fault {\n        Exchange ex = message.getExchange();\n        BindingOperationInfo bop = ex.get(BindingOperationInfo.class);\n        if (bop == null) {\n            return;\n        }\n        \n        if (bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n        \n        boolean client = isRequestor(message);\n        BindingMessageInfo bmi = client ? bop.getInput() : bop.getOutput();\n        \n        if (bmi == null) {\n            return;\n        }\n        \n        SoapBodyInfo sbi = bmi.getExtensor(SoapBodyInfo.class);\n        \n        if (sbi == null || sbi.getAttachments() == null || sbi.getAttachments().size() == 0) {\n            Service s = ex.get(Service.class);\n            DataBinding db = s.getDataBinding();\n            if (db instanceof JAXBDataBinding\n                && hasSwaRef((JAXBDataBinding) db)) {\n                setupAttachmentOutput(message);\n            }\n            return;\n        }\n        processAttachments(message, sbi);\n    }","commit_id":"dd2b395bf99a69fa7299a63f22dfa2b0423a82d4","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Creates a map instance. If the type class is a <code>Map<\/code> or\n     * extends the <code>Map<\/code> interface a <code>HashMap<\/code> is\n     * created. Otherwise the map classs (i.e. LinkedHashMap) is instantiated\n     * using the default constructor.\n     *\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<Object, Object> instantiateMap() {\n        Map<Object, Object> map = null;\n\n        if (getTypeClass().equals(Map.class)) {\n            map = new HashMap<Object, Object>();\n        } else if (getTypeClass().equals(Hashtable.class)) {\n            map = new Hashtable<Object, Object>();\n        } else if (getTypeClass().isInterface()) {\n            map = new HashMap<Object, Object>();\n        } else {\n            try {\n                map = (Map<Object, Object>)getTypeClass().newInstance();\n            } catch (Exception e) {\n                throw new DatabindingException(\"Could not create map implementation: \"\n                                               + getTypeClass().getName(), e);\n            }\n        }\n\n        return map;\n    }","id":89144,"modified_method":"/**\n     * Creates a map instance. If the type class is a <code>Map<\/code> or\n     * extends the <code>Map<\/code> interface a <code>HashMap<\/code> is\n     * created. Otherwise the map classs (i.e. LinkedHashMap) is instantiated\n     * using the default constructor.\n     *\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<Object, Object> instantiateMap() {\n        Map<Object, Object> map = null;\n\n        Class<?> cls = getTypeClass();\n        if (cls.equals(Map.class)) {\n            map = new HashMap<Object, Object>();\n        } else if (cls.equals(Hashtable.class)) {\n            map = new Hashtable<Object, Object>();\n        } else if (cls.equals(ConcurrentMap.class)) {\n            map = new ConcurrentHashMap<Object, Object>();\n        } else if (cls.equals(ConcurrentNavigableMap.class)) {\n            map = new ConcurrentSkipListMap<Object, Object>();\n        } else if (cls.equals(SortedMap.class) || cls.equals(NavigableMap.class)) {\n            map = new TreeMap<Object, Object>();\n        } else if (cls.isInterface()) {\n            map = new HashMap<Object, Object>();\n        } else {\n            try {\n                map = (Map<Object, Object>)cls.newInstance();\n            } catch (Exception e) {\n                throw new DatabindingException(\"Could not create map implementation: \"\n                                               + getTypeClass().getName(), e);\n            }\n        }\n\n        return map;\n    }","commit_id":"be86e45a2a20de03e53382b85f99bb51f6cc322f","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Collection<Object> createCollection() {\n        Collection values = null;\n\n        if (getTypeClass().isAssignableFrom(List.class)) {\n            values = new ArrayList();\n        } else if (getTypeClass().isAssignableFrom(SortedSet.class)) {\n            values = new TreeSet();\n        } else if (getTypeClass().isAssignableFrom(Set.class)) {\n            values = new HashSet();\n        } else if (getTypeClass().isAssignableFrom(Vector.class)) {\n            values = new Vector();\n        } else if (getTypeClass().isInterface()) {\n            values = new ArrayList();\n        } else {\n            try {\n                values = (Collection<Object>)getTypeClass().newInstance();\n            } catch (Exception e) {\n                throw new DatabindingException(\"Could not create map implementation: \"\n                                               + getTypeClass().getName(), e);\n            }\n        }\n\n        return values;\n    }","id":89145,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Collection<Object> createCollection() {\n        Collection values = null;\n        \n        /*\n         * getTypeClass returns the type of the object. These ifs asked if the proposed\n         * type can be assigned to the object, not the other way around. Thus List before\n         * Vector and Set before SortedSet.\n         */\n        \n        Class userTypeClass = getTypeClass();\n        if (userTypeClass.isAssignableFrom(List.class)) {\n            values = new ArrayList();\n        } else if (userTypeClass.isAssignableFrom(LinkedList.class)) {\n            values = new LinkedList();\n        } else if (userTypeClass.isAssignableFrom(Set.class)) {\n            values = new HashSet();\n        } else if (userTypeClass.isAssignableFrom(SortedSet.class)) {\n            values = new TreeSet();\n        } else if (userTypeClass.isAssignableFrom(Vector.class)) {\n            values = new Vector();\n        } else if (userTypeClass.isAssignableFrom(Stack.class)) {\n            values = new Stack();\n        } else if (userTypeClass.isInterface()) {\n            values = new ArrayList();\n        } else {\n            try {\n                values = (Collection<Object>)userTypeClass.newInstance();\n            } catch (Exception e) {\n                throw new DatabindingException(\"Could not create map implementation: \"\n                                               + userTypeClass.getName(), e);\n            }\n        }\n\n        return values;\n    }","commit_id":"a0d787f98524ccda12f33503e3df4513481ee7f1","url":"https://github.com/apache/cxf"},{"original_method":"/** Build an adapted Frame from the given Frame. Useful for efficient bulk\n   *  scoring of a new dataset to an existing model.  Same adaption as above,\n   *  but expressed as a Frame instead of as an int[][]. The returned Frame\n   *  does not have a response column.\n   *  It returns <b>two elements array<\/b> containing an adapted frame and a frame which\n   *  contains only vectors which where adapted\n   *  (the purpose of the second frame is to delete all adapted vectors with deletion of the frame). */\n  public Frame[] adapt( Frame fr, boolean exact ) {\n    int map[][] = adapt(fr.names(),fr.domains(),exact);\n    int cmap[] =     map[_names.length-1];\n    Vec vecs[] = new Vec[_names.length-1];\n    int avCnt = 0;\n    for( int c=0; c<cmap.length; c++ ) if (map[c] != null) avCnt++;\n    Vec[]    avecs = new Vec[avCnt]; // list of adapted vectors\n    String[] anames = new String[avCnt]; // names of adapted vectors\n    avCnt = 0;\n    for( int c=0; c<cmap.length; c++ ) { // iterate over columns\n      int d = cmap[c];          // Data index\n      if( d == -1 ) throw H2O.unimpl(); // Swap in a new all-NA Vec\n      else if( map[c] == null ) {       // No or identity domain map?\n        vecs[c] = fr.vecs()[d];         // Just use the Vec as-is\n      } else {\n        // Domain mapping - creates a new vector\n        vecs[c] = avecs[avCnt] = remapVecDomain(map[c], fr.vecs()[d]);\n        anames[avCnt] = fr.names()[d];\n        avCnt++;\n      }\n    }\n    return new Frame[] { new Frame(Arrays.copyOf(_names,_names.length-1),vecs), new Frame(anames, avecs) };\n  }","id":89146,"modified_method":"/** Build an adapted Frame from the given Frame. Useful for efficient bulk\n   *  scoring of a new dataset to an existing model.  Same adaption as above,\n   *  but expressed as a Frame instead of as an int[][]. The returned Frame\n   *  does not have a response column.\n   *  It returns a <b>two element array<\/b> containing an adapted frame and a\n   *  frame which contains only vectors which where adapted (the purpose of the\n   *  second frame is to delete all adapted vectors with deletion of the\n   *  frame). */\n  public Frame[] adapt( Frame fr, boolean exact ) {\n    String frnames[] = fr.names();\n    Vec frvecs[] = fr.vecs();\n    int map[][] = adapt(frnames,fr.domains(),exact);\n    int cmap[] =     map[_names.length-1];\n    Vec vecs[] = new Vec[_names.length-1];\n    int avCnt = 0;\n    for( int c=0; c<cmap.length; c++ ) if (map[c] != null) avCnt++;\n    Vec[]    avecs = new Vec[avCnt]; // list of adapted vectors\n    String[] anames = new String[avCnt]; // names of adapted vectors\n    avCnt = 0;\n    for( int c=0; c<cmap.length; c++ ) { // iterate over columns\n      int d = cmap[c];          // Data index\n      if( d == -1 ) throw H2O.unimpl(); // Swap in a new all-NA Vec\n      else if( map[c] == null ) {       // No or identity domain map?\n        vecs[c] = frvecs[d];            // Just use the Vec as-is\n      } else {\n        // Domain mapping - creates a new vector\n        vecs[c] = avecs[avCnt] = frvecs[d].makeTransf(map[c]);\n        anames[avCnt] = frnames[d];\n        avCnt++;\n      }\n    }\n    return new Frame[] { new Frame(Arrays.copyOf(_names,_names.length-1),vecs), new Frame(anames, avecs) };\n  }","commit_id":"074fca6bf6d7f3f01ba3f77697601e64941ebdfe","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override protected void compute2() {\n\n      KMeansModel model = null;\n      try {\n        _parms.read_lock_frames(KMeans.this); // Fetch & read-lock input frames\n        init(true);\n\n        // The model to be built\n        model = new KMeansModel(dest(), _parms, new KMeansModel.KMeansOutput(KMeans.this));\n        model.delete_and_lock(_key);\n\n        // means are used to impute NAs\n        model._output._ncats = _ncats;\n        Vec vecs[] = _train.vecs();\n        final int N = vecs.length; // Feature count\n        double[] means = new double[N];\n        for( int i = 0; i < N; i++ )\n          means[i] = vecs[i].mean();\n        // mults & means for standardization\n        double[] mults = null;\n        if( _parms._standardize ) {\n          mults = new double[N];\n          for( int i = 0; i < N; i++ ) {\n            double sigma = vecs[i].sigma();\n            mults[i] = standardize(sigma) ? 1.0 / sigma : 1.0;\n          }\n        }\n\n        // Initialize clusters\n        Random rand = water.util.RandomUtils.getRNG(_parms._seed - 1);\n        double clusters[][];    // Standardized cluster centers\n        if( _parms._init == Initialization.None ) {\n          // Initialize all clusters to random rows\n          clusters = model._output._clusters = new double[_parms._k][_train.numCols()];\n          for( double[] cluster : clusters )\n            randomRow(vecs, rand, cluster, means, mults);\n        } else {\n          clusters = new double[1][vecs.length];\n          // Initialize first cluster to random row\n          randomRow(vecs, rand, clusters[0], means, mults);\n\n          while( model._output._iters < 5 ) {\n            // Sum squares distances to clusters\n            SumSqr sqr = new SumSqr(clusters,means,mults,_ncats).doAll(vecs);\n\n            // Sample with probability inverse to square distance\n            Sampler sampler = new Sampler(clusters, means, mults, _ncats, sqr._sqr, _parms._k * 3, _parms._seed).doAll(vecs);\n            clusters = ArrayUtils.append(clusters,sampler._sampled);\n\n            // Fill in sample clusters into the model\n            if( !isRunning() ) return; // Stopped/cancelled\n            model._output._clusters = destandardize(clusters, _ncats, means, mults);\n            model._output._avgwithinss = sqr._sqr/_train.numRows();\n\n            model._output._iters++;     // One iteration done\n\n            // This doesn't count towards model building (we didn't account these iterations as work to be done during construction)\n            // update(1);          // One unit of work\n\n            model.update(_key); // Early version of model is visible\n          }\n          // Recluster down to K standardized clusters\n          clusters = recluster(clusters, rand);\n        }\n        model._output._iters = 0;     // Reset iteration count\n\n        // ---\n        // Run the main KMeans Clustering loop\n        // Stop after enough iterations\n        LOOP:\n        for( ; model._output._iters < _parms._max_iters; model._output._iters++ ) {\n          if( !isRunning() ) return; // Stopped/cancelled\n          Lloyds task = new Lloyds(clusters,means,mults,_ncats, _parms._k).doAll(vecs);\n          // Pick the max categorical level for clusters' center\n          max_cats(task._cMeans,task._cats);\n\n          // Handle the case where some clusters go dry.  Rescue only 1 cluster\n          // per iteration ('cause we only tracked the 1 worst row)\n          boolean badrow=false;\n          for( int clu=0; clu<_parms._k; clu++ ) {\n            if (task._rows[clu] == 0) {\n              // If we see 2 or more bad rows, just re-run Lloyds to get the\n              // next-worst row.  We don't count this as an iteration, because\n              // we're not really adjusting the centers, we're trying to get\n              // some centers *at-all*.\n              if (badrow) {\n                Log.warn(\"KMeans: Re-running Lloyds to re-init another cluster\");\n                model._output._iters--; // Do not count against iterations\n                if (_reinit_attempts++ < _parms._k) {\n                  continue LOOP;  // Rerun Lloyds, and assign points to centroids\n                } else {\n                  _reinit_attempts = 0;\n                  break; //give up and accept empty cluster\n                }\n              }\n              long row = task._worst_row;\n              Log.warn(\"KMeans: Re-initializing cluster \" + clu + \" to row \" + row);\n              data(clusters[clu] = task._cMeans[clu], vecs, row, means, mults);\n              task._rows[clu] = 1;\n              badrow = true;\n            }\n          }\n\n          // Fill in the model; destandardized centers\n          model._output._names = _train.names();\n          model._output._clusters = destandardize(task._cMeans, _ncats, means, mults);\n          model._output._rows = task._rows;\n          model._output._withinmse = task._cSqr;\n          double ssq = 0;       // sum squared error\n          for( int i=0; i<_parms._k; i++ ) {\n            ssq += model._output._withinmse[i]; // sum squared error all clusters\n            model._output._withinmse[i] /= task._rows[i]; // mse within-cluster\n          }\n          model._output._avgwithinss = ssq/_train.numRows(); // mse total\n\n          // Sum-of-square distance from grand mean (since we auto-standardize data, this is just the origin)\n          if(_parms._k == 1)\n            model._output._avgss = model._output._avgwithinss;\n          else {\n            SumSqr totss = new SumSqr(new double[1][means.length],means,mults,_ncats).doAll(vecs);\n            model._output._avgss = totss._sqr/_train.numRows(); // mse with respect to grand mean\n          }\n          model._output._avgbetweenss = model._output._avgss - model._output._avgwithinss;  // mse between-cluster\n          model.update(_key); // Update model in K/V store\n          update(1);          // One unit of work\n\n          // Compute change in clusters centers\n          double sum=0;\n          for( int clu=0; clu<_parms._k; clu++ )\n            sum += distance(clusters[clu],task._cMeans[clu],_ncats);\n          sum /= N;             // Average change per feature\n          Log.info(\"KMeans: Change in cluster centers=\"+sum);\n          if( sum < 1e-6 ) break;  // Model appears to be stable\n          clusters = task._cMeans; // Update cluster centers\n\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"KMeans: iter: \").append(model._output._iters).append(\", MSE=\").append(model._output._avgwithinss);\n          for( int i=0; i<_parms._k; i++ )\n            sb.append(\", \").append(task._cSqr[i]).append(\"/\").append(task._rows[i]);\n          Log.info(sb);\n        }\n\n      } catch( Throwable t ) {\n        t.printStackTrace();\n        cancel2(t);\n        throw t;\n      } finally {\n        if( model != null ) model.unlock(_key);\n        _parms.read_unlock_frames(KMeans.this);\n        done();                 // Job done!\n      }\n      tryComplete();\n    }","id":89147,"modified_method":"@Override protected void compute2() {\n\n      KMeansModel model = null;\n      try {\n        _parms.read_lock_frames(KMeans.this); // Fetch & read-lock input frames\n        init(true);\n\n        // The model to be built\n        model = new KMeansModel(dest(), _parms, new KMeansModel.KMeansOutput(KMeans.this));\n        model.delete_and_lock(_key);\n\n        // means are used to impute NAs\n        model._output._ncats = _ncats;\n        Vec vecs[] = _train.vecs();\n        final int N = vecs.length; // Feature count\n        double[] means = new double[N];\n        for( int i = 0; i < N; i++ )\n          means[i] = vecs[i].mean();\n        // mults & means for standardization\n        double[] mults = null;\n        if( _parms._standardize ) {\n          mults = new double[N];\n          for( int i = 0; i < N; i++ ) {\n            double sigma = vecs[i].sigma();\n            mults[i] = standardize(sigma) ? 1.0 / sigma : 1.0;\n          }\n        }\n\n        // Initialize clusters\n        Random rand = water.util.RandomUtils.getRNG(_parms._seed - 1);\n        double clusters[][];    // Standardized cluster centers\n        if( _parms._init == Initialization.None ) {\n          // Initialize all clusters to random rows\n          clusters = model._output._clusters = new double[_parms._k][_train.numCols()];\n          for( double[] cluster : clusters )\n            randomRow(vecs, rand, cluster, means, mults);\n        } else {\n          clusters = new double[1][vecs.length];\n          // Initialize first cluster to random row\n          randomRow(vecs, rand, clusters[0], means, mults);\n\n          while( model._output._iters < 5 ) {\n            // Sum squares distances to clusters\n            SumSqr sqr = new SumSqr(clusters,means,mults,_ncats).doAll(vecs);\n\n            // Sample with probability inverse to square distance\n            Sampler sampler = new Sampler(clusters, means, mults, _ncats, sqr._sqr, _parms._k * 3, _parms._seed).doAll(vecs);\n            clusters = ArrayUtils.append(clusters,sampler._sampled);\n\n            // Fill in sample clusters into the model\n            if( !isRunning() ) return; // Stopped/cancelled\n            model._output._clusters = destandardize(clusters, _ncats, means, mults);\n            model._output._avgwithinss = sqr._sqr/_train.numRows();\n\n            model._output._iters++;     // One iteration done\n\n            // This doesn't count towards model building (we didn't account these iterations as work to be done during construction)\n            // update(1);          // One unit of work\n\n            model.update(_key); // Early version of model is visible\n          }\n          // Recluster down to K standardized clusters\n          clusters = recluster(clusters, rand);\n        }\n        model._output._iters = 0;     // Reset iteration count\n\n        // ---\n        // Run the main KMeans Clustering loop\n        // Stop after enough iterations\n        LOOP:\n        for( ; model._output._iters < _parms._max_iters; model._output._iters++ ) {\n          if( !isRunning() ) return; // Stopped/cancelled\n          Lloyds task = new Lloyds(clusters,means,mults,_ncats, _parms._k).doAll(vecs);\n          // Pick the max categorical level for clusters' center\n          max_cats(task._cMeans,task._cats);\n\n          // Handle the case where some clusters go dry.  Rescue only 1 cluster\n          // per iteration ('cause we only tracked the 1 worst row)\n          boolean badrow=false;\n          for( int clu=0; clu<_parms._k; clu++ ) {\n            if (task._rows[clu] == 0) {\n              // If we see 2 or more bad rows, just re-run Lloyds to get the\n              // next-worst row.  We don't count this as an iteration, because\n              // we're not really adjusting the centers, we're trying to get\n              // some centers *at-all*.\n              if (badrow) {\n                Log.warn(\"KMeans: Re-running Lloyds to re-init another cluster\");\n                model._output._iters--; // Do not count against iterations\n                if (_reinit_attempts++ < _parms._k) {\n                  continue LOOP;  // Rerun Lloyds, and assign points to centroids\n                } else {\n                  _reinit_attempts = 0;\n                  break; //give up and accept empty cluster\n                }\n              }\n              long row = task._worst_row;\n              Log.warn(\"KMeans: Re-initializing cluster \" + clu + \" to row \" + row);\n              data(clusters[clu] = task._cMeans[clu], vecs, row, means, mults);\n              task._rows[clu] = 1;\n              badrow = true;\n            }\n          }\n\n          // Fill in the model; destandardized centers\n          model._output._clusters = destandardize(task._cMeans, _ncats, means, mults);\n          String[] rowHeaders = new String[_parms._k];\n          for(int i = 0; i < _parms._k; i++)\n            rowHeaders[i] = String.valueOf(i+1);\n          model._output._centers = new TwoDimTable(\"Cluster centers:\", _train.names(), null, rowHeaders,\n                  new String[_parms._k][], model._output._clusters);\n          model._output._rows = task._rows;\n          model._output._withinmse = task._cSqr;\n          double ssq = 0;       // sum squared error\n          for( int i=0; i<_parms._k; i++ ) {\n            ssq += model._output._withinmse[i]; // sum squared error all clusters\n            model._output._withinmse[i] /= task._rows[i]; // mse within-cluster\n          }\n          model._output._avgwithinss = ssq/_train.numRows(); // mse total\n\n          // Sum-of-square distance from grand mean (since we auto-standardize the data, this is just the origin)\n          if(_parms._k == 1)\n            model._output._avgss = model._output._avgwithinss;\n          else {\n            SumSqr totss = new SumSqr(new double[1][means.length],means,mults,_ncats).doAll(vecs);\n            model._output._avgss = totss._sqr/_train.numRows(); // mse with respect to grand mean\n          }\n          model._output._avgbetweenss = model._output._avgss - model._output._avgwithinss;  // mse between-cluster\n          model.update(_key); // Update model in K/V store\n          update(1);          // One unit of work\n\n          // Compute change in clusters centers\n          double sum=0;\n          for( int clu=0; clu<_parms._k; clu++ )\n            sum += distance(clusters[clu],task._cMeans[clu],_ncats);\n          sum /= N;             // Average change per feature\n          Log.info(\"KMeans: Change in cluster centers=\"+sum);\n          if( sum < 1e-6 ) break;  // Model appears to be stable\n          clusters = task._cMeans; // Update cluster centers\n\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"KMeans: iter: \").append(model._output._iters).append(\", MSE=\").append(model._output._avgwithinss);\n          for( int i=0; i<_parms._k; i++ )\n            sb.append(\", \").append(task._cSqr[i]).append(\"/\").append(task._rows[i]);\n          Log.info(sb);\n        }\n\n      } catch( Throwable t ) {\n        t.printStackTrace();\n        cancel2(t);\n        throw t;\n      } finally {\n        if( model != null ) model.unlock(_key);\n        _parms.read_unlock_frames(KMeans.this);\n        done();                 // Job done!\n      }\n      tryComplete();\n    }","commit_id":"cf0e2bf8bddafb42d07f1c6f8831d1e40bebe473","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            String childName = operation.require(CHILD_TYPE).asString();\n\n            ModelNode subModel = context.getSubModel().clone();\n            if (!subModel.isDefined()) {\n                final ModelNode result = new ModelNode();\n                result.setEmptyList();\n                resultHandler.handleResultFragment(new String[0], result);\n                resultHandler.handleResultComplete();\n            } else {\n                final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final Set<String> childNames = context.getRegistry().getChildNames(address);\n                if (!childNames.contains(childName)) {\n                    throw new OperationFailedException(new ModelNode().set(\"No known child called \" + childName)); //TODO i18n\n                } else {\n                    final AtomicBoolean ok = new AtomicBoolean(true);\n                    final ModelNode result = new ModelNode();\n                    subModel = subModel.get(childName);\n                    if (!subModel.isDefined()) {\n                        result.setEmptyList();\n                    } else {\n\n                        for (final String key : subModel.keys()) {\n                            if (!ok.get()) {\n                                break;\n                            }\n                            final PathAddress childAddress = address.append(PathElement.pathElement(childName, key));\n\n                            final ModelNode readOp = operation.clone();\n                            readOp.get(OP_ADDR).set(childAddress.toModelNode());\n\n                            if(operation.hasDefined(INCLUDE_RUNTIME))\n                                readOp.get(INCLUDE_RUNTIME).set(operation.get(INCLUDE_RUNTIME).asBoolean());\n\n                            final ModelNode readResult = readModel(context, readOp, new ResultHandler() {\n                                public void handleResultFragment(String[] location, ModelNode result) {\n                                    // TODO\n                                }\n                                public void handleResultComplete() {\n                                    // TODO\n                                }\n                                public void handleFailed(ModelNode failureDescription) {\n                                    ok.set(false);\n                                    resultHandler.handleFailed(failureDescription);\n                                }\n                                public void handleCancellation() {\n                                    ok.set(false);\n                                    resultHandler.handleCancellation();\n                                }\n                            }, childAddress);\n                            result.add(key, readResult);\n                        }\n                    }\n\n                    if (ok.get()) {\n                        resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n                        resultHandler.handleResultComplete();\n                    }\n                }\n            }\n\n            return new BasicOperationResult();\n        }","id":89148,"modified_method":"@Override\n        public void execute(NewOperationContext context, ModelNode operation) throws OperationFailedException {\n            final String childName = operation.require(CHILD_TYPE).asString();\n\n            ModelNode subModel = context.readModel(PathAddress.EMPTY_ADDRESS);\n            if (!subModel.isDefined()) {\n                context.getResult().setEmptyList();\n            } else {\n                final Set<String> childNames = context.getModelNodeRegistration().getChildNames(PathAddress.EMPTY_ADDRESS);\n                if (!childNames.contains(childName)) {\n                    throw new OperationFailedException(new ModelNode().set(\"No known child called \" + childName)); //TODO i18n\n                } else {\n                    final ModelNode result = context.getResult();\n                    subModel = subModel.get(childName);\n                    if (!subModel.isDefined()) {\n                        result.setEmptyList();\n                    } else {\n                        for (final String key : subModel.keys()) {\n                            final PathAddress childAddress = PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(childName, key));\n\n                            final ModelNode readOp = new ModelNode();\n                            readOp.get(OP).set(READ_RESOURCE_OPERATION);\n                            readOp.get(OP_ADDR).set(childAddress.toModelNode());\n\n                            if(operation.hasDefined(INCLUDE_RUNTIME)) {\n                                readOp.get(INCLUDE_RUNTIME).set(operation.get(INCLUDE_RUNTIME).asBoolean());\n                            }\n                            final NewStepHandler handler = context.getModelNodeRegistration().getOperationHandler(childAddress, READ_RESOURCE_OPERATION);\n                            if(handler == null) {\n                                throw new OperationFailedException(new ModelNode().set(\"no operation handler\"));\n                            }\n                            context.addStep(result.get(key), readOp, handler, NewOperationContext.Stage.MODEL);\n                        }\n                    }\n                }\n            }\n            context.completeStep();\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n            OperationResult handlerResult = new BasicOperationResult();\n\n            final String attributeName = operation.require(NAME).asString();\n            final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n            final AttributeAccess attributeAccess = context.getRegistry().getAttributeAccess(address, attributeName);\n            if (attributeAccess == null) {\n                final Set<String> children = context.getRegistry().getChildNames(address);\n                if(children.contains(attributeName)) {\n                    throw new OperationFailedException(new ModelNode().set(String.format(\"'%s' is a registered child of resource (%s)\", attributeName, address))); // TODO i18n\n                } else if(context.getSubModel().has(attributeName)) {\n                    final ModelNode result = context.getSubModel().get(attributeName).clone();\n                    resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n                    resultHandler.handleResultComplete();\n                } else {\n                    throw new OperationFailedException(new ModelNode().set(\"No known attribute called \" + attributeName)); // TODO i18n\n                }\n            } else if (attributeAccess.getReadHandler() == null) {\n                final ModelNode result = context.getSubModel().get(attributeName).clone();\n                resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n                resultHandler.handleResultComplete();\n            } else {\n                // FIXME bogus cast just to compile\n                handlerResult = ((OperationHandler) attributeAccess.getReadHandler()).execute(context, operation, resultHandler);\n            }\n\n            return handlerResult;\n        }","id":89149,"modified_method":"@Override\n        public void execute(NewOperationContext context, ModelNode operation) throws OperationFailedException {\n\n            final String attributeName = operation.require(NAME).asString();\n            final ModelNode subModel = context.readModel(PathAddress.EMPTY_ADDRESS);\n            final AttributeAccess attributeAccess = context.getModelNodeRegistration().getAttributeAccess(PathAddress.EMPTY_ADDRESS, attributeName);\n            if (attributeAccess == null) {\n                final Set<String> children = context.getModelNodeRegistration().getChildNames(PathAddress.EMPTY_ADDRESS);\n                if(children.contains(attributeName)) {\n                    throw new OperationFailedException(new ModelNode().set(String.format(\"'%s' is a registered child of resource (%s)\", attributeName, operation.get(OP_ADDR)))); // TODO i18n\n                } else if(subModel.has(attributeName)) {\n                    final ModelNode result = subModel.get(attributeName);\n                    context.getResult().set(result);\n                    context.completeStep();\n                } else {\n                    throw new OperationFailedException(new ModelNode().set(\"No known attribute called \" + attributeName)); // TODO i18n\n                }\n            } else if (attributeAccess.getReadHandler() == null) {\n                final ModelNode result = subModel.get(attributeName);\n                context.getResult().set(result);\n                context.completeStep();\n            } else {\n                attributeAccess.getReadHandler().execute(context, operation);\n            }\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(NewOperationContext context, ModelNode operation) throws OperationFailedException {\n            final String attributeName = operation.require(NAME).asString();\n            final AttributeAccess attributeAccess = context.getModelNodeRegistration().getAttributeAccess(PathAddress.pathAddress(operation.get(OP_ADDR)), attributeName);\n            if (attributeAccess == null) {\n                throw new OperationFailedException(new ModelNode().set(\"No known attribute called \" + attributeName)); // TODO i18n\n            } else if (attributeAccess.getAccessType() != AccessType.READ_WRITE) {\n                throw new OperationFailedException(new ModelNode().set(\"Attribute \" + attributeName + \" is not writeable\")); // TODO i18n\n            } else {\n                // FIXME bogus cast just to compile\n                ((NewStepHandler) attributeAccess.getWriteHandler()).execute(context, operation);\n            }\n            context.completeStep();\n        }","id":89150,"modified_method":"public void execute(NewOperationContext context, ModelNode operation) throws OperationFailedException {\n            final String attributeName = operation.require(NAME).asString();\n            final AttributeAccess attributeAccess = context.getModelNodeRegistration().getAttributeAccess(PathAddress.EMPTY_ADDRESS, attributeName);\n            if (attributeAccess == null) {\n                throw new OperationFailedException(new ModelNode().set(\"No known attribute called \" + attributeName)); // TODO i18n\n            } else if (attributeAccess.getAccessType() != AccessType.READ_WRITE) {\n                throw new OperationFailedException(new ModelNode().set(\"Attribute \" + attributeName + \" is not writeable\")); // TODO i18n\n            } else {\n                attributeAccess.getReadHandler().execute(context, operation);\n            }\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            String childName = operation.require(CHILD_TYPE).asString();\n\n            ModelNode subModel = context.getSubModel().clone();\n            if (!subModel.isDefined()) {\n                final ModelNode result = new ModelNode();\n                result.setEmptyList();\n                resultHandler.handleResultFragment(new String[0], result);\n            } else {\n                final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final Set<String> childNames = context.getRegistry().getChildNames(address);\n                if (!childNames.contains(childName)) {\n                    throw new OperationFailedException(new ModelNode().set(\"No known child called \" + childName)); //TODO i18n\n                } else {\n                    final ModelNode result = new ModelNode();\n                    subModel = subModel.get(childName);\n                    if (!subModel.isDefined()) {\n                        result.setEmptyList();\n                    } else {\n                        for (final String key : subModel.keys()) {\n                            final ModelNode node = new ModelNode();\n                            node.set(key);\n                            result.add(node);\n                        }\n                    }\n                    resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n                }\n            }\n\n            resultHandler.handleResultComplete();\n            return new BasicOperationResult();\n        }","id":89151,"modified_method":"@Override\n        public void execute(NewOperationContext context, ModelNode operation) throws OperationFailedException {\n\n            final String childName = operation.require(CHILD_TYPE).asString();\n            ModelNode subModel = context.readModel(PathAddress.EMPTY_ADDRESS);\n\n            if (!subModel.isDefined()) {\n                final ModelNode result = new ModelNode();\n                context.getResult().setEmptyList();\n            } else {\n                final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final Set<String> childNames = context.getModelNodeRegistration().getChildNames(PathAddress.EMPTY_ADDRESS);\n                if (!childNames.contains(childName)) {\n                    throw new OperationFailedException(new ModelNode().set(\"No known child called \" + childName)); //TODO i18n\n                } else {\n                    final ModelNode result = new ModelNode();\n                    subModel = subModel.get(childName);\n                    if (!subModel.isDefined()) {\n                        result.setEmptyList();\n                    } else {\n                        for (final String key : subModel.keys()) {\n                            final ModelNode node = new ModelNode();\n                            node.set(key);\n                            result.add(node);\n                        }\n                    }\n                    context.getResult().set(result);\n                }\n            }\n            context.completeStep();\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected ModelNode readModel(final OperationContext context, final ModelNode readOperation,\n                final ResultHandler resultHandler, final PathAddress address) throws OperationFailedException {\n            final ModelNodeRegistration registry = context.getRegistry();\n            final ModelNode model = context.getSubModel(address);\n            final ModelNode result;\n                if (readOperation.get(RECURSIVE).asBoolean(false)) {\n                    // FIXME security checks JBAS-8842\n                    result = model.clone();\n                    if(readOperation.get(PROXIES).asBoolean(true)) {\n                        addProxyNodes(context, address, readOperation, result, registry);\n                    }\n                } else {\n                    result = new ModelNode();\n\n                    final Set<String> childNames = registry.getChildNames(address);\n\n                    final ModelNode subModel = model.clone();\n                    for (final String key : subModel.keys()) {\n                        final ModelNode child = subModel.get(key);\n                        if (childNames.contains(key)) {\n                            //Prune the value for this child\n                            if (subModel.get(key).isDefined()) {\n                                for (final String childKey : child.keys()) {\n                                    subModel.get(key, childKey).set(new ModelNode());\n                                }\n                            }\n\n                            result.get(key).set(child);\n                        } else {\n                            result.get(key).set(child);\n                        }\n                    }\n                    // Handle attributes\n                    final boolean queryRuntime = readOperation.get(INCLUDE_RUNTIME).asBoolean(false);\n                    final Set<String> attributeNames = registry.getAttributeNames(address);\n                    for(final String attributeName : attributeNames) {\n                        final AttributeAccess access = registry.getAttributeAccess(address, attributeName);\n                        if(access == null) {\n                            continue;\n                        } else {\n                            final AttributeAccess.Storage storage = access.getStorageType();\n                            if(! queryRuntime && storage != AttributeAccess.Storage.CONFIGURATION) {\n                                continue;\n                            }\n                            final AccessType type = access.getAccessType();\n                            // FIXME incorrect cast just to compile\n                            final OperationHandler handler = (OperationHandler) access.getReadHandler();\n                            if(handler != null) {\n                                // Create the attribute operation\n                                final ModelNode attributeOperation = readOperation.clone();\n                                attributeOperation.get(NAME).set(attributeName);\n                                // TODO this assumes the ResultHandler is invoked synchronously\n                                handler.execute(context, attributeOperation, new ResultHandler() {\n                                    @Override\n                                    public void handleResultFragment(final String[] location, final ModelNode attributeResult) {\n                                        result.get(attributeName).set(attributeResult);\n                                    }\n                                    @Override\n                                    public void handleResultComplete() {\n                                        // TODO\n                                    }\n                                    @Override\n                                    public void handleFailed(ModelNode failureDescription) {\n                                        if(type != AccessType.METRIC) {\n                                            resultHandler.handleFailed(failureDescription);\n                                        }\n                                    }\n                                    @Override\n                                    public void handleCancellation() {\n                                        resultHandler.handleCancellation();\n                                    }\n                                });\n                            }\n                        }\n                    }\n                    handleNonRecursiveProxyEntries(context, address, readOperation, result, registry);\n                }\n            return result;\n        }","id":89152,"modified_method":"protected ModelNode readModel(final NewOperationContext context, final ModelNode readOperation, final PathAddress address) throws OperationFailedException {\n            final ModelNodeRegistration registry = context.getModelNodeRegistration();\n            final ModelNode model = context.readModel(address);\n            final ModelNode result;\n                if (readOperation.get(RECURSIVE).asBoolean(false)) {\n                    // FIXME security checks JBAS-8842\n                    result = model.clone();\n                } else {\n                    result = new ModelNode();\n\n                    final Set<String> childNames = registry != null ? registry.getChildNames(address) : Collections.<String>emptySet();\n\n                    final ModelNode subModel = model.clone();\n                    for (final String key : subModel.keys()) {\n                        final ModelNode child = subModel.get(key);\n                        if (childNames.contains(key)) {\n                            //Prune the value for this child\n                            if (subModel.get(key).isDefined()) {\n                                for (final String childKey : child.keys()) {\n                                    subModel.get(key, childKey).set(new ModelNode());\n                                }\n                            }\n\n                            result.get(key).set(child);\n                        } else {\n                            result.get(key).set(child);\n                        }\n                    }\n                    // Handle attributes\n                    final boolean queryRuntime = readOperation.get(INCLUDE_RUNTIME).asBoolean(false);\n                    final Set<String> attributeNames = registry != null ? registry.getAttributeNames(address) : Collections.<String>emptySet();\n                    for(final String attributeName : attributeNames) {\n                        final AttributeAccess access = registry.getAttributeAccess(address, attributeName);\n                        if(access == null) {\n                            continue;\n                        } else {\n                            final AttributeAccess.Storage storage = access.getStorageType();\n                            if(! queryRuntime && storage != AttributeAccess.Storage.CONFIGURATION) {\n                                continue;\n                            }\n                            final AccessType type = access.getAccessType();\n                            // FIXME incorrect cast just to compile\n                            final NewStepHandler handler = access.getReadHandler();\n                            if(handler != null) {\n                                // Create the attribute operation\n                                final ModelNode attributeOperation = readOperation.clone();\n                                attributeOperation.get(NAME).set(attributeName);\n                                context.addStep(result.get(attributeName), attributeOperation, handler, NewOperationContext.Stage.MODEL);\n                            }\n                        }\n                    }\n                }\n            return result;\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n            final ModelNode result = readModel(context, operation, resultHandler, address);\n            resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n            resultHandler.handleResultComplete();\n            return new BasicOperationResult();\n        }","id":89153,"modified_method":"@Override\n        public void execute(NewOperationContext context, ModelNode operation) throws OperationFailedException {\n\n            final ModelNode result = readModel(context, operation, PathAddress.EMPTY_ADDRESS);\n            context.getResult().set(result);\n            context.completeStep();\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void execute(NewOperationContext context, ModelNode operation) {\n            ModelNode model = new ModelNode();\n\n            //Atttributes\n            model.get(\"attr1\").set(1);\n            model.get(\"attr2\").set(2);\n\n            context.writeModel(PathAddress.EMPTY_ADDRESS, model);\n\n            context.completeStep();\n        }","id":89154,"modified_method":"@Override\n        public void execute(NewOperationContext context, ModelNode operation) {\n            ModelNode model = new ModelNode();\n\n            //Atttributes\n            model.get(\"attr1\").set(1);\n            model.get(\"attr2\").set(2);\n\n            model.get(\"child\", \"one\", \"attribute1\").set(1);\n            model.get(\"child\", \"two\", \"attribute2\").set(2);\n\n            context.writeModel(PathAddress.EMPTY_ADDRESS, model);\n\n            context.completeStep();\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void start(StartContext context) throws StartException {\n            ServiceTarget target = serviceContainer.subTarget();\n            ServiceController<?> serviceController = context.getController();\n            ModelNodeRegistration rootRegistration = ModelNodeRegistration.Factory.create(DESC_PROVIDER);\n\n            rootRegistration.registerOperationHandler(\"setup\", new SetupHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"composite\", new NewCompositeOperationHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"good\", new ModelStageGoodHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"bad\", new ModelStageFailsHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"evil\", new ModelStageThrowsExceptionHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"handleFailed\", new RuntimeStageFailsHandler(state), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"runtimeException\", new RuntimeStageThrowsExceptionHandler(state), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"operationFailedException\", new RuntimeStageThrowsOFEHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"good-service\", new GoodServiceHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"bad-service\", new BadServiceHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"missing-service\", new MissingServiceHandler(), DESC_PROVIDER, false);\n\n            value = new NewModelControllerImpl(serviceContainer, target, rootRegistration, new ContainerStateMonitor(serviceContainer, serviceController),\n                    new NullConfigurationPersister(), NewOperationContext.Type.SERVER, null);\n            latch.countDown();\n        }","id":89155,"modified_method":"@Override\n        public void start(StartContext context) throws StartException {\n            ServiceTarget target = serviceContainer.subTarget();\n            ServiceController<?> serviceController = context.getController();\n            ModelNodeRegistration rootRegistration = ModelNodeRegistration.Factory.create(DESC_PROVIDER);\n\n            rootRegistration.registerOperationHandler(\"setup\", new SetupHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"composite\", new NewCompositeOperationHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"good\", new ModelStageGoodHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"bad\", new ModelStageFailsHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"evil\", new ModelStageThrowsExceptionHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"handleFailed\", new RuntimeStageFailsHandler(state), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"runtimeException\", new RuntimeStageThrowsExceptionHandler(state), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"operationFailedException\", new RuntimeStageThrowsOFEHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"good-service\", new GoodServiceHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"bad-service\", new BadServiceHandler(), DESC_PROVIDER, false);\n            rootRegistration.registerOperationHandler(\"missing-service\", new MissingServiceHandler(), DESC_PROVIDER, false);\n\n            rootRegistration.registerOperationHandler(READ_RESOURCE_OPERATION, GlobalOperationHandlers.READ_RESOURCE, CommonProviders.READ_RESOURCE_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_ATTRIBUTE_OPERATION, GlobalOperationHandlers.READ_ATTRIBUTE, CommonProviders.READ_ATTRIBUTE_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_RESOURCE_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_RESOURCE_DESCRIPTION, CommonProviders.READ_RESOURCE_DESCRIPTION_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_CHILDREN_NAMES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_NAMES, CommonProviders.READ_CHILDREN_NAMES_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_CHILDREN_TYPES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_TYPES, CommonProviders.READ_CHILDREN_TYPES_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_CHILDREN_RESOURCES_OPERATION, GlobalOperationHandlers.READ_CHILDREN_RESOURCES, CommonProviders.READ_CHILDREN_RESOURCES_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_OPERATION_NAMES_OPERATION, GlobalOperationHandlers.READ_OPERATION_NAMES, CommonProviders.READ_OPERATION_NAMES_PROVIDER, true);\n            rootRegistration.registerOperationHandler(READ_OPERATION_DESCRIPTION_OPERATION, GlobalOperationHandlers.READ_OPERATION_DESCRIPTION, CommonProviders.READ_OPERATION_PROVIDER, true);\n            rootRegistration.registerOperationHandler(WRITE_ATTRIBUTE_OPERATION, GlobalOperationHandlers.WRITE_ATTRIBUTE, CommonProviders.WRITE_ATTRIBUTE_PROVIDER, true);\n\n            rootRegistration.registerSubModel(PathElement.pathElement(\"child\"), DESC_PROVIDER);\n\n            value = new NewModelControllerImpl(serviceContainer, target, rootRegistration, new ContainerStateMonitor(serviceContainer, serviceController),\n                    new NullConfigurationPersister(), NewOperationContext.Type.SERVER, null);\n            latch.countDown();\n        }","commit_id":"0c91eaf468c4b12df584faa9861cdf7443e8ec0b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tprotected void cleanUp() {\n\t\t_className = null;\n\t\t_classPK = 0;\n\t\t_editable = false;\n\t\t_label = false;\n\t}","id":89156,"modified_method":"@Override\n\tprotected void cleanUp() {\n\t\t_className = null;\n\t\t_classPK = 0;\n\t\t_editable = false;\n\t\t_label = false;\n\t\t_ignore = null;\n\t}","commit_id":"0c6a2a9967a170e5289fd9f8801f6ea5ae8fa02c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void setAttributes(HttpServletRequest request) {\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:classPK\",\n\t\t\tString.valueOf(_classPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:editable\",\n\t\t\tString.valueOf(_editable));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:label\", String.valueOf(_label));\n\t}","id":89157,"modified_method":"@Override\n\tprotected void setAttributes(HttpServletRequest request) {\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:classPK\",\n\t\t\tString.valueOf(_classPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:editable\",\n\t\t\tString.valueOf(_editable));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:label\", String.valueOf(_label));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:ignore\", _ignore);\n\t}","commit_id":"0c6a2a9967a170e5289fd9f8801f6ea5ae8fa02c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong companyId = _companyId;\n\n\t\t\tif (companyId == 0) {\n\t\t\t\tcompanyId = themeDisplay.getCompanyId();\n\t\t\t}\n\n\t\t\tExpandoBridge expandoBridge = null;\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className, _classPK);\n\t\t\t}\n\n\t\t\tEnumeration<String> enu = expandoBridge.getAttributeNames();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString attributeName = enu.nextElement();\n\n\t\t\t\tSerializable value = expandoBridge.getAttribute(attributeName);\n\n\t\t\t\tif (Validator.isNull(value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUnicodeProperties properties =\n\t\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\t\tboolean propertyHidden = GetterUtil.getBoolean(\n\t\t\t\t\tproperties.get(ExpandoColumnConstants.PROPERTY_HIDDEN));\n\t\t\t\tboolean propertyVisibleWithUpdatePermission =\n\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\tproperties.get(\n\t\t\t\t\t\t\tExpandoColumnConstants.\n\t\t\t\t\t\t\t\tPROPERTY_VISIBLE_WITH_UPDATE_PERMISSION));\n\n\t\t\t\tif (_editable && propertyVisibleWithUpdatePermission) {\n\t\t\t\t\tif (ExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, ActionKeys.UPDATE)) {\n\n\t\t\t\t\t\tpropertyHidden = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpropertyHidden = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!propertyHidden &&\n\t\t\t\t\tExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, attributeName,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_className = null;\n\t\t\t\t_classPK = 0;\n\t\t\t\t_companyId = 0;\n\t\t\t\t_editable = false;\n\t\t\t}\n\t\t}\n\t}","id":89158,"modified_method":"@Override\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong companyId = _companyId;\n\n\t\t\tif (companyId == 0) {\n\t\t\t\tcompanyId = themeDisplay.getCompanyId();\n\t\t\t}\n\n\t\t\tExpandoBridge expandoBridge = null;\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className, _classPK);\n\t\t\t}\n\n\t\t\tList<String> attributes = CustomAttributesTagUtil.getUnignoredAttributes(expandoBridge.getAttributeNames(), _ignore);\n\t\t\t\n\t\t\tif(attributes.isEmpty()) {\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\t\t\t\n\t\t\tif (_classPK == 0) {\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\tfor (String attributeName : attributes) {\n\n\t\t\t\tSerializable value = expandoBridge.getAttribute(attributeName);\n\n\t\t\t\tif (Validator.isNull(value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUnicodeProperties properties =\n\t\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\t\tboolean propertyHidden = GetterUtil.getBoolean(\n\t\t\t\t\tproperties.get(ExpandoColumnConstants.PROPERTY_HIDDEN));\n\t\t\t\tboolean propertyVisibleWithUpdatePermission =\n\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\tproperties.get(\n\t\t\t\t\t\t\tExpandoColumnConstants.\n\t\t\t\t\t\t\t\tPROPERTY_VISIBLE_WITH_UPDATE_PERMISSION));\n\n\t\t\t\tif (_editable && propertyVisibleWithUpdatePermission) {\n\t\t\t\t\tif (ExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, ActionKeys.UPDATE)) {\n\n\t\t\t\t\t\tpropertyHidden = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpropertyHidden = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!propertyHidden &&\n\t\t\t\t\tExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, attributeName,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_className = null;\n\t\t\t\t_classPK = 0;\n\t\t\t\t_companyId = 0;\n\t\t\t\t_editable = false;\n\t\t\t\t_ignore = null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"0c6a2a9967a170e5289fd9f8801f6ea5ae8fa02c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addAttributes(Document doc, ExpandoBridge expandoBridge) {\n\t\tif (expandoBridge == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> attributeNames = Collections.list(\n\t\t\texpandoBridge.getAttributeNames());\n\n\t\tfor (String attributeName : attributeNames) {\n\t\t\tint attributeType = expandoBridge.getAttributeType(attributeName);\n\t\t\tUnicodeProperties attributeProperties =\n\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\tboolean propertyIndexable = GetterUtil.getBoolean(\n\t\t\t\tattributeProperties.get(ExpandoBridgeIndexer.INDEXABLE));\n\n\t\t\tif ((attributeType == ExpandoColumnConstants.STRING) &&\n\t\t\t\t(propertyIndexable)) {\n\n\t\t\t\ttry {\n\t\t\t\t\tString attributeValue =\n\t\t\t\t\t\tExpandoValueLocalServiceUtil.getData(\n\t\t\t\t\t\t\texpandoBridge.getClassName(),\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, expandoBridge.getClassPK(),\n\t\t\t\t\t\t\tStringPool.BLANK);\n\n\t\t\t\t\tdoc.addText(attributeName, attributeValue);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Indexing \" + attributeName, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":89159,"modified_method":"public void addAttributes(Document doc, ExpandoBridge expandoBridge) {\n\t\tif (expandoBridge == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tEnumeration<String> enu = expandoBridge.getAttributeNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = enu.nextElement();\n\n\t\t\tint type = expandoBridge.getAttributeType(name);\n\n\t\t\tUnicodeProperties properties = expandoBridge.getAttributeProperties(\n\t\t\t\tname);\n\n\t\t\tboolean indexable = GetterUtil.getBoolean(\n\t\t\t\tproperties.get(ExpandoBridgeIndexer.INDEXABLE));\n\n\t\t\tif (!indexable || (type != ExpandoColumnConstants.STRING)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString value = ExpandoValueLocalServiceUtil.getData(\n\t\t\t\t\texpandoBridge.getClassName(),\n\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, name,\n\t\t\t\t\texpandoBridge.getClassPK(), StringPool.BLANK);\n\n\t\t\t\tdoc.addText(name, value);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Indexing \" + name, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"9fc8c08413d905829849fa6777452cf0287dd4de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doStartTag() {\n\t\ttry {\n\t\t\tlong companyId = _companyId;\n\n\t\t\tif (companyId == 0) {\n\t\t\t\tcompanyId = CompanyThreadLocal.getCompanyId();\n\t\t\t}\n\n\t\t\tExpandoBridge expandoBridge = null;\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className, _classPK);\n\t\t\t}\n\n\t\t\tList<String> attributeNames = Collections.list(\n\t\t\t\texpandoBridge.getAttributeNames());\n\n\t\t\tif (attributeNames.isEmpty()) {\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_classPK == 0) {\n\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t}\n\n\t\t\t\tHttpServletRequest request =\n\t\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t(ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\t\tfor (String attributeName : attributeNames) {\n\t\t\t\t\tSerializable value = expandoBridge.getAttribute(\n\t\t\t\t\t\tattributeName);\n\n\t\t\t\t\tif (Validator.isNull(value)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tUnicodeProperties properties =\n\t\t\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\t\t\tboolean propertyHidden = GetterUtil.getBoolean(\n\t\t\t\t\t\tproperties.get(ExpandoColumnConstants.PROPERTY_HIDDEN));\n\t\t\t\t\tboolean propertyVisibleWithUpdatePermission =\n\t\t\t\t\t\tGetterUtil.getBoolean(properties.get(\n\t\t\t\t\t\t\tExpandoColumnConstants.\n\t\t\t\t\t\t\t\tPROPERTY_VISIBLE_WITH_UPDATE_PERMISSION));\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (_editable && propertyVisibleWithUpdatePermission) {\n\t\t\t\t\t\t\tpropertyHidden = !ExpandoColumnPermission.contains(\n\t\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\t\tattributeName, ActionKeys.UPDATE);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!propertyHidden && ExpandoColumnPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SystemException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_className = null;\n\t\t\t\t_classPK = 0;\n\t\t\t\t_editable = false;\n\t\t\t\t_companyId = 0;\n\t\t\t}\n\t\t}\n\t}","id":89160,"modified_method":"@Override\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)request.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tlong companyId = _companyId;\n\n\t\t\tif (companyId == 0) {\n\t\t\t\tcompanyId = themeDisplay.getCompanyId();\n\t\t\t}\n\n\t\t\tExpandoBridge expandoBridge = null;\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className, _classPK);\n\t\t\t}\n\n\t\t\tEnumeration<String> enu = expandoBridge.getAttributeNames();\n\n\t\t\tif (enu.hasMoreElements()) {\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString attributeName = enu.nextElement();\n\n\t\t\t\tSerializable value = expandoBridge.getAttribute(\n\t\t\t\t\tattributeName);\n\n\t\t\t\tif (Validator.isNull(value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUnicodeProperties properties =\n\t\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\t\tboolean propertyHidden = GetterUtil.getBoolean(\n\t\t\t\t\tproperties.get(ExpandoColumnConstants.PROPERTY_HIDDEN));\n\t\t\t\tboolean propertyVisibleWithUpdatePermission =\n\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\tproperties.get(\n\t\t\t\t\t\t\tExpandoColumnConstants.\n\t\t\t\t\t\t\t\tPROPERTY_VISIBLE_WITH_UPDATE_PERMISSION));\n\n\t\t\t\tif (_editable && propertyVisibleWithUpdatePermission) {\n\t\t\t\t\tif (ExpandoColumnPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, ActionKeys.UPDATE)) {\n\n\t\t\t\t\t\tpropertyHidden = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpropertyHidden = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!propertyHidden &&\n\t\t\t\t\tExpandoColumnPermission.contains(\n\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\tattributeName, ActionKeys.VIEW)) {\n\n\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_className = null;\n\t\t\t\t_classPK = 0;\n\t\t\t\t_companyId = 0;\n\t\t\t\t_editable = false;\n\t\t\t}\n\t\t}\n\t}","commit_id":"30f0a8fbe42ceed44b964d8920070b50d0f33165","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void setAttributes(HttpServletRequest request) {\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:classPK\",\n\t\t\tString.valueOf(_classPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:editable\",\n\t\t\tString.valueOf(_editable));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:label\", String.valueOf(_label));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:ignore\", _ignore);\n\t}","id":89161,"modified_method":"@Override\n\tprotected void setAttributes(HttpServletRequest request) {\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:classPK\",\n\t\t\tString.valueOf(_classPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:editable\",\n\t\t\tString.valueOf(_editable));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:ignore\", _ignore);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:custom-attribute-list:label\", String.valueOf(_label));\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void cleanUp() {\n\t\t_className = null;\n\t\t_classPK = 0;\n\t\t_editable = false;\n\t\t_label = false;\n\t\t_ignore = null;\n\t}","id":89162,"modified_method":"@Override\n\tprotected void cleanUp() {\n\t\t_className = null;\n\t\t_classPK = 0;\n\t\t_editable = false;\n\t\t_ignore = null;\n\t\t_label = false;\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong companyId = _companyId;\n\n\t\t\tif (companyId == 0) {\n\t\t\t\tcompanyId = themeDisplay.getCompanyId();\n\t\t\t}\n\n\t\t\tExpandoBridge expandoBridge = null;\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className, _classPK);\n\t\t\t}\n\n\t\t\tList<String> attributes = CustomAttributesTagUtil.getUnignoredAttributes(expandoBridge.getAttributeNames(), _ignore);\n\t\t\t\n\t\t\tif(attributes.isEmpty()) {\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\t\t\t\n\t\t\tif (_classPK == 0) {\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\tfor (String attributeName : attributes) {\n\n\t\t\t\tSerializable value = expandoBridge.getAttribute(attributeName);\n\n\t\t\t\tif (Validator.isNull(value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUnicodeProperties properties =\n\t\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\t\tboolean propertyHidden = GetterUtil.getBoolean(\n\t\t\t\t\tproperties.get(ExpandoColumnConstants.PROPERTY_HIDDEN));\n\t\t\t\tboolean propertyVisibleWithUpdatePermission =\n\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\tproperties.get(\n\t\t\t\t\t\t\tExpandoColumnConstants.\n\t\t\t\t\t\t\t\tPROPERTY_VISIBLE_WITH_UPDATE_PERMISSION));\n\n\t\t\t\tif (_editable && propertyVisibleWithUpdatePermission) {\n\t\t\t\t\tif (ExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, ActionKeys.UPDATE)) {\n\n\t\t\t\t\t\tpropertyHidden = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpropertyHidden = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!propertyHidden &&\n\t\t\t\t\tExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, attributeName,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_className = null;\n\t\t\t\t_classPK = 0;\n\t\t\t\t_companyId = 0;\n\t\t\t\t_editable = false;\n\t\t\t\t_ignore = null;\n\t\t\t}\n\t\t}\n\t}","id":89163,"modified_method":"@Override\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tlong companyId = _companyId;\n\n\t\t\tif (companyId == 0) {\n\t\t\t\tcompanyId = themeDisplay.getCompanyId();\n\t\t\t}\n\n\t\t\tExpandoBridge expandoBridge = null;\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandoBridge = ExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tcompanyId, _className, _classPK);\n\t\t\t}\n\n\t\t\tList<String> attributeNames =\n\t\t\t\tCustomAttributesTagUtil.filterAttributes(\n\t\t\t\t\tCollections.list(expandoBridge.getAttributeNames()),\n\t\t\t\t\t_ignore);\n\n\t\t\tif (attributeNames.isEmpty()) {\n\t\t\t\treturn SKIP_BODY;\n\t\t\t}\n\n\t\t\tif (_classPK == 0) {\n\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t}\n\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\tfor (String attributeName : attributeNames) {\n\t\t\t\tSerializable value = expandoBridge.getAttribute(attributeName);\n\n\t\t\t\tif (Validator.isNull(value)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tUnicodeProperties properties =\n\t\t\t\t\texpandoBridge.getAttributeProperties(attributeName);\n\n\t\t\t\tboolean propertyHidden = GetterUtil.getBoolean(\n\t\t\t\t\tproperties.get(ExpandoColumnConstants.PROPERTY_HIDDEN));\n\t\t\t\tboolean propertyVisibleWithUpdatePermission =\n\t\t\t\t\tGetterUtil.getBoolean(\n\t\t\t\t\t\tproperties.get(\n\t\t\t\t\t\t\tExpandoColumnConstants.\n\t\t\t\t\t\t\t\tPROPERTY_VISIBLE_WITH_UPDATE_PERMISSION));\n\n\t\t\t\tif (_editable && propertyVisibleWithUpdatePermission) {\n\t\t\t\t\tif (ExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME,\n\t\t\t\t\t\t\tattributeName, ActionKeys.UPDATE)) {\n\n\t\t\t\t\t\tpropertyHidden = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpropertyHidden = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!propertyHidden &&\n\t\t\t\t\tExpandoColumnPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, companyId, _className,\n\t\t\t\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, attributeName,\n\t\t\t\t\t\tActionKeys.VIEW)) {\n\n\t\t\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!ServerDetector.isResin()) {\n\t\t\t\t_className = null;\n\t\t\t\t_classPK = 0;\n\t\t\t\t_companyId = 0;\n\t\t\t\t_editable = false;\n\t\t\t\t_ignore = null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testForIgnoringNonexistingElements() {\n\t\tassertEquals(\"aaa,bbb,ccc\", concat(getUnignoredAttributes(attributes.elements(), \"some-attribute\")));\n\t\tassertEquals(\"aaa,bbb,ccc\", concat(getUnignoredAttributes(attributes.elements(), \"some-attribute,some-other-attribute,yet-another-attribute\")));\n\t\tassertEquals(\"aaa,bbb,ccc\", concat(getUnignoredAttributes(attributes.elements(), \"attribute-one,attribute-two,nonexisting-attribute\")));\n\t}","id":89164,"modified_method":"@Test\n\tpublic void testIgnoreNonexistingAttributes() {\n\t\tAssert.assertEquals(\n\t\t\t\"aaa,bbb,ccc\",\n\t\t\tStringUtil.merge(filterAttributes(_attributes, \"some-attribute\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa,bbb,ccc\",\n\t\t\tStringUtil.merge(\n\t\t\t\tfilterAttributes(\n\t\t\t\t\t_attributes,\n\t\t\t\t\t\"some-attribute,some-other-attribute,another-attribute\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa,bbb,ccc\",\n\t\t\tStringUtil.merge(\n\t\t\t\tfilterAttributes(\n\t\t\t\t\t_attributes,\n\t\t\t\t\t\"attribute-one,attribute-two,nonexisting-attribute\")));\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testForIgnoringSomeAttributes() {\n\t\tassertEquals(\"ccc\", concat(getUnignoredAttributes(attributes.elements(), \"aaa,bbb\")));\n\t\tassertEquals(\"bbb\", concat(getUnignoredAttributes(attributes.elements(), \"aaa,ccc\")));\n\t\tassertEquals(\"aaa\", concat(getUnignoredAttributes(attributes.elements(), \"bbb,ccc\")));\n\t\tassertEquals(\"aaa\", concat(getUnignoredAttributes(attributes.elements(), \"ccc,bbb\")));\n\t\tassertEquals(\"bbb\", concat(getUnignoredAttributes(attributes.elements(), \"ccc,aaa\")));\n\t\tassertEquals(\"aaa,bbb\", concat(getUnignoredAttributes(attributes.elements(), \"ccc,ccc,ccc\")));\n\t}","id":89165,"modified_method":"@Test\n\tpublic void testIgnoreAttributes() {\n\t\tAssert.assertEquals(\n\t\t\t\"ccc\", StringUtil.merge(filterAttributes(_attributes, \"aaa,bbb\")));\n\t\tAssert.assertEquals(\n\t\t\t\"bbb\", StringUtil.merge(filterAttributes(_attributes, \"aaa,ccc\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa\", StringUtil.merge(filterAttributes(_attributes, \"bbb,ccc\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa\", StringUtil.merge(filterAttributes(_attributes, \"ccc,bbb\")));\n\t\tAssert.assertEquals(\n\t\t\t\"bbb\", StringUtil.merge(filterAttributes(_attributes, \"ccc,aaa\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa,bbb\",\n\t\t\tStringUtil.merge(filterAttributes(_attributes, \"ccc,ccc,ccc\")));\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testForNoAttributesAvailable() {\n\t\tVector<String> empty = new Vector<String>();\n\t\tassertEquals(\"\", concat(getUnignoredAttributes(empty.elements(), \"some-attribute\")));\n\t\tassertEquals(\"\", concat(getUnignoredAttributes(empty.elements(), \"some-attribute,some-other-attribute,yet-another-attribute\")));\n\t\tassertEquals(\"\", concat(getUnignoredAttributes(empty.elements(), \"\")));\n\t\tassertEquals(\"\", concat(getUnignoredAttributes(empty.elements(), null)));\n\t}","id":89166,"modified_method":"@Test\n\tpublic void testNoAttributesAvailable() {\n\t\tAssert.assertEquals(\n\t\t\tStringPool.BLANK,\n\t\t\tStringUtil.merge(\n\t\t\t\tfilterAttributes(\n\t\t\t\t\tCollections.<String>emptyList(), \"some-attribute\")));\n\t\tAssert.assertEquals(\n\t\t\tStringPool.BLANK,\n\t\t\tStringUtil.merge(\n\t\t\t\tfilterAttributes(\n\t\t\t\t\tCollections.<String>emptyList(),\n\t\t\t\t\t\"some-attribute,some-other-attribute,another-attribute\")));\n\t\tAssert.assertEquals(\n\t\t\tStringPool.BLANK,\n\t\t\tStringUtil.merge(\n\t\t\t\tfilterAttributes(\n\t\t\t\t\tCollections.<String>emptyList(), StringPool.BLANK)));\n\t\tAssert.assertEquals(\n\t\t\tStringPool.BLANK,\n\t\t\tStringUtil.merge(\n\t\t\t\tfilterAttributes(Collections.<String>emptyList(), null)));\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testForIgnoringOneAttribute() {\n\t\tassertEquals(\"bbb,ccc\", concat(getUnignoredAttributes(attributes.elements(), \"aaa\")));\n\t\tassertEquals(\"aaa,ccc\", concat(getUnignoredAttributes(attributes.elements(), \"bbb\")));\n\t\tassertEquals(\"aaa,bbb\", concat(getUnignoredAttributes(attributes.elements(), \"ccc\")));\n\t}","id":89167,"modified_method":"@Test\n\tpublic void testIgnoreOneAttribute() {\n\t\tAssert.assertEquals(\n\t\t\t\"bbb,ccc\", StringUtil.merge(filterAttributes(_attributes, \"aaa\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa,ccc\", StringUtil.merge(filterAttributes(_attributes, \"bbb\")));\n\t\tAssert.assertEquals(\n\t\t\t\"aaa,bbb\", StringUtil.merge(filterAttributes(_attributes, \"ccc\")));\n\t}","commit_id":"a873c038025066fee0caca3e7423a4b71eff6a9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** {@inheritDoc} */\n    public Requisition addInterfaceToNode(final String groupName, final String pathToNode, final String ipAddr) {\n        m_writeLock.lock();\n        try {\n            final Requisition group = getProvisioningGroup(groupName);\n            Assert.notNull(group, \"Group should not be Null and is null groupName: \" + groupName);\n            final RequisitionNode node = BeanUtils.getPathValue(group, pathToNode, RequisitionNode.class);\n            Assert.notNull(node, \"Node should not be Null and pathToNode: \" + pathToNode);\n            \n            String snmpPrimary = \"P\";\n            if (node.getInterfaceCount() > 0) {\n                snmpPrimary = \"S\";\n            }\n    \n            final int ifaceCount = node.getInterfaceCount();\n            final RequisitionInterface iface = createInterface(ipAddr, snmpPrimary);\n            node.putInterface(iface);\n            // Assert.isTrue(node.getInterfaceCount() == (ifaceCount + 1), \"Interface was not added correctly\");\n    \n            m_pendingForeignSourceRepository.save(group);\n            return m_pendingForeignSourceRepository.getRequisition(groupName);\n        } finally {\n            m_writeLock.unlock();\n        }\n    }","id":89168,"modified_method":"/** {@inheritDoc} */\n    public Requisition addInterfaceToNode(final String groupName, final String pathToNode, final String ipAddr) {\n        m_writeLock.lock();\n        try {\n            final Requisition group = getProvisioningGroup(groupName);\n            Assert.notNull(group, \"Group should not be Null and is null groupName: \" + groupName);\n            final RequisitionNode node = BeanUtils.getPathValue(group, pathToNode, RequisitionNode.class);\n            Assert.notNull(node, \"Node should not be Null and pathToNode: \" + pathToNode);\n            \n            String snmpPrimary = \"P\";\n            if (node.getInterfaceCount() > 0) {\n                snmpPrimary = \"S\";\n            }\n    \n            // final int ifaceCount = node.getInterfaceCount();\n            final RequisitionInterface iface = createInterface(ipAddr, snmpPrimary);\n            node.putInterface(iface);\n            // Assert.isTrue(node.getInterfaceCount() == (ifaceCount + 1), \"Interface was not added correctly\");\n    \n            m_pendingForeignSourceRepository.save(group);\n            return m_pendingForeignSourceRepository.getRequisition(groupName);\n        } finally {\n            m_writeLock.unlock();\n        }\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public Requisition addAssetFieldToNode(final String groupName, final String pathToNode, final String assetName, final String assetValue) {\n        m_writeLock.lock();\n        try {\n            final Requisition group = getProvisioningGroup(groupName);\n            final RequisitionNode node = BeanUtils.getPathValue(group, pathToNode, RequisitionNode.class);\n    \n            final int assetCount = node.getAssetCount();\n            final RequisitionAsset asset = new RequisitionAsset();\n            asset.setName(assetName);\n            asset.setValue(assetValue);\n            node.putAsset(asset);\n            // Assert.isTrue(node.getCategoryCount() == (assetCount + 1), \"Asset was not added correctly\");\n    \n            m_pendingForeignSourceRepository.save(group);\n            return m_pendingForeignSourceRepository.getRequisition(groupName);\n        } finally {\n            m_writeLock.unlock();\n\t\t  }\n    }","id":89169,"modified_method":"/** {@inheritDoc} */\n    public Requisition addAssetFieldToNode(final String groupName, final String pathToNode, final String assetName, final String assetValue) {\n        m_writeLock.lock();\n        try {\n            final Requisition group = getProvisioningGroup(groupName);\n            final RequisitionNode node = BeanUtils.getPathValue(group, pathToNode, RequisitionNode.class);\n    \n            // final int assetCount = node.getAssetCount();\n            final RequisitionAsset asset = new RequisitionAsset();\n            asset.setName(assetName);\n            asset.setValue(assetValue);\n            node.putAsset(asset);\n            // Assert.isTrue(node.getCategoryCount() == (assetCount + 1), \"Asset was not added correctly\");\n    \n            m_pendingForeignSourceRepository.save(group);\n            return m_pendingForeignSourceRepository.getRequisition(groupName);\n        } finally {\n            m_writeLock.unlock();\n\t\t  }\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    public Requisition addCategoryToNode(final String groupName, final String pathToNode, final String categoryName) {\n        m_writeLock.lock();\n        try {\n            final Requisition group = getProvisioningGroup(groupName);\n            \n            final RequisitionNode node = BeanUtils.getPathValue(group, pathToNode, RequisitionNode.class);\n            \n            final int catCount = node.getCategoryCount();\n            final RequisitionCategory category = new RequisitionCategory();\n            category.setName(categoryName);\n            node.putCategory(category);\n            // Assert.isTrue(node.getCategoryCount() == (catCount + 1), \"Category was not added correctly\");\n    \n            m_pendingForeignSourceRepository.save(group);\n    \n            return m_pendingForeignSourceRepository.getRequisition(groupName);\n\t\t  } finally {\n\t\t      m_writeLock.unlock();\n\t\t  }\n    }","id":89170,"modified_method":"/** {@inheritDoc} */\n    public Requisition addCategoryToNode(final String groupName, final String pathToNode, final String categoryName) {\n        m_writeLock.lock();\n        try {\n            final Requisition group = getProvisioningGroup(groupName);\n            \n            final RequisitionNode node = BeanUtils.getPathValue(group, pathToNode, RequisitionNode.class);\n            \n            // final int catCount = node.getCategoryCount();\n            final RequisitionCategory category = new RequisitionCategory();\n            category.setName(categoryName);\n            node.putCategory(category);\n            // Assert.isTrue(node.getCategoryCount() == (catCount + 1), \"Category was not added correctly\");\n    \n            m_pendingForeignSourceRepository.save(group);\n    \n            return m_pendingForeignSourceRepository.getRequisition(groupName);\n\t\t  } finally {\n\t\t      m_writeLock.unlock();\n\t\t  }\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getNodeCategoryNames<\/p>\n     *\n     * @return a {@link java.util.Collection} object.\n     */\n    public Collection<String> getNodeCategoryNames() {\n        m_readLock.lock();\n        \n        try {\n            final Collection<String> names = new LinkedList<String>();\n            for (final OnmsCategory category : m_categoryDao.findAll()) {\n                names.add(category.getName());\n            }\n            return names;\n        } finally {\n            m_readLock.unlock();\n        }\n    }","id":89171,"modified_method":"/**\n     * <p>getServiceTypeNames<\/p>\n     *\n     * @return a {@link java.util.Collection} object.\n     */\n    public Collection<String> getServiceTypeNames(String groupName) {\n        m_readLock.lock();\n        try {\n            return m_deployedForeignSourceRepository.getForeignSource(groupName).getDetectorNames();\n        } finally {\n            m_readLock.unlock();\n        }\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setServiceTypeDao<\/p>\n     *\n     * @param serviceTypeDao a {@link org.opennms.netmgt.dao.ServiceTypeDao} object.\n     */\n    public void setServiceTypeDao(final ServiceTypeDao serviceTypeDao) {\n        m_writeLock.lock();\n        try {\n            m_serviceTypeDao = serviceTypeDao;\n        } finally {\n            m_writeLock.unlock();\n        }\n    }","id":89172,"modified_method":"/**\n     * <p>setServiceTypeDao<\/p>\n     *\n     * @param serviceTypeDao a {@link org.opennms.netmgt.dao.ServiceTypeDao} object.\n     */\n    public void setServiceTypeDao(final ServiceTypeDao serviceTypeDao) {\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    protected Map<String, Collection<String>> referenceData(HttpServletRequest request) throws Exception {\n        Map<String, Collection<String>> map = new HashMap<String, Collection<String>>();\n        \n        // Fetch the list of possible values out of the Castor enumeration\n        List<String> choices = new ArrayList<String>();\n        for (Object type : Collections.list(InterfaceSnmpPrimaryType.enumerate())) {\n            choices.add(type.toString());\n        }\n        map.put(\"snmpPrimaryChoices\", choices);\n        \n        map.put(\"categories\", m_provisioningService.getNodeCategoryNames());\n        map.put(\"assetFields\", m_provisioningService.getAssetFieldNames());\n        map.put(\"services\",  m_provisioningService.getServiceTypeNames());\n        \n        \n        return map;\n    }","id":89173,"modified_method":"/** {@inheritDoc} */\n    @Override\n    protected Map<String, Collection<String>> referenceData(HttpServletRequest request) throws Exception {\n        Map<String, Collection<String>> map = new HashMap<String, Collection<String>>();\n        \n        // Fetch the list of possible values out of the Castor enumeration\n        List<String> choices = new ArrayList<String>();\n        for (Object type : Collections.list(InterfaceSnmpPrimaryType.enumerate())) {\n            choices.add(type.toString());\n        }\n        map.put(\"snmpPrimaryChoices\", choices);\n        \n        String groupName = request.getParameter(\"groupName\");\n        if (groupName != null) {\n            map.put(\"services\",  m_provisioningService.getServiceTypeNames(groupName));\n        }\n        \n        map.put(\"categories\", m_provisioningService.getNodeCategoryNames());\n        map.put(\"assetFields\", m_provisioningService.getAssetFieldNames());\n        \n        \n        \n        \n        return map;\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>compareTo<\/p>\n     *\n     * @param obj a {@link org.opennms.netmgt.provision.persist.foreignsource.ForeignSource} object.\n     * @return a int.\n     */\n    public int compareTo(final ForeignSource obj) {\n        return new CompareToBuilder()\n            .append(getName(), obj.getName())\n            .append(getScanInterval(), obj.getScanInterval())\n            .append(getDetectors().toArray(OF_PLUGIN_CONFIGS), obj.getDetectors().toArray(OF_PLUGIN_CONFIGS))\n            .append(getPolicies().toArray(OF_PLUGIN_CONFIGS), obj.getPolicies().toArray(OF_PLUGIN_CONFIGS))\n            .toComparison();\n    }","id":89174,"modified_method":"/**\n     * <p>compareTo<\/p>\n     *\n     * @param obj a {@link org.opennms.netmgt.provision.persist.foreignsource.ForeignSource} object.\n     * @return a int.\n     */\n    public int compareTo(final ForeignSource obj) {\n        return new CompareToBuilder()\n            .append(getName(), obj.getName())\n            .toComparison();\n    }","commit_id":"35757384f5025bea5f304b106186a21278f05fea","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Build the matrix of assignments and grades for the given users with the specified sort order\n\t *\n\t * @param assignments list of assignments\n\t * @param studentUuids student uuids\n\t * @param uiSettings the settings from the UI that wraps up preferences\n\t * @return\n\t */\n\tpublic List<GbStudentGradeInfo> buildGradeMatrix(final List<Assignment> assignments,\n\t\t\tfinal List<String> studentUuids, final GradebookUiSettings uiSettings) throws GbException {\n\n\t\t// TODO move GradebookUISettings to business\n\n\t\t// settings could be null depending on constructor so it needs to be corrected\n\t\tfinal GradebookUiSettings settings = (uiSettings != null) ? uiSettings : new GradebookUiSettings();\n\n\t\tfinal StopWatch stopwatch = new StopWatch();\n\t\tstopwatch.start();\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"buildGradeMatrix start\", stopwatch.getTime());\n\n\t\tfinal Gradebook gradebook = this.getGradebook();\n\t\tif (gradebook == null) {\n\t\t\treturn null;\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"getGradebook\", stopwatch.getTime());\n\n\t\tfinal boolean categoriesEnabled = categoriesAreEnabled();\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"categoriesAreEnabled\", stopwatch.getTime());\n\n\t\t// get current user\n\t\tfinal String currentUserUuid = getCurrentUser().getId();\n\n\t\t// get role for current user\n\t\tfinal GbRole role = this.getUserRole();\n\n\t\t// get uuids as list of Users.\n\t\t// this gives us our base list and will be sorted as per our desired\n\t\t// sort method\n\t\tfinal List<User> students = getUsers(studentUuids);\n\t\tif (settings.getNameSortOrder() != null) {\n\n\t\t\tif (settings.getNameSortOrder() == GbStudentNameSortOrder.LAST_NAME) {\n\t\t\t\tCollections.sort(students, new LastNameComparator());\n\t\t\t} else {\n\t\t\t\tCollections.sort(students, new FirstNameComparator());\n\t\t\t}\n\t\t}\n\n\t\t// get course grades\n\t\tfinal Map<String, CourseGrade> courseGrades = getCourseGrades(studentUuids);\n\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"getSiteCourseGrades\", stopwatch.getTime());\n\n\t\t// setup a map because we progressively build this up by adding grades\n\t\t// to a student's entry\n\t\tfinal Map<String, GbStudentGradeInfo> matrix = new LinkedHashMap<>();\n\n\t\t// setup the course grade formatter\n\t\t// TODO we want the override except in certain cases. Can we hard code this?\n\t\tfinal CourseGradeFormatter courseGradeFormatter = new CourseGradeFormatter(\n\t\t\t\tgradebook,\n\t\t\t\trole,\n\t\t\t\tisCourseGradeVisible(currentUserUuid),\n\t\t\t\tsettings.getShowPoints(),\n\t\t\t\ttrue);\n\n\t\t// seed the map for all students so we can progresseively add grades\n\t\t// also add the course grade here, to save an iteration later\n\t\t// TA permissions already included in course grade visibility\n\t\tfor (final User student : students) {\n\n\t\t\t// create and add the user info\n\t\t\tfinal GbStudentGradeInfo sg = new GbStudentGradeInfo(student);\n\n\t\t\t// add the course grade, including the display\n\t\t\tfinal CourseGrade courseGrade = courseGrades.get(student.getId());\n\t\t\tfinal GbCourseGrade gbCourseGrade = new GbCourseGrade(courseGrades.get(student.getId()));\n\t\t\tgbCourseGrade.setDisplayString(courseGradeFormatter.format(courseGrade));\n\t\t\tsg.setCourseGrade(gbCourseGrade);\n\n\t\t\t// add to map so we can build on it later\n\t\t\tmatrix.put(student.getId(), sg);\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix seeded\", stopwatch.getTime());\n\n\t\t// get categories. This call is filtered for TAs as well.\n\t\tfinal List<CategoryDefinition> categories = this.getGradebookCategories();\n\n\t\t// for TA's, build a lookup map of visible categoryIds so we can filter\n\t\t// the assignment list to not fetch grades\n\t\t// for assignments we don't have category level access to.\n\t\t// for everyone else this will just be an empty list that is unused\n\t\tfinal List<Long> categoryIds = new ArrayList<>();\n\n\t\tif (role == GbRole.TA) {\n\t\t\tfor (final CategoryDefinition category : categories) {\n\t\t\t\tcategoryIds.add(category.getId());\n\t\t\t}\n\t\t}\n\n\t\t// this holds a map of categoryId and the list of assignment ids in each\n\t\t// we build this whilst iterating below to save further iterations when\n\t\t// building the category list\n\t\tfinal Map<Long, Set<Long>> categoryAssignments = new TreeMap<>();\n\n\t\t// iterate over assignments and get the grades for each\n\t\t// note, the returned list only includes entries where there is a grade\n\t\t// for the user\n\t\t// we also build the category lookup map here\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal Long categoryId = assignment.getCategoryId();\n\t\t\tfinal Long assignmentId = assignment.getId();\n\n\t\t\t// TA permission check. If there are categories and they don't have\n\t\t\t// access to this one, skip it\n\t\t\tif (role == GbRole.TA) {\n\t\t\t\tif (!categoryIds.isEmpty() && !categoryIds.contains(categoryId)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TA stub out. So that we can support 'per grade' permissions for a\n\t\t\t// TA, we need a stub record for every student\n\t\t\t// This is because getGradesForStudentsForItem only returns records\n\t\t\t// where there is a grade (even if blank)\n\t\t\t// So this iteration for TAs allows the matrix to be fully\n\t\t\t// populated.\n\t\t\t// This is later updated to be a real grade entry if there is one.\n\t\t\tif (role == GbRole.TA) {\n\t\t\t\tfor (final User student : students) {\n\t\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(student.getId());\n\t\t\t\t\tsg.addGrade(assignment.getId(), new GbGradeInfo(null));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build the category map (if assignment is categorised)\n\t\t\tif (categoryId != null) {\n\t\t\t\tSet<Long> values;\n\t\t\t\tif (categoryAssignments.containsKey(categoryId)) {\n\t\t\t\t\tvalues = categoryAssignments.get(categoryId);\n\t\t\t\t\tvalues.add(assignmentId);\n\t\t\t\t} else {\n\t\t\t\t\tvalues = new HashSet<Long>();\n\t\t\t\t\tvalues.add(assignmentId);\n\t\t\t\t}\n\t\t\t\tcategoryAssignments.put(categoryId, values);\n\t\t\t}\n\n\t\t\t// get grades\n\t\t\tfinal List<GradeDefinition> defs = this.gradebookService.getGradesForStudentsForItem(gradebook.getUid(),\n\t\t\t\t\tassignment.getId(), studentUuids);\n\t\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"getGradesForStudentsForItem: \" + assignment.getId(),\n\t\t\t\t\tstopwatch.getTime());\n\n\t\t\t// iterate the definitions returned and update the record for each\n\t\t\t// student with the grades\n\t\t\tfor (final GradeDefinition def : defs) {\n\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(def.getStudentUid());\n\n\t\t\t\tif (sg == null) {\n\t\t\t\t\tlog.warn(\"No matrix entry seeded for: \" + def.getStudentUid()\n\t\t\t\t\t\t\t+ \". This user may be been removed from the site\");\n\t\t\t\t} else {\n\t\t\t\t\t// this will overwrite the stub entry for the TA matrix if\n\t\t\t\t\t// need be\n\t\t\t\t\tsg.addGrade(assignment.getId(), new GbGradeInfo(def));\n\t\t\t\t}\n\t\t\t}\n\t\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"updatedStudentGradeInfo: \" + assignment.getId(),\n\t\t\t\t\tstopwatch.getTime());\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix built\", stopwatch.getTime());\n\n\t\t// build category columns\n\t\tfor (final CategoryDefinition category : categories) {\n\n\t\t\t// use the category mappings for faster lookup of the assignmentIds\n\t\t\t// and grades in the category\n\t\t\tfinal Set<Long> categoryAssignmentIds = categoryAssignments.get(category.getId());\n\n\t\t\t// if there are no assignments in the category (ie its a new\n\t\t\t// category) this will be null, so skip\n\t\t\tif (categoryAssignmentIds != null) {\n\n\t\t\t\tfor (final User student : students) {\n\n\t\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(student.getId());\n\n\t\t\t\t\t// get grades\n\t\t\t\t\tfinal Map<Long, GbGradeInfo> grades = sg.getGrades();\n\n\t\t\t\t\t// build map of just the grades we want\n\t\t\t\t\tfinal Map<Long, String> gradeMap = new HashMap<>();\n\t\t\t\t\tfor (final Long assignmentId : categoryAssignmentIds) {\n\t\t\t\t\t\tfinal GbGradeInfo gradeInfo = grades.get(assignmentId);\n\t\t\t\t\t\tif (gradeInfo != null) {\n\t\t\t\t\t\t\tgradeMap.put(assignmentId, gradeInfo.getGrade());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal Double categoryScore = this.gradebookService.calculateCategoryScore(gradebook,\n\t\t\t\t\t\t\tstudent.getId(), category, assignments, gradeMap);\n\n\t\t\t\t\t// add to GbStudentGradeInfo\n\t\t\t\t\tsg.addCategoryAverage(category.getId(), categoryScore);\n\n\t\t\t\t\t// TODO the TA permission check could reuse this\n\t\t\t\t\t// iteration... check performance.\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"categories built\", stopwatch.getTime());\n\n\t\t// course grade override. if no grades, course grade should be - instead\n\t\t// of 'F'\n\t\t// TODO this iteration may not be necessary as we could instead\n\t\t// add a boolean to the GbStudentGradeInfo object for each student and\n\t\t// when calling addGrade set it to true\n\t\t// then check the boolean on the front end, but then it needs to be\n\t\t// checked everywhere so this may be better.\n\t\t// for (final User student : students) {\n\t\t// final GbStudentGradeInfo sg = matrix.get(student.getId());\n\t\t//\n\t\t// if (sg.getGrades().isEmpty()) {\n\t\t// sg.setCourseGrade(\"-\");\n\t\t// }\n\t\t// }\n\t\t// Temp.timeWithContext(\"buildGradeMatrix\", \"course grade override\n\t\t// done\", stopwatch.getTime());\n\n\t\t// for a TA, apply the permissions to each grade item to see if we can\n\t\t// render it\n\t\t// the list of students, assignments and grades is already filtered to\n\t\t// those that can be viewed\n\t\t// so we are only concerned with the gradeable permission\n\t\tif (role == GbRole.TA) {\n\n\t\t\t// get permissions\n\t\t\tfinal List<PermissionDefinition> permissions = getPermissionsForUser(currentUserUuid);\n\n\t\t\t// only need to process this if some are defined\n\t\t\t// again only concerned with grade permission, so parse the list to\n\t\t\t// remove those that aren't GRADE\n\t\t\tif (!permissions.isEmpty()) {\n\n\t\t\t\tfinal Iterator<PermissionDefinition> iter = permissions.iterator();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tfinal PermissionDefinition permission = iter.next();\n\t\t\t\t\tif (!StringUtils.equalsIgnoreCase(GraderPermission.GRADE.toString(), permission.getFunction())) {\n\t\t\t\t\t\titer.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we still have permissions, they will be of type grade, so we\n\t\t\t// need to enrich the students grades\n\t\t\tif (!permissions.isEmpty()) {\n\n\t\t\t\tlog.debug(\"Grade permissions exist, processing: \" + permissions.size());\n\n\t\t\t\t// first need a lookup map of assignment id to category so we\n\t\t\t\t// can link up permissions by category\n\t\t\t\tfinal Map<Long, Long> assignmentCategoryMap = new HashMap<>();\n\t\t\t\tfor (final Assignment assignment : assignments) {\n\t\t\t\t\tassignmentCategoryMap.put(assignment.getId(), assignment.getCategoryId());\n\t\t\t\t}\n\n\t\t\t\t// get the group membership for the students\n\t\t\t\tfinal Map<String, List<String>> groupMembershipsMap = getGroupMemberships();\n\n\t\t\t\t// for every student\n\t\t\t\tfor (final User student : students) {\n\n\t\t\t\t\tlog.debug(\"Processing student: \" + student.getEid());\n\n\t\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(student.getId());\n\n\t\t\t\t\t// get their assignment/grade list\n\t\t\t\t\tfinal Map<Long, GbGradeInfo> gradeMap = sg.getGrades();\n\n\t\t\t\t\t// for every assignment that has a grade\n\t\t\t\t\tfor (final Map.Entry<Long, GbGradeInfo> entry : gradeMap.entrySet()) {\n\n\t\t\t\t\t\t// categoryId\n\t\t\t\t\t\tfinal Long gradeCategoryId = assignmentCategoryMap.get(entry.getKey());\n\n\t\t\t\t\t\tlog.debug(\"Grade: \" + entry.getValue());\n\n\t\t\t\t\t\t// iterate the permissions\n\t\t\t\t\t\t// if category, compare the category,\n\t\t\t\t\t\t// then check the group and find the user in the group\n\t\t\t\t\t\t// if all ok, mark it as GRADEABLE\n\n\t\t\t\t\t\tboolean gradeable = false;\n\n\t\t\t\t\t\tfor (final PermissionDefinition permission : permissions) {\n\t\t\t\t\t\t\t// we know they are all GRADE so no need to check\n\t\t\t\t\t\t\t// here\n\n\t\t\t\t\t\t\tboolean categoryOk = false;\n\t\t\t\t\t\t\tboolean groupOk = false;\n\n\t\t\t\t\t\t\tfinal Long permissionCategoryId = permission.getCategoryId();\n\t\t\t\t\t\t\tfinal String permissionGroupReference = permission.getGroupReference();\n\n\t\t\t\t\t\t\tlog.debug(\"permissionCategoryId: \" + permissionCategoryId);\n\t\t\t\t\t\t\tlog.debug(\"permissionGroupReference: \" + permissionGroupReference);\n\n\t\t\t\t\t\t\t// if permissions category is null (can grade all categories) or they match (can grade this category)\n\t\t\t\t\t\t\tif (!categoriesEnabled || (permissionCategoryId == null || permissionCategoryId.equals(gradeCategoryId))) {\n\t\t\t\t\t\t\t\tcategoryOk = true;\n\t\t\t\t\t\t\t\tlog.debug(\"Category check passed\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if group reference is null (can grade all groups)\n\t\t\t\t\t\t\t// or group membership contains student (can grade\n\t\t\t\t\t\t\t// this group)\n\t\t\t\t\t\t\tif (StringUtils.isBlank(permissionGroupReference)) {\n\t\t\t\t\t\t\t\tgroupOk = true;\n\t\t\t\t\t\t\t\tlog.debug(\"Group check passed #1\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfinal List<String> groupMembers = groupMembershipsMap.get(permissionGroupReference);\n\t\t\t\t\t\t\t\tlog.debug(\"groupMembers: \" + groupMembers);\n\n\t\t\t\t\t\t\t\tif (groupMembers != null && groupMembers.contains(student.getId())) {\n\t\t\t\t\t\t\t\t\tgroupOk = true;\n\t\t\t\t\t\t\t\t\tlog.debug(\"Group check passed #2\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (categoryOk && groupOk) {\n\t\t\t\t\t\t\t\tgradeable = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// set the gradeable flag on this grade instance\n\t\t\t\t\t\tfinal GbGradeInfo gradeInfo = entry.getValue();\n\t\t\t\t\t\tgradeInfo.setGradeable(gradeable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"TA permissions applied\", stopwatch.getTime());\n\t\t}\n\n\t\t// get the matrix as a list of GbStudentGradeInfo\n\t\tfinal List<GbStudentGradeInfo> items = new ArrayList<>(matrix.values());\n\n\t\t// sort the matrix based on the supplied assignment sort order (if any)\n\t\tif (settings.getAssignmentSortOrder() != null) {\n\t\t\tfinal AssignmentGradeComparator comparator = new AssignmentGradeComparator();\n\t\t\tcomparator.setAssignmentId(settings.getAssignmentSortOrder().getAssignmentId());\n\n\t\t\tfinal SortDirection direction = settings.getAssignmentSortOrder().getDirection();\n\n\t\t\t// sort\n\t\t\tCollections.sort(items, comparator);\n\n\t\t\t// reverse if required\n\t\t\tif (direction == SortDirection.DESCENDING) {\n\t\t\t\tCollections.reverse(items);\n\t\t\t}\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix sorted by assignment\", stopwatch.getTime());\n\n\t\t// sort the matrix based on the supplied category sort order (if any)\n\t\tif (settings.getCategorySortOrder() != null) {\n\t\t\tfinal CategorySubtotalComparator comparator = new CategorySubtotalComparator();\n\t\t\tcomparator.setCategoryId(settings.getCategorySortOrder().getCategoryId());\n\n\t\t\tfinal SortDirection direction = settings.getCategorySortOrder().getDirection();\n\n\t\t\t// sort\n\t\t\tCollections.sort(items, comparator);\n\n\t\t\t// reverse if required\n\t\t\tif (direction == SortDirection.DESCENDING) {\n\t\t\t\tCollections.reverse(items);\n\t\t\t}\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix sorted by category\", stopwatch.getTime());\n\n\t\tif (settings.getCourseGradeSortOrder() != null) {\n\t\t\t// sort\n\t\t\tCollections.sort(items, new CourseGradeComparator());\n\n\t\t\t// reverse if required\n\t\t\tif (settings.getCourseGradeSortOrder() == SortDirection.DESCENDING) {\n\t\t\t\tCollections.reverse(items);\n\t\t\t}\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix sorted by course grade\", stopwatch.getTime());\n\n\t\treturn items;\n\t}","id":89175,"modified_method":"/**\n\t * Build the matrix of assignments and grades for the given users with the specified sort order\n\t *\n\t * @param assignments list of assignments\n\t * @param studentUuids student uuids\n\t * @param uiSettings the settings from the UI that wraps up preferences\n\t * @return\n\t */\n\tpublic List<GbStudentGradeInfo> buildGradeMatrix(final List<Assignment> assignments,\n\t\t\tfinal List<String> studentUuids, final GradebookUiSettings uiSettings) throws GbException {\n\n\t\t// TODO move GradebookUISettings to business\n\n\t\t// settings could be null depending on constructor so it needs to be corrected\n\t\tfinal GradebookUiSettings settings = (uiSettings != null) ? uiSettings : new GradebookUiSettings();\n\n\t\tfinal StopWatch stopwatch = new StopWatch();\n\t\tstopwatch.start();\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"buildGradeMatrix start\", stopwatch.getTime());\n\n\t\tfinal Gradebook gradebook = this.getGradebook();\n\t\tif (gradebook == null) {\n\t\t\treturn null;\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"getGradebook\", stopwatch.getTime());\n\n\t\tfinal boolean categoriesEnabled = categoriesAreEnabled();\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"categoriesAreEnabled\", stopwatch.getTime());\n\n\t\t// get current user\n\t\tfinal String currentUserUuid = getCurrentUser().getId();\n\n\t\t// get role for current user\n\t\tfinal GbRole role = this.getUserRole();\n\n\t\t// get uuids as list of Users.\n\t\t// this gives us our base list and will be sorted as per our desired\n\t\t// sort method\n\t\tfinal List<User> students = getUsers(studentUuids);\n\t\tif (settings.getNameSortOrder() != null) {\n\n\t\t\tif (settings.getNameSortOrder() == GbStudentNameSortOrder.LAST_NAME) {\n\t\t\t\tCollections.sort(students, new LastNameComparator());\n\t\t\t} else {\n\t\t\t\tCollections.sort(students, new FirstNameComparator());\n\t\t\t}\n\t\t}\n\n\t\t// get course grades\n\t\tfinal Map<String, CourseGrade> courseGrades = getCourseGrades(studentUuids);\n\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"getSiteCourseGrades\", stopwatch.getTime());\n\n\t\t// setup a map because we progressively build this up by adding grades\n\t\t// to a student's entry\n\t\tfinal Map<String, GbStudentGradeInfo> matrix = new LinkedHashMap<>();\n\n\t\t// setup the course grade formatter\n\t\t// TODO we want the override except in certain cases. Can we hard code this?\n\t\tfinal CourseGradeFormatter courseGradeFormatter = new CourseGradeFormatter(\n\t\t\t\tgradebook,\n\t\t\t\trole,\n\t\t\t\tisCourseGradeVisible(currentUserUuid),\n\t\t\t\tsettings.getShowPoints(),\n\t\t\t\ttrue);\n\n\t\t// seed the map for all students so we can progresseively add grades\n\t\t// also add the course grade here, to save an iteration later\n\t\t// TA permissions already included in course grade visibility\n\t\tfor (final User student : students) {\n\n\t\t\t// create and add the user info\n\t\t\tfinal GbStudentGradeInfo sg = new GbStudentGradeInfo(student);\n\n\t\t\t// add the course grade, including the display\n\t\t\tfinal CourseGrade courseGrade = courseGrades.get(student.getId());\n\t\t\tfinal GbCourseGrade gbCourseGrade = new GbCourseGrade(courseGrades.get(student.getId()));\n\t\t\tgbCourseGrade.setDisplayString(courseGradeFormatter.format(courseGrade));\n\t\t\tsg.setCourseGrade(gbCourseGrade);\n\n\t\t\t// add to map so we can build on it later\n\t\t\tmatrix.put(student.getId(), sg);\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix seeded\", stopwatch.getTime());\n\n\t\t// get categories. This call is filtered for TAs as well.\n\t\tfinal List<CategoryDefinition> categories = this.getGradebookCategories();\n\n\t\t// for TA's, build a lookup map of visible categoryIds so we can filter\n\t\t// the assignment list to not fetch grades\n\t\t// for assignments we don't have category level access to.\n\t\t// for everyone else this will just be an empty list that is unused\n\t\tfinal List<Long> categoryIds = new ArrayList<>();\n\n\t\tif (role == GbRole.TA) {\n\t\t\tfor (final CategoryDefinition category : categories) {\n\t\t\t\tcategoryIds.add(category.getId());\n\t\t\t}\n\t\t}\n\n\t\t// this holds a map of categoryId and the list of assignment ids in each\n\t\t// we build this whilst iterating below to save further iterations when\n\t\t// building the category list\n\t\tfinal Map<Long, Set<Long>> categoryAssignments = new TreeMap<>();\n\n\t\t// iterate over assignments and get the grades for each\n\t\t// note, the returned list only includes entries where there is a grade\n\t\t// for the user\n\t\t// we also build the category lookup map here\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal Long categoryId = assignment.getCategoryId();\n\t\t\tfinal Long assignmentId = assignment.getId();\n\n\t\t\t// TA permission check. If there are categories and they don't have\n\t\t\t// access to this one, skip it\n\t\t\tif (role == GbRole.TA) {\n\t\t\t\tif (!categoryIds.isEmpty() && !categoryIds.contains(categoryId)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TA stub out. So that we can support 'per grade' permissions for a\n\t\t\t// TA, we need a stub record for every student\n\t\t\t// This is because getGradesForStudentsForItem only returns records\n\t\t\t// where there is a grade (even if blank)\n\t\t\t// So this iteration for TAs allows the matrix to be fully\n\t\t\t// populated.\n\t\t\t// This is later updated to be a real grade entry if there is one.\n\t\t\tif (role == GbRole.TA) {\n\t\t\t\tfor (final User student : students) {\n\t\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(student.getId());\n\t\t\t\t\tsg.addGrade(assignment.getId(), new GbGradeInfo(null));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build the category map (if assignment is categorised)\n\t\t\tif (categoryId != null) {\n\t\t\t\tSet<Long> values;\n\t\t\t\tif (categoryAssignments.containsKey(categoryId)) {\n\t\t\t\t\tvalues = categoryAssignments.get(categoryId);\n\t\t\t\t\tvalues.add(assignmentId);\n\t\t\t\t} else {\n\t\t\t\t\tvalues = new HashSet<Long>();\n\t\t\t\t\tvalues.add(assignmentId);\n\t\t\t\t}\n\t\t\t\tcategoryAssignments.put(categoryId, values);\n\t\t\t}\n\n\t\t\t// get grades\n\t\t\tfinal List<GradeDefinition> defs = this.gradebookService.getGradesForStudentsForItem(gradebook.getUid(),\n\t\t\t\t\tassignment.getId(), studentUuids);\n\t\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"getGradesForStudentsForItem: \" + assignment.getId(),\n\t\t\t\t\tstopwatch.getTime());\n\n\t\t\t// iterate the definitions returned and update the record for each\n\t\t\t// student with the grades\n\t\t\tfor (final GradeDefinition def : defs) {\n\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(def.getStudentUid());\n\n\t\t\t\tif (sg == null) {\n\t\t\t\t\tlog.warn(\"No matrix entry seeded for: \" + def.getStudentUid()\n\t\t\t\t\t\t\t+ \". This user may be been removed from the site\");\n\t\t\t\t} else {\n\t\t\t\t\t// this will overwrite the stub entry for the TA matrix if\n\t\t\t\t\t// need be\n\t\t\t\t\tsg.addGrade(assignment.getId(), new GbGradeInfo(def));\n\t\t\t\t}\n\t\t\t}\n\t\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"updatedStudentGradeInfo: \" + assignment.getId(),\n\t\t\t\t\tstopwatch.getTime());\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix built\", stopwatch.getTime());\n\n\t\t// build category columns\n\t\tfor (final CategoryDefinition category : categories) {\n\n\t\t\t// use the category mappings for faster lookup of the assignmentIds\n\t\t\t// and grades in the category\n\t\t\tfinal Set<Long> categoryAssignmentIds = categoryAssignments.get(category.getId());\n\n\t\t\t// if there are no assignments in the category (ie its a new\n\t\t\t// category) this will be null, so skip\n\t\t\tif (categoryAssignmentIds != null) {\n\n\t\t\t\tfor (final User student : students) {\n\n\t\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(student.getId());\n\n\t\t\t\t\t// get grades\n\t\t\t\t\tfinal Map<Long, GbGradeInfo> grades = sg.getGrades();\n\n\t\t\t\t\t// build map of just the grades we want\n\t\t\t\t\tfinal Map<Long, String> gradeMap = new HashMap<>();\n\t\t\t\t\tfor (final Long assignmentId : categoryAssignmentIds) {\n\t\t\t\t\t\tfinal GbGradeInfo gradeInfo = grades.get(assignmentId);\n\t\t\t\t\t\tif (gradeInfo != null) {\n\t\t\t\t\t\t\tgradeMap.put(assignmentId, gradeInfo.getGrade());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal Double categoryScore = this.gradebookService.calculateCategoryScore(gradebook,\n\t\t\t\t\t\t\tstudent.getId(), category, assignments, gradeMap);\n\n\t\t\t\t\t// add to GbStudentGradeInfo\n\t\t\t\t\tsg.addCategoryAverage(category.getId(), categoryScore);\n\n\t\t\t\t\t// TODO the TA permission check could reuse this\n\t\t\t\t\t// iteration... check performance.\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"categories built\", stopwatch.getTime());\n\n\t\t// course grade override. if no grades, course grade should be - instead\n\t\t// of 'F'\n\t\t// TODO this iteration may not be necessary as we could instead\n\t\t// add a boolean to the GbStudentGradeInfo object for each student and\n\t\t// when calling addGrade set it to true\n\t\t// then check the boolean on the front end, but then it needs to be\n\t\t// checked everywhere so this may be better.\n\t\t// for (final User student : students) {\n\t\t// final GbStudentGradeInfo sg = matrix.get(student.getId());\n\t\t//\n\t\t// if (sg.getGrades().isEmpty()) {\n\t\t// sg.setCourseGrade(\"-\");\n\t\t// }\n\t\t// }\n\t\t// Temp.timeWithContext(\"buildGradeMatrix\", \"course grade override\n\t\t// done\", stopwatch.getTime());\n\n\t\t// for a TA, apply the permissions to each grade item to see if we can\n\t\t// render it\n\t\t// the list of students, assignments and grades is already filtered to\n\t\t// those that can be viewed\n\t\t// so we are only concerned with the gradeable permission\n\t\tif (role == GbRole.TA) {\n\n\t\t\t// get permissions\n\t\t\tfinal List<PermissionDefinition> permissions = getPermissionsForUser(currentUserUuid);\n\n\t\t\t// only need to process this if some are defined\n\t\t\t// again only concerned with grade permission, so parse the list to\n\t\t\t// remove those that aren't GRADE\n\t\t\tif (!permissions.isEmpty()) {\n\n\t\t\t\tfinal Iterator<PermissionDefinition> iter = permissions.iterator();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tfinal PermissionDefinition permission = iter.next();\n\t\t\t\t\tif (!StringUtils.equalsIgnoreCase(GraderPermission.GRADE.toString(), permission.getFunction())) {\n\t\t\t\t\t\titer.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we still have permissions, they will be of type grade, so we\n\t\t\t// need to enrich the students grades\n\t\t\tif (!permissions.isEmpty()) {\n\n\t\t\t\tlog.debug(\"Grade permissions exist, processing: \" + permissions.size());\n\n\t\t\t\t// first need a lookup map of assignment id to category so we\n\t\t\t\t// can link up permissions by category\n\t\t\t\tfinal Map<Long, Long> assignmentCategoryMap = new HashMap<>();\n\t\t\t\tfor (final Assignment assignment : assignments) {\n\t\t\t\t\tassignmentCategoryMap.put(assignment.getId(), assignment.getCategoryId());\n\t\t\t\t}\n\n\t\t\t\t// get the group membership for the students\n\t\t\t\tfinal Map<String, List<String>> groupMembershipsMap = getGroupMemberships();\n\n\t\t\t\t// for every student\n\t\t\t\tfor (final User student : students) {\n\n\t\t\t\t\tlog.debug(\"Processing student: \" + student.getEid());\n\n\t\t\t\t\tfinal GbStudentGradeInfo sg = matrix.get(student.getId());\n\n\t\t\t\t\t// get their assignment/grade list\n\t\t\t\t\tfinal Map<Long, GbGradeInfo> gradeMap = sg.getGrades();\n\n\t\t\t\t\t// for every assignment that has a grade\n\t\t\t\t\tfor (final Map.Entry<Long, GbGradeInfo> entry : gradeMap.entrySet()) {\n\n\t\t\t\t\t\t// categoryId\n\t\t\t\t\t\tfinal Long gradeCategoryId = assignmentCategoryMap.get(entry.getKey());\n\n\t\t\t\t\t\tlog.debug(\"Grade: \" + entry.getValue());\n\n\t\t\t\t\t\t// iterate the permissions\n\t\t\t\t\t\t// if category, compare the category,\n\t\t\t\t\t\t// then check the group and find the user in the group\n\t\t\t\t\t\t// if all ok, mark it as GRADEABLE\n\n\t\t\t\t\t\tboolean gradeable = false;\n\n\t\t\t\t\t\tfor (final PermissionDefinition permission : permissions) {\n\t\t\t\t\t\t\t// we know they are all GRADE so no need to check\n\t\t\t\t\t\t\t// here\n\n\t\t\t\t\t\t\tboolean categoryOk = false;\n\t\t\t\t\t\t\tboolean groupOk = false;\n\n\t\t\t\t\t\t\tfinal Long permissionCategoryId = permission.getCategoryId();\n\t\t\t\t\t\t\tfinal String permissionGroupReference = permission.getGroupReference();\n\n\t\t\t\t\t\t\tlog.debug(\"permissionCategoryId: \" + permissionCategoryId);\n\t\t\t\t\t\t\tlog.debug(\"permissionGroupReference: \" + permissionGroupReference);\n\n\t\t\t\t\t\t\t// if permissions category is null (can grade all categories) or they match (can grade this category)\n\t\t\t\t\t\t\tif (!categoriesEnabled || (permissionCategoryId == null || permissionCategoryId.equals(gradeCategoryId))) {\n\t\t\t\t\t\t\t\tcategoryOk = true;\n\t\t\t\t\t\t\t\tlog.debug(\"Category check passed\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if group reference is null (can grade all groups)\n\t\t\t\t\t\t\t// or group membership contains student (can grade\n\t\t\t\t\t\t\t// this group)\n\t\t\t\t\t\t\tif (StringUtils.isBlank(permissionGroupReference)) {\n\t\t\t\t\t\t\t\tgroupOk = true;\n\t\t\t\t\t\t\t\tlog.debug(\"Group check passed #1\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfinal List<String> groupMembers = groupMembershipsMap.get(permissionGroupReference);\n\t\t\t\t\t\t\t\tlog.debug(\"groupMembers: \" + groupMembers);\n\n\t\t\t\t\t\t\t\tif (groupMembers != null && groupMembers.contains(student.getId())) {\n\t\t\t\t\t\t\t\t\tgroupOk = true;\n\t\t\t\t\t\t\t\t\tlog.debug(\"Group check passed #2\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (categoryOk && groupOk) {\n\t\t\t\t\t\t\t\tgradeable = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// set the gradeable flag on this grade instance\n\t\t\t\t\t\tfinal GbGradeInfo gradeInfo = entry.getValue();\n\t\t\t\t\t\tgradeInfo.setGradeable(gradeable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"TA permissions applied\", stopwatch.getTime());\n\t\t}\n\n\t\t// get the matrix as a list of GbStudentGradeInfo\n\t\tfinal List<GbStudentGradeInfo> items = new ArrayList<>(matrix.values());\n\n\t\t// sort the matrix based on the supplied assignment sort order (if any)\n\t\tif (settings.getAssignmentSortOrder() != null) {\n\t\t\tfinal AssignmentGradeComparator comparator = new AssignmentGradeComparator();\n\t\t\tcomparator.setAssignmentId(settings.getAssignmentSortOrder().getAssignmentId());\n\n\t\t\tfinal SortDirection direction = settings.getAssignmentSortOrder().getDirection();\n\n\t\t\t// sort\n\t\t\tCollections.sort(items, comparator);\n\n\t\t\t// reverse if required\n\t\t\tif (direction == SortDirection.DESCENDING) {\n\t\t\t\tCollections.reverse(items);\n\t\t\t}\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix sorted by assignment\", stopwatch.getTime());\n\n\t\t// sort the matrix based on the supplied category sort order (if any)\n\t\tif (settings.getCategorySortOrder() != null) {\n\t\t\tfinal CategorySubtotalComparator comparator = new CategorySubtotalComparator();\n\t\t\tcomparator.setCategoryId(settings.getCategorySortOrder().getCategoryId());\n\n\t\t\tfinal SortDirection direction = settings.getCategorySortOrder().getDirection();\n\n\t\t\t// sort\n\t\t\tCollections.sort(items, comparator);\n\n\t\t\t// reverse if required\n\t\t\tif (direction == SortDirection.DESCENDING) {\n\t\t\t\tCollections.reverse(items);\n\t\t\t}\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix sorted by category\", stopwatch.getTime());\n\n\t\tif (settings.getCourseGradeSortOrder() != null) {\n\t\t\t// sort\n\t\t\tCollections.sort(items, new CourseGradeComparator(getGradebookSettings()));\n\n\t\t\t// reverse if required\n\t\t\tif (settings.getCourseGradeSortOrder() == SortDirection.DESCENDING) {\n\t\t\t\tCollections.reverse(items);\n\t\t\t}\n\t\t}\n\t\tTemp.timeWithContext(\"buildGradeMatrix\", \"matrix sorted by course grade\", stopwatch.getTime());\n\n\t\treturn items;\n\t}","commit_id":"911bed76d7f01974bf2aa65da38888094574db84","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\t\tpublic int compare(final GbStudentGradeInfo g1, final GbStudentGradeInfo g2) {\n\t\t\treturn new CompareToBuilder()\n\t\t\t\t\t.append(g1.getCourseGrade().getDisplayString(), g2.getCourseGrade().getDisplayString())\n\t\t\t\t\t.toComparison();\n\t\t}","id":89176,"modified_method":"@Override\n\t\tpublic int compare(final GbStudentGradeInfo g1, final GbStudentGradeInfo g2) {\n\t\t\tCourseGrade cg1 = g1.getCourseGrade().getCourseGrade();\n\t\t\tCourseGrade cg2 = g2.getCourseGrade().getCourseGrade();\n\n\t\t\tString letterGrade1 = cg1.getMappedGrade();\n\t\t\tif (cg1.getEnteredGrade() != null) {\n\t\t\t\tletterGrade1 = cg1.getEnteredGrade();\n\t\t\t}\n\t\t\tString letterGrade2 = cg2.getMappedGrade();\n\t\t\tif (cg2.getEnteredGrade() != null) {\n\t\t\t\tletterGrade2 = cg2.getEnteredGrade();\n\t\t\t}\n\n\t\t\treturn new CompareToBuilder()\n\t\t\t\t\t.append(ascendingGrades.indexOf(letterGrade1), ascendingGrades.indexOf(letterGrade2))\n\t\t\t\t\t.append(ascendingGrades.indexOf(cg1.getPointsEarned()), ascendingGrades.indexOf(cg2.getPointsEarned()))\n\t\t\t\t\t.toComparison();\n\t\t}","commit_id":"911bed76d7f01974bf2aa65da38888094574db84","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this)\n            .append(\"name\", getName())\n            .append(\"scan-interval\", getScanInterval())\n            .append(\"detectors\", getDetectors().toArray(OF_PLUGIN_CONFIGS))\n            .append(\"policies\", getPolicies().toArray(OF_PLUGIN_CONFIGS))\n            .toString();\n    }","id":89177,"modified_method":"@Override\n    public String toString() {\n        return \"ForeignSource [name=\" + m_name + \", dateStamp=\"\n                + m_dateStamp + \", scanInterval=\" + m_scanInterval\n                + \", detectors=\" + m_detectors + \", policies=\"\n                + m_policies + \", default=\" + m_default + \"]\";\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>compareTo<\/p>\n     *\n     * @param obj a {@link org.opennms.netmgt.provision.persist.foreignsource.ForeignSource} object.\n     * @return a int.\n     */\n    public int compareTo(final ForeignSource obj) {\n        return new CompareToBuilder()\n            .append(getName(), obj.getName())\n            .toComparison();\n    }","id":89178,"modified_method":"@Override\n    public int compareTo(final ForeignSource other) {\n        return new CompareToBuilder()\n            .append(m_name, other.m_name)\n            .append(m_default, other.m_default)\n            .append(m_scanInterval, other.m_scanInterval)\n            .append(m_detectors, other.m_detectors)\n            .append(m_policies, other.m_policies)\n            .toComparison();\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder()\n            .append(getName())\n            .append(getPluginClass())\n            .append(getParametersAsString())\n            .toHashCode();\n      }","id":89179,"modified_method":"@Override\n    public int hashCode() {\n        final int prime = 107;\n        int result = 1;\n        result = prime * result + ((m_name == null) ? 0 : m_name.hashCode());\n        result = prime * result + ((m_pluginClass == null) ? 0 : m_pluginClass.hashCode());\n        result = prime * result + ((m_parameters == null) ? 0 : m_parameters.hashCode());\n        return result;\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this)\n            .append(\"name\", getName())\n            .append(\"plugin-class\", getPluginClass())\n            .append(\"parameters\", getParametersAsString())\n            .toString();\n    }","id":89180,"modified_method":"@Override\n    public String toString() {\n        return \"PluginConfig [name=\" + m_name + \", pluginClass=\"\n                + m_pluginClass + \", parameters=\" + getParametersAsString() + \"]\";\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof PluginConfig) {\n            PluginConfig other = (PluginConfig) obj;\n            return new EqualsBuilder()\n                .append(getName(), other.getName())\n                .append(getPluginClass(), other.getPluginClass())\n                .append(getParametersAsString(), other.getParametersAsString())\n                .isEquals();\n        }\n        return false;\n    }","id":89181,"modified_method":"@Override\n    public boolean equals(final Object obj) {\n        if (this == obj) return true;\n        if (obj == null) return false;\n        if (!(obj instanceof PluginConfig)) return false;\n        final PluginConfig other = (PluginConfig) obj;\n        if (m_name == null) {\n            if (other.m_name != null) return false;\n        } else if (!m_name.equals(other.m_name)) {\n            return false;\n        }\n        if (m_pluginClass == null) {\n            if (other.m_pluginClass != null) return false;\n        } else if (!m_pluginClass.equals(other.m_pluginClass)) {\n            return false;\n        }\n        if (m_parameters == null) {\n            if (other.m_parameters != null) return false;\n        } else if (!m_parameters.equals(other.m_parameters)) {\n            return false;\n        }\n        return true;\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>compareTo<\/p>\n     *\n     * @param obj a {@link org.opennms.netmgt.provision.persist.foreignsource.PluginConfig} object.\n     * @return a int.\n     */\n    public int compareTo(PluginConfig obj) {\n        return new CompareToBuilder()\n            .append(getName(), obj.getName())\n            .append(getPluginClass(), obj.getPluginClass())\n            .append(getParametersAsString(), obj.getParametersAsString())\n            .toComparison();\n    }","id":89182,"modified_method":"@Override\n    public int compareTo(final PluginConfig other) {\n        return new CompareToBuilder()\n            .append(m_name, other.m_name)\n            .append(m_pluginClass, other.m_pluginClass)\n            .toComparison();\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getParametersAsString() {\n        StringBuilder sb = new StringBuilder();\n        for (PluginParameter p : getParameters()) {\n            sb.append(p.getKey()).append('=').append(p.getValue()).append('/');\n        }\n        if (sb.length() > 0) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }","id":89183,"modified_method":"private String getParametersAsString() {\n        final StringBuilder sb = new StringBuilder();\n        for (final PluginParameter p : getParameters()) {\n            sb.append(p.getKey()).append('=').append(p.getValue()).append('/');\n        }\n        if (sb.length() > 0) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof PluginParameter) {\n            PluginParameter other = (PluginParameter) obj;\n            return new EqualsBuilder()\n                .append(getKey(), other.getKey())\n                .append(getValue(), other.getValue())\n                .isEquals();\n        }\n        return false;\n    }","id":89184,"modified_method":"@Override\n    public boolean equals(final Object obj) {\n        if (this == obj) return true;\n        if (obj == null) return false;\n        if (!(obj instanceof PluginParameter)) return false;\n        final PluginParameter other = (PluginParameter) obj;\n        if (m_key == null) {\n            if (other.m_key != null) return false;\n        } else if (!m_key.equals(other.m_key)) {\n            return false;\n        }\n        if (m_value == null) {\n            if (other.m_value != null) return false;\n        } else if (!m_value.equals(other.m_value)) {\n            return false;\n        }\n        return true;\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return new ToStringBuilder(this)\n            .append(\"key\", getKey())\n            .append(\"value\", getValue())\n            .toString();\n    }","id":89185,"modified_method":"@Override\n    public String toString() {\n        return \"PluginParameter [key=\" + m_key + \", value=\" + m_value + \"]\";\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public int hashCode() {\n        return new HashCodeBuilder(701, 1873)\n            .append(getKey())\n            .append(getValue())\n            .toHashCode();\n      }","id":89186,"modified_method":"@Override\n    public int hashCode() {\n        final int prime = 421;\n        int result = 1;\n        result = prime * result + ((m_key == null) ? 0 : m_key.hashCode());\n        result = prime * result + ((m_value == null) ? 0 : m_value.hashCode());\n        return result;\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>compareTo<\/p>\n     *\n     * @param obj a {@link org.opennms.netmgt.provision.persist.foreignsource.PluginParameter} object.\n     * @return a int.\n     */\n    public int compareTo(PluginParameter obj) {\n        return new CompareToBuilder()\n            .append(getKey(), obj.getKey())\n            .toComparison();\n    }","id":89187,"modified_method":"@Override\n    public int compareTo(final PluginParameter other) {\n        return new CompareToBuilder()\n            .append(m_key, other.m_key)\n            .append(m_value, other.m_value)\n            .toComparison();\n    }","commit_id":"54ba5b15622209863e3dfba443ffe2fbc6078e6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public int compareTo(final ForeignSource other) {\n        return new CompareToBuilder()\n            .append(m_name, other.m_name)\n            .append(m_default, other.m_default)\n            .append(m_scanInterval, other.m_scanInterval)\n            .append(m_detectors, other.m_detectors)\n            .append(m_policies, other.m_policies)\n            .toComparison();\n    }","id":89188,"modified_method":"@Override\n    public int compareTo(final ForeignSource other) {\n        return new CompareToBuilder()\n            .append(m_name, other.m_name)\n            .toComparison();\n    }","commit_id":"eccf807e1ed20c626d987cd4537690bb2e3235f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Enriches the input data (<code>exchange<\/code>) by first obtaining\n     * additional data from an endpoint represented by an endpoint\n     * <code>producer<\/code> and second by aggregating input data and additional\n     * data. Aggregation of input data and additional data is delegated to an\n     * {@link AggregationStrategy} object set at construction time. If the\n     * message exchange with the resource endpoint fails then no aggregation\n     * will be done and the failed exchange content is copied over to the\n     * original message exchange.\n     * \n     * @param exchange input data.\n     */\n    public void process(Exchange exchange) throws Exception {\n        Exchange resourceExchange = createResourceExchange(exchange, ExchangePattern.InOut);\n        producer.process(resourceExchange);\n\n        if (resourceExchange.isFailed()) {\n            // copy resource exchange onto original exchange (preserving pattern)\n            copyResultsPreservePattern(exchange, resourceExchange);\n        } else {\n            prepareResult(exchange);\n\n            // aggregate original exchange and resource exchange\n            // but do not aggregate if the resource exchange was filtered\n            Boolean filtered = resourceExchange.getProperty(Exchange.FILTERED, Boolean.class);\n            if (filtered == null || !filtered) {\n                // prepare the exchanges for aggregation\n                ExchangeHelper.prepareAggregation(exchange, resourceExchange);\n                Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange);\n                // copy aggregation result onto original exchange (preserving pattern)\n                copyResultsPreservePattern(exchange, aggregatedExchange);\n            } else {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cannot aggregate exchange as its filtered: \" + resourceExchange);\n                }\n            }\n        }\n    }","id":89189,"modified_method":"/**\n     * Enriches the input data (<code>exchange<\/code>) by first obtaining\n     * additional data from an endpoint represented by an endpoint\n     * <code>producer<\/code> and second by aggregating input data and additional\n     * data. Aggregation of input data and additional data is delegated to an\n     * {@link AggregationStrategy} object set at construction time. If the\n     * message exchange with the resource endpoint fails then no aggregation\n     * will be done and the failed exchange content is copied over to the\n     * original message exchange.\n     * \n     * @param exchange input data.\n     */\n    public void process(Exchange exchange) throws Exception {\n        Exchange resourceExchange = createResourceExchange(exchange, ExchangePattern.InOut);\n        producer.process(resourceExchange);\n\n        if (resourceExchange.isFailed()) {\n            // copy resource exchange onto original exchange (preserving pattern)\n            copyResultsPreservePattern(exchange, resourceExchange);\n        } else {\n            prepareResult(exchange);\n\n            // aggregate original exchange and resource exchange\n            // but do not aggregate if the resource exchange was filtered\n            Boolean filtered = resourceExchange.getProperty(Exchange.FILTERED, Boolean.class);\n            if (filtered == null || !filtered) {\n                // prepare the exchanges for aggregation\n                ExchangeHelper.prepareAggregation(exchange, resourceExchange);\n                Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange);\n                if (aggregatedExchange != null) {\n                    // copy aggregation result onto original exchange (preserving pattern)\n                    copyResultsPreservePattern(exchange, aggregatedExchange);\n                }\n            } else {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cannot aggregate exchange as its filtered: \" + resourceExchange);\n                }\n            }\n        }\n    }","commit_id":"b3763ddc378149d7cd995a7ed66543264f5b7e03","url":"https://github.com/apache/camel"},{"original_method":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n            copyResultsPreservePattern(oldExchange, newExchange);\n            return oldExchange;\n        }","id":89190,"modified_method":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n            if (newExchange != null) {\n                copyResultsPreservePattern(oldExchange, newExchange);\n            }\n            return oldExchange;\n        }","commit_id":"b3763ddc378149d7cd995a7ed66543264f5b7e03","url":"https://github.com/apache/camel"},{"original_method":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n            copyResultsPreservePattern(oldExchange, newExchange);\n            return oldExchange;\n        }","id":89191,"modified_method":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n            if (newExchange != null) {\n                copyResultsPreservePattern(oldExchange, newExchange);\n            }\n            return oldExchange;\n        }","commit_id":"b3763ddc378149d7cd995a7ed66543264f5b7e03","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy to pre check polling.\n     * <p/>\n     * Is currently used to prevent doing poll enrich from a file based endpoint when the current route also\n     * started from a file based endpoint as that is not currently supported.\n     *\n     * @param exchange the current exchange\n     */\n    protected void preChceckPoll(Exchange exchange) throws Exception {\n        // cannot poll a file endpoint if already consuming from a file endpoint (CAMEL-1895)\n        if (consumer instanceof EventDrivenPollingConsumer) {\n            EventDrivenPollingConsumer edpc = (EventDrivenPollingConsumer) consumer;\n            boolean fileBasedConsumer = edpc.getEndpoint().getEndpointKey().startsWith(\"file\") || edpc.getEndpoint().getEndpointKey().startsWith(\"ftp\");\n            boolean fileBasedExchange = exchange.getFromEndpoint().getEndpointUri().startsWith(\"file\") || exchange.getFromEndpoint().getEndpointUri().startsWith(\"ftp\");\n            if (fileBasedConsumer && fileBasedExchange) {\n                throw new IllegalArgumentException(\"Camel durrently does not support pollEnrich from a file/ftp endpoint\"\n                        + \" when the route also started from a file/ftp endpoint.\"\n                        + \" Started from: \" + exchange.getFromEndpoint().getEndpointUri() + \" pollEnrich: \" + edpc.getEndpoint().getEndpointUri());\n            }\n        }\n    }","id":89192,"modified_method":"/**\n     * Strategy to pre check polling.\n     * <p/>\n     * Is currently used to prevent doing poll enrich from a file based endpoint when the current route also\n     * started from a file based endpoint as that is not currently supported.\n     *\n     * @param exchange the current exchange\n     */\n    protected void preChceckPoll(Exchange exchange) throws Exception {\n        // cannot poll a file endpoint if already consuming from a file endpoint (CAMEL-1895)\n        if (consumer instanceof EventDrivenPollingConsumer) {\n            EventDrivenPollingConsumer edpc = (EventDrivenPollingConsumer) consumer;\n            boolean fileBasedConsumer = edpc.getEndpoint().getEndpointKey().startsWith(\"file\") || edpc.getEndpoint().getEndpointKey().startsWith(\"ftp\");\n            boolean fileBasedExchange = exchange.getFromEndpoint().getEndpointUri().startsWith(\"file\") || exchange.getFromEndpoint().getEndpointUri().startsWith(\"ftp\");\n            if (fileBasedConsumer && fileBasedExchange) {\n                throw new IllegalArgumentException(\"Camel currently does not support pollEnrich from a file/ftp endpoint\"\n                        + \" when the route also started from a file/ftp endpoint.\"\n                        + \" Started from: \" + exchange.getFromEndpoint().getEndpointUri() + \" pollEnrich: \" + edpc.getEndpoint().getEndpointUri());\n            }\n        }\n    }","commit_id":"b3763ddc378149d7cd995a7ed66543264f5b7e03","url":"https://github.com/apache/camel"},{"original_method":"public Exchange receiveNoWait() {\n        // spring have changed the sematic of the receive timeout mode\n        // so we need to deterime if running spring 2.0.x or 2.5.x or newer\n        if (spring20x) {\n            // spring 2.0.x\n            return receive(0L);\n        } else {\n            // spring 2.5.x\n            return receive(-1L);\n        }\n    }","id":89193,"modified_method":"public Exchange receiveNoWait() {\n        // spring have changed the semantic of the receive timeout mode\n        // so we need to determine if running spring 2.0.x or 2.5.x or newer\n        if (spring20x) {\n            // spring 2.0.x\n            return receive(0L);\n        } else {\n            // spring 2.5.x\n            // no wait using -1L does not work properly so wait at most 1 millis to simulate no wait\n            return receive(1);\n        }\n    }","commit_id":"a4c6174edb61fcd26e830e380ba79843e6e3ddae","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testJmsPollingConsumer() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello Claus\");\n\n        // use another thread for polling consumer to demonstrate that we can wait before\n        // the message is sent to the quueue\n        Executors.newSingleThreadExecutor().execute(new Runnable() {\n            public void run() {\n                String body = consumer.receiveBody(\"activemq:queue.start\", String.class);\n                template.sendBody(\"activemq:queue.foo\", body + \" Claus\");\n            }\n        });\n\n        // wait a little to demonstrate we can start poll before we have a msg on the queue\n        Thread.sleep(50);\n\n        template.sendBody(\"direct:start\", \"Hello\");\n\n        assertMockEndpointsSatisfied();\n    }","id":89194,"modified_method":"@Test\n    public void testJmsPollingConsumerWait() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedBodiesReceived(\"Hello Claus\");\n\n        // use another thread for polling consumer to demonstrate that we can wait before\n        // the message is sent to the queue\n        Executors.newSingleThreadExecutor().execute(new Runnable() {\n            public void run() {\n                String body = consumer.receiveBody(\"activemq:queue.start\", String.class);\n                template.sendBody(\"activemq:queue.foo\", body + \" Claus\");\n            }\n        });\n\n        // wait a little to demonstrate we can start poll before we have a msg on the queue\n        Thread.sleep(500);\n\n        template.sendBody(\"direct:start\", \"Hello\");\n\n        assertMockEndpointsSatisfied();\n    }","commit_id":"a4c6174edb61fcd26e830e380ba79843e6e3ddae","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Enriches the input data (<code>exchange<\/code>) by first obtaining\n     * additional data from an endpoint represented by an endpoint\n     * <code>producer<\/code> and second by aggregating input data and additional\n     * data. Aggregation of input data and additional data is delegated to an\n     * {@link org.apache.camel.processor.aggregate.AggregationStrategy} object set at construction time. If the\n     * message exchange with the resource endpoint fails then no aggregation\n     * will be done and the failed exchange content is copied over to the\n     * original message exchange.\n     *\n     * @param exchange input data.\n     */\n    public void process(Exchange exchange) throws Exception {\n        preChceckPoll(exchange);\n\n        Exchange resourceExchange;\n        if (timeout < 0) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Consumer receive: \" + consumer);\n            }\n            resourceExchange = consumer.receive();\n        } else if (timeout == 0) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Consumer receiveNoWait: \" + consumer);\n            }\n            resourceExchange = consumer.receiveNoWait();\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Consumer receive with timeout: \" + timeout + \" ms. \" + consumer);\n            }\n            resourceExchange = consumer.receive(timeout);\n        }\n\n        if (resourceExchange != null && resourceExchange.isFailed()) {\n            // copy resource exchange onto original exchange (preserving pattern)\n            copyResultsPreservePattern(exchange, resourceExchange);\n        } else {\n            prepareResult(exchange);\n\n            // aggregate original exchange and resource exchange\n            // but do not aggregate if the resource exchange was filtered\n            Boolean filtered = null;\n            if (resourceExchange != null) {\n                filtered = resourceExchange.getProperty(Exchange.FILTERED, Boolean.class);\n            }\n            if (filtered == null || !filtered) {\n                // prepare the exchanges for aggregation\n                ExchangeHelper.prepareAggregation(exchange, resourceExchange);\n                Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange);\n                // copy aggregation result onto original exchange (preserving pattern)\n                copyResultsPreservePattern(exchange, aggregatedExchange);\n            } else {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cannot aggregate exchange as its filtered: \" + resourceExchange);\n                }\n            }\n        }\n    }","id":89195,"modified_method":"/**\n     * Enriches the input data (<code>exchange<\/code>) by first obtaining\n     * additional data from an endpoint represented by an endpoint\n     * <code>producer<\/code> and second by aggregating input data and additional\n     * data. Aggregation of input data and additional data is delegated to an\n     * {@link org.apache.camel.processor.aggregate.AggregationStrategy} object set at construction time. If the\n     * message exchange with the resource endpoint fails then no aggregation\n     * will be done and the failed exchange content is copied over to the\n     * original message exchange.\n     *\n     * @param exchange input data.\n     */\n    public void process(Exchange exchange) throws Exception {\n        preChceckPoll(exchange);\n\n        Exchange resourceExchange;\n        if (timeout < 0) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Consumer receive: \" + consumer);\n            }\n            resourceExchange = consumer.receive();\n        } else if (timeout == 0) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Consumer receiveNoWait: \" + consumer);\n            }\n            resourceExchange = consumer.receiveNoWait();\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Consumer receive with timeout: \" + timeout + \" ms. \" + consumer);\n            }\n            resourceExchange = consumer.receive(timeout);\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (resourceExchange == null) {\n                LOG.debug(\"Consumer received no exchange\");\n            } else {\n                LOG.debug(\"Consumer received: \" + resourceExchange);\n            }\n        }\n\n        if (resourceExchange != null && resourceExchange.isFailed()) {\n            // copy resource exchange onto original exchange (preserving pattern)\n            copyResultsPreservePattern(exchange, resourceExchange);\n        } else {\n            prepareResult(exchange);\n\n            // aggregate original exchange and resource exchange\n            // but do not aggregate if the resource exchange was filtered\n            Boolean filtered = null;\n            if (resourceExchange != null) {\n                filtered = resourceExchange.getProperty(Exchange.FILTERED, Boolean.class);\n            }\n            if (filtered == null || !filtered) {\n                // prepare the exchanges for aggregation\n                ExchangeHelper.prepareAggregation(exchange, resourceExchange);\n                Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange);\n                if (aggregatedExchange != null) {\n                    // copy aggregation result onto original exchange (preserving pattern)\n                    copyResultsPreservePattern(exchange, aggregatedExchange);\n                }\n            } else {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Cannot aggregate exchange as its filtered: \" + resourceExchange);\n                }\n            }\n        }\n    }","commit_id":"a4c6174edb61fcd26e830e380ba79843e6e3ddae","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        // lookup in registry\n        if (ObjectHelper.isNotEmpty(comparatorRef)) {\n            comparator = routeContext.getCamelContext().getRegistry().lookup(comparatorRef, Comparator.class);\n        }\n\n        // if no comparator then default on to string representation\n        if (comparator == null) {\n            comparator = new Comparator() {\n                public int compare(Object o1, Object o2) {\n                    return ObjectHelper.compare(o1, o2);\n                }\n            };\n        }\n\n        // if no expression provided then default to body expression\n        if (getExpression() == null) {\n            setExpression(bodyExpression());\n        }\n\n        Expression exp = expression.getExpression();\n        return new SortProcessor(exp, getComparator());\n    }","id":89196,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        // lookup in registry\n        if (ObjectHelper.isNotEmpty(comparatorRef)) {\n            comparator = routeContext.getCamelContext().getRegistry().lookup(comparatorRef, Comparator.class);\n        }\n\n        // if no comparator then default on to string representation\n        if (comparator == null) {\n            comparator = new Comparator() {\n                public int compare(Object o1, Object o2) {\n                    return ObjectHelper.compare(o1, o2);\n                }\n            };\n        }\n\n        // if no expression provided then default to body expression\n        if (getExpression() == null) {\n            setExpression(bodyExpression());\n        }\n\n        Expression exp = expression.getExpression();\n        // fallback to the type when its been initialized from JAXB using camel-spring\n        if (exp == null) {\n            exp = expression.getExpressionType();\n        }\n        return new SortProcessor(exp, getComparator());\n    }","commit_id":"a4c6174edb61fcd26e830e380ba79843e6e3ddae","url":"https://github.com/apache/camel"},{"original_method":"public static ImageInfo createFromDeviceMapping( UserFullName userFullName, String rootDeviceName, final List<BlockDeviceMappingItemType> blockDeviceMappings ) throws EucalyptusCloudException {\n    Context ctx = Contexts.lookup( );\n    BlockDeviceMappingItemType rootBlockDevice = Iterables.find( blockDeviceMappings, findEbsRoot( rootDeviceName ) );\n    String snapshotId = rootBlockDevice.getEbs( ).getSnapshotId( );\n    try {\n      Snapshot snap = Snapshots.lookup( userFullName, snapshotId );\n      if ( !userFullName.getUserId( ).equals( snap.getOwnerUserId( ) ) ) {\n        throw new EucalyptusCloudException( \"Failed to create image from specified block device mapping: \" + rootBlockDevice\n                                            + \" because of: you must the owner of the source snapshot.\" );\n      }\n      Integer snapVolumeSize = snap.getVolumeSize( );\n      Integer suppliedVolumeSize = rootBlockDevice.getEbs( ).getVolumeSize( );\n      suppliedVolumeSize = ( suppliedVolumeSize == null ) ? rootBlockDevice.getSize( ) : suppliedVolumeSize;\n      Integer targetVolumeSize = ( snapVolumeSize <= suppliedVolumeSize ) ? suppliedVolumeSize : snapVolumeSize;\n      Boolean targetDeleteOnTermination = Boolean.TRUE.equals( rootBlockDevice.getEbs( ).getDeleteOnTermination( ) );\n      BlockStorageImageInfo ret = new BlockStorageImageInfo( generateImageId( Image.Type.machine.getTypePrefix( ), snapshotId ),\n                                                             snap.getDisplayName( ), targetVolumeSize, targetDeleteOnTermination );\n      ret = Transactions.save( ret, new Callback<BlockStorageImageInfo>( ) {\n        \n        @Override\n        public void fire( BlockStorageImageInfo t ) {\n          t.getDeviceMappings( ).addAll( Lists.transform( blockDeviceMappings, Images.deviceMappingGenerator( t ) ) );\n        }\n      } );\n      return ret;\n    } catch ( TransactionFireException ex ) {\n      throw new EucalyptusCloudException( \"Failed to create image from specified block device mapping: \" + rootBlockDevice + \" because of: \" + ex.getMessage( ) );\n    } catch ( ExecutionException ex ) {\n      LOG.error( ex, ex );\n      throw new EucalyptusCloudException( \"Failed to create image from specified block device mapping: \" + rootBlockDevice + \" because of: \" + ex.getMessage( ) );\n    }\n  }","id":89197,"modified_method":"public static ImageInfo createFromDeviceMapping( UserFullName userFullName, String rootDeviceName, final List<BlockDeviceMappingItemType> blockDeviceMappings ) throws EucalyptusCloudException {\n    Context ctx = Contexts.lookup( );\n    BlockDeviceMappingItemType rootBlockDevice = Iterables.find( blockDeviceMappings, findEbsRoot( rootDeviceName ) );\n    String snapshotId = rootBlockDevice.getEbs( ).getSnapshotId( );\n    try {\n      Snapshot snap = Snapshots.lookup( userFullName, snapshotId );\n      if ( !userFullName.getUserId( ).equals( snap.getOwnerUserId( ) ) ) {\n        throw new EucalyptusCloudException( \"Failed to create image from specified block device mapping: \" + rootBlockDevice\n                                            + \" because of: you must the owner of the source snapshot.\" );\n      }\n      Integer snapVolumeSize = snap.getVolumeSize( );\n      Integer suppliedVolumeSize = ( rootBlockDevice.getEbs( ).getVolumeSize( ) != null ) ? rootBlockDevice.getEbs( ).getVolumeSize( ) : -1; \n      suppliedVolumeSize = ( suppliedVolumeSize == null ) ? rootBlockDevice.getSize( ) : suppliedVolumeSize;\n      Integer targetVolumeSize = ( snapVolumeSize <= suppliedVolumeSize ) ? suppliedVolumeSize : snapVolumeSize;\n      Boolean targetDeleteOnTermination = Boolean.TRUE.equals( rootBlockDevice.getEbs( ).getDeleteOnTermination( ) );\n      BlockStorageImageInfo ret = new BlockStorageImageInfo( generateImageId( Image.Type.machine.getTypePrefix( ), snapshotId ),\n                                                             snap.getDisplayName( ), targetVolumeSize, targetDeleteOnTermination );\n      ret = Transactions.save( ret, new Callback<BlockStorageImageInfo>( ) {\n        \n        @Override\n        public void fire( BlockStorageImageInfo t ) {\n          t.getDeviceMappings( ).addAll( Lists.transform( blockDeviceMappings, Images.deviceMappingGenerator( t ) ) );\n        }\n      } );\n      return ret;\n    } catch ( TransactionFireException ex ) {\n      throw new EucalyptusCloudException( \"Failed to create image from specified block device mapping: \" + rootBlockDevice + \" because of: \" + ex.getMessage( ) );\n    } catch ( ExecutionException ex ) {\n      LOG.error( ex, ex );\n      throw new EucalyptusCloudException( \"Failed to create image from specified block device mapping: \" + rootBlockDevice + \" because of: \" + ex.getMessage( ) );\n    }\n  }","commit_id":"cc0df98a1553219e84f1f78af69ebd4cc35fad1a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void fireEvent(Event event)\n\t{\n\t\tif (event instanceof S3Event) {\n\t\t\tS3Event s3Event = (S3Event) event;\n\n\t\t\t/* Retain records of all account and user id's and names encountered\n\t\t\t * even if they're subsequently deleted.\n\t\t\t */\n\t\t\tReportingAccountDao.getInstance().addUpdateAccount(\n\t\t\t\t\ts3Event.getAccountId(), s3Event.getAccountName());\n\t\t\tReportingUserDao.getInstance().addUpdateUser(s3Event.getOwnerId(),\n\t\t\t\t\ts3Event.getOwnerName());\n\n\t\t\tlong timeMillis = getCurrentTimeMillis();\n\n\t\t\tfinal S3UsageLog usageLog = S3UsageLog.getS3UsageLog();\n\n\t\t\tEntityWrapper<S3UsageSnapshot> entityWrapper =\n\t\t\t\tEntityWrapper.get( S3UsageSnapshot.class );\n\t\t\ttry {\n\n\t\t\t\tLOG.info(\"Receive event:\" + s3Event.toString());\n\n\t\t\t\t/* Load usageDataMap if starting up\n\t\t\t\t */\n\t\t\t\tif (usageDataMap == null) {\n\n\t\t\t\t\tthis.usageDataMap = usageLog.findLatestUsageData();\n\t\t\t\t\tLOG.info(\"Loaded usageDataMap\");\n\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t/* Update usageDataMap\n\t\t\t\t */\n\t\t\t\tS3SummaryKey key = new S3SummaryKey(s3Event.getOwnerId(),\n\t\t\t\t\t\ts3Event.getAccountId());\n\t\t\t\tS3UsageData usageData;\n\t\t\t\tif (usageDataMap.containsKey(key)) {\n\t\t\t\t\tusageData = usageDataMap.get(key);\n\t\t\t\t} else {\n\t\t\t\t\tusageData = new S3UsageData();\n\t\t\t\t\tusageDataMap.put(key, usageData);\n\t\t\t\t}\n\t\t\t\tlong addNum = (s3Event.isCreateOrDelete()) ? 1 : -1;\n\n\t\t\t\tif (s3Event.isObjectOrBucket()) {\n\t\t\t\t\t\n\t\t\t\t\tlong addAmountMegs = (s3Event.isCreateOrDelete())\n\t\t\t\t\t\t? s3Event.getSizeMegs()\n\t\t\t\t\t\t: -s3Event.getSizeMegs();\n\t\t\t\t\tLOG.info(\"Receive event:\" + s3Event.toString() + \" usageData:\" + usageData + \" addNum:\" + addNum + \" addAmountMegs:\" + addAmountMegs);\n\n\t\t\t\t\tLong newObjectsNum =\n\t\t\t\t\t\taddLong(usageData.getObjectsNum(), addNum);\n\t\t\t\t\tusageData.setObjectsNum(newObjectsNum);\n\t\t\t\t\tLong newObjectsMegs =\n\t\t\t\t\t\taddLong(usageData.getObjectsMegs(), addAmountMegs);\n\t\t\t\t\tusageData.setObjectsMegs(newObjectsMegs);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tLong newBucketsNum =\n\t\t\t\t\t\taddLong(usageData.getBucketsNum(), addNum);\n\t\t\t\t\tusageData.setBucketsNum(newBucketsNum);\n\t\t\t\t\tLOG.info(\"Receive event:\" + s3Event.toString() + \" usageData:\" + usageData + \" addNum:\" + addNum);\n\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t/* Write data to DB\n\t\t\t\t */\n\t\t\t\tif ((timeMillis - lastAllSnapshotMs) > WRITE_INTERVAL_MS) {\n\t\t\t\t\t/* Write all snapshots\n\t\t\t\t\t */\n\t\t\t\t\tLOG.info(\"Starting allSnapshot...\");\n\t\t\t\t\tfor (S3SummaryKey summaryKey: usageDataMap.keySet()) {\n\t\t\t\t\t\tS3SnapshotKey snapshotKey = new S3SnapshotKey(\n\t\t\t\t\t\t\t\tsummaryKey.getOwnerId(), summaryKey.getAccountId(),\n\t\t\t\t\t\t\t\ttimeMillis);\n\t\t\t\t\t\tS3UsageSnapshot sus =\n\t\t\t\t\t\t\tnew S3UsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\t\tsus.setAllSnapshot(true);\n\t\t\t\t\t\tLOG.info(\"Storing part of allSnapshot:\" + sus);\n\t\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t\t\tlastAllSnapshotMs = timeMillis;\n\t\t\t\t\t}\n\t\t\t\t\tLOG.info(\"Ending allSnapshot...\");\n\t\t\t\t} else {\n\t\t\t\t\t/* Write this snapshot\n\t\t\t\t\t */\n\t\t\t\t\tS3SnapshotKey snapshotKey = new S3SnapshotKey(\n\t\t\t\t\t\t\tkey.getOwnerId(), key.getAccountId(),\n\t\t\t\t\t\t\ttimeMillis);\n\t\t\t\t\tS3UsageSnapshot sus =\n\t\t\t\t\t\tnew S3UsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\tLOG.info(\"Storing:\" + sus);\n\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t}\n\n\t\t\t\tentityWrapper.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tentityWrapper.rollback();\n\t\t\t\tLOG.error(ex);\t\t\n\t\t\t}\n\t\t}\n\t}","id":89198,"modified_method":"@Override\n\tpublic void fireEvent(Event event)\n\t{\n\t\tif (event instanceof S3Event) {\n\t\t\tS3Event s3Event = (S3Event) event;\n\n\t\t\t/* Retain records of all account and user id's and names encountered\n\t\t\t * even if they're subsequently deleted.\n\t\t\t */\n\t\t\tReportingAccountDao.getInstance().addUpdateAccount(\n\t\t\t\t\ts3Event.getAccountId(), s3Event.getAccountName());\n\t\t\tReportingUserDao.getInstance().addUpdateUser(s3Event.getOwnerId(),\n\t\t\t\t\ts3Event.getOwnerName());\n\n\t\t\tlong timeMillis = getCurrentTimeMillis();\n\n\t\t\tfinal S3UsageLog usageLog = S3UsageLog.getS3UsageLog();\n\n\t\t\tEntityWrapper<S3UsageSnapshot> entityWrapper =\n\t\t\t\tEntityWrapper.get( S3UsageSnapshot.class );\n\t\t\ttry {\n\n\t\t\t\t/* Load usageDataMap if starting up\n\t\t\t\t */\n\t\t\t\tif (usageDataMap == null) {\n\n\t\t\t\t\tthis.usageDataMap = usageLog.findLatestUsageData();\n\t\t\t\t\tLOG.info(\"Loaded usageDataMap\");\n\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t/* Update usageDataMap\n\t\t\t\t */\n\t\t\t\tS3SummaryKey key = new S3SummaryKey(s3Event.getOwnerId(),\n\t\t\t\t\t\ts3Event.getAccountId());\n\t\t\t\tS3UsageData usageData;\n\t\t\t\tif (usageDataMap.containsKey(key)) {\n\t\t\t\t\tusageData = usageDataMap.get(key);\n\t\t\t\t} else {\n\t\t\t\t\tusageData = new S3UsageData();\n\t\t\t\t\tusageDataMap.put(key, usageData);\n\t\t\t\t}\n\t\t\t\tlong addNum = (s3Event.isCreateOrDelete()) ? 1 : -1;\n\n\t\t\t\tif (s3Event.isObjectOrBucket()) {\n\t\t\t\t\t\n\t\t\t\t\tlong addAmountMegs = (s3Event.isCreateOrDelete())\n\t\t\t\t\t\t? s3Event.getSizeMegs()\n\t\t\t\t\t\t: -s3Event.getSizeMegs();\n\t\t\t\t\tLOG.info(\"Receive event:\" + s3Event.toString() + \" usageData:\" + usageData + \" addNum:\" + addNum + \" addAmountMegs:\" + addAmountMegs);\n\n\t\t\t\t\tLong newObjectsNum =\n\t\t\t\t\t\taddLong(usageData.getObjectsNum(), addNum);\n\t\t\t\t\tif (newObjectsNum!=null && newObjectsNum.longValue()<0) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Objects num cannot be negative\");\n\t\t\t\t\t}\n\t\t\t\t\tusageData.setObjectsNum(newObjectsNum);\n\t\t\t\t\tLong newObjectsMegs =\n\t\t\t\t\t\taddLong(usageData.getObjectsMegs(), addAmountMegs);\n\t\t\t\t\tif (newObjectsMegs!=null && newObjectsMegs.longValue()<0) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Objects megs cannot be negative\");\n\t\t\t\t\t}\n\t\t\t\t\tusageData.setObjectsMegs(newObjectsMegs);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tLong newBucketsNum =\n\t\t\t\t\t\taddLong(usageData.getBucketsNum(), addNum);\n\t\t\t\t\tif (newBucketsNum!=null && newBucketsNum.longValue()<0) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Buckets num cannot be negative\");\n\t\t\t\t\t}\n\t\t\t\t\tusageData.setBucketsNum(newBucketsNum);\n\t\t\t\t\tLOG.info(\"Receive event:\" + s3Event.toString() + \" usageData:\" + usageData + \" addNum:\" + addNum);\n\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t/* Write data to DB\n\t\t\t\t */\n\t\t\t\tif ((timeMillis - lastAllSnapshotMs) > WRITE_INTERVAL_MS) {\n\t\t\t\t\t/* Write all snapshots\n\t\t\t\t\t */\n\t\t\t\t\tLOG.info(\"Starting allSnapshot...\");\n\t\t\t\t\tfor (S3SummaryKey summaryKey: usageDataMap.keySet()) {\n\t\t\t\t\t\tS3SnapshotKey snapshotKey = new S3SnapshotKey(\n\t\t\t\t\t\t\t\tsummaryKey.getOwnerId(), summaryKey.getAccountId(),\n\t\t\t\t\t\t\t\ttimeMillis);\n\t\t\t\t\t\tS3UsageSnapshot sus =\n\t\t\t\t\t\t\tnew S3UsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\t\tsus.setAllSnapshot(true);\n\t\t\t\t\t\tLOG.info(\"Storing part of allSnapshot:\" + sus);\n\t\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t\t\tlastAllSnapshotMs = timeMillis;\n\t\t\t\t\t}\n\t\t\t\t\tLOG.info(\"Ending allSnapshot...\");\n\t\t\t\t} else {\n\t\t\t\t\t/* Write this snapshot\n\t\t\t\t\t */\n\t\t\t\t\tS3SnapshotKey snapshotKey = new S3SnapshotKey(\n\t\t\t\t\t\t\tkey.getOwnerId(), key.getAccountId(),\n\t\t\t\t\t\t\ttimeMillis);\n\t\t\t\t\tS3UsageSnapshot sus =\n\t\t\t\t\t\tnew S3UsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\tLOG.info(\"Storing:\" + sus);\n\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t}\n\n\t\t\t\tentityWrapper.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tentityWrapper.rollback();\n\t\t\t\tLOG.error(ex);\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"96548cac581af37fa9a645792f47cd106efcd51d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void fireDeleteEvent( Snapshot snap ) {\n    try {\n      final String userId = snap.getOwnerUserId();\n      final String accountId = snap.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsSnapshot, false, snap.getVolumeSize( ),\n                                                                   userId, userName, accountId, accountName,\n                                                                   snap.getVolumeCluster( ), snap.getVolumePartition( ) ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n    }\n  }","id":89199,"modified_method":"public static void fireDeleteEvent( Snapshot snap ) {\n    try {\n      final String userId = snap.getOwnerUserId();\n      final String accountId = snap.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n      final Long volSize = (snap.getVolumeSize()==null) ? null : snap.getVolumeSize().longValue()*1024;\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsSnapshot, false, volSize,\n                                                                   userId, userName, accountId, accountName,\n                                                                   snap.getVolumeCluster( ), snap.getVolumePartition( ) ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n    }\n  }","commit_id":"96548cac581af37fa9a645792f47cd106efcd51d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void fireCreateEvent( final Snapshot snap ) {\n    try {\n\n      final String userId = snap.getOwnerUserId();\n      final String accountId = snap.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsSnapshot, true, snap.getVolumeSize( ),\n                                                                   userId, userName, accountId, accountName,\n                                                                   snap.getVolumeCluster( ), snap.getVolumePartition( ) ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n    }\n  }","id":89200,"modified_method":"public static void fireCreateEvent( final Snapshot snap ) {\n    try {\n\n      final String userId = snap.getOwnerUserId();\n      final String accountId = snap.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n      final Long volSize = (snap.getVolumeSize()==null) ? null : snap.getVolumeSize().longValue()*1024;\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsSnapshot, true, volSize,\n                                                                   userId, userName, accountId, accountName,\n                                                                   snap.getVolumeCluster( ), snap.getVolumePartition( ) ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex );\n    }\n  }","commit_id":"96548cac581af37fa9a645792f47cd106efcd51d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void fireEvent(Event event)\n\t{\n\t\tif (event instanceof StorageEvent) {\n\t\t\tStorageEvent storageEvent = (StorageEvent) event;\n\n\t\t\t\n\t\t\t/* Retain records of all account and user id's and names encountered\n\t\t\t * even if they're subsequently deleted.\n\t\t\t */\n\t\t\tReportingAccountDao.getInstance().addUpdateAccount(\n\t\t\t\t\tstorageEvent.getAccountId(), storageEvent.getAccountName());\n\t\t\tReportingUserDao.getInstance().addUpdateUser(storageEvent.getOwnerId(),\n\t\t\t\t\tstorageEvent.getOwnerName());\n\n\n\t\t\tlong timeMillis = getCurrentTimeMillis();\n\n\t\t\tfinal StorageUsageLog usageLog = StorageUsageLog.getStorageUsageLog();\n\n\t\t\tEntityWrapper<StorageUsageSnapshot> entityWrapper =\n\t\t\t\tEntityWrapper.get( StorageUsageSnapshot.class );\n\t\t\ttry {\n\n\t\t\t\t/* Load usageDataMap if starting up\n\t\t\t\t */\n\t\t\t\tif (usageDataMap == null) {\n\n\t\t\t\t\tthis.usageDataMap = usageLog.findLatestUsageData();\n\t\t\t\t\tLOG.info(\"Loaded usageDataMap\");\n\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t/* Update usageDataMap\n\t\t\t\t */\n\t\t\t\tStorageSummaryKey key = new StorageSummaryKey(\n\t\t\t\t\t\tstorageEvent.getOwnerId(),\n\t\t\t\t\t\tstorageEvent.getAccountId(),\n\t\t\t\t\t\tstorageEvent.getClusterName(),\n\t\t\t\t\t\tstorageEvent.getAvailabilityZone());\n\t\t\t\tStorageUsageData usageData;\n\t\t\t\tif (usageDataMap.containsKey(key)) {\n\t\t\t\t\tusageData = usageDataMap.get(key);\n\t\t\t\t} else {\n\t\t\t\t\tusageData = new StorageUsageData();\n\t\t\t\t\tusageDataMap.put(key, usageData);\n\t\t\t\t}\n\t\t\t\tlong addAmountMegs = (storageEvent.isCreateOrDelete())\n\t\t\t\t\t\t? storageEvent.getSizeMegs()\n\t\t\t\t\t\t: -storageEvent.getSizeMegs();\n\t\t\t\tlong addNum = (storageEvent.isCreateOrDelete()) ? 1 : -1;\n\t\t\t\tLOG.info(\"Receive event:\" + storageEvent.toString() + \" usageData:\" + usageData + \" addAmountMegs:\" + addAmountMegs + \" addNum:\" + addNum);\n\n\t\t\t\tswitch(storageEvent.getEventType()) {\n\t\t\t\t\tcase EbsSnapshot:\n\t\t\t\t\t\tLong newSnapshotsNum =\n\t\t\t\t\t\t\taddLong(usageData.getSnapshotsNum(), addNum);\n\t\t\t\t\t\tusageData.setSnapshotsNum(newSnapshotsNum);\n\t\t\t\t\t\tLong newSnapshotsMegs =\n\t\t\t\t\t\t\taddLong(usageData.getSnapshotsMegs(), addAmountMegs);\n\t\t\t\t\t\tusageData.setSnapshotsMegs(newSnapshotsMegs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EbsVolume:\n\t\t\t\t\t\tLong newVolumesNum =\n\t\t\t\t\t\t\taddLong(usageData.getVolumesNum(), addNum);\n\t\t\t\t\t\tusageData.setVolumesNum(newVolumesNum);\n\t\t\t\t\t\tLong newVolumesMegs =\n\t\t\t\t\t\t\taddLong(usageData.getVolumesMegs(), addAmountMegs);\n\t\t\t\t\t\tusageData.setVolumesMegs(newVolumesMegs);\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t/* Write data to DB\n\t\t\t\t */\n\t\t\t\tif ((timeMillis - lastAllSnapshotMs) > WRITE_INTERVAL_MS) {\n\t\t\t\t\t/* Write all snapshots\n\t\t\t\t\t */\n\t\t\t\t\tLOG.info(\"Starting allSnapshot...\");\n\t\t\t\t\tfor (StorageSummaryKey summaryKey: usageDataMap.keySet()) {\n\t\t\t\t\t\tStorageSnapshotKey snapshotKey = new StorageSnapshotKey(\n\t\t\t\t\t\t\t\tsummaryKey.getOwnerId(), summaryKey.getAccountId(),\n\t\t\t\t\t\t\t\tsummaryKey.getClusterName(),\n\t\t\t\t\t\t\t\tsummaryKey.getAvailabilityZone(), timeMillis);\n\t\t\t\t\t\tStorageUsageSnapshot sus =\n\t\t\t\t\t\t\tnew StorageUsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\t\tsus.setAllSnapshot(true);\n\t\t\t\t\t\tLOG.info(\"Storing as part of allSnapshot:\" + sus);\n\t\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t\t\tlastAllSnapshotMs = timeMillis;\n\t\t\t\t\t}\n\t\t\t\t\tLOG.info(\"Ending allSnapshot...\");\n\t\t\t\t} else {\n\t\t\t\t\t/* Write this snapshot\n\t\t\t\t\t */\n\t\t\t\t\tStorageSnapshotKey snapshotKey = new StorageSnapshotKey(\n\t\t\t\t\t\t\tkey.getOwnerId(), key.getAccountId(), key.getClusterName(),\n\t\t\t\t\t\t\tkey.getAvailabilityZone(), timeMillis);\n\t\t\t\t\tStorageUsageSnapshot sus =\n\t\t\t\t\t\tnew StorageUsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\tLOG.info(\"Storing:\" + sus);\n\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t}\n\n\t\t\t\tentityWrapper.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tentityWrapper.rollback();\n\t\t\t\tLOG.error(ex);\t\t\n\t\t\t}\n\t\t}\n\t}","id":89201,"modified_method":"@Override\n\tpublic void fireEvent(Event event)\n\t{\n\t\tif (event instanceof StorageEvent) {\n\t\t\tStorageEvent storageEvent = (StorageEvent) event;\n\n\t\t\t\n\t\t\t/* Retain records of all account and user id's and names encountered\n\t\t\t * even if they're subsequently deleted.\n\t\t\t */\n\t\t\tReportingAccountDao.getInstance().addUpdateAccount(\n\t\t\t\t\tstorageEvent.getAccountId(), storageEvent.getAccountName());\n\t\t\tReportingUserDao.getInstance().addUpdateUser(storageEvent.getOwnerId(),\n\t\t\t\t\tstorageEvent.getOwnerName());\n\n\n\t\t\tlong timeMillis = getCurrentTimeMillis();\n\n\t\t\tfinal StorageUsageLog usageLog = StorageUsageLog.getStorageUsageLog();\n\n\t\t\tEntityWrapper<StorageUsageSnapshot> entityWrapper =\n\t\t\t\tEntityWrapper.get( StorageUsageSnapshot.class );\n\t\t\ttry {\n\n\t\t\t\t/* Load usageDataMap if starting up\n\t\t\t\t */\n\t\t\t\tif (usageDataMap == null) {\n\n\t\t\t\t\tthis.usageDataMap = usageLog.findLatestUsageData();\n\t\t\t\t\tLOG.info(\"Loaded usageDataMap\");\n\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t/* Update usageDataMap\n\t\t\t\t */\n\t\t\t\tStorageSummaryKey key = new StorageSummaryKey(\n\t\t\t\t\t\tstorageEvent.getOwnerId(),\n\t\t\t\t\t\tstorageEvent.getAccountId(),\n\t\t\t\t\t\tstorageEvent.getClusterName(),\n\t\t\t\t\t\tstorageEvent.getAvailabilityZone());\n\t\t\t\tStorageUsageData usageData;\n\t\t\t\tif (usageDataMap.containsKey(key)) {\n\t\t\t\t\tusageData = usageDataMap.get(key);\n\t\t\t\t} else {\n\t\t\t\t\tusageData = new StorageUsageData();\n\t\t\t\t\tusageDataMap.put(key, usageData);\n\t\t\t\t}\n\t\t\t\tlong addAmountMegs = (storageEvent.isCreateOrDelete())\n\t\t\t\t\t\t? storageEvent.getSizeMegs()\n\t\t\t\t\t\t: -storageEvent.getSizeMegs();\n\t\t\t\tlong addNum = (storageEvent.isCreateOrDelete()) ? 1 : -1;\n\t\t\t\tLOG.info(\"Receive event:\" + storageEvent.toString() + \" usageData:\" + usageData + \" addAmountMegs:\" + addAmountMegs + \" addNum:\" + addNum);\n\n\t\t\t\tswitch(storageEvent.getEventType()) {\n\t\t\t\t\tcase EbsSnapshot:\n\t\t\t\t\t\tLong newSnapshotsNum =\n\t\t\t\t\t\t\taddLong(usageData.getSnapshotsNum(), addNum);\n\t\t\t\t\t\tif (newSnapshotsNum!=null && newSnapshotsNum.longValue()<0) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Snapshots num cannot be negative\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusageData.setSnapshotsNum(newSnapshotsNum);\n\t\t\t\t\t\tLong newSnapshotsMegs =\n\t\t\t\t\t\t\taddLong(usageData.getSnapshotsMegs(), addAmountMegs);\n\t\t\t\t\t\tif (newSnapshotsMegs!=null && newSnapshotsMegs.longValue()<0) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Snapshots megs cannot be negative\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusageData.setSnapshotsMegs(newSnapshotsMegs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EbsVolume:\n\t\t\t\t\t\tLong newVolumesNum =\n\t\t\t\t\t\t\taddLong(usageData.getVolumesNum(), addNum);\n\t\t\t\t\t\tif (newVolumesNum!=null && newVolumesNum.longValue()<0) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Volumes num cannot be negative\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusageData.setVolumesNum(newVolumesNum);\n\t\t\t\t\t\tLong newVolumesMegs =\n\t\t\t\t\t\t\taddLong(usageData.getVolumesMegs(), addAmountMegs);\n\t\t\t\t\t\tif (newVolumesMegs!=null && newVolumesMegs.longValue()<0) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Volumes megs cannot be negative\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusageData.setVolumesMegs(newVolumesMegs);\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t/* Write data to DB\n\t\t\t\t */\n\t\t\t\tif ((timeMillis - lastAllSnapshotMs) > WRITE_INTERVAL_MS) {\n\t\t\t\t\t/* Write all snapshots\n\t\t\t\t\t */\n\t\t\t\t\tLOG.info(\"Starting allSnapshot...\");\n\t\t\t\t\tfor (StorageSummaryKey summaryKey: usageDataMap.keySet()) {\n\t\t\t\t\t\tStorageSnapshotKey snapshotKey = new StorageSnapshotKey(\n\t\t\t\t\t\t\t\tsummaryKey.getOwnerId(), summaryKey.getAccountId(),\n\t\t\t\t\t\t\t\tsummaryKey.getClusterName(),\n\t\t\t\t\t\t\t\tsummaryKey.getAvailabilityZone(), timeMillis);\n\t\t\t\t\t\tStorageUsageSnapshot sus =\n\t\t\t\t\t\t\tnew StorageUsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\t\tsus.setAllSnapshot(true);\n\t\t\t\t\t\tLOG.info(\"Storing as part of allSnapshot:\" + sus);\n\t\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t\t\tlastAllSnapshotMs = timeMillis;\n\t\t\t\t\t}\n\t\t\t\t\tLOG.info(\"Ending allSnapshot...\");\n\t\t\t\t} else {\n\t\t\t\t\t/* Write this snapshot\n\t\t\t\t\t */\n\t\t\t\t\tStorageSnapshotKey snapshotKey = new StorageSnapshotKey(\n\t\t\t\t\t\t\tkey.getOwnerId(), key.getAccountId(), key.getClusterName(),\n\t\t\t\t\t\t\tkey.getAvailabilityZone(), timeMillis);\n\t\t\t\t\tStorageUsageSnapshot sus =\n\t\t\t\t\t\tnew StorageUsageSnapshot(snapshotKey, usageDataMap.get(key));\n\t\t\t\t\tLOG.info(\"Storing:\" + sus);\n\t\t\t\t\tentityWrapper.add(sus);\n\t\t\t\t}\n\n\t\t\t\tentityWrapper.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tentityWrapper.rollback();\n\t\t\t\tLOG.error(ex);\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"96548cac581af37fa9a645792f47cd106efcd51d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"static void fireCreateEvent( final Volume t ) {\n    try {\n      final String userId = t.getOwnerUserId();\n      final String accountId = t.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsVolume, true, t.getSize( ),\n                                                                   userId, userName, accountId, accountName,\n                                                                   t.getScName( ), t.getPartition( ) ) );\n    } catch ( final Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n  }","id":89202,"modified_method":"static void fireCreateEvent( final Volume t ) {\n    try {\n      final String userId = t.getOwnerUserId();\n      final String accountId = t.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n      final Long volSize = (t.getSize()==null) ? null : t.getSize().longValue()*1024;\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsVolume, true, volSize,\n                                                                   userId, userName, accountId, accountName,\n                                                                   t.getScName( ), t.getPartition( ) ) );\n    } catch ( final Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n  }","commit_id":"96548cac581af37fa9a645792f47cd106efcd51d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"static void fireDeleteEvent( final Volume v ) {\n    try {\n      final String userId = v.getOwnerUserId();\n      final String accountId = v.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsVolume, false, v.getSize( ),\n                                                                   userId, userName, accountId, accountName,\n                                                                   v.getScName( ), v.getPartition( ) ) );\n    } catch ( final Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n  }","id":89203,"modified_method":"static void fireDeleteEvent( final Volume v ) {\n    try {\n      final String userId = v.getOwnerUserId();\n      final String accountId = v.getOwnerAccountNumber();\n      final String userName = Accounts.lookupUserById(userId).getName();\n      final String accountName = Accounts.lookupAccountById(accountId).getName();\n      final Long volSize = (v.getSize()==null) ? null : v.getSize().longValue()*1024;\n\n      ListenerRegistry.getInstance( ).fireEvent( new StorageEvent( StorageEvent.EventType.EbsVolume, false, volSize,\n                                                                   userId, userName, accountId, accountName,\n                                                                   v.getScName( ), v.getPartition( ) ) );\n    } catch ( final Exception ex ) {\n      LOG.error( ex );\n      Logs.extreme( ).error( ex, ex );\n    }\n  }","commit_id":"96548cac581af37fa9a645792f47cd106efcd51d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, StratifiedAlignmentContext stratifiedContext, VariantContext vc, Genotype g) {\n        // for now, we don't support indels\n        if ( g == null || !g.isCalled() || vc.getType() != VariantContext.Type.SNP )\n            return null;\n\n        Set<Allele> altAlleles = vc.getAlternateAlleles();\n        if ( altAlleles.size() == 0 )\n            return null;\n\n        HashMap<Byte, Integer> alleleCounts = new HashMap<Byte, Integer>();\n        for ( Allele allele : altAlleles )\n            alleleCounts.put(allele.getBases()[0], 0);\n\n        ReadBackedPileup pileup = stratifiedContext.getContext(StratifiedAlignmentContext.StratifiedContextType.COMPLETE).getBasePileup();\n        for (PileupElement p : pileup ) {\n            if ( alleleCounts.containsKey(p.getBase()) )\n                alleleCounts.put(p.getBase(), alleleCounts.get(p.getBase())+1);\n        }\n\n        StringBuffer sb = new StringBuffer();\n        // we need to add counts in the correct order\n        for ( Allele allele : vc.getAlleles() ) {\n            if ( alleleCounts.containsKey(allele.getBases()[0]) ) {\n                if ( sb.length() > 0 )\n                    sb.append(\",\");\n                sb.append(String.format(\"%d\", alleleCounts.get(allele.getBases()[0])));\n            }\n        }\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyName(), sb.toString());\n        return map;\n    }","id":89204,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, StratifiedAlignmentContext stratifiedContext, VariantContext vc, Genotype g) {\n        // for now, we don't support indels\n        if ( g == null || !g.isCalled() )\n            return null;\n\n        if ( vc.isSNP() ) {\n            return annotateSNP(tracker,ref,stratifiedContext,vc,g);\n        } else if ( vc.isIndel() ) {\n            return annotateIndel(tracker,ref,stratifiedContext,vc,g);\n        } else {\n            return null;\n        }\n    }","commit_id":"ebd0fabf86bb2c18cc9a17e913bb9898f105118a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, StratifiedAlignmentContext> stratifiedContexts, VariantContext vc) {\n\n        if ( !vc.isBiallelic() || !vc.isSNP() )\n            return null;\n\n        int run = computeHomopolymerRun(vc.getAlternateAllele(0).toString().charAt(0), ref);\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyName(), String.format(\"%d\", run));\n        return map;\n    }","id":89205,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, StratifiedAlignmentContext> stratifiedContexts, VariantContext vc) {\n\n        if ( !vc.isBiallelic() )\n            return null;\n\n        int run;\n        if ( vc.isSNP() ) {\n            run = computeHomopolymerRun(vc.getAlternateAllele(0).toString().charAt(0), ref);\n        } else if ( vc.isIndel() && ANNOTATE_INDELS ) {\n            run = computeIndelHomopolymerRun(vc,ref);\n        } else {\n            return null;\n        }\n        \n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyName(), String.format(\"%d\", run));\n        return map;\n    }","commit_id":"ebd0fabf86bb2c18cc9a17e913bb9898f105118a","url":"https://github.com/broadgsa/gatk"},{"original_method":"private GenotypeLikelihoodsCalculationModel.Model getCurrentGLModel(final RefMetaDataTracker tracker, final ReferenceContext refContext,\n                                                                        final AlignmentContext rawContext ) {\n        if (rawContext.hasExtendedEventPileup() ) {\n            // todo - remove this code\n            if ((UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL) &&\n                   (UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) )\n                return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n        }\n        else {\n            // no extended event pileup\n            // if we're genotyping given alleles and we have a requested SNP at this position, do SNP\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                VariantContext vcInput = SNPGenotypeLikelihoodsCalculationModel.getSNPVCFromAllelesRod(tracker, refContext, false, logger);\n                if (vcInput == null)\n                    return null;\n\n                if (vcInput.isSNP() &&  ( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.SNP))\n                    return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                else if ((vcInput.isIndel() || vcInput.isMixed()) && (UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL))\n                    return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n            }   else {\n                // todo - this assumes SNP's take priority when BOTH is selected, should do a smarter way once extended events are removed\n                if( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.SNP)\n                    return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                else if (UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL)\n                    return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n                }\n        }\n        return null;\n    }","id":89206,"modified_method":"private GenotypeLikelihoodsCalculationModel.Model getCurrentGLModel(final RefMetaDataTracker tracker, final ReferenceContext refContext,\n                                                                        final AlignmentContext rawContext ) {\n        if (rawContext.hasExtendedEventPileup() ) {\n            // todo - remove this code\n            if ((UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL) &&\n                   (UAC.GenotypingMode != GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES ) )\n                return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n        }\n        else {\n            // no extended event pileup\n            // if we're genotyping given alleles and we have a requested SNP at this position, do SNP\n            if (UAC.GenotypingMode == GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES) {\n                VariantContext vcInput = SNPGenotypeLikelihoodsCalculationModel.getSNPVCFromAllelesRod(tracker, refContext, false, logger);\n                if (vcInput == null)\n                    return null;\n\n                // todo - no support to genotype MNP's yet\n                if  (vcInput.isMNP())\n                    return null;\n\n                if (vcInput.isSNP())  {\n                    if (( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.SNP))\n                        return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                    else\n                        // ignore SNP's if user chose INDEL mode\n                        return null;\n                }\n                else if ((vcInput.isIndel() || vcInput.isMixed()) && (UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL))\n                    return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n            }\n            else {\n                // todo - this assumes SNP's take priority when BOTH is selected, should do a smarter way once extended events are removed\n                if( UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.BOTH || UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.SNP)\n                    return GenotypeLikelihoodsCalculationModel.Model.SNP;\n                else if (UAC.GLmodel == GenotypeLikelihoodsCalculationModel.Model.INDEL)\n                    return GenotypeLikelihoodsCalculationModel.Model.INDEL;\n            }\n        }\n        return null;\n    }","commit_id":"cfe43e3971327ff26ef9087e31b4294d4a98d99c","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Integer> refQuals, List<Integer> altQuals) {\n        for ( final PileupElement p : pileup ) {\n            if( isUsableBase(p) ) {\n                if ( p.getBase() == ref ) {\n                    refQuals.add((int)p.getQual());\n                } else if ( p.getBase() == alt ) {\n                    altQuals.add((int)p.getQual());\n                }\n            }\n        }\n    }","id":89207,"modified_method":"protected void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Double> refQuals, List<Double> altQuals) {\n        for ( final PileupElement p : pileup ) {\n            if( isUsableBase(p) ) {\n                if ( p.getBase() == ref ) {\n                    refQuals.add((double)p.getQual());\n                } else if ( p.getBase() == alt ) {\n                    altQuals.add((double)p.getQual());\n                }\n            }\n        }\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( ! vc.isVariant() || vc.isFiltered() || ! vc.isBiallelic() || ! vc.isSNP() )\n            return null;\n\n        int[][] table = getContingencyTable(stratifiedContexts, vc.getReference(), vc.getAlternateAllele(0));\n        Double pvalue = Math.max(pValueForContingencyTable(table), MIN_PVALUE);\n        if ( pvalue == null )\n            return null;\n\n        // use Math.abs to prevent -0's\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(FS, String.format(\"%.3f\", QualityUtils.phredScaleErrorRate(pvalue)));\n        return map;\n    }","id":89208,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( ! vc.isVariant() || vc.isFiltered()  )\n            return null;\n\n\n        int[][] table;\n\n        if (vc.isBiallelic() && vc.isSNP())\n            table = getSNPContingencyTable(stratifiedContexts, vc.getReference(), vc.getAlternateAllele(0));\n        else if (vc.isIndel() || vc.isMixed()) {\n            table = getIndelContingencyTable(stratifiedContexts, vc);\n            if (table == null)\n                return null;\n        }\n        else\n            return null;\n\n        Double pvalue = Math.max(pValueForContingencyTable(table), MIN_PVALUE);\n        if ( pvalue == null )\n            return null;\n\n        // use Math.abs to prevent -0's\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(FS, String.format(\"%.3f\", QualityUtils.phredScaleErrorRate(pvalue)));\n        return map;\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     Allocate and fill a 2x2 strand contingency table.  In the end, it'll look something like this:\n     *             fw      rc\n     *   allele1   #       #\n     *   allele2   #       #\n     * @return a 2x2 contingency table\n     */\n    private static int[][] getContingencyTable(Map<String, AlignmentContext> stratifiedContexts, Allele ref, Allele alt) {\n        int[][] table = new int[2][2];\n\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            for (PileupElement p : sample.getValue().getBasePileup()) {\n                if ( p.isDeletion() ) // ignore deletions\n                    continue;\n\n                if ( p.getRead().getMappingQuality() < 20 || p.getQual() < 20 )\n                    continue; // todo -- fixme, should take filtered context!\n\n                Allele base = Allele.create(p.getBase(), false);\n                boolean isFW = !p.getRead().getReadNegativeStrandFlag();\n\n                boolean matchesRef = ref.equals(base, true);\n                boolean matchesAlt = alt.equals(base, true);\n                if ( matchesRef || matchesAlt ) {\n                    int row = matchesRef ? 0 : 1;\n                    int column = isFW ? 0 : 1;\n\n                    table[row][column]++;\n                }\n            }\n        }\n\n        return table;\n    }","id":89209,"modified_method":"/**\n     Allocate and fill a 2x2 strand contingency table.  In the end, it'll look something like this:\n     *             fw      rc\n     *   allele1   #       #\n     *   allele2   #       #\n     * @return a 2x2 contingency table\n     */\n    private static int[][] getSNPContingencyTable(Map<String, AlignmentContext> stratifiedContexts, Allele ref, Allele alt) {\n        int[][] table = new int[2][2];\n\n        for ( Map.Entry<String, AlignmentContext> sample : stratifiedContexts.entrySet() ) {\n            for (PileupElement p : sample.getValue().getBasePileup()) {\n                if ( p.isDeletion() ) // ignore deletions\n                    continue;\n\n                if ( p.getRead().getMappingQuality() < 20 || p.getQual() < 20 )\n                    continue; // todo -- fixme, should take filtered context!\n\n                Allele base = Allele.create(p.getBase(), false);\n                boolean isFW = !p.getRead().getReadNegativeStrandFlag();\n\n                boolean matchesRef = ref.equals(base, true);\n                boolean matchesAlt = alt.equals(base, true);\n                if ( matchesRef || matchesAlt ) {\n                    int row = matchesRef ? 0 : 1;\n                    int column = isFW ? 0 : 1;\n\n                    table[row][column]++;\n                }\n            }\n        }\n\n        return table;\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n\n        final Map<String, Genotype> genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() < MIN_SAMPLES || !vc.isBiallelic() )\n            return null;\n\n        double refCount = 0.0;\n        double hetCount = 0.0;\n        double homCount = 0.0;\n        int N = 0; // number of samples that have likelihoods\n        for ( final Map.Entry<String, Genotype> genotypeMap : genotypes.entrySet() ) {\n            Genotype g = genotypeMap.getValue();\n            if ( g.isNoCall() )\n                continue;\n\n            N++;\n            final double[] normalizedLikelihoods = MathUtils.normalizeFromLog10( g.getLikelihoods().getAsVector() );\n            refCount += normalizedLikelihoods[0];\n            hetCount += normalizedLikelihoods[1];\n            homCount += normalizedLikelihoods[2];\n        }\n\n        final double p = ( 2.0 * refCount + hetCount ) / ( 2.0 * (refCount + hetCount + homCount) ); // expected reference allele frequency\n        final double q = 1.0 - p; // expected alternative allele frequency\n        final double F = 1.0 - ( hetCount / ( 2.0 * p * q * (double)N ) ); // inbreeding coefficient\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", F));\n        return map;\n    }","id":89210,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n\n        final Map<String, Genotype> genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() < MIN_SAMPLES )\n            return null;\n\n        int idxAA = 0, idxAB = 1, idxBB = 2;\n\n        if (!vc.isBiallelic()) {\n            // for non-bliallelic case, do test with most common alt allele.\n            // Get then corresponding indeces in GL vectors to retrieve GL of AA,AB and BB.\n            int[] idxVector = vc.getGLIndecesOfAllele(vc.getAltAlleleWithHighestAlleleCount());\n            idxAA = idxVector[0];\n            idxAB = idxVector[1];\n            idxBB = idxVector[2];\n        }\n        double refCount = 0.0;\n        double hetCount = 0.0;\n        double homCount = 0.0;\n        int N = 0; // number of samples that have likelihoods\n        for ( final Map.Entry<String, Genotype> genotypeMap : genotypes.entrySet() ) {\n            Genotype g = genotypeMap.getValue();\n            if ( g.isNoCall() )\n                continue;\n\n            N++;\n            final double[] normalizedLikelihoods = MathUtils.normalizeFromLog10( g.getLikelihoods().getAsVector() );\n            refCount += normalizedLikelihoods[idxAA];\n            hetCount += normalizedLikelihoods[idxAB];\n            homCount += normalizedLikelihoods[idxBB];\n        }\n\n        final double p = ( 2.0 * refCount + hetCount ) / ( 2.0 * (refCount + hetCount + homCount) ); // expected reference allele frequency\n        final double q = 1.0 - p; // expected alternative allele frequency\n        final double F = 1.0 - ( hetCount / ( 2.0 * p * q * (double)N ) ); // inbreeding coefficient\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", F));\n        return map;\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"private List<Haplotype> computeHaplotypes(final ReadBackedPileup pileup, final int contextSize, final int locus) {\n        // Compute all possible haplotypes consistent with current pileup\n        final PriorityQueue<Haplotype> candidateHaplotypeQueue = new PriorityQueue<Haplotype>(100, new HaplotypeComparator());\n        final PriorityQueue<Haplotype> consensusHaplotypeQueue = new PriorityQueue<Haplotype>(MAX_CONSENSUS_HAPLOTYPES_TO_CONSIDER, new HaplotypeComparator());\n\n        for ( final PileupElement p : pileup ) {\n            final Haplotype haplotypeFromRead = getHaplotypeFromRead(p, contextSize, locus);\n            candidateHaplotypeQueue.add(haplotypeFromRead);\n        }\n\n        // Now that priority queue has been built with all reads at context, we need to merge and find possible segregating haplotypes\n        Haplotype elem;\n        while ((elem = candidateHaplotypeQueue.poll()) != null)  {\n            boolean foundHaplotypeMatch = false;\n            Haplotype lastCheckedHaplotype = null;\n            for ( final Haplotype haplotypeFromList : consensusHaplotypeQueue ) {\n                final Haplotype consensusHaplotype = getConsensusHaplotype(elem, haplotypeFromList);\n                if (consensusHaplotype != null)  {\n                    foundHaplotypeMatch = true;\n                    if (consensusHaplotype.getQualitySum() > haplotypeFromList.getQualitySum()) {\n                        consensusHaplotypeQueue.remove(haplotypeFromList);\n                        consensusHaplotypeQueue.add(consensusHaplotype);\n                    }\n                    break;\n                }\n                else {\n                    lastCheckedHaplotype = haplotypeFromList;\n                }\n            }\n\n            if (!foundHaplotypeMatch && consensusHaplotypeQueue.size() < MAX_CONSENSUS_HAPLOTYPES_TO_CONSIDER) {\n                consensusHaplotypeQueue.add(elem);\n            } else if (!foundHaplotypeMatch && lastCheckedHaplotype != null && elem.getQualitySum() > lastCheckedHaplotype.getQualitySum() ) {\n                consensusHaplotypeQueue.remove(lastCheckedHaplotype);\n                consensusHaplotypeQueue.add(elem);\n            }\n        }\n\n        // Now retrieve the two most popular haplotypes\n        if (consensusHaplotypeQueue.size() > 0) {\n            // Since the consensus haplotypes are in a quality-ordered priority queue, the two best haplotypes are just the first two in the queue\n            final Haplotype haplotype1 = consensusHaplotypeQueue.poll();\n            Haplotype haplotype2 = consensusHaplotypeQueue.poll();\n            if(haplotype2 == null ) { haplotype2 = haplotype1; } // Sometimes only the reference haplotype can be found\n            return Arrays.asList(new Haplotype(haplotype1.getBasesAsBytes(), 60), new Haplotype(haplotype2.getBasesAsBytes(), 20)); // These qual values aren't used for anything\n        } else {\n            return null;\n        }\n    }","id":89211,"modified_method":"private List<Haplotype> computeHaplotypes(final ReadBackedPileup pileup, final int contextSize, final int locus, final VariantContext vc) {\n        // Compute all possible haplotypes consistent with current pileup\n\n        int haplotypesToCompute = vc.getAlternateAlleles().size()+1;\n\n        final PriorityQueue<Haplotype> candidateHaplotypeQueue = new PriorityQueue<Haplotype>(100, new HaplotypeComparator());\n        final PriorityQueue<Haplotype> consensusHaplotypeQueue = new PriorityQueue<Haplotype>(MAX_CONSENSUS_HAPLOTYPES_TO_CONSIDER, new HaplotypeComparator());\n\n        for ( final PileupElement p : pileup ) {\n            final Haplotype haplotypeFromRead = getHaplotypeFromRead(p, contextSize, locus);\n            candidateHaplotypeQueue.add(haplotypeFromRead);\n        }\n\n        // Now that priority queue has been built with all reads at context, we need to merge and find possible segregating haplotypes\n        Haplotype elem;\n        while ((elem = candidateHaplotypeQueue.poll()) != null)  {\n            boolean foundHaplotypeMatch = false;\n            Haplotype lastCheckedHaplotype = null;\n            for ( final Haplotype haplotypeFromList : consensusHaplotypeQueue ) {\n                final Haplotype consensusHaplotype = getConsensusHaplotype(elem, haplotypeFromList);\n                if (consensusHaplotype != null)  {\n                    foundHaplotypeMatch = true;\n                    if (consensusHaplotype.getQualitySum() > haplotypeFromList.getQualitySum()) {\n                        consensusHaplotypeQueue.remove(haplotypeFromList);\n                        consensusHaplotypeQueue.add(consensusHaplotype);\n                    }\n                    break;\n                }\n                else {\n                    lastCheckedHaplotype = haplotypeFromList;\n                }\n            }\n\n            if (!foundHaplotypeMatch && consensusHaplotypeQueue.size() < MAX_CONSENSUS_HAPLOTYPES_TO_CONSIDER) {\n                consensusHaplotypeQueue.add(elem);\n            } else if (!foundHaplotypeMatch && lastCheckedHaplotype != null && elem.getQualitySum() > lastCheckedHaplotype.getQualitySum() ) {\n                consensusHaplotypeQueue.remove(lastCheckedHaplotype);\n                consensusHaplotypeQueue.add(elem);\n            }\n        }\n\n        // Now retrieve the N most popular haplotypes\n        if (consensusHaplotypeQueue.size() > 0) {\n            // Since the consensus haplotypes are in a quality-ordered priority queue, the two best haplotypes are just the first two in the queue\n            final Haplotype haplotype1 = consensusHaplotypeQueue.poll();\n\n            List<Haplotype>hlist = new ArrayList<Haplotype>();\n            hlist.add(new Haplotype(haplotype1.getBasesAsBytes(), 60));\n\n            for (int k=1;k < haplotypesToCompute; k++) {\n                Haplotype haplotype2 = consensusHaplotypeQueue.poll();\n                if(haplotype2 == null ) { haplotype2 = haplotype1; } // Sometimes only the reference haplotype can be found\n                hlist.add(new Haplotype(haplotype2.getBasesAsBytes(), 20));\n            }\n            return hlist;\n        } else\n            return null;\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( !vc.isBiallelic() || stratifiedContexts.size() == 0 ) // size 0 means that call was made by someone else and we have no data here\n            return null;\n        \n        final AlignmentContext context = AlignmentContextUtils.joinContexts(stratifiedContexts.values());\n\n        final int contextWingSize = Math.min(((int)ref.getWindow().size() - 1)/2, MIN_CONTEXT_WING_SIZE);\n        final int contextSize = contextWingSize * 2 + 1;\n\n        final int locus = ref.getLocus().getStart() + (ref.getLocus().getStop() - ref.getLocus().getStart()) / 2;\n\n        // Compute all haplotypes consistent with the current read pileup\n        ReadBackedPileup pileup = null;\n        if (context.hasExtendedEventPileup())\n            pileup = context.getExtendedEventPileup();\n        else if (context.hasBasePileup())\n            pileup = context.getBasePileup();\n\n        if (pileup == null)\n            return null;\n        \n        final List<Haplotype> haplotypes = computeHaplotypes(pileup, contextSize, locus);\n\n\t    final MathUtils.RunningAverage scoreRA = new MathUtils.RunningAverage();\n        if (haplotypes != null) {\n            final Set<Map.Entry<String, Genotype>> genotypes = vc.getGenotypes().entrySet();\n            for ( final Map.Entry<String, Genotype> genotype : genotypes ) {\n                final AlignmentContext thisContext = stratifiedContexts.get(genotype.getKey());\n                if ( thisContext != null ) {\n                    final ReadBackedPileup thisPileup;\n                    if (thisContext.hasExtendedEventPileup())\n                        thisPileup = thisContext.getExtendedEventPileup();\n                    else if (thisContext.hasBasePileup())\n                        thisPileup = thisContext.getBasePileup();\n                    else\n                        thisPileup = null;\n\n                    if (thisPileup != null) {\n                        scoreRA.add( scoreReadsAgainstHaplotypes(haplotypes, thisPileup, contextSize, locus) ); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                    }\n                }\n            }\n        }\n\n        // annotate the score in the info field\n        final Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", scoreRA.mean()));\n        return map;\n    }","id":89212,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if (stratifiedContexts.size() == 0 ) // size 0 means that call was made by someone else and we have no data here\n            return null;\n\n        if (vc.isSNP() &&  !vc.isBiallelic())\n            return null;\n\n        final AlignmentContext context = AlignmentContextUtils.joinContexts(stratifiedContexts.values());\n\n        final int contextWingSize = Math.min(((int)ref.getWindow().size() - 1)/2, MIN_CONTEXT_WING_SIZE);\n        final int contextSize = contextWingSize * 2 + 1;\n\n        final int locus = ref.getLocus().getStart() + (ref.getLocus().getStop() - ref.getLocus().getStart()) / 2;\n\n        // Compute all haplotypes consistent with the current read pileup\n        ReadBackedPileup pileup = null;\n        if (context.hasExtendedEventPileup())\n            pileup = context.getExtendedEventPileup();\n        else if (context.hasBasePileup())\n            pileup = context.getBasePileup();\n\n        if (pileup == null)\n            return null;\n        \n        final List<Haplotype> haplotypes = computeHaplotypes(pileup, contextSize, locus, vc);\n\n\t    final MathUtils.RunningAverage scoreRA = new MathUtils.RunningAverage();\n        if (haplotypes != null) {\n            final Set<Map.Entry<String, Genotype>> genotypes = vc.getGenotypes().entrySet();\n            for ( final Map.Entry<String, Genotype> genotype : genotypes ) {\n                final AlignmentContext thisContext = stratifiedContexts.get(genotype.getKey());\n                if ( thisContext != null ) {\n                    final ReadBackedPileup thisPileup;\n                    if (thisContext.hasExtendedEventPileup())\n                        thisPileup = thisContext.getExtendedEventPileup();\n                    else if (thisContext.hasBasePileup())\n                        thisPileup = thisContext.getBasePileup();\n                    else\n                        thisPileup = null;\n\n                    if (thisPileup != null) {\n                        if (vc.isSNP())\n                            scoreRA.add( scoreReadsAgainstHaplotypes(haplotypes, thisPileup, contextSize, locus) ); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                        else if (vc.isIndel() || vc.isMixed()) {\n                            Double d = scoreIndelsAgainstHaplotypes(thisPileup);\n                            if (d == null)\n                                return null;\n                            scoreRA.add( d ); // Taking the simple average of all sample's score since the score can be negative and the RMS doesn't make sense\n                        }\n                        else\n                            return null;\n\n                    }\n                }\n            }\n        }\n\n        // annotate the score in the info field\n        final Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", scoreRA.mean()));\n        return map;\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Integer> refQuals, List<Integer> altQuals) {\n        for ( final PileupElement p : pileup ) {\n            if( isUsableBase(p) && p.getMappingQual() < 254 ) { // 254 and 255 are special mapping qualities used as a code by aligners\n                if ( p.getBase() == ref ) {\n                    refQuals.add(p.getMappingQual());\n                } else if ( p.getBase() == alt ) {\n                    altQuals.add(p.getMappingQual());\n                }\n            }\n        }\n    }","id":89213,"modified_method":"protected void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Double> refQuals, List<Double> altQuals) {\n        for ( final PileupElement p : pileup ) {\n            if( isUsableBase(p) && p.getMappingQual() < 254 ) { // 254 and 255 are special mapping qualities used as a code by aligners\n                if ( p.getBase() == ref ) {\n                    refQuals.add((double)p.getMappingQual());\n                } else if ( p.getBase() == alt ) {\n                    altQuals.add((double)p.getMappingQual());\n                }\n            }\n        }\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected abstract void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Integer> refQuals, List<Integer> altQuals);","id":89214,"modified_method":"protected abstract void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Double> refQuals, List<Double> altQuals);","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n         \n        if ( !vc.isBiallelic() || !vc.isSNP() )\n            return null;\n        \n        final Map<String, Genotype> genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() == 0 )\n            return null;\n\n        final ArrayList<Integer> refQuals = new ArrayList<Integer>();\n        final ArrayList<Integer> altQuals = new ArrayList<Integer>();\n\n        for ( final Map.Entry<String, Genotype> genotype : genotypes.entrySet() ) {\n            final AlignmentContext context = stratifiedContexts.get(genotype.getKey());\n            if ( context == null ) {\n                continue;\n            }\n            fillQualsFromPileup(ref.getBase(), vc.getAlternateAllele(0).getBases()[0], context.getBasePileup(), refQuals, altQuals);\n        }\n\n        final MannWhitneyU mannWhitneyU = new MannWhitneyU();\n        for ( final Integer qual : altQuals ) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET1);\n        }\n        for ( final Integer qual : refQuals ) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET2);\n        }\n\n        // we are testing that set1 (the alt bases) have lower quality scores than set2 (the ref bases)\n        final Pair<Double,Double> testResults = mannWhitneyU.runOneSidedTest( MannWhitneyU.USet.SET1 );\n\n        final Map<String, Object> map = new HashMap<String, Object>();\n        if ( ! Double.isNaN(testResults.first) )\n            map.put(getKeyNames().get(0), String.format(\"%.3f\", testResults.first));\n        return map;\n    }","id":89215,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if ( stratifiedContexts.size() == 0 )\n            return null;\n         \n        final Map<String, Genotype> genotypes = vc.getGenotypes();\n        if ( genotypes == null || genotypes.size() == 0 )\n            return null;\n\n\n        final ArrayList<Double> refQuals = new ArrayList<Double>();\n        final ArrayList<Double> altQuals = new ArrayList<Double>();\n\n        if (vc.isSNP() && vc.isBiallelic()) {\n            // todo - no current support for multiallelic snps\n            for ( final Map.Entry<String, Genotype> genotype : genotypes.entrySet() ) {\n                final AlignmentContext context = stratifiedContexts.get(genotype.getKey());\n                if ( context == null ) {\n                    continue;\n                }\n                fillQualsFromPileup(ref.getBase(), vc.getAlternateAllele(0).getBases()[0], context.getBasePileup(), refQuals, altQuals);\n            }\n        }\n        else if (vc.isIndel() || vc.isMixed()) {\n\n            for ( final Map.Entry<String, Genotype> genotype : genotypes.entrySet() ) {\n                final AlignmentContext context = stratifiedContexts.get(genotype.getKey());\n                if ( context == null ) {\n                    continue;\n                }\n\n                ReadBackedPileup pileup = null;\n                if (context.hasExtendedEventPileup())\n                    pileup = context.getExtendedEventPileup();\n                else if (context.hasBasePileup())\n                    pileup = context.getBasePileup();\n\n                if (pileup == null)\n                    continue;\n\n                if (IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap() == null ||\n                        IndelGenotypeLikelihoodsCalculationModel.getIndelLikelihoodMap().size() == 0)\n                    return null;\n\n                fillIndelQualsFromPileup(pileup, refQuals, altQuals);\n            }\n        }\n        else\n            return null;\n\n        final MannWhitneyU mannWhitneyU = new MannWhitneyU();\n        for ( final Double qual : altQuals ) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET1);\n        }\n        for ( final Double qual : refQuals ) {\n            mannWhitneyU.add(qual, MannWhitneyU.USet.SET2);\n        }\n\n        if (DEBUG) {\n            System.out.format(\"%s, REF QUALS:\",this.getClass().getName());\n            for ( final Double qual : refQuals )\n                System.out.format(\"%4.1f \",qual);\n            System.out.println();\n            System.out.format(\"%s, ALT QUALS:\",this.getClass().getName());            \n            for ( final Double qual : altQuals )\n                System.out.format(\"%4.1f \",qual);\n            System.out.println();\n\n        }\n        // we are testing that set1 (the alt bases) have lower quality scores than set2 (the ref bases)\n        final Pair<Double,Double> testResults = mannWhitneyU.runOneSidedTest( MannWhitneyU.USet.SET1 );\n\n        final Map<String, Object> map = new HashMap<String, Object>();\n        if ( ! Double.isNaN(testResults.first) )\n            map.put(getKeyNames().get(0), String.format(\"%.3f\", testResults.first));\n        return map;\n\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Integer> refQuals, List<Integer> altQuals) {\n        for ( final PileupElement p : pileup ) {\n            if( isUsableBase(p) ) {\n                int readPos = AlignmentUtils.calcAlignmentByteArrayOffset(p.getRead().getCigar(), p.getOffset(), 0, 0);\n                final int numAlignedBases = AlignmentUtils.getNumAlignedBases(p.getRead());\n                if( readPos > numAlignedBases / 2 ) {\n                    readPos = numAlignedBases - ( readPos + 1 );\n                }\n\n                if ( p.getBase() == ref ) {\n                    refQuals.add( readPos );\n                } else if ( p.getBase() == alt ) {\n                    altQuals.add( readPos );\n                }\n            }\n        }\n    }","id":89216,"modified_method":"protected void fillQualsFromPileup(byte ref, byte alt, ReadBackedPileup pileup, List<Double> refQuals, List<Double> altQuals) {\n        for ( final PileupElement p : pileup ) {\n            if( isUsableBase(p) ) {\n                int readPos = AlignmentUtils.calcAlignmentByteArrayOffset(p.getRead().getCigar(), p.getOffset(), 0, 0);\n                final int numAlignedBases = AlignmentUtils.getNumAlignedBases(p.getRead());\n                if( readPos > numAlignedBases / 2 ) {\n                    readPos = numAlignedBases - ( readPos + 1 );\n                }\n\n                if ( p.getBase() == ref ) {\n                    refQuals.add( (double)readPos );\n                } else if ( p.getBase() == alt ) {\n                    altQuals.add( (double)readPos );\n                }\n            }\n        }\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiTechnologies() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,100,000\",\n                1,\n                Arrays.asList(\"d453f2e44fb7f0ec027c2a5f791da6aa\"));\n\n        executeTest(String.format(\"test multiple technologies\"), spec);\n    }","id":89217,"modified_method":"@Test\n    public void testMultiTechnologies() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,100,000\",\n                1,\n                Arrays.asList(\"4de696898979e57644e5c983e40b882a\"));\n\n        executeTest(String.format(\"test multiple technologies\"), spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testHeterozyosity() {\n        HashMap<Double, String> e = new HashMap<Double, String>();\n        e.put( 0.01, \"649590cbfc67bddf82416a0b82027696\" );\n        e.put( 1.0 / 1850, \"22153b7d06d13ea1a1ffdc45d7668974\" );\n\n        for ( Map.Entry<Double, String> entry : e.entrySet() ) {\n            WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                    baseCommand + \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -o %s -L 1:10,000,000-10,100,000 --heterozygosity \" + entry.getKey(), 1,\n                    Arrays.asList(entry.getValue()));\n            executeTest(String.format(\"test heterozyosity[%s]\", entry.getKey()), spec);\n        }\n    }","id":89218,"modified_method":"@Test\n    public void testHeterozyosity() {\n        HashMap<Double, String> e = new HashMap<Double, String>();\n        e.put( 0.01, \"cb8da711af63409f75c49cff3680b7e1\" );\n        e.put( 1.0 / 1850, \"4249a2ab3ff7516d3a77521d9516eb23\" );\n\n        for ( Map.Entry<Double, String> entry : e.entrySet() ) {\n            WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                    baseCommand + \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -o %s -L 1:10,000,000-10,100,000 --heterozygosity \" + entry.getKey(), 1,\n                    Arrays.asList(entry.getValue()));\n            executeTest(String.format(\"test heterozyosity[%s]\", entry.getKey()), spec);\n        }\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testOutputParameter() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( \"-sites_only\", \"71f61655f725cda56bc46d99d1cc24eb\" );\n        e.put( \"--output_mode EMIT_ALL_CONFIDENT_SITES\", \"8193a4c06ddbd82d0a328491118b16a8\" );\n        e.put( \"--output_mode EMIT_ALL_SITES\", \"89859bd987e8b797d37f5dec54d37e9c\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                    baseCommand + \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -o %s -L 1:10,000,000-10,010,000 \" + entry.getKey(), 1,\n                    Arrays.asList(entry.getValue()));\n            executeTest(String.format(\"testParameter[%s]\", entry.getKey()), spec);\n        }\n    }","id":89219,"modified_method":"@Test\n    public void testOutputParameter() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( \"-sites_only\", \"71f61655f725cda56bc46d99d1cc24eb\" );\n        e.put( \"--output_mode EMIT_ALL_CONFIDENT_SITES\", \"8193a4c06ddbd82d0a328491118b16a8\" );\n        e.put( \"--output_mode EMIT_ALL_SITES\", \"74c25dedf25652e35707fb617d7637b6\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                    baseCommand + \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -o %s -L 1:10,000,000-10,010,000 \" + entry.getKey(), 1,\n                    Arrays.asList(entry.getValue()));\n            executeTest(String.format(\"testParameter[%s]\", entry.getKey()), spec);\n        }\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiTechnologyIndels() {\n         WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                 baseCommandIndels +\n                         \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                         \" -o %s\" +\n                         \" -L 1:10,000,000-10,500,000\",\n                 1,\n                 Arrays.asList(\"32a06420a3357c1451fdc36a40df4d08\"));\n\n         executeTest(String.format(\"test indel calling, multiple technologies\"), spec);\n     }","id":89220,"modified_method":"@Test\n    public void testMultiTechnologyIndels() {\n         WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                 baseCommandIndels +\n                         \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                         \" -o %s\" +\n                         \" -L 1:10,000,000-10,500,000\",\n                 1,\n                 Arrays.asList(\"8d4b2d5a093cbd6f421e85390d346f83\"));\n\n         executeTest(String.format(\"test indel calling, multiple technologies\"), spec);\n     }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCallingWithBAQOff() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,100,000\" +\n                        \" -baq OFF\",\n                1,\n                Arrays.asList(\"d453f2e44fb7f0ec027c2a5f791da6aa\"));\n\n        executeTest(String.format(\"test calling with BAQ OFF\"), spec);\n    }","id":89221,"modified_method":"@Test\n    public void testCallingWithBAQOff() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,100,000\" +\n                        \" -baq OFF\",\n                1,\n                Arrays.asList(\"4de696898979e57644e5c983e40b882a\"));\n\n        executeTest(String.format(\"test calling with BAQ OFF\"), spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCallingWithBAQ() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,100,000\" +\n                        \" -baq CALCULATE_AS_NECESSARY\",\n                1,\n                Arrays.asList(\"60cc4c793caaf891075d862a2376d73c\"));\n\n        executeTest(String.format(\"test calling with BAQ\"), spec);\n    }","id":89222,"modified_method":"@Test\n    public void testCallingWithBAQ() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,100,000\" +\n                        \" -baq CALCULATE_AS_NECESSARY\",\n                1,\n                Arrays.asList(\"e31fb159a93011edd66c02b365c6c76e\"));\n\n        executeTest(String.format(\"test calling with BAQ\"), spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testSingleSamplePilot2() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand + \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -o %s -L 1:10,000,000-10,100,000\", 1,\n                Arrays.asList(\"61db698ea6d11deba2fc900bd544b082\"));\n        executeTest(\"test SingleSample Pilot2\", spec);\n    }","id":89223,"modified_method":"@Test\n    public void testSingleSamplePilot2() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand + \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -o %s -L 1:10,000,000-10,100,000\", 1,\n                Arrays.asList(\"274a4eae68b0083191d59b95db95cbfc\"));\n        executeTest(\"test SingleSample Pilot2\", spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testIndelsWithLowMinAlleleCnt() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam\" +\n                        \" -o %s\" +\n                        \" -minIndelCnt 1\" +\n                        \" -L 1:10,000,000-10,100,000\",\n                1,\n                Arrays.asList(\"11d761009bfbc04ba23cbee000a62954\"));\n\n        executeTest(String.format(\"test indel caller in SLX witn low min allele count\"), spec);\n    }","id":89224,"modified_method":"@Test\n    public void testIndelsWithLowMinAlleleCnt() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam\" +\n                        \" -o %s\" +\n                        \" -minIndelCnt 1\" +\n                        \" -L 1:10,000,000-10,100,000\",\n                1,\n                Arrays.asList(\"cb1e3d077b7fb17eb4f1be758ed4e4d6\"));\n\n        executeTest(String.format(\"test indel caller in SLX witn low min allele count\"), spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void testWithIndelAllelesPassedIn() {\n        WalkerTest.WalkerTestSpec spec1 = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels + \" --genotyping_mode GENOTYPE_GIVEN_ALLELES -B:alleles,vcf \" + validationDataLocation + \"indelAllelesForUG.vcf -I \" + validationDataLocation +\n                        \"pilot2_daughters.chr20.10k-11k.bam -o %s -L 20:10,000,000-10,100,000\", 1,\n                Arrays.asList(\"e95c545b8ae06f0721f260125cfbe1f0\"));\n        executeTest(\"test MultiSample Pilot2 indels with alleles passed in\", spec1);\n\n        WalkerTest.WalkerTestSpec spec2 = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels + \" --output_mode EMIT_ALL_SITES --genotyping_mode GENOTYPE_GIVEN_ALLELES -B:alleles,vcf \"\n                        + validationDataLocation + \"indelAllelesForUG.vcf -I \" + validationDataLocation +\n                        \"pilot2_daughters.chr20.10k-11k.bam -o %s -L 20:10,000,000-10,100,000\", 1,\n                Arrays.asList(\"6c96d76b9bc3aade0c768d7c657ae210\"));\n        executeTest(\"test MultiSample Pilot2 indels with alleles passed in and emitting all sites\", spec2);\n    }","id":89225,"modified_method":"@Test\n    public void testWithIndelAllelesPassedIn() {\n        WalkerTest.WalkerTestSpec spec1 = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels + \" --genotyping_mode GENOTYPE_GIVEN_ALLELES -B:alleles,vcf \" + validationDataLocation + \"indelAllelesForUG.vcf -I \" + validationDataLocation +\n                        \"pilot2_daughters.chr20.10k-11k.bam -o %s -L 20:10,000,000-10,100,000\", 1,\n                Arrays.asList(\"a3351235c893d38ed4b1d23ab3cda744\"));\n        executeTest(\"test MultiSample Pilot2 indels with alleles passed in\", spec1);\n\n        WalkerTest.WalkerTestSpec spec2 = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels + \" --output_mode EMIT_ALL_SITES --genotyping_mode GENOTYPE_GIVEN_ALLELES -B:alleles,vcf \"\n                        + validationDataLocation + \"indelAllelesForUG.vcf -I \" + validationDataLocation +\n                        \"pilot2_daughters.chr20.10k-11k.bam -o %s -L 20:10,000,000-10,100,000\", 1,\n                Arrays.asList(\"31afc73ecba6b466bcb17ef3ebdd7a99\"));\n        executeTest(\"test MultiSample Pilot2 indels with alleles passed in and emitting all sites\", spec2);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testSimpleIndels() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,500,000\",\n                1,\n                Arrays.asList(\"51726ce0b309a77cb833dd2e11e2219e\"));\n\n        executeTest(String.format(\"test indel caller in SLX\"), spec);\n    }","id":89226,"modified_method":"@Test\n    public void testSimpleIndels() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommandIndels +\n                        \" -I \" + validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam\" +\n                        \" -o %s\" +\n                        \" -L 1:10,000,000-10,500,000\",\n                1,\n                Arrays.asList(\"ca800d36708a337c3e29216c1b73bb6d\"));\n\n        executeTest(String.format(\"test indel caller in SLX\"), spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiSamplePilot1() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand + \" -I \" + validationDataLocation + \"low_coverage_CEU.chr1.10k-11k.bam -o %s -L 1:10,022,000-10,025,000\", 1,\n                Arrays.asList(\"91246d154ba379cb04a1920d365f11c3\"));\n        executeTest(\"test MultiSample Pilot1\", spec);\n    }","id":89227,"modified_method":"@Test\n    public void testMultiSamplePilot1() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                baseCommand + \" -I \" + validationDataLocation + \"low_coverage_CEU.chr1.10k-11k.bam -o %s -L 1:10,022,000-10,025,000\", 1,\n                Arrays.asList(\"82d77402919f5d5b627a789f0bfffbb9\"));\n        executeTest(\"test MultiSample Pilot1\", spec);\n    }","commit_id":"d534241f35505d757f39d482d45d3316d6dd944e","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void addDeployment(CommandContext ctx, final File f, String name, final String runtimeName) {\n        ModelNode request = new ModelNode();\n        request.get(Util.OPERATION).set(Util.ADD);\n        request.get(Util.ADDRESS, Util.DEPLOYMENT).set(name);\n        if (runtimeName != null) {\n            request.get(Util.RUNTIME_NAME).set(runtimeName);\n        }\n\n        ModelNode result;\n        FileInputStream is = null;\n        try {\n            is = new FileInputStream(f);\n            OperationBuilder op = new OperationBuilder(request);\n            op.addInputStream(is);\n            request.get(Util.CONTENT).get(0).get(Util.INPUT_STREAM_INDEX).set(0);\n            result = ctx.getModelControllerClient().execute(op.build());\n        } catch (Exception e) {\n            ctx.printLine(\"Failed to add the deployment content to the repository: \" + e.getLocalizedMessage());\n            return;\n        } finally {\n            StreamUtils.safeClose(is);\n        }\n        if (!Util.isSuccess(result)) {\n            ctx.printLine(Util.getFailureDescription(result));\n            return;\n        }\n    }","id":89228,"modified_method":"protected ModelNode buildAddRequest(CommandContext ctx, final File f, String name, final String runtimeName) {\n        final ModelNode request = new ModelNode();\n        request.get(Util.OPERATION).set(Util.ADD);\n        request.get(Util.ADDRESS, Util.DEPLOYMENT).set(name);\n        if (runtimeName != null) {\n            request.get(Util.RUNTIME_NAME).set(runtimeName);\n        }\n        request.get(Util.CONTENT).get(0).get(Util.INPUT_STREAM_INDEX).set(0);\n        return request;\n    }","commit_id":"53636d77d07cc35a8cdd2b308ddc751fbc92caa7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        ParsedCommandLine args = ctx.getParsedCommandLine();\n        boolean l = this.l.isPresent(args);\n        if (!args.hasProperties() || l) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                ctx.printLine(\"Path \" + f.getAbsolutePath() + \" doesn't exist.\");\n                return;\n            }\n            if(f.isDirectory()) {\n                ctx.printLine(f.getAbsolutePath() + \" is a directory.\");\n                return;\n            }\n        } else {\n            f = null;\n        }\n\n        String name = this.name.getValue(args);\n        if(name == null) {\n            if(f == null) {\n                ctx.printLine(\"Either path or --name is requied.\");\n                return;\n            }\n            name = f.getName();\n        }\n\n        final String runtimeName = rtName.getValue(args);\n\n        final boolean force = this.force.isPresent(args);\n        final boolean disabled = this.disabled.isPresent(args);\n        final String serverGroups = this.serverGroups.getValue(args);\n        final boolean allServerGroups = this.allServerGroups.isPresent(args);\n\n        if(force) {\n            if(f == null) {\n                ctx.printLine(this.force.getFullName() + \" requires a filesystem path of the deployment to be added to the deployment repository.\");\n                return;\n            }\n            if(disabled || serverGroups != null || allServerGroups) {\n                ctx.printLine(this.force.getFullName() +\n                        \" only replaces the content in the deployment repository and can't be used in combination with any of \" +\n                        this.disabled.getFullName() + \", \" + this.serverGroups.getFullName() + \" or \" + this.allServerGroups.getFullName() + '.');\n                return;\n            }\n\n            if(Util.isDeploymentInRepository(name, client)) {\n                replaceDeployment(ctx, f, name, runtimeName);\n            } else {\n                // add deployment to the repository (enabled in standalone, disabled in domain (i.e. not associated with any sg))\n                addDeployment(ctx, f, name, runtimeName);\n            }\n            return;\n        }\n\n        if(disabled) {\n            if(f == null) {\n                ctx.printLine(this.disabled.getFullName() + \" requires a filesystem path of the deployment to be added to the deployment repository.\");\n                return;\n            }\n\n            if(serverGroups != null || allServerGroups) {\n                ctx.printLine(this.serverGroups.getFullName() + \" and \" + this.allServerGroups.getFullName() +\n                        \" can't be used in combination with \" + this.disabled.getFullName() + '.');\n                return;\n            }\n\n            if(Util.isDeploymentInRepository(name, client)) {\n                ctx.printLine(\"'\" + name + \"' already exists in the deployment repository (use \" +\n                this.force.getFullName() + \" to replace the existing content in the repository).\");\n                return;\n            }\n\n            // add deployment to the repository disabled\n            addDeployment(ctx, f, name, runtimeName);\n            return;\n        }\n\n        // actually, the deployment is added before it is deployed\n        // but this code here is to validate arguments and not to add deployment if something is wrong\n        ModelNode deployRequest = null;\n        if(ctx.isDomainMode()) {\n            final List<String> sgList;\n            if(allServerGroups) {\n                if(serverGroups != null) {\n                    ctx.printLine(this.serverGroups.getFullName() + \" can't appear in the same command with \" + this.allServerGroups.getFullName());\n                    return;\n                }\n                sgList = Util.getServerGroups(client);\n                if(sgList.isEmpty()) {\n                    ctx.printLine(\"No server group is available.\");\n                    return;\n                }\n            } else if(serverGroups == null) {\n                final StringBuilder buf = new StringBuilder();\n                buf.append(\"One of \");\n                if(f != null) {\n                    buf.append(this.disabled.getFullName()).append(\", \");\n                }\n                buf.append(this.allServerGroups.getFullName() + \" or \" + this.serverGroups.getFullName() + \" is missing.\");\n                ctx.printLine(buf.toString());\n                return;\n            } else {\n                sgList = Arrays.asList(serverGroups.split(\",\"));\n                if(sgList.isEmpty()) {\n                    ctx.printLine(\"Couldn't locate server group name in '\" + this.serverGroups.getFullName() + \"=\" + serverGroups + \"'.\");\n                    return;\n                }\n            }\n\n            deployRequest = new ModelNode();\n            deployRequest.get(Util.OPERATION).set(Util.COMPOSITE);\n            deployRequest.get(Util.ADDRESS).setEmptyList();\n            ModelNode steps = deployRequest.get(Util.STEPS);\n            for (String serverGroup : sgList) {\n                steps.add(Util.configureDeploymentOperation(Util.ADD, name, serverGroup));\n            }\n            for (String serverGroup : sgList) {\n                steps.add(Util.configureDeploymentOperation(Util.DEPLOY, name, serverGroup));\n            }\n        } else {\n            if(serverGroups != null || allServerGroups) {\n                ctx.printLine(this.serverGroups.getFullName() + \" and \" + this.allServerGroups.getFullName() +\n                        \" can't appear in standalone mode.\");\n                return;\n            }\n            deployRequest = new ModelNode();\n            deployRequest.get(Util.OPERATION).set(Util.DEPLOY);\n            deployRequest.get(Util.ADDRESS, Util.DEPLOYMENT).set(name);\n        }\n\n        if(f != null) {\n            if(Util.isDeploymentInRepository(name, client)) {\n                ctx.printLine(\"'\" + name + \"' already exists in the deployment repository (use \" +\n                this.force.getFullName() + \" to replace the existing content in the repository).\");\n                return;\n            }\n            addDeployment(ctx, f, name, runtimeName);\n        } else if(!Util.isDeploymentInRepository(name, client)) {\n            ctx.printLine(\"'\" + name + \"' is not found among the registered deployments.\");\n            return;\n        }\n\n        if(deployRequest != null) {\n            try {\n                final ModelNode result = client.execute(deployRequest);\n                if (!Util.isSuccess(result)) {\n                    ctx.printLine(Util.getFailureDescription(result));\n                    return;\n                }\n            } catch (Exception e) {\n                ctx.printLine(\"Failed to deploy: \" + e.getLocalizedMessage());\n                return;\n            }\n\n        }\n    }","id":89229,"modified_method":"@Override\n    protected void doHandle(CommandContext ctx) throws CommandFormatException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        ParsedCommandLine args = ctx.getParsedCommandLine();\n        boolean l = this.l.isPresent(args);\n        if (!args.hasProperties() || l) {\n            printList(ctx, Util.getDeployments(client), l);\n            return;\n        }\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                ctx.printLine(\"Path \" + f.getAbsolutePath() + \" doesn't exist.\");\n                return;\n            }\n            if(f.isDirectory()) {\n                ctx.printLine(f.getAbsolutePath() + \" is a directory.\");\n                return;\n            }\n        } else {\n            f = null;\n        }\n\n        String name = this.name.getValue(args);\n        if(name == null) {\n            if(f == null) {\n                ctx.printLine(\"Either path or --name is requied.\");\n                return;\n            }\n            name = f.getName();\n        }\n\n        final String runtimeName = rtName.getValue(args);\n\n        final boolean force = this.force.isPresent(args);\n        final boolean disabled = this.disabled.isPresent(args);\n        final String serverGroups = this.serverGroups.getValue(args);\n        final boolean allServerGroups = this.allServerGroups.isPresent(args);\n\n        if(force) {\n            if(f == null) {\n                ctx.printLine(this.force.getFullName() + \" requires a filesystem path of the deployment to be added to the deployment repository.\");\n                return;\n            }\n            if(disabled || serverGroups != null || allServerGroups) {\n                ctx.printLine(this.force.getFullName() +\n                        \" only replaces the content in the deployment repository and can't be used in combination with any of \" +\n                        this.disabled.getFullName() + \", \" + this.serverGroups.getFullName() + \" or \" + this.allServerGroups.getFullName() + '.');\n                return;\n            }\n\n            if(Util.isDeploymentInRepository(name, client)) {\n                replaceDeployment(ctx, f, name, runtimeName);\n                return;\n            } else if(ctx.isDomainMode()) {\n                // add deployment to the repository (enabled in standalone, disabled in domain (i.e. not associated with any sg))\n                final ModelNode request = buildAddRequest(ctx, f, name, runtimeName);\n                execute(ctx, request, f);\n                return;\n            }\n            // standalone mode will add and deploy\n        }\n\n        if(disabled) {\n            if(f == null) {\n                ctx.printLine(this.disabled.getFullName() + \" requires a filesystem path of the deployment to be added to the deployment repository.\");\n                return;\n            }\n\n            if(serverGroups != null || allServerGroups) {\n                ctx.printLine(this.serverGroups.getFullName() + \" and \" + this.allServerGroups.getFullName() +\n                        \" can't be used in combination with \" + this.disabled.getFullName() + '.');\n                return;\n            }\n\n            if(Util.isDeploymentInRepository(name, client)) {\n                ctx.printLine(\"'\" + name + \"' already exists in the deployment repository (use \" +\n                this.force.getFullName() + \" to replace the existing content in the repository).\");\n                return;\n            }\n\n            // add deployment to the repository disabled\n            final ModelNode request = buildAddRequest(ctx, f, name, runtimeName);\n            execute(ctx, request, f);\n            return;\n        }\n\n        // actually, the deployment is added before it is deployed\n        // but this code here is to validate arguments and not to add deployment if something is wrong\n        final ModelNode deployRequest;\n        if(ctx.isDomainMode()) {\n            final List<String> sgList;\n            if(allServerGroups) {\n                if(serverGroups != null) {\n                    ctx.printLine(this.serverGroups.getFullName() + \" can't appear in the same command with \" + this.allServerGroups.getFullName());\n                    return;\n                }\n                sgList = Util.getServerGroups(client);\n                if(sgList.isEmpty()) {\n                    ctx.printLine(\"No server group is available.\");\n                    return;\n                }\n            } else if(serverGroups == null) {\n                final StringBuilder buf = new StringBuilder();\n                buf.append(\"One of \");\n                if(f != null) {\n                    buf.append(this.disabled.getFullName()).append(\", \");\n                }\n                buf.append(this.allServerGroups.getFullName() + \" or \" + this.serverGroups.getFullName() + \" is missing.\");\n                ctx.printLine(buf.toString());\n                return;\n            } else {\n                sgList = Arrays.asList(serverGroups.split(\",\"));\n                if(sgList.isEmpty()) {\n                    ctx.printLine(\"Couldn't locate server group name in '\" + this.serverGroups.getFullName() + \"=\" + serverGroups + \"'.\");\n                    return;\n                }\n            }\n\n            deployRequest = new ModelNode();\n            deployRequest.get(Util.OPERATION).set(Util.COMPOSITE);\n            deployRequest.get(Util.ADDRESS).setEmptyList();\n            ModelNode steps = deployRequest.get(Util.STEPS);\n            for (String serverGroup : sgList) {\n                steps.add(Util.configureDeploymentOperation(Util.ADD, name, serverGroup));\n            }\n            for (String serverGroup : sgList) {\n                steps.add(Util.configureDeploymentOperation(Util.DEPLOY, name, serverGroup));\n            }\n        } else {\n            if(serverGroups != null || allServerGroups) {\n                ctx.printLine(this.serverGroups.getFullName() + \" and \" + this.allServerGroups.getFullName() +\n                        \" can't appear in standalone mode.\");\n                return;\n            }\n            deployRequest = new ModelNode();\n            deployRequest.get(Util.OPERATION).set(Util.DEPLOY);\n            deployRequest.get(Util.ADDRESS, Util.DEPLOYMENT).set(name);\n        }\n\n        if(f != null) {\n            if(Util.isDeploymentInRepository(name, client)) {\n                ctx.printLine(\"'\" + name + \"' already exists in the deployment repository (use \" +\n                this.force.getFullName() + \" to replace the existing content in the repository).\");\n                return;\n            }\n            final ModelNode request = new ModelNode();\n            request.get(Util.OPERATION).set(Util.COMPOSITE);\n            request.get(Util.ADDRESS).setEmptyList();\n            final ModelNode steps = request.get(Util.STEPS);\n            steps.add(buildAddRequest(ctx, f, name, runtimeName));\n            steps.add(deployRequest);\n            execute(ctx, request, f);\n            return;\n        } else if(!Util.isDeploymentInRepository(name, client)) {\n            ctx.printLine(\"'\" + name + \"' is not found among the registered deployments.\");\n            return;\n        }\n\n        try {\n            final ModelNode result = client.execute(deployRequest);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(Util.getFailureDescription(result));\n                return;\n            }\n        } catch (Exception e) {\n            ctx.printLine(\"Failed to deploy: \" + e.getLocalizedMessage());\n            return;\n        }\n    }","commit_id":"53636d77d07cc35a8cdd2b308ddc751fbc92caa7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void main(String[] args) throws IOException {\n        generateTest(\n                \"compiler/tests/\",\n                \"JetDiagnosticsTestGenerated\",\n                AbstractDiagnosticsTestWithEagerResolve.class,\n                testModel(\"compiler/testData/diagnostics/tests\"),\n                testModel(\"compiler/testData/diagnostics/tests/script\", true, \"ktscript\", \"doTest\")\n        );\n\n        GenerateRangesCodegenTestData.main(args);\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                testModel(\"compiler/testData/codegen/box\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxMultiFileCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                new SimpleTestClassModel(new File(\"compiler/testData/codegen/boxMultiFile\"), false, Pattern.compile(\"^(.+)$\"), \"doTestMultiFile\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxWithJavaCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                testModel(\"compiler/testData/codegen/boxWithJava\", \"doTestWithJava\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxWithStdlibCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                testModel(\"compiler/testData/codegen/boxWithStdlib\", \"doTestWithStdlib\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BytecodeTextTestGenerated\",\n                AbstractBytecodeTextTest.class,\n                testModel(\"compiler/testData/codegen/bytecodeText\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CheckLocalVariablesTableTestGenerated\",\n                AbstractCheckLocalVariablesTableTest.class,\n                testModel(\"compiler/testData/checkLocalVariablesTable\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"WriteFlagsTestGenerated\",\n                AbstractWriteFlagsTest.class,\n                testModel(\"compiler/testData/writeFlags\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"DefaultArgumentsReflectionTestGenerated\",\n                AbstractDefaultConstructorCodegenTest.class,\n                testModel(\"compiler/testData/codegen/defaultArguments/reflection\")\n        );\n\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LoadCompiledKotlinTestGenerated\",\n                AbstractLoadCompiledKotlinTest.class,\n                testModel(\"compiler/testData/loadKotlin\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LoadJavaTestGenerated\",\n                AbstractLoadJavaTest.class,\n                testModel(\"compiler/testData/loadJava\", true, \"java\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CompileJavaAgainstKotlinTestGenerated\",\n                AbstractCompileJavaAgainstKotlinTest.class,\n                testModel(\"compiler/testData/compileJavaAgainstKotlin\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CompileKotlinAgainstKotlinTestGenerated\",\n                AbstractCompileKotlinAgainstKotlinTest.class,\n                testModel(\"compiler/testData/compileKotlinAgainstKotlin\", true, \"A.kt\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CompileKotlinAgainstCustomJavaGenerated\",\n                AbstractCompileKotlinAgainstCustomJavaTest.class,\n                testModel(\"compiler/testData/compileKotlinAgainstCustomJava\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LazyResolveDescriptorRendererTestGenerated\",\n                AbstractLazyResolveDescriptorRendererTest.class,\n                testModel(\"compiler/testData/renderer\")\n        );\n\n        // TODO test is temporarily disabled\n        //generateTest(\n        //        \"compiler/tests/\",\n        //        \"org.jetbrains.jet.lang.resolve.lazy\",\n        //        \"LazyResolveDiagnosticsTestGenerated\",\n        //        AbstractLazyResolveDiagnosticsTest.class,\n        //        new SimpleTestClassModel(AbstractLazyResolveDiagnosticsTest.TEST_DATA_DIR, true, \"kt\", \"doTest\")\n        //);\n\n        generateTest(\"compiler/tests\",\n                     \"LazyResolveTestGenerated\",\n                     AbstractLazyResolveTest.class,\n                     testModel(\"compiler/testData/resolve/imports\", false, \"resolve\", \"doTest\"));\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LazyResolveNamespaceComparingTestGenerated\",\n                AbstractLazyResolveNamespaceComparingTest.class,\n                testModel(\"compiler/testData/loadKotlin\", \"doTestCheckingPrimaryConstructors\"),\n                testModel(\"compiler/testData/loadJava\", \"doTestNotCheckingPrimaryConstructors\"),\n                testModel(\"compiler/testData/lazyResolve/namespaceComparator\", \"doTestCheckingPrimaryConstructors\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"JetPsiCheckerTestGenerated\",\n                AbstractJetPsiCheckerTest.class,\n                testModel(\"idea/testData/checker\", false, \"kt\", \"doTest\"),\n                testModel(\"idea/testData/checker/regression\"),\n                testModel(\"idea/testData/checker/rendering\"),\n                testModel(\"idea/testData/checker/infos\", false, \"kt\", \"doTestWithInfos\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"QuickFixTestGenerated\",\n                AbstractQuickFixTest.class,\n                new SimpleTestClassModel(new File(\"idea/testData/quickfix\"), true, Pattern.compile(\"^before(\\\\w+)\\\\.kt$\"), \"doTest\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"QuickFixMultiFileTestGenerated\",\n                AbstractQuickFixMultiFileTest.class,\n                new SimpleTestClassModel(new File(\"idea/testData/quickfix\"), true, Pattern.compile(\"^(\\\\w+)\\\\.before\\\\.Main\\\\.kt$\"), \"doTestWithExtraFile\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"DeprecatedHighlightingTestGenerated\",\n                AbstractDeprecatedHighlightingTest.class,\n                testModel(\"idea/testData/highlighter/deprecated\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithIfTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/if\", \"doTestWithIfSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithIfElseTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/ifElse\", \"doTestWithIfElseSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithNotTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/not\", \"doTestWithNotSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithParenthesesTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/parentheses\", \"doTestWithParenthesesSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithStringTemplateTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/stringTemplate\", \"doTestWithStringTemplateSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithWhenTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/when\", \"doTestWithWhenSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithTryCatchTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/tryCatch\", \"doTestWithTryCatchSurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithTryCatchFinallyTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/tryCatchFinally\", \"doTestWithTryCatchFinallySurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithTryFinallyTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/tryFinally\", \"doTestWithTryFinallySurrounder\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithFunctionLiteralTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/functionLiteral\", \"doTestWithFunctionLiteralSurrounder\")\n        );\n    }","id":89230,"modified_method":"public static void main(String[] args) throws IOException {\n        generateTest(\n                \"compiler/tests/\",\n                \"JetDiagnosticsTestGenerated\",\n                AbstractDiagnosticsTestWithEagerResolve.class,\n                testModel(\"compiler/testData/diagnostics/tests\"),\n                testModel(\"compiler/testData/diagnostics/tests/script\", true, \"ktscript\", \"doTest\")\n        );\n\n        GenerateRangesCodegenTestData.main(args);\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                testModel(\"compiler/testData/codegen/box\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxMultiFileCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                new SimpleTestClassModel(new File(\"compiler/testData/codegen/boxMultiFile\"), false, Pattern.compile(\"^(.+)$\"), \"doTestMultiFile\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxWithJavaCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                testModel(\"compiler/testData/codegen/boxWithJava\", \"doTestWithJava\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BlackBoxWithStdlibCodegenTestGenerated\",\n                AbstractBlackBoxCodegenTest.class,\n                testModel(\"compiler/testData/codegen/boxWithStdlib\", \"doTestWithStdlib\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"BytecodeTextTestGenerated\",\n                AbstractBytecodeTextTest.class,\n                testModel(\"compiler/testData/codegen/bytecodeText\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CheckLocalVariablesTableTestGenerated\",\n                AbstractCheckLocalVariablesTableTest.class,\n                testModel(\"compiler/testData/checkLocalVariablesTable\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"WriteFlagsTestGenerated\",\n                AbstractWriteFlagsTest.class,\n                testModel(\"compiler/testData/writeFlags\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"DefaultArgumentsReflectionTestGenerated\",\n                AbstractDefaultConstructorCodegenTest.class,\n                testModel(\"compiler/testData/codegen/defaultArguments/reflection\")\n        );\n\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LoadCompiledKotlinTestGenerated\",\n                AbstractLoadCompiledKotlinTest.class,\n                testModel(\"compiler/testData/loadKotlin\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LoadJavaTestGenerated\",\n                AbstractLoadJavaTest.class,\n                testModel(\"compiler/testData/loadJava\", true, \"java\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CompileJavaAgainstKotlinTestGenerated\",\n                AbstractCompileJavaAgainstKotlinTest.class,\n                testModel(\"compiler/testData/compileJavaAgainstKotlin\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CompileKotlinAgainstKotlinTestGenerated\",\n                AbstractCompileKotlinAgainstKotlinTest.class,\n                testModel(\"compiler/testData/compileKotlinAgainstKotlin\", true, \"A.kt\", \"doTest\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"CompileKotlinAgainstCustomJavaGenerated\",\n                AbstractCompileKotlinAgainstCustomJavaTest.class,\n                testModel(\"compiler/testData/compileKotlinAgainstCustomJava\")\n        );\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LazyResolveDescriptorRendererTestGenerated\",\n                AbstractLazyResolveDescriptorRendererTest.class,\n                testModel(\"compiler/testData/renderer\")\n        );\n\n        // TODO test is temporarily disabled\n        //generateTest(\n        //        \"compiler/tests/\",\n        //        \"org.jetbrains.jet.lang.resolve.lazy\",\n        //        \"LazyResolveDiagnosticsTestGenerated\",\n        //        AbstractLazyResolveDiagnosticsTest.class,\n        //        new SimpleTestClassModel(AbstractLazyResolveDiagnosticsTest.TEST_DATA_DIR, true, \"kt\", \"doTest\")\n        //);\n\n        generateTest(\"compiler/tests\",\n                     \"LazyResolveTestGenerated\",\n                     AbstractLazyResolveTest.class,\n                     testModel(\"compiler/testData/resolve/imports\", false, \"resolve\", \"doTest\"));\n\n        generateTest(\n                \"compiler/tests/\",\n                \"LazyResolveNamespaceComparingTestGenerated\",\n                AbstractLazyResolveNamespaceComparingTest.class,\n                testModel(\"compiler/testData/loadKotlin\", \"doTestCheckingPrimaryConstructors\"),\n                testModel(\"compiler/testData/loadJava\", \"doTestNotCheckingPrimaryConstructors\"),\n                testModel(\"compiler/testData/lazyResolve/namespaceComparator\", \"doTestCheckingPrimaryConstructors\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"JetPsiCheckerTestGenerated\",\n                AbstractJetPsiCheckerTest.class,\n                testModel(\"idea/testData/checker\", false, \"kt\", \"doTest\"),\n                testModel(\"idea/testData/checker/regression\"),\n                testModel(\"idea/testData/checker/rendering\"),\n                testModel(\"idea/testData/checker/infos\", false, \"kt\", \"doTestWithInfos\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"QuickFixTestGenerated\",\n                AbstractQuickFixTest.class,\n                new SimpleTestClassModel(new File(\"idea/testData/quickfix\"), true, Pattern.compile(\"^before(\\\\w+)\\\\.kt$\"), \"doTest\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"QuickFixMultiFileTestGenerated\",\n                AbstractQuickFixMultiFileTest.class,\n                new SimpleTestClassModel(new File(\"idea/testData/quickfix\"), true, Pattern.compile(\"^(\\\\w+)\\\\.before\\\\.Main\\\\.kt$\"), \"doTestWithExtraFile\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"DeprecatedHighlightingTestGenerated\",\n                AbstractDeprecatedHighlightingTest.class,\n                testModel(\"idea/testData/highlighter/deprecated\")\n        );\n\n        generateTest(\n                \"idea/tests/\",\n                \"SurroundWithTestGenerated\",\n                AbstractSurroundWithTest.class,\n                testModel(\"idea/testData/codeInsight/surroundWith/if\", \"doTestWithIfSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/ifElse\", \"doTestWithIfElseSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/not\", \"doTestWithNotSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/parentheses\", \"doTestWithParenthesesSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/stringTemplate\", \"doTestWithStringTemplateSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/when\", \"doTestWithWhenSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/tryCatch\", \"doTestWithTryCatchSurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/tryCatchFinally\", \"doTestWithTryCatchFinallySurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/tryFinally\", \"doTestWithTryFinallySurrounder\"),\n                testModel(\"idea/testData/codeInsight/surroundWith/functionLiteral\", \"doTestWithFunctionLiteralSurrounder\")\n        );\n    }","commit_id":"9bbfc788ea06cc0408476c67ad465f2f16913a50","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Add rows until RSS or rowcount target met.\n     * Delete some rows rows (triggers compaction).\n     * Re-add odd rows until RSS or rowcount target met (makes buffers out of order).\n     */\n    private void loadTable(VoltTable t) throws Exception {\n        // if #partitions is odd, delete every 2 - if even, delete every 3\n        int n = 3 - (topo.partitions % 2);\n\n        int redundancy = topo.sites / topo.partitions;\n        long realRowCount = (config.targetrowcount * topo.hosts) / redundancy;\n        // if replicated\n        if (TableHelper.getTableName(t).equals(\"B\")) {\n            realRowCount /= topo.partitions;\n        }\n\n        System.out.printf(_F(\"loading table\\n\"));\n        long max = maxId(t);\n        TableHelper.fillTableWithBigintPkey(t, config.targetrssmb, realRowCount, client, rand, max + 1, 1);\n        TableHelper.deleteEveryNRows(t, client, n);\n        TableHelper.fillTableWithBigintPkey(t, config.targetrssmb, realRowCount, client, rand, 1, n);\n    }","id":89231,"modified_method":"/**\n     * Add rows until RSS or rowcount target met.\n     * Delete some rows rows (triggers compaction).\n     * Re-add odd rows until RSS or rowcount target met (makes buffers out of order).\n     */\n    private void loadTable(VoltTable t) {\n        // if #partitions is odd, delete every 2 - if even, delete every 3\n        int n = 3 - (topo.partitions % 2);\n\n        int redundancy = topo.sites / topo.partitions;\n        long realRowCount = (config.targetrowcount * topo.hosts) / redundancy;\n        // if replicated\n        if (TableHelper.getTableName(t).equals(\"B\")) {\n            realRowCount /= topo.partitions;\n        }\n\n        System.out.printf(_F(\"loading table\\n\"));\n        long max = maxId(t);\n\n        TableLoader loader = new TableLoader(this, t, rand);\n        loader.load(max + 1, realRowCount, 1);\n        loader.delete(1, realRowCount, n);\n        loader.load(1, realRowCount, n);\n    }","commit_id":"191ae5bc1e8c4fe42f453f8525959f9eda2a6791","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void runTestWorkload() throws Exception {\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", new StatusListener());\n        //clientConfig.setProcedureCallTimeout(30 * 60 * 1000); // 30 min\n        client = ClientFactory.createClient(clientConfig);\n        connect(config.servers);\n\n        // get the topo\n        topo = getCluterTopology();\n\n        // kick this off with a random schema\n        VoltTable t = catalogChange(null, true);\n\n        startTime = System.currentTimeMillis();\n\n        while (config.duration == 0 || (System.currentTimeMillis() - startTime < (config.duration * 1000))) {\n            // make sure the table is full and mess around with it\n            loadTable(t);\n\n            for (int j = 0; j < 3; j++) {\n\n                String tableName = TableHelper.getTableName(t);\n\n                // deterministically sample some rows\n                VoltTable preT = sample(t);\n                //System.out.printf(_F(\"First sample:\\n%s\\n\", preT.toFormattedString()));\n\n                // move to an entirely new table or migrated schema\n                t = catalogChange(t, (j == 0) && (rand.nextInt(5) == 0));\n\n                // if the table has been migrated, check the data\n                if (TableHelper.getTableName(t).equals(tableName)) {\n                    VoltTable guessT = t.clone(4096 * 1024);\n                    //System.out.printf(_F(\"Empty clone:\\n%s\\n\", guessT.toFormattedString()));\n\n                    TableHelper.migrateTable(preT, guessT);\n                    //System.out.printf(_F(\"Java migration:\\n%s\\n\", guessT.toFormattedString()));\n\n                    // deterministically sample the same rows\n                    VoltTable postT = sample(t);\n                    //System.out.printf(_F(\"Second sample:\\n%s\\n\", postT.toFormattedString()));\n\n                    postT.resetRowPosition();\n                    preT.resetRowPosition();\n                    StringBuilder sb = new StringBuilder();\n                    if (!TableHelper.deepEqualsWithErrorMsg(postT, guessT, sb)) {\n                        System.err.println(_F(sb.toString()));\n                        assert(false);\n                    }\n                }\n            }\n        }\n\n        client.close();\n    }","id":89232,"modified_method":"private void runTestWorkload() throws Exception {\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", new StatusListener());\n        //clientConfig.setProcedureCallTimeout(30 * 60 * 1000); // 30 min\n        client = ClientFactory.createClient(clientConfig);\n        connect(config.servers);\n\n        // get the topo\n        topo = getCluterTopology();\n\n        // kick this off with a random schema\n        VoltTable t = null;\n        while (t == null) {\n            t = catalogChange(null, true);\n        }\n\n        startTime = System.currentTimeMillis();\n\n        while (config.duration == 0 || (System.currentTimeMillis() - startTime < (config.duration * 1000))) {\n            // make sure the table is full and mess around with it\n            loadTable(t);\n\n            for (int j = 0; j < 3; j++) {\n\n                String tableName = TableHelper.getTableName(t);\n\n                // deterministically sample some rows\n                VoltTable preT = sample(t);\n                //System.out.printf(_F(\"First sample:\\n%s\\n\", preT.toFormattedString()));\n\n                // move to an entirely new table or migrated schema\n                VoltTable newT = null;\n                boolean isNewTable = (j == 0) && (rand.nextInt(5) == 0);\n                while (newT == null) {\n                    newT = catalogChange(t, isNewTable);\n                }\n                t = newT;\n\n                // if the table has been migrated, check the data\n                if (TableHelper.getTableName(t).equals(tableName)) {\n                    VoltTable guessT = t.clone(4096 * 1024);\n                    //System.out.printf(_F(\"Empty clone:\\n%s\\n\", guessT.toFormattedString()));\n\n                    TableHelper.migrateTable(preT, guessT);\n                    //System.out.printf(_F(\"Java migration:\\n%s\\n\", guessT.toFormattedString()));\n\n                    // deterministically sample the same rows\n                    VoltTable postT = sample(t);\n                    //System.out.printf(_F(\"Second sample:\\n%s\\n\", postT.toFormattedString()));\n\n                    postT.resetRowPosition();\n                    preT.resetRowPosition();\n                    StringBuilder sb = new StringBuilder();\n                    if (!TableHelper.deepEqualsWithErrorMsg(postT, guessT, sb)) {\n                        System.err.println(_F(sb.toString()));\n                        assert(false);\n                    }\n                }\n            }\n        }\n\n        client.close();\n    }","commit_id":"191ae5bc1e8c4fe42f453f8525959f9eda2a6791","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void validate() {\n            if (targetrssmb < 0) exitWithMessageAndUsage(\"targetrssmb must be >= 0\");\n            if (targetrowcount < 0) exitWithMessageAndUsage(\"targetrowcount must be >= 0\");\n            if (duration < 0) exitWithMessageAndUsage(\"duration must be >= 0\");\n        }","id":89233,"modified_method":"@Override\n        public void validate() {\n            if (targetrowcount <= 0) exitWithMessageAndUsage(\"targetrowcount must be > 0\");\n            if (duration < 0) exitWithMessageAndUsage(\"duration must be >= 0\");\n        }","commit_id":"191ae5bc1e8c4fe42f453f8525959f9eda2a6791","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Call a procedure and check the return code.\n     * Success just returns the result to the caller.\n     * Unpossible errors end the process.\n     * Some errors will retry the call until the global progress timeout with various waits.\n     * After the global progress timeout, the process is killed.\n     */\n    private ClientResponse callROProcedureWithRetry(String procName, Object... params) {\n        long startTime = System.currentTimeMillis();\n        long now = startTime;\n\n        while (now - startTime < config.noProgressTimeout) {\n            ClientResponse cr = null;\n\n            try {\n                cr = client.callProcedure(procName, params);\n            }\n            catch (ProcCallException e) {\n                cr = e.getClientResponse();\n            }\n            catch (NoConnectionsException e) {\n                // wait a bit to retry\n                try { Thread.sleep(1000); } catch (InterruptedException e1) {}\n            } catch (IOException e) {\n                // IOException is not cool man\n                e.printStackTrace();\n                System.exit(-1);\n            }\n\n            if (cr != null) {\n                switch (cr.getStatus()) {\n                case ClientResponse.SUCCESS:\n                    // hooray!\n                    return cr;\n                case ClientResponse.CONNECTION_LOST:\n                    // can retry after a delay\n                    try { Thread.sleep(5 * 1000); } catch (Exception e) {}\n                    break;\n                case ClientResponse.CONNECTION_TIMEOUT:\n                    // can retry after a delay\n                    try { Thread.sleep(5 * 1000); } catch (Exception e) {}\n                    break;\n                case ClientResponse.GRACEFUL_FAILURE:\n                    // for starters, I'm assuming this can't happen for reads in a sound system\n                    assert(false);\n                    System.exit(-1);\n                case ClientResponse.RESPONSE_UNKNOWN:\n                    // can try again immediately - cluster is up but a node died\n                    break;\n                case ClientResponse.SERVER_UNAVAILABLE:\n                    // shouldn't be in admin mode (paused) in this app, but can retry after a delay\n                    try { Thread.sleep(60 * 1000); } catch (Exception e) {}\n                    break;\n                case ClientResponse.UNEXPECTED_FAILURE:\n                    // should never happen\n                    assert(false);\n                    System.exit(-1);\n                case ClientResponse.USER_ABORT:\n                    // no user aborts as part of the app\n                    assert(false);\n                    System.exit(-1);\n                }\n            }\n\n            now = System.currentTimeMillis();\n        }\n\n        assert(false);\n        System.exit(-1);\n        return null;\n    }","id":89234,"modified_method":"/**\n     * Call a procedure and check the return code.\n     * Success just returns the result to the caller.\n     * Unpossible errors end the process.\n     * Some errors will retry the call until the global progress timeout with various waits.\n     * After the global progress timeout, the process is killed.\n     */\n    ClientResponse callROProcedureWithRetry(String procName, Object... params) {\n        long startTime = System.currentTimeMillis();\n        long now = startTime;\n\n        while (now - startTime < (config.noProgressTimeout * 1000)) {\n            ClientResponse cr = null;\n\n            try {\n                cr = client.callProcedure(procName, params);\n            }\n            catch (ProcCallException e) {\n                cr = e.getClientResponse();\n            }\n            catch (NoConnectionsException e) {\n                // wait a bit to retry\n                try { Thread.sleep(1000); } catch (InterruptedException e1) {}\n            } catch (IOException e) {\n                // IOException is not cool man\n                e.printStackTrace();\n                System.exit(-1);\n            }\n\n            if (cr != null) {\n                switch (cr.getStatus()) {\n                case ClientResponse.SUCCESS:\n                    // hooray!\n                    return cr;\n                case ClientResponse.CONNECTION_LOST:\n                case ClientResponse.CONNECTION_TIMEOUT:\n                    // can retry after a delay\n                    try { Thread.sleep(5 * 1000); } catch (Exception e) {}\n                    break;\n                case ClientResponse.RESPONSE_UNKNOWN:\n                    // can try again immediately - cluster is up but a node died\n                    break;\n                case ClientResponse.SERVER_UNAVAILABLE:\n                    // shouldn't be in admin mode (paused) in this app, but can retry after a delay\n                    try { Thread.sleep(30 * 1000); } catch (Exception e) {}\n                    break;\n                case ClientResponse.GRACEFUL_FAILURE:\n                case ClientResponse.UNEXPECTED_FAILURE:\n                case ClientResponse.USER_ABORT:\n                    // for starters, I'm assuming these errors can't happen for reads in a sound system\n                    assert(false);\n                    System.exit(-1);\n                }\n            }\n\n            now = System.currentTimeMillis();\n        }\n\n        assert(false);\n        System.exit(-1);\n        return null;\n    }","commit_id":"191ae5bc1e8c4fe42f453f8525959f9eda2a6791","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Perform a schema change to a mutated version of the current table (80%) or\n     * to a new table entirely (20%, drops and adds the new table).\n     */\n    private VoltTable catalogChange(VoltTable t1, boolean newTable) throws Exception {\n        CatalogBuilder builder = new CatalogBuilder();\n        VoltTable t2 = null;\n        String currentName = t1 == null ? \"B\" : TableHelper.getTableName(t1);\n        String newName = currentName;\n\n        if (newTable) {\n            newName = currentName.equals(\"A\") ? \"B\" : \"A\";\n            t2 = TableHelper.getTotallyRandomTable(newName, rand);\n        }\n        else {\n            t2 = TableHelper.mutateTable(t1, false, rand);\n        }\n\n        System.out.printf(_F(\"New Schema:\\n%s\\n\", TableHelper.ddlForTable(t2)));\n\n        builder.addLiteralSchema(TableHelper.ddlForTable(t2));\n        // make tables name A partitioned and tables named B replicated\n        if (newName.equalsIgnoreCase(\"A\")) {\n            int pkeyIndex = TableHelper.getBigintPrimaryKeyIndexIfExists(t2);\n            builder.addPartitionInfo(newName, t2.getColumnName(pkeyIndex));\n        }\n        byte[] catalogData = builder.compileToBytes();\n        assert(catalogData != null);\n\n        long count = tupleCount(t1);\n        long start = System.nanoTime();\n\n        if (newTable) {\n            System.out.println(_F(\"Starting catalog update to swap tables.\"));\n        }\n        else {\n            System.out.println(_F(\"Starting catalog update to change schema.\"));\n        }\n\n        ClientResponse cr = client.callProcedure(\"@UpdateApplicationCatalog\", catalogData, null);\n        assert(cr.getStatus() == ClientResponse.SUCCESS);\n\n        long end = System.nanoTime();\n        double seconds = (end - start) / 1000000000.0;\n\n        if (newTable) {\n            System.out.printf(_F(\"Completed catalog update that swapped tables in %.4f seconds\\n\",\n                    seconds));\n        }\n        else {\n            System.out.printf(_F(\"Completed catalog update of %d tuples in %.4f seconds (%d tuples/sec)\\n\",\n                    count, seconds, (long) (count / seconds)));\n        }\n\n        //System.out.println(_F(\"Sleeping for 5s\"));\n        //Thread.sleep(5000);\n\n        return t2;\n    }","id":89235,"modified_method":"/**\n     * Perform a schema change to a mutated version of the current table (80%) or\n     * to a new table entirely (20%, drops and adds the new table).\n     */\n    private VoltTable catalogChange(VoltTable t1, boolean newTable) throws Exception {\n        CatalogBuilder builder = new CatalogBuilder();\n        VoltTable t2 = null;\n        String currentName = t1 == null ? \"B\" : TableHelper.getTableName(t1);\n        String newName = currentName;\n\n        // add an empty table with the schema version number in it\n        VoltTable versionT = TableHelper.quickTable(String.format(\"V%s (BIGINT)\", schemaVersionNo + 1));\n\n        if (newTable) {\n            newName = currentName.equals(\"A\") ? \"B\" : \"A\";\n            t2 = TableHelper.getTotallyRandomTable(newName, rand);\n        }\n        else {\n            t2 = TableHelper.mutateTable(t1, false, rand);\n        }\n\n        System.out.printf(_F(\"New Schema:\\n%s\\n\", TableHelper.ddlForTable(t2)));\n\n        builder.addLiteralSchema(TableHelper.ddlForTable(t2));\n        builder.addLiteralSchema(TableHelper.ddlForTable(versionT));\n        // make tables name A partitioned and tables named B replicated\n        if (newName.equalsIgnoreCase(\"A\")) {\n            int pkeyIndex = TableHelper.getBigintPrimaryKeyIndexIfExists(t2);\n            builder.addPartitionInfo(newName, t2.getColumnName(pkeyIndex));\n        }\n        byte[] catalogData = builder.compileToBytes();\n        assert(catalogData != null);\n\n        long count = tupleCount(t1);\n        long start = System.nanoTime();\n\n        if (newTable) {\n            System.out.println(_F(\"Starting catalog update to swap tables.\"));\n        }\n        else {\n            System.out.println(_F(\"Starting catalog update to change schema.\"));\n        }\n\n        boolean success = false;\n        ClientResponse cr = null;\n        try {\n            cr = client.callProcedure(\"@UpdateApplicationCatalog\", catalogData, null);\n        }\n        catch (NoConnectionsException e) {\n            // failure\n        } catch (IOException e) {\n            // IOException is not cool man\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        if (cr != null) {\n            switch (cr.getStatus()) {\n            case ClientResponse.SUCCESS:\n                // hooray!\n                success = true;\n                break;\n            case ClientResponse.CONNECTION_LOST:\n            case ClientResponse.CONNECTION_TIMEOUT:\n            case ClientResponse.RESPONSE_UNKNOWN:\n            case ClientResponse.SERVER_UNAVAILABLE:\n                // can try again after a break\n                break;\n            case ClientResponse.UNEXPECTED_FAILURE:\n            case ClientResponse.GRACEFUL_FAILURE:\n            case ClientResponse.USER_ABORT:\n                // should never happen\n                assert(false);\n                System.exit(-1);\n            }\n        }\n\n        // don't actually trust the call... manually verify\n        int versionObserved = verifyAndGetSchemaVersion();\n\n        // did not update\n        if (versionObserved == schemaVersionNo) {\n            // make sure the system didn't say it worked\n            assert(success == false);\n\n            // signal to the caller this didn't work\n            return null;\n        }\n        // success!\n        else {\n            assert(versionObserved == (schemaVersionNo + 1));\n            schemaVersionNo++;\n\n            long end = System.nanoTime();\n            double seconds = (end - start) / 1000000000.0;\n\n            if (newTable) {\n                System.out.printf(_F(\"Completed catalog update that swapped tables in %.4f seconds\\n\",\n                        seconds));\n            }\n            else {\n                System.out.printf(_F(\"Completed catalog update of %d tuples in %.4f seconds (%d tuples/sec)\\n\",\n                        count, seconds, (long) (count / seconds)));\n            }\n\n            return t2;\n        }\n    }","commit_id":"191ae5bc1e8c4fe42f453f8525959f9eda2a6791","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Helper method for RandomFill\n     */\n    protected static Object[] randomRow(VoltTable table, int maxStringSize, Random rand) {\n        Object[] row = new Object[table.getColumnCount()];\n        for (int col = 0; col < table.getColumnCount(); col++) {\n            boolean allowNulls = table.getColumnNullable(col);\n            int size = table.getColumnMaxSize(col);\n            if (size > maxStringSize) size = maxStringSize;\n            double nullFraction = allowNulls ? 0.05 : 0.0;\n            row[col] = VoltTypeUtil.getRandomValue(table.getColumnType(col), size, nullFraction, rand);\n        }\n        return row;\n    }","id":89236,"modified_method":"/**\n     * Helper method for RandomFill\n     */\n    public static Object[] randomRow(VoltTable table, int maxStringSize, Random rand) {\n        Object[] row = new Object[table.getColumnCount()];\n        for (int col = 0; col < table.getColumnCount(); col++) {\n            boolean allowNulls = table.getColumnNullable(col);\n            int size = table.getColumnMaxSize(col);\n            if (size > maxStringSize) size = maxStringSize;\n            double nullFraction = allowNulls ? 0.05 : 0.0;\n            row[col] = VoltTypeUtil.getRandomValue(table.getColumnType(col), size, nullFraction, rand);\n        }\n        return row;\n    }","commit_id":"191ae5bc1e8c4fe42f453f8525959f9eda2a6791","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void runTestWorkload() throws Exception {\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", new StatusListener());\n        //clientConfig.setProcedureCallTimeout(30 * 60 * 1000); // 30 min\n        client = ClientFactory.createClient(clientConfig);\n        connect(config.servers);\n\n        // get the topo\n        topo = getCluterTopology();\n\n        // kick this off with a random schema\n        VoltTable t = null;\n        while (t == null) {\n            t = catalogChange(null, true);\n        }\n\n        startTime = System.currentTimeMillis();\n\n        while (config.duration == 0 || (System.currentTimeMillis() - startTime < (config.duration * 1000))) {\n\n            // make sure the table is full and mess around with it\n            loadTable(t);\n\n            for (int j = 0; j < 3; j++) {\n\n                String tableName = TableHelper.getTableName(t);\n\n                // deterministically sample some rows\n                VoltTable preT = null;\n                long max = maxId(t);\n                long sampleOffset = -1;\n                if (max > 0) {\n                    sampleOffset = Math.min((long) (max * .75), max - 100);\n                    assert(max >= 0);\n                    preT = sample(sampleOffset, t);\n                    assert(preT.getRowCount() > 0);\n                    log.info(_F(\"Sampled table %s from offset %d limit 100 and found %d rows.\",\n                            tableName, sampleOffset, preT.getRowCount()));\n                }\n                //log.info(_F(\"First sample:\\n%s\", preT.toFormattedString()));\n\n                // move to an entirely new table or migrated schema\n                VoltTable newT = null;\n                boolean isNewTable = (j == 0) && (rand.nextInt(5) == 0);\n                while (newT == null) {\n                    newT = catalogChange(t, isNewTable);\n                }\n                t = newT;\n\n                // if the table has been migrated, check the data\n                if (!isNewTable && (preT != null)) {\n                    VoltTable guessT = t.clone(4096 * 1024);\n                    //log.info(_F(\"Empty clone:\\n%s\", guessT.toFormattedString()));\n\n                    TableHelper.migrateTable(preT, guessT);\n                    //log.info(_F(\"Java migration:\\n%s\", guessT.toFormattedString()));\n\n                    // deterministically sample the same rows\n                    assert(sampleOffset >= 0);\n                    VoltTable result = callROProcedureWithRetry(\n                            \"VerifySchemaChanged\" + tableName, sampleOffset, guessT).getResults()[0];\n                    boolean success = result.fetchRow(0).getLong(0) == 1;\n                    String err = result.fetchRow(0).getString(1);\n                    if (!success) {\n                        log.error(_F(err));\n                        assert(false);\n                    }\n                }\n            }\n        }\n\n        client.close();\n    }","id":89237,"modified_method":"private void runTestWorkload() throws Exception {\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", new StatusListener());\n        //clientConfig.setProcedureCallTimeout(30 * 60 * 1000); // 30 min\n        client = ClientFactory.createClient(clientConfig);\n        connect(config.servers);\n\n        // get the topo\n        topo = getCluterTopology();\n\n        // kick this off with a random schema\n        VoltTable t = null;\n        TableHelper.ViewRep v = null;\n        while (t == null) {\n            Pair<VoltTable, TableHelper.ViewRep> schema = catalogChange(null, true, null);\n            t = schema.getFirst();\n            v = schema.getSecond();\n        }\n\n        startTime = System.currentTimeMillis();\n\n        while (config.duration == 0 || (System.currentTimeMillis() - startTime < (config.duration * 1000))) {\n\n            // make sure the table is full and mess around with it\n            loadTable(t);\n\n            for (int j = 0; j < 3; j++) {\n\n                String tableName = TableHelper.getTableName(t);\n\n                // deterministically sample some rows\n                VoltTable preT = null;\n                long max = maxId(t);\n                long sampleOffset = -1;\n                if (max > 0) {\n                    sampleOffset = Math.min((long) (max * .75), max - 100);\n                    assert(max >= 0);\n                    preT = sample(sampleOffset, t);\n                    assert(preT.getRowCount() > 0);\n                    log.info(_F(\"Sampled table %s from offset %d limit 100 and found %d rows.\",\n                            tableName, sampleOffset, preT.getRowCount()));\n                }\n                //log.info(_F(\"First sample:\\n%s\", preT.toFormattedString()));\n\n                // move to an entirely new table or migrated schema\n                VoltTable newT = null;\n                TableHelper.ViewRep newV = null;\n                boolean isNewTable = (j == 0) && (rand.nextInt(5) == 0);\n                while (newT == null) {\n                    Pair<VoltTable, TableHelper.ViewRep> schema = catalogChange(t, isNewTable, v);\n                    newT = schema.getFirst();\n                    newV = schema.getSecond();\n                }\n                t = newT;\n                v = newV;\n\n                // if the table has been migrated, check the data\n                if (!isNewTable && (preT != null)) {\n                    VoltTable guessT = t.clone(4096 * 1024);\n                    //log.info(_F(\"Empty clone:\\n%s\", guessT.toFormattedString()));\n\n                    TableHelper.migrateTable(preT, guessT);\n                    //log.info(_F(\"Java migration:\\n%s\", guessT.toFormattedString()));\n\n                    // deterministically sample the same rows\n                    assert(sampleOffset >= 0);\n                    VoltTable result = callROProcedureWithRetry(\n                            \"VerifySchemaChanged\" + tableName, sampleOffset, guessT).getResults()[0];\n                    boolean success = result.fetchRow(0).getLong(0) == 1;\n                    String err = result.fetchRow(0).getString(1);\n                    if (!success) {\n                        log.error(_F(err));\n                        assert(false);\n                    }\n                }\n            }\n        }\n\n        client.close();\n    }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            // if the benchmark is still active\n            long currentTime = System.currentTimeMillis();\n            if ((currentTime - startTime) < (config.duration * 1000)) {\n                log.warn(_F(\"Lost connection to %s:%d.\", hostname, port));\n                totalConnections.decrementAndGet();\n                // setup for retry\n                final String server = hostname;\n                new Thread(new Runnable() {\n                    @Override\n                    public void run() {\n                        connectToOneServerWithRetry(server);\n                    }\n                }).start();\n            }\n        }","id":89238,"modified_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            // if the benchmark is still active\n            long currentTime = System.currentTimeMillis();\n            if ((currentTime - startTime) < (config.duration * 1000)) {\n                log.warn(_F(\"Lost connection to %s:%d.\", hostname, port));\n                totalConnections.decrementAndGet();\n\n                // reset the connection id so the client will connect to a recovered cluster\n                // this is a bit of a hack\n                if (connectionsLeft == 0) {\n                    ((ClientImpl) client).resetInstanceId();\n                }\n\n                // setup for retry\n                final String server = MiscUtils.getHostnameColonPortString(hostname, port);\n                new Thread(new Runnable() {\n                    @Override\n                    public void run() {\n                        connectToOneServerWithRetry(server);\n                    }\n                }).start();\n            }\n        }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Perform a schema change to a mutated version of the current table (80%) or\n     * to a new table entirely (20%, drops and adds the new table).\n     */\n    private VoltTable catalogChange(VoltTable t1, boolean newTable) throws Exception {\n        CatalogBuilder builder = new CatalogBuilder();\n        VoltTable t2 = null;\n        String currentName = t1 == null ? \"B\" : TableHelper.getTableName(t1);\n        String newName = currentName;\n\n        // add an empty table with the schema version number in it\n        VoltTable versionT = TableHelper.quickTable(String.format(\"V%s (BIGINT)\", schemaVersionNo + 1));\n\n        if (newTable) {\n            newName = currentName.equals(\"A\") ? \"B\" : \"A\";\n            t2 = TableHelper.getTotallyRandomTable(newName, rand);\n        }\n        else {\n            t2 = TableHelper.mutateTable(t1, true, rand);\n        }\n\n        log.info(_F(\"New Schema:\\n%s\", TableHelper.ddlForTable(t2)));\n\n        builder.addLiteralSchema(TableHelper.ddlForTable(t2));\n        builder.addLiteralSchema(TableHelper.ddlForTable(versionT));\n        // make tables name A partitioned and tables named B replicated\n        if (newName.equalsIgnoreCase(\"A\")) {\n            int pkeyIndex = TableHelper.getBigintPrimaryKeyIndexIfExists(t2);\n            builder.addPartitionInfo(newName, t2.getColumnName(pkeyIndex));\n            builder.addProcedures(VerifySchemaChangedA.class);\n        }\n        else {\n            builder.addProcedures(VerifySchemaChangedB.class);\n        }\n        byte[] catalogData = builder.compileToBytes();\n        assert(catalogData != null);\n\n        long count = tupleCount(t1);\n        long start = System.nanoTime();\n\n        if (newTable) {\n            log.info(_F(\"Starting catalog update to swap tables.\"));\n        }\n        else {\n            log.info(_F(\"Starting catalog update to change schema.\"));\n        }\n\n        boolean success = false;\n        ClientResponse cr = null;\n        try {\n            cr = client.callProcedure(\"@UpdateApplicationCatalog\", catalogData, null);\n        }\n        catch (NoConnectionsException e) {\n            // failure\n        } catch (IOException e) {\n            // IOException is not cool man\n            logStackTrace(e);\n            System.exit(-1);\n        }\n\n        if (cr != null) {\n            switch (cr.getStatus()) {\n            case ClientResponse.SUCCESS:\n                // hooray!\n                success = true;\n                break;\n            case ClientResponse.CONNECTION_LOST:\n            case ClientResponse.CONNECTION_TIMEOUT:\n            case ClientResponse.RESPONSE_UNKNOWN:\n            case ClientResponse.SERVER_UNAVAILABLE:\n                // can try again after a break\n                break;\n            case ClientResponse.UNEXPECTED_FAILURE:\n            case ClientResponse.GRACEFUL_FAILURE:\n            case ClientResponse.USER_ABORT:\n                // should never happen\n                assert(false);\n                System.exit(-1);\n            }\n        }\n\n        // don't actually trust the call... manually verify\n        int versionObserved = verifyAndGetSchemaVersion();\n\n        // did not update\n        if (versionObserved == schemaVersionNo) {\n            // make sure the system didn't say it worked\n            assert(success == false);\n\n            // signal to the caller this didn't work\n            return null;\n        }\n        // success!\n        else {\n            assert(versionObserved == (schemaVersionNo + 1));\n            schemaVersionNo++;\n\n            long end = System.nanoTime();\n            double seconds = (end - start) / 1000000000.0;\n\n            if (newTable) {\n                log.info(_F(\"Completed catalog update that swapped tables in %.4f seconds\",\n                        seconds));\n            }\n            else {\n                log.info(_F(\"Completed catalog update of %d tuples in %.4f seconds (%d tuples/sec)\",\n                        count, seconds, (long) (count / seconds)));\n            }\n\n            return t2;\n        }\n    }","id":89239,"modified_method":"/**\n     * Perform a schema change to a mutated version of the current table (80%) or\n     * to a new table entirely (20%, drops and adds the new table).\n     */\n    private Pair<VoltTable,TableHelper.ViewRep> catalogChange(VoltTable t1, boolean newTable, TableHelper.ViewRep view) throws Exception {\n        CatalogBuilder builder = new CatalogBuilder();\n        VoltTable t2 = null;\n        String currentName = t1 == null ? \"B\" : TableHelper.getTableName(t1);\n        String newName = currentName;\n\n        // add an empty table with the schema version number in it\n        VoltTable versionT = TableHelper.quickTable(String.format(\"V%s (BIGINT)\", schemaVersionNo + 1));\n\n        if (newTable) {\n            newName = currentName.equals(\"A\") ? \"B\" : \"A\";\n            t2 = TableHelper.getTotallyRandomTable(newName, rand);\n        }\n        else {\n            t2 = TableHelper.mutateTable(t1, true, rand);\n        }\n\n        log.info(_F(\"New Schema:\\n%s\", TableHelper.ddlForTable(t2)));\n\n        // handle views\n        if (view == null) {\n            view = TableHelper.ViewRep.viewRepForTable(\"MV\", t2, rand);\n        }\n        else {\n            if (!view.compatibleWithTable(t2)) {\n                view = null;\n            }\n        }\n        if (view != null) {\n            log.info(_F(\"New View:\\n%s\", view.ddlForView()));\n        }\n        else {\n            log.info(\"New View: NULL\");\n        }\n\n        builder.addLiteralSchema(TableHelper.ddlForTable(t2));\n        if (view != null) {\n            builder.addLiteralSchema(view.ddlForView());\n        }\n        builder.addLiteralSchema(TableHelper.ddlForTable(versionT));\n        // make tables name A partitioned and tables named B replicated\n        if (newName.equalsIgnoreCase(\"A\")) {\n            int pkeyIndex = TableHelper.getBigintPrimaryKeyIndexIfExists(t2);\n            builder.addPartitionInfo(newName, t2.getColumnName(pkeyIndex));\n            builder.addProcedures(VerifySchemaChangedA.class);\n        }\n        else {\n            builder.addProcedures(VerifySchemaChangedB.class);\n        }\n        byte[] catalogData = builder.compileToBytes();\n        assert(catalogData != null);\n\n        long count = tupleCount(t1);\n        long start = System.nanoTime();\n\n        if (newTable) {\n            log.info(_F(\"Starting catalog update to swap tables.\"));\n        }\n        else {\n            log.info(_F(\"Starting catalog update to change schema.\"));\n        }\n\n        boolean success = false;\n        ClientResponse cr = null;\n        try {\n            cr = client.callProcedure(\"@UpdateApplicationCatalog\", catalogData, null);\n        }\n        catch (NoConnectionsException e) {\n            // failure\n        } catch (IOException e) {\n            // IOException is not cool man\n            logStackTrace(e);\n            System.exit(-1);\n        }\n\n        if (cr != null) {\n            switch (cr.getStatus()) {\n            case ClientResponse.SUCCESS:\n                // hooray!\n                success = true;\n                break;\n            case ClientResponse.CONNECTION_LOST:\n            case ClientResponse.CONNECTION_TIMEOUT:\n            case ClientResponse.RESPONSE_UNKNOWN:\n            case ClientResponse.SERVER_UNAVAILABLE:\n                // can try again after a break\n                break;\n            case ClientResponse.UNEXPECTED_FAILURE:\n            case ClientResponse.GRACEFUL_FAILURE:\n            case ClientResponse.USER_ABORT:\n                // should never happen\n                assert(false);\n                System.exit(-1);\n            }\n        }\n\n        // don't actually trust the call... manually verify\n        int versionObserved = verifyAndGetSchemaVersion();\n\n        // did not update\n        if (versionObserved == schemaVersionNo) {\n            // make sure the system didn't say it worked\n            assert(success == false);\n\n            // signal to the caller this didn't work\n            return null;\n        }\n        // success!\n        else {\n            assert(versionObserved == (schemaVersionNo + 1));\n            schemaVersionNo++;\n\n            long end = System.nanoTime();\n            double seconds = (end - start) / 1000000000.0;\n\n            if (newTable) {\n                log.info(_F(\"Completed catalog update that swapped tables in %.4f seconds\",\n                        seconds));\n            }\n            else {\n                log.info(_F(\"Completed catalog update of %d tuples in %.4f seconds (%d tuples/sec)\",\n                        count, seconds, (long) (count / seconds)));\n            }\n\n            return new Pair<VoltTable,TableHelper.ViewRep>(t2, view, false);\n        }\n    }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Find the largest pkey value in the table.\n     */\n    private long maxId(VoltTable t) {\n        if (t == null) {\n            return 0;\n        }\n        VoltTable result = callROProcedureWithRetry(\"@AdHoc\",\n                String.format(\"select pkey from %s order by pkey desc limit 1;\", TableHelper.getTableName(t))).getResults()[0];\n        return result.getRowCount() > 0 ? result.asScalarLong() : 0;\n    }","id":89240,"modified_method":"/**\n     * Find the largest pkey value in the table.\n     */\n    public long maxId(VoltTable t) {\n        if (t == null) {\n            return 0;\n        }\n        VoltTable result = callROProcedureWithRetry(\"@AdHoc\",\n                String.format(\"select pkey from %s order by pkey desc limit 1;\", TableHelper.getTableName(t))).getResults()[0];\n        return result.getRowCount() > 0 ? result.asScalarLong() : 0;\n    }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Add rows until RSS or rowcount target met.\n     * Delete some rows rows (triggers compaction).\n     * Re-add odd rows until RSS or rowcount target met (makes buffers out of order).\n     */\n    private void loadTable(VoltTable t) {\n        // if #partitions is odd, delete every 2 - if even, delete every 3\n        int n = 3 - (topo.partitions % 2);\n\n        int redundancy = topo.sites / topo.partitions;\n        long realRowCount = (config.targetrowcount * topo.hosts) / redundancy;\n        // if replicated\n        if (TableHelper.getTableName(t).equals(\"B\")) {\n            realRowCount /= topo.partitions;\n        }\n\n        long max = maxId(t);\n\n        TableLoader loader = new TableLoader(this, t, rand);\n\n        log.info(_F(\"loading table\"));\n        loader.load(max + 1, realRowCount, 1);\n        log.info(_F(\"deleting from table\"));\n        loader.delete(1, realRowCount, n);\n        log.info(_F(\"reloading table\"));\n        loader.load(1, realRowCount, n);\n    }","id":89241,"modified_method":"/**\n     * Add rows until RSS or rowcount target met.\n     * Delete some rows rows (triggers compaction).\n     * Re-add odd rows until RSS or rowcount target met (makes buffers out of order).\n     */\n    private void loadTable(VoltTable t) {\n        // if #partitions is odd, delete every 2 - if even, delete every 3\n        //int n = 3 - (topo.partitions % 2);\n\n        int redundancy = topo.sites / topo.partitions;\n        long realRowCount = (config.targetrowcount * topo.hosts) / redundancy;\n        // if replicated\n        if (TableHelper.getTableName(t).equals(\"B\")) {\n            realRowCount /= topo.partitions;\n        }\n\n        long max = maxId(t);\n\n        TableLoader loader = new TableLoader(this, t, rand);\n\n        log.info(_F(\"loading table\"));\n        loader.load(max + 1, realRowCount);\n    }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            switch (clientResponse.getStatus()) {\n            case ClientResponse.SUCCESS:\n                // hooray!\n                boolean success = outstandingPkeys.remove(pkey);\n                assert(success);\n                break;\n            case ClientResponse.CONNECTION_LOST:\n            case ClientResponse.CONNECTION_TIMEOUT:\n            case ClientResponse.RESPONSE_UNKNOWN:\n            case ClientResponse.SERVER_UNAVAILABLE:\n                // no need to be verbose, as there might be many messages\n                hadError.set(true);\n                break;\n            case ClientResponse.UNEXPECTED_FAILURE:\n            case ClientResponse.GRACEFUL_FAILURE:\n            case ClientResponse.USER_ABORT:\n                // should never happen\n                log.error(\"Error in loader callback:\");\n                log.error(((ClientResponseImpl)clientResponse).toJSONString());\n                assert(false);\n                System.exit(-1);\n            }\n        }","id":89242,"modified_method":"@Override\n        public void clientCallback(ClientResponse clientResponse) throws Exception {\n            switch (clientResponse.getStatus()) {\n            case ClientResponse.SUCCESS:\n                // hooray!\n                boolean success = outstandingPkeys.remove(pkey);\n                assert(success);\n                break;\n            case ClientResponse.CONNECTION_LOST:\n            case ClientResponse.CONNECTION_TIMEOUT:\n            case ClientResponse.RESPONSE_UNKNOWN:\n            case ClientResponse.SERVER_UNAVAILABLE:\n                // no need to be verbose, as there might be many messages\n                hadError.set(true);\n                break;\n            case ClientResponse.GRACEFUL_FAILURE:\n                // all graceful failures but this one fall through to death\n                if (clientResponse.getStatusString().contains(\"CONSTRAINT VIOLATION\")) {\n                    break;\n                }\n            case ClientResponse.UNEXPECTED_FAILURE:\n            case ClientResponse.USER_ABORT:\n                // should never happen\n                log.error(\"Error in loader callback:\");\n                log.error(((ClientResponseImpl)clientResponse).toJSONString());\n                assert(false);\n                System.exit(-1);\n            }\n        }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private long loadChunk(long startPkey, long stopPkey, long jump) {\n\n        log.info(_F(\"loadChunk | startPkey:%d stopPkey:%d jump:%d\", startPkey, stopPkey, jump));\n\n        assert(startPkey < stopPkey);\n        assert(startPkey >= 0);\n\n        long nextPkey = startPkey;\n\n        long maxSentPkey = -1;\n        hadError.set(false);\n        while ((nextPkey <= stopPkey) && (!hadError.get())) {\n            Object[] row = TableHelper.randomRow(table, Integer.MAX_VALUE, rand);\n            row[pkeyColIndex] = nextPkey;\n            try {\n                outstandingPkeys.add(nextPkey);\n                maxSentPkey = nextPkey;\n                client.callProcedure(new Callback(nextPkey), insertCRUD, row);\n            }\n            catch (Exception e) {\n                break;\n            }\n            nextPkey += jump;\n        }\n\n        try { client.drain(); } catch (Exception e) {}\n\n        long minOutstandingPkey = -1;\n        try {\n            minOutstandingPkey = outstandingPkeys.first();\n        }\n        catch (NoSuchElementException e) {\n            // we inserted all rows\n            assert((maxSentPkey + jump) > stopPkey);\n            return stopPkey;\n        }\n        assert(minOutstandingPkey >= 0);\n\n        // delete any messiness beyond where the errors started\n        for (long pkey = minOutstandingPkey; pkey <= maxSentPkey; pkey += jump) {\n            long modCount = scc.callROProcedureWithRetry(deleteCRUD, pkey).getResults()[0].asScalarLong();\n            assert((modCount >= 0) && (modCount <= 1));\n        }\n\n        return Math.max(minOutstandingPkey - jump, -1);\n    }","id":89243,"modified_method":"private boolean loadChunk(long startPkey, long stopPkey) {\n        assert(startPkey >= 0);\n        assert(stopPkey >= 0);\n\n        if (startPkey >= stopPkey) {\n            return true;\n        }\n\n        outstandingPkeys.clear();\n\n        log.info(_F(\"loadChunk | startPkey:%d stopPkey:%d\", startPkey, stopPkey));\n\n        long maxSentPkey = -1;\n        hadError.set(false);\n        for (long key = startPkey; key <= stopPkey; key++) {\n            if (hadError.get()) {\n                log.info(\"loadChunk exiting (failed) due to callback error\");\n                return false;\n            }\n\n            Object[] row = TableHelper.randomRow(table, Integer.MAX_VALUE, rand);\n            row[pkeyColIndex] = key;\n            try {\n                outstandingPkeys.add(key);\n                maxSentPkey = key;\n                client.callProcedure(new Callback(key), insertCRUD, row);\n            }\n            catch (Exception e) {\n                log.info(\"loadChunk exiting (failed) due to thrown exception: \" + e.getMessage());\n                return false;\n            }\n        }\n\n        try {\n            client.drain();\n        }\n        catch (Exception e) {\n            log.info(\"loadChunk exiting (failed) due to thrown exception during drain: \" + e.getMessage());\n            return false;\n        }\n\n        if ((outstandingPkeys.size() == 0) && (maxSentPkey == stopPkey)) {\n            return true;\n        }\n        else {\n            log.info(_F(\"loadChunk exiting (failed) due to thrown condition %d, %d, %d\",\n                    outstandingPkeys.size(), maxSentPkey, stopPkey));\n            return false;\n        }\n    }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void load(long startPkey, long stopPkey, long jump) {\n        assert(outstandingPkeys.isEmpty());\n\n        if (startPkey >= stopPkey) return;\n\n        long lastSuccessfullyLoadedKey = -1;\n\n        while (lastSuccessfullyLoadedKey < stopPkey) {\n            long nextKey = lastSuccessfullyLoadedKey >= 0 ? lastSuccessfullyLoadedKey + jump : startPkey;\n            nextKey = loadChunk(nextKey, stopPkey, jump);\n            if (nextKey >= 0) {\n                lastSuccessfullyLoadedKey = nextKey;\n            }\n        }\n\n        outstandingPkeys.clear();\n    }","id":89244,"modified_method":"void load(long startPkey, long stopPkey) {\n        while (!loadChunk(startPkey, stopPkey)) {\n            startPkey = safeStartPkey(startPkey, stopPkey);\n        }\n    }","commit_id":"eaa05760beccb1ec1fa1c5f84542dd7851651cbb","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public Serialize(XQueryContext context) {\n        super(context, signature);\n    }","id":89245,"modified_method":"public Serialize(XQueryContext context, FunctionSignature signature)\n    {\n        super(context, signature);\n    }","commit_id":"7893980b81873090240f0634294130fb1934e852","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n            throws XPathException {\n        if (args[0].isEmpty())\n            return Sequence.EMPTY_SEQUENCE;\n        \n        // check the file output path\n        String path = args[1].itemAt(0).getStringValue();\n        File file = new File(path);\n        if (file.isDirectory()) {\n            LOG.debug(\"Output file is a directory: \" + file.getAbsolutePath());\n            return BooleanValue.FALSE;\n        }\n        if (file.exists() && !file.canWrite()) {\n            LOG.debug(\"Cannot write to file \" + file.getAbsolutePath());\n            return BooleanValue.FALSE;\n        }\n        \n        // parse serialization options\n        Properties outputProperties = new Properties();\n        outputProperties.setProperty(OutputKeys.INDENT, \"yes\");\n        outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        for (SequenceIterator i = args[2].iterate(); i.hasNext(); ) { \n            String opt[] = Pragma.parseKeyValuePair(i.nextItem().getStringValue());\n            outputProperties.setProperty(opt[0], opt[1]);\n        }\n        \n        // serialize the node set\n        SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(SAXSerializer.class);\n        try {\n            String encoding = outputProperties.getProperty(OutputKeys.ENCODING, \"UTF-8\");\n            Writer writer = new OutputStreamWriter(new FileOutputStream(file), encoding);\n            sax.setOutput(writer, outputProperties);\n            Serializer serializer = context.getBroker().getSerializer();\n            serializer.reset();\n            serializer.setProperties(outputProperties);\n            serializer.setReceiver(sax);\n\n            sax.startDocument();\n            \n            for (SequenceIterator i = args[0].iterate(); i.hasNext(); ) {\n                NodeValue next = (NodeValue) i.nextItem();\n                serializer.toSAX(next);\n            }\n            \n            sax.endDocument();\n            writer.close();\n        } catch (SAXException e) {\n            throw new XPathException(getASTNode(), \"A problem ocurred while serializing the node set: \" + e.getMessage(), e);\n        } catch (IOException e) {\n            throw new XPathException(getASTNode(), \"A problem ocurred while serializing the node set: \" + e.getMessage(), e);\n        } finally {\n            SerializerPool.getInstance().returnObject(sax);\n        }\n        return BooleanValue.TRUE;\n    }","id":89246,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException\n    {\n        if(args[0].isEmpty())\n            return Sequence.EMPTY_SEQUENCE;\n        \n        \n        Properties outputProperties = null;\n        OutputStream os = null;\n        \n        if(args.length == 3)\n        {\n        \t/** serialize to disk **/\n        \t\n\t        // check the file output path\n\t        String path = args[1].itemAt(0).getStringValue();\n\t        File file = new File(path);\n\t        if (file.isDirectory()) {\n\t            LOG.debug(\"Output file is a directory: \" + file.getAbsolutePath());\n\t            return BooleanValue.FALSE;\n\t        }\n\t        if (file.exists() && !file.canWrite()) {\n\t            LOG.debug(\"Cannot write to file \" + file.getAbsolutePath());\n\t            return BooleanValue.FALSE;\n\t        }\n\t        \n\t        //parse serialization options from third argument to function\n\t        outputProperties = parseSerializationOptions(args[2].iterate());\n\t        \n\t        //setup output stream for file\n\t        try\n\t        {\n\t        \tos = new FileOutputStream(file);\n\t        }\n\t        catch(IOException e)\n\t        {\n\t        \tthrow new XPathException(getASTNode(), \"A problem ocurred while serializing the node set: \" + e.getMessage(), e);\n\t        }\n\t        \n\t        //do the serialization\n\t        serialize(args[0].iterate(), outputProperties, os);\n\t    \n\t        return BooleanValue.TRUE;\n        }\n        else\n        {\n        \t/** serialize to string **/\n\n\t        //parse serialization options from second argument to function        \t\n        \toutputProperties = parseSerializationOptions(args[1].iterate());\n        \t\n        \t//setup output stream for byte array\n        \tos = new ByteArrayOutputStream();\n\n\t        //do the serialization\n        \tserialize(args[0].iterate(), outputProperties, os);\n        \t\n        \ttry\n        \t{\n        \t\tString encoding = outputProperties.getProperty(OutputKeys.ENCODING, \"UTF-8\");\n        \t\treturn new StringValue(new String(((ByteArrayOutputStream)os).toByteArray(), encoding));\n        \t}\n        \tcatch(UnsupportedEncodingException e)\n        \t{\n        \t\tthrow new XPathException(getASTNode(), \"A problem ocurred while serializing the node set: \" + e.getMessage(), e);\n        \t}\n        }\n        \n    }","commit_id":"7893980b81873090240f0634294130fb1934e852","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void updateGroupUsers(ActionRequest req) throws Exception {\n\t\tString groupId = ParamUtil.getString(req, \"groupId\");\n\n\t\tString[] addUserIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"addUserIds\"));\n\t\tString[] removeUserIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"removeUserIds\"));\n\n\t\tUserServiceUtil.addGroupUsers(groupId, addUserIds);\n\t\tUserServiceUtil.unsetGroupUsers(groupId, removeUserIds);\n\t}","id":89247,"modified_method":"protected void updateGroupUsers(ActionRequest req) throws Exception {\n\t\tString groupId = ParamUtil.getString(req, \"groupId\");\n\n\t\tString[] addUserIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"addUserIds\"));\n\t\tString[] removeUserIds = StringUtil.split(\n\t\t\tParamUtil.getString(req, \"removeUserIds\"));\n\n\t\tif (addUserIds.length > 0) {\n\t\t\tUserServiceUtil.addGroupUsers(groupId, addUserIds);\n\t\t}\n\t\tif (removeUserIds.length > 0) {\n\t\t\tUserServiceUtil.unsetGroupUsers(groupId, removeUserIds);\n\t\t}\n\t}","commit_id":"8c79013894d06342318917ed5138835d3e9efe5f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List findByC_N_D(\n\t\t\tString companyId, String name, String description, Map params,\n\t\t\tint begin, int end)\n\t\tthrows SystemException {\n\n\t\tname = StringUtil.lowerCase(name);\n\t\tdescription = StringUtil.lowerCase(description);\n\n\t\tString userId = (String)params.get(\"usersGroups\");\n\n\t\tMap params1 = params;\n\n\t\tMap params2 = new HashMap();\n\n\t\tparams2.putAll(params1);\n\n\t\tif (Validator.isNotNull(userId)) {\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams2.put(\"groupsOrgs\", userId);\n\t\t}\n\n\t\tMap params3 = new HashMap();\n\n\t\tparams3.putAll(params1);\n\n\t\tif (Validator.isNotNull(userId)) {\n\t\t\tparams3.remove(\"usersGroups\");\n\t\t\tparams3.put(\"groupsUserGroups\", userId);\n\t\t}\n\n\t\tList list = new ArrayList();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tString sql = null;\n\n\t\t\tsql = \"(\";\n\t\t\tsql += CustomSQLUtil.get(FIND_BY_C_N_D);\n\t\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", _getJoin(params1));\n\t\t\tsql += \")\";\n\n\t\t\tif (Validator.isNotNull(userId)) {\n\t\t\t\tsql += \" UNION \";\n\n\t\t\t\tsql += \"(\";\n\t\t\t\tsql += CustomSQLUtil.get(FIND_BY_C_N_D);\n\t\t\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", _getJoin(params2));\n\t\t\t\tsql += \")\";\n\n\t\t\t\tsql += \" UNION \";\n\n\t\t\t\tsql += \"(\";\n\t\t\t\tsql += CustomSQLUtil.get(FIND_BY_C_N_D);\n\t\t\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", _getJoin(params3));\n\t\t\t\tsql += \")\";\n\t\t\t}\n\n\t\t\tsql += \" ORDER BY groupName ASC\";\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"groupId\", Hibernate.STRING);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t_setJoin(qPos, params1);\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(name);\n\t\t\tqPos.add(name);\n\t\t\tqPos.add(description);\n\t\t\tqPos.add(description);\n\n\t\t\tif (Validator.isNotNull(userId)) {\n\t\t\t\t_setJoin(qPos, params2);\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(description);\n\t\t\t\tqPos.add(description);\n\n\t\t\t\t_setJoin(qPos, params3);\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(description);\n\t\t\t\tqPos.add(description);\n\t\t\t}\n\n\t\t\tIterator itr = QueryUtil.iterate(\n\t\t\t\tq, HibernateUtil.getDialect(), begin, end);\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tString groupId = (String)itr.next();\n\n\t\t\t\tGroup group = GroupUtil.findByPrimaryKey(groupId);\n\n\t\t\t\tlist.add(group);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\n\t\treturn list;\n\t}","id":89248,"modified_method":"public static List findByC_N_D(\n\t\t\tString companyId, String name, String description, Map params,\n\t\t\tint begin, int end)\n\t\tthrows SystemException {\n\n\t\tname = StringUtil.lowerCase(name);\n\t\tdescription = StringUtil.lowerCase(description);\n\n\t\tString userId = (String)params.get(\"usersGroups\");\n\n\t\tMap params1 = params;\n\n\t\tMap params2 = new HashMap();\n\n\t\tparams2.putAll(params1);\n\n\t\tif (Validator.isNotNull(userId)) {\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams2.put(\"groupsOrgs\", userId);\n\t\t}\n\n\t\tMap params3 = new HashMap();\n\n\t\tparams3.putAll(params1);\n\n\t\tif (Validator.isNotNull(userId)) {\n\t\t\tparams3.remove(\"usersGroups\");\n\t\t\tparams3.put(\"groupsUserGroups\", userId);\n\t\t}\n\n\t\tList list = new ArrayList();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tString sql = null;\n\n\t\t\tsql = \"(\";\n\t\t\tsql += CustomSQLUtil.get(FIND_BY_C_N_D);\n\t\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", _getJoin(params1));\n\t\t\tsql += \")\";\n\n\t\t\tif (Validator.isNotNull(userId)) {\n\t\t\t\tsql += \" UNION \";\n\n\t\t\t\tsql += \"(\";\n\t\t\t\tsql += CustomSQLUtil.get(FIND_BY_C_N_D);\n\t\t\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", _getJoin(params2));\n\t\t\t\tsql += \")\";\n\n\t\t\t\tsql += \" UNION \";\n\n\t\t\t\tsql += \"(\";\n\t\t\t\tsql += CustomSQLUtil.get(FIND_BY_C_N_D);\n\t\t\t\tsql = StringUtil.replace(sql, \"[$JOIN$]\", _getJoin(params3));\n\t\t\t\tsql += \")\";\n\t\t\t}\n\n\t\t\tsql += \" ORDER BY groupName ASC\";\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"groupId\", Hibernate.STRING);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t_setJoin(qPos, params1);\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(name);\n\t\t\tqPos.add(name);\n\t\t\tqPos.add(description);\n\t\t\tqPos.add(description);\n\n\t\t\tif (Validator.isNotNull(userId)) {\n\t\t\t\t_setJoin(qPos, params2);\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(description);\n\t\t\t\tqPos.add(description);\n\n\t\t\t\t_setJoin(qPos, params3);\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(name);\n\t\t\t\tqPos.add(description);\n\t\t\t\tqPos.add(description);\n\t\t\t}\n\n\t\t\tIterator itr = null;\n\t\t\t\n\t\t\tif (begin > 0 || end > 0) {\n\t\t\t\titr = QueryUtil.iterate(\n\t\t\t\t\t\tq, HibernateUtil.getDialect(), begin, end);\n\t\t\t}\n\t\t\telse {\n\t\t\t\titr = q.list().iterator();\n\t\t\t}\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tString groupId = (String)itr.next();\n\n\t\t\t\tGroup group = GroupUtil.findByPrimaryKey(groupId);\n\n\t\t\t\tlist.add(group);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"8c79013894d06342318917ed5138835d3e9efe5f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void applyRule(final SNode baseConcept, final TypeCheckingContext typeCheckingContext) {\n    IOperationContext operationContext = typeCheckingContext.getOperationContext();\n    if (operationContext == null) {\n      return;\n    }\n\n    SNode node = baseConcept;\n    ModelConstraintsManager cm = ModelConstraintsManager.getInstance();\n\n    if (node.getParent() != null && !(node.getParent().isUnknown())) {\n\n      String role = node.getRole_();\n      LinkDeclaration link = node.getParent().getLinkDeclaration(role);\n      if (!(node.isAttribute())) {\n\n        if (link == null) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Child in a role with unknown link\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"4950342498455637390\", intentionProvider, errorTarget);\n          }\n          return;\n        }\n      }\n\n      SNode linkNode = (link == null ?\n        null :\n        link.getNode()\n      );\n      boolean canBeChild = cm.canBeChild(node.getConceptFqName(), operationContext, node.getParent(), linkNode);\n      if (!(canBeChild)) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Node isn't applicable in the context\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"5622704259074610949\", intentionProvider, errorTarget);\n          {\n            SNode _foreign_34989546 = cm.getCanBeChildBlock(operationContext, node.getConceptFqName());\n            _reporter_2309309498.addAdditionalRuleId(_foreign_34989546.getModel().toString(), _foreign_34989546.getId());\n          }\n        }\n      }\n    }\n    if (node.isRoot()) {\n      boolean canBeRoot = cm.canBeRoot(operationContext, node.getConceptFqName(), node.getModel());\n      if (!(canBeRoot)) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Not rootable concept added as root\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"5622704259074611001\", intentionProvider, errorTarget);\n          {\n            SNode _foreign_34989546 = cm.getCanBeRootBlock(operationContext, node.getConceptFqName());\n            _reporter_2309309498.addAdditionalRuleId(_foreign_34989546.getModel().toString(), _foreign_34989546.getId());\n          }\n        }\n      }\n    }\n\n    for (SNode child : node.getChildren()) {\n      SNode childConcept = BaseAdapter.fromAdapter(child.getConceptDeclarationAdapter());\n      LinkDeclaration link = node.getLinkDeclaration(child.getRole_());\n      if (link == null) {\n        continue;\n      }\n      if (!(cm.canBeParent(node, childConcept, link.getNode(), operationContext))) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Node isn't applicable in the context\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"5622704259074611096\", intentionProvider, errorTarget);\n          {\n            SNode _foreign_34989546 = cm.getCanBeParentBlock(node, operationContext);\n            _reporter_2309309498.addAdditionalRuleId(_foreign_34989546.getModel().toString(), _foreign_34989546.getId());\n          }\n        }\n      }\n    }\n  }","id":89249,"modified_method":"public void applyRule(final SNode baseConcept, final TypeCheckingContext typeCheckingContext) {\n    IOperationContext operationContext = typeCheckingContext.getOperationContext();\n    if (operationContext == null) {\n      return;\n    }\n\n    SNode node = baseConcept;\n    ModelConstraintsManager cm = ModelConstraintsManager.getInstance();\n\n    if (node.getParent() != null && !(node.getParent().isUnknown())) {\n\n      String role = node.getRole_();\n      LinkDeclaration link = node.getParent().getLinkDeclaration(role);\n      if (!(node.isAttribute())) {\n\n        if (link == null) {\n          {\n            BaseIntentionProvider intentionProvider = null;\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Child in a role with unknown link\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"4950342498455637390\", intentionProvider, errorTarget);\n          }\n          return;\n        }\n      }\n\n      SNode linkNode = (link == null ?\n        null :\n        link.getNode()\n      );\n      boolean canBeChild = cm.canBeChild(node.getConceptFqName(), operationContext, node.getParent(), linkNode);\n      if (!(canBeChild)) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Node isn't applicable in the context\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"5622704259074610949\", intentionProvider, errorTarget);\n          {\n            SNode _foreign_34989546 = cm.getCanBeChildBlock(operationContext, node.getConceptFqName());\n            if (_foreign_34989546 != null) {\n              _reporter_2309309498.addAdditionalRuleId(_foreign_34989546.getModel().toString(), _foreign_34989546.getId());\n            }\n          }\n        }\n      }\n    }\n    if (node.isRoot()) {\n      boolean canBeRoot = cm.canBeRoot(operationContext, node.getConceptFqName(), node.getModel());\n      if (!(canBeRoot)) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Not rootable concept added as root\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"5622704259074611001\", intentionProvider, errorTarget);\n          {\n            SNode _foreign_34989546 = cm.getCanBeRootBlock(operationContext, node.getConceptFqName());\n            if (_foreign_34989546 != null) {\n              _reporter_2309309498.addAdditionalRuleId(_foreign_34989546.getModel().toString(), _foreign_34989546.getId());\n            }\n          }\n        }\n      }\n    }\n\n    for (SNode child : node.getChildren()) {\n      SNode childConcept = BaseAdapter.fromAdapter(child.getConceptDeclarationAdapter());\n      LinkDeclaration link = node.getLinkDeclaration(child.getRole_());\n      if (link == null) {\n        continue;\n      }\n      if (!(cm.canBeParent(node, childConcept, link.getNode(), operationContext))) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(node, \"Node isn't applicable in the context\", \"r:cec599e3-51d2-48a7-af31-989e3cbd593c(jetbrains.mps.lang.core.typesystem)\", \"5622704259074611096\", intentionProvider, errorTarget);\n          {\n            SNode _foreign_34989546 = cm.getCanBeParentBlock(node, operationContext);\n            if (_foreign_34989546 != null) {\n              _reporter_2309309498.addAdditionalRuleId(_foreign_34989546.getModel().toString(), _foreign_34989546.getId());\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"920cc822b54193782bf9a6349ccbc5a06051bde7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     *\n     * @return boolean\n     */\n    public boolean handle() {\n        // Don't handle if message is incomplete.\n        if (this.clientMessage == null) {\n            return true;\n        }\n\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            m.insertGelfMessage(message);\n\n            // This is doing the upcounting for statistics.\n            ReceiveHookManager.postProcess(new MessageCounterHook(), message);\n            \n            // Counts up host in hosts collection.\n            ReceiveHookManager.postProcess(new HostUpsertHook(), message);\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }","id":89250,"modified_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     *\n     * @return boolean\n     */\n    public boolean handle() {\n        // Don't handle if message is incomplete.\n        if (this.clientMessage == null) {\n            return true;\n        }\n\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            ReceiveHookManager.postProcess(new GELFMessageFilterHook(), message);\n            if( message.getShortMessage() == \"GRAYLOG2_FILTEROUT\" ) {\n            \tSyslog.getInstance(\"udp\").debug(\"Not inserting event into database.\");\n            } else {\n                m.insertGelfMessage(message);\n                // This is doing the upcounting for statistics.\n                ReceiveHookManager.postProcess(new MessageCounterHook(), message);\n\n                // Counts up host in hosts collection.\n                ReceiveHookManager.postProcess(new HostUpsertHook(), message);\n            }\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }","commit_id":"573bda8152528437c594231f5f6a78cdbc4702e9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Process the hook.\n     */\n    public void process(Object message) {\n\t\t/**\n\t\t * Convert message Object to string for regex match\n\t\t */\n    \tString msg = new String(((SyslogServerEventIF) message).getRaw());\n    \tString regex = null;\n    \tPattern pattern = null;\n    \tMatcher matcher = null;\n\t\t \n    \tint regex_count = Integer.parseInt(Main.regexConfig.getProperty(\"filter.out.count\"));\n    \t\n    \tfor( int i = 0; i < regex_count; i++) {\n    \t\tregex = Main.regexConfig.getProperty(\"filter.out.regex.\" + i);\n    \t\tpattern = Pattern.compile(regex);\n    \t\tmatcher = pattern.matcher(msg);\n\n    \t   \tif(matcher.matches()){\n    \t   \t\tSyslog.getInstance(\"udp\").debug(\"Message Filtered :\" + msg);\n    \t\t\t((SyslogServerEventIF) message).setMessage(\"GRAYLOG2_FILTEROUT\");\n    \t\t\tbreak;\n    \t   \t}\n    \t}\n    }","id":89251,"modified_method":"/**\n     * Process the hook.\n     */\n    public void process(Object message) {\n\t\t/**\n\t\t * Convert message Object to string for regex match\n\t\t */\n    \tString msg = new String(((SyslogServerEventIF) message).getRaw());\n    \tString regex = null;\n    \tPattern pattern = null;\n    \tMatcher matcher = null;\n\t\t \n    \tint regex_count = Integer.parseInt(Main.regexConfig.getProperty(\"filter.out.syslog.count\"));\n    \t\n    \tfor( int i = 0; i < regex_count; i++) {\n    \t\tregex = Main.regexConfig.getProperty(\"filter.out.syslog.regex.\" + i);\n    \t\tpattern = Pattern.compile(regex);\n    \t\tmatcher = pattern.matcher(msg);\n\n    \t   \tif(matcher.matches()){\n    \t   \t\tSyslog.getInstance(\"udp\").debug(\"Message Filtered :\" + msg);\n    \t\t\t((SyslogServerEventIF) message).setMessage(\"GRAYLOG2_FILTEROUT\");\n    \t\t\tbreak;\n    \t   \t}\n    \t}\n    }","commit_id":"573bda8152528437c594231f5f6a78cdbc4702e9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     * \n     * @return boolean\n     */\n    public boolean handle() {\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            m.insertGelfMessage(message);\n\n            // This is doing the upcounting for statistics.\n            ReceiveHookManager.postProcess(new MessageCounterHook(), message);\n\n            // Counts up host in hosts collection.\n            ReceiveHookManager.postProcess(new HostUpsertHook(), message);\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }","id":89252,"modified_method":"/**\n     * Handles the client: Decodes JSON, Stores in MongoDB, ReceiveHooks\n     * \n     * @return boolean\n     */\n    public boolean handle() {\n        try {\n             // Fills properties with values from JSON.\n            try { this.parse(); } catch(Exception e) {\n                Log.warn(\"Could not parse GELF JSON: \" + e.toString() + \" - clientMessage was: \" + this.clientMessage);\n                return false;\n            }\n\n            // Store in MongoDB.\n            // Connect to database.\n            MongoBridge m = new MongoBridge();\n\n            // Log if we are in debug mode.\n            Log.info(\"Got GELF message: \" + message.toString());\n\n            // Insert message into MongoDB.\n            ReceiveHookManager.postProcess(new GELFMessageFilterHook(), message);\n            if( message.getShortMessage() == \"GRAYLOG2_FILTEROUT\" ) {\n            \tSyslog.getInstance(\"udp\").debug(\"Not inserting event into database.\");\n            } else {\n                m.insertGelfMessage(message);\n                // This is doing the upcounting for statistics.\n                ReceiveHookManager.postProcess(new MessageCounterHook(), message);\n\n                // Counts up host in hosts collection.\n                ReceiveHookManager.postProcess(new HostUpsertHook(), message);\n            }\n\n        } catch(Exception e) {\n            Log.warn(\"Could not handle GELF client: \" + e.toString());\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }","commit_id":"573bda8152528437c594231f5f6a78cdbc4702e9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"void resetAnticipator() {\n        m_anticipator.reset();\n        m_anticipatedEvents.clear();\n    }","id":89253,"modified_method":"private void resetAnticipator() {\n        m_anticipator.reset();\n        m_anticipatedEvents.clear();\n    }","commit_id":"0293fca8b947b0c162d50745c1f1e6115d6c452b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void verifyEvents(int remainEvents) {\n        if (remainEvents == 0) {\n            List<Event> receivedList = m_anticipator.getAnticipatedEventsRecieved();\n            log().info(\"verifyEvents: Anticipated=\" + m_anticipatedEvents.size() + \", Received=\" + receivedList.size());\n            if (m_anticipatedEvents.size() != receivedList.size()) {\n                for (Event e : m_anticipatedEvents) {\n                    System.err.println(\"expected event \" + e.getUei() + \": \" + e.getDescr());\n                }\n                System.err.println(\"anticipated = \" + m_anticipatedEvents + \", received = \" + receivedList);\n                fail(\"Anticipated event count (\" + m_anticipatedEvents.size() + \") is different from received event count (\" + receivedList.size() + \").\");\n            }\n            for (int i = 0; i < m_anticipatedEvents.size(); i++) {\n                String anticipated = eventToString(m_anticipatedEvents.get(i));\n                String received = eventToString(receivedList.get(i));\n                log().info(\"verifyEvents: Anticipated \" + anticipated);\n                log().info(\"verifyEvents: Received    \" + received);\n                assertTrue(received.startsWith(anticipated));\n            }\n        }\n        m_anticipator.verifyAnticipated(1000, 0, 0, remainEvents, 0);\n    }","id":89254,"modified_method":"private void verifyEvents(int remainEvents) {\n        if (remainEvents == 0) {\n            List<Event> receivedList = m_anticipator.getAnticipatedEventsRecieved();\n            log().info(\"verifyEvents: Anticipated=\" + m_anticipatedEvents.size() + \", Received=\" + receivedList.size());\n            if (m_anticipatedEvents.size() != receivedList.size()) {\n                for (Event e : m_anticipatedEvents) {\n                    System.err.println(\"expected event \" + e.getUei() + \": \" + e.getDescr());\n                }\n                System.err.println(\"anticipated = \" + m_anticipatedEvents + \", received = \" + receivedList);\n                fail(\"Anticipated event count (\" + m_anticipatedEvents.size() + \") is different from received event count (\" + receivedList.size() + \").\");\n            }\n            for (int i = 0; i < m_anticipatedEvents.size(); i++) {\n                log().info(\"verifyEvents: processing event \" + (i+1));\n                assertTrue(compareEvents(m_anticipatedEvents.get(i), receivedList.get(i)));\n            }\n        }\n        m_anticipator.verifyAnticipated(0, 0, 0, remainEvents, 0);\n    }","commit_id":"0293fca8b947b0c162d50745c1f1e6115d6c452b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void resetAnticipator() {\n        m_anticipator.reset();\n        m_anticipatedEvents.clear();\n    }","id":89255,"modified_method":"private void resetAnticipator() {\n        m_anticipator.reset();\n        m_anticipatedEvents.clear();\n    }","commit_id":"19e979b6061f62fe8e5ad82499a1d86b43f43dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void verifyEvents(int remainEvents) {\n        if (remainEvents == 0) {\n            List<Event> receivedList = m_anticipator.getAnticipatedEventsRecieved();\n            log().info(\"verifyEvents: Anticipated=\" + m_anticipatedEvents.size() + \", Received=\" + receivedList.size());\n            if (m_anticipatedEvents.size() != receivedList.size()) {\n                for (Event e : m_anticipatedEvents) {\n                    System.err.println(\"expected event \" + e.getUei() + \": \" + e.getDescr());\n                }\n                System.err.println(\"anticipated = \" + m_anticipatedEvents + \", received = \" + receivedList);\n                fail(\"Anticipated event count (\" + m_anticipatedEvents.size() + \") is different from received event count (\" + receivedList.size() + \").\");\n            }\n            for (int i = 0; i < m_anticipatedEvents.size(); i++) {\n                String anticipated = eventToString(m_anticipatedEvents.get(i));\n                String received = eventToString(receivedList.get(i));\n                log().info(\"verifyEvents: Anticipated \" + anticipated);\n                log().info(\"verifyEvents: Received    \" + received);\n                assertTrue(received.startsWith(anticipated));\n            }\n        }\n        m_anticipator.verifyAnticipated(1000, 0, 0, remainEvents, 0);\n    }","id":89256,"modified_method":"private void verifyEvents(int remainEvents) {\n        if (remainEvents == 0) {\n            List<Event> receivedList = m_anticipator.getAnticipatedEventsRecieved();\n            log().info(\"verifyEvents: Anticipated=\" + m_anticipatedEvents.size() + \", Received=\" + receivedList.size());\n            if (m_anticipatedEvents.size() != receivedList.size()) {\n                for (Event e : m_anticipatedEvents) {\n                    System.err.println(\"expected event \" + e.getUei() + \": \" + e.getDescr());\n                }\n                System.err.println(\"anticipated = \" + m_anticipatedEvents + \", received = \" + receivedList);\n                fail(\"Anticipated event count (\" + m_anticipatedEvents.size() + \") is different from received event count (\" + receivedList.size() + \").\");\n            }\n            for (int i = 0; i < m_anticipatedEvents.size(); i++) {\n                log().info(\"verifyEvents: processing event \" + (i+1));\n                assertTrue(compareEvents(m_anticipatedEvents.get(i), receivedList.get(i)));\n            }\n        }\n        m_anticipator.verifyAnticipated(0, 0, 0, remainEvents, 0);\n    }","commit_id":"19e979b6061f62fe8e5ad82499a1d86b43f43dd5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void resetAnticipator() {\n        m_anticipator.reset();\n        m_anticipatedEvents.clear();\n    }","id":89257,"modified_method":"private void resetAnticipator() {\n        m_anticipator.reset();\n        m_anticipatedEvents.clear();\n    }","commit_id":"52616c74b74e7d01b4fcf8c044a4e6228e73ebe6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"void verifyEvents(int remainEvents) {\n        if (remainEvents == 0) {\n            List<Event> receivedList = m_anticipator.getAnticipatedEventsRecieved();\n            log().info(\"verifyEvents: Anticipated=\" + m_anticipatedEvents.size() + \", Received=\" + receivedList.size());\n            if (m_anticipatedEvents.size() != receivedList.size()) {\n                for (Event e : m_anticipatedEvents) {\n                    System.err.println(\"expected event \" + e.getUei() + \": \" + e.getDescr());\n                }\n                System.err.println(\"anticipated = \" + m_anticipatedEvents + \", received = \" + receivedList);\n                fail(\"Anticipated event count (\" + m_anticipatedEvents.size() + \") is different from received event count (\" + receivedList.size() + \").\");\n            }\n            for (int i = 0; i < m_anticipatedEvents.size(); i++) {\n                String anticipated = eventToString(m_anticipatedEvents.get(i));\n                String received = eventToString(receivedList.get(i));\n                log().info(\"verifyEvents: Anticipated \" + anticipated);\n                log().info(\"verifyEvents: Received    \" + received);\n                assertTrue(received.startsWith(anticipated));\n            }\n        }\n        m_anticipator.verifyAnticipated(1000, 0, 0, remainEvents, 0);\n    }","id":89258,"modified_method":"private void verifyEvents(int remainEvents) {\n        if (remainEvents == 0) {\n            List<Event> receivedList = m_anticipator.getAnticipatedEventsRecieved();\n            log().info(\"verifyEvents: Anticipated=\" + m_anticipatedEvents.size() + \", Received=\" + receivedList.size());\n            if (m_anticipatedEvents.size() != receivedList.size()) {\n                for (Event e : m_anticipatedEvents) {\n                    System.err.println(\"expected event \" + e.getUei() + \": \" + e.getDescr());\n                }\n                System.err.println(\"anticipated = \" + m_anticipatedEvents + \", received = \" + receivedList);\n                fail(\"Anticipated event count (\" + m_anticipatedEvents.size() + \") is different from received event count (\" + receivedList.size() + \").\");\n            }\n            for (int i = 0; i < m_anticipatedEvents.size(); i++) {\n                log().info(\"verifyEvents: processing event \" + (i+1));\n                assertTrue(compareEvents(m_anticipatedEvents.get(i), receivedList.get(i)));\n            }\n        }\n        m_anticipator.verifyAnticipated(0, 0, 0, remainEvents, 0);\n    }","commit_id":"52616c74b74e7d01b4fcf8c044a4e6228e73ebe6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static DefaultTypeMapping createDefaultTypeMapping(boolean defaultNillable, \n                                                              boolean enableMtomXmime) {\n        // by convention, the default mapping is against the XML schema URI.\n        DefaultTypeMapping tm = new DefaultTypeMapping(SOAPConstants.XSD);\n        fillStandardMappings(tm, defaultNillable, enableMtomXmime);\n        defaultRegister(tm, defaultNillable, Character.class, \n                        CharacterAsStringType.CHARACTER_AS_STRING_TYPE_QNAME,\n                        new CharacterAsStringType());\n        defaultRegister(tm, defaultNillable, char.class, \n                        CharacterAsStringType.CHARACTER_AS_STRING_TYPE_QNAME,\n                        new CharacterAsStringType());\n\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.Duration\", XMLSchemaQNames.XSD_DURATION,\n                            \"org.apache.cxf.aegis.type.java5.DurationType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_DATE,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_TIME,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_G_DAY,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_G_MONTH,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_G_MONTH_DAY,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_G_YEAR,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_G_YEAR_MONTH,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        registerIfAvailable(tm, defaultNillable, \"javax.xml.datatype.XMLGregorianCalendar\",\n                            XMLSchemaQNames.XSD_DATETIME,\n                            \"org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType\");\n        return tm;\n    }","id":89259,"modified_method":"public static DefaultTypeMapping createDefaultTypeMapping(boolean defaultNillable, \n                                                              boolean enableMtomXmime) {\n        // by convention, the default mapping is against the XML schema URI.\n        DefaultTypeMapping tm = new DefaultTypeMapping(SOAPConstants.XSD);\n        fillStandardMappings(tm, defaultNillable, enableMtomXmime);\n        defaultRegister(tm, defaultNillable, Character.class, \n                        CharacterAsStringType.CHARACTER_AS_STRING_TYPE_QNAME,\n                        new CharacterAsStringType());\n        defaultRegister(tm, defaultNillable, char.class, \n                        CharacterAsStringType.CHARACTER_AS_STRING_TYPE_QNAME,\n                        new CharacterAsStringType());\n\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.Duration.class, XMLSchemaQNames.XSD_DURATION,\n                            new org.apache.cxf.aegis.type.java5.DurationType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_DATE,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_TIME,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_G_DAY,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_G_MONTH,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_G_MONTH_DAY,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_G_YEAR,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_G_YEAR_MONTH,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        defaultRegister(tm, defaultNillable, javax.xml.datatype.XMLGregorianCalendar.class,\n                            XMLSchemaQNames.XSD_DATETIME,\n                            new org.apache.cxf.aegis.type.java5.XMLGregorianCalendarType());\n        return tm;\n    }","commit_id":"005861ec81666548ccc61c4e90b2e921f1ebdb08","url":"https://github.com/apache/cxf"},{"original_method":"public void activate(@Nullable final Runnable runnable, boolean autoFocusContents, boolean forced) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    myToolWindowManager.activateToolWindow(myId, forced, autoFocusContents);\n\n    getActivation().doWhenDone(new Runnable() {\n      public void run() {\n        myToolWindowManager.invokeLater(runnable);\n      }\n    });\n  }","id":89260,"modified_method":"public void activate(@Nullable final Runnable runnable, boolean autoFocusContents, boolean forced) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    myToolWindowManager.activateToolWindow(myId, forced, autoFocusContents);\n\n    if (runnable != null) {\n      getActivation().doWhenDone(new Runnable() {\n        public void run() {\n          myToolWindowManager.invokeLater(runnable);\n        }\n      });\n    }\n  }","commit_id":"4e6043b715857d542f2f2f746bfc3717888738a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void show(final Runnable runnable) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    myToolWindowManager.showToolWindow(myId);\n    getActivation().doWhenDone(new Runnable() {\n      public void run() {\n        myToolWindowManager.invokeLater(runnable);\n      }\n    });\n  }","id":89261,"modified_method":"public final void show(final Runnable runnable) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    myToolWindowManager.showToolWindow(myId);\n    if (runnable != null) {\n      getActivation().doWhenDone(new Runnable() {\n        public void run() {\n          myToolWindowManager.invokeLater(runnable);\n        }\n      });\n    }\n  }","commit_id":"4e6043b715857d542f2f2f746bfc3717888738a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Stops this bundle.\n     * @param bc the bundle context\n     * @throws Exception if something goes wrong\n     */\n    public void stop(BundleContext bc) throws Exception\n    {\n        bc.removeServiceListener(panel);\n        panelRegistration.unregister();\n    }","id":89262,"modified_method":"/**\n     * Stops this bundle.\n     * @param bc the bundle context\n     * @throws Exception if something goes wrong\n     */\n    public void stop(BundleContext bc) throws Exception\n    {\n        if(panel != null)\n            bc.removeServiceListener(panel);\n\n        if(panelRegistration != null)\n            panelRegistration.unregister();\n    }","commit_id":"1ffcb1c2ddb5bf5859e9e4cc42c81b309951962e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Loads all user interface configurations.\n     */\n    public static void loadGuiConfigurations()\n    {\n        configService.addPropertyChangeListener(\n            new ConfigurationChangeListener());\n\n        // Load the \"auPopupNewMessage\" property.\n        String autoPopupProperty = \n            \"service.gui.AUTO_POPUP_NEW_MESSAGE\";\n\n        String autoPopup = configService.getString(autoPopupProperty);\n\n        if(autoPopup == null)\n            autoPopup = GuiActivator.getResources().\n                getSettingsString(autoPopupProperty);\n\n        if(autoPopup != null && autoPopup.equalsIgnoreCase(\"yes\"))\n            autoPopupNewMessage = true;\n\n        // Load the \"sendMessageCommand\" property.\n        String messageCommandProperty\n            = \"service.gui.SEND_MESSAGE_COMMAND\";\n        String messageCommand = configService.getString(messageCommandProperty);\n\n        if(messageCommand == null)\n            messageCommand\n                = GuiActivator.getResources()\n                    .getSettingsString(messageCommandProperty);\n\n        if(messageCommand == null || messageCommand.length() == 0)\n            sendMessageCommand = messageCommand;\n\n        // Load the showCallPanel property.\n        String callPanelShown = configService.getString(\n            \"net.java.sip.communicator.impl.gui.showCallPanel\");\n\n        if(callPanelShown != null && callPanelShown.length() > 0)\n        {\n            isCallPanelShown = Boolean.parseBoolean(callPanelShown);\n        }\n\n        // Load the \"showOffline\" property.\n        String showOffline = configService.getString(\n            \"net.java.sip.communicator.impl.gui.showOffline\");\n        \n        if(showOffline != null && showOffline.length() > 0)\n        {\n            isShowOffline = Boolean.parseBoolean(showOffline);\n        }\n\n        // Load the \"showApplication\" property.\n        String isVisible = configService.getString(\n            \"net.java.sip.communicator.impl.systray.showApplication\");\n\n        if(isVisible != null && isVisible.length() > 0)\n        {\n            isApplicationVisible = new Boolean(isVisible).booleanValue();\n        }\n\n        // Load the \"showAppQuitWarning\" property.\n        String quitWarningShown = configService.getString(\n            \"net.java.sip.communicator.impl.gui.quitWarningShown\");\n\n        if(quitWarningShown != null && quitWarningShown.length() > 0)\n        {\n            isQuitWarningShown\n                = Boolean.parseBoolean(quitWarningShown);\n        }\n\n        // Load the \"sendTypingNotifications\" property.\n        String isSendTypingNotifProperty = \n            \"service.gui.SEND_TYPING_NOTIFICATIONS_ENABLED\";\n        String isSendTypingNotif = \n            configService.getString(isSendTypingNotifProperty);\n\n        if(isSendTypingNotif == null)\n            isSendTypingNotif = \n                GuiActivator.getResources().\n                    getSettingsString(isSendTypingNotifProperty);\n\n        if(isSendTypingNotif != null && isSendTypingNotif.length() > 0)\n        {\n            isSendTypingNotifications\n                = Boolean.parseBoolean(isSendTypingNotif);\n        }\n\n        // Load the \"isMoveContactConfirmationRequested\" property.\n        String isMoveContactConfirmationRequestedString\n            = configService.getString(\n            \"net.java.sip.communicator.impl.gui.isMoveContactConfirmationRequested\");\n\n        if(isMoveContactConfirmationRequestedString != null\n            && isMoveContactConfirmationRequestedString.length() > 0)\n        {\n            isMoveContactConfirmationRequested\n                = Boolean.parseBoolean(isMoveContactConfirmationRequestedString);\n        }\n\n        // Load the \"isMultiChatWindowEnabled\" property.\n        String isMultiChatWindowEnabledStringProperty\n            = \"service.gui.IS_MULTI_CHAT_WINDOW_ENABLED\";\n\n        String isMultiChatWindowEnabledString\n            = configService.getString(isMultiChatWindowEnabledStringProperty);\n\n        if(isMultiChatWindowEnabledString == null)\n            isMultiChatWindowEnabledString = \n                GuiActivator.getResources().\n                    getSettingsString(isMultiChatWindowEnabledStringProperty);\n\n        if(isMultiChatWindowEnabledString != null\n            && isMultiChatWindowEnabledString.length() > 0)\n        {\n            isMultiChatWindowEnabled\n                = Boolean.parseBoolean(isMultiChatWindowEnabledString);\n        }\n\n        // Load the \"isLeaveChatroomOnWindowCloseEnabled\" property.\n        String isLeaveChatRoomOnWindowCloseEnabledStringProperty\n            = \"service.gui.LEAVE_CHATROOM_ON_WINDOW_CLOSE\";\n\n        String isLeaveChatRoomOnWindowCloseEnabledString\n            = configService.getString(\n                isLeaveChatRoomOnWindowCloseEnabledStringProperty);\n\n        if(isLeaveChatRoomOnWindowCloseEnabledString == null)\n            isLeaveChatRoomOnWindowCloseEnabledString =\n                GuiActivator.getResources().getSettingsString(\n                    isLeaveChatRoomOnWindowCloseEnabledStringProperty);\n\n        if(isLeaveChatRoomOnWindowCloseEnabledString != null\n            && isLeaveChatRoomOnWindowCloseEnabledString.length() > 0)\n        {\n            isLeaveChatRoomOnWindowCloseEnabled\n                = new Boolean(isLeaveChatRoomOnWindowCloseEnabledString)\n                    .booleanValue();\n        }\n\n        // Load the \"isHistoryLoggingEnabled\" property.\n        String isHistoryLoggingEnabledString\n            = configService.getString(\n            \"net.java.sip.communicator.impl.gui.isHistoryLoggingEnabled\");\n\n        if(isHistoryLoggingEnabledString != null\n            && isHistoryLoggingEnabledString.length() > 0)\n        {\n            isHistoryLoggingEnabled\n                = Boolean.parseBoolean(isHistoryLoggingEnabledString);\n        }\n\n        // Load the \"isHistoryShown\" property.\n        String isHistoryShownStringProperty = \n            \"service.gui.IS_MESSAGE_HISTORY_SHOWN\";\n\n        String isHistoryShownString\n            = configService.getString(isHistoryShownStringProperty);\n\n        if(isHistoryShownString == null)\n            isHistoryShownString = \n                GuiActivator.getResources().\n                    getSettingsString(isHistoryShownStringProperty);\n\n        if(isHistoryShownString != null\n            && isHistoryShownString.length() > 0)\n        {\n            isHistoryShown\n                = Boolean.parseBoolean(isHistoryShownString);\n        }\n\n        // Load the \"chatHistorySize\" property.\n        String chatHistorySizeStringProperty =\n            \"service.gui.MESSAGE_HISTORY_SIZE\";\n        String chatHistorySizeString\n            = configService.getString(chatHistorySizeStringProperty);\n\n        if(chatHistorySizeString == null)\n            chatHistorySizeString = \n                GuiActivator.getResources().\n                    getSettingsString(chatHistorySizeStringProperty);\n\n        if(chatHistorySizeString != null\n            && chatHistorySizeString.length() > 0)\n        {\n            chatHistorySize = Integer.parseInt(chatHistorySizeString);\n        }\n\n        // Load the \"CHAT_WRITE_AREA_SIZE\" property.\n        String chatWriteAreaSizeStringProperty =\n            \"net.java.sip.communicator.impl.gui.CHAT_WRITE_AREA_SIZE\";\n        String chatWriteAreaSizeString\n            = configService.getString(chatWriteAreaSizeStringProperty);\n\n        if(chatWriteAreaSizeString == null)\n            chatWriteAreaSizeString = \n                GuiActivator.getResources().\n                    getSettingsString(chatWriteAreaSizeStringProperty);\n\n        if(chatWriteAreaSizeString != null\n            && chatWriteAreaSizeString.length() > 0)\n        {\n            chatWriteAreaSize\n                = Integer.parseInt(chatWriteAreaSizeString);\n        }\n\n        // Load the \"isTransparentWindowEnabled\" property.\n        String isTransparentWindowEnabledProperty =\n            \"impl.gui.IS_TRANSPARENT_WINDOW_ENABLED\";\n\n        String isTransparentWindowEnabledString\n            = configService.getString(isTransparentWindowEnabledProperty);\n\n        if(isTransparentWindowEnabledString == null)\n            isTransparentWindowEnabledString = \n                GuiActivator.getResources().\n                    getSettingsString(isTransparentWindowEnabledProperty);\n\n        if(isTransparentWindowEnabledString != null\n            && isTransparentWindowEnabledString.length() > 0)\n        {\n            isTransparentWindowEnabled\n                = Boolean.parseBoolean(isTransparentWindowEnabledString);\n        }\n\n        // Load the \"windowTransparency\" property.\n        String windowTransparencyProperty =\n            \"impl.gui.WINDOW_TRANSPARENCY\";\n\n        String windowTransparencyString\n            = configService.getString(windowTransparencyProperty);\n\n        if(windowTransparencyString == null)\n            windowTransparencyString = \n                GuiActivator.getResources().\n                    getSettingsString(windowTransparencyProperty);\n\n        if(windowTransparencyString != null\n            && windowTransparencyString.length() > 0)\n        {\n            windowTransparency\n                = Integer.parseInt(windowTransparencyString);\n        }\n\n        // Load the \"isWindowDecorated\" property.\n        String isWindowDecoratedProperty\n            = \"impl.gui.IS_WINDOW_DECORATED\";\n\n        String isWindowDecoratedString\n            = configService.getString(isWindowDecoratedProperty);\n\n        if(isWindowDecoratedString == null)\n            isWindowDecoratedString = \n                GuiActivator.getResources().\n                    getSettingsString(isWindowDecoratedProperty);\n\n        if(isWindowDecoratedString != null\n            && isWindowDecoratedString.length() > 0)\n        {\n            isWindowDecorated\n                = Boolean.parseBoolean(isWindowDecoratedString);\n        }\n\n        // Load the \"isChatToolbarVisible\" property\n        isChatToolbarVisible\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.ChatWindow.showToolbar\",\n                true);\n        // Load the \"isChatToolbarVisible\" property\n        isChatStylebarVisible\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.ChatWindow.showStylebar\",\n                true);\n\n        // Load the \"isShowSmileys\" property\n        isShowSmileys\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.ChatWindow.showSmileys\",\n                true);\n\n        // Load the \"lastContactParent\" property.\n        lastContactParent = configService.getString(\n            \"net.java.sip.communicator.impl.gui.addcontact.lastContactParent\");\n\n        // Load the \"sendFileLastDir\" property.\n        sendFileLastDir = configService.getString(\n            \"net.java.sip.communicator.impl.gui.chat.filetransfer.\" +\n            \"SEND_FILE_LAST_DIR\");\n\n        // Load the \"ADD_CONTACT_DISABLED\" property.\n        isAddContactDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.contactlist.\" +\n                \"CONTACT_ADD_DISABLED\",\n                false);\n\n        // Load the \"CREATE_GROUP_DISABLED\" property.\n        isCreateGroupDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.contactlist.\" +\n                \"CREATE_GROUP_DISABLED\",\n                false);\n\n        // Load the \"GO_TO_CHATROOM_DISABLED\" property.\n        isGoToChatroomDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.chatroomslist.\" +\n                \"GO_TO_CHATROOM_DISABLED\",\n                false);\n\n        // Load the \"REMOVE_CONTACT_DISABLED\" property.\n        isRemoveContactDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.contactlist.\" +\n                \"CONTACT_REMOVE_DISABLED\",\n                false);\n\n        // Load the \"net.java.sip.communicator.impl.gui.main.account\n        // .ADVANCED_CONFIG_DISABLED\" property.\n        String advancedConfigDisabledDefaultProp\n            = GuiActivator.getResources().getSettingsString(\n                \"impl.gui.main.account.ADVANCED_CONFIG_DISABLED\");\n\n        boolean isAdvancedConfigDisabled = false;\n\n        if (advancedConfigDisabledDefaultProp != null)\n            isAdvancedConfigDisabled\n                = Boolean.parseBoolean(advancedConfigDisabledDefaultProp);\n\n        // Load the advanced account configuration disabled.\n        isAdvancedAccountConfigDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.account.\" +\n                \"ADVANCED_CONFIG_DISABLED\",\n                isAdvancedConfigDisabled);\n\n        if(isFontSupportEnabled())\n        {\n            // Load default font family string.\n            defaultFontFamily = configService.getString(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_FAMILY\");\n\n            // Load default font size.\n            defaultFontSize = configService.getString(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_SIZE\");\n\n            // Load isBold chat property.\n            isDefaultFontBold = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_BOLD\",\n                isDefaultFontBold);\n\n            // Load isItalic chat property.\n            isDefaultFontItalic = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_ITALIC\",\n                isDefaultFontItalic);\n\n            // Load isUnderline chat property.\n            isDefaultFontUnderline = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_UNDERLINE\",\n                isDefaultFontUnderline);\n\n            // Load default font color property.\n            int colorSetting = configService.getInt(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_COLOR\",\n                -1);\n\n            if(colorSetting != -1)\n                defaultFontColor = colorSetting;\n        }\n\n        String showStatusChangedInChatProperty\n                = \"impl.gui.SHOW_STATUS_CHANGED_IN_CHAT\";\n        String showStatusChangedInChatDefault = GuiActivator.getResources().\n            getSettingsString(showStatusChangedInChatProperty);\n\n        // if there is a default value use it\n        if(showStatusChangedInChatDefault != null)\n            showStatusChangedInChat = Boolean.parseBoolean(\n                showStatusChangedInChatDefault);\n\n        showStatusChangedInChat = configService.getBoolean(\n            showStatusChangedInChatProperty,\n            showStatusChangedInChat);\n    }","id":89263,"modified_method":"/**\n     * Loads all user interface configurations.\n     */\n    public static void loadGuiConfigurations()\n    {\n        configService.addPropertyChangeListener(\n            new ConfigurationChangeListener());\n\n        // Load the \"auPopupNewMessage\" property.\n        String autoPopupProperty = \n            \"service.gui.AUTO_POPUP_NEW_MESSAGE\";\n\n        String autoPopup = configService.getString(autoPopupProperty);\n\n        if(autoPopup == null)\n            autoPopup = GuiActivator.getResources().\n                getSettingsString(autoPopupProperty);\n\n        if(autoPopup != null && autoPopup.equalsIgnoreCase(\"yes\"))\n            autoPopupNewMessage = true;\n\n        // Load the \"sendMessageCommand\" property.\n        String messageCommandProperty\n            = \"service.gui.SEND_MESSAGE_COMMAND\";\n        String messageCommand = configService.getString(messageCommandProperty);\n\n        if(messageCommand == null)\n            messageCommand\n                = GuiActivator.getResources()\n                    .getSettingsString(messageCommandProperty);\n\n        if(messageCommand == null || messageCommand.length() == 0)\n            sendMessageCommand = messageCommand;\n\n        // Load the showCallPanel property.\n        String callPanelShown = configService.getString(\n            \"net.java.sip.communicator.impl.gui.showCallPanel\");\n\n        if(callPanelShown != null && callPanelShown.length() > 0)\n        {\n            isCallPanelShown = Boolean.parseBoolean(callPanelShown);\n        }\n\n        // Load the \"showOffline\" property.\n        String showOffline = configService.getString(\n            \"net.java.sip.communicator.impl.gui.showOffline\");\n        \n        if(showOffline != null && showOffline.length() > 0)\n        {\n            isShowOffline = Boolean.parseBoolean(showOffline);\n        }\n\n        // Load the \"showApplication\" property.\n        String isVisible = configService.getString(\n            \"net.java.sip.communicator.impl.systray.showApplication\");\n\n        if(isVisible != null && isVisible.length() > 0)\n        {\n            isApplicationVisible = new Boolean(isVisible).booleanValue();\n        }\n\n        // Load the \"showAppQuitWarning\" property.\n        String quitWarningShown = configService.getString(\n            \"net.java.sip.communicator.impl.gui.quitWarningShown\");\n\n        if(quitWarningShown != null && quitWarningShown.length() > 0)\n        {\n            isQuitWarningShown\n                = Boolean.parseBoolean(quitWarningShown);\n        }\n\n        // Load the \"sendTypingNotifications\" property.\n        String isSendTypingNotifProperty = \n            \"service.gui.SEND_TYPING_NOTIFICATIONS_ENABLED\";\n        String isSendTypingNotif = \n            configService.getString(isSendTypingNotifProperty);\n\n        if(isSendTypingNotif == null)\n            isSendTypingNotif = \n                GuiActivator.getResources().\n                    getSettingsString(isSendTypingNotifProperty);\n\n        if(isSendTypingNotif != null && isSendTypingNotif.length() > 0)\n        {\n            isSendTypingNotifications\n                = Boolean.parseBoolean(isSendTypingNotif);\n        }\n\n        // Load the \"isMoveContactConfirmationRequested\" property.\n        String isMoveContactConfirmationRequestedString\n            = configService.getString(\n            \"net.java.sip.communicator.impl.gui.isMoveContactConfirmationRequested\");\n\n        if(isMoveContactConfirmationRequestedString != null\n            && isMoveContactConfirmationRequestedString.length() > 0)\n        {\n            isMoveContactConfirmationRequested\n                = Boolean.parseBoolean(isMoveContactConfirmationRequestedString);\n        }\n\n        // Load the \"isMultiChatWindowEnabled\" property.\n        String isMultiChatWindowEnabledStringProperty\n            = \"service.gui.IS_MULTI_CHAT_WINDOW_ENABLED\";\n\n        String isMultiChatWindowEnabledString\n            = configService.getString(isMultiChatWindowEnabledStringProperty);\n\n        if(isMultiChatWindowEnabledString == null)\n            isMultiChatWindowEnabledString = \n                GuiActivator.getResources().\n                    getSettingsString(isMultiChatWindowEnabledStringProperty);\n\n        if(isMultiChatWindowEnabledString != null\n            && isMultiChatWindowEnabledString.length() > 0)\n        {\n            isMultiChatWindowEnabled\n                = Boolean.parseBoolean(isMultiChatWindowEnabledString);\n        }\n\n        // Load the \"isLeaveChatroomOnWindowCloseEnabled\" property.\n        String isLeaveChatRoomOnWindowCloseEnabledStringProperty\n            = \"service.gui.LEAVE_CHATROOM_ON_WINDOW_CLOSE\";\n\n        String isLeaveChatRoomOnWindowCloseEnabledString\n            = configService.getString(\n                isLeaveChatRoomOnWindowCloseEnabledStringProperty);\n\n        if(isLeaveChatRoomOnWindowCloseEnabledString == null)\n            isLeaveChatRoomOnWindowCloseEnabledString =\n                GuiActivator.getResources().getSettingsString(\n                    isLeaveChatRoomOnWindowCloseEnabledStringProperty);\n\n        if(isLeaveChatRoomOnWindowCloseEnabledString != null\n            && isLeaveChatRoomOnWindowCloseEnabledString.length() > 0)\n        {\n            isLeaveChatRoomOnWindowCloseEnabled\n                = new Boolean(isLeaveChatRoomOnWindowCloseEnabledString)\n                    .booleanValue();\n        }\n\n        // Load the \"isHistoryLoggingEnabled\" property.\n        String isHistoryLoggingEnabledString\n            = configService.getString(\n            \"net.java.sip.communicator.impl.gui.isHistoryLoggingEnabled\");\n\n        if(isHistoryLoggingEnabledString != null\n            && isHistoryLoggingEnabledString.length() > 0)\n        {\n            isHistoryLoggingEnabled\n                = Boolean.parseBoolean(isHistoryLoggingEnabledString);\n        }\n\n        // Load the \"isHistoryShown\" property.\n        String isHistoryShownStringProperty = \n            \"service.gui.IS_MESSAGE_HISTORY_SHOWN\";\n\n        String isHistoryShownString\n            = configService.getString(isHistoryShownStringProperty);\n\n        if(isHistoryShownString == null)\n            isHistoryShownString = \n                GuiActivator.getResources().\n                    getSettingsString(isHistoryShownStringProperty);\n\n        if(isHistoryShownString != null\n            && isHistoryShownString.length() > 0)\n        {\n            isHistoryShown\n                = Boolean.parseBoolean(isHistoryShownString);\n        }\n\n        // Load the \"chatHistorySize\" property.\n        String chatHistorySizeStringProperty =\n            \"service.gui.MESSAGE_HISTORY_SIZE\";\n        String chatHistorySizeString\n            = configService.getString(chatHistorySizeStringProperty);\n\n        if(chatHistorySizeString == null)\n            chatHistorySizeString = \n                GuiActivator.getResources().\n                    getSettingsString(chatHistorySizeStringProperty);\n\n        if(chatHistorySizeString != null\n            && chatHistorySizeString.length() > 0)\n        {\n            chatHistorySize = Integer.parseInt(chatHistorySizeString);\n        }\n\n        // Load the \"CHAT_WRITE_AREA_SIZE\" property.\n        String chatWriteAreaSizeStringProperty =\n            \"net.java.sip.communicator.impl.gui.CHAT_WRITE_AREA_SIZE\";\n        String chatWriteAreaSizeString\n            = configService.getString(chatWriteAreaSizeStringProperty);\n\n        if(chatWriteAreaSizeString == null)\n            chatWriteAreaSizeString = \n                GuiActivator.getResources().\n                    getSettingsString(chatWriteAreaSizeStringProperty);\n\n        if(chatWriteAreaSizeString != null\n            && chatWriteAreaSizeString.length() > 0)\n        {\n            chatWriteAreaSize\n                = Integer.parseInt(chatWriteAreaSizeString);\n        }\n\n        // Load the \"isTransparentWindowEnabled\" property.\n        String isTransparentWindowEnabledProperty =\n            \"impl.gui.IS_TRANSPARENT_WINDOW_ENABLED\";\n\n        String isTransparentWindowEnabledString\n            = configService.getString(isTransparentWindowEnabledProperty);\n\n        if(isTransparentWindowEnabledString == null)\n            isTransparentWindowEnabledString = \n                GuiActivator.getResources().\n                    getSettingsString(isTransparentWindowEnabledProperty);\n\n        if(isTransparentWindowEnabledString != null\n            && isTransparentWindowEnabledString.length() > 0)\n        {\n            isTransparentWindowEnabled\n                = Boolean.parseBoolean(isTransparentWindowEnabledString);\n        }\n\n        // Load the \"windowTransparency\" property.\n        String windowTransparencyProperty =\n            \"impl.gui.WINDOW_TRANSPARENCY\";\n\n        String windowTransparencyString\n            = configService.getString(windowTransparencyProperty);\n\n        if(windowTransparencyString == null)\n            windowTransparencyString = \n                GuiActivator.getResources().\n                    getSettingsString(windowTransparencyProperty);\n\n        if(windowTransparencyString != null\n            && windowTransparencyString.length() > 0)\n        {\n            windowTransparency\n                = Integer.parseInt(windowTransparencyString);\n        }\n\n        // Load the \"isWindowDecorated\" property.\n        String isWindowDecoratedProperty\n            = \"impl.gui.IS_WINDOW_DECORATED\";\n\n        String isWindowDecoratedString\n            = configService.getString(isWindowDecoratedProperty);\n\n        if(isWindowDecoratedString == null)\n            isWindowDecoratedString = \n                GuiActivator.getResources().\n                    getSettingsString(isWindowDecoratedProperty);\n\n        if(isWindowDecoratedString != null\n            && isWindowDecoratedString.length() > 0)\n        {\n            isWindowDecorated\n                = Boolean.parseBoolean(isWindowDecoratedString);\n        }\n\n        // Load the \"isChatToolbarVisible\" property\n        isChatToolbarVisible\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.ChatWindow.showToolbar\",\n                true);\n        // Load the \"isChatToolbarVisible\" property\n        isChatStylebarVisible\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.ChatWindow.showStylebar\",\n                true);\n\n        // Load the \"isShowSmileys\" property\n        isShowSmileys\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.ChatWindow.showSmileys\",\n                true);\n\n        // Load the \"lastContactParent\" property.\n        lastContactParent = configService.getString(\n            \"net.java.sip.communicator.impl.gui.addcontact.lastContactParent\");\n\n        // Load the \"sendFileLastDir\" property.\n        sendFileLastDir = configService.getString(\n            \"net.java.sip.communicator.impl.gui.chat.filetransfer.\" +\n            \"SEND_FILE_LAST_DIR\");\n\n        // Load the \"ADD_CONTACT_DISABLED\" property.\n        isAddContactDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.contactlist.\" +\n                \"CONTACT_ADD_DISABLED\",\n                false);\n\n        // Load the \"CREATE_GROUP_DISABLED\" property.\n        isCreateGroupDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.contactlist.\" +\n                \"CREATE_GROUP_DISABLED\",\n                false);\n\n        // Load the \"GO_TO_CHATROOM_DISABLED\" property.\n        isGoToChatroomDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.chatroomslist.\" +\n                \"GO_TO_CHATROOM_DISABLED\",\n                false);\n\n        // Load the \"REMOVE_CONTACT_DISABLED\" property.\n        isRemoveContactDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.contactlist.\" +\n                \"CONTACT_REMOVE_DISABLED\",\n                false);\n\n        // Load the \"net.java.sip.communicator.impl.gui.main.account\n        // .ADVANCED_CONFIG_DISABLED\" property.\n        String advancedConfigDisabledDefaultProp\n            = GuiActivator.getResources().getSettingsString(\n                \"impl.gui.main.account.ADVANCED_CONFIG_DISABLED\");\n\n        boolean isAdvancedConfigDisabled = false;\n\n        if (advancedConfigDisabledDefaultProp != null)\n            isAdvancedConfigDisabled\n                = Boolean.parseBoolean(advancedConfigDisabledDefaultProp);\n\n        // Load the advanced account configuration disabled.\n        isAdvancedAccountConfigDisabled\n            = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.main.account.\" +\n                \"ADVANCED_CONFIG_DISABLED\",\n                isAdvancedConfigDisabled);\n\n        if(isFontSupportEnabled())\n        {\n            // Load default font family string.\n            defaultFontFamily = configService.getString(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_FAMILY\");\n\n            // Load default font size.\n            defaultFontSize = configService.getString(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_SIZE\");\n\n            // Load isBold chat property.\n            isDefaultFontBold = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_BOLD\",\n                isDefaultFontBold);\n\n            // Load isItalic chat property.\n            isDefaultFontItalic = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_ITALIC\",\n                isDefaultFontItalic);\n\n            // Load isUnderline chat property.\n            isDefaultFontUnderline = configService.getBoolean(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_UNDERLINE\",\n                isDefaultFontUnderline);\n\n            // Load default font color property.\n            int colorSetting = configService.getInt(\n                \"net.java.sip.communicator.impl.gui.chat.DEFAULT_FONT_COLOR\",\n                -1);\n\n            if(colorSetting != -1)\n                defaultFontColor = colorSetting;\n        }\n\n        String showStatusChangedInChatProperty\n                = \"impl.gui.SHOW_STATUS_CHANGED_IN_CHAT\";\n        String showStatusChangedInChatDefault = GuiActivator.getResources().\n            getSettingsString(showStatusChangedInChatProperty);\n\n        // if there is a default value use it\n        if(showStatusChangedInChatDefault != null)\n            showStatusChangedInChat = Boolean.parseBoolean(\n                showStatusChangedInChatDefault);\n\n        showStatusChangedInChat = configService.getBoolean(\n            showStatusChangedInChatProperty,\n            showStatusChangedInChat);\n\n        String routeVideoAndDesktopUsingPhoneNumberProperty\n            = \"impl.gui.ROUTE_VIDEO_AND_DESKTOP_TO_PNONENUMBER\";\n        String routeVideoAndDesktopUsingPhoneNumberDefault =\n            GuiActivator.getResources()\n                .getSettingsString(routeVideoAndDesktopUsingPhoneNumberProperty);\n\n        if(routeVideoAndDesktopUsingPhoneNumberDefault != null)\n            routeVideoAndDesktopUsingPhoneNumber = Boolean.parseBoolean(\n                routeVideoAndDesktopUsingPhoneNumberDefault);\n    }","commit_id":"1ffcb1c2ddb5bf5859e9e4cc42c81b309951962e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Calls the given treeNode with video option enabled.\n     * @param treeNode the <tt>TreeNode<\/tt> to call\n     */\n    private void callVideo(TreeNode treeNode)\n    {\n        List<UIContactDetail> videoContacts\n            = ((ContactNode) treeNode).getContactDescriptor()\n                .getContactDetailsForOperationSet(\n                    OperationSetVideoTelephony.class);\n\n        ChooseCallAccountPopupMenu chooseAccountDialog = null;\n\n        if (videoContacts.size() == 1)\n        {\n            UIContactDetail detail = videoContacts.get(0);\n\n            ProtocolProviderService preferredProvider\n                = detail.getPreferredProtocolProvider(\n                    OperationSetVideoTelephony.class);\n\n            List<ProtocolProviderService> providers = null;\n            String protocolName = null;\n\n            if (preferredProvider != null)\n            {\n                if (preferredProvider.isRegistered())\n                    CallManager.createVideoCall(\n                        preferredProvider, detail.getAddress());\n                // If we have a provider, but it's not registered we try to\n                // obtain all registered providers for the same protocol as the\n                // given preferred provider.\n                else\n                {\n                    protocolName = preferredProvider.getProtocolName();\n                    providers = GuiActivator.getRegisteredProviders(protocolName,\n                        OperationSetVideoTelephony.class);\n                }\n            }\n            // If we don't have a preferred provider we try to obtain a\n            // preferred protocol name and all registered providers for it.\n            else\n            {\n                protocolName = detail\n                    .getPreferredProtocol(OperationSetVideoTelephony.class);\n\n                if (protocolName != null)\n                    providers\n                        = GuiActivator.getRegisteredProviders(protocolName,\n                            OperationSetVideoTelephony.class);\n                else\n                    providers\n                        = GuiActivator.getRegisteredProviders(\n                            OperationSetVideoTelephony.class);\n            }\n\n            // If our call didn't succeed, try to call through one of the other\n            // protocol providers obtained above.\n            if (providers != null)\n            {\n                int providersCount = providers.size();\n\n                if (providersCount <= 0)\n                {\n                    new ErrorDialog(null,\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.CALL_FAILED\"),\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\",\n                            new String[]{protocolName}))\n                    .showDialog();\n                }\n                else if (providersCount == 1)\n                {\n                    CallManager.createVideoCall(\n                        providers.get(0), detail.getAddress());\n                }\n                else if (providersCount > 1)\n                    chooseAccountDialog = new ChooseCallAccountPopupMenu(\n                            tree, detail.getAddress(), providers,\n                            OperationSetVideoTelephony.class);\n            }\n        }\n        else if (videoContacts.size() > 1)\n        {\n            chooseAccountDialog\n                = new ChooseCallAccountPopupMenu(tree, videoContacts,\n                    OperationSetVideoTelephony.class);\n        }\n\n        // If the choose dialog is created we're going to show it.\n        if (chooseAccountDialog != null)\n        {\n            Point location = new Point(callVideoButton.getX(),\n                callVideoButton.getY() + callVideoButton.getHeight());\n\n            SwingUtilities.convertPointToScreen(location, tree);\n\n            location.y = location.y\n                + tree.getPathBounds(tree.getSelectionPath()).y;\n\n            chooseAccountDialog.showPopupMenu(location.x + 8, location.y - 8);\n        }\n    }","id":89264,"modified_method":"/**\n     * Calls the given treeNode with video option enabled.\n     * @param treeNode the <tt>TreeNode<\/tt> to call\n     */\n    private void callVideo(TreeNode treeNode)\n    {\n        List<UIContactDetail> videoContacts\n            = ((ContactNode) treeNode).getContactDescriptor()\n                .getContactDetailsForOperationSet(\n                    OperationSetVideoTelephony.class);\n\n        if(ConfigurationManager.isRouteVideoAndDesktopUsingPhoneNumberEnabled())\n            videoContacts.addAll(getAdditionalNumbers());\n\n        ChooseCallAccountPopupMenu chooseAccountDialog = null;\n\n        if (videoContacts.size() == 1)\n        {\n            UIContactDetail detail = videoContacts.get(0);\n\n            ProtocolProviderService preferredProvider\n                = detail.getPreferredProtocolProvider(\n                    OperationSetVideoTelephony.class);\n\n            List<ProtocolProviderService> providers = null;\n            String protocolName = null;\n\n            if (preferredProvider != null)\n            {\n                if (preferredProvider.isRegistered())\n                    CallManager.createVideoCall(\n                        preferredProvider, detail.getAddress());\n                // If we have a provider, but it's not registered we try to\n                // obtain all registered providers for the same protocol as the\n                // given preferred provider.\n                else\n                {\n                    protocolName = preferredProvider.getProtocolName();\n                    providers = GuiActivator.getRegisteredProviders(protocolName,\n                        OperationSetVideoTelephony.class);\n                }\n            }\n            // If we don't have a preferred provider we try to obtain a\n            // preferred protocol name and all registered providers for it.\n            else\n            {\n                protocolName = detail\n                    .getPreferredProtocol(OperationSetVideoTelephony.class);\n\n                if (protocolName != null)\n                    providers\n                        = GuiActivator.getRegisteredProviders(protocolName,\n                            OperationSetVideoTelephony.class);\n                else\n                    providers\n                        = GuiActivator.getRegisteredProviders(\n                            OperationSetVideoTelephony.class);\n            }\n\n            // If our call didn't succeed, try to call through one of the other\n            // protocol providers obtained above.\n            if (providers != null)\n            {\n                int providersCount = providers.size();\n\n                if (providersCount <= 0)\n                {\n                    new ErrorDialog(null,\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.CALL_FAILED\"),\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\",\n                            new String[]{protocolName}))\n                    .showDialog();\n                }\n                else if (providersCount == 1)\n                {\n                    CallManager.createVideoCall(\n                        providers.get(0), detail.getAddress());\n                }\n                else if (providersCount > 1)\n                    chooseAccountDialog = new ChooseCallAccountPopupMenu(\n                            tree, detail.getAddress(), providers,\n                            OperationSetVideoTelephony.class);\n            }\n        }\n        else if (videoContacts.size() > 1)\n        {\n            chooseAccountDialog\n                = new ChooseCallAccountPopupMenu(tree, videoContacts,\n                    OperationSetVideoTelephony.class);\n        }\n\n        // If the choose dialog is created we're going to show it.\n        if (chooseAccountDialog != null)\n        {\n            Point location = new Point(callVideoButton.getX(),\n                callVideoButton.getY() + callVideoButton.getHeight());\n\n            SwingUtilities.convertPointToScreen(location, tree);\n\n            location.y = location.y\n                + tree.getPathBounds(tree.getSelectionPath()).y;\n\n            chooseAccountDialog.showPopupMenu(location.x + 8, location.y - 8);\n        }\n    }","commit_id":"1ffcb1c2ddb5bf5859e9e4cc42c81b309951962e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Calls the given treeNode.\n     * @param treeNode the <tt>TreeNode<\/tt> to call\n     */\n    private void call(TreeNode treeNode)\n    {\n        List<UIContactDetail> telephonyContacts\n            = ((ContactNode) treeNode).getContactDescriptor()\n                .getContactDetailsForOperationSet(\n                    OperationSetBasicTelephony.class);\n\n        // Adds additional phone numbers found in contact information\n        ContactNode n = (ContactNode)treeNode;\n        MetaContact metaContact = null;\n\n        if(n.getContactDescriptor().getDescriptor() instanceof MetaContact)\n        {\n            metaContact = (MetaContact)n.getContactDescriptor().getDescriptor();\n            Iterator<Contact> contacts = metaContact.getContacts();\n\n            while(contacts.hasNext())\n            {\n                Contact contact = contacts.next();\n                OperationSetServerStoredContactInfo infoOpSet =\n                    contact.getProtocolProvider().getOperationSet(\n                        OperationSetServerStoredContactInfo.class);\n                Iterator<GenericDetail> details = null;\n                ArrayList<String> phones = new ArrayList<String>();\n\n                if(infoOpSet != null)\n                {\n                    details = infoOpSet.getAllDetailsForContact(contact);\n\n                    while(details.hasNext())\n                    {\n                        GenericDetail d = details.next();\n                        if(d instanceof PhoneNumberDetail && \n                            !(d instanceof PagerDetail) && \n                            !(d instanceof FaxDetail))\n                        {\n                            PhoneNumberDetail pnd = (PhoneNumberDetail)d;\n                            if(pnd.getNumber() != null &&\n                                pnd.getNumber().length() > 0)\n                            {\n                                String localizedType = null;\n                                \n                                if(d instanceof WorkPhoneDetail)\n                                {\n                                    localizedType = \n                                        GuiActivator.getResources().\n                                            getI18NString(\n                                                \"service.gui.WORK_PHONE\");\n                                }\n                                else if(d instanceof MobilePhoneDetail)\n                                {\n                                    localizedType = \n                                        GuiActivator.getResources().\n                                            getI18NString(\n                                                \"service.gui.MOBILE_PHONE\");\n                                }\n                                else\n                                {\n                                    localizedType = \n                                        GuiActivator.getResources().\n                                            getI18NString(\n                                                \"service.gui.PHONE\");\n                                }\n                                    \n                                phones.add(pnd.getNumber());\n\n                                UIContactDetail cd =\n                                    new UIContactDetail(\n                                        pnd.getNumber(),\n                                        pnd.getNumber() + \n                                        \" (\" + localizedType + \")\",\n                                        null,\n                                        new ArrayList<String>(),\n                                        null,\n                                        null,\n                                        null)\n                                {\n                                    public PresenceStatus getPresenceStatus()\n                                    {\n                                        return null;\n                                    }\n                                };\n                                telephonyContacts.add(cd);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        ChooseCallAccountPopupMenu chooseAccountDialog = null;\n\n        if (telephonyContacts.size() == 1)\n        {\n            UIContactDetail detail = telephonyContacts.get(0);\n\n            ProtocolProviderService preferredProvider\n                = detail.getPreferredProtocolProvider(\n                    OperationSetBasicTelephony.class);\n\n            List<ProtocolProviderService> providers\n                = GuiActivator.getOpSetRegisteredProviders(\n                    OperationSetBasicTelephony.class,\n                    preferredProvider,\n                    detail.getPreferredProtocol(\n                        OperationSetBasicTelephony.class));\n\n            if (providers != null)\n            {\n                int providersCount = providers.size();\n\n                if (providersCount <= 0)\n                {\n                    new ErrorDialog(null,\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.CALL_FAILED\"),\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\"))\n                    .showDialog();\n                }\n                else if (providersCount == 1)\n                {\n                    CallManager.createCall(\n                        providers.get(0), detail.getAddress());\n                }\n                else if (providersCount > 1)\n                    chooseAccountDialog = new ChooseCallAccountPopupMenu(\n                            tree, detail.getAddress(), providers);\n            }\n        }\n        else if (telephonyContacts.size() > 1)\n        {\n            chooseAccountDialog\n                = new ChooseCallAccountPopupMenu(tree, telephonyContacts);\n        }\n\n        // If the choose dialog is created we're going to show it.\n        if (chooseAccountDialog != null)\n        {\n            Point location = new Point(callButton.getX(),\n                callButton.getY() + callButton.getHeight());\n\n            SwingUtilities.convertPointToScreen(location, tree);\n\n            location.y = location.y\n                + tree.getPathBounds(tree.getSelectionPath()).y;\n\n            chooseAccountDialog.showPopupMenu(location.x + 8, location.y - 8);\n        }\n    }","id":89265,"modified_method":"/**\n     * Calls the given treeNode.\n     * @param treeNode the <tt>TreeNode<\/tt> to call\n     */\n    private void call(TreeNode treeNode)\n    {\n        List<UIContactDetail> telephonyContacts\n            = ((ContactNode) treeNode).getContactDescriptor()\n                .getContactDetailsForOperationSet(\n                    OperationSetBasicTelephony.class);\n\n        telephonyContacts.addAll(getAdditionalNumbers());\n\n        ChooseCallAccountPopupMenu chooseAccountDialog = null;\n\n        if (telephonyContacts.size() == 1)\n        {\n            UIContactDetail detail = telephonyContacts.get(0);\n\n            ProtocolProviderService preferredProvider\n                = detail.getPreferredProtocolProvider(\n                    OperationSetBasicTelephony.class);\n\n            List<ProtocolProviderService> providers\n                = GuiActivator.getOpSetRegisteredProviders(\n                    OperationSetBasicTelephony.class,\n                    preferredProvider,\n                    detail.getPreferredProtocol(\n                        OperationSetBasicTelephony.class));\n\n            if (providers != null)\n            {\n                int providersCount = providers.size();\n\n                if (providersCount <= 0)\n                {\n                    new ErrorDialog(null,\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.CALL_FAILED\"),\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\"))\n                    .showDialog();\n                }\n                else if (providersCount == 1)\n                {\n                    CallManager.createCall(\n                        providers.get(0), detail.getAddress());\n                }\n                else if (providersCount > 1)\n                    chooseAccountDialog = new ChooseCallAccountPopupMenu(\n                            tree, detail.getAddress(), providers);\n            }\n        }\n        else if (telephonyContacts.size() > 1)\n        {\n            chooseAccountDialog\n                = new ChooseCallAccountPopupMenu(tree, telephonyContacts);\n        }\n\n        // If the choose dialog is created we're going to show it.\n        if (chooseAccountDialog != null)\n        {\n            Point location = new Point(callButton.getX(),\n                callButton.getY() + callButton.getHeight());\n\n            SwingUtilities.convertPointToScreen(location, tree);\n\n            location.y = location.y\n                + tree.getPathBounds(tree.getSelectionPath()).y;\n\n            chooseAccountDialog.showPopupMenu(location.x + 8, location.y - 8);\n        }\n    }","commit_id":"1ffcb1c2ddb5bf5859e9e4cc42c81b309951962e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes buttons panel.\n     * @param uiContact the <tt>UIContact<\/tt> for which we initialize the\n     * button panel\n     */\n    private void initButtonsPanel(UIContact uiContact)\n    {\n        this.remove(chatButton);\n        this.remove(callButton);\n        this.remove(callVideoButton);\n        this.remove(desktopSharingButton);\n        this.remove(addContactButton);\n\n        if (!isSelected)\n            return;\n\n        int statusMessageLabelHeight = 0;\n        if (displayDetailsLabel.getText().length() > 0)\n            statusMessageLabelHeight = 20;\n        else\n            statusMessageLabelHeight = 15;\n\n        UIContactDetail imContact = null;\n        // For now we support instance messaging only for contacts in our\n        // contact list until it's implemented for external source contacts.\n        if (uiContact.getDescriptor() instanceof MetaContact)\n            imContact = uiContact.getDefaultContactDetail(\n                         OperationSetBasicInstantMessaging.class);\n\n        int x = (statusIcon == null ? 0 : statusIcon.getIconWidth())\n                + (statusLabel == null ? 0 : statusLabel.getIconTextGap())\n                + LEFT_BORDER\n                + STATUS_RIGHT_BORDER;\n\n        if (imContact != null)\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 1;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.chatButton.setBorder(null);\n            this.add(chatButton, constraints);\n\n            chatButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight,\n                28, 28);\n\n            x += chatButton.getWidth();\n        }\n\n        UIContactDetail telephonyContact\n            = uiContact.getDefaultContactDetail(\n                OperationSetBasicTelephony.class);\n\n        // Check if contact has additional phone numbers, if yes show the\n        // call button\n        boolean hasPhone = false;\n\n        // check for phone stored in contact info only\n        // if telephony contact is missing\n        if(uiContact.getDescriptor() != null\n           && uiContact.getDescriptor() instanceof MetaContact\n           && telephonyContact == null)\n        {\n            MetaContact metaContact =\n                (MetaContact)uiContact.getDescriptor();\n            Iterator<Contact> contacts = metaContact.getContacts();\n\n            while(contacts.hasNext() && !hasPhone)\n            {\n                Contact contact = contacts.next();\n\n                if(!contact.getProtocolProvider().isRegistered())\n                    continue;\n\n                OperationSetServerStoredContactInfo infoOpSet =\n                    contact.getProtocolProvider().getOperationSet(\n                        OperationSetServerStoredContactInfo.class);\n                Iterator<GenericDetail> details;\n\n                if(infoOpSet != null)\n                {\n                    details = infoOpSet.requestAllDetailsForContact(\n                        contact,\n                        new DetailsListener(treeNode, callButton, uiContact));\n\n                    if(details != null)\n                    {\n                        while(details.hasNext())\n                        {\n                            GenericDetail d = details.next();\n                            if(d instanceof PhoneNumberDetail &&\n                                !(d instanceof PagerDetail) &&\n                                !(d instanceof FaxDetail))\n                            {\n                                PhoneNumberDetail pnd = (PhoneNumberDetail)d;\n                                if(pnd.getNumber() != null &&\n                                    pnd.getNumber().length() > 0)\n                                {\n                                    hasPhone = true;\n                                    break;\n                                }\n                             }\n                        }\n                    }\n                }\n            }\n        }\n\n        // for SourceContact in history that do not support telephony, we\n        // show the button but disabled\n        List<ProtocolProviderService> providers\n            = GuiActivator.getOpSetRegisteredProviders(\n                OperationSetBasicTelephony.class,\n                null,\n                null);\n\n        if ((telephonyContact != null && telephonyContact.getAddress() != null) ||\n            uiContact.getDescriptor() instanceof SourceContact ||\n            (hasPhone && providers.size() > 0))\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 2;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.callButton.setBorder(null);\n            this.add(callButton, constraints);\n\n            callButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n            callButton.setEnabled(telephonyContact != null || hasPhone);\n\n            x += callButton.getWidth();\n        }\n\n        UIContactDetail videoContact\n            = uiContact.getDefaultContactDetail(\n                OperationSetVideoTelephony.class);\n\n        if (videoContact != null)\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 3;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.callVideoButton.setBorder(null);\n            this.add(callVideoButton, constraints);\n\n            callVideoButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n\n            x += callVideoButton.getWidth();\n        }\n\n        UIContactDetail desktopContact\n            = uiContact.getDefaultContactDetail(\n                OperationSetDesktopSharingServer.class);\n\n        if (desktopContact != null)\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 4;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.desktopSharingButton.setBorder(null);\n            this.add(desktopSharingButton, constraints);\n\n            desktopSharingButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n\n            x += desktopSharingButton.getWidth();\n        }\n\n        if (uiContact.getDescriptor() instanceof SourceContact\n            && !ConfigurationManager.isAddContactDisabled())\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 5;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.addContactButton.setBorder(null);\n            this.add(addContactButton, constraints);\n\n            addContactButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n\n            x += addContactButton.getWidth();\n        }\n\n        this.setBounds(0, 0, tree.getWidth(), getPreferredSize().height);\n    }","id":89266,"modified_method":"/**\n     * Initializes buttons panel.\n     * @param uiContact the <tt>UIContact<\/tt> for which we initialize the\n     * button panel\n     */\n    private void initButtonsPanel(UIContact uiContact)\n    {\n        this.remove(chatButton);\n        this.remove(callButton);\n        this.remove(callVideoButton);\n        this.remove(desktopSharingButton);\n        this.remove(addContactButton);\n\n        if (!isSelected)\n            return;\n\n        int statusMessageLabelHeight = 0;\n        if (displayDetailsLabel.getText().length() > 0)\n            statusMessageLabelHeight = 20;\n        else\n            statusMessageLabelHeight = 15;\n\n        UIContactDetail imContact = null;\n        // For now we support instance messaging only for contacts in our\n        // contact list until it's implemented for external source contacts.\n        if (uiContact.getDescriptor() instanceof MetaContact)\n            imContact = uiContact.getDefaultContactDetail(\n                         OperationSetBasicInstantMessaging.class);\n\n        int x = (statusIcon == null ? 0 : statusIcon.getIconWidth())\n                + (statusLabel == null ? 0 : statusLabel.getIconTextGap())\n                + LEFT_BORDER\n                + STATUS_RIGHT_BORDER;\n\n        if (imContact != null)\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 1;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.chatButton.setBorder(null);\n            this.add(chatButton, constraints);\n\n            chatButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight,\n                28, 28);\n\n            x += chatButton.getWidth();\n        }\n\n        UIContactDetail telephonyContact\n            = uiContact.getDefaultContactDetail(\n                OperationSetBasicTelephony.class);\n\n        // Check if contact has additional phone numbers, if yes show the\n        // call button\n        boolean hasPhone = false;\n\n        // check for phone stored in contact info only\n        // if telephony contact is missing\n        if(uiContact.getDescriptor() != null\n           && uiContact.getDescriptor() instanceof MetaContact\n           && telephonyContact == null)\n        {\n            MetaContact metaContact =\n                (MetaContact)uiContact.getDescriptor();\n            Iterator<Contact> contacts = metaContact.getContacts();\n\n            while(contacts.hasNext() && !hasPhone)\n            {\n                Contact contact = contacts.next();\n\n                if(!contact.getProtocolProvider().isRegistered())\n                    continue;\n\n                OperationSetServerStoredContactInfo infoOpSet =\n                    contact.getProtocolProvider().getOperationSet(\n                        OperationSetServerStoredContactInfo.class);\n                Iterator<GenericDetail> details;\n\n                if(infoOpSet != null)\n                {\n                    details = infoOpSet.requestAllDetailsForContact(\n                        contact,\n                        new DetailsListener(treeNode, callButton, uiContact));\n\n                    if(details != null)\n                    {\n                        while(details.hasNext())\n                        {\n                            GenericDetail d = details.next();\n                            if(d instanceof PhoneNumberDetail &&\n                                !(d instanceof PagerDetail) &&\n                                !(d instanceof FaxDetail))\n                            {\n                                PhoneNumberDetail pnd = (PhoneNumberDetail)d;\n                                if(pnd.getNumber() != null &&\n                                    pnd.getNumber().length() > 0)\n                                {\n                                    hasPhone = true;\n                                    break;\n                                }\n                             }\n                        }\n                    }\n                }\n            }\n        }\n\n        // for SourceContact in history that do not support telephony, we\n        // show the button but disabled\n        List<ProtocolProviderService> providers\n            = GuiActivator.getOpSetRegisteredProviders(\n                OperationSetBasicTelephony.class,\n                null,\n                null);\n\n        if ((telephonyContact != null && telephonyContact.getAddress() != null) ||\n            uiContact.getDescriptor() instanceof SourceContact ||\n            (hasPhone && providers.size() > 0))\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 2;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.callButton.setBorder(null);\n            this.add(callButton, constraints);\n\n            callButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n            callButton.setEnabled(telephonyContact != null || hasPhone);\n\n            x += callButton.getWidth();\n        }\n\n        UIContactDetail videoContact\n            = uiContact.getDefaultContactDetail(\n                OperationSetVideoTelephony.class);\n\n        if (videoContact != null\n            || (ConfigurationManager\n                    .isRouteVideoAndDesktopUsingPhoneNumberEnabled()\n                    && hasPhone\n                    && GuiActivator.getOpSetRegisteredProviders(\n                                    OperationSetVideoTelephony.class,\n                                    null,\n                                    null).size() > 0))\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 3;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.callVideoButton.setBorder(null);\n            this.add(callVideoButton, constraints);\n\n            callVideoButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n\n            x += callVideoButton.getWidth();\n        }\n\n        UIContactDetail desktopContact\n            = uiContact.getDefaultContactDetail(\n                OperationSetDesktopSharingServer.class);\n\n        if (desktopContact != null\n            || (ConfigurationManager\n                    .isRouteVideoAndDesktopUsingPhoneNumberEnabled()\n                    && hasPhone\n                    && GuiActivator.getOpSetRegisteredProviders(\n                            OperationSetDesktopSharingServer.class,\n                            null,\n                            null).size() > 0))\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 4;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.desktopSharingButton.setBorder(null);\n            this.add(desktopSharingButton, constraints);\n\n            desktopSharingButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n\n            x += desktopSharingButton.getWidth();\n        }\n\n        if (uiContact.getDescriptor() instanceof SourceContact\n            && !ConfigurationManager.isAddContactDisabled())\n        {\n            constraints.anchor = GridBagConstraints.WEST;\n            constraints.fill = GridBagConstraints.NONE;\n            constraints.gridx = 5;\n            constraints.gridy = 2;\n            constraints.gridwidth = 1;\n            constraints.gridheight = 1;\n            constraints.weightx = 0f;\n            constraints.weighty = 0f;\n            this.addContactButton.setBorder(null);\n            this.add(addContactButton, constraints);\n\n            addContactButton.setBounds(x,\n                nameLabel.getHeight() + statusMessageLabelHeight, 28, 28);\n\n            x += addContactButton.getWidth();\n        }\n\n        this.setBounds(0, 0, tree.getWidth(), getPreferredSize().height);\n    }","commit_id":"1ffcb1c2ddb5bf5859e9e4cc42c81b309951962e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shares the user desktop with the contact contained in the given\n     * <tt>treeNode<\/tt>.\n     * @param treeNode the <tt>TreeNode<\/tt>, containing the contact to share\n     * the desktop with\n     */\n    private void shareDesktop(TreeNode treeNode)\n    {\n        List<UIContactDetail> desktopContacts\n            = ((ContactNode) treeNode).getContactDescriptor()\n                .getContactDetailsForOperationSet(\n                    OperationSetDesktopSharingServer.class);\n\n        ChooseCallAccountPopupMenu chooseAccountDialog = null;\n\n        if (desktopContacts.size() == 1)\n        {\n            UIContactDetail detail = desktopContacts.get(0);\n\n            ProtocolProviderService preferredProvider\n                = detail.getPreferredProtocolProvider(\n                    OperationSetDesktopSharingServer.class);\n\n            List<ProtocolProviderService> providers = null;\n            String protocolName = null;\n\n            if (preferredProvider != null)\n            {\n                if (preferredProvider.isRegistered())\n                    shareDesktop(preferredProvider, detail.getAddress());\n\n                // If we have a provider, but it's not registered we try to\n                // obtain all registered providers for the same protocol as the\n                // given preferred provider.\n                else\n                {\n                    protocolName = preferredProvider.getProtocolName();\n                    providers\n                        = GuiActivator.getRegisteredProviders(protocolName,\n                            OperationSetDesktopSharingServer.class);\n                }\n            }\n            // If we don't have a preferred provider we try to obtain a\n            // preferred protocol name and all registered providers for it.\n            else\n            {\n                protocolName = detail.getPreferredProtocol(\n                        OperationSetDesktopSharingServer.class);\n\n                if (protocolName != null)\n                    providers\n                        = GuiActivator.getRegisteredProviders(protocolName,\n                            OperationSetDesktopSharingServer.class);\n                else\n                    providers\n                        = GuiActivator.getRegisteredProviders(\n                            OperationSetDesktopSharingServer.class);\n            }\n\n            // If our call didn't succeed, try to call through one of the other\n            // protocol providers obtained above.\n            if (providers != null)\n            {\n                int providersCount = providers.size();\n\n                if (providersCount <= 0)\n                {\n                    new ErrorDialog(null,\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.CALL_FAILED\"),\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\",\n                            new String[]{protocolName}))\n                    .showDialog();\n                }\n                else if (providersCount == 1)\n                {\n                    shareDesktop(providers.get(0), detail.getAddress());\n                }\n                else if (providersCount > 1)\n                    chooseAccountDialog = new ChooseCallAccountPopupMenu(\n                            tree, detail.getAddress(), providers,\n                            OperationSetDesktopSharingServer.class);\n            }\n        }\n        else if (desktopContacts.size() > 1)\n        {\n            chooseAccountDialog\n                = new ChooseCallAccountPopupMenu(tree, desktopContacts,\n                    OperationSetDesktopSharingServer.class);\n        }\n\n        // If the choose dialog is created we're going to show it.\n        if (chooseAccountDialog != null)\n        {\n            Point location = new Point(desktopSharingButton.getX(),\n                desktopSharingButton.getY() + desktopSharingButton.getHeight());\n\n            SwingUtilities.convertPointToScreen(location, tree);\n\n            location.y = location.y\n                + tree.getPathBounds(tree.getSelectionPath()).y;\n\n            chooseAccountDialog.showPopupMenu(location.x + 8, location.y - 8);\n        }\n    }","id":89267,"modified_method":"/**\n     * Shares the user desktop with the contact contained in the given\n     * <tt>treeNode<\/tt>.\n     * @param treeNode the <tt>TreeNode<\/tt>, containing the contact to share\n     * the desktop with\n     */\n    private void shareDesktop(TreeNode treeNode)\n    {\n        List<UIContactDetail> desktopContacts\n            = ((ContactNode) treeNode).getContactDescriptor()\n                .getContactDetailsForOperationSet(\n                    OperationSetDesktopSharingServer.class);\n\n        if(ConfigurationManager.isRouteVideoAndDesktopUsingPhoneNumberEnabled())\n            desktopContacts.addAll(getAdditionalNumbers());\n\n        ChooseCallAccountPopupMenu chooseAccountDialog = null;\n\n        if (desktopContacts.size() == 1)\n        {\n            UIContactDetail detail = desktopContacts.get(0);\n\n            ProtocolProviderService preferredProvider\n                = detail.getPreferredProtocolProvider(\n                    OperationSetDesktopSharingServer.class);\n\n            List<ProtocolProviderService> providers = null;\n            String protocolName = null;\n\n            if (preferredProvider != null)\n            {\n                if (preferredProvider.isRegistered())\n                    shareDesktop(preferredProvider, detail.getAddress());\n\n                // If we have a provider, but it's not registered we try to\n                // obtain all registered providers for the same protocol as the\n                // given preferred provider.\n                else\n                {\n                    protocolName = preferredProvider.getProtocolName();\n                    providers\n                        = GuiActivator.getRegisteredProviders(protocolName,\n                            OperationSetDesktopSharingServer.class);\n                }\n            }\n            // If we don't have a preferred provider we try to obtain a\n            // preferred protocol name and all registered providers for it.\n            else\n            {\n                protocolName = detail.getPreferredProtocol(\n                        OperationSetDesktopSharingServer.class);\n\n                if (protocolName != null)\n                    providers\n                        = GuiActivator.getRegisteredProviders(protocolName,\n                            OperationSetDesktopSharingServer.class);\n                else\n                    providers\n                        = GuiActivator.getRegisteredProviders(\n                            OperationSetDesktopSharingServer.class);\n            }\n\n            // If our call didn't succeed, try to call through one of the other\n            // protocol providers obtained above.\n            if (providers != null)\n            {\n                int providersCount = providers.size();\n\n                if (providersCount <= 0)\n                {\n                    new ErrorDialog(null,\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.CALL_FAILED\"),\n                        GuiActivator.getResources().getI18NString(\n                            \"service.gui.NO_ONLINE_TELEPHONY_ACCOUNT\",\n                            new String[]{protocolName}))\n                    .showDialog();\n                }\n                else if (providersCount == 1)\n                {\n                    shareDesktop(providers.get(0), detail.getAddress());\n                }\n                else if (providersCount > 1)\n                    chooseAccountDialog = new ChooseCallAccountPopupMenu(\n                            tree, detail.getAddress(), providers,\n                            OperationSetDesktopSharingServer.class);\n            }\n        }\n        else if (desktopContacts.size() > 1)\n        {\n            chooseAccountDialog\n                = new ChooseCallAccountPopupMenu(tree, desktopContacts,\n                    OperationSetDesktopSharingServer.class);\n        }\n\n        // If the choose dialog is created we're going to show it.\n        if (chooseAccountDialog != null)\n        {\n            Point location = new Point(desktopSharingButton.getX(),\n                desktopSharingButton.getY() + desktopSharingButton.getHeight());\n\n            SwingUtilities.convertPointToScreen(location, tree);\n\n            location.y = location.y\n                + tree.getPathBounds(tree.getSelectionPath()).y;\n\n            chooseAccountDialog.showPopupMenu(location.x + 8, location.y - 8);\n        }\n    }","commit_id":"1ffcb1c2ddb5bf5859e9e4cc42c81b309951962e","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public void stop(BundleContext bc) throws Exception\n    {\n        // Unregister transformation layer.\n        // start listening for newly register or removed protocol providers\n        bundleContext.removeServiceListener(this);\n        bundleContext.removeServiceListener(scOtrEngine);\n        bundleContext.removeServiceListener(otrContactManager);\n\n        ServiceReference[] protocolProviderRefs;\n        try\n        {\n            protocolProviderRefs =\n                bundleContext.getServiceReferences(\n                    ProtocolProviderService.class.getName(), null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // this shouldn't happen since we're providing no parameter string\n            // but let's log just in case.\n            logger.error(\"Error while retrieving service refs\", ex);\n            return;\n        }\n\n        if (protocolProviderRefs != null && protocolProviderRefs.length > 0)\n        {\n            // in case we found any\n            for (ServiceReference protocolProviderRef : protocolProviderRefs)\n            {\n                ProtocolProviderService provider =\n                    (ProtocolProviderService) bundleContext\n                        .getService(protocolProviderRef);\n\n                this.handleProviderRemoved(provider);\n            }\n        }\n    }","id":89268,"modified_method":"@Override\n    public void stop(BundleContext bc) throws Exception\n    {\n        // Unregister transformation layer.\n        // start listening for newly register or removed protocol providers\n        bundleContext.removeServiceListener(this);\n\n        if(scOtrEngine != null)\n            bundleContext.removeServiceListener(scOtrEngine);\n\n        if(otrContactManager != null)\n            bundleContext.removeServiceListener(otrContactManager);\n\n        ServiceReference[] protocolProviderRefs;\n        try\n        {\n            protocolProviderRefs =\n                bundleContext.getServiceReferences(\n                    ProtocolProviderService.class.getName(), null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // this shouldn't happen since we're providing no parameter string\n            // but let's log just in case.\n            logger.error(\"Error while retrieving service refs\", ex);\n            return;\n        }\n\n        if (protocolProviderRefs != null && protocolProviderRefs.length > 0)\n        {\n            // in case we found any\n            for (ServiceReference protocolProviderRef : protocolProviderRefs)\n            {\n                ProtocolProviderService provider =\n                    (ProtocolProviderService) bundleContext\n                        .getService(protocolProviderRef);\n\n                this.handleProviderRemoved(provider);\n            }\n        }\n    }","commit_id":"256b6673f8e33ac400a07c021223c497cf849fb5","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            \n            if ( StringUtils.isEmpty( encoding ) && isFilteringEnabled( getResources() ) )\n            {\n                getLog().warn(\n                               \"File encoding has not been set, using platform encoding \" + ReaderFactory.FILE_ENCODING\n                                   + \", i.e. build is platform dependent!\" );\n            }\n            \n\n            MavenResourcesExecution mavenResourcesExecution = new MavenResourcesExecution( getResources(), \n                                                                                           getOutputDirectory(),\n                                                                                           project, encoding, filters,\n                                                                                           Collections.EMPTY_LIST,\n                                                                                           session );\n            \n            List filterWrappers = mavenFileFilter.getDefaultFilterWrappers( project, filters, escapeWindowsPaths,\n                                                                            session, mavenResourcesExecution, null );\n            \n            mavenResourcesExecution.setFilterWrappers( filterWrappers );\n            mavenResourcesExecution.setUseDefaultFilterWrappers( false );\n            \n            mavenResourcesExecution.setEscapeString( escapeString );\n            mavenResourcesExecution.setOverwrite( overwrite );\n            mavenResourcesExecution.setIncludeEmptyDirs( includeEmptyDirs );\n            if ( nonFilteredFileExtensions != null )\n            {\n                mavenResourcesExecution.setNonFilteredFileExtensions( nonFilteredFileExtensions );\n            }\n            mavenResourcesFiltering.filterResources( mavenResourcesExecution );\n        }\n        catch ( MavenFilteringException e )\n        {\n            throw new MojoExecutionException( e.getMessage(), e );\n        }\n    }","id":89269,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            \n            if ( StringUtils.isEmpty( encoding ) && isFilteringEnabled( getResources() ) )\n            {\n                getLog().warn(\n                               \"File encoding has not been set, using platform encoding \" + ReaderFactory.FILE_ENCODING\n                                   + \", i.e. build is platform dependent!\" );\n            }\n            \n            List filters = getFilters();\n\n            MavenResourcesExecution mavenResourcesExecution = new MavenResourcesExecution( getResources(), \n                                                                                           getOutputDirectory(),\n                                                                                           project, encoding, filters,\n                                                                                           Collections.EMPTY_LIST,\n                                                                                           session );\n            \n            List filterWrappers = mavenFileFilter.getDefaultFilterWrappers( project, filters, escapeWindowsPaths,\n                                                                            session, mavenResourcesExecution, null );\n            \n            mavenResourcesExecution.setFilterWrappers( filterWrappers );\n            mavenResourcesExecution.setUseDefaultFilterWrappers( false );\n            \n            mavenResourcesExecution.setEscapeString( escapeString );\n            mavenResourcesExecution.setOverwrite( overwrite );\n            mavenResourcesExecution.setIncludeEmptyDirs( includeEmptyDirs );\n            if ( nonFilteredFileExtensions != null )\n            {\n                mavenResourcesExecution.setNonFilteredFileExtensions( nonFilteredFileExtensions );\n            }\n            mavenResourcesFiltering.filterResources( mavenResourcesExecution );\n        }\n        catch ( MavenFilteringException e )\n        {\n            throw new MojoExecutionException( e.getMessage(), e );\n        }\n    }","commit_id":"9968c04a1c85ecfe0d3e4e36995b1ca96bdf6eec","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @throws Exception\n     */\n    public void testProjectProperty_Filtering_PropertyDestination()\n        throws Exception\n    {\n        File testPom = new File( getBasedir(), defaultPomFilePath );\n        ResourcesMojo mojo = (ResourcesMojo) lookupMojo( \"resources\", testPom );\n        MavenProjectResourcesStub project = new MavenProjectResourcesStub(\n                                                                           \"resourcePojectProperty_Filtering_PropertyDestination\" );\n        List resources = project.getBuild().getResources();\n\n        assertNotNull( mojo );\n\n        project.addFile( \"file4.properties\", \"current working directory=${description}\" );\n        project.setResourceFiltering( 0, true );\n        project.setupBuildEnvironment();\n\n        // setup dummy property\n        project.setDescription( \"c:\\\\\\\\org\\\\apache\\\\test\" );\n\n        // setVariableValueToObject(mojo,\"encoding\",\"UTF-8\");\n        setVariableValueToObject( mojo, \"project\", project );\n        setVariableValueToObject( mojo, \"resources\", resources );\n        setVariableValueToObject( mojo, \"outputDirectory\", new File( project.getBuild().getOutputDirectory() ) );\n        setVariableValueToObject( mojo, \"filters\", new LinkedList() );\n        mojo.execute();\n\n        String resourcesDir = project.getOutputDirectory();\n        String checkString = \"current working directory=c:\\\\\\\\\\\\\\\\org\\\\\\\\apache\\\\\\\\test\";\n\n        assertContent( resourcesDir + \"/file4.properties\", checkString );\n    }","id":89270,"modified_method":"/**\n     * @throws Exception\n     */\n    public void testProjectProperty_Filtering_PropertyDestination()\n        throws Exception\n    {\n        File testPom = new File( getBasedir(), defaultPomFilePath );\n        ResourcesMojo mojo = (ResourcesMojo) lookupMojo( \"resources\", testPom );\n        MavenProjectResourcesStub project = new MavenProjectResourcesStub(\n                                                                           \"resourcePojectProperty_Filtering_PropertyDestination\" );\n        List resources = project.getBuild().getResources();\n\n        assertNotNull( mojo );\n\n        project.addFile( \"file4.properties\", \"current working directory=${description}\" );\n        project.setResourceFiltering( 0, true );\n        project.setupBuildEnvironment();\n\n        // setup dummy property\n        project.setDescription( \"c:\\\\\\\\org\\\\apache\\\\test\" );\n\n        // setVariableValueToObject(mojo,\"encoding\",\"UTF-8\");\n        setVariableValueToObject( mojo, \"project\", project );\n        setVariableValueToObject( mojo, \"resources\", resources );\n        setVariableValueToObject( mojo, \"outputDirectory\", new File( project.getBuild().getOutputDirectory() ) );\n        setVariableValueToObject( mojo, \"filters\", new LinkedList() );\n        setVariableValueToObject( mojo, \"escapeWindowsPaths\", Boolean.TRUE );\n        mojo.execute();\n\n        String resourcesDir = project.getOutputDirectory();\n        String checkString = \"current working directory=c:\\\\\\\\\\\\\\\\org\\\\\\\\apache\\\\\\\\test\";\n\n        assertContent( resourcesDir + \"/file4.properties\", checkString );\n    }","commit_id":"9968c04a1c85ecfe0d3e4e36995b1ca96bdf6eec","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testWindowsPathEscapingEnabled()\n        throws Exception\n    {\n        File testPom = new File( getBasedir(), defaultPomFilePath );\n        ResourcesMojo mojo = (ResourcesMojo) lookupMojo( \"resources\", testPom );\n        MavenProjectResourcesStub project = new MavenProjectResourcesStub( \"windows-paths\" );\n        List resources = project.getBuild().getResources();\n\n        assertNotNull( mojo );\n\n        project.getProperties().setProperty( \"basePath\", \"C:\\\\Users\\\\Administrator\" );\n        project.getProperties().setProperty( \"docsPath\", \"${basePath}\\\\Documents\" );\n\n        project.addFile( \"path-listing.txt\", \"base path is ${basePath}\\ndocuments path is ${docsPath}\" );\n        project.setResourceFiltering( 0, true );\n\n        project.cleanBuildEnvironment();\n        project.setupBuildEnvironment();\n\n        setVariableValueToObject( mojo, \"project\", project );\n        setVariableValueToObject( mojo, \"resources\", resources );\n        setVariableValueToObject( mojo, \"outputDirectory\", new File( project.getBuild().getOutputDirectory() ) );\n        setVariableValueToObject( mojo, \"filters\", new LinkedList() );\n\n        MavenFileFilter mff = null;\n        try\n        {\n            mff = (MavenFileFilter) lookup( MavenFileFilter.class.getName(), \"default\" );\n            setVariableValueToObject( mojo, \"mavenFileFilter\", mff );\n\n            setVariableValueToObject( mojo, \"escapeWindowsPaths\", Boolean.TRUE );\n\n            mojo.execute();\n        }\n        finally\n        {\n            if ( mff != null )\n            {\n                try\n                {\n                    release( mff );\n                }\n                catch ( Exception e )\n                {\n                }\n            }\n        }\n\n        String resourcesDir = project.getOutputDirectory();\n\n        assertTrue( FileUtils.fileExists( new File( resourcesDir, \"path-listing.txt\" ).getAbsolutePath() ) );\n\n        // FIXME See http://jira.codehaus.org/browse/MSHARED-121\n//        assertEquals( \"base path is C:\\\\\\\\Users\\\\\\\\Administrator\\ndocuments path is C:\\\\\\\\Users\\\\\\\\Administrator\\\\\\\\Documents\",\n//                      FileUtils.fileRead( new File( resourcesDir, \"path-listing.txt\" ) ) );\n        \n        assertEquals( \"base path is C:\\\\\\\\Users\\\\\\\\Administrator\\ndocuments path is C:\\\\\\\\Users\\\\\\\\Administrator\\\\Documents\",\n                      FileUtils.fileRead( new File( resourcesDir, \"path-listing.txt\" ) ) );\n    }","id":89271,"modified_method":"public void testWindowsPathEscapingEnabled()\n        throws Exception\n    {\n        File testPom = new File( getBasedir(), defaultPomFilePath );\n        ResourcesMojo mojo = (ResourcesMojo) lookupMojo( \"resources\", testPom );\n        MavenProjectResourcesStub project = new MavenProjectResourcesStub( \"windows-paths\" );\n        List resources = project.getBuild().getResources();\n\n        assertNotNull( mojo );\n\n        project.getProperties().setProperty( \"basePath\", \"C:\\\\Users\\\\Administrator\" );\n        project.getProperties().setProperty( \"docsPath\", \"${basePath}\\\\Documents\" );\n\n        project.addFile( \"path-listing.txt\", \"base path is ${basePath}\\ndocuments path is ${docsPath}\" );\n        project.setResourceFiltering( 0, true );\n\n        project.cleanBuildEnvironment();\n        project.setupBuildEnvironment();\n\n        setVariableValueToObject( mojo, \"project\", project );\n        setVariableValueToObject( mojo, \"resources\", resources );\n        setVariableValueToObject( mojo, \"outputDirectory\", new File( project.getBuild().getOutputDirectory() ) );\n        setVariableValueToObject( mojo, \"filters\", new LinkedList() );\n\n        setVariableValueToObject( mojo, \"escapeWindowsPaths\", Boolean.TRUE );\n\n        mojo.execute();\n\n        String resourcesDir = project.getOutputDirectory();\n\n        assertTrue( FileUtils.fileExists( new File( resourcesDir, \"path-listing.txt\" ).getAbsolutePath() ) );\n\n        // FIXME See http://jira.codehaus.org/browse/MSHARED-121\n//        assertEquals( \"base path is C:\\\\\\\\Users\\\\\\\\Administrator\\ndocuments path is C:\\\\\\\\Users\\\\\\\\Administrator\\\\\\\\Documents\",\n//                      FileUtils.fileRead( new File( resourcesDir, \"path-listing.txt\" ) ) );\n        \n        assertEquals( \"base path is C:\\\\\\\\Users\\\\\\\\Administrator\\ndocuments path is C:\\\\\\\\Users\\\\\\\\Administrator\\\\Documents\",\n                      FileUtils.fileRead( new File( resourcesDir, \"path-listing.txt\" ) ) );\n    }","commit_id":"9968c04a1c85ecfe0d3e4e36995b1ca96bdf6eec","url":"https://github.com/apache/maven-plugins"},{"original_method":"public EditorCell createConstantCell4(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89272,"modified_method":"public EditorCell createConstantCell4(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89273,"modified_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89274,"modified_method":"public EditorCell createConstantCell3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparator3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89275,"modified_method":"public EditorCell createSeparator3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRootableCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"rootable\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setSubstituteInfo(new BooleanPropertySubstituteInfo(node, \"rootable\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"rootable\"));\n    return editorCell;\n  }","id":89276,"modified_method":"public EditorCell createRootableCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"rootable\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setSubstituteInfo(new BooleanPropertySubstituteInfo(node, \"rootable\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"rootable\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparator2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89277,"modified_method":"public EditorCell createSeparator2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createPropertyDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myPropertyDeclarationListHandler == null) {\n      this.myPropertyDeclarationListHandler = new ConceptDeclaration_Editor_PropertyDeclarationListHandler(node, \"propertyDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myPropertyDeclarationListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    return editorCell;\n  }","id":89278,"modified_method":"public EditorCell createPropertyDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myPropertyDeclarationListHandler == null) {\n      this.myPropertyDeclarationListHandler = new ConceptDeclaration_Editor_PropertyDeclarationListHandler(node, \"propertyDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myPropertyDeclarationListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparator(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89279,"modified_method":"public EditorCell createSeparator(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89280,"modified_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"Extends:\"));\n    editorCell.addEditorCell(this.createExtendsReferenceCell(context, node));\n    return editorCell;\n  }","id":89281,"modified_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createIndent(context, node, \"    \"));\n    editorCell.addEditorCell(this.createContentArea(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89282,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createLinkDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myLinkDeclarationListHandler == null) {\n      this.myLinkDeclarationListHandler = new ConceptDeclaration_Editor_LinkDeclarationListHandler(node, \"linkDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myLinkDeclarationListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    return editorCell;\n  }","id":89283,"modified_method":"public EditorCell createLinkDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myLinkDeclarationListHandler == null) {\n      this.myLinkDeclarationListHandler = new ConceptDeclaration_Editor_LinkDeclarationListHandler(node, \"linkDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myLinkDeclarationListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    editorCell.addEditorCell(this.createSeparator(context, node, \"\"));\n    editorCell.addEditorCell(this.createRowCell(context, node));\n    editorCell.addEditorCell(this.createSeparator1(context, node, \"\"));\n    editorCell.addEditorCell(this.createRowCell1(context, node));\n    editorCell.addEditorCell(this.createSeparator2(context, node, \"\"));\n    editorCell.addEditorCell(this.createConstantCell3(context, node, \"Links:\"));\n    editorCell.addEditorCell(this.createLinkDeclarationList(context, node));\n    editorCell.addEditorCell(this.createSeparator3(context, node, \"\"));\n    editorCell.addEditorCell(this.createConstantCell4(context, node, \"Properties:\"));\n    editorCell.addEditorCell(this.createPropertyDeclarationList(context, node));\n    return editorCell;\n  }","id":89284,"modified_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    editorCell.addEditorCell(this.createSeparator(context, node, \"\"));\n    editorCell.addEditorCell(this.createRowCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createExtendsReferenceCell(EditorContext context, SemanticNode node) {\n    SemanticNode effectiveNode = null;\n    effectiveNode = node.getReferent(\"extends\");\n    LinkDeclaration linkDeclaration = SModelUtil.getLinkDeclaration(node, \"extends\");\n    if(effectiveNode == null) {\n      {\n        EditorCell_Constant noRefCell = EditorCell_Constant.create(context, node, null, true);\n        noRefCell.setDefaultText(\"<none>\");\n        noRefCell.setEditable(true);\n        noRefCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n        noRefCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n        noRefCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n        noRefCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n        return noRefCell;\n      }\n    }\n    AbstractCellProvider inlineComponent = new ConceptDeclaration_Editor_extends_InlineComponent(effectiveNode);\n    EditorCell editorCell = inlineComponent.createEditorCell(context);\n    EditorUtil.setSemanticNodeToCells(editorCell, node);\n    editorCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n    editorCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteReferenceToNode(node, \"extends\", effectiveNode));\n    editorCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n    return editorCell;\n  }","id":89285,"modified_method":"public EditorCell createExtendsReferenceCell(EditorContext context, SemanticNode node) {\n    SemanticNode effectiveNode = null;\n    effectiveNode = node.getReferent(\"extends\");\n    LinkDeclaration linkDeclaration = SModelUtil.getLinkDeclaration(node, \"extends\");\n    if(effectiveNode == null) {\n      {\n        EditorCell_Constant noRefCell = EditorCell_Constant.create(context, node, null, true);\n        noRefCell.setDefaultText(\"<none>\");\n        noRefCell.setEditable(true);\n        noRefCell.setDrawBrackets(false);\n        noRefCell.setBracketsColor(Color.black);\n        noRefCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n        noRefCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n        noRefCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n        noRefCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n        return noRefCell;\n      }\n    }\n    AbstractCellProvider inlineComponent = new ConceptDeclaration_Editor_extends_InlineComponent(effectiveNode);\n    EditorCell editorCell = inlineComponent.createEditorCell(context);\n    EditorUtil.setSemanticNodeToCells(editorCell, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n    editorCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteReferenceToNode(node, \"extends\", effectiveNode));\n    editorCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","id":89286,"modified_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparator1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89287,"modified_method":"public EditorCell createSeparator1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Concept Declaration\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","id":89288,"modified_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"concept declaration\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell1(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \"Is Root:\"));\n    editorCell.addEditorCell(this.createRootableCell(context, node));\n    return editorCell;\n  }","id":89289,"modified_method":"public EditorCell createRowCell1(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"extends:\"));\n    editorCell.addEditorCell(this.createExtendsReferenceCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89290,"modified_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    editorCell.addEditorCell(this.createRowCell(context, node));\n    editorCell.addEditorCell(this.createSeparator(context, node, \"  \"));\n    editorCell.addEditorCell(this.createRowCell1(context, node));\n    return editorCell;\n  }","id":89291,"modified_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    editorCell.addEditorCell(this.createRowCell(context, node));\n    editorCell.addEditorCell(this.createSeparator(context, node, \"  \"));\n    editorCell.addEditorCell(this.createRowCell1(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSimpleDataType_ExtendedDataTypeNameCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_SimpleDataType_ExtendedDataTypeName(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<none>\");\n    ConstrainedDataTypeDeclaration_ExtendsCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89292,"modified_method":"public EditorCell createSimpleDataType_ExtendedDataTypeNameCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_SimpleDataType_ExtendedDataTypeName(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<none>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    ConstrainedDataTypeDeclaration_ExtendsCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"    extends:\"));\n    editorCell.addEditorCell(this.createSimpleDataType_ExtendedDataTypeNameCell(context, node));\n    return editorCell;\n  }","id":89293,"modified_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"    extends:\"));\n    editorCell.addEditorCell(this.createSimpleDataType_ExtendedDataTypeNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89294,"modified_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstraintCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"constraint\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"constraint\"));\n    return editorCell;\n  }","id":89295,"modified_method":"public EditorCell createConstraintCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"constraint\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"constraint\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Simple Data Type\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","id":89296,"modified_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Simple Data Type\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","id":89297,"modified_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell1(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \"    constraint:\"));\n    editorCell.addEditorCell(this.createConstraintCell(context, node));\n    return editorCell;\n  }","id":89298,"modified_method":"public EditorCell createRowCell1(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \"    constraint:\"));\n    editorCell.addEditorCell(this.createConstraintCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89299,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSeparator(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89300,"modified_method":"public EditorCell createSeparator(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    editorCell.addEditorCell(this.createColumnCell(context, node));\n    editorCell.addEditorCell(this.createRowCell3(context, node));\n    return editorCell;\n  }","id":89301,"modified_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    editorCell.addEditorCell(this.createColumnCell(context, node));\n    editorCell.addEditorCell(this.createRowCell3(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell3(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createIndent3(context, node, \"        \"));\n    editorCell.addEditorCell(this.createMemberList(context, node));\n    return editorCell;\n  }","id":89302,"modified_method":"public EditorCell createRowCell3(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createIndent3(context, node, \"        \"));\n    editorCell.addEditorCell(this.createMemberList(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createEnumDataType_MemberDataTypeNameCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_EnumDataType_MemberDataTypeName(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no data type>\");\n    EnumerationDataTypeDeclaration_MemberDataTypeActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89303,"modified_method":"public EditorCell createEnumDataType_MemberDataTypeNameCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_EnumDataType_MemberDataTypeName(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no data type>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    EnumerationDataTypeDeclaration_MemberDataTypeActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","id":89304,"modified_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell2(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createIndent2(context, node, \"    \"));\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \"members:\"));\n    return editorCell;\n  }","id":89305,"modified_method":"public EditorCell createRowCell2(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createIndent2(context, node, \"    \"));\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \"members:\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createColumnCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(true);\n    editorCell.addEditorCell(this.createRowCell(context, node));\n    editorCell.addEditorCell(this.createRowCell1(context, node));\n    editorCell.addEditorCell(this.createRowCell2(context, node));\n    return editorCell;\n  }","id":89306,"modified_method":"public EditorCell createColumnCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createRowCell(context, node));\n    editorCell.addEditorCell(this.createRowCell1(context, node));\n    editorCell.addEditorCell(this.createRowCell2(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createIndent(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89307,"modified_method":"public EditorCell createIndent(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Enumeration Data Type\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","id":89308,"modified_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Enumeration Data Type\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89309,"modified_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createIndent(context, node, \"    \"));\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"member type:\"));\n    editorCell.addEditorCell(this.createEnumDataType_MemberDataTypeNameCell(context, node));\n    return editorCell;\n  }","id":89310,"modified_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createIndent(context, node, \"    \"));\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"member type:\"));\n    editorCell.addEditorCell(this.createEnumDataType_MemberDataTypeNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89311,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createIndent3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89312,"modified_method":"public EditorCell createIndent3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89313,"modified_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createIndent2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89314,"modified_method":"public EditorCell createIndent2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createIndent1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89315,"modified_method":"public EditorCell createIndent1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createMemberList(EditorContext context, SemanticNode node) {\n    if(this.myMemberListHandler == null) {\n      this.myMemberListHandler = new EnumerationDataTypeDeclaration_Editor_MemberListHandler(node, \"member\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myMemberListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    return editorCell;\n  }","id":89316,"modified_method":"public EditorCell createMemberList(EditorContext context, SemanticNode node) {\n    if(this.myMemberListHandler == null) {\n      this.myMemberListHandler = new EnumerationDataTypeDeclaration_Editor_MemberListHandler(node, \"member\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myMemberListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell1(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createIndent1(context, node, \"    \"));\n    return editorCell;\n  }","id":89317,"modified_method":"public EditorCell createRowCell1(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createIndent1(context, node, \"    \"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createInternalValueCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"internalValue\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"NULL\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"internalValue\"));\n    return editorCell;\n  }","id":89318,"modified_method":"public EditorCell createInternalValueCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"internalValue\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"NULL\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"internalValue\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89319,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89320,"modified_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell4(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89321,"modified_method":"public EditorCell createConstantCell4(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createEnumMember_IsDefaultCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_EnumMember_IsDefault(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    EnumerationMemberDeclaration_IsDefaultActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89322,"modified_method":"public EditorCell createEnumMember_IsDefaultCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_EnumMember_IsDefault(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    EnumerationMemberDeclaration_IsDefaultActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","id":89323,"modified_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"constant:\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"(\"));\n    editorCell.addEditorCell(this.createExternalValueCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \",\"));\n    editorCell.addEditorCell(this.createInternalValueCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell3(context, node, \")\"));\n    editorCell.addEditorCell(this.createConstantCell4(context, node, \"default:\"));\n    editorCell.addEditorCell(this.createEnumMember_IsDefaultCell(context, node));\n    return editorCell;\n  }","id":89324,"modified_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"constant:\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"(\"));\n    editorCell.addEditorCell(this.createExternalValueCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell2(context, node, \",\"));\n    editorCell.addEditorCell(this.createInternalValueCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell3(context, node, \")\"));\n    editorCell.addEditorCell(this.createConstantCell4(context, node, \"default:\"));\n    editorCell.addEditorCell(this.createEnumMember_IsDefaultCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createExternalValueCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"externalValue\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no external value>\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"externalValue\"));\n    return editorCell;\n  }","id":89325,"modified_method":"public EditorCell createExternalValueCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"externalValue\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no external value>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"externalValue\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89326,"modified_method":"public EditorCell createConstantCell3(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89327,"modified_method":"public EditorCell createConstantCell2(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89328,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createLinkDeclaration_SpecializedSourceCardinalityCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedSourceCardinality(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.lightGray);\n    LinkDeclaration_DisableDelete_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89329,"modified_method":"public EditorCell createLinkDeclaration_SpecializedSourceCardinalityCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedSourceCardinality(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.lightGray);\n    LinkDeclaration_DisableDelete_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89330,"modified_method":"public EditorCell createConstantCell1(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createLinkDeclaration_SpecializedTargetCardinalityCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedTargetCardinality(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.lightGray);\n    LinkDeclaration_DisableDelete_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89331,"modified_method":"public EditorCell createLinkDeclaration_SpecializedTargetCardinalityCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedTargetCardinality(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.lightGray);\n    LinkDeclaration_DisableDelete_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createLinkDeclaration_SpecializedMetaclassCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedMetaclass(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.lightGray);\n    LinkDeclaration_DisableDelete_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89332,"modified_method":"public EditorCell createLinkDeclaration_SpecializedMetaclassCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedMetaclass(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.lightGray);\n    LinkDeclaration_DisableDelete_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createTargetReferenceCell(EditorContext context, SemanticNode node) {\n    SemanticNode effectiveNode = null;\n    effectiveNode = node.getReferent(\"target\");\n    LinkDeclaration linkDeclaration = SModelUtil.getLinkDeclaration(node, \"target\");\n    if(effectiveNode == null) {\n      {\n        EditorCell_Error noRefCell = EditorCell_Error.create(context, node, \"<no target>\");\n        noRefCell.setEditable(true);\n        noRefCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n        noRefCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n        noRefCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n        noRefCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n        return noRefCell;\n      }\n    }\n    AbstractCellProvider inlineComponent = new LinkDeclaration_Editor_target_InlineComponent(effectiveNode);\n    EditorCell editorCell = inlineComponent.createEditorCell(context);\n    EditorUtil.setSemanticNodeToCells(editorCell, node);\n    editorCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n    editorCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n    editorCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n    return editorCell;\n  }","id":89333,"modified_method":"public EditorCell createTargetReferenceCell(EditorContext context, SemanticNode node) {\n    SemanticNode effectiveNode = null;\n    effectiveNode = node.getReferent(\"target\");\n    LinkDeclaration linkDeclaration = SModelUtil.getLinkDeclaration(node, \"target\");\n    if(effectiveNode == null) {\n      {\n        EditorCell_Error noRefCell = EditorCell_Error.create(context, node, \"<no target>\");\n        noRefCell.setEditable(true);\n        noRefCell.setDrawBrackets(false);\n        noRefCell.setBracketsColor(Color.black);\n        noRefCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n        noRefCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n        noRefCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n        noRefCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n        return noRefCell;\n      }\n    }\n    AbstractCellProvider inlineComponent = new LinkDeclaration_Editor_target_InlineComponent(effectiveNode);\n    EditorCell editorCell = inlineComponent.createEditorCell(context);\n    EditorUtil.setSemanticNodeToCells(editorCell, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.putUserObject(EditorCell.METAINFO_LINK_DECLARATION, linkDeclaration);\n    editorCell.putUserObject(EditorCell.METAINFO_SOURCE_NODE, node);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n    editorCell.setSubstituteInfo(new DefaultReferenceSubstituteInfo(node, linkDeclaration));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createRoleCell(context, node));\n    if(Aspects.semanticNodeCondition_LinkDeclaration_NotSpecializes(node)) {\n      editorCell.addEditorCell(this.createMetaClassCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_NotSpecializes(node)) {\n      editorCell.addEditorCell(this.createSourceCardinalityCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_NotSpecializes(node)) {\n      editorCell.addEditorCell(this.createTargetCardinalityCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_Specializes(node)) {\n      editorCell.addEditorCell(this.createLinkDeclaration_SpecializedMetaclassCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_Specializes(node)) {\n      editorCell.addEditorCell(this.createLinkDeclaration_SpecializedSourceCardinalityCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_Specializes(node)) {\n      editorCell.addEditorCell(this.createLinkDeclaration_SpecializedTargetCardinalityCell(context, node));\n    }\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"target:\"));\n    editorCell.addEditorCell(this.createTargetReferenceCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"specializes:\"));\n    editorCell.addEditorCell(this.createLinkDeclaration_SpecializedLinkRoleCell(context, node));\n    return editorCell;\n  }","id":89334,"modified_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createRoleCell(context, node));\n    if(Aspects.semanticNodeCondition_LinkDeclaration_NotSpecializes(node)) {\n      editorCell.addEditorCell(this.createMetaClassCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_NotSpecializes(node)) {\n      editorCell.addEditorCell(this.createSourceCardinalityCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_NotSpecializes(node)) {\n      editorCell.addEditorCell(this.createTargetCardinalityCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_Specializes(node)) {\n      editorCell.addEditorCell(this.createLinkDeclaration_SpecializedMetaclassCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_Specializes(node)) {\n      editorCell.addEditorCell(this.createLinkDeclaration_SpecializedSourceCardinalityCell(context, node));\n    }\n    if(Aspects.semanticNodeCondition_LinkDeclaration_Specializes(node)) {\n      editorCell.addEditorCell(this.createLinkDeclaration_SpecializedTargetCardinalityCell(context, node));\n    }\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"target:\"));\n    editorCell.addEditorCell(this.createTargetReferenceCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell1(context, node, \"specializes:\"));\n    editorCell.addEditorCell(this.createLinkDeclaration_SpecializedLinkRoleCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createLinkDeclaration_SpecializedLinkRoleCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedLinkRole(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<none>\");\n    LinkDeclaration_SpecializedLink_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89335,"modified_method":"public EditorCell createLinkDeclaration_SpecializedLinkRoleCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_LinkDeclaration_SpecializedLinkRole(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<none>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    LinkDeclaration_SpecializedLink_Actions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createMetaClassCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"metaClass\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setSubstituteInfo(new LinkMetaclass_PropertySubstituteInfo(node, \"metaClass\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"metaClass\"));\n    return editorCell;\n  }","id":89336,"modified_method":"public EditorCell createMetaClassCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"metaClass\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setSubstituteInfo(new LinkMetaclass_PropertySubstituteInfo(node, \"metaClass\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"metaClass\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createTargetCardinalityCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"targetCardinality\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setSubstituteInfo(new Cardinality_PropertySubstituteInfo(node, \"targetCardinality\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"targetCardinality\"));\n    return editorCell;\n  }","id":89337,"modified_method":"public EditorCell createTargetCardinalityCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"targetCardinality\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setSubstituteInfo(new Cardinality_PropertySubstituteInfo(node, \"targetCardinality\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"targetCardinality\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createSourceCardinalityCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"sourceCardinality\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setSubstituteInfo(new Cardinality_PropertySubstituteInfo(node, \"sourceCardinality\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"sourceCardinality\"));\n    return editorCell;\n  }","id":89338,"modified_method":"public EditorCell createSourceCardinalityCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"sourceCardinality\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setSubstituteInfo(new Cardinality_PropertySubstituteInfo(node, \"sourceCardinality\"));\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"sourceCardinality\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRoleCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"role\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"role\"));\n    return editorCell;\n  }","id":89339,"modified_method":"public EditorCell createRoleCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"role\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"role\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Primitive Data Type\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","id":89340,"modified_method":"public EditorCell createHeaderRow(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createConstantCell(context, node, \"Primitive Data Type\"));\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","id":89341,"modified_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.getTextLine().setTextBackgroundColor(Color.yellow);\n    editorCell.getTextLine().setSelectedTextBackgroundColor(Color.cyan);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    return editorCell;\n  }","id":89342,"modified_method":"public EditorCell createNodeBox(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createVertical(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createHeaderRow(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89343,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createPropertyDeclaration_DataTypeNameCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_PropertyDeclaration_DataTypeName(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no data type>\");\n    PropertyDeclaration_DataTypeActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89344,"modified_method":"public EditorCell createPropertyDeclaration_DataTypeNameCell(EditorContext context, SemanticNode node) {\n    ModelAccessor modelAccessor = Aspects.createModelAccessor_PropertyDeclaration_DataTypeName(node);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, modelAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no data type>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    PropertyDeclaration_DataTypeActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","id":89345,"modified_method":"public EditorCell createNameCell(EditorContext context, SemanticNode node) {\n    PropertyAccessor propertyAccessor = new PropertyAccessor(node, \"name\", false, false);\n    EditorCell_Property editorCell = EditorCell_Property.create(context, propertyAccessor, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(true);\n    editorCell.setDefaultText(\"<no name>\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_DeleteProperty(node, \"name\"));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell(context, node, \":\"));\n    editorCell.addEditorCell(this.createPropertyDeclaration_DataTypeNameCell(context, node));\n    return editorCell;\n  }","id":89346,"modified_method":"public EditorCell createRowCell(EditorContext context, SemanticNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.addEditorCell(this.createNameCell(context, node));\n    editorCell.addEditorCell(this.createConstantCell(context, node, \":\"));\n    editorCell.addEditorCell(this.createPropertyDeclaration_DataTypeNameCell(context, node));\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":89347,"modified_method":"public EditorCell createConstantCell(EditorContext context, SemanticNode node, String text) {\n    EditorCell_Constant editorCell = EditorCell_Constant.create(context, node, text, false);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setEditable(false);\n    editorCell.setDefaultText(\"\");\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bca5a5d73528d9501b9795729a60bcb0ed1feab7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int countByRolesPermissions(\n\t\t\tList<Permission> permissions, List<Role> roles)\n\t\tthrows SystemException {\n\n\t\tObject finderArgs[] = new Object[] {\n\t\t\tListUtil.toString(permissions, \"permissionId\"),\n\t\t\tListUtil.toString(roles, \"roleId\")\n\t\t};\n\n\t\tObject result = FinderCacheUtil.getResult(\n\t\t\tFINDER_PATH_COUNT_BY_ROLES_PERMISSIONS, finderArgs, this);\n\n\t\tif (result == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tString sql = CustomSQLUtil.get(COUNT_BY_ROLES_PERMISSIONS);\n\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$PERMISSION_IDS$]\",\n\t\t\t\t\tgetPermissionIds(permissions, \"Roles_Permissions\"));\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$ROLE_IDS$]\",\n\t\t\t\t\tgetRoleIds(roles, \"Roles_Permissions\"));\n\n\t\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\t\tq.addScalar(COUNT_COLUMN_NAME, Type.LONG);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tsetPermissionIds(qPos, permissions);\n\t\t\t\tsetRoleIds(qPos, roles);\n\n\t\t\t\tint count = 0;\n\n\t\t\t\tIterator<Long> itr = q.list().iterator();\n\n\t\t\t\tif (itr.hasNext()) {\n\t\t\t\t\tLong l = itr.next();\n\n\t\t\t\t\tif (l != null) {\n\t\t\t\t\t\tcount = l.intValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(\n\t\t\t\t\tFINDER_PATH_COUNT_BY_ROLES_PERMISSIONS, finderArgs,\n\t\t\t\t\tnew Long(count));\n\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn ((Long)result).intValue();\n\t\t}\n\t}","id":89348,"modified_method":"public int countByRolesPermissions(\n\t\t\tList<Permission> permissions, List<Role> roles)\n\t\tthrows SystemException {\n\n\t\tObject finderArgs[] = new Object[] {\n\t\t\tListUtil.toString(permissions, \"permissionId\"),\n\t\t\tListUtil.toString(roles, \"roleId\")\n\t\t};\n\n\t\tLong count = (Long)FinderCacheUtil.getResult(\n\t\t\tFINDER_PATH_COUNT_BY_ROLES_PERMISSIONS, finderArgs, this);\n\n\t\tif (count == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tString sql = CustomSQLUtil.get(COUNT_BY_ROLES_PERMISSIONS);\n\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$PERMISSION_IDS$]\",\n\t\t\t\t\tgetPermissionIds(permissions, \"Roles_Permissions\"));\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$ROLE_IDS$]\",\n\t\t\t\t\tgetRoleIds(roles, \"Roles_Permissions\"));\n\n\t\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\t\tq.addScalar(COUNT_COLUMN_NAME, Type.LONG);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tsetPermissionIds(qPos, permissions);\n\t\t\t\tsetRoleIds(qPos, roles);\n\n\t\t\t\tcount = (Long)q.uniqueResult();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (count == null) {\n\t\t\t\t\tcount = Long.valueOf(0);\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(\n\t\t\t\t\tFINDER_PATH_COUNT_BY_ROLES_PERMISSIONS, finderArgs, count);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn count.intValue();\n\t}","commit_id":"ab3194c8ab396105eda61caba5e42ac6df5f13f7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<Permission> findByA_R(String actionId, long[] resourceIds)\n\t\tthrows SystemException {\n\n\t\tObject finderArgs[] = new Object[] {\n\t\t\tactionId, StringUtil.merge(ArrayUtil.toArray(resourceIds))\n\t\t};\n\n\t\tObject result = FinderCacheUtil.getResult(\n\t\t\tFINDER_PATH_FIND_BY_A_R, finderArgs, this);\n\n\t\tif (result == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tString sql = CustomSQLUtil.get(FIND_BY_A_R);\n\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$RESOURCE_IDS$]\", getResourceIds(resourceIds));\n\n\t\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\t\tq.addEntity(\"Permission_\", PermissionImpl.class);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(actionId);\n\t\t\t\tsetResourceIds(qPos, resourceIds);\n\n\t\t\t\tList<Permission> permissions = q.list();\n\n\t\t\t\tFinderCacheUtil.putResult(\n\t\t\t\t\tFINDER_PATH_FIND_BY_A_R, finderArgs, permissions);\n\n\t\t\t\treturn permissions;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (List<Permission>)result;\n\t\t}\n\t}","id":89349,"modified_method":"public List<Permission> findByA_R(String actionId, long[] resourceIds)\n\t\tthrows SystemException {\n\n\t\tObject finderArgs[] = new Object[] {\n\t\t\tactionId, StringUtil.merge(ArrayUtil.toArray(resourceIds))\n\t\t};\n\n\t\tList<Permission> list = (List<Permission>)FinderCacheUtil.getResult(\n\t\t\tFINDER_PATH_FIND_BY_A_R, finderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tString sql = CustomSQLUtil.get(FIND_BY_A_R);\n\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$RESOURCE_IDS$]\", getResourceIds(resourceIds));\n\n\t\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\t\tq.addEntity(\"Permission_\", PermissionImpl.class);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(actionId);\n\t\t\t\tsetResourceIds(qPos, resourceIds);\n\n\t\t\t\tlist = q.list();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<Permission>();\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(\n\t\t\t\t\tFINDER_PATH_FIND_BY_A_R, finderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"ab3194c8ab396105eda61caba5e42ac6df5f13f7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * <h3>Advanced<\/h3>\n   * Get a list of all available captures as a String array. i.e.\n   * println(Capture.list()) will show you the goodies.\n   * \n   * @param sourceName String\n   */\n  static public String[] list(String sourceName) {\n    return list(sourceName, devicePropertyName);\n  }","id":89350,"modified_method":"/**\n   * <h3>Advanced<\/h3>\n   * Get a list of all available captures as a String array. i.e.\n   * println(Capture.list()) will show you the goodies.\n   * \n   * @param sourceName String\n   */\n  static public String[] list(String sourceName) {\n    String[] res;\n    try {\n      res = list(sourceName, devicePropertyName);\n    } catch (IllegalArgumentException e) {      \n      if (PApplet.platform == LINUX) {\n        // Linux hack to detect currently connected cameras\n        // by looking for device files named /dev/video0, \n        // /dev/video1, etc.\n        ArrayList<String> devices = new ArrayList<String>();\n        String dir = \"/dev\";\n        File libPath = new File(dir);\n        String[] files = libPath.list();\n        if (files != null) {\n          for (int i = 0; i < files.length; i++) {\n            if (-1 < files[i].indexOf(\"video\")) {\n              devices.add(\"/dev/\" + files[i]);\n            }\n          }\n        }\n        res = new String[devices.size()];\n        for (int i = 0; i < res.length; i++) {\n          res[i] = (String)devices.get(i);\n        }\n      } else {      \n        System.err.println(\"The capture plugin doesn't support device query!\");\n        res = new String[0];\n      }\n    }\n    return res;\n  }","commit_id":"375f3781efe6f7ca9d7051be7000efa9697f9064","url":"https://github.com/processing/processing"},{"original_method":"public List<RatingsEntry> findByU_C_C(\n\t\t\tlong userId, long classNameId, List<Long> classPKs)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_U_C_C);\n\n\t\t\tsql = StringUtil.replace(\n\t\t\t\tsql, \"[$CLASS_PKS$]\", StringUtil.merge(classPKs));\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addEntity(\"RatingsEntry\", RatingsEntryImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(userId);\n\t\t\tqPos.add(classNameId);\n\n\t\t\treturn q.list();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":89351,"modified_method":"public List<RatingsEntry> findByU_C_C(\n\t\t\tlong userId, long classNameId, List<Long> classPKs)\n\t\tthrows SystemException {\n\n\t\tObject[] finderArgs = new Object[] {\n\t\t\tuserId, classNameId,\n\t\t\tStringUtil.merge(classPKs.toArray(new Long[classPKs.size()]))\n\t\t};\n\n\t\tList<RatingsEntry> list = (List<RatingsEntry>)FinderCacheUtil.getResult(\n\t\t\tFINDER_PATH_FIND_BY_U_C_C, finderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tString sql = CustomSQLUtil.get(FIND_BY_U_C_C);\n\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$CLASS_PKS$]\", StringUtil.merge(classPKs));\n\n\t\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\t\tq.addEntity(\"RatingsEntry\", RatingsEntryImpl.class);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(userId);\n\t\t\t\tqPos.add(classNameId);\n\n\t\t\t\tlist = q.list();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<RatingsEntry>();\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(\n\t\t\t\t\tFINDER_PATH_FIND_BY_U_C_C, finderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"fa3648816037822633c2052617052a3c7c50effb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<RatingsStats> findByC_C(long classNameId, List<Long> classPKs)\n\t\tthrows SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_C_C);\n\n\t\t\tsql = StringUtil.replace(\n\t\t\t\tsql, \"[$CLASS_PKS$]\", StringUtil.merge(classPKs));\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addEntity(\"RatingsStats\", RatingsStatsImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(classNameId);\n\n\t\t\treturn q.list();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":89352,"modified_method":"public List<RatingsStats> findByC_C(long classNameId, List<Long> classPKs)\n\t\tthrows SystemException {\n\n\t\tObject[] finderArgs = new Object[] {\n\t\t\tclassNameId,\n\t\t\tStringUtil.merge(classPKs.toArray(new Long[classPKs.size()]))\n\t\t};\n\n\t\tList<RatingsStats> list = (List<RatingsStats>)FinderCacheUtil.getResult(\n\t\t\tFINDER_PATH_FIND_BY_C_C, finderArgs, this);\n\n\t\tif (list == null) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = openSession();\n\n\t\t\t\tString sql = CustomSQLUtil.get(FIND_BY_C_C);\n\n\t\t\t\tsql = StringUtil.replace(\n\t\t\t\t\tsql, \"[$CLASS_PKS$]\", StringUtil.merge(classPKs));\n\n\t\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\t\tq.addEntity(\"RatingsStats\", RatingsStatsImpl.class);\n\n\t\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\t\tqPos.add(classNameId);\n\n\t\t\t\tlist = q.list();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (list == null) {\n\t\t\t\t\tlist = new ArrayList<RatingsStats>();\n\t\t\t\t}\n\n\t\t\t\tFinderCacheUtil.putResult(\n\t\t\t\t\tFINDER_PATH_FIND_BY_C_C, finderArgs, list);\n\n\t\t\t\tcloseSession(session);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"fa3648816037822633c2052617052a3c7c50effb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n        TestSuite suite = new TestSuite();\n        final TestSuite checkerSuite = JetTestCaseBuilder.suiteForDirectory(PluginTestCaseBase.getTestDataPathBase(), \"/checker/\", false, new JetTestCaseBuilder.NamedTestFactory() {\n            @NotNull\n            @Override\n            public Test createTest(@NotNull String dataPath, @NotNull String name) {\n                return new JetPsiCheckerTest(dataPath, name);\n            }\n        });\n        if (checkerSuite.countTestCases() == 0) {\n            throw new RuntimeException(\"didn't find any testcases under /checker/\");\n        }\n        suite.addTest(checkerSuite);\n        suite.addTest(JetTestCaseBuilder.suiteForDirectory(PluginTestCaseBase.getTestDataPathBase(), \"/checker/regression/\", false, new JetTestCaseBuilder.NamedTestFactory() {\n            @NotNull\n            @Override\n            public Test createTest(@NotNull String dataPath, @NotNull String name) {\n                return new JetPsiCheckerTest(dataPath, name);\n            }\n        }));\n        suite.addTest(JetTestCaseBuilder.suiteForDirectory(PluginTestCaseBase.getTestDataPathBase(), \"/checker/infos/\", false, new JetTestCaseBuilder.NamedTestFactory() {\n            @NotNull\n            @Override\n            public Test createTest(@NotNull String dataPath, @NotNull String name) {\n                return new JetPsiCheckerTest(dataPath, name).setCheckInfos(true);\n            }\n        }));\n        return suite;\n    }","id":89353,"modified_method":"public static Test suite() {\n        TestSuite suite = new TestSuite();\n        JetTestCaseBuilder.appendTestsInDirectory(PluginTestCaseBase.getTestDataPathBase(), \"/checker/\", false, JetTestCaseBuilder.emptyFilter, new JetTestCaseBuilder.NamedTestFactory() {\n            @NotNull\n            @Override\n            public Test createTest(@NotNull String dataPath, @NotNull String name) {\n                return new JetPsiCheckerTest(dataPath, name);\n            }\n        }, suite);\n        JetTestCaseBuilder.appendTestsInDirectory(PluginTestCaseBase.getTestDataPathBase(), \"/checker/regression/\", false, JetTestCaseBuilder.emptyFilter, new JetTestCaseBuilder.NamedTestFactory() {\n            @NotNull\n            @Override\n            public Test createTest(@NotNull String dataPath, @NotNull String name) {\n                return new JetPsiCheckerTest(dataPath, name);\n            }\n        }, suite);\n        JetTestCaseBuilder.appendTestsInDirectory(PluginTestCaseBase.getTestDataPathBase(), \"/checker/infos/\", false, JetTestCaseBuilder.emptyFilter, new JetTestCaseBuilder.NamedTestFactory() {\n            @NotNull\n            @Override\n            public Test createTest(@NotNull String dataPath, @NotNull String name) {\n                return new JetPsiCheckerTest(dataPath, name).setCheckInfos(true);\n            }\n        }, suite);\n        return suite;\n    }","commit_id":"2f191d3c43a6c3ec43574c0e71fd076b2adc9de9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static TestSuite suiteForDirectory(String baseDataDir, @NotNull final String dataPath, boolean recursive, final FilenameFilter filter, @NotNull NamedTestFactory factory) {\n        TestSuite suite = new TestSuite(dataPath);\n        final String extensionJet = \".jet\";\n        final String extensionKt = \".kt\";\n        final FilenameFilter extensionFilter = new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return name.endsWith(extensionJet) || name.endsWith(extensionKt);\n            }\n        };\n        FilenameFilter resultFilter;\n        if (filter != emptyFilter) {\n            resultFilter = new FilenameFilter() {\n                @Override\n                public boolean accept(File file, String s) {\n                    return extensionFilter.accept(file, s) && filter.accept(file, s);\n                }\n            };\n        }\n        else {\n            resultFilter = extensionFilter;\n        }\n        File dir = new File(baseDataDir + dataPath);\n        FileFilter dirFilter = new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n                return pathname.isDirectory();\n            }\n        };\n        if (recursive) {\n            File[] files = dir.listFiles(dirFilter);\n            assert files != null : dir;\n            List<File> subdirs = Arrays.asList(files);\n            Collections.sort(subdirs);\n            for (File subdir : subdirs) {\n                suite.addTest(suiteForDirectory(baseDataDir, dataPath + \"/\" + subdir.getName(), recursive, filter, factory));\n            }\n        }\n        List<File> files = Arrays.asList(dir.listFiles(resultFilter));\n        Collections.sort(files);\n        for (File file : files) {\n            String fileName = file.getName();\n            assert fileName != null;\n            String extension = fileName.endsWith(extensionJet) ? extensionJet : extensionKt;\n            suite.addTest(factory.createTest(dataPath, fileName.substring(0, fileName.length() - extension.length())));\n        }\n        return suite;\n    }","id":89354,"modified_method":"@NotNull\n    public static TestSuite suiteForDirectory(String baseDataDir, @NotNull final String dataPath, boolean recursive, final FilenameFilter filter, @NotNull NamedTestFactory factory) {\n        TestSuite suite = new TestSuite(dataPath);\n        appendTestsInDirectory(baseDataDir, dataPath, recursive, filter, factory, suite);\n        return suite;\n    }","commit_id":"2f191d3c43a6c3ec43574c0e71fd076b2adc9de9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        nameValidator.validate(operation);\n        final String attributeName = operation.require(NAME).asString();\n        // Don't require VALUE. Let the validator decide if it's bothered by an undefined value\n        final ModelNode newValue = operation.hasDefined(VALUE) ? operation.get(VALUE) : new ModelNode();\n        validateUnresolvedValue(attributeName, newValue);\n        final ModelNode submodel = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n        final ModelNode currentValue = submodel.get(attributeName).clone();\n\n        final AttributeDefinition attributeDefinition = getAttributeDefinition(attributeName);\n        if (attributeDefinition != null) {\n            final ModelNode syntheticOp = new ModelNode();\n            syntheticOp.get(attributeName).set(newValue);\n            attributeDefinition.validateAndSet(syntheticOp, submodel);\n        } else {\n            submodel.get(attributeName).set(newValue);\n        }\n\n        if (requiresRuntime(context)) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    ModelNode resolvedValue = attributeDefinition != null ? attributeDefinition.resolveModelAttribute(context, submodel) : newValue.resolve();\n                    validateResolvedValue(attributeName, newValue);\n                    HandbackHolder<T> handback = new HandbackHolder<T>();\n                    boolean restartRequired = applyUpdateToRuntime(context, operation, attributeName, resolvedValue, currentValue, handback);\n                    if (restartRequired) {\n                        context.reloadRequired();\n                    }\n\n                    if (context.completeStep() != OperationContext.ResultAction.KEEP) {\n                        ModelNode valueToRestore = currentValue.resolve();\n                        try {\n                            revertUpdateToRuntime(context, operation, attributeName, valueToRestore, resolvedValue, handback.handback);\n                        } catch (Exception e) {\n                            MGMT_OP_LOGGER.errorRevertingOperation(e, getClass().getSimpleName(),\n                                    operation.require(ModelDescriptionConstants.OP).asString(),\n                                    PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n                        }\n                        if (restartRequired) {\n                            context.revertReloadRequired();\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n\n        context.completeStep();\n    }","id":89355,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        nameValidator.validate(operation);\n        final String attributeName = operation.require(NAME).asString();\n        // Don't require VALUE. Let the validator decide if it's bothered by an undefined value\n        final ModelNode newValue = operation.hasDefined(VALUE) ? operation.get(VALUE) : new ModelNode();\n        validateUnresolvedValue(attributeName, newValue);\n        final Resource resource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n        final ModelNode submodel = resource.getModel();\n        final ModelNode currentValue = submodel.get(attributeName).clone();\n\n        final AttributeDefinition attributeDefinition = getAttributeDefinition(attributeName);\n        if (attributeDefinition != null) {\n            final ModelNode syntheticOp = new ModelNode();\n            syntheticOp.get(attributeName).set(newValue);\n            attributeDefinition.validateAndSet(syntheticOp, submodel);\n        } else {\n            submodel.get(attributeName).set(newValue);\n        }\n\n        validateUpdatedModel(context, resource);\n\n        if (requiresRuntime(context)) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    ModelNode resolvedValue = attributeDefinition != null ? attributeDefinition.resolveModelAttribute(context, submodel) : newValue.resolve();\n                    validateResolvedValue(attributeName, newValue);\n                    HandbackHolder<T> handback = new HandbackHolder<T>();\n                    boolean restartRequired = applyUpdateToRuntime(context, operation, attributeName, resolvedValue, currentValue, handback);\n                    if (restartRequired) {\n                        context.reloadRequired();\n                    }\n\n                    if (context.completeStep() != OperationContext.ResultAction.KEEP) {\n                        ModelNode valueToRestore = currentValue.resolve();\n                        try {\n                            revertUpdateToRuntime(context, operation, attributeName, valueToRestore, resolvedValue, handback.handback);\n                        } catch (Exception e) {\n                            MGMT_OP_LOGGER.errorRevertingOperation(e, getClass().getSimpleName(),\n                                    operation.require(ModelDescriptionConstants.OP).asString(),\n                                    PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n                        }\n                        if (restartRequired) {\n                            context.revertReloadRequired();\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n\n        context.completeStep();\n    }","commit_id":"60b860d2433e89ae554e0b3f35ddbdfdefd704ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean requiresRuntime(OperationContext context) {\n        return true;\n    }","id":89356,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void populateModel(final OperationContext context, final ModelNode operation, final Resource resource) throws OperationFailedException {\n\n        ModelNode model = resource.getModel();\n        populateModel(operation, model);\n\n        SocketBindingGroupResourceDefinition.PORT_OFFSET.validateAndSet(operation, model);\n\n        SocketBindingGroupResourceDefinition.validateDefaultInterfaceReference(context, model);\n    }","commit_id":"60b860d2433e89ae554e0b3f35ddbdfdefd704ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        super.registerAttributes(resourceRegistration);\n\n        resourceRegistration.registerReadOnlyAttribute(NAME, null);\n        resourceRegistration.registerReadWriteAttribute(DEFAULT_INTERFACE, null, new ReloadRequiredWriteAttributeHandler(DEFAULT_INTERFACE));\n\n        if (forDomainModel) {\n            /* This will be reintroduced for 7.2.0, leave commented out\n            resourceRegistration.registerReadWriteAttribute(INCLUDES, null, new WriteAttributeHandlers.AttributeDefinitionValidatingHandler(INCLUDES));\n            */\n        } else {\n            resourceRegistration.registerReadWriteAttribute(PORT_OFFSET, null, new ReloadRequiredWriteAttributeHandler(PORT_OFFSET));\n        }\n    }","id":89357,"modified_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n        super.registerAttributes(resourceRegistration);\n\n        resourceRegistration.registerReadOnlyAttribute(NAME, null);\n        resourceRegistration.registerReadWriteAttribute(DEFAULT_INTERFACE, null, new ReloadRequiredWriteAttributeHandler(DEFAULT_INTERFACE) {\n            protected void validateUpdatedModel(final OperationContext context, final Resource model) throws OperationFailedException {\n                if (!forDomainModel) {\n                    validateDefaultInterfaceReference(context, model.getModel());\n                }\n            }\n        });\n\n        if (forDomainModel) {\n            /* This will be reintroduced for 7.2.0, leave commented out\n            resourceRegistration.registerReadWriteAttribute(INCLUDES, null, new WriteAttributeHandlers.AttributeDefinitionValidatingHandler(INCLUDES));\n            */\n        } else {\n            resourceRegistration.registerReadWriteAttribute(PORT_OFFSET, null, new ReloadRequiredWriteAttributeHandler(PORT_OFFSET));\n        }\n    }","commit_id":"60b860d2433e89ae554e0b3f35ddbdfdefd704ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void performRuntime(final OperationContext context, final ModelNode operation, final Resource resource, final ModelNode model,\n                                final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ModelNode address = operation.require(OP_ADDR);\n        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n        final String jndiName = model.get(JNDI_NAME.getName()).asString();\n        boolean jta = JTA.resolveModelAttribute(context, operation).asBoolean();\n        final boolean statsEnabled = STATISTICS_ENABLED.resolveModelAttribute(context, operation).asBoolean();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n\n        ModelNode node = DATASOURCE_DRIVER.resolveModelAttribute(context, model);\n\n        final String driverName = node.asString();\n        final ServiceName driverServiceName = ServiceName.JBOSS.append(\"jdbc-driver\", driverName.replaceAll(\"\\\\.\", \"_\"));\n\n\n        ValueInjectionService driverDemanderService = new ValueInjectionService<Driver>();\n\n        final ServiceName driverDemanderServiceName = ServiceName.JBOSS.append(\"driver-demander\").append(jndiName);\n                final ServiceBuilder<?> driverDemanderBuilder = serviceTarget\n                        .addService(driverDemanderServiceName, driverDemanderService)\n                        .addDependency(driverServiceName, Driver.class,\n                                driverDemanderService.getInjector());\n        driverDemanderBuilder.addListener(verificationHandler);\n        driverDemanderBuilder.setInitialMode(ServiceController.Mode.ACTIVE);\n\n        AbstractDataSourceService dataSourceService = createDataSourceService(dsName);\n\n        final ManagementResourceRegistration registration = context.getResourceRegistrationForUpdate();\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> dataSourceServiceBuilder =\n                Services.addServerExecutorDependency(\n                        serviceTarget.addService(dataSourceServiceName, dataSourceService),\n                        dataSourceService.getExecutorServiceInjector(), false)\n                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                        dataSourceService.getManagementRepositoryInjector())\n                .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                        dataSourceService.getSubjectFactoryInjector())\n                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,\n                        dataSourceService.getDriverRegistryInjector())\n                .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                .addDependency(NamingService.SERVICE_NAME);\n        if (jta) {\n            dataSourceServiceBuilder.addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class, dataSourceService.getTransactionIntegrationInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, dataSourceService.getCcmInjector());\n\n        }\n        //Register an empty override model regardless of we're enabled or not - the statistics listener will add the relevant childresources\n        ManagementResourceRegistration overrideRegistration = registration.isAllowsOverride() ? registration.registerOverrideModel(dsName, DataSourcesSubsystemProviders.OVERRIDE_DS_DESC) : registration;\n        dataSourceServiceBuilder.addListener(new DataSourceStatisticsListener(overrideRegistration, resource, dsName, statsEnabled));\n        dataSourceServiceBuilder.addListener(verificationHandler);\n        startConfigAndAddDependency(dataSourceServiceBuilder, dataSourceService, dsName, serviceTarget, operation, verificationHandler);\n\n        dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                    dataSourceService.getDriverInjector());\n\n        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.NEVER);\n\n        controllers.add(dataSourceServiceBuilder.install());\n        controllers.add(driverDemanderBuilder.install());\n\n    }","id":89358,"modified_method":"private void performRuntime(final OperationContext context, final ModelNode operation, final Resource resource, final ModelNode model,\n                                final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ModelNode address = operation.require(OP_ADDR);\n        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n        final String jndiName = model.get(JNDI_NAME.getName()).asString();\n        boolean jta = JTA.resolveModelAttribute(context, operation).asBoolean();\n        final boolean statsEnabled = STATISTICS_ENABLED.resolveModelAttribute(context, model).asBoolean();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n\n        ModelNode node = DATASOURCE_DRIVER.resolveModelAttribute(context, model);\n\n        final String driverName = node.asString();\n        final ServiceName driverServiceName = ServiceName.JBOSS.append(\"jdbc-driver\", driverName.replaceAll(\"\\\\.\", \"_\"));\n\n\n        ValueInjectionService driverDemanderService = new ValueInjectionService<Driver>();\n\n        final ServiceName driverDemanderServiceName = ServiceName.JBOSS.append(\"driver-demander\").append(jndiName);\n                final ServiceBuilder<?> driverDemanderBuilder = serviceTarget\n                        .addService(driverDemanderServiceName, driverDemanderService)\n                        .addDependency(driverServiceName, Driver.class,\n                                driverDemanderService.getInjector());\n        driverDemanderBuilder.addListener(verificationHandler);\n        driverDemanderBuilder.setInitialMode(ServiceController.Mode.ACTIVE);\n\n        AbstractDataSourceService dataSourceService = createDataSourceService(dsName);\n\n        final ManagementResourceRegistration registration = context.getResourceRegistrationForUpdate();\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> dataSourceServiceBuilder =\n                Services.addServerExecutorDependency(\n                        serviceTarget.addService(dataSourceServiceName, dataSourceService),\n                        dataSourceService.getExecutorServiceInjector(), false)\n                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                        dataSourceService.getManagementRepositoryInjector())\n                .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                        dataSourceService.getSubjectFactoryInjector())\n                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,\n                        dataSourceService.getDriverRegistryInjector())\n                .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                .addDependency(NamingService.SERVICE_NAME);\n        if (jta) {\n            dataSourceServiceBuilder.addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class, dataSourceService.getTransactionIntegrationInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, dataSourceService.getCcmInjector());\n\n        }\n        //Register an empty override model regardless of we're enabled or not - the statistics listener will add the relevant childresources\n        if (registration.isAllowsOverride()) {\n            registration.registerOverrideModel(dsName, DataSourcesSubsystemProviders.OVERRIDE_DS_DESC);\n        }\n        dataSourceServiceBuilder.addListener(verificationHandler);\n        startConfigAndAddDependency(dataSourceServiceBuilder, dataSourceService, dsName, serviceTarget, operation, verificationHandler);\n\n        dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                    dataSourceService.getDriverInjector());\n\n        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.NEVER);\n\n        controllers.add(dataSourceServiceBuilder.install());\n        controllers.add(driverDemanderBuilder.install());\n\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void reEnable(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        if (context.isNormalServer()) {\n            PathAddress addr = PathAddress.pathAddress(operation.get(OP_ADDR));\n            Resource resource = context.getOriginalRootResource();\n            for (PathElement element : addr) {\n                resource = resource.getChild(element);\n            }\n            DataSourceEnable.addServices(context, operation, null, Resource.Tools.readModel(resource), isXa(), new LinkedList<ServiceController<?>>());\n        }\n    }","id":89359,"modified_method":"private void reEnable(final OperationContext context, final ModelNode operation, final ManagementResourceRegistration datasourceRegistration) throws OperationFailedException {\n        if (context.isNormalServer()) {\n            PathAddress addr = PathAddress.pathAddress(operation.get(OP_ADDR));\n            Resource resource = context.getOriginalRootResource();\n            for (PathElement element : addr) {\n                resource = resource.getChild(element);\n            }\n            DataSourceEnable.addServices(context, operation, null, datasourceRegistration,\n                    Resource.Tools.readModel(resource), isXa(), new LinkedList<ServiceController<?>>());\n        }\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) {\n\n        final ModelNode model = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n        model.get(ENABLED).set(false);\n\n        if (context.isNormalServer()) {\n            if (context.isResourceServiceRestartAllowed()) {\n                context.addStep(new OperationStepHandler() {\n                    public void execute(final OperationContext context, ModelNode operation) throws OperationFailedException {\n\n                        final ModelNode address = operation.require(OP_ADDR);\n                        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n                        final String jndiName = model.get(JNDI_NAME.getName()).asString();\n\n                        final ServiceRegistry registry = context.getServiceRegistry(true);\n\n                        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n                        final ServiceController<?> dataSourceController = registry.getService(dataSourceServiceName);\n                        if (dataSourceController != null) {\n                            if (ServiceController.State.UP.equals(dataSourceController.getState())) {\n                                dataSourceController.setMode(ServiceController.Mode.NEVER);\n                            } else {\n                                throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotEnabled(\"Data-source\", dsName)));\n                            }\n                        } else {\n                            throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source\", dsName)));\n                        }\n\n                        final ServiceName referenceServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE.append(dsName);\n                        final ServiceController<?> referenceController = registry.getService(referenceServiceName);\n                        if (referenceController != null ) {\n                            context.removeService(referenceController);\n                        }\n\n                        final ServiceName binderServiceName = ContextNames.bindInfoFor(jndiName).getBinderServiceName();\n\n                        final ServiceController<?> binderController = registry.getService(binderServiceName);\n                        if (binderController != null ) {\n                            context.removeService(binderController);\n                        }\n\n                        final ServiceName dataSourceConfigServiceName = DataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n                        final ServiceController<?> dataSourceConfigController = registry.getService(dataSourceConfigServiceName);\n\n\n                        final List<ServiceName> serviceNames = registry.getServiceNames();\n\n\n                        final ServiceName xaDataSourceConfigServiceName = XADataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n                        final ServiceController<?> xaDataSourceConfigController = registry.getService(xaDataSourceConfigServiceName);\n\n\n                        for (ServiceName name : serviceNames) {\n                            if (dataSourceConfigServiceName.append(\"connection-properties\").isParentOf(name)) {\n                                final ServiceController<?> connPropertyController = registry.getService(name);\n\n                                if (connPropertyController != null) {\n                                    if (ServiceController.State.UP.equals(connPropertyController.getState())) {\n                                        connPropertyController.setMode(ServiceController.Mode.NEVER);\n                                    } else {\n                                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.connectionProperty\", name)));\n                                    }\n                                } else {\n                                    throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source.connectionProperty\", name)));\n                                }\n                            }\n                            if (xaDataSourceConfigServiceName.append(\"xa-datasource-properties\").isParentOf(name)) {\n                                final ServiceController<?> xaConfigPropertyController = registry.getService(name);\n\n                                if (xaConfigPropertyController != null) {\n                                    if (ServiceController.State.UP.equals(xaConfigPropertyController.getState())) {\n                                        xaConfigPropertyController.setMode(ServiceController.Mode.NEVER);\n                                    } else {\n                                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.xa-config-property\", name)));\n                                    }\n                                } else {\n                                    throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source.xa-config-property\", name)));\n                                }\n                            }\n                        }\n\n\n                        if (xaDataSourceConfigController != null) {\n                            context.removeService(xaDataSourceConfigController);\n                        }\n\n                        if (dataSourceConfigController != null) {\n                            context.removeService(dataSourceConfigController);\n                        }\n\n                        context.completeStep(new OperationContext.RollbackHandler() {\n                            @Override\n                            public void handleRollback(OperationContext context, ModelNode operation) {\n                                try {\n                                    reEnable(context,operation);\n                                } catch (OperationFailedException e) {\n\n                                }\n                            }\n                        });\n                    }\n                }, OperationContext.Stage.RUNTIME);\n            } else {\n                context.addStep(new OperationStepHandler() {\n                    @Override\n                    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                        context.reloadRequired();\n                        context.completeStep(OperationContext.RollbackHandler.REVERT_RELOAD_REQUIRED_ROLLBACK_HANDLER);\n                    }\n                }, OperationContext.Stage.RUNTIME);\n            }\n        }\n        context.stepCompleted();\n    }","id":89360,"modified_method":"public void execute(OperationContext context, ModelNode operation) {\n\n        final ManagementResourceRegistration datasourceRegistration = context.getResourceRegistrationForUpdate();\n        final Resource resource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n        final ModelNode model = resource.getModel();\n        model.get(ENABLED).set(false);\n\n        if (context.isNormalServer()) {\n\n            DataSourceStatisticsListener.removeStatisticsResources(resource);\n\n            if (context.isResourceServiceRestartAllowed()) {\n                context.addStep(new OperationStepHandler() {\n                    public void execute(final OperationContext context, ModelNode operation) throws OperationFailedException {\n\n                        final ModelNode address = operation.require(OP_ADDR);\n                        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n                        final String jndiName = model.get(JNDI_NAME.getName()).asString();\n\n                        final ServiceRegistry registry = context.getServiceRegistry(true);\n\n                        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n                        final ServiceController<?> dataSourceController = registry.getService(dataSourceServiceName);\n                        if (dataSourceController != null) {\n                            if (ServiceController.State.UP.equals(dataSourceController.getState())) {\n                                dataSourceController.setMode(ServiceController.Mode.NEVER);\n                            } else {\n                                throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotEnabled(\"Data-source\", dsName)));\n                            }\n                        } else {\n                            throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source\", dsName)));\n                        }\n\n                        final ServiceName referenceServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE.append(dsName);\n                        final ServiceController<?> referenceController = registry.getService(referenceServiceName);\n                        if (referenceController != null ) {\n                            context.removeService(referenceController);\n                        }\n\n                        final ServiceName binderServiceName = ContextNames.bindInfoFor(jndiName).getBinderServiceName();\n\n                        final ServiceController<?> binderController = registry.getService(binderServiceName);\n                        if (binderController != null ) {\n                            context.removeService(binderController);\n                        }\n\n                        final ServiceName dataSourceConfigServiceName = DataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n                        final ServiceController<?> dataSourceConfigController = registry.getService(dataSourceConfigServiceName);\n\n\n                        final List<ServiceName> serviceNames = registry.getServiceNames();\n\n\n                        final ServiceName xaDataSourceConfigServiceName = XADataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n                        final ServiceController<?> xaDataSourceConfigController = registry.getService(xaDataSourceConfigServiceName);\n\n\n                        for (ServiceName name : serviceNames) {\n                            if (dataSourceConfigServiceName.append(\"connection-properties\").isParentOf(name)) {\n                                final ServiceController<?> connPropertyController = registry.getService(name);\n\n                                if (connPropertyController != null) {\n                                    if (ServiceController.State.UP.equals(connPropertyController.getState())) {\n                                        connPropertyController.setMode(ServiceController.Mode.NEVER);\n                                    } else {\n                                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.connectionProperty\", name)));\n                                    }\n                                } else {\n                                    throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source.connectionProperty\", name)));\n                                }\n                            }\n                            if (xaDataSourceConfigServiceName.append(\"xa-datasource-properties\").isParentOf(name)) {\n                                final ServiceController<?> xaConfigPropertyController = registry.getService(name);\n\n                                if (xaConfigPropertyController != null) {\n                                    if (ServiceController.State.UP.equals(xaConfigPropertyController.getState())) {\n                                        xaConfigPropertyController.setMode(ServiceController.Mode.NEVER);\n                                    } else {\n                                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.xa-config-property\", name)));\n                                    }\n                                } else {\n                                    throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source.xa-config-property\", name)));\n                                }\n                            }\n                        }\n\n\n                        if (xaDataSourceConfigController != null) {\n                            context.removeService(xaDataSourceConfigController);\n                        }\n\n                        if (dataSourceConfigController != null) {\n                            context.removeService(dataSourceConfigController);\n                        }\n\n                        context.completeStep(new OperationContext.RollbackHandler() {\n                            @Override\n                            public void handleRollback(OperationContext context, ModelNode operation) {\n                                try {\n                                    reEnable(context, operation, datasourceRegistration);\n                                } catch (OperationFailedException e) {\n                                    // ignored\n                                }\n                            }\n                        });\n                    }\n                }, OperationContext.Stage.RUNTIME);\n            } else {\n                context.addStep(new OperationStepHandler() {\n                    @Override\n                    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                        context.reloadRequired();\n                        context.completeStep(OperationContext.RollbackHandler.REVERT_RELOAD_REQUIRED_ROLLBACK_HANDLER);\n                    }\n                }, OperationContext.Stage.RUNTIME);\n            }\n        }\n        context.stepCompleted();\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void addServices(OperationContext context, ModelNode operation, ServiceVerificationHandler verificationHandler, ModelNode model, boolean isXa, final List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final ModelNode address = operation.require(OP_ADDR);\n        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n        final String jndiName = model.get(JNDI_NAME.getName()).asString();\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final List<ServiceName> serviceNames = registry.getServiceNames();\n\n\n        if (isXa) {\n            final ModifiableXaDataSource dataSourceConfig;\n            try {\n                dataSourceConfig = xaFrom(context, model, dsName);\n            } catch (ValidateException e) {\n                throw new OperationFailedException(e, new ModelNode().set(ConnectorLogger.ROOT_LOGGER.failedToCreate(\"XaDataSource\", operation, e.getLocalizedMessage())));\n            }\n            final ServiceName xaDataSourceConfigServiceName = XADataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n            final XADataSourceConfigService xaDataSourceConfigService = new XADataSourceConfigService(dataSourceConfig);\n\n            final ServiceBuilder<?> builder = serviceTarget.addService(xaDataSourceConfigServiceName, xaDataSourceConfigService);\n            if (verificationHandler != null) {\n                builder.addListener(verificationHandler);\n            }\n            // add dependency on security domain service if applicable\n            final DsSecurity dsSecurityConfig = dataSourceConfig.getSecurity();\n            if (dsSecurityConfig != null) {\n                final String securityDomainName = dsSecurityConfig.getSecurityDomain();\n                if (securityDomainName != null) {\n                    builder.addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomainName));\n                }\n            }\n            int propertiesCount = 0;\n            for (ServiceName name : serviceNames) {\n                if (xaDataSourceConfigServiceName.append(\"xa-datasource-properties\").isParentOf(name)) {\n                    final ServiceController<?> xaConfigPropertyController = registry.getService(name);\n                    XaDataSourcePropertiesService xaPropService = (XaDataSourcePropertiesService) xaConfigPropertyController.getService();\n\n                    if (!ServiceController.State.UP.equals(xaConfigPropertyController.getState())) {\n                        propertiesCount++;\n                        xaConfigPropertyController.setMode(ServiceController.Mode.ACTIVE);\n                        builder.addDependency(name, String.class, xaDataSourceConfigService.getXaDataSourcePropertyInjector(xaPropService.getName()));\n\n                    } else {\n                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.xa-config-property\", name)));\n                    }\n                }\n            }\n            if (propertiesCount == 0) {\n                throw ConnectorLogger.ROOT_LOGGER.xaDataSourcePropertiesNotPresent();\n            }\n            controllers.add(builder.install());\n\n        } else {\n\n            final ModifiableDataSource dataSourceConfig;\n            try {\n                dataSourceConfig = from(context, model,dsName);\n            } catch (ValidateException e) {\n                throw new OperationFailedException(e, new ModelNode().set(ConnectorLogger.ROOT_LOGGER.failedToCreate(\"DataSource\", operation, e.getLocalizedMessage())));\n            }\n            final ServiceName dataSourceCongServiceName = DataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n            final DataSourceConfigService configService = new DataSourceConfigService(dataSourceConfig);\n\n            final ServiceBuilder<?> builder = serviceTarget.addService(dataSourceCongServiceName, configService);\n            if (verificationHandler != null) {\n                builder.addListener(verificationHandler);\n            }\n            // add dependency on security domain service if applicable\n            final DsSecurity dsSecurityConfig = dataSourceConfig.getSecurity();\n            if (dsSecurityConfig != null) {\n                final String securityDomainName = dsSecurityConfig.getSecurityDomain();\n                if (securityDomainName != null) {\n                    builder.addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomainName));\n                }\n            }\n            for (ServiceName name : serviceNames) {\n                if (dataSourceCongServiceName.append(\"connection-properties\").isParentOf(name)) {\n                    final ServiceController<?> dataSourceController = registry.getService(name);\n                    ConnectionPropertiesService connPropService = (ConnectionPropertiesService) dataSourceController.getService();\n\n                    if (!ServiceController.State.UP.equals(dataSourceController.getState())) {\n                        dataSourceController.setMode(ServiceController.Mode.ACTIVE);\n                        builder.addDependency(name, String.class, configService.getConnectionPropertyInjector(connPropService.getName()));\n\n                    } else {\n                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.connectionProperty\", name)));\n                    }\n                }\n            }\n            controllers.add(builder.install());\n\n\n        }\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n\n\n        final ServiceController<?> dataSourceController = registry.getService(dataSourceServiceName);\n\n        if (dataSourceController != null) {\n            if (!ServiceController.State.UP.equals(dataSourceController.getState())) {\n                dataSourceController.setMode(ServiceController.Mode.ACTIVE);\n            } else {\n                throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source\", dsName)));\n            }\n        } else {\n            throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source\", dsName)));\n        }\n\n        final DataSourceReferenceFactoryService referenceFactoryService = new DataSourceReferenceFactoryService();\n        final ServiceName referenceFactoryServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE\n                .append(dsName);\n        final ServiceBuilder<?> referenceBuilder = serviceTarget.addService(referenceFactoryServiceName,\n                referenceFactoryService).addDependency(dataSourceServiceName, javax.sql.DataSource.class,\n                referenceFactoryService.getDataSourceInjector());\n        if (verificationHandler != null) {\n            referenceBuilder.addListener(verificationHandler);\n        }\n\n        controllers.add(referenceBuilder.install());\n\n        final ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(jndiName);\n        final BinderService binderService = new BinderService(bindInfo.getBindName());\n        final ServiceBuilder<?> binderBuilder = serviceTarget\n                .addService(bindInfo.getBinderServiceName(), binderService)\n                .addDependency(referenceFactoryServiceName, ManagedReferenceFactory.class, binderService.getManagedObjectInjector())\n                .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                    public void transition(final ServiceController<? extends Object> controller, final ServiceController.Transition transition) {\n                        switch (transition) {\n                            case STARTING_to_UP: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.boundDataSource(jndiName);\n                                break;\n                            }\n                            case STOPPING_to_DOWN: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.unboundDataSource(jndiName);\n                                break;\n                            }\n                            case REMOVING_to_REMOVED: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.debugf(\"Removed JDBC Data-source [%s]\", jndiName);\n                                break;\n                            }\n                        }\n                    }\n                });\n        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE);\n        if (verificationHandler != null) {\n            binderBuilder.addListener(verificationHandler);\n        }\n        controllers.add(binderBuilder.install());\n\n    }","id":89361,"modified_method":"static void addServices(OperationContext context, ModelNode operation, ServiceVerificationHandler verificationHandler, ManagementResourceRegistration datasourceRegistration, ModelNode model, boolean isXa, final List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final ModelNode address = operation.require(OP_ADDR);\n        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n        final String jndiName = model.get(JNDI_NAME.getName()).asString();\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final List<ServiceName> serviceNames = registry.getServiceNames();\n\n\n        if (isXa) {\n            final ModifiableXaDataSource dataSourceConfig;\n            try {\n                dataSourceConfig = xaFrom(context, model, dsName);\n            } catch (ValidateException e) {\n                throw new OperationFailedException(e, new ModelNode().set(ConnectorLogger.ROOT_LOGGER.failedToCreate(\"XaDataSource\", operation, e.getLocalizedMessage())));\n            }\n            final ServiceName xaDataSourceConfigServiceName = XADataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n            final XADataSourceConfigService xaDataSourceConfigService = new XADataSourceConfigService(dataSourceConfig);\n\n            final ServiceBuilder<?> builder = serviceTarget.addService(xaDataSourceConfigServiceName, xaDataSourceConfigService);\n            if (verificationHandler != null) {\n                builder.addListener(verificationHandler);\n            }\n            // add dependency on security domain service if applicable\n            final DsSecurity dsSecurityConfig = dataSourceConfig.getSecurity();\n            if (dsSecurityConfig != null) {\n                final String securityDomainName = dsSecurityConfig.getSecurityDomain();\n                if (securityDomainName != null) {\n                    builder.addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomainName));\n                }\n            }\n            int propertiesCount = 0;\n            for (ServiceName name : serviceNames) {\n                if (xaDataSourceConfigServiceName.append(\"xa-datasource-properties\").isParentOf(name)) {\n                    final ServiceController<?> xaConfigPropertyController = registry.getService(name);\n                    XaDataSourcePropertiesService xaPropService = (XaDataSourcePropertiesService) xaConfigPropertyController.getService();\n\n                    if (!ServiceController.State.UP.equals(xaConfigPropertyController.getState())) {\n                        propertiesCount++;\n                        xaConfigPropertyController.setMode(ServiceController.Mode.ACTIVE);\n                        builder.addDependency(name, String.class, xaDataSourceConfigService.getXaDataSourcePropertyInjector(xaPropService.getName()));\n\n                    } else {\n                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.xa-config-property\", name)));\n                    }\n                }\n            }\n            if (propertiesCount == 0) {\n                throw ConnectorLogger.ROOT_LOGGER.xaDataSourcePropertiesNotPresent();\n            }\n            controllers.add(builder.install());\n\n        } else {\n\n            final ModifiableDataSource dataSourceConfig;\n            try {\n                dataSourceConfig = from(context, model,dsName);\n            } catch (ValidateException e) {\n                throw new OperationFailedException(e, new ModelNode().set(ConnectorLogger.ROOT_LOGGER.failedToCreate(\"DataSource\", operation, e.getLocalizedMessage())));\n            }\n            final ServiceName dataSourceCongServiceName = DataSourceConfigService.SERVICE_NAME_BASE.append(dsName);\n            final DataSourceConfigService configService = new DataSourceConfigService(dataSourceConfig);\n\n            final ServiceBuilder<?> builder = serviceTarget.addService(dataSourceCongServiceName, configService);\n            if (verificationHandler != null) {\n                builder.addListener(verificationHandler);\n            }\n            // add dependency on security domain service if applicable\n            final DsSecurity dsSecurityConfig = dataSourceConfig.getSecurity();\n            if (dsSecurityConfig != null) {\n                final String securityDomainName = dsSecurityConfig.getSecurityDomain();\n                if (securityDomainName != null) {\n                    builder.addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomainName));\n                }\n            }\n            for (ServiceName name : serviceNames) {\n                if (dataSourceCongServiceName.append(\"connection-properties\").isParentOf(name)) {\n                    final ServiceController<?> dataSourceController = registry.getService(name);\n                    ConnectionPropertiesService connPropService = (ConnectionPropertiesService) dataSourceController.getService();\n\n                    if (!ServiceController.State.UP.equals(dataSourceController.getState())) {\n                        dataSourceController.setMode(ServiceController.Mode.ACTIVE);\n                        builder.addDependency(name, String.class, configService.getConnectionPropertyInjector(connPropService.getName()));\n\n                    } else {\n                        throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source.connectionProperty\", name)));\n                    }\n                }\n            }\n            controllers.add(builder.install());\n\n\n        }\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n\n\n        final ServiceController<?> dataSourceController = registry.getService(dataSourceServiceName);\n\n        if (dataSourceController != null) {\n            if (!ServiceController.State.UP.equals(dataSourceController.getState())) {\n                final boolean statsEnabled = STATISTICS_ENABLED.resolveModelAttribute(context, model).asBoolean();\n                dataSourceController.addListener(new DataSourceStatisticsListener(datasourceRegistration, statsEnabled));\n\n                dataSourceController.setMode(ServiceController.Mode.ACTIVE);\n            } else {\n                throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceAlreadyStarted(\"Data-source\", dsName)));\n            }\n        } else {\n            throw new OperationFailedException(new ModelNode().set(ConnectorLogger.ROOT_LOGGER.serviceNotAvailable(\"Data-source\", dsName)));\n        }\n\n        final DataSourceReferenceFactoryService referenceFactoryService = new DataSourceReferenceFactoryService();\n        final ServiceName referenceFactoryServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE\n                .append(dsName);\n        final ServiceBuilder<?> referenceBuilder = serviceTarget.addService(referenceFactoryServiceName,\n                referenceFactoryService).addDependency(dataSourceServiceName, javax.sql.DataSource.class,\n                referenceFactoryService.getDataSourceInjector());\n        if (verificationHandler != null) {\n            referenceBuilder.addListener(verificationHandler);\n        }\n\n        controllers.add(referenceBuilder.install());\n\n        final ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(jndiName);\n        final BinderService binderService = new BinderService(bindInfo.getBindName());\n        final ServiceBuilder<?> binderBuilder = serviceTarget\n                .addService(bindInfo.getBinderServiceName(), binderService)\n                .addDependency(referenceFactoryServiceName, ManagedReferenceFactory.class, binderService.getManagedObjectInjector())\n                .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                    public void transition(final ServiceController<? extends Object> controller, final ServiceController.Transition transition) {\n                        switch (transition) {\n                            case STARTING_to_UP: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.boundDataSource(jndiName);\n                                break;\n                            }\n                            case STOPPING_to_DOWN: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.unboundDataSource(jndiName);\n                                break;\n                            }\n                            case REMOVING_to_REMOVED: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.debugf(\"Removed JDBC Data-source [%s]\", jndiName);\n                                break;\n                            }\n                        }\n                    }\n                });\n        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE);\n        if (verificationHandler != null) {\n            binderBuilder.addListener(verificationHandler);\n        }\n        controllers.add(binderBuilder.install());\n\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) {\n\n        final ModelNode model = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n\n        if (context.isNormalServer()) {\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n                    model.get(ENABLED).set(true);\n                    addServices(context, operation, verificationHandler, model, isXa(), controllers);\n                    context.addStep(verificationHandler, Stage.VERIFY);\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                                            @Override\n                                            public void handleRollback(OperationContext context, ModelNode operation) {\n                                                rollbackRuntime(context, operation, model, controllers);\n                                            }\n                                        });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.stepCompleted();\n    }","id":89362,"modified_method":"public void execute(OperationContext context, ModelNode operation) {\n\n        final ManagementResourceRegistration registration = context.getResourceRegistrationForUpdate();\n        final Resource resource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n        final ModelNode model = resource.getModel();\n\n        if (context.isNormalServer()) {\n            model.get(ENABLED).set(true);\n            DataSourceStatisticsListener.registerStatisticsResources(resource);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n                    addServices(context, operation, verificationHandler, registration, model, isXa(), controllers);\n                    context.addStep(verificationHandler, Stage.VERIFY);\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                                            @Override\n                                            public void handleRollback(OperationContext context, ModelNode operation) {\n                                                rollbackRuntime(context, operation, model, controllers);\n                                            }\n                                        });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.stepCompleted();\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"public DataSourceStatisticsListener(final ManagementResourceRegistration overrideRegistration, Resource resource, final String dsName, final boolean statsEnabled) {\n        this.overrideRegistration = overrideRegistration;\n        this.resource = resource;\n        this.dsName = dsName;\n        this.statsEnabled = statsEnabled;\n    }","id":89363,"modified_method":"public DataSourceStatisticsListener(final ManagementResourceRegistration overrideRegistration, final boolean statsEnabled) {\n        this.overrideRegistration = overrideRegistration;\n        this.statsEnabled = statsEnabled;\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void transition(final ServiceController<? extends Object> controller,\n                           final ServiceController.Transition transition) {\n\n        switch (transition) {\n            case STARTING_to_UP: {\n\n                CommonDeployment deploymentMD = ((AbstractDataSourceService) controller.getService()).getDeploymentMD();\n\n                StatisticsPlugin jdbcStats = deploymentMD.getDataSources()[0].getStatistics();\n                StatisticsPlugin poolStats = deploymentMD.getDataSources()[0].getPool().getStatistics();\n                jdbcStats.setEnabled(statsEnabled);\n                poolStats.setEnabled(statsEnabled);\n\n                int jdbcStatsSize = jdbcStats.getNames().size();\n                int poolStatsSize = poolStats.getNames().size();\n                if (jdbcStatsSize > 0 || poolStatsSize > 0) {\n                    if (overrideRegistration != null) {\n                        if (jdbcStatsSize > 0) {\n                            ManagementResourceRegistration jdbcRegistration = overrideRegistration.registerSubModel(new StatisticsResourceDefinition(JDBC_STATISTICS,DataSourcesSubsystemProviders.RESOURCE_NAME, jdbcStats));\n                            jdbcRegistration.setRuntimeOnly(true);\n                            resource.registerChild(JDBC_STATISTICS, new PlaceholderResource.PlaceholderResourceEntry(JDBC_STATISTICS));\n                        }\n\n                        if (poolStatsSize > 0) {\n                            ManagementResourceRegistration poolRegistration = overrideRegistration.registerSubModel(new StatisticsResourceDefinition(POOL_STATISTICS, DataSourcesSubsystemProviders.RESOURCE_NAME, poolStats));\n                            poolRegistration.setRuntimeOnly(true);\n                            resource.registerChild(POOL_STATISTICS, new PlaceholderResource.PlaceholderResourceEntry(JDBC_STATISTICS));\n                        }\n                    }\n                }\n                break;\n\n\n            }\n            case UP_to_STOP_REQUESTED: {\n\n                if (overrideRegistration != null) {\n                    overrideRegistration.unregisterSubModel(JDBC_STATISTICS);\n                    overrideRegistration.unregisterSubModel(POOL_STATISTICS);\n                }\n\n                if (resource.hasChild(JDBC_STATISTICS)) {\n                    resource.removeChild(JDBC_STATISTICS);\n                }\n\n                if (resource.hasChild(POOL_STATISTICS)) {\n                    resource.removeChild(POOL_STATISTICS);\n                }\n                break;\n\n            }\n        }\n    }","id":89364,"modified_method":"public void transition(final ServiceController<?> controller,\n                           final ServiceController.Transition transition) {\n\n        switch (transition) {\n            case STARTING_to_UP: {\n\n                CommonDeployment deploymentMD = ((AbstractDataSourceService) controller.getService()).getDeploymentMD();\n\n                StatisticsPlugin jdbcStats = deploymentMD.getDataSources()[0].getStatistics();\n                StatisticsPlugin poolStats = deploymentMD.getDataSources()[0].getPool().getStatistics();\n                jdbcStats.setEnabled(statsEnabled);\n                poolStats.setEnabled(statsEnabled);\n\n                int jdbcStatsSize = jdbcStats.getNames().size();\n                int poolStatsSize = poolStats.getNames().size();\n                if (jdbcStatsSize > 0 || poolStatsSize > 0) {\n                    if (overrideRegistration != null) {\n                        if (jdbcStatsSize > 0) {\n                            ManagementResourceRegistration jdbcRegistration = overrideRegistration.registerSubModel(new StatisticsResourceDefinition(JDBC_STATISTICS,DataSourcesSubsystemProviders.RESOURCE_NAME, jdbcStats));\n                            jdbcRegistration.setRuntimeOnly(true);\n                        }\n\n                        if (poolStatsSize > 0) {\n                            ManagementResourceRegistration poolRegistration = overrideRegistration.registerSubModel(new StatisticsResourceDefinition(POOL_STATISTICS, DataSourcesSubsystemProviders.RESOURCE_NAME, poolStats));\n                            poolRegistration.setRuntimeOnly(true);\n                        }\n                    }\n                }\n                break;\n\n\n            }\n            case UP_to_STOP_REQUESTED: {\n\n                if (overrideRegistration != null) {\n                    overrideRegistration.unregisterSubModel(JDBC_STATISTICS);\n                    overrideRegistration.unregisterSubModel(POOL_STATISTICS);\n                }\n                break;\n\n            }\n        }\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void startDataSource(final AbstractDataSourceService dataSourceService,\n                                 final String jndiName,\n                                 final String driverName,\n                                 final ServiceTarget serviceTarget,\n                                 final ServiceVerificationHandler verificationHandler,\n                                 final ManagementResourceRegistration registration,\n                                 final Resource resource,\n                                 final String managementName) {\n\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> dataSourceServiceBuilder =\n                Services.addServerExecutorDependency(\n                        serviceTarget.addService(dataSourceServiceName, dataSourceService),\n                        dataSourceService.getExecutorServiceInjector(), false)\n                .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                        dataSourceService.getTransactionIntegrationInjector())\n                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                        dataSourceService.getManagementRepositoryInjector())\n                .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                        dataSourceService.getSubjectFactoryInjector())\n                .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, dataSourceService.getCcmInjector())\n                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,\n                        dataSourceService.getDriverRegistryInjector()).addDependency(NamingService.SERVICE_NAME);\n\n        //Register an empty override model regardless of we're enabled or not - the statistics listener will add the relevant childresources\n        if (registration.isAllowsOverride()) {\n            ManagementResourceRegistration overrideRegistration = registration.getOverrideModel(managementName);\n            if (overrideRegistration == null || overrideRegistration.isAllowsOverride()) {\n                overrideRegistration = registration.registerOverrideModel(managementName, DataSourcesSubsystemProviders.OVERRIDE_DS_DESC);\n            }\n            dataSourceServiceBuilder.addListener(new DataSourceStatisticsListener(overrideRegistration, resource, managementName, false));\n        } // else should probably throw an ISE or something\n\n        final ServiceName driverServiceName = ServiceName.JBOSS.append(\"jdbc-driver\", driverName.replaceAll(\"\\\\.\", \"_\"));\n        if (driverServiceName != null) {\n            dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                    dataSourceService.getDriverInjector());\n        }\n\n        final DataSourceReferenceFactoryService referenceFactoryService = new DataSourceReferenceFactoryService();\n        final ServiceName referenceFactoryServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE\n                .append(jndiName);\n        final ServiceBuilder<?> referenceBuilder = serviceTarget.addService(referenceFactoryServiceName,\n                referenceFactoryService).addDependency(dataSourceServiceName, javax.sql.DataSource.class,\n                referenceFactoryService.getDataSourceInjector());\n\n        final ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(jndiName);\n        final BinderService binderService = new BinderService(bindInfo.getBindName());\n        final ServiceBuilder<?> binderBuilder = serviceTarget\n                .addService(bindInfo.getBinderServiceName(), binderService)\n                .addDependency(referenceFactoryServiceName, ManagedReferenceFactory.class, binderService.getManagedObjectInjector())\n                .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                    public void transition(final ServiceController<?> controller, final ServiceController.Transition transition) {\n                        switch (transition) {\n                            case STARTING_to_UP: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.boundDataSource(jndiName);\n                                break;\n                            }\n                            case START_REQUESTED_to_DOWN: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.unboundDataSource(jndiName);\n                                break;\n                            }\n                            case REMOVING_to_REMOVED: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.debugf(\"Removed JDBC Data-source [%s]\", jndiName);\n                                break;\n                            }\n                        }\n                    }\n                });\n\n        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n        referenceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n    }","id":89365,"modified_method":"private void startDataSource(final AbstractDataSourceService dataSourceService,\n                                 final String jndiName,\n                                 final String driverName,\n                                 final ServiceTarget serviceTarget,\n                                 final ServiceVerificationHandler verificationHandler,\n                                 final ManagementResourceRegistration registration,\n                                 final Resource resource,\n                                 final String managementName) {\n\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> dataSourceServiceBuilder =\n                Services.addServerExecutorDependency(\n                        serviceTarget.addService(dataSourceServiceName, dataSourceService),\n                        dataSourceService.getExecutorServiceInjector(), false)\n                .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                        dataSourceService.getTransactionIntegrationInjector())\n                .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                        dataSourceService.getManagementRepositoryInjector())\n                .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                        dataSourceService.getSubjectFactoryInjector())\n                .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, dataSourceService.getCcmInjector())\n                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,\n                        dataSourceService.getDriverRegistryInjector()).addDependency(NamingService.SERVICE_NAME);\n\n        //Register an empty override model regardless of we're enabled or not - the statistics listener will add the relevant childresources\n        if (registration.isAllowsOverride()) {\n            ManagementResourceRegistration overrideRegistration = registration.getOverrideModel(managementName);\n            if (overrideRegistration == null || overrideRegistration.isAllowsOverride()) {\n                overrideRegistration = registration.registerOverrideModel(managementName, DataSourcesSubsystemProviders.OVERRIDE_DS_DESC);\n            }\n            dataSourceServiceBuilder.addListener(new DataSourceStatisticsListener(overrideRegistration, false));\n            DataSourceStatisticsListener.registerStatisticsResources(resource);\n        } // else should probably throw an ISE or something\n\n        final ServiceName driverServiceName = ServiceName.JBOSS.append(\"jdbc-driver\", driverName.replaceAll(\"\\\\.\", \"_\"));\n        if (driverServiceName != null) {\n            dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                    dataSourceService.getDriverInjector());\n        }\n\n        final DataSourceReferenceFactoryService referenceFactoryService = new DataSourceReferenceFactoryService();\n        final ServiceName referenceFactoryServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE\n                .append(jndiName);\n        final ServiceBuilder<?> referenceBuilder = serviceTarget.addService(referenceFactoryServiceName,\n                referenceFactoryService).addDependency(dataSourceServiceName, javax.sql.DataSource.class,\n                referenceFactoryService.getDataSourceInjector());\n\n        final ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(jndiName);\n        final BinderService binderService = new BinderService(bindInfo.getBindName());\n        final ServiceBuilder<?> binderBuilder = serviceTarget\n                .addService(bindInfo.getBinderServiceName(), binderService)\n                .addDependency(referenceFactoryServiceName, ManagedReferenceFactory.class, binderService.getManagedObjectInjector())\n                .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                    public void transition(final ServiceController<?> controller, final ServiceController.Transition transition) {\n                        switch (transition) {\n                            case STARTING_to_UP: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.boundDataSource(jndiName);\n                                break;\n                            }\n                            case START_REQUESTED_to_DOWN: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.unboundDataSource(jndiName);\n                                break;\n                            }\n                            case REMOVING_to_REMOVED: {\n                                SUBSYSTEM_DATASOURCES_LOGGER.debugf(\"Removed JDBC Data-source [%s]\", jndiName);\n                                break;\n                            }\n                        }\n                    }\n                });\n\n        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n        referenceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n    }","commit_id":"0a59f93cae431bf952877b505856b49c7f839603","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void doStart() {\n        this.serverOpenChannels = new OpenChannelsHandler(logger);\n\n        if (blockingServer) {\n            serverBootstrap = new ServerBootstrap(new OioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_boss\")),\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_worker\"))\n            ));\n        } else {\n            serverBootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_boss\")),\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_worker\")),\n                    workerCount));\n        }\n\n        serverBootstrap.setPipelineFactory(configureServerChannelPipelineFactory());\n\n        if (!\"default\".equals(tcpNoDelay)) {\n            serverBootstrap.setOption(\"child.tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n        if (!\"default\".equals(tcpKeepAlive)) {\n            serverBootstrap.setOption(\"child.keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n        serverBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"child.receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        if (reuseAddress != null) {\n            serverBootstrap.setOption(\"reuseAddress\", reuseAddress);\n            serverBootstrap.setOption(\"child.reuseAddress\", reuseAddress);\n        }\n\n        // Bind and start to accept incoming connections.\n        InetAddress hostAddressX;\n        try {\n            hostAddressX = networkService.resolveBindHostAddress(bindHost);\n        } catch (IOException e) {\n            throw new BindHttpException(\"Failed to resolve host [\" + bindHost + \"]\", e);\n        }\n        final InetAddress hostAddress = hostAddressX;\n\n        PortsRange portsRange = new PortsRange(port);\n        final AtomicReference<Exception> lastException = new AtomicReference<>();\n        boolean success = portsRange.iterate(new PortsRange.PortCallback() {\n            @Override\n            public boolean onPortNumber(int portNumber) {\n                try {\n                    serverChannel = serverBootstrap.bind(new InetSocketAddress(hostAddress, portNumber));\n                } catch (Exception e) {\n                    lastException.set(e);\n                    return false;\n                }\n                return true;\n            }\n        });\n        if (!success) {\n            throw new BindHttpException(\"Failed to bind to [\" + port + \"]\", lastException.get());\n        }\n\n        InetSocketAddress boundAddress = (InetSocketAddress) serverChannel.getLocalAddress();\n        InetSocketAddress publishAddress;\n        if (0 == publishPort) {\n            publishPort = boundAddress.getPort();\n        }\n        try {\n            publishAddress = new InetSocketAddress(networkService.resolvePublishHostAddress(publishHost), publishPort);\n        } catch (Exception e) {\n            throw new BindTransportException(\"Failed to resolve publish address\", e);\n        }\n        this.boundAddress = new BoundTransportAddress(new InetSocketTransportAddress(boundAddress), new InetSocketTransportAddress(publishAddress));\n    }","id":89366,"modified_method":"@Override\n    protected void doStart() {\n        this.serverOpenChannels = new OpenChannelsHandler(logger);\n\n        if (blockingServer) {\n            serverBootstrap = new ServerBootstrap(new OioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_boss\")),\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_worker\"))\n            ));\n        } else {\n            serverBootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_boss\")),\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, \"http_server_worker\")),\n                    workerCount));\n        }\n\n        serverBootstrap.setPipelineFactory(configureServerChannelPipelineFactory());\n\n        if (!\"default\".equals(tcpNoDelay)) {\n            serverBootstrap.setOption(\"child.tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n        if (!\"default\".equals(tcpKeepAlive)) {\n            serverBootstrap.setOption(\"child.keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n        serverBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"child.receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"reuseAddress\", reuseAddress);\n        serverBootstrap.setOption(\"child.reuseAddress\", reuseAddress);\n\n        // Bind and start to accept incoming connections.\n        InetAddress hostAddressX;\n        try {\n            hostAddressX = networkService.resolveBindHostAddress(bindHost);\n        } catch (IOException e) {\n            throw new BindHttpException(\"Failed to resolve host [\" + bindHost + \"]\", e);\n        }\n        final InetAddress hostAddress = hostAddressX;\n\n        PortsRange portsRange = new PortsRange(port);\n        final AtomicReference<Exception> lastException = new AtomicReference<>();\n        boolean success = portsRange.iterate(new PortsRange.PortCallback() {\n            @Override\n            public boolean onPortNumber(int portNumber) {\n                try {\n                    serverChannel = serverBootstrap.bind(new InetSocketAddress(hostAddress, portNumber));\n                } catch (Exception e) {\n                    lastException.set(e);\n                    return false;\n                }\n                return true;\n            }\n        });\n        if (!success) {\n            throw new BindHttpException(\"Failed to bind to [\" + port + \"]\", lastException.get());\n        }\n\n        InetSocketAddress boundAddress = (InetSocketAddress) serverChannel.getLocalAddress();\n        InetSocketAddress publishAddress;\n        if (0 == publishPort) {\n            publishPort = boundAddress.getPort();\n        }\n        try {\n            publishAddress = new InetSocketAddress(networkService.resolvePublishHostAddress(publishHost), publishPort);\n        } catch (Exception e) {\n            throw new BindTransportException(\"Failed to resolve publish address\", e);\n        }\n        this.boundAddress = new BoundTransportAddress(new InetSocketTransportAddress(boundAddress), new InetSocketTransportAddress(publishAddress));\n    }","commit_id":"a40ba3be5aecc00e9b0b7ef79a0220d09159e327","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void createServerBootstrap(String name, Settings settings) {\n        boolean blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", this.settings.getAsBoolean(TCP_BLOCKING_SERVER, this.settings.getAsBoolean(TCP_BLOCKING, false)));\n        String port = settings.get(\"port\");\n        String bindHost = settings.get(\"bind_host\");\n        String publishHost = settings.get(\"publish_host\");\n        String tcpNoDelay = settings.get(\"tcp_no_delay\");\n        String tcpKeepAlive = settings.get(\"tcp_keep_alive\");\n        Boolean reuseAddress = settings.getAsBoolean(\"reuse_address\", NetworkUtils.defaultReuseAddress());\n        ByteSizeValue tcpSendBufferSize = settings.getAsBytesSize(\"tcp_send_buffer_size\", TCP_DEFAULT_SEND_BUFFER_SIZE);\n        ByteSizeValue tcpReceiveBufferSize = settings.getAsBytesSize(\"tcp_receive_buffer_size\", TCP_DEFAULT_RECEIVE_BUFFER_SIZE);\n\n        logger.debug(\"using profile[{}], worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}/{}], receive_predictor[{}->{}]\",\n                name, workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeRecovery, connectionsPerNodeBulk, connectionsPerNodeReg, connectionsPerNodeState, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);\n\n        final ThreadFactory bossFactory = daemonThreadFactory(this.settings, HTTP_SERVER_BOSS_THREAD_NAME_PREFIX, name);\n        final ThreadFactory workerFactory = daemonThreadFactory(this.settings, HTTP_SERVER_WORKER_THREAD_NAME_PREFIX, name);\n        ServerBootstrap serverBootstrap;\n        if (blockingServer) {\n            serverBootstrap = new ServerBootstrap(new OioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(bossFactory),\n                    Executors.newCachedThreadPool(workerFactory)\n            ));\n        } else {\n            serverBootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(bossFactory),\n                    Executors.newCachedThreadPool(workerFactory),\n                    workerCount));\n        }\n        serverBootstrap.setPipelineFactory(configureServerChannelPipelineFactory(name, settings));\n        if (!\"default\".equals(tcpNoDelay)) {\n            serverBootstrap.setOption(\"child.tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n        if (!\"default\".equals(tcpKeepAlive)) {\n            serverBootstrap.setOption(\"child.keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n        serverBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"child.receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        if (reuseAddress != null) {\n            serverBootstrap.setOption(\"reuseAddress\", reuseAddress);\n            serverBootstrap.setOption(\"child.reuseAddress\", reuseAddress);\n        }\n\n        serverBootstraps.put(name, serverBootstrap);\n    }","id":89367,"modified_method":"private void createServerBootstrap(String name, Settings settings) {\n        boolean blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", this.settings.getAsBoolean(TCP_BLOCKING_SERVER, this.settings.getAsBoolean(TCP_BLOCKING, false)));\n        String port = settings.get(\"port\");\n        String bindHost = settings.get(\"bind_host\");\n        String publishHost = settings.get(\"publish_host\");\n        String tcpNoDelay = settings.get(\"tcp_no_delay\");\n        String tcpKeepAlive = settings.get(\"tcp_keep_alive\");\n        boolean reuseAddress = settings.getAsBoolean(\"reuse_address\", NetworkUtils.defaultReuseAddress());\n        ByteSizeValue tcpSendBufferSize = settings.getAsBytesSize(\"tcp_send_buffer_size\", TCP_DEFAULT_SEND_BUFFER_SIZE);\n        ByteSizeValue tcpReceiveBufferSize = settings.getAsBytesSize(\"tcp_receive_buffer_size\", TCP_DEFAULT_RECEIVE_BUFFER_SIZE);\n\n        logger.debug(\"using profile[{}], worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}/{}], receive_predictor[{}->{}]\",\n                name, workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeRecovery, connectionsPerNodeBulk, connectionsPerNodeReg, connectionsPerNodeState, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);\n\n        final ThreadFactory bossFactory = daemonThreadFactory(this.settings, HTTP_SERVER_BOSS_THREAD_NAME_PREFIX, name);\n        final ThreadFactory workerFactory = daemonThreadFactory(this.settings, HTTP_SERVER_WORKER_THREAD_NAME_PREFIX, name);\n        ServerBootstrap serverBootstrap;\n        if (blockingServer) {\n            serverBootstrap = new ServerBootstrap(new OioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(bossFactory),\n                    Executors.newCachedThreadPool(workerFactory)\n            ));\n        } else {\n            serverBootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(\n                    Executors.newCachedThreadPool(bossFactory),\n                    Executors.newCachedThreadPool(workerFactory),\n                    workerCount));\n        }\n        serverBootstrap.setPipelineFactory(configureServerChannelPipelineFactory(name, settings));\n        if (!\"default\".equals(tcpNoDelay)) {\n            serverBootstrap.setOption(\"child.tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n        if (!\"default\".equals(tcpKeepAlive)) {\n            serverBootstrap.setOption(\"child.keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            serverBootstrap.setOption(\"child.receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n        serverBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"child.receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n        serverBootstrap.setOption(\"reuseAddress\", reuseAddress);\n        serverBootstrap.setOption(\"child.reuseAddress\", reuseAddress);\n\n        serverBootstraps.put(name, serverBootstrap);\n    }","commit_id":"a40ba3be5aecc00e9b0b7ef79a0220d09159e327","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private ClientBootstrap createClientBootstrap() {\n\n        if (blockingClient) {\n            clientBootstrap = new ClientBootstrap(new OioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX))));\n        } else {\n            int bossCount = settings.getAsInt(\"transport.netty.boss_count\", 1);\n            clientBootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)),\n                    bossCount,\n                    new NioWorkerPool(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX)), workerCount),\n                    new HashedWheelTimer(daemonThreadFactory(settings, \"transport_client_timer\"))));\n        }\n        clientBootstrap.setPipelineFactory(configureClientChannelPipelineFactory());\n        clientBootstrap.setOption(\"connectTimeoutMillis\", connectTimeout.millis());\n\n        String tcpNoDelay = settings.get(\"transport.netty.tcp_no_delay\", settings.get(TCP_NO_DELAY, \"true\"));\n        if (!\"default\".equals(tcpNoDelay)) {\n            clientBootstrap.setOption(\"tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n\n        String tcpKeepAlive = settings.get(\"transport.netty.tcp_keep_alive\", settings.get(TCP_KEEP_ALIVE, \"true\"));\n        if (!\"default\".equals(tcpKeepAlive)) {\n            clientBootstrap.setOption(\"keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n\n        ByteSizeValue tcpSendBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n\n        ByteSizeValue tcpReceiveBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n\n        clientBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n\n        Boolean reuseAddress = settings.getAsBoolean(\"transport.netty.reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        if (reuseAddress != null) {\n            clientBootstrap.setOption(\"reuseAddress\", reuseAddress);\n        }\n\n        return clientBootstrap;\n    }","id":89368,"modified_method":"private ClientBootstrap createClientBootstrap() {\n\n        if (blockingClient) {\n            clientBootstrap = new ClientBootstrap(new OioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX))));\n        } else {\n            int bossCount = settings.getAsInt(\"transport.netty.boss_count\", 1);\n            clientBootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(\n                    Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)),\n                    bossCount,\n                    new NioWorkerPool(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX)), workerCount),\n                    new HashedWheelTimer(daemonThreadFactory(settings, \"transport_client_timer\"))));\n        }\n        clientBootstrap.setPipelineFactory(configureClientChannelPipelineFactory());\n        clientBootstrap.setOption(\"connectTimeoutMillis\", connectTimeout.millis());\n\n        String tcpNoDelay = settings.get(\"transport.netty.tcp_no_delay\", settings.get(TCP_NO_DELAY, \"true\"));\n        if (!\"default\".equals(tcpNoDelay)) {\n            clientBootstrap.setOption(\"tcpNoDelay\", Booleans.parseBoolean(tcpNoDelay, null));\n        }\n\n        String tcpKeepAlive = settings.get(\"transport.netty.tcp_keep_alive\", settings.get(TCP_KEEP_ALIVE, \"true\"));\n        if (!\"default\".equals(tcpKeepAlive)) {\n            clientBootstrap.setOption(\"keepAlive\", Booleans.parseBoolean(tcpKeepAlive, null));\n        }\n\n        ByteSizeValue tcpSendBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"sendBufferSize\", tcpSendBufferSize.bytes());\n        }\n\n        ByteSizeValue tcpReceiveBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {\n            clientBootstrap.setOption(\"receiveBufferSize\", tcpReceiveBufferSize.bytes());\n        }\n\n        clientBootstrap.setOption(\"receiveBufferSizePredictorFactory\", receiveBufferSizePredictorFactory);\n\n        boolean reuseAddress = settings.getAsBoolean(\"transport.netty.reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        clientBootstrap.setOption(\"reuseAddress\", reuseAddress);\n\n        return clientBootstrap;\n    }","commit_id":"a40ba3be5aecc00e9b0b7ef79a0220d09159e327","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private Settings createFallbackSettings() {\n        ImmutableSettings.Builder fallbackSettingsBuilder = settingsBuilder();\n\n        String fallbackBindHost = settings.get(\"transport.netty.bind_host\", settings.get(\"transport.bind_host\", settings.get(\"transport.host\")));\n        if (fallbackBindHost != null) {\n            fallbackSettingsBuilder.put(\"bind_host\", fallbackBindHost);\n        }\n\n        String fallbackPublishHost = settings.get(\"transport.netty.publish_host\", settings.get(\"transport.publish_host\", settings.get(\"transport.host\")));\n        if (fallbackPublishHost != null) {\n            fallbackSettingsBuilder.put(\"publish_host\", fallbackPublishHost);\n        }\n\n        String fallbackTcpNoDelay = settings.get(\"transport.netty.tcp_no_delay\", settings.get(TCP_NO_DELAY, \"true\"));\n        if (fallbackTcpNoDelay != null) {\n            fallbackSettingsBuilder.put(\"tcp_no_delay\", fallbackTcpNoDelay);\n        }\n\n        String fallbackTcpKeepAlive = settings.get(\"transport.netty.tcp_keep_alive\", settings.get(TCP_KEEP_ALIVE, \"true\"));\n        if (fallbackTcpKeepAlive != null) {\n            fallbackSettingsBuilder.put(\"tcp_keep_alive\", fallbackTcpKeepAlive);\n        }\n\n        Boolean fallbackReuseAddress = settings.getAsBoolean(\"transport.netty.reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        if (fallbackReuseAddress != null) {\n            fallbackSettingsBuilder.put(\"reuse_address\", fallbackReuseAddress);\n        }\n\n        ByteSizeValue fallbackTcpSendBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        if (fallbackTcpSendBufferSize != null) {\n            fallbackSettingsBuilder.put(\"tcp_send_buffer_size\", fallbackTcpSendBufferSize);\n        }\n\n        ByteSizeValue fallbackTcpBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        if (fallbackTcpBufferSize != null) {\n            fallbackSettingsBuilder.put(\"tcp_receive_buffer_size\", fallbackTcpBufferSize);\n        }\n\n        return fallbackSettingsBuilder.build();\n    }","id":89369,"modified_method":"private Settings createFallbackSettings() {\n        ImmutableSettings.Builder fallbackSettingsBuilder = settingsBuilder();\n\n        String fallbackBindHost = settings.get(\"transport.netty.bind_host\", settings.get(\"transport.bind_host\", settings.get(\"transport.host\")));\n        if (fallbackBindHost != null) {\n            fallbackSettingsBuilder.put(\"bind_host\", fallbackBindHost);\n        }\n\n        String fallbackPublishHost = settings.get(\"transport.netty.publish_host\", settings.get(\"transport.publish_host\", settings.get(\"transport.host\")));\n        if (fallbackPublishHost != null) {\n            fallbackSettingsBuilder.put(\"publish_host\", fallbackPublishHost);\n        }\n\n        String fallbackTcpNoDelay = settings.get(\"transport.netty.tcp_no_delay\", settings.get(TCP_NO_DELAY, \"true\"));\n        if (fallbackTcpNoDelay != null) {\n            fallbackSettingsBuilder.put(\"tcp_no_delay\", fallbackTcpNoDelay);\n        }\n\n        String fallbackTcpKeepAlive = settings.get(\"transport.netty.tcp_keep_alive\", settings.get(TCP_KEEP_ALIVE, \"true\"));\n        if (fallbackTcpKeepAlive != null) {\n            fallbackSettingsBuilder.put(\"tcp_keep_alive\", fallbackTcpKeepAlive);\n        }\n\n        boolean fallbackReuseAddress = settings.getAsBoolean(\"transport.netty.reuse_address\", settings.getAsBoolean(TCP_REUSE_ADDRESS, NetworkUtils.defaultReuseAddress()));\n        fallbackSettingsBuilder.put(\"reuse_address\", fallbackReuseAddress);\n\n        ByteSizeValue fallbackTcpSendBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_send_buffer_size\", settings.getAsBytesSize(TCP_SEND_BUFFER_SIZE, TCP_DEFAULT_SEND_BUFFER_SIZE));\n        if (fallbackTcpSendBufferSize != null) {\n            fallbackSettingsBuilder.put(\"tcp_send_buffer_size\", fallbackTcpSendBufferSize);\n        }\n\n        ByteSizeValue fallbackTcpBufferSize = settings.getAsBytesSize(\"transport.netty.tcp_receive_buffer_size\", settings.getAsBytesSize(TCP_RECEIVE_BUFFER_SIZE, TCP_DEFAULT_RECEIVE_BUFFER_SIZE));\n        if (fallbackTcpBufferSize != null) {\n            fallbackSettingsBuilder.put(\"tcp_receive_buffer_size\", fallbackTcpBufferSize);\n        }\n\n        return fallbackSettingsBuilder.build();\n    }","commit_id":"a40ba3be5aecc00e9b0b7ef79a0220d09159e327","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static Boolean defaultReuseAddress() {\n        return Constants.WINDOWS ? null : true;\n    }","id":89370,"modified_method":"public static boolean defaultReuseAddress() {\n        return Constants.WINDOWS ? false : true;\n    }","commit_id":"a40ba3be5aecc00e9b0b7ef79a0220d09159e327","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final Switchboard sb = (Switchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n         \r\n        \r\n        // get the virtualHost string\r\n        final String virtualHost = sb.getConfig(\"fileHost\", \"localhost\");\r\n        \r\n        \r\n        // server sessions\r\n        // get the serverCore thread\r\n        final WorkflowThread httpd = sb.getThread(\"10_httpd\");\r\n        \r\n        /* waiting for all threads to finish */\r\n        int count  = serverCore.sessionThreadGroup.activeCount();    \r\n        final Thread[] threadList = new Thread[((serverCore) httpd).getJobCount()];     \r\n        count = serverCore.sessionThreadGroup.enumerate(threadList);\r\n        \r\n        // determines if name lookup should be done or not \r\n        boolean doNameLookup = false;\r\n        if (post != null) {  \r\n            if (post.containsKey(\"nameLookup\") && post.get(\"nameLookup\",\"true\").equals(\"true\")) {\r\n                doNameLookup = true;\r\n            }\r\n            if (post.containsKey(\"closeServerSession\")) {\r\n                final String sessionName = post.get(\"closeServerSession\", null);\r\n                sb.closeSessions(\"10_httpd\", sessionName);\r\n                prop.put(\"LOCATION\",\"\");\r\n                return prop;                \r\n            }\r\n        }  \r\n        \r\n        int idx = 0, numActiveRunning = 0, numActivePending = 0;\r\n        boolean dark = true;\r\n        for ( int currentThreadIdx = 0; currentThreadIdx < count; currentThreadIdx++ )  {\r\n            final Thread t = threadList[currentThreadIdx];\r\n            if ((t != null) && (t instanceof serverCore.Session) && (t.isAlive())) {\r\n                // get the session object\r\n                final Session s = ((Session) t);\r\n                \r\n                // get the session runtime\r\n                final long sessionTime = s.getTime();\r\n                \r\n                // getthe request command line\r\n                boolean blockingRequest = false;\r\n                String commandLine = s.getCommandLine();\r\n                if (commandLine == null) blockingRequest = true;                \r\n                final int commandCount = s.getCommandCount();\r\n                \r\n                // get the source ip address and port\r\n                final InetAddress userAddress = s.getUserAddress();\r\n                final int userPort = s.getUserPort();\r\n                if (userAddress == null) continue;\r\n                \r\n                final boolean isSSL = s.isSSL();\r\n                \r\n                String dest = null;\r\n                String prot = null;\r\n                final serverHandler cmdObj = s.getCommandObj();\r\n                if (cmdObj instanceof HTTPDemon) {\r\n                    prot = isSSL ? \"https\":\"http\";\r\n                    \r\n                    // get the http command object\r\n                    final HTTPDemon currentHttpd =  (HTTPDemon)cmdObj;\r\n                    \r\n                    // get the connection properties of this session\r\n                    final Properties conProp = (Properties) currentHttpd.getConProp().clone();\r\n                    \r\n                    // get the destination host\r\n                    dest = conProp.getProperty(HeaderFramework.CONNECTION_PROP_HOST);\r\n                    if (dest==null)continue;\r\n                }            \r\n                \r\n                if ((dest != null) && (dest.equals(virtualHost))) dest = sb.peers.mySeed().getName() + \".yacy\";\r\n                \r\n                // determining if the source is a yacy host\r\n                yacySeed seed = null;\r\n                if (doNameLookup) {\r\n                    seed = sb.peers.lookupByIP(userAddress,true,false,false);\r\n                    if (seed != null) {\r\n                        if ((seed.hash.equals(sb.peers.mySeed().hash)) && \r\n                                (!seed.get(yacySeed.PORT,\"\").equals(Integer.toString(userPort)))) {\r\n                            seed = null;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                prop.put(\"list_\" + idx + \"_dark\", dark ? \"1\" : \"0\");\r\n                dark=!dark;\r\n                try {\r\n                    prop.put(\"list_\" + idx + \"_serverSessionID\",URLEncoder.encode(s.getName(),\"UTF8\"));\r\n                } catch (final UnsupportedEncodingException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n                prop.putHTML(\"list_\" + idx + \"_sessionName\", s.getName());\r\n                prop.put(\"list_\" + idx + \"_proto\", prot);\r\n                if (sessionTime > 1000*60) {\r\n                    prop.put(\"list_\" + idx + \"_ms\", \"0\");\r\n                    prop.put(\"list_\" + idx + \"_ms_duration\",DateFormatter.formatInterval(sessionTime));\r\n                } else {\r\n                    prop.put(\"list_\" + idx + \"_ms\", \"1\");\r\n                    prop.putNum(\"list_\" + idx + \"_ms_duration\", sessionTime);\r\n                }\r\n                prop.putHTML(\"list_\" + idx + \"_source\",(seed!=null)?seed.getName()+\".yacy\":userAddress.getHostAddress()+\":\"+userPort);\r\n                prop.putHTML(\"list_\" + idx + \"_dest\",(dest==null)?\"-\":dest);\r\n                if (blockingRequest) {\r\n                    prop.put(\"list_\" + idx + \"_running\", \"0\");\r\n                    prop.putNum(\"list_\" + idx + \"_running_reqNr\", commandCount+1);\r\n                    numActivePending++;\r\n                } else {\r\n                    prop.put(\"list_\" + idx + \"_running\", \"1\");\r\n                    prop.put(\"list_\" + idx + \"_running_command\", commandLine==null ? \"\" :commandLine);\r\n                    numActiveRunning++;\r\n                }\r\n                prop.putNum(\"list_\" + idx + \"_used\", commandCount);\r\n                idx++;                \r\n            }\r\n        }     \r\n        prop.put(\"list\", idx);\r\n        \r\n        prop.putNum(\"numMax\", ((serverCore)httpd).getMaxSessionCount());\r\n        prop.putNum(\"numActiveRunning\", numActiveRunning);\r\n        prop.putNum(\"numActivePending\", numActivePending);\r\n        \r\n        // client sessions\r\n        final Set<ConnectionInfo> allConnections = ConnectionInfo.getAllConnections();\r\n        // TODO sorting\r\n//        Arrays.sort(a, httpc.connectionTimeComparatorInstance);\r\n        int c = 0;\r\n        synchronized (allConnections) {\r\n        for (final ConnectionInfo conInfo: allConnections) {\r\n            prop.put(\"clientList_\" + c + \"_clientProtocol\", conInfo.getProtocol());\r\n            prop.putNum(\"clientList_\" + c + \"_clientLifetime\", conInfo.getLifetime());\r\n            prop.putNum(\"clientList_\" + c + \"_clientIdletime\", conInfo.getIdletime());\r\n            prop.put(\"clientList_\" + c + \"_clientTargetHost\", conInfo.getTargetHost());\r\n            prop.putHTML(\"clientList_\" + c + \"_clientCommand\", conInfo.getCommand());\r\n            prop.put(\"clientList_\" + c + \"_clientID\", conInfo.getID());\r\n            c++;\r\n        }\r\n        }\r\n        prop.put(\"clientList\", c);\r\n        prop.put(\"clientActive\", Client.connectionCount());\r\n        \r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","id":89371,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        final Switchboard sb = (Switchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n         \r\n        \r\n        // get the virtualHost string\r\n        final String virtualHost = sb.getConfig(\"fileHost\", \"localhost\");\r\n        \r\n        \r\n        // server sessions\r\n        // get the serverCore thread\r\n        final WorkflowThread httpd = sb.getThread(\"10_httpd\");\r\n        \r\n        // determines if name lookup should be done or not \r\n        boolean doNameLookup = false;\r\n        if (post != null) {  \r\n            if (post.containsKey(\"nameLookup\") && post.get(\"nameLookup\",\"true\").equals(\"true\")) {\r\n                doNameLookup = true;\r\n            }\r\n            if (post.containsKey(\"closeServerSession\")) {\r\n                final String sessionName = post.get(\"closeServerSession\", null);\r\n                sb.closeSessions(\"10_httpd\", sessionName);\r\n                prop.put(\"LOCATION\",\"\");\r\n                return prop;                \r\n            }\r\n        }  \r\n        \r\n        // waiting for all threads to finish\r\n        int idx = 0, numActiveRunning = 0, numActivePending = 0;\r\n        boolean dark = true;\r\n        for (Session s: ((serverCore) httpd).getJobList()) {\r\n            if (!s.isAlive()) continue;\r\n            \r\n            // get the session runtime\r\n            final long sessionTime = s.getTime();\r\n            \r\n            // getthe request command line\r\n            boolean blockingRequest = false;\r\n            String commandLine = s.getCommandLine();\r\n            if (commandLine == null) blockingRequest = true;                \r\n            final int commandCount = s.getCommandCount();\r\n            \r\n            // get the source ip address and port\r\n            final InetAddress userAddress = s.getUserAddress();\r\n            final int userPort = s.getUserPort();\r\n            if (userAddress == null) continue;\r\n            \r\n            final boolean isSSL = s.isSSL();\r\n            \r\n            String dest = null;\r\n            String prot = null;\r\n            final serverHandler cmdObj = s.getCommandObj();\r\n            if (cmdObj instanceof HTTPDemon) {\r\n                prot = isSSL ? \"https\":\"http\";\r\n                \r\n                // get the http command object\r\n                final HTTPDemon currentHttpd =  (HTTPDemon)cmdObj;\r\n                \r\n                // get the connection properties of this session\r\n                final Properties conProp = (Properties) currentHttpd.getConProp().clone();\r\n                \r\n                // get the destination host\r\n                dest = conProp.getProperty(HeaderFramework.CONNECTION_PROP_HOST);\r\n                if (dest==null)continue;\r\n            }            \r\n            \r\n            if ((dest != null) && (dest.equals(virtualHost))) dest = sb.peers.mySeed().getName() + \".yacy\";\r\n            \r\n            // determining if the source is a yacy host\r\n            yacySeed seed = null;\r\n            if (doNameLookup) {\r\n                seed = sb.peers.lookupByIP(userAddress,true,false,false);\r\n                if (seed != null) {\r\n                    if ((seed.hash.equals(sb.peers.mySeed().hash)) && \r\n                            (!seed.get(yacySeed.PORT,\"\").equals(Integer.toString(userPort)))) {\r\n                        seed = null;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            prop.put(\"list_\" + idx + \"_dark\", dark ? \"1\" : \"0\");\r\n            dark=!dark;\r\n            try {\r\n                prop.put(\"list_\" + idx + \"_serverSessionID\",URLEncoder.encode(s.getName(),\"UTF8\"));\r\n            } catch (final UnsupportedEncodingException e) {\r\n                // TODO Auto-generated catch block\r\n                e.printStackTrace();\r\n            }\r\n            prop.putHTML(\"list_\" + idx + \"_sessionName\", s.getName());\r\n            prop.put(\"list_\" + idx + \"_proto\", prot);\r\n            if (sessionTime > 1000*60) {\r\n                prop.put(\"list_\" + idx + \"_ms\", \"0\");\r\n                prop.put(\"list_\" + idx + \"_ms_duration\",DateFormatter.formatInterval(sessionTime));\r\n            } else {\r\n                prop.put(\"list_\" + idx + \"_ms\", \"1\");\r\n                prop.putNum(\"list_\" + idx + \"_ms_duration\", sessionTime);\r\n            }\r\n            prop.putHTML(\"list_\" + idx + \"_source\",(seed!=null)?seed.getName()+\".yacy\":userAddress.getHostAddress()+\":\"+userPort);\r\n            prop.putHTML(\"list_\" + idx + \"_dest\",(dest==null)?\"-\":dest);\r\n            if (blockingRequest) {\r\n                prop.put(\"list_\" + idx + \"_running\", \"0\");\r\n                prop.putNum(\"list_\" + idx + \"_running_reqNr\", commandCount+1);\r\n                numActivePending++;\r\n            } else {\r\n                prop.put(\"list_\" + idx + \"_running\", \"1\");\r\n                prop.put(\"list_\" + idx + \"_running_command\", commandLine==null ? \"\" :commandLine);\r\n                numActiveRunning++;\r\n            }\r\n            prop.putNum(\"list_\" + idx + \"_used\", commandCount);\r\n            idx++;\r\n        }     \r\n        prop.put(\"list\", idx);\r\n        \r\n        prop.putNum(\"numMax\", ((serverCore)httpd).getMaxSessionCount());\r\n        prop.putNum(\"numActiveRunning\", numActiveRunning);\r\n        prop.putNum(\"numActivePending\", numActivePending);\r\n        \r\n        // client sessions\r\n        final Set<ConnectionInfo> allConnections = ConnectionInfo.getAllConnections();\r\n        // TODO sorting\r\n//        Arrays.sort(a, httpc.connectionTimeComparatorInstance);\r\n        int c = 0;\r\n        synchronized (allConnections) {\r\n        for (final ConnectionInfo conInfo: allConnections) {\r\n            prop.put(\"clientList_\" + c + \"_clientProtocol\", conInfo.getProtocol());\r\n            prop.putNum(\"clientList_\" + c + \"_clientLifetime\", conInfo.getLifetime());\r\n            prop.putNum(\"clientList_\" + c + \"_clientIdletime\", conInfo.getIdletime());\r\n            prop.put(\"clientList_\" + c + \"_clientTargetHost\", conInfo.getTargetHost());\r\n            prop.putHTML(\"clientList_\" + c + \"_clientCommand\", conInfo.getCommand());\r\n            prop.put(\"clientList_\" + c + \"_clientID\", conInfo.getID());\r\n            c++;\r\n        }\r\n        }\r\n        prop.put(\"clientList\", c);\r\n        prop.put(\"clientActive\", Client.connectionCount());\r\n        \r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","commit_id":"f0b8db93f040f5efd82de2947caec8626e3cae9c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void listen() {\r\n            try {\r\n                // start dialog\r\n                byte[] requestBytes = null;\r\n                boolean terminate = false;\r\n                String reqCmd;\r\n                String reqProtocol = \"HTTP\";\r\n                final Object[] stringParameter = new String[1];\r\n                long situationDependentKeepAliveTimeout = keepAliveTimeout;\r\n                while (this.in != null &&\r\n                       this.controlSocket != null &&\r\n                       this.controlSocket.isConnected() &&\r\n                       (this.commandCounter == 0 || System.currentTimeMillis() - this.start < situationDependentKeepAliveTimeout) &&\r\n                       (requestBytes = readLine()) != null) {\r\n                    this.setName(\"Session_\" + this.userAddress.getHostAddress() + \r\n                            \":\" + this.controlSocket.getPort() + \r\n                            \"#\" + this.commandCounter);\r\n                    \r\n                    this.request = new String(requestBytes);\r\n                    //this.log.logDebug(\"* session \" + handle + \" received command '\" + request + \"'. time = \" + (System.currentTimeMillis() - handle));\r\n                    log(false, this.request);\r\n                    try {                        \r\n                        // if we can not determine the proper command string we try to call function emptyRequest\r\n                        // of the commandObject\r\n                        if (this.request.trim().length() == 0) this.request = \"EMPTY\";\r\n                        \r\n                        // getting the rest of the request parameters\r\n                        final int pos = this.request.indexOf(' ');\r\n                        if (pos < 0) {\r\n                            reqCmd = this.request.trim().toUpperCase();\r\n                            stringParameter[0] = \"\";\r\n                        } else {\r\n                            reqCmd = this.request.substring(0, pos).trim().toUpperCase();\r\n                            stringParameter[0] = this.request.substring(pos).trim();\r\n                        }\r\n                        \r\n                        // now we need to initialize the session\r\n                        if (this.commandCounter == 0) {\r\n                            // first we need to determine the proper protocol handler\r\n                            if (this.request.indexOf(\"HTTP\") >= 0)          reqProtocol = \"HTTP\";\r\n                            else                                            reqProtocol = null;                            \r\n                            \r\n                            if (this.request == null) break;\r\n                            if (reqProtocol.equals(\"HTTP\")) {\r\n                                this.commandObj = handlerPrototype.clone();\r\n                            }\r\n                            \r\n                            // initializing the session\r\n                            this.commandObj.initSession(this); \r\n                        }\r\n                        \r\n                        // count the amount of requests that were processed by this session until yet\r\n                        this.commandCounter++;\r\n                        \r\n                        // setting the socket timeout for reading of the request content\r\n                        this.controlSocket.setSoTimeout(this.socketTimeout);\r\n                        \r\n                        // exec command and return value\r\n                        Object commandMethod = commandObjMethodCache.get(reqProtocol + \"_\" + reqCmd);\r\n                        if (commandMethod == null) {\r\n                            try {\r\n                                commandMethod = this.commandObj.getClass().getMethod(reqCmd, stringType);\r\n                                commandObjMethodCache.put(reqProtocol + \"_\" + reqCmd, commandMethod);\r\n                            } catch (final NoSuchMethodException noMethod) {\r\n                                commandMethod = this.commandObj.getClass().getMethod(\"UNKNOWN\", stringType);\r\n                                stringParameter[0] = this.request.trim();\r\n                            }\r\n                        }\r\n                        //long commandStart = System.currentTimeMillis();\r\n                        Object result = ((Method)commandMethod).invoke(this.commandObj, stringParameter);\r\n                        //announceMoreExecTime(commandStart - System.currentTimeMillis()); // shall be negative!\r\n                        //this.log.logDebug(\"* session \" + handle + \" completed command '\" + request + \"'. time = \" + (System.currentTimeMillis() - handle));\r\n                        this.out.flush();\r\n                        if (result != null) {\r\n                            if (result instanceof Boolean) {\r\n                                if (((Boolean) result).equals(TERMINATE_CONNECTION)) break;\r\n                                \r\n                                /* \r\n                                 * setting timeout to a very high level. \r\n                                 * this is needed because of persistent connection\r\n                                 * support.\r\n                                 */\r\n                                if (!this.controlSocket.isClosed()) this.controlSocket.setSoTimeout(30*60*1000);\r\n                            } else if (result instanceof String) {\r\n                                if (((String) result).startsWith(\"!\")) {\r\n                                    result = ((String) result).substring(1);\r\n                                    terminate = true;\r\n                                }\r\n                                writeLine((String) result);\r\n                            } else if (result instanceof InputStream) {\r\n                                String tmp = send(this.out, (InputStream) result);\r\n                                if ((tmp.length() > 4) && (tmp.toUpperCase().startsWith(\"PASS\"))) {\r\n                                    log(true, \"PASS ********\");\r\n                                } else {\r\n                                    log(true, tmp);\r\n                                }\r\n                                tmp = null;\r\n                            }\r\n                        }\r\n                        if (terminate) break;\r\n                        \r\n                        \r\n                    } catch (final InvocationTargetException e) {\r\n                        log.logSevere(\"command execution, target exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // we extract a target exception\r\n                        writeLine(this.commandObj.error(e.getTargetException()));\r\n                        break;\r\n                    } catch (final NoSuchMethodException e) {\r\n                        log.logSevere(\"command execution, method exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        if (!this.userAddress.isSiteLocalAddress()) {\r\n                            if (denyHost != null) {\r\n                                denyHost.put((\"\"+this.userAddress.getHostAddress()), \"deny\"); // block client: hacker attempt\r\n                            }\r\n                        }\r\n                        break;\r\n                    } catch (final IllegalAccessException e) {\r\n                        log.logSevere(\"command execution, illegal access exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // wrong parameters: this can only be an internal problem\r\n                        writeLine(this.commandObj.error(e));\r\n                        break;\r\n                    } catch (final java.lang.ClassCastException e) {\r\n                        log.logSevere(\"command execution, cast exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // ??\r\n                        writeLine(this.commandObj.error(e));\r\n                        break;\r\n                    } catch (final Exception e) {\r\n                        log.logSevere(\"command execution, generic exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // whatever happens: the thread has to survive!\r\n                        writeLine(\"UNKNOWN REASON:\" + this.commandObj.error(e));\r\n                        break;\r\n                    }\r\n                    // check if we should still keep this alive:\r\n                    // the more connections are alive, the shorter the keep alive timeout\r\n                    situationDependentKeepAliveTimeout = keepAliveTimeout / Math.max(1, sessionThreadGroup.activeCount() - 20);\r\n                } // end of while\r\n            } catch (final IOException e) {\r\n                log.logSevere(\"command execution, IO exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n            }\r\n            //announceMoreExecTime(System.currentTimeMillis() - this.start);\r\n        }","id":89372,"modified_method":"private void listen() {\r\n            try {\r\n                // start dialog\r\n                byte[] requestBytes = null;\r\n                boolean terminate = false;\r\n                String reqCmd;\r\n                String reqProtocol = \"HTTP\";\r\n                final Object[] stringParameter = new String[1];\r\n                long situationDependentKeepAliveTimeout = keepAliveTimeout;\r\n                while (this.in != null &&\r\n                       this.controlSocket != null &&\r\n                       this.controlSocket.isConnected() &&\r\n                       (this.commandCounter == 0 || System.currentTimeMillis() - this.start < situationDependentKeepAliveTimeout) &&\r\n                       (requestBytes = readLine()) != null) {\r\n                    this.setName(\"Session_\" + this.userAddress.getHostAddress() + \r\n                            \":\" + this.controlSocket.getPort() + \r\n                            \"#\" + this.commandCounter);\r\n                    \r\n                    this.request = new String(requestBytes);\r\n                    //this.log.logDebug(\"* session \" + handle + \" received command '\" + request + \"'. time = \" + (System.currentTimeMillis() - handle));\r\n                    log(false, this.request);\r\n                    try {                        \r\n                        // if we can not determine the proper command string we try to call function emptyRequest\r\n                        // of the commandObject\r\n                        if (this.request.trim().length() == 0) this.request = \"EMPTY\";\r\n                        \r\n                        // getting the rest of the request parameters\r\n                        final int pos = this.request.indexOf(' ');\r\n                        if (pos < 0) {\r\n                            reqCmd = this.request.trim().toUpperCase();\r\n                            stringParameter[0] = \"\";\r\n                        } else {\r\n                            reqCmd = this.request.substring(0, pos).trim().toUpperCase();\r\n                            stringParameter[0] = this.request.substring(pos).trim();\r\n                        }\r\n                        \r\n                        // now we need to initialize the session\r\n                        if (this.commandCounter == 0) {\r\n                            // first we need to determine the proper protocol handler\r\n                            if (this.request.indexOf(\"HTTP\") >= 0)          reqProtocol = \"HTTP\";\r\n                            else                                            reqProtocol = null;                            \r\n                            \r\n                            if (this.request == null) break;\r\n                            if (reqProtocol.equals(\"HTTP\")) {\r\n                                this.commandObj = handlerPrototype.clone();\r\n                            }\r\n                            \r\n                            // initializing the session\r\n                            this.commandObj.initSession(this); \r\n                        }\r\n                        \r\n                        // count the amount of requests that were processed by this session until yet\r\n                        this.commandCounter++;\r\n                        \r\n                        // setting the socket timeout for reading of the request content\r\n                        this.controlSocket.setSoTimeout(this.socketTimeout);\r\n                        \r\n                        // exec command and return value\r\n                        Object commandMethod = commandObjMethodCache.get(reqProtocol + \"_\" + reqCmd);\r\n                        if (commandMethod == null) {\r\n                            try {\r\n                                commandMethod = this.commandObj.getClass().getMethod(reqCmd, stringType);\r\n                                commandObjMethodCache.put(reqProtocol + \"_\" + reqCmd, commandMethod);\r\n                            } catch (final NoSuchMethodException noMethod) {\r\n                                commandMethod = this.commandObj.getClass().getMethod(\"UNKNOWN\", stringType);\r\n                                stringParameter[0] = this.request.trim();\r\n                            }\r\n                        }\r\n                        //long commandStart = System.currentTimeMillis();\r\n                        Object result = ((Method)commandMethod).invoke(this.commandObj, stringParameter);\r\n                        //announceMoreExecTime(commandStart - System.currentTimeMillis()); // shall be negative!\r\n                        //this.log.logDebug(\"* session \" + handle + \" completed command '\" + request + \"'. time = \" + (System.currentTimeMillis() - handle));\r\n                        this.out.flush();\r\n                        if (result != null) {\r\n                            if (result instanceof Boolean) {\r\n                                if (((Boolean) result).equals(TERMINATE_CONNECTION)) break;\r\n                                \r\n                                /* \r\n                                 * setting timeout to a very high level. \r\n                                 * this is needed because of persistent connection\r\n                                 * support.\r\n                                 */\r\n                                if (!this.controlSocket.isClosed()) this.controlSocket.setSoTimeout(30*60*1000);\r\n                            } else if (result instanceof String) {\r\n                                if (((String) result).startsWith(\"!\")) {\r\n                                    result = ((String) result).substring(1);\r\n                                    terminate = true;\r\n                                }\r\n                                writeLine((String) result);\r\n                            } else if (result instanceof InputStream) {\r\n                                String tmp = send(this.out, (InputStream) result);\r\n                                if ((tmp.length() > 4) && (tmp.toUpperCase().startsWith(\"PASS\"))) {\r\n                                    log(true, \"PASS ********\");\r\n                                } else {\r\n                                    log(true, tmp);\r\n                                }\r\n                                tmp = null;\r\n                            }\r\n                        }\r\n                        if (terminate) break;\r\n                        \r\n                        \r\n                    } catch (final InvocationTargetException e) {\r\n                        log.logSevere(\"command execution, target exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // we extract a target exception\r\n                        writeLine(this.commandObj.error(e.getTargetException()));\r\n                        break;\r\n                    } catch (final NoSuchMethodException e) {\r\n                        log.logSevere(\"command execution, method exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        if (!this.userAddress.isSiteLocalAddress()) {\r\n                            if (denyHost != null) {\r\n                                denyHost.put((\"\"+this.userAddress.getHostAddress()), \"deny\"); // block client: hacker attempt\r\n                            }\r\n                        }\r\n                        break;\r\n                    } catch (final IllegalAccessException e) {\r\n                        log.logSevere(\"command execution, illegal access exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // wrong parameters: this can only be an internal problem\r\n                        writeLine(this.commandObj.error(e));\r\n                        break;\r\n                    } catch (final java.lang.ClassCastException e) {\r\n                        log.logSevere(\"command execution, cast exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // ??\r\n                        writeLine(this.commandObj.error(e));\r\n                        break;\r\n                    } catch (final Exception e) {\r\n                        log.logSevere(\"command execution, generic exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n                        // whatever happens: the thread has to survive!\r\n                        writeLine(\"UNKNOWN REASON:\" + this.commandObj.error(e));\r\n                        break;\r\n                    }\r\n                    // check if we should still keep this alive:\r\n                    if (sessionThreadGroup.activeCount() > maxBusySessions / 2) break;\r\n                    // the more connections are alive, the shorter the keep alive timeout\r\n                    situationDependentKeepAliveTimeout = keepAliveTimeout / Math.max(1, sessionThreadGroup.activeCount() - 20);\r\n                } // end of while\r\n            } catch (final IOException e) {\r\n                log.logSevere(\"command execution, IO exception \" + e.getMessage() + \" for client \" + this.userAddress.getHostAddress(), e);\r\n            }\r\n            //announceMoreExecTime(System.currentTimeMillis() - this.start);\r\n        }","commit_id":"f0b8db93f040f5efd82de2947caec8626e3cae9c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public serverCore( \r\n            final int timeout,\r\n            final boolean blockAttack,\r\n            final serverHandler handlerPrototype, \r\n            final serverSwitch switchboard,\r\n            final int commandMaxLength\r\n    ) {\r\n        this.timeout = timeout;\r\n        \r\n        this.commandMaxLength = commandMaxLength;\r\n        this.denyHost = (blockAttack) ? new HashMap<String, String>() : null;\r\n        this.handlerPrototype = handlerPrototype;\r\n        this.switchboard = switchboard;\r\n        \r\n        // initialize logger\r\n        this.log = new Log(\"SERVER\");\r\n\r\n        // init the ssl socket factory\r\n        this.sslSocketFactory = initSSLFactory();\r\n\r\n        // init session parameter\r\n        maxBusySessions = Math.max(1, Integer.valueOf(switchboard.getConfig(\"httpdMaxBusySessions\",\"100\")).intValue());\r\n        \r\n        this.lastAutoTermination = System.currentTimeMillis();\r\n        \r\n        // init servercore\r\n        init();\r\n    }","id":89373,"modified_method":"public serverCore( \r\n            final int timeout,\r\n            final boolean blockAttack,\r\n            final serverHandler handlerPrototype, \r\n            final serverSwitch switchboard,\r\n            final int commandMaxLength\r\n    ) {\r\n        this.timeout = timeout;\r\n        \r\n        this.commandMaxLength = commandMaxLength;\r\n        this.denyHost = (blockAttack) ? new HashMap<String, String>() : null;\r\n        this.handlerPrototype = handlerPrototype;\r\n        this.switchboard = switchboard;\r\n        \r\n        // initialize logger\r\n        this.log = new Log(\"SERVER\");\r\n\r\n        // init the ssl socket factory\r\n        this.sslSocketFactory = initSSLFactory();\r\n\r\n        // init session parameter\r\n        this.maxBusySessions = Math.max(1, Integer.valueOf(switchboard.getConfig(\"httpdMaxBusySessions\",\"100\")).intValue());\r\n        \r\n        this.lastAutoTermination = System.currentTimeMillis();\r\n        \r\n        // init servercore\r\n        init();\r\n    }","commit_id":"f0b8db93f040f5efd82de2947caec8626e3cae9c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public String[] sessionsOlderThan(String threadName, long timeout) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        final WorkflowThread st = getThread(threadName);\r\n        final Thread[] threadList = new Thread[((serverCore) st).getJobCount()];\r\n        serverCore.sessionThreadGroup.enumerate(threadList);\r\n        \r\n        for (Thread t: threadList) {\r\n            if (t == null) continue;\r\n            if (!(t instanceof serverCore.Session)) continue;\r\n            if (!t.isAlive()) continue;\r\n            if (t == null) continue;\r\n            final Session s = (Session) t;\r\n            if (s.getTime() > timeout) {\r\n                list.add(s.getName());\r\n            }\r\n        }\r\n        return (String[]) list.toArray();\r\n    }","id":89374,"modified_method":"public String[] sessionsOlderThan(String threadName, long timeout) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        final WorkflowThread st = getThread(threadName);\r\n        \r\n        for (Session s: ((serverCore) st).getJobList()) {\r\n            if (!s.isAlive()) continue;\r\n            if (s.getTime() > timeout) {\r\n                list.add(s.getName());\r\n            }\r\n        }\r\n        return (String[]) list.toArray();\r\n    }","commit_id":"f0b8db93f040f5efd82de2947caec8626e3cae9c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void closeSessions(String threadName, String sessionName) {\r\n        if (sessionName == null) return;\r\n        final WorkflowThread st = getThread(threadName);\r\n        final Thread[] threadList = new Thread[((serverCore) st).getJobCount()];\r\n        serverCore.sessionThreadGroup.enumerate(threadList);\r\n        \r\n        for (Thread t: threadList) {\r\n            if (\r\n                (t != null) && \r\n                (t instanceof serverCore.Session) && \r\n                (t.isAlive()) &&\r\n                (t.getName().equals(sessionName))\r\n            ) {\r\n                // try to stop session\r\n                ((Session)t).setStopped(true);\r\n                try { Thread.sleep(100); } catch (final InterruptedException ex) {}\r\n                \r\n                // try to interrupt session\r\n                if (t.isAlive()) {\r\n                    t.interrupt();\r\n                    try { Thread.sleep(100); } catch (final InterruptedException ex) {}\r\n                } \r\n                \r\n                // try to close socket\r\n                if (t.isAlive()) {\r\n                    ((Session)t).close();\r\n                }\r\n                \r\n                // wait for session to finish\r\n                if (t.isAlive()) {\r\n                    try { t.join(500); } catch (final InterruptedException ex) {}\r\n                }\r\n            }\r\n        }\r\n    }","id":89375,"modified_method":"public void closeSessions(String threadName, String sessionName) {\r\n        if (sessionName == null) return;\r\n        final WorkflowThread st = getThread(threadName);\r\n        \r\n        for (Session s: ((serverCore) st).getJobList()) {\r\n            if (\r\n                (s.isAlive()) &&\r\n                (s.getName().equals(sessionName))\r\n            ) {\r\n                // try to stop session\r\n                s.setStopped(true);\r\n                try { Thread.sleep(100); } catch (final InterruptedException ex) {}\r\n                \r\n                // try to interrupt session\r\n                s.interrupt();\r\n                try { Thread.sleep(100); } catch (final InterruptedException ex) {}\r\n                \r\n                // try to close socket\r\n                if (s.isAlive()) {\r\n                    s.close();\r\n                }\r\n                \r\n                // wait for session to finish\r\n                if (s.isAlive()) {\r\n                    try { s.join(500); } catch (final InterruptedException ex) {}\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"f0b8db93f040f5efd82de2947caec8626e3cae9c","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public AkromasBlessing(UUID ownerId) {\r\n        super(ownerId, 1, \"Akroma's Blessing\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{2}{W}\");\r\n        this.expansionSetCode = \"ONS\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Choose a color. Creatures you control gain protection from the chosen color until end of turn.\r\n        this.getSpellAbility().addEffect(new AcromasBlessingEffect());\r\n        // Cycling {W}\r\n        this.addAbility(new CyclingAbility(new ManaCostsImpl(\"{W}\")));\r\n    }","id":89376,"modified_method":"public AkromasBlessing(UUID ownerId) {\r\n        super(ownerId, 1, \"Akroma's Blessing\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{2}{W}\");\r\n        this.expansionSetCode = \"ONS\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Choose a color. Creatures you control gain protection from the chosen color until end of turn.\r\n        this.getSpellAbility().addEffect(new AkromasBlessingChooseColorEffect());\r\n        // Cycling {W}\r\n        this.addAbility(new CyclingAbility(new ManaCostsImpl(\"{W}\")));\r\n    }","commit_id":"28ed7f1b63fd8eecf155f645e9bd860f56edff9b","url":"https://github.com/magefree/mage"},{"original_method":"public BraveTheElements(UUID ownerId) {\n        super(ownerId, 4, \"Brave the Elements\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{W}\");\n        this.expansionSetCode = \"ZEN\";\n        this.color.setWhite(true);\n\n        // Choose a color. White creatures you control gain protection from the chosen color until end of turn.\n        this.getSpellAbility().addEffect(new BraveTheElementsEffect());\n    }","id":89377,"modified_method":"public BraveTheElements(UUID ownerId) {\n        super(ownerId, 4, \"Brave the Elements\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{W}\");\n        this.expansionSetCode = \"ZEN\";\n        this.color.setWhite(true);\n\n        // Choose a color. White creatures you control gain protection from the chosen color until end of turn.\n        this.getSpellAbility().addEffect(new BraveTheElementsChooseColorEffect());\n    }","commit_id":"28ed7f1b63fd8eecf155f645e9bd860f56edff9b","url":"https://github.com/magefree/mage"},{"original_method":"public CompoundAbility(String ruleText, Ability... abilities) {\n        for (Ability ability : abilities) {\n            add(ability);\n        }\n    }","id":89378,"modified_method":"public CompoundAbility(String ruleText, Ability... abilities) {\n        addAll(Arrays.asList(abilities));\n    }","commit_id":"28ed7f1b63fd8eecf155f645e9bd860f56edff9b","url":"https://github.com/magefree/mage"},{"original_method":"public KabiraEvangel(UUID ownerId) {\r\n        super(ownerId, 15, \"Kabira Evangel\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Cleric\");\r\n        this.subtype.add(\"Ally\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(3);\r\n\r\n        FilterPermanent filter = new FilterPermanent(\"Kabira Evangel or another Ally\");\r\n        filter.add(Predicates.or(\r\n        new CardIdPredicate(this.getId()),\r\n        new SubtypePredicate(\"Ally\")));\r\n\r\n        // Whenever Kabira Evangel or another Ally enters the battlefield under your control, you may choose a color. If you do, Allies you control gain protection from the chosen color until end of turn.\r\n        this.addAbility(new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, new ChooseColorEffect(), filter, true));\r\n    }","id":89379,"modified_method":"public KabiraEvangel(UUID ownerId) {\r\n        super(ownerId, 15, \"Kabira Evangel\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Cleric\");\r\n        this.subtype.add(\"Ally\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(3);\r\n\r\n        FilterPermanent filter = new FilterPermanent(getName() + \" or another Ally\");\r\n        filter.add(Predicates.or(\r\n        new CardIdPredicate(this.getId()),\r\n        new SubtypePredicate(\"Ally\")));\r\n\r\n        // Whenever Kabira Evangel or another Ally enters the battlefield under your control, you may choose a color. If you do, Allies you control gain protection from the chosen color until end of turn.\r\n        this.addAbility(new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, new KabiraEvangelChooseColorEffect(), filter, true));\r\n    }","commit_id":"28ed7f1b63fd8eecf155f645e9bd860f56edff9b","url":"https://github.com/magefree/mage"},{"original_method":"public PhantasmalTerrain(UUID ownerId) {\n        super(ownerId, 69, \"Phantasmal Terrain\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{U}{U}\");\n        this.expansionSetCode = \"LEA\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setBlue(true);\n\n        // Enchant land\n        TargetPermanent auraTarget = new TargetLandPermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));\n        this.addAbility(new EnchantAbility(auraTarget.getTargetName()));\n        \n        // As Phantasmal Terrain enters the battlefield, choose a basic land type.\n        this.addAbility(new AsEntersBattlefieldAbility(new PhantasmalTerrainChooseEffect()));\n        \n        // Enchanted land is the chosen type.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PhantasmalTerrainContinuousEffect()));\n    }","id":89380,"modified_method":"public PhantasmalTerrain(UUID ownerId) {\n        super(ownerId, 69, \"Phantasmal Terrain\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{U}{U}\");\n        this.expansionSetCode = \"LEA\";\n        this.subtype.add(\"Aura\");\n\n        // Enchant land\n        TargetPermanent auraTarget = new TargetLandPermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));\n        this.addAbility(new EnchantAbility(auraTarget.getTargetName()));\n        \n        // As Phantasmal Terrain enters the battlefield, choose a basic land type.\n        this.addAbility(new AsEntersBattlefieldAbility(new PhantasmalTerrainChooseEffect()));\n        \n        // Enchanted land is the chosen type.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PhantasmalTerrainContinuousEffect()));\n    }","commit_id":"887cc094c9fe56a070de79c73e577cda3ea52f52","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null) {\n            ChoiceImpl choices = new ChoiceImpl(true);\n            choices.setMessage(\"Choose basic land type\");\n            choices.isRequired();\n            choices.getChoices().add(\"Forest\");\n            choices.getChoices().add(\"Plains\");\n            choices.getChoices().add(\"Mountain\");\n            choices.getChoices().add(\"Island\");\n            choices.getChoices().add(\"Swamp\");\n            if (player.choose(Outcome.Neutral, choices, game)) {\n                game.informPlayers(new StringBuilder(\"Phantasmal Terrain: \").append(\" chosen basic land type is \").append(choices.getChoice()).toString());\n                game.getState().setValue(source.getSourceId().toString() + \"_PhantasmalTerrain\", choices.getChoice());\n                return true;\n            }\n        }\n        return false;\n    }","id":89381,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = source.getSourceObject(game);\n        if (sourceObject != null && controller != null) {\n            ChoiceImpl choices = new ChoiceImpl(true);\n            choices.setMessage(\"Choose basic land type\");\n            choices.getChoices().add(\"Forest\");\n            choices.getChoices().add(\"Plains\");\n            choices.getChoices().add(\"Mountain\");\n            choices.getChoices().add(\"Island\");\n            choices.getChoices().add(\"Swamp\");\n            if (controller.choose(Outcome.Neutral, choices, game)) {\n                game.informPlayers(sourceObject.getLogName() + \": chosen basic land type is \" + choices.getChoice());\n                game.getState().setValue(source.getSourceId().toString() + \"_PhantasmalTerrain\", choices.getChoice());\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"887cc094c9fe56a070de79c73e577cda3ea52f52","url":"https://github.com/magefree/mage"},{"original_method":"public PhantasmalTerrainContinuousEffect(){\n        super(Duration.WhileOnBattlefield, Outcome.Neutral);\n        this.staticText = \"Enchanted land is the chosen type.\";\n    }","id":89382,"modified_method":"public PhantasmalTerrainContinuousEffect(){\n        super(Duration.WhileOnBattlefield, Outcome.Neutral);\n        this.staticText = \"enchanted land is the chosen type\";\n    }","commit_id":"887cc094c9fe56a070de79c73e577cda3ea52f52","url":"https://github.com/magefree/mage"},{"original_method":"public PhantasmalTerrainChooseEffect() {\n        super(Outcome.Neutral);\n        this.staticText = \"choose a basic land type.\";\n    }","id":89383,"modified_method":"public PhantasmalTerrainChooseEffect() {\n        super(Outcome.Neutral);\n        this.staticText = \"choose a basic land type\";\n    }","commit_id":"887cc094c9fe56a070de79c73e577cda3ea52f52","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n        public void onChannelJoin(ChanJoinMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()))\n            {\n                String user = msg.getSource().getNick();\n\n                if (isMe(msg.getSource()))\n                {\n                    // I think that this should not happen.\n                }\n                else\n                {\n                    ChatRoomMemberIrcImpl member =\n                        new ChatRoomMemberIrcImpl(IrcStack.this.provider,\n                            this.chatroom, user,\n                            ChatRoomMemberRole.SILENT_MEMBER);\n                    this.chatroom.fireMemberPresenceEvent(member, null,\n                        ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED, null);\n                }\n            }\n        }","id":89384,"modified_method":"@Override\n        public void onChannelJoin(ChanJoinMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()) == false)\n                return;\n            \n            if (isMe(msg.getSource()))\n            {\n                // I think that this should not happen.\n            }\n            else\n            {\n                String user = msg.getSource().getNick();\n                ChatRoomMemberIrcImpl member =\n                    new ChatRoomMemberIrcImpl(IrcStack.this.provider,\n                        this.chatroom, user, ChatRoomMemberRole.SILENT_MEMBER);\n                this.chatroom.fireMemberPresenceEvent(member, null,\n                    ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED, null);\n            }\n        }","commit_id":"5b21c014e4874707145a4616b8a822774eee2718","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n        public void onTopicChange(TopicMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()))\n            {\n                this.chatroom.updateSubject(msg.getTopic().getValue());\n            }\n        }","id":89385,"modified_method":"@Override\n        public void onTopicChange(TopicMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()) == false)\n                return;\n            \n            this.chatroom.updateSubject(msg.getTopic().getValue());\n        }","commit_id":"5b21c014e4874707145a4616b8a822774eee2718","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n        public void onChannelKick(ChannelKick msg)\n        {\n            //TODO DEBUG CODE!\n            System.out.println(\"KICK: \" + msg.getText() + \" \"\n                + msg.getChannelName() + \" \" + msg.getKickedUser());\n\n            if (isThisChatRoom(msg.getChannelName()))\n            {\n                String kickedUser = msg.getKickedUser();\n                if (isMe(kickedUser))\n                {\n                    IrcStack.this.provider.getMUC().fireLocalUserPresenceEvent(\n                        this.chatroom,\n                        LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_KICKED,\n                        msg.getText());\n                    IrcStack.this.joined.remove(this.chatroom.getIdentifier());\n                    IrcStack.this.irc.deleteListener(this);\n                }\n                else\n                {\n                    ChatRoomMember kickedMember =\n                        this.chatroom.getChatRoomMember(kickedUser);\n                    String user = msg.getSource().getNick();\n                    if (kickedMember != null)\n                    {\n                        ChatRoomMember kicker =\n                            this.chatroom.getChatRoomMember(user);\n                        this.chatroom.fireMemberPresenceEvent(kickedMember,\n                            kicker,\n                            ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED,\n                            msg.getText());\n                    }\n                }\n            }\n        }","id":89386,"modified_method":"@Override\n        public void onChannelKick(ChannelKick msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()) == false)\n                return;\n            \n            //TODO DEBUG CODE!\n            System.out.println(\"KICK: \" + msg.getText() + \" \"\n                + msg.getChannelName() + \" \" + msg.getKickedUser());\n\n            String kickedUser = msg.getKickedUser();\n            if (isMe(kickedUser))\n            {\n                IrcStack.this.provider.getMUC().fireLocalUserPresenceEvent(\n                    this.chatroom,\n                    LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_KICKED,\n                    msg.getText());\n                IrcStack.this.joined.remove(this.chatroom.getIdentifier());\n                IrcStack.this.irc.deleteListener(this);\n            }\n            else\n            {\n                ChatRoomMember kickedMember =\n                    this.chatroom.getChatRoomMember(kickedUser);\n                String user = msg.getSource().getNick();\n                if (kickedMember != null)\n                {\n                    ChatRoomMember kicker =\n                        this.chatroom.getChatRoomMember(user);\n                    this.chatroom.fireMemberPresenceEvent(kickedMember,\n                        kicker,\n                        ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED,\n                        msg.getText());\n                }\n            }\n        }","commit_id":"5b21c014e4874707145a4616b8a822774eee2718","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n        public void onChannelPart(ChanPartMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()))\n            {\n                String user = msg.getSource().getNick();\n\n                if (isMe(msg.getSource()))\n                {\n                    IrcStack.this.provider.getMUC().fireLocalUserPresenceEvent(\n                        this.chatroom,\n                        LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT,\n                        null);\n                    IrcStack.this.joined.remove(this.chatroom.getIdentifier());\n                    IrcStack.this.irc.deleteListener(this);\n                }\n                else\n                {\n                    ChatRoomMember member =\n                        this.chatroom.getChatRoomMember(user);\n                    this.chatroom.fireMemberPresenceEvent(member, null,\n                        ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT,\n                        msg.getPartMsg());\n                }\n            }\n        }","id":89387,"modified_method":"@Override\n        public void onChannelPart(ChanPartMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()) == false)\n                return;\n            \n            if (isMe(msg.getSource()))\n            {\n                IrcStack.this.provider.getMUC().fireLocalUserPresenceEvent(\n                    this.chatroom,\n                    LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT, null);\n                IrcStack.this.joined.remove(this.chatroom.getIdentifier());\n                IrcStack.this.irc.deleteListener(this);\n            }\n            else\n            {\n                String user = msg.getSource().getNick();\n                ChatRoomMember member = this.chatroom.getChatRoomMember(user);\n                this.chatroom.fireMemberPresenceEvent(member, null,\n                    ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT,\n                    msg.getPartMsg());\n            }\n        }","commit_id":"5b21c014e4874707145a4616b8a822774eee2718","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n        public void onChannelMode(ChannelModeMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()))\n            {\n                processModeMessage(msg);\n            }\n        }","id":89388,"modified_method":"@Override\n        public void onChannelMode(ChannelModeMessage msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()) == false)\n                return;\n            \n            processModeMessage(msg);\n        }","commit_id":"5b21c014e4874707145a4616b8a822774eee2718","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n        public void onChannelMessage(ChannelPrivMsg msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()))\n            {\n                MessageIrcImpl message =\n                    new MessageIrcImpl(msg.getText(), \"text/plain\", \"UTF-8\",\n                        null);\n                ChatRoomMemberIrcImpl member =\n                    new ChatRoomMemberIrcImpl(IrcStack.this.provider,\n                        this.chatroom, msg.getSource().getNick(),\n                        ChatRoomMemberRole.MEMBER);\n                this.chatroom.fireMessageReceivedEvent(message, member,\n                    new Date(),\n                    ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);\n            }\n        }","id":89389,"modified_method":"@Override\n        public void onChannelMessage(ChannelPrivMsg msg)\n        {\n            if (isThisChatRoom(msg.getChannelName()) == false)\n                return;\n\n            MessageIrcImpl message =\n                new MessageIrcImpl(msg.getText(), \"text/plain\", \"UTF-8\", null);\n            ChatRoomMemberIrcImpl member =\n                new ChatRoomMemberIrcImpl(IrcStack.this.provider,\n                    this.chatroom, msg.getSource().getNick(),\n                    ChatRoomMemberRole.MEMBER);\n            this.chatroom.fireMessageReceivedEvent(message, member, new Date(),\n                ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);\n        }","commit_id":"5b21c014e4874707145a4616b8a822774eee2718","url":"https://github.com/jitsi/jitsi"},{"original_method":"public EditorCell createTypeCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode type = node.getReferent(\"type\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(type != null) {\n      editorCell = this.nodeCell(editorContext, type);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    FieldDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89390,"modified_method":"public EditorCell createTypeCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode type = node.getReferent(\"type\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(type != null) {\n      editorCell = this.nodeCell(editorContext, type);\n      FieldDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      FieldDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createInitializerCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode initializer = node.getReferent(\"initializer\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(initializer != null) {\n      editorCell = this.nodeCell(editorContext, initializer);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    _VariableInitializer_ActionSet.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89391,"modified_method":"public EditorCell createInitializerCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode initializer = node.getReferent(\"initializer\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(initializer != null) {\n      editorCell = this.nodeCell(editorContext, initializer);\n      _VariableInitializer_ActionSet.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      _VariableInitializer_ActionSet.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConditionCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode condition = node.getReferent(\"condition\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(condition != null) {\n      editorCell = this.nodeCell(editorContext, condition);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    IfStatement_ConditionCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89392,"modified_method":"public EditorCell createConditionCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode condition = node.getReferent(\"condition\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(condition != null) {\n      editorCell = this.nodeCell(editorContext, condition);\n      IfStatement_ConditionCellActions.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      IfStatement_ConditionCellActions.setCellActions(editorCell, node);\n      _DefErrorActions.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createReturnType(EditorContext editorContext, SemanticNode node) {\n    SemanticNode returnType = node.getReferent(\"returnType\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(returnType != null) {\n      editorCell = this.nodeCell(editorContext, returnType);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    InstanceMethodDeclaration_ReturnTypeCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89393,"modified_method":"public EditorCell createReturnType(EditorContext editorContext, SemanticNode node) {\n    SemanticNode returnType = node.getReferent(\"returnType\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(returnType != null) {\n      editorCell = this.nodeCell(editorContext, returnType);\n      InstanceMethodDeclaration_ReturnTypeCellActions.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      InstanceMethodDeclaration_ReturnTypeCellActions.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createTypeCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode type = node.getReferent(\"type\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(type != null) {\n      editorCell = this.nodeCell(editorContext, type);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    LocalVariableDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89394,"modified_method":"public EditorCell createTypeCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode type = node.getReferent(\"type\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(type != null) {\n      editorCell = this.nodeCell(editorContext, type);\n      LocalVariableDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      LocalVariableDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createInitializerCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode initializer = node.getReferent(\"initializer\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(initializer != null) {\n      editorCell = this.nodeCell(editorContext, initializer);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    _VariableInitializer_ActionSet.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89395,"modified_method":"public EditorCell createInitializerCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode initializer = node.getReferent(\"initializer\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(initializer != null) {\n      editorCell = this.nodeCell(editorContext, initializer);\n      _VariableInitializer_ActionSet.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      _VariableInitializer_ActionSet.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createTypeCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode type = node.getReferent(\"type\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(type != null) {\n      editorCell = this.nodeCell(editorContext, type);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    ParameterDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89396,"modified_method":"public EditorCell createTypeCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode type = node.getReferent(\"type\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(type != null) {\n      editorCell = this.nodeCell(editorContext, type);\n      ParameterDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      ParameterDeclaration_TypeCellActions.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createExpressionCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode expression = node.getReferent(\"expression\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(expression != null) {\n      editorCell = this.nodeCell(editorContext, expression);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n    }\n    ReturnStatement_ExpressionCellActions.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":89397,"modified_method":"public EditorCell createExpressionCell(EditorContext editorContext, SemanticNode node) {\n    SemanticNode expression = node.getReferent(\"expression\", (SemanticNode)null);\n    EditorCell editorCell = null;\n    if(expression != null) {\n      editorCell = this.nodeCell(editorContext, expression);\n      ReturnStatement_ExpressionCellActions.setCellActions(editorCell, node);\n    } else {\n      editorCell = EditorCell_Error.create(editorContext, node, null);\n      ReturnStatement_ExpressionCellActions.setCellActions(editorCell, node);\n      _DefErrorActions.setCellActions(editorCell, node);\n    }\n    return editorCell;\n  }","commit_id":"4c8fe2cc673e138ce461a9592200af9da15f9dc0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void registerAttribute(@NotNull AttributeDefinition attrDef,\n                                        String namespaceKey,\n                                        DomExtensionsRegistrar registrar,\n                                        @Nullable MyAttributeProcessor processor,\n                                        @NotNull DomElement element) {\n    XmlName xmlName = new XmlName(attrDef.getName(), namespaceKey);\n    Set<AttributeFormat> formats = attrDef.getFormats();\n    Class valueClass = formats.size() == 1 ? getValueClass(formats.iterator().next()) : String.class;\n    registrar.registerAttributeChildExtension(xmlName, GenericAttributeValue.class);\n    DomExtension extension = registrar.registerGenericAttributeValueChildExtension(xmlName, valueClass);\n    final Converter converter = AndroidDomUtil.getConverter(attrDef);\n    if (converter != null) {\n      extension.setConverter(converter, mustBeSoft(converter, attrDef.getFormats()));\n    }\n    if (processor != null) {\n      processor.process(xmlName, extension, element);\n    }\n  }","id":89398,"modified_method":"private static void registerAttribute(@NotNull AttributeDefinition attrDef,\n                                        String namespaceKey,\n                                        DomExtensionsRegistrar registrar,\n                                        @Nullable MyAttributeProcessor processor,\n                                        @NotNull DomElement element) {\n    XmlName xmlName = new XmlName(attrDef.getName(), namespaceKey);\n    Set<AttributeFormat> formats = attrDef.getFormats();\n    Class valueClass = formats.size() == 1 ? getValueClass(formats.iterator().next()) : String.class;\n    registrar.registerAttributeChildExtension(xmlName, GenericAttributeValue.class);\n    DomExtension extension = registrar.registerGenericAttributeValueChildExtension(xmlName, valueClass);\n\n    Converter converter = AndroidDomUtil.getSpecificConverter(xmlName, element);\n    if (converter == null) {\n      converter = AndroidDomUtil.getConverter(attrDef);\n    }\n\n    if (converter != null) {\n      extension.setConverter(converter, mustBeSoft(converter, attrDef.getFormats()));\n    }\n    if (processor != null) {\n      processor.process(xmlName, extension, element);\n    }\n  }","commit_id":"41aaa5c898516ce9b190da6ba221589ac2d8ee11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public final Converter getConverterInstance(final Class<? extends Converter> converterClass) {\n    return myConverterInstances.get(converterClass);\n  }","id":89399,"modified_method":"@NotNull\n  public final Converter getConverterInstance(final Class<? extends Converter> converterClass) {\n    return getInstance(converterClass);\n  }","commit_id":"21656eaa1cd3c7a4bb6bfc26a35fc1e83550543e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addReferenceElementNames(final Condition<Class> condition, final HashSet<String> set, final HashSet<GenericInfoImpl> visited) {\n    visited.add(this);\n    Type[] classes = getConcreteInterfaceVariants();\n    if (classes.length == 1 && classes[0].equals(myClass)) {\n      for (final DomChildDescriptionImpl description : getChildrenDescriptions()) {\n        final Convert annotation = description.getAnnotation(Convert.class);\n        final boolean hasResolveConverter = annotation != null && ReflectionCache.isAssignable(ResolvingConverter.class, annotation.value());\n        final Type type = description.getType();\n        if (condition.value(DomReflectionUtil.getRawType(type))) {\n          if (hasResolveConverter || !String.class.equals(DomUtil.getGenericValueParameter(type)) || description.getAnnotation(NameValue.class) != null) {\n            set.add(description.getXmlElementName());\n          }\n        } else {\n          final GenericInfoImpl childGenericInfo = description.getChildGenericInfo(myDomManager.getProject());\n          if (!visited.contains(childGenericInfo)) {\n            childGenericInfo.addReferenceElementNames(condition, set, visited);\n          }\n        }\n      }\n    } else {\n      for (final Type aClass : classes) {\n        final GenericInfoImpl info = myDomManager.getGenericInfo(aClass);\n        if (!visited.contains(info)) {\n          info.addReferenceElementNames(condition, set, visited);\n        }\n      }\n    }\n  }","id":89400,"modified_method":"private void addReferenceElementNames(final Condition<Class> condition, final HashSet<String> set, final HashSet<GenericInfoImpl> visited) {\n    visited.add(this);\n    Type[] classes = getConcreteInterfaceVariants();\n    if (classes.length == 1 && classes[0].equals(myClass)) {\n      for (final DomChildDescriptionImpl description : getChildrenDescriptions()) {\n        final Convert annotation = description.getAnnotation(Convert.class);\n        final boolean hasResolveConverter = annotation != null &&\n                                            (ReflectionCache.isAssignable(ResolvingConverter.class, annotation.value()) ||\n                                             ReflectionCache.isAssignable(CustomReferenceConverter.class, annotation.value()));\n        final Type type = description.getType();\n        if (condition.value(DomReflectionUtil.getRawType(type))) {\n          if (hasResolveConverter ||\n              !String.class.equals(DomUtil.getGenericValueParameter(type)) ||\n              description.getAnnotation(NameValue.class) != null ||\n              description.getAnnotation(Referencing.class) != null) {\n            set.add(description.getXmlElementName());\n          }\n        } else {\n          final GenericInfoImpl childGenericInfo = description.getChildGenericInfo(myDomManager.getProject());\n          if (!visited.contains(childGenericInfo)) {\n            childGenericInfo.addReferenceElementNames(condition, set, visited);\n          }\n        }\n      }\n    } else {\n      for (final Type aClass : classes) {\n        final GenericInfoImpl info = myDomManager.getGenericInfo(aClass);\n        if (!visited.contains(info)) {\n          info.addReferenceElementNames(condition, set, visited);\n        }\n      }\n    }\n  }","commit_id":"21656eaa1cd3c7a4bb6bfc26a35fc1e83550543e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public final PsiReference[] getReferencesByElement(PsiElement psiElement) {\n    if (!(psiElement instanceof XmlTag || psiElement instanceof XmlAttributeValue)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    PsiElement originalElement = psiElement.getUserData(PsiUtil.ORIGINAL_KEY);\n    if (originalElement != null) {\n      psiElement = originalElement;\n    }\n\n    final XmlTag tag = PsiTreeUtil.getParentOfType(psiElement, XmlTag.class, false);\n\n    DomElement domElement = DomManager.getDomManager(psiElement.getManager().getProject()).getDomElement(tag);\n    if (domElement == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    if (psiElement instanceof XmlAttributeValue) {\n      final PsiElement parent = psiElement.getParent();\n      if (parent instanceof XmlAttribute) {\n        final XmlAttribute attribute = (XmlAttribute)parent;\n        final String name = attribute.getLocalName();\n        final DomAttributeChildDescription childDescription = domElement.getGenericInfo().getAttributeChildDescription(name);\n        if (childDescription != null) {\n          domElement = childDescription.getDomAttributeValue(domElement);\n        }\n      }\n    }\n\n    if (!(domElement instanceof GenericDomValue)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    GenericDomValue domValue = (GenericDomValue)domElement;\n\n    final Converter converter = domValue.getConverter();\n\n    PsiReference[] references = createReferences(domValue, (XmlElement)psiElement, converter);\n\n    // creating \"declaration\" reference\n    DomElement parent = domElement.getParent();\n    if (references.length == 0) {\n      final NameValue nameValue = domElement.getAnnotation(NameValue.class);\n      if (nameValue != null && nameValue.referencable()) {\n        references = ArrayUtil.append(references, PsiReferenceBase.createSelfReference(psiElement, parent.getXmlElement()), PsiReference.class);\n      }\n    }\n    return references;\n  }","id":89401,"modified_method":"@NotNull\n  public final PsiReference[] getReferencesByElement(PsiElement psiElement) {\n    if (!(psiElement instanceof XmlTag || psiElement instanceof XmlAttributeValue)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    PsiElement originalElement = psiElement.getUserData(PsiUtil.ORIGINAL_KEY);\n    if (originalElement != null) {\n      psiElement = originalElement;\n    }\n\n    final XmlTag tag = PsiTreeUtil.getParentOfType(psiElement, XmlTag.class, false);\n\n    final DomManager domManager = DomManager.getDomManager(psiElement.getManager().getProject());\n    DomElement domElement = domManager.getDomElement(tag);\n    if (domElement == null) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    if (psiElement instanceof XmlAttributeValue) {\n      final PsiElement parent = psiElement.getParent();\n      if (parent instanceof XmlAttribute) {\n        final XmlAttribute attribute = (XmlAttribute)parent;\n        final String name = attribute.getLocalName();\n        final DomAttributeChildDescription childDescription = domElement.getGenericInfo().getAttributeChildDescription(name);\n        if (childDescription != null) {\n          domElement = childDescription.getDomAttributeValue(domElement);\n        }\n      }\n    }\n\n    if (!(domElement instanceof GenericDomValue)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    GenericDomValue domValue = (GenericDomValue)domElement;\n\n    final Referencing referencing = domValue.getAnnotation(Referencing.class);\n    final Object converter;\n    if (referencing == null) {\n      converter = domValue.getConverter();\n    }\n    else {\n      Class<? extends CustomReferenceConverter> clazz = referencing.value();\n      converter = ((ConverterManagerImpl)domManager.getConverterManager()).getInstance(clazz);\n    }\n    PsiReference[] references = createReferences(domValue, (XmlElement)psiElement, converter);\n\n    // creating \"declaration\" reference\n    if (references.length == 0) {\n      final NameValue nameValue = domElement.getAnnotation(NameValue.class);\n      if (nameValue != null && nameValue.referencable()) {\n        DomElement parent = domElement.getParent();\n        assert parent != null;\n        references = ArrayUtil.append(references, PsiReferenceBase.createSelfReference(psiElement, parent.getXmlElement()), PsiReference.class);\n      }\n    }\n    return references;\n  }","commit_id":"21656eaa1cd3c7a4bb6bfc26a35fc1e83550543e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private PsiReference[] createReferences(final GenericDomValue domValue, final XmlElement psiElement, final Converter converter) {\n    if (converter instanceof CustomReferenceConverter) {\n      return ((CustomReferenceConverter)converter).createReferences(domValue, psiElement, new AbstractConvertContext() {\n        @NotNull\n        public DomElement getInvocationElement() {\n          return domValue;\n        }\n\n        public PsiManager getPsiManager() {\n          return psiElement.getManager();\n        }\n      });\n    }\n    if (converter instanceof PsiReferenceConverter) {\n      return ((PsiReferenceConverter)converter).createReferences(psiElement, true);\n    }\n    final boolean isResolvingConverter = converter instanceof ResolvingConverter;\n\n    final DomInvocationHandler invocationHandler = getInvocationHandler(domValue);\n    final Class clazz = DomUtil.getGenericValueParameter(invocationHandler.getDomElementType());\n    if (clazz == null) return PsiReference.EMPTY_ARRAY;\n\n    if (ReflectionCache.isAssignable(PsiType.class, clazz)) {\n      return new PsiReference[]{new PsiTypeReference((GenericDomValue<PsiType>)domValue)};\n    }\n    if (ReflectionCache.isAssignable(PsiClass.class, clazz)) {\n      ExtendClass extendClass = invocationHandler.getAnnotation(ExtendClass.class);\n      JavaClassReferenceProvider provider;\n      if (extendClass == null) {\n        provider = new JavaClassReferenceProvider();\n      }\n      else {\n        provider = new JavaClassReferenceProvider(extendClass.value(), extendClass.instantiatable());\n      }\n      provider.setSoft(true);\n      final PsiReference[] references = provider.getReferencesByElement(psiElement);\n      return isResolvingConverter ? ArrayUtil.append(references, new GenericDomValueReference(domValue), PsiReference.class)\n        : references;\n    }\n    if (!isResolvingConverter && ReflectionCache.isAssignable(Integer.class, clazz)) {\n      return new PsiReference[]{new GenericDomValueReference<Integer>((GenericDomValue<Integer>)domValue) {\n        public Object[] getVariants() {\n          return new Object[]{\"0\"};\n        }\n      }};\n    }\n    if (!isResolvingConverter && ReflectionCache.isAssignable(String.class, clazz)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    PsiReferenceFactory provider = myProviders.get(clazz);\n    if (provider != null) {\n      return provider.getReferencesByElement(psiElement);\n    }\n\n    return new PsiReference[]{new GenericDomValueReference(domValue)};\n  }","id":89402,"modified_method":"@NotNull\n  private PsiReference[] createReferences(final GenericDomValue domValue, final XmlElement psiElement, final Object converter) {\n    if (converter instanceof CustomReferenceConverter) {\n      return ((CustomReferenceConverter)converter).createReferences(domValue, psiElement, new AbstractConvertContext() {\n        @NotNull\n        public DomElement getInvocationElement() {\n          return domValue;\n        }\n\n        public PsiManager getPsiManager() {\n          return psiElement.getManager();\n        }\n      });\n    }\n    if (converter instanceof PsiReferenceConverter) {\n      return ((PsiReferenceConverter)converter).createReferences(psiElement, true);\n    }\n    final boolean isResolvingConverter = converter instanceof ResolvingConverter;\n\n    final DomInvocationHandler invocationHandler = getInvocationHandler(domValue);\n    assert invocationHandler != null;\n    final Class clazz = DomUtil.getGenericValueParameter(invocationHandler.getDomElementType());\n    if (clazz == null) return PsiReference.EMPTY_ARRAY;\n\n    if (ReflectionCache.isAssignable(PsiType.class, clazz)) {\n      return new PsiReference[]{new PsiTypeReference((GenericDomValue<PsiType>)domValue)};\n    }\n    if (ReflectionCache.isAssignable(PsiClass.class, clazz)) {\n      ExtendClass extendClass = invocationHandler.getAnnotation(ExtendClass.class);\n      JavaClassReferenceProvider provider;\n      if (extendClass == null) {\n        provider = new JavaClassReferenceProvider();\n      }\n      else {\n        provider = new JavaClassReferenceProvider(extendClass.value(), extendClass.instantiatable());\n      }\n      provider.setSoft(true);\n      final PsiReference[] references = provider.getReferencesByElement(psiElement);\n      return isResolvingConverter ? ArrayUtil.append(references, new GenericDomValueReference(domValue), PsiReference.class)\n        : references;\n    }\n    if (!isResolvingConverter && ReflectionCache.isAssignable(Integer.class, clazz)) {\n      return new PsiReference[]{new GenericDomValueReference<Integer>((GenericDomValue<Integer>)domValue) {\n        public Object[] getVariants() {\n          return new Object[]{\"0\"};\n        }\n      }};\n    }\n    if (!isResolvingConverter && ReflectionCache.isAssignable(String.class, clazz)) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n    PsiReferenceFactory provider = myProviders.get(clazz);\n    if (provider != null) {\n      return provider.getReferencesByElement(psiElement);\n    }\n\n    return new PsiReference[]{new GenericDomValueReference(domValue)};\n  }","commit_id":"21656eaa1cd3c7a4bb6bfc26a35fc1e83550543e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Converter getConverterForChild(final Method method) {\n    try {\n      final Class aClass = DomUtil.getGenericValueType(method.getGenericReturnType());\n      if (aClass == null) return null;\n\n      final Convert convertAnnotation = DomUtil.findAnnotationDFS(method, Convert.class);\n      if (convertAnnotation != null) {\n        return myManager.getConverterManager().getConverter(convertAnnotation.value());\n      }\n\n      return myManager.getConverterManager().getConverter(aClass);\n    }\n    catch (InstantiationException e) {\n      LOG.error(e);\n    }\n    catch (IllegalAccessException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","id":89403,"modified_method":"private Converter getConverterForChild(final Method method) {\n    try {\n      final Resolve resolveAnnotation = DomUtil.findAnnotationDFS(method, Resolve.class);\n      if (resolveAnnotation != null) {\n        return new DomResolveConverter(resolveAnnotation.value());\n      }\n\n      final Convert convertAnnotation = DomUtil.findAnnotationDFS(method, Convert.class);\n      if (convertAnnotation != null) {\n        return myManager.getConverterManager().getConverter(convertAnnotation.value());\n      }\n\n      final Class aClass = DomUtil.getGenericValueType(method.getGenericReturnType());\n      return aClass == null ? null : myManager.getConverterManager().getConverter(aClass);\n    }\n    catch (InstantiationException e) {\n      LOG.error(e);\n    }\n    catch (IllegalAccessException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","commit_id":"becb75efd1de6a90d4d1a063d714d913b45e6790","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Gets the value that results when the given Ognl expression is applied to the model\n\t * object (Ognl.getValue).\n\t * @return the value that results when the given Ognl expression is applied to the\n\t *         model object\n\t * @see wicket.model.IModel#getObject()\n\t */\n\tpublic Object getObject()\n\t{\n\t\tString expr = getExpression();\n\t\tif (expr == null || expr.trim().length() == 0)\n\t\t{\n\t\t\t// No expression will cause OGNL to throw an exception. The OGNL\n\t\t\t// expression to return the current object is \"#this\". Instead\n\t\t\t// of throwing that exception, we'll provide a meaningfull\n\t\t\t// return value\n\t\t\treturn model.getObject();\n\t\t}\n\t\tIModel theModel = getModel();\n\t\tif (theModel == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tObject modelObject = theModel.getObject();\n\t\tif (modelObject == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOgnlContext ctx = getContext();\n\t\t\tObject raw = Ognl.getValue(expr, ctx, modelObject);\n\t\t\tif (applyFormatting)\n\t\t\t{\n\t\t\t\tIStringConverter converter = component.getConverter();\n\t\t\t\treturn converter.toString(raw);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn raw;\n\t\t\t}\n\t\t}\n\t\tcatch (OgnlException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t}","id":89404,"modified_method":"/**\n\t * Gets the value that results when the given Ognl expression is applied to the model\n\t * object (Ognl.getValue).\n\t * @return the value that results when the given Ognl expression is applied to the\n\t *         model object\n\t * @see wicket.model.IModel#getObject()\n\t */\n\tpublic Object getObject()\n\t{\n\t\tString expr = getExpression();\n\t\tif (expr == null || expr.trim().length() == 0)\n\t\t{\n\t\t\t// No expression will cause OGNL to throw an exception. The OGNL\n\t\t\t// expression to return the current object is \"#this\". Instead\n\t\t\t// of throwing that exception, we'll provide a meaningfull\n\t\t\t// return value\n\t\t\treturn model.getObject();\n\t\t}\n\t\tIModel theModel = getModel();\n\t\tif (theModel == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tObject modelObject = theModel.getObject();\n\t\tif (modelObject == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOgnlContext ctx = getContext();\n\t\t\tObject raw = Ognl.getValue(expr, ctx, modelObject);\n\t\t\tif (applyFormatting)\n\t\t\t{\n\t\t\t\tfinal IStringConverter converter;\n\t\t\t\tif(component != null) // could be null if used directly by clients\n\t\t\t\t{\n\t\t\t\t\tconverter = component.getConverter();\n\t\t\t\t}\n\t\t\t\telse // safety option\n\t\t\t\t{\n\t\t\t\t\tSession session = Session.get();\n\t\t\t\t\tconverter = (IStringConverter)session.getConverter();\n\t\t\t\t}\n\t\t\t\treturn converter.toString(raw);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn raw;\n\t\t\t}\n\t\t}\n\t\tcatch (OgnlException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t}","commit_id":"77fc2fec783f3b3e6bd168cfb3a6e410081167e2","url":"https://github.com/apache/wicket"},{"original_method":"private void ensureFileSetCapacityForValue(Value value, int count) {\n    if (count <= 1) return;\n    Object fileSetObject = getFileSetObject(value);\n\n    if (fileSetObject != null) {\n      if (fileSetObject instanceof Integer) {\n        ChangeBufferingList list = new ChangeBufferingList(count + 1);\n        list.add(((Integer)fileSetObject).intValue());\n        resetFileSetForValue(value, list);\n      } else if (fileSetObject instanceof ChangeBufferingList) {\n        ChangeBufferingList list = (ChangeBufferingList)fileSetObject;\n        list.ensureCapacity(count);\n      }\n      return;\n    }\n\n    final Object fileSet = new ChangeBufferingList(count);\n    attachFileSetForNewValue(value, fileSet);\n  }","id":89405,"modified_method":"private @Nullable ChangeBufferingList ensureFileSetCapacityForValue(Value value, int count) {\n    if (count <= 1) return null;\n    Object fileSetObject = getFileSetObject(value);\n\n    if (fileSetObject != null) {\n      if (fileSetObject instanceof Integer) {\n        ChangeBufferingList list = new ChangeBufferingList(count + 1);\n        list.add(((Integer)fileSetObject).intValue());\n        resetFileSetForValue(value, list);\n        return list;\n      } else if (fileSetObject instanceof ChangeBufferingList) {\n        ChangeBufferingList list = (ChangeBufferingList)fileSetObject;\n        list.ensureCapacity(count);\n        return list;\n      }\n      return null;\n    }\n\n    final ChangeBufferingList fileSet = new ChangeBufferingList(count);\n    attachFileSetForNewValue(value, fileSet);\n    return fileSet;\n  }","commit_id":"eec068545660be3480a269281d33816c5042edaa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readFrom(DataInputStream stream, DataExternalizer<Value> externalizer) throws IOException {\n    FileId2ValueMapping<Value> mapping = null;\n\n    while (stream.available() > 0) {\n      final int valueCount = DataInputOutputUtil.readINT(stream);\n      if (valueCount < 0) {\n        // ChangeTrackingValueContainer marked inputId as invalidated, see ChangeTrackingValueContainer.saveTo\n        final int inputId = -valueCount;\n\n        if (mapping == null && size() > NUMBER_OF_VALUES_THRESHOLD) { // avoid O(NumberOfValues)\n          mapping = new FileId2ValueMapping<Value>(this);\n        }\n\n        boolean doCompact;\n        if(mapping != null) {\n          doCompact = mapping.removeFileId(inputId);\n        } else {\n          removeAssociatedValue(inputId);\n          doCompact = true;\n        }\n\n        if (doCompact) setNeedsCompacting(true);\n      }\n      else {\n        for (int valueIdx = 0; valueIdx < valueCount; valueIdx++) {\n          final Value value = externalizer.read(stream);\n          int idCountOrSingleValue = DataInputOutputUtil.readINT(stream);\n\n          if (idCountOrSingleValue > 0) {\n            addValue(idCountOrSingleValue, value);\n            if (mapping != null) mapping.associateFileIdToValue(idCountOrSingleValue, value);\n          } else {\n            idCountOrSingleValue = -idCountOrSingleValue;\n            ensureFileSetCapacityForValue(value, idCountOrSingleValue);\n            int prev = 0;\n\n            for (int i = 0; i < idCountOrSingleValue; i++) {\n              final int id = DataInputOutputUtil.readINT(stream);\n              addValue(prev + id, value);\n              if (mapping != null) mapping.associateFileIdToValue(prev + id, value);\n              prev += id;\n            }\n          }\n        }\n      }\n    }\n  }","id":89406,"modified_method":"public void readFrom(DataInputStream stream, DataExternalizer<Value> externalizer) throws IOException {\n    FileId2ValueMapping<Value> mapping = null;\n\n    while (stream.available() > 0) {\n      final int valueCount = DataInputOutputUtil.readINT(stream);\n      if (valueCount < 0) {\n        // ChangeTrackingValueContainer marked inputId as invalidated, see ChangeTrackingValueContainer.saveTo\n        final int inputId = -valueCount;\n\n        if (mapping == null && size() > NUMBER_OF_VALUES_THRESHOLD) { // avoid O(NumberOfValues)\n          mapping = new FileId2ValueMapping<Value>(this);\n        }\n\n        boolean doCompact;\n        if(mapping != null) {\n          doCompact = mapping.removeFileId(inputId);\n        } else {\n          removeAssociatedValue(inputId);\n          doCompact = true;\n        }\n\n        if (doCompact) setNeedsCompacting(true);\n      }\n      else {\n        for (int valueIdx = 0; valueIdx < valueCount; valueIdx++) {\n          final Value value = externalizer.read(stream);\n          int idCountOrSingleValue = DataInputOutputUtil.readINT(stream);\n\n          if (idCountOrSingleValue > 0) {\n            addValue(idCountOrSingleValue, value);\n            if (mapping != null) mapping.associateFileIdToValue(idCountOrSingleValue, value);\n          } else {\n            idCountOrSingleValue = -idCountOrSingleValue;\n            ChangeBufferingList changeBufferingList = ensureFileSetCapacityForValue(value, idCountOrSingleValue);\n            int prev = 0;\n\n            for (int i = 0; i < idCountOrSingleValue; i++) {\n              final int id = DataInputOutputUtil.readINT(stream);\n              if (changeBufferingList != null)  changeBufferingList.add(prev + id);\n              else addValue(prev + id, value);\n              if (mapping != null) mapping.associateFileIdToValue(prev + id, value);\n              prev += id;\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"eec068545660be3480a269281d33816c5042edaa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n     * Parses the element into an entity.<p>\r\n     * \r\n     * @param content the entity content\r\n     * @param element the current element\r\n     * @param locale the content locale\r\n     * @param entityId the entity id\r\n     * @param typeName the entity type name\r\n     * @param registeredTypes the types used within the entity\r\n     * \r\n     * @return the entity\r\n     */\r\n    protected Entity readEntity(\r\n        CmsXmlContent content,\r\n        Element element,\r\n        Locale locale,\r\n        String entityId,\r\n        String typeName,\r\n        Map<String, I_Type> registeredTypes) {\r\n\r\n        Entity result = new Entity(entityId, typeName);\r\n        @SuppressWarnings(\"unchecked\")\r\n        List<Element> elements = element.elements();\r\n        I_Type type = registeredTypes.get(typeName);\r\n        int counter = 0;\r\n        CmsObject cms = getCmsObject();\r\n        for (Element child : elements) {\r\n            String attributeName = getAttributeName(child.getName(), typeName);\r\n            String subTypeName = type.getAttributeTypeName(attributeName);\r\n            if (registeredTypes.get(subTypeName).isSimpleType()) {\r\n                String path = removeFirstTwoPathLevel(child.getPath());\r\n                I_CmsXmlContentValue value = content.getValue(path, locale);\r\n                result.addAttributeValue(attributeName, value.getStringValue(cms));\r\n            } else {\r\n                Entity subEntity = readEntity(\r\n                    content,\r\n                    child,\r\n                    locale,\r\n                    entityId + \"/\" + attributeName + counter,\r\n                    subTypeName,\r\n                    registeredTypes);\r\n                result.addAttributeValue(attributeName, subEntity);\r\n\r\n            }\r\n        }\r\n        return result;\r\n    }","id":89407,"modified_method":"/**\r\n     * Parses the element into an entity.<p>\r\n     * \r\n     * @param content the entity content\r\n     * @param element the current element\r\n     * @param locale the content locale\r\n     * @param entityId the entity id\r\n     * @param typeName the entity type name\r\n     * @param registeredTypes the types used within the entity\r\n     * \r\n     * @return the entity\r\n     */\r\n    protected Entity readEntity(\r\n        CmsXmlContent content,\r\n        Element element,\r\n        Locale locale,\r\n        String entityId,\r\n        String typeName,\r\n        Map<String, I_Type> registeredTypes) {\r\n\r\n        Entity result = new Entity(entityId, typeName);\r\n        @SuppressWarnings(\"unchecked\")\r\n        List<Element> elements = element.elements();\r\n        I_Type type = registeredTypes.get(typeName);\r\n        int counter = 0;\r\n        CmsObject cms = getCmsObject();\r\n        for (Element child : elements) {\r\n            String attributeName = getAttributeName(child.getName(), typeName);\r\n            String subTypeName = type.getAttributeTypeName(attributeName);\r\n            if (registeredTypes.get(subTypeName).isSimpleType()) {\r\n                String path = removeFirstTwoPathLevel(child.getPath());\r\n                I_CmsXmlContentValue value = content.getValue(path, locale);\r\n                result.addAttributeValue(attributeName, value.getStringValue(cms));\r\n            } else {\r\n                Entity subEntity = readEntity(content, child, locale, entityId\r\n                    + \"/\"\r\n                    + attributeName\r\n                    + \"[\"\r\n                    + counter\r\n                    + \"]\", subTypeName, registeredTypes);\r\n                result.addAttributeValue(attributeName, subEntity);\r\n\r\n            }\r\n        }\r\n        return result;\r\n    }","commit_id":"1a2c6c6892a809483d6b19357f81afdece28e37c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.alkacon.acacia.shared.rpc.I_ContentService#saveEntity(com.alkacon.acacia.shared.Entity, java.lang.String)\r\n     */\r\n    public void saveEntity(Entity entity, String locale) throws CmsRpcException {\r\n\r\n        String entityId = entity.getId();\r\n        CmsUUID structureId = entityIdToUuid(entityId);\r\n        CmsObject cms = getCmsObject();\r\n        try {\r\n            Locale contentLocale = new Locale(locale);\r\n            CmsResource resource = cms.readResource(structureId);\r\n            CmsFile file = cms.readFile(resource);\r\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(cms, file);\r\n            if (content.hasLocale(contentLocale)) {\r\n                content.removeLocale(contentLocale);\r\n            }\r\n            content.addLocale(cms, contentLocale);\r\n            addEntityAttributes(cms, content, \"\", entity, contentLocale);\r\n            writeContent(cms, file, content, getFileEncoding(cms, file));\r\n\r\n        } catch (Exception e) {\r\n            error(e);\r\n        }\r\n\r\n    }","id":89408,"modified_method":"/**\r\n     * @see com.alkacon.acacia.shared.rpc.I_ContentService#saveEntity(com.alkacon.acacia.shared.Entity, java.lang.String)\r\n     */\r\n    public void saveEntity(Entity entity, String locale) throws CmsRpcException {\r\n\r\n        String entityId = entity.getId();\r\n        CmsUUID structureId = entityIdToUuid(entityId);\r\n        CmsObject cms = getCmsObject();\r\n        try {\r\n            Locale contentLocale = new Locale(locale);\r\n            CmsResource resource = cms.readResource(structureId);\r\n            ensureLock(resource);\r\n            CmsFile file = cms.readFile(resource);\r\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(cms, file);\r\n            if (content.hasLocale(contentLocale)) {\r\n                content.removeLocale(contentLocale);\r\n            }\r\n            content.addLocale(cms, contentLocale);\r\n            addEntityAttributes(cms, content, \"\", entity, contentLocale);\r\n            writeContent(cms, file, content, getFileEncoding(cms, file));\r\n            tryUnlock(resource);\r\n        } catch (Exception e) {\r\n            error(e);\r\n        }\r\n\r\n    }","commit_id":"1a2c6c6892a809483d6b19357f81afdece28e37c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Adds the attribute values of the entity to the given XML content.<p>\r\n     * \r\n     * @param cms the current cms context\r\n     * @param content the XML content\r\n     * @param parentPath the parent path\r\n     * @param entity the entity\r\n     * @param contentLocale the content locale\r\n     */\r\n    private void addEntityAttributes(\r\n        CmsObject cms,\r\n        CmsXmlContent content,\r\n        String parentPath,\r\n        I_Entity entity,\r\n        Locale contentLocale) {\r\n\r\n        for (I_EntityAttribute attribute : entity.getAttributes()) {\r\n            String elementPath = parentPath + getElementName(attribute.getAttributeName());\r\n            if (attribute.isSimpleValue()) {\r\n                List<String> values = attribute.getSimpleValues();\r\n                for (int i = 1; i <= values.size(); i++) {\r\n                    String value = values.get(i);\r\n                    content.addValue(cms, elementPath, contentLocale, i).setStringValue(cms, value);\r\n                }\r\n            } else {\r\n                List<I_Entity> entities = attribute.getComplexValues();\r\n                for (int i = 1; i <= entities.size(); i++) {\r\n                    I_Entity child = entities.get(i);\r\n                    content.addValue(cms, elementPath, contentLocale, i);\r\n                    addEntityAttributes(cms, content, elementPath + \"[\" + i + \"]/\", child, contentLocale);\r\n                }\r\n            }\r\n        }\r\n    }","id":89409,"modified_method":"/**\r\n     * Adds the attribute values of the entity to the given XML content.<p>\r\n     * \r\n     * @param cms the current cms context\r\n     * @param content the XML content\r\n     * @param parentPath the parent path\r\n     * @param entity the entity\r\n     * @param contentLocale the content locale\r\n     */\r\n    private void addEntityAttributes(\r\n        CmsObject cms,\r\n        CmsXmlContent content,\r\n        String parentPath,\r\n        I_Entity entity,\r\n        Locale contentLocale) {\r\n\r\n        for (I_EntityAttribute attribute : entity.getAttributes()) {\r\n            String elementPath = parentPath + getElementName(attribute.getAttributeName());\r\n            if (attribute.isSimpleValue()) {\r\n                List<String> values = attribute.getSimpleValues();\r\n                for (int i = 0; i < values.size(); i++) {\r\n                    String value = values.get(i);\r\n                    I_CmsXmlContentValue field = content.getValue(elementPath, contentLocale, i);\r\n                    if (field == null) {\r\n                        field = content.addValue(cms, elementPath, contentLocale, i);\r\n                    }\r\n                    field.setStringValue(cms, value);\r\n\r\n                }\r\n            } else {\r\n                List<I_Entity> entities = attribute.getComplexValues();\r\n                for (int i = 0; i < entities.size(); i++) {\r\n                    I_Entity child = entities.get(i);\r\n                    I_CmsXmlContentValue field = content.getValue(elementPath, contentLocale, i);\r\n                    if (field == null) {\r\n                        field = content.addValue(cms, elementPath, contentLocale, i);\r\n                    }\r\n                    addEntityAttributes(cms, content, field.getPath() + \"/\", child, contentLocale);\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"1a2c6c6892a809483d6b19357f81afdece28e37c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n         * Reads the attribute configuration for the given schema type. May return <code>null<\/code> if no special configuration was set.<p>\r\n         * \r\n         * @param schemaType the schema type\r\n         * \r\n         * @return the attribute configuration\r\n         */\r\n        private AttributeConfiguration readConfiguration(I_CmsXmlSchemaType schemaType) {\r\n\r\n            AttributeConfiguration result = null;\r\n            try {\r\n                I_CmsWidget widget = schemaType.getContentDefinition().getContentHandler().getWidget(schemaType);\r\n                result = new AttributeConfiguration(\r\n                    getLabel(schemaType),\r\n                    getHelp(schemaType),\r\n                    widget.getClass().getName(),\r\n                    widget.getConfiguration());\r\n            } catch (Exception e) {\r\n                // may happen if no widget was set for the value\r\n                LOG.debug(e.getMessage(), e);\r\n            }\r\n            return result;\r\n        }","id":89410,"modified_method":"/**\r\n         * Reads the attribute configuration for the given schema type. May return <code>null<\/code> if no special configuration was set.<p>\r\n         * \r\n         * @param schemaType the schema type\r\n         * \r\n         * @return the attribute configuration\r\n         */\r\n        private AttributeConfiguration readConfiguration(I_CmsXmlSchemaType schemaType) {\r\n\r\n            AttributeConfiguration result = null;\r\n            String widgetName = null;\r\n            String widgetConfig = null;\r\n            try {\r\n                I_CmsWidget widget = schemaType.getContentDefinition().getContentHandler().getWidget(schemaType);\r\n                widgetName = widget.getClass().getName();\r\n                widgetConfig = widget.getConfiguration();\r\n            } catch (Exception e) {\r\n                // may happen if no widget was set for the value\r\n                LOG.debug(e.getMessage(), e);\r\n            }\r\n            result = new AttributeConfiguration(getLabel(schemaType), getHelp(schemaType), widgetName, widgetConfig);\r\n            return result;\r\n        }","commit_id":"1a2c6c6892a809483d6b19357f81afdece28e37c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.opencms.ade.contenteditor.shared.rpc.I_CmsContentService#prefetch()\r\n     */\r\n    public ContentDefinition prefetch() throws CmsRpcException {\r\n\r\n        String paramResource = getRequest().getParameter(CmsDialog.PARAM_RESOURCE);\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(paramResource)) {\r\n            try {\r\n                CmsResource resource = getCmsObject().readResource(paramResource);\r\n                if (CmsResourceTypeXmlContent.isXmlContent(resource)) {\r\n                    Locale defaultLocale = OpenCms.getLocaleManager().getDefaultLocale(getCmsObject(), resource);\r\n\r\n                    return readContentDefinition(resource, null, defaultLocale);\r\n                }\r\n            } catch (Exception e) {\r\n                // TODO: Auto-generated catch block\r\n                error(e);\r\n            }\r\n\r\n        }\r\n        return null;\r\n    }","id":89411,"modified_method":"/**\r\n     * @see org.opencms.ade.contenteditor.shared.rpc.I_CmsContentService#prefetch()\r\n     */\r\n    public ContentDefinition prefetch() throws CmsRpcException {\r\n\r\n        String paramResource = getRequest().getParameter(CmsDialog.PARAM_RESOURCE);\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(paramResource)) {\r\n            try {\r\n                CmsResource resource = getCmsObject().readResource(paramResource);\r\n                if (CmsResourceTypeXmlContent.isXmlContent(resource)) {\r\n                    String paramLocale = getRequest().getParameter(CmsEditor.PARAM_ELEMENTLANGUAGE);\r\n                    Locale locale;\r\n                    if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(paramLocale)) {\r\n                        locale = new Locale(paramLocale);\r\n                    } else {\r\n                        locale = OpenCms.getLocaleManager().getDefaultLocale(getCmsObject(), resource);\r\n                    }\r\n\r\n                    return readContentDefinition(resource, null, locale);\r\n                }\r\n            } catch (Exception e) {\r\n                // TODO: Auto-generated catch block\r\n                error(e);\r\n            }\r\n\r\n        }\r\n        return null;\r\n    }","commit_id":"1a2c6c6892a809483d6b19357f81afdece28e37c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void getInfo(CombinationLookupMeta in)\n\t{\n\t\tint nrkeys         = wKey.nrNonEmpty();\n\n\t\tin.allocate(nrkeys);\n\n\t\tlog.logDebug(toString(), Messages.getString(\"CombinationLookupDialog.Log.SomeKeysFound\",String.valueOf(nrkeys))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (int i=0;i<nrkeys;i++)\n\t\t{\n\t\t\tTableItem item = wKey.getNonEmpty(i);\n\t\t\tin.getKeyField()[i]  = item.getText(1);\n\t\t\tin.getKeyLookup()[i] = item.getText(2);\n\t\t}\n\n\t\tin.setUseAutoinc( wAutoinc.getSelection() && wAutoinc.isEnabled() );\n\t\tin.setReplaceFields( wReplace.getSelection() );\n\t\tin.setUseHash( wHashcode.getSelection() );\n\t\tin.setHashField( wHashfield.getText() );\n\t\tin.setTablename( wTable.getText() );\n\t\tin.setTechnicalKeyField( wTk.getText() );\n\t\tif ( wAutoinc.getSelection() == true )  \n\t\t{\n\t\t\tin.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_AUTOINC);\n\t\t\tin.setUseAutoinc( true );   // for downwards compatibility\n\t\t\tin.setSequenceFrom( null );\n\t\t}\n\t\telse if ( wSeqButton.getSelection() == true )\n\t\t{\n\t\t\tin.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_SEQUENCE);\n\t\t\tin.setUseAutoinc(false);\n\t\t\tin.setSequenceFrom( wSeq.getText() );\n\t\t}\n\t\telse  // all the rest\n\t\t{\n\t\t\tin.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_TABLEMAX);\n\t\t\tin.setUseAutoinc( false );\n\t\t\tin.setSequenceFrom( null );\n\t\t}\n\t\t\n\t\tin.setDatabase( transMeta.findDatabase(wConnection.getText()) );\n\n\t\tin.setCommitSize( Const.toInt(wCommit.getText(), 0) );\n\t}","id":89412,"modified_method":"private void getInfo(CombinationLookupMeta in)\n\t{\n\t\tint nrkeys         = wKey.nrNonEmpty();\n\n\t\tin.allocate(nrkeys);\n\n\t\tlog.logDebug(toString(), Messages.getString(\"CombinationLookupDialog.Log.SomeKeysFound\",String.valueOf(nrkeys))); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tfor (int i=0;i<nrkeys;i++)\n\t\t{\n\t\t\tTableItem item = wKey.getNonEmpty(i);\n\t\t\tin.getKeyLookup()[i] = item.getText(1);\n\t\t\tin.getKeyField()[i]  = item.getText(2);\t\t\t\n\t\t}\n\n\t\tin.setUseAutoinc( wAutoinc.getSelection() && wAutoinc.isEnabled() );\n\t\tin.setReplaceFields( wReplace.getSelection() );\n\t\tin.setUseHash( wHashcode.getSelection() );\n\t\tin.setHashField( wHashfield.getText() );\n\t\tin.setTablename( wTable.getText() );\n\t\tin.setTechnicalKeyField( wTk.getText() );\n\t\tif ( wAutoinc.getSelection() == true )  \n\t\t{\n\t\t\tin.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_AUTOINC);\n\t\t\tin.setUseAutoinc( true );   // for downwards compatibility\n\t\t\tin.setSequenceFrom( null );\n\t\t}\n\t\telse if ( wSeqButton.getSelection() == true )\n\t\t{\n\t\t\tin.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_SEQUENCE);\n\t\t\tin.setUseAutoinc(false);\n\t\t\tin.setSequenceFrom( wSeq.getText() );\n\t\t}\n\t\telse  // all the rest\n\t\t{\n\t\t\tin.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_TABLEMAX);\n\t\t\tin.setUseAutoinc( false );\n\t\t\tin.setSequenceFrom( null );\n\t\t}\n\t\t\n\t\tin.setDatabase( transMeta.findDatabase(wConnection.getText()) );\n\n\t\tin.setCommitSize( Const.toInt(wCommit.getText(), 0) );\n\t}","commit_id":"bda4e3ce52dffee87762854516477074b485c03a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\n \t\tprops.setLook(shell);\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"CombinationLookupDialog.Shell.Title\")); //$NON-NLS-1$\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\t\tci = input.getDatabase();\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"CombinationLookupDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabase()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\twConnection.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\t// We have new content: change ci connection:\n\t\t\t\t\tci = transMeta.findDatabase(wConnection.getText());\n\t\t\t\t\tsetAutoincUse();\n\t\t\t\t\tsetSequence();\n\t\t\t\t\tinput.setChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Table line...\n\t\twlTable = new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"CombinationLookupDialog.Target.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable = new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right = new FormAttachment(middle, -margin);\n\t\tfdlTable.top = new FormAttachment(wConnection, margin * 2);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable = new Button(shell, SWT.PUSH | SWT.CENTER);\n \t\tprops.setLook(wbTable);\n \t\twbTable.setText(Messages.getString(\"CombinationLookupDialog.BrowseTable.Button\"));\n\t\tfdbTable = new FormData();\n\t\tfdbTable.right = new FormAttachment(100, 0);\n\t\tfdbTable.top = new FormAttachment(wConnection, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable = new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top = new FormAttachment(wConnection, margin * 2);\n\t\tfdTable.right = new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\t\t\n\t\t\n\t\t// Commit size ...\n\t\twlCommit=new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"CombinationLookupDialog.Commitsize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit=new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.right= new FormAttachment(middle, -margin);\n\t\tfdlCommit.top  = new FormAttachment(wTable, margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit=new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top  = new FormAttachment(wTable, margin);\n\t\tfdCommit.right= new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n\n\t\t//\n\t\t// The Lookup fields: usually the (business) key\n\t\t//\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"CombinationLookupDialog.Keyfields.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCommit, margin);\n\t\tfdlKey.right = new FormAttachment(100, 0);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=2;\n\t\tint nrKeyRows=(input.getKeyField()!=null?input.getKeyField().length:1);\n\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"CombinationLookupDialog.ColumnInfo.FieldInStream\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"CombinationLookupDialog.ColumnInfo.DimensionField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\n\t\twKey=new TableView(shell,\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL,\n\t\t\t\t\t\t      ciKey,\n\t\t\t\t\t\t      nrKeyRows,\n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"CombinationLookupDialog.OK.Button\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"CombinationLookupDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twCreate=new Button(shell, SWT.PUSH);\n\t\twCreate.setText(Messages.getString(\"CombinationLookupDialog.SQL.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wGet, wCreate, wCancel }, margin, null);\n\n\t\t// Technical key field:\n\t\twlHashfield=new Label(shell, SWT.RIGHT);\n\t\twlHashfield.setText(Messages.getString(\"CombinationLookupDialog.Hashfield.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHashfield);\n\t\tfdlHashfield=new FormData();\n\t\tfdlHashfield.left  = new FormAttachment(0, 0);\n\t\tfdlHashfield.right = new FormAttachment(middle, -margin);\n\t\tfdlHashfield.bottom= new FormAttachment(wOK, -2*margin);\n\t\twlHashfield.setLayoutData(fdlHashfield);\n\t\twHashfield=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wHashfield);\n\t\twHashfield.addModifyListener(lsMod);\n\t\tfdHashfield=new FormData();\n\t\tfdHashfield.left  = new FormAttachment(middle, 0);\n\t\tfdHashfield.right = new FormAttachment(100, 0);\n\t\tfdHashfield.bottom= new FormAttachment(wOK, -2*margin);\n\t\twHashfield.setLayoutData(fdHashfield);\n\n\t\t// Output the input rows or one (1) log-record?\n\t\twlHashcode=new Label(shell, SWT.RIGHT);\n\t\twlHashcode.setText(Messages.getString(\"CombinationLookupDialog.Hashcode.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHashcode);\n\t\tfdlHashcode=new FormData();\n\t\tfdlHashcode.left  = new FormAttachment(0, 0);\n\t\tfdlHashcode.right = new FormAttachment(middle, -margin);\n\t\tfdlHashcode.bottom= new FormAttachment(wHashfield, -margin);\n\t\twlHashcode.setLayoutData(fdlHashcode);\n\t\twHashcode=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wHashcode);\n\t\tfdHashcode=new FormData();\n\t\tfdHashcode.left   = new FormAttachment(middle, 0);\n\t\tfdHashcode.right  = new FormAttachment(100, 0);\n\t\tfdHashcode.bottom = new FormAttachment(wHashfield, -margin);\n\t\twHashcode.setLayoutData(fdHashcode);\n\t\twHashcode.addSelectionListener(new SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tenableFields();\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Replace lookup fields in the output stream?\n\t\twlReplace=new Label(shell, SWT.RIGHT);\n\t\twlReplace.setText(Messages.getString(\"CombinationLookupDialog.Replace.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlReplace);\n\t\tfdlReplace=new FormData();\n\t\tfdlReplace.left  = new FormAttachment(0, 0);\n\t\tfdlReplace.right = new FormAttachment(middle, -margin);\n\t\tfdlReplace.bottom= new FormAttachment(wHashcode, -margin);\n\t\twlReplace.setLayoutData(fdlReplace);\n\t\twReplace=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wReplace);\n\t\tfdReplace=new FormData();\n\t\tfdReplace.left  = new FormAttachment(middle, 0);\n\t\tfdReplace.bottom= new FormAttachment(wHashcode, -margin);\n\t\tfdReplace.right = new FormAttachment(100, 0);\n\t\twReplace.setLayoutData(fdReplace);\n\t\twReplace.addSelectionListener(new SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tgTechGroup = new Group(shell, SWT.SHADOW_ETCHED_IN);\n\t\tgTechGroup.setText(Messages.getString(\"CombinationLookupDialog.TechGroup.Label\")); //$NON-NLS-1$;\n\t\tGridLayout gridLayout = new GridLayout(3, false);\n\t\tgTechGroup.setLayout(gridLayout);\n\t\tfdTechGroup=new FormData();\n\t\tfdTechGroup.left   = new FormAttachment(middle, 0);\n\t\tfdTechGroup.bottom = new FormAttachment(wReplace, -margin);\n\t\tfdTechGroup.right  = new FormAttachment(100, 0);\n\t\tgTechGroup.setBackground(shell.getBackground()); // the default looks ugly\n\t\tgTechGroup.setLayoutData(fdTechGroup);\n\n\t\t// Use maximum of table + 1\n\t\twTableMax=new Button(gTechGroup, SWT.RADIO);\n \t\tprops.setLook(wTableMax);\n \t\twTableMax.setSelection(false);\n\t\tgdTableMax=new GridData();\n\t\twTableMax.setLayoutData(gdTableMax);\n\t\twTableMax.setToolTipText(Messages.getString(\"CombinationLookupDialog.TableMaximum.Tooltip\",Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\twlTableMax=new Label(gTechGroup, SWT.LEFT);\n\t\twlTableMax.setText(Messages.getString(\"CombinationLookupDialog.TableMaximum.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTableMax);\n\t\tgdlTableMax = new GridData(GridData.FILL_BOTH);\n\t\tgdlTableMax.horizontalSpan = 2; gdlTableMax.verticalSpan = 1;\n\t\twlTableMax.setLayoutData(gdlTableMax);\n\t\t\n\t\t// Sequence Check Button\n\t\twSeqButton=new Button(gTechGroup, SWT.RADIO);\n \t\tprops.setLook(wSeqButton);\n \t\twSeqButton.setSelection(false);\n\t\tgdSeqButton=new GridData();\n\t\twSeqButton.setLayoutData(gdSeqButton);\n\t\twSeqButton.setToolTipText(Messages.getString(\"CombinationLookupDialog.Sequence.Tooltip\",Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\t\t\n\t\twlSeqButton=new Label(gTechGroup, SWT.LEFT);\n\t\twlSeqButton.setText(Messages.getString(\"CombinationLookupDialog.Sequence.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSeqButton); \t\n\t\tgdlSeqButton=new GridData();\n\t\twlSeqButton.setLayoutData(gdlSeqButton);\n\n\t\twSeq=new Text(gTechGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wSeq);\n\t\twSeq.addModifyListener(lsMod);\n\t\tgdSeq=new GridData(GridData.FILL_HORIZONTAL);\n\t\twSeq.setLayoutData(gdSeq);\n\t\twSeq.addFocusListener(new FocusListener() {\n\t\t\tpublic void focusGained(FocusEvent arg0) {\n\t\t\t\tinput.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_SEQUENCE);\n\t\t\t\twSeqButton.setSelection(true);\n\t\t\t\twAutoinc.setSelection(false);\n\t\t\t\twTableMax.setSelection(false);\t\t\t\t\n\t\t\t}\n\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t} \n\t\t});\t\t\n\t\t\n\t\t// Use an autoincrement field?\n\t\twAutoinc=new Button(gTechGroup, SWT.RADIO);\n \t\tprops.setLook(wAutoinc);\n \t\twAutoinc.setSelection(false);\n\t\tgdAutoinc=new GridData();\n\t\twAutoinc.setLayoutData(gdAutoinc);\n\t\twAutoinc.setToolTipText(Messages.getString(\"CombinationLookupDialog.AutoincButton.Tooltip\",Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\twlAutoinc=new Label(gTechGroup, SWT.LEFT);\n\t\twlAutoinc.setText(Messages.getString(\"CombinationLookupDialog.Autoincrement.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlAutoinc);\n\t\tgdlAutoinc=new GridData();\n\t\twlAutoinc.setLayoutData(gdlAutoinc);\n\n\t\tsetTableMax();\n\t\tsetSequence();\n\t\tsetAutoincUse();\n\t\t\n\t\t// Technical key field:\n\t\twlTk=new Label(shell, SWT.RIGHT);\n\t\twlTk.setText(Messages.getString(\"CombinationLookupDialog.TechnicalKey.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTk);\n\t\tfdlTk=new FormData();\n\t\tfdlTk.left   = new FormAttachment(0, 0);\n\t\tfdlTk.right  = new FormAttachment(middle, -margin);\n\t\tfdlTk.bottom = new FormAttachment(gTechGroup, -margin);\n\t\twlTk.setLayoutData(fdlTk);\n\t\twTk=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTk);\n\t\tfdTk=new FormData();\n\t\tfdTk.left   = new FormAttachment(middle, 0);\n\t\tfdTk.bottom = new FormAttachment(gTechGroup, -margin);\n\t\tfdTk.right  = new FormAttachment(100, 0);\n\t\twTk.setLayoutData(fdTk);\n\n\t\tfdKey=new FormData();\n\t\tfdKey.left  = new FormAttachment(0, 0);\n\t\tfdKey.top   = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(100, 0);\n\t\tfdKey.bottom= new FormAttachment(wTk, -margin);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();         } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();        } };\n\t\tlsCreate   = new Listener() { public void handleEvent(Event e) { create();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();     } };\n\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twCreate.addListener(SWT.Selection, lsCreate);\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twStepname.addSelectionListener( lsDef );\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n//\t\tinput.setChanged();\n\t\t\n\t\treturn stepname;\n\t}","id":89413,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\n \t\tprops.setLook(shell);\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"CombinationLookupDialog.Shell.Title\")); //$NON-NLS-1$\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\t\tci = input.getDatabase();\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"CombinationLookupDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabase()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\twConnection.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\t// We have new content: change ci connection:\n\t\t\t\t\tci = transMeta.findDatabase(wConnection.getText());\n\t\t\t\t\tsetAutoincUse();\n\t\t\t\t\tsetSequence();\n\t\t\t\t\tinput.setChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Table line...\n\t\twlTable = new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"CombinationLookupDialog.Target.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable = new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right = new FormAttachment(middle, -margin);\n\t\tfdlTable.top = new FormAttachment(wConnection, margin * 2);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable = new Button(shell, SWT.PUSH | SWT.CENTER);\n \t\tprops.setLook(wbTable);\n \t\twbTable.setText(Messages.getString(\"CombinationLookupDialog.BrowseTable.Button\"));\n\t\tfdbTable = new FormData();\n\t\tfdbTable.right = new FormAttachment(100, 0);\n\t\tfdbTable.top = new FormAttachment(wConnection, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable = new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top = new FormAttachment(wConnection, margin * 2);\n\t\tfdTable.right = new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\t\t\n\t\t\n\t\t// Commit size ...\n\t\twlCommit=new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"CombinationLookupDialog.Commitsize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit=new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.right= new FormAttachment(middle, -margin);\n\t\tfdlCommit.top  = new FormAttachment(wTable, margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit=new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top  = new FormAttachment(wTable, margin);\n\t\tfdCommit.right= new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n\n\t\t//\n\t\t// The Lookup fields: usually the (business) key\n\t\t//\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"CombinationLookupDialog.Keyfields.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCommit, margin);\n\t\tfdlKey.right = new FormAttachment(100, 0);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=2;\n\t\tint nrKeyRows=(input.getKeyField()!=null?input.getKeyField().length:1);\n\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"CombinationLookupDialog.ColumnInfo.DimensionField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"CombinationLookupDialog.ColumnInfo.FieldInStream\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\n\t\twKey=new TableView(shell,\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL,\n\t\t\t\t\t\t      ciKey,\n\t\t\t\t\t\t      nrKeyRows,\n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"CombinationLookupDialog.OK.Button\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"CombinationLookupDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twCreate=new Button(shell, SWT.PUSH);\n\t\twCreate.setText(Messages.getString(\"CombinationLookupDialog.SQL.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wGet, wCreate, wCancel }, margin, null);\n\n\t\t// Technical key field:\n\t\twlHashfield=new Label(shell, SWT.RIGHT);\n\t\twlHashfield.setText(Messages.getString(\"CombinationLookupDialog.Hashfield.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHashfield);\n\t\tfdlHashfield=new FormData();\n\t\tfdlHashfield.left  = new FormAttachment(0, 0);\n\t\tfdlHashfield.right = new FormAttachment(middle, -margin);\n\t\tfdlHashfield.bottom= new FormAttachment(wOK, -2*margin);\n\t\twlHashfield.setLayoutData(fdlHashfield);\n\t\twHashfield=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wHashfield);\n\t\twHashfield.addModifyListener(lsMod);\n\t\tfdHashfield=new FormData();\n\t\tfdHashfield.left  = new FormAttachment(middle, 0);\n\t\tfdHashfield.right = new FormAttachment(100, 0);\n\t\tfdHashfield.bottom= new FormAttachment(wOK, -2*margin);\n\t\twHashfield.setLayoutData(fdHashfield);\n\n\t\t// Output the input rows or one (1) log-record?\n\t\twlHashcode=new Label(shell, SWT.RIGHT);\n\t\twlHashcode.setText(Messages.getString(\"CombinationLookupDialog.Hashcode.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHashcode);\n\t\tfdlHashcode=new FormData();\n\t\tfdlHashcode.left  = new FormAttachment(0, 0);\n\t\tfdlHashcode.right = new FormAttachment(middle, -margin);\n\t\tfdlHashcode.bottom= new FormAttachment(wHashfield, -margin);\n\t\twlHashcode.setLayoutData(fdlHashcode);\n\t\twHashcode=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wHashcode);\n\t\tfdHashcode=new FormData();\n\t\tfdHashcode.left   = new FormAttachment(middle, 0);\n\t\tfdHashcode.right  = new FormAttachment(100, 0);\n\t\tfdHashcode.bottom = new FormAttachment(wHashfield, -margin);\n\t\twHashcode.setLayoutData(fdHashcode);\n\t\twHashcode.addSelectionListener(new SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tenableFields();\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Replace lookup fields in the output stream?\n\t\twlReplace=new Label(shell, SWT.RIGHT);\n\t\twlReplace.setText(Messages.getString(\"CombinationLookupDialog.Replace.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlReplace);\n\t\tfdlReplace=new FormData();\n\t\tfdlReplace.left  = new FormAttachment(0, 0);\n\t\tfdlReplace.right = new FormAttachment(middle, -margin);\n\t\tfdlReplace.bottom= new FormAttachment(wHashcode, -margin);\n\t\twlReplace.setLayoutData(fdlReplace);\n\t\twReplace=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wReplace);\n\t\tfdReplace=new FormData();\n\t\tfdReplace.left  = new FormAttachment(middle, 0);\n\t\tfdReplace.bottom= new FormAttachment(wHashcode, -margin);\n\t\tfdReplace.right = new FormAttachment(100, 0);\n\t\twReplace.setLayoutData(fdReplace);\n\t\twReplace.addSelectionListener(new SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tgTechGroup = new Group(shell, SWT.SHADOW_ETCHED_IN);\n\t\tgTechGroup.setText(Messages.getString(\"CombinationLookupDialog.TechGroup.Label\")); //$NON-NLS-1$;\n\t\tGridLayout gridLayout = new GridLayout(3, false);\n\t\tgTechGroup.setLayout(gridLayout);\n\t\tfdTechGroup=new FormData();\n\t\tfdTechGroup.left   = new FormAttachment(middle, 0);\n\t\tfdTechGroup.bottom = new FormAttachment(wReplace, -margin);\n\t\tfdTechGroup.right  = new FormAttachment(100, 0);\n\t\tgTechGroup.setBackground(shell.getBackground()); // the default looks ugly\n\t\tgTechGroup.setLayoutData(fdTechGroup);\n\n\t\t// Use maximum of table + 1\n\t\twTableMax=new Button(gTechGroup, SWT.RADIO);\n \t\tprops.setLook(wTableMax);\n \t\twTableMax.setSelection(false);\n\t\tgdTableMax=new GridData();\n\t\twTableMax.setLayoutData(gdTableMax);\n\t\twTableMax.setToolTipText(Messages.getString(\"CombinationLookupDialog.TableMaximum.Tooltip\",Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\twlTableMax=new Label(gTechGroup, SWT.LEFT);\n\t\twlTableMax.setText(Messages.getString(\"CombinationLookupDialog.TableMaximum.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTableMax);\n\t\tgdlTableMax = new GridData(GridData.FILL_BOTH);\n\t\tgdlTableMax.horizontalSpan = 2; gdlTableMax.verticalSpan = 1;\n\t\twlTableMax.setLayoutData(gdlTableMax);\n\t\t\n\t\t// Sequence Check Button\n\t\twSeqButton=new Button(gTechGroup, SWT.RADIO);\n \t\tprops.setLook(wSeqButton);\n \t\twSeqButton.setSelection(false);\n\t\tgdSeqButton=new GridData();\n\t\twSeqButton.setLayoutData(gdSeqButton);\n\t\twSeqButton.setToolTipText(Messages.getString(\"CombinationLookupDialog.Sequence.Tooltip\",Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\t\t\n\t\twlSeqButton=new Label(gTechGroup, SWT.LEFT);\n\t\twlSeqButton.setText(Messages.getString(\"CombinationLookupDialog.Sequence.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSeqButton); \t\n\t\tgdlSeqButton=new GridData();\n\t\twlSeqButton.setLayoutData(gdlSeqButton);\n\n\t\twSeq=new Text(gTechGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wSeq);\n\t\twSeq.addModifyListener(lsMod);\n\t\tgdSeq=new GridData(GridData.FILL_HORIZONTAL);\n\t\twSeq.setLayoutData(gdSeq);\n\t\twSeq.addFocusListener(new FocusListener() {\n\t\t\tpublic void focusGained(FocusEvent arg0) {\n\t\t\t\tinput.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_SEQUENCE);\n\t\t\t\twSeqButton.setSelection(true);\n\t\t\t\twAutoinc.setSelection(false);\n\t\t\t\twTableMax.setSelection(false);\t\t\t\t\n\t\t\t}\n\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t} \n\t\t});\t\t\n\t\t\n\t\t// Use an autoincrement field?\n\t\twAutoinc=new Button(gTechGroup, SWT.RADIO);\n \t\tprops.setLook(wAutoinc);\n \t\twAutoinc.setSelection(false);\n\t\tgdAutoinc=new GridData();\n\t\twAutoinc.setLayoutData(gdAutoinc);\n\t\twAutoinc.setToolTipText(Messages.getString(\"CombinationLookupDialog.AutoincButton.Tooltip\",Const.CR)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\twlAutoinc=new Label(gTechGroup, SWT.LEFT);\n\t\twlAutoinc.setText(Messages.getString(\"CombinationLookupDialog.Autoincrement.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlAutoinc);\n\t\tgdlAutoinc=new GridData();\n\t\twlAutoinc.setLayoutData(gdlAutoinc);\n\n\t\tsetTableMax();\n\t\tsetSequence();\n\t\tsetAutoincUse();\n\t\t\n\t\t// Technical key field:\n\t\twlTk=new Label(shell, SWT.RIGHT);\n\t\twlTk.setText(Messages.getString(\"CombinationLookupDialog.TechnicalKey.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTk);\n\t\tfdlTk=new FormData();\n\t\tfdlTk.left   = new FormAttachment(0, 0);\n\t\tfdlTk.right  = new FormAttachment(middle, -margin);\n\t\tfdlTk.bottom = new FormAttachment(gTechGroup, -margin);\n\t\twlTk.setLayoutData(fdlTk);\n\t\twTk=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTk);\n\t\tfdTk=new FormData();\n\t\tfdTk.left   = new FormAttachment(middle, 0);\n\t\tfdTk.bottom = new FormAttachment(gTechGroup, -margin);\n\t\tfdTk.right  = new FormAttachment(100, 0);\n\t\twTk.setLayoutData(fdTk);\n\n\t\tfdKey=new FormData();\n\t\tfdKey.left  = new FormAttachment(0, 0);\n\t\tfdKey.top   = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(100, 0);\n\t\tfdKey.bottom= new FormAttachment(wTk, -margin);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();         } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();        } };\n\t\tlsCreate   = new Listener() { public void handleEvent(Event e) { create();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();     } };\n\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twCreate.addListener(SWT.Selection, lsCreate);\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twStepname.addSelectionListener( lsDef );\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\t\n\t\treturn stepname;\n\t}","commit_id":"bda4e3ce52dffee87762854516477074b485c03a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), Messages.getString(\"CombinationLookupDialog.Log.GettingKeyInfo\")); //$NON-NLS-1$\n\n\t\tif (input.getKeyField()!=null)\n\t\tfor (i=0;i<input.getKeyField().length;i++)\n\t\t{\n\t\t\tTableItem item = wKey.table.getItem(i);\n\t\t\tif (input.getKeyField()[i]!=null)  item.setText(1, input.getKeyField()[i]);\n\t\t\tif (input.getKeyLookup()[i]!=null) item.setText(2, input.getKeyLookup()[i]);\n\t\t}\n\n\t\twReplace.setSelection( input.replaceFields() );\n\t\twHashcode.setSelection( input.useHash() );\n\t\twHashfield.setEnabled(input.useHash());\n\t\twHashfield.setVisible(input.useHash());\n\t\twlHashfield.setEnabled(input.useHash());\n\t\t\n\t\tString techKeyCreation = input.getTechKeyCreation(); \n\t\tif ( techKeyCreation == null )  {\t\t    \n\t\t    // Determine the creation of the technical key for\n\t\t\t// backwards compatibility. Can probably be removed at\n\t\t\t// version 3.x or so (Sven Boden).\n\t\t    DatabaseMeta database = input.getDatabase(); \n\t\t    if ( database == null || ! database.supportsAutoinc() )  \n\t\t    {\n \t\t\t    input.setUseAutoinc(false);\t\t\t\n\t\t    }\t\t\n\t\t    wAutoinc.setSelection(input.isUseAutoinc());\n\t\t    \n\t\t    wSeqButton.setSelection(input.getSequenceFrom() != null && input.getSequenceFrom().length() > 0);\n\t\t    if ( input.isUseAutoinc() == false && \n\t\t\t     (input.getSequenceFrom() == null || input.getSequenceFrom().length() <= 0) ) \n\t\t    {\n \t\t\t    wTableMax.setSelection(true); \t\t\t    \n\t\t    }\n\t\t    \n\t\t\tif ( database != null && database.supportsSequences() && \n\t\t\t\t input.getSequenceFrom() != null) \n\t\t\t{\n\t\t\t\twSeq.setText(input.getSequenceFrom());\n\t\t\t\tinput.setUseAutoinc(false);\n\t\t\t\twTableMax.setSelection(false);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    // KETTLE post 2.2 version:\n\t\t\t// The \"creation\" field now determines the behaviour of the\n\t\t\t// key creation.\n\t\t\tif ( CombinationLookupMeta.CREATION_METHOD_AUTOINC.equals(techKeyCreation))  \n\t\t\t{\n\t\t\t    wAutoinc.setSelection(true);\n\t\t\t}\n\t\t\telse if ( ( CombinationLookupMeta.CREATION_METHOD_SEQUENCE.equals(techKeyCreation)) )\n\t\t\t{\n\t\t\t\twSeqButton.setSelection(true);\n\t\t\t}\n\t\t\telse // the rest\n\t\t\t{\n\t\t\t\twTableMax.setSelection(true);\n\t\t\t\tinput.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_TABLEMAX);\n\t\t\t}\n\t\t\tif ( input.getSequenceFrom() != null )\n\t\t\t{\n    \t        wSeq.setText(input.getSequenceFrom());\n\t\t\t}\n\t\t}\n\t\tsetAutoincUse();\n\t\tsetSequence();\n\t\tsetTableMax();\n  \t\tif (input.getTablename()!=null)         wTable.setText( input.getTablename() );\n\t\tif (input.getTechnicalKeyField()!=null) wTk.setText(input.getTechnicalKeyField());\n\n\t\tif (input.getDatabase()!=null) wConnection.setText(input.getDatabase().getName());\n\t\telse if (transMeta.nrDatabases()==1)\n\t\t{\n\t\t\twConnection.setText( transMeta.getDatabase(0).getName() );\n\t\t}\n\t\tif (input.getHashField()!=null)    wHashfield.setText(input.getHashField());\n\n\t\twCommit.setText(\"\"+input.getCommitSize()); //$NON-NLS-1$\n\n\t\twKey.setRowNums();\n\t\twKey.optWidth(true);\n\n\t\twStepname.selectAll();\n\t}","id":89414,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\tint i;\n\t\tlog.logDebug(toString(), Messages.getString(\"CombinationLookupDialog.Log.GettingKeyInfo\")); //$NON-NLS-1$\n\n\t\tif (input.getKeyField()!=null)\n\t\tfor (i=0;i<input.getKeyField().length;i++)\n\t\t{\n\t\t\tTableItem item = wKey.table.getItem(i);\n\t\t\tif (input.getKeyLookup()[i]!=null) item.setText(1, input.getKeyLookup()[i]);\n\t\t\tif (input.getKeyField()[i]!=null)  item.setText(2, input.getKeyField()[i]);\t\t\t\n\t\t}\n\n\t\twReplace.setSelection( input.replaceFields() );\n\t\twHashcode.setSelection( input.useHash() );\n\t\twHashfield.setEnabled(input.useHash());\n\t\twHashfield.setVisible(input.useHash());\n\t\twlHashfield.setEnabled(input.useHash());\n\t\t\n\t\tString techKeyCreation = input.getTechKeyCreation(); \n\t\tif ( techKeyCreation == null )  {\t\t    \n\t\t    // Determine the creation of the technical key for\n\t\t\t// backwards compatibility. Can probably be removed at\n\t\t\t// version 3.x or so (Sven Boden).\n\t\t    DatabaseMeta database = input.getDatabase(); \n\t\t    if ( database == null || ! database.supportsAutoinc() )  \n\t\t    {\n \t\t\t    input.setUseAutoinc(false);\t\t\t\n\t\t    }\t\t\n\t\t    wAutoinc.setSelection(input.isUseAutoinc());\n\t\t    \n\t\t    wSeqButton.setSelection(input.getSequenceFrom() != null && input.getSequenceFrom().length() > 0);\n\t\t    if ( input.isUseAutoinc() == false && \n\t\t\t     (input.getSequenceFrom() == null || input.getSequenceFrom().length() <= 0) ) \n\t\t    {\n \t\t\t    wTableMax.setSelection(true); \t\t\t    \n\t\t    }\n\t\t    \n\t\t\tif ( database != null && database.supportsSequences() && \n\t\t\t\t input.getSequenceFrom() != null) \n\t\t\t{\n\t\t\t\twSeq.setText(input.getSequenceFrom());\n\t\t\t\tinput.setUseAutoinc(false);\n\t\t\t\twTableMax.setSelection(false);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    // KETTLE post 2.2 version:\n\t\t\t// The \"creation\" field now determines the behaviour of the\n\t\t\t// key creation.\n\t\t\tif ( CombinationLookupMeta.CREATION_METHOD_AUTOINC.equals(techKeyCreation))  \n\t\t\t{\n\t\t\t    wAutoinc.setSelection(true);\n\t\t\t}\n\t\t\telse if ( ( CombinationLookupMeta.CREATION_METHOD_SEQUENCE.equals(techKeyCreation)) )\n\t\t\t{\n\t\t\t\twSeqButton.setSelection(true);\n\t\t\t}\n\t\t\telse // the rest\n\t\t\t{\n\t\t\t\twTableMax.setSelection(true);\n\t\t\t\tinput.setTechKeyCreation(CombinationLookupMeta.CREATION_METHOD_TABLEMAX);\n\t\t\t}\n\t\t\tif ( input.getSequenceFrom() != null )\n\t\t\t{\n    \t        wSeq.setText(input.getSequenceFrom());\n\t\t\t}\n\t\t}\n\t\tsetAutoincUse();\n\t\tsetSequence();\n\t\tsetTableMax();\n  \t\tif (input.getTablename()!=null)         wTable.setText( input.getTablename() );\n\t\tif (input.getTechnicalKeyField()!=null) wTk.setText(input.getTechnicalKeyField());\n\n\t\tif (input.getDatabase()!=null) wConnection.setText(input.getDatabase().getName());\n\t\telse if (transMeta.nrDatabases()==1)\n\t\t{\n\t\t\twConnection.setText( transMeta.getDatabase(0).getName() );\n\t\t}\n\t\tif (input.getHashField()!=null)    wHashfield.setText(input.getHashField());\n\n\t\twCommit.setText(\"\"+input.getCommitSize()); //$NON-NLS-1$\n\n\t\twKey.setRowNums();\n\t\twKey.optWidth(true);\n\n\t\twStepname.selectAll();\n\t}","commit_id":"bda4e3ce52dffee87762854516477074b485c03a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public SQLStatement getSQLStatements(TransMeta transMeta, StepMeta stepMeta, Row prev)\n\t{\n\t\tSQLStatement retval = new SQLStatement(stepMeta.getName(), database, null); // default: nothing to do!\n\n\t\tint i;\n\n\t\tif (database!=null)\n\t\t{\n\t\t\tif (prev!=null && prev.size()>0)\n\t\t\t{\n\t\t\t\tif (tablename!=null && tablename.length()>0)\n\t\t\t\t{\n\t\t\t\t\tDatabase db = new Database(database);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tboolean doHash = false;\n\t\t\t\t\t\tString cr_table = null;\n\n\t\t\t\t\t\tdb.connect();\n\n\t\t\t\t\t\t// OK, what do we put in the new table??\n\t\t\t\t\t\tRow fields = new Row();\n\n\t\t\t\t\t\t// First, the new technical key...\n\t\t\t\t\t\tValue vkeyfield = new Value(technicalKeyField, Value.VALUE_TYPE_INTEGER);\n\t\t\t\t\t\tvkeyfield.setLength(10,0);\n\n\t\t\t\t\t\t// Then the hashcode (optional)\n\t\t\t\t\t\tValue vhashfield = null;\n\t\t\t\t\t\tif (useHash && hashField != null && hashField.length()>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvhashfield = new Value(hashField, Value.VALUE_TYPE_INTEGER);\n\t\t\t\t\t\t\tvhashfield.setLength(15,0);\n\t\t\t\t\t\t\tdoHash = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! db.checkTableExists(tablename) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Add technical key field.\n\t\t\t\t\t\t\tfields.addValue(vkeyfield);\n\n\t\t\t\t\t\t\tString keyLookup[] = getKeyLookup();\n\t\t\t\t\t\t\tif ( keyLookup != null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint cnt = prev.size();\n\t\t\t\t\t\t\t\tfor (i=0;i<cnt;i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString error_field=\"\"; //$NON-NLS-1$\n\n\t\t\t\t\t\t\t\t\tValue v = prev.getValue(i);\n\t\t\t\t\t\t\t\t\tValue newValue = (Value)v.clone();\n\t\t\t\t\t\t\t\t\tString name = keyLookup[i];\n\t\t\t\t\t\t\t\t\tnewValue.setName(name);\n\t\t\t\t\t\t\t\t\tif ( name.equals(vkeyfield.getName()) ||\n\t\t\t\t\t\t\t\t\t\t\t(doHash == true && name.equals(vhashfield.getName())) )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\terror_field+=name;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (error_field.length()>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NameCollision\", error_field)); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfields.addValue(newValue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( doHash == true )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfields.addValue(vhashfield);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Table already exists\n\n\t\t\t\t\t\t\t// Get the fields that are in the table now:\n\t\t\t\t\t\t\tRow tabFields = db.getTableFields(tablename);\n\n\t\t\t\t\t\t\t// Don't forget to quote these as well...\n\t\t\t\t\t\t\tdatabase.quoteReservedWords(tabFields);\n\n\t\t\t\t\t\t\tif (tabFields.searchValue( vkeyfield.getName() ) == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Add technical key field if it didn't exist yet\n\t\t\t\t\t\t\t\tfields.addValue(vkeyfield);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add the already existing fields\n\t\t\t\t\t\t\tint cnt = tabFields.size();\n\t\t\t\t\t\t\tfor ( i=0;i<cnt;i++ )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tValue v = tabFields.getValue(i);\n\n\t\t\t\t\t\t\t\tfields.addValue(v);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Find the missing fields in the real table\n\t\t\t\t\t\t\tString keyLookup[] = getKeyLookup();\n\t\t\t\t\t\t\tif ( keyLookup != null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcnt = prev.size();\n\t\t\t\t\t\t\t\tfor ( i=0;i<cnt;i++ )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tValue v = prev.getValue(i);\n\t\t\t\t\t\t\t\t\tValue newValue = (Value)v.clone();\n\t\t\t\t\t\t\t\t\tString name = keyLookup[i];\n\t\t\t\t\t\t\t\t\tnewValue.setName(name);\n\n\t\t\t\t\t\t\t\t\tif ( tabFields.searchValue( newValue.getName() )==null )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfields.addValue(newValue); // nope --> add\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (doHash == true && tabFields.searchValue( vhashfield.getName() ) == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Add hash field\n\t\t\t\t\t\t\t\tfields.addValue(vhashfield);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcr_table = db.getDDL(tablename,\n\t\t\t\t\t\t\t\t             fields,\n\t\t\t\t\t\t\t\t             (CREATION_METHOD_SEQUENCE.equals(getTechKeyCreation()) &&\n\t\t\t\t\t\t\t\t\t\t     sequenceFrom!=null && sequenceFrom.length()==0)?technicalKeyField:null,\n\t\t\t\t\t\t\t\t\t\t\t CREATION_METHOD_AUTOINC.equals(getTechKeyCreation()),\n\t\t\t\t\t\t\t\t\t\t\t null,\n\t\t\t\t\t\t\t\t\t\t\t true);\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// OK, now let's build the index\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// What fields do we put int the index?\n\t\t\t\t\t\t// Only the hashcode or all fields?\n\t\t\t\t\t\tString cr_index = \"\"; //$NON-NLS-1$\n\t\t\t\t\t\tString cr_uniq_index = \"\"; //$NON-NLS-1$\n\t\t\t\t\t\tString idx_fields[] = null;\n\t\t\t\t\t\tif (useHash)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (hashField!=null && hashField.length()>0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tidx_fields = new String[] { hashField };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotHashFieldSpecified\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse  // index on all key fields...\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (keyLookup!=null && keyLookup.length>0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint nrfields = keyLookup.length;\n\t\t\t\t\t\t\t\tif (nrfields>32 && database.getDatabaseType()==DatabaseMeta.TYPE_DATABASE_ORACLE)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnrfields=32;  // Oracle indexes are limited to 32 fields...\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tidx_fields = new String[nrfields];\n\t\t\t\t\t\t\t\tfor (i=0;i<nrfields;i++) idx_fields[i] = keyLookup[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotFieldsSpecified\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// OK, now get the create index statement...\n\n\t\t\t\t\t\tif ( technicalKeyField != null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString techKeyArr[] = new String [] { technicalKeyField };\n\t\t\t\t\t\t\tif (!db.checkIndexExists(tablename, techKeyArr))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString indexname = \"idx_\"+tablename+\"_pk\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\tcr_uniq_index = db.getCreateIndexStatement(tablename, indexname, techKeyArr, true, true, false, true);\n\t\t\t\t\t\t\t\tcr_uniq_index+=Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// OK, now get the create lookup index statement...\n\t\t\t\t\t\tif (idx_fields!=null && idx_fields.length>0 &&\n\t\t\t\t\t\t\t\t!db.checkIndexExists(tablename, idx_fields)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString indexname = \"idx_\"+tablename+\"_lookup\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\tcr_index = db.getCreateIndexStatement(tablename, indexname, idx_fields, false, false, false, true);\n\t\t\t\t\t\t\tcr_index+=Const.CR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Don't forget the sequence (optional)\n\t\t\t\t\t\t//\n\t\t\t\t\t\tString cr_seq=\"\"; //$NON-NLS-1$\n\t\t\t\t\t\tif ((database.getDatabaseType()==DatabaseMeta.TYPE_DATABASE_ORACLE) &&\n\t\t\t\t\t\t\t\tCREATION_METHOD_SEQUENCE.equals(getTechKeyCreation()) &&\n\t\t\t\t\t\t\t\tsequenceFrom!=null && sequenceFrom.length()>0\n\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!db.checkSequenceExists(sequenceFrom))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcr_seq+=db.getCreateSequenceStatement(sequenceFrom, 1L, 1L, -1L, true);\n\t\t\t\t\t\t\t\tcr_seq+=Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tretval.setSQL(cr_table+cr_uniq_index+cr_index+cr_seq);\n\t\t\t\t\t}\n\t\t\t\t\tcatch(KettleException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.ErrorOccurred\")+Const.CR+e.getMessage()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotTableDefined\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotReceivingField\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotConnectionDefined\")); //$NON-NLS-1$\n\t\t}\n\n\t\treturn retval;\n\t}","id":89415,"modified_method":"public SQLStatement getSQLStatements(TransMeta transMeta, StepMeta stepMeta, Row prev)\n\t{\n\t\tSQLStatement retval = new SQLStatement(stepMeta.getName(), database, null); // default: nothing to do!\n\n\t\tint i;\n\n\t\tif (database!=null)\n\t\t{\n\t\t\tif (prev!=null && prev.size()>0)\n\t\t\t{\n\t\t\t\tif (tablename!=null && tablename.length()>0)\n\t\t\t\t{\n\t\t\t\t\tDatabase db = new Database(database);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tboolean doHash = false;\n\t\t\t\t\t\tString cr_table = null;\n\n\t\t\t\t\t\tdb.connect();\n\n\t\t\t\t\t\t// OK, what do we put in the new table??\n\t\t\t\t\t\tRow fields = new Row();\n\n\t\t\t\t\t\t// First, the new technical key...\n\t\t\t\t\t\tValue vkeyfield = new Value(technicalKeyField, Value.VALUE_TYPE_INTEGER);\n\t\t\t\t\t\tvkeyfield.setLength(10,0);\n\n\t\t\t\t\t\t// Then the hashcode (optional)\n\t\t\t\t\t\tValue vhashfield = null;\n\t\t\t\t\t\tif (useHash && hashField != null && hashField.length()>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvhashfield = new Value(hashField, Value.VALUE_TYPE_INTEGER);\n\t\t\t\t\t\t\tvhashfield.setLength(15,0);\n\t\t\t\t\t\t\tdoHash = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! db.checkTableExists(tablename) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Add technical key field.\n\t\t\t\t\t\t\tfields.addValue(vkeyfield);\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Add the keys only to the table\n\t\t\t\t\t\t\tif ( keyField != null && keyLookup != null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint cnt = keyField.length;\n\t\t\t\t\t\t\t\tfor ( i=0;i<cnt;i++ )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString error_field=\"\"; //$NON-NLS-1$\n\n\t\t\t\t\t\t\t\t\t// Find the value in the stream\n\t\t\t\t\t\t\t\t\tValue v = prev.searchValue(keyField[i]);\n\t\t\t\t\t\t\t\t\tif ( v != null )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tString name = keyLookup[i];\n\t\t\t\t\t\t\t\t\t    Value newValue = (Value)v.clone();\n\t\t\t\t\t\t\t\t\t    newValue.setName(name);\n\n        \t\t\t\t\t\t\t\tif ( name.equals(vkeyfield.getName()) ||\n\t\t \t\t  \t\t\t\t\t\t\t (doHash == true && name.equals(vhashfield.getName())) )\n  \t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t    error_field+=name;\n\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t    if (error_field.length()>0)\n\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t    retval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NameCollision\", error_field)); //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t    else\n\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t        fields.addValue(newValue);\n\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( doHash == true )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfields.addValue(vhashfield);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Table already exists\n\n\t\t\t\t\t\t\t// Get the fields that are in the table now:\n\t\t\t\t\t\t\tRow tabFields = db.getTableFields(tablename);\n\n\t\t\t\t\t\t\t// Don't forget to quote these as well...\n\t\t\t\t\t\t\tdatabase.quoteReservedWords(tabFields);\n\n\t\t\t\t\t\t\tif (tabFields.searchValue( vkeyfield.getName() ) == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Add technical key field if it didn't exist yet\n\t\t\t\t\t\t\t\tfields.addValue(vkeyfield);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add the already existing fields\n\t\t\t\t\t\t\tint cnt = tabFields.size();\n\t\t\t\t\t\t\tfor ( i=0;i<cnt;i++ )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tValue v = tabFields.getValue(i);\n\n\t\t\t\t\t\t\t\tfields.addValue(v);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Find the missing fields in the real table\n\t\t\t\t\t\t\tString keyLookup[] = getKeyLookup();\n\t\t\t\t\t\t\tString keyField[] = getKeyField();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ( keyField != null && keyLookup != null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcnt = keyField.length;\n\t\t\t\t\t\t\t\tfor ( i=0;i<cnt;i++ )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Find the value in the stream\n\t\t\t\t\t\t\t\t\tValue v = prev.searchValue(keyField[i]);\n\t\t\t\t\t\t\t\t\tif ( v != null )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t    Value newValue = (Value)v.clone();\n\t\t\t\t\t\t\t\t\t    newValue.setName(keyLookup[i]);\n\n\t\t\t\t\t\t\t\t\t    // Does the corresponding name exist in the table\n\t\t\t\t\t\t\t\t\t    if ( tabFields.searchValue( newValue.getName() )==null )\n\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t    fields.addValue(newValue); // nope --> add\n\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (doHash == true && tabFields.searchValue( vhashfield.getName() ) == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Add hash field\n\t\t\t\t\t\t\t\tfields.addValue(vhashfield);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcr_table = db.getDDL(tablename,\n\t\t\t\t\t\t\t\t             fields,\n\t\t\t\t\t\t\t\t             (CREATION_METHOD_SEQUENCE.equals(getTechKeyCreation()) &&\n\t\t\t\t\t\t\t\t\t\t     sequenceFrom!=null && sequenceFrom.length()==0)?technicalKeyField:null,\n\t\t\t\t\t\t\t\t\t\t\t CREATION_METHOD_AUTOINC.equals(getTechKeyCreation()),\n\t\t\t\t\t\t\t\t\t\t\t null,\n\t\t\t\t\t\t\t\t\t\t\t true);\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// OK, now let's build the index\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// What fields do we put int the index?\n\t\t\t\t\t\t// Only the hashcode or all fields?\n\t\t\t\t\t\tString cr_index = \"\"; //$NON-NLS-1$\n\t\t\t\t\t\tString cr_uniq_index = \"\"; //$NON-NLS-1$\n\t\t\t\t\t\tString idx_fields[] = null;\n\t\t\t\t\t\tif (useHash)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (hashField!=null && hashField.length()>0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tidx_fields = new String[] { hashField };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotHashFieldSpecified\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse  // index on all key fields...\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (keyLookup!=null && keyLookup.length>0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint nrfields = keyLookup.length;\n\t\t\t\t\t\t\t\tif (nrfields>32 && database.getDatabaseType()==DatabaseMeta.TYPE_DATABASE_ORACLE)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnrfields=32;  // Oracle indexes are limited to 32 fields...\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tidx_fields = new String[nrfields];\n\t\t\t\t\t\t\t\tfor (i=0;i<nrfields;i++) idx_fields[i] = keyLookup[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotFieldsSpecified\")); //$NON-NLS-1$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// OK, now get the create index statement...\n\n\t\t\t\t\t\tif ( technicalKeyField != null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString techKeyArr[] = new String [] { technicalKeyField };\n\t\t\t\t\t\t\tif (!db.checkIndexExists(tablename, techKeyArr))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString indexname = \"idx_\"+tablename+\"_pk\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\t\tcr_uniq_index = db.getCreateIndexStatement(tablename, indexname, techKeyArr, true, true, false, true);\n\t\t\t\t\t\t\t\tcr_uniq_index+=Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// OK, now get the create lookup index statement...\n\t\t\t\t\t\tif (idx_fields!=null && idx_fields.length>0 &&\n\t\t\t\t\t\t\t\t!db.checkIndexExists(tablename, idx_fields)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString indexname = \"idx_\"+tablename+\"_lookup\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t\tcr_index = db.getCreateIndexStatement(tablename, indexname, idx_fields, false, false, false, true);\n\t\t\t\t\t\t\tcr_index+=Const.CR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Don't forget the sequence (optional)\n\t\t\t\t\t\t//\n\t\t\t\t\t\tString cr_seq=\"\"; //$NON-NLS-1$\n\t\t\t\t\t\tif ((database.getDatabaseType()==DatabaseMeta.TYPE_DATABASE_ORACLE) &&\n\t\t\t\t\t\t\t\tCREATION_METHOD_SEQUENCE.equals(getTechKeyCreation()) &&\n\t\t\t\t\t\t\t\tsequenceFrom!=null && sequenceFrom.length()>0\n\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!db.checkSequenceExists(sequenceFrom))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcr_seq+=db.getCreateSequenceStatement(sequenceFrom, 1L, 1L, -1L, true);\n\t\t\t\t\t\t\t\tcr_seq+=Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tretval.setSQL(cr_table+cr_uniq_index+cr_index+cr_seq);\n\t\t\t\t\t}\n\t\t\t\t\tcatch(KettleException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.ErrorOccurred\")+Const.CR+e.getMessage()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotTableDefined\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotReceivingField\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tretval.setError(Messages.getString(\"CombinationLookupMeta.ReturnValue.NotConnectionDefined\")); //$NON-NLS-1$\n\t\t}\n\n\t\treturn retval;\n\t}","commit_id":"bda4e3ce52dffee87762854516477074b485c03a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static long getAgentId(final byte[] bytes) {\n        return NumbersUtil.bytesToLong(bytes, 28);\n    }","id":89416,"modified_method":"public static long getAgentId(final byte[] bytes) {\n        return NumbersUtil.bytesToLong(bytes, 24);\n    }","commit_id":"a0ce3da1913e580d767a0942de347b8cedf7a3f4","url":"https://github.com/apache/cloudstack"},{"original_method":"public static long getViaAgentId(final byte[] bytes) {\n        return NumbersUtil.bytesToLong(bytes, 24);\n    }","id":89417,"modified_method":"public static long getViaAgentId(final byte[] bytes) {\n        return NumbersUtil.bytesToLong(bytes, 32);\n    }","commit_id":"a0ce3da1913e580d767a0942de347b8cedf7a3f4","url":"https://github.com/apache/cloudstack"},{"original_method":"protected String log(String msg, boolean logContent, Level level) {\n        StringBuilder content = new StringBuilder();\n        if (logContent) {\n            if (_cmds == null) {\n                _cmds = s_gson.fromJson(_content, this instanceof Response ? Answer[].class : Command[].class);\n            }\n            try {\n                s_gogger.toJson(_cmds, content);\n            } catch (Throwable e) {\n                StringBuilder buff = new StringBuilder();\n                for (Command cmd : _cmds) {\n                    buff.append(cmd.getClass().getSimpleName()).append(\"/\");\n                }\n                s_logger.error(\"Gson serialization error \" + buff.toString(), e);\n                assert false : \"More gson errors on \" + buff.toString();\n                return \"\";\n            }\n            if (content.length() <= 4) {\n                return null;\n            }\n        } else {\n            if (_cmds == null) {\n                _cmds = s_gson.fromJson(_content, this instanceof Response ? Answer[].class : Command[].class);\n            }\n            content.append(\"{ \");\n            for (Command cmd : _cmds) {\n                content.append(cmd.getClass().getSimpleName()).append(\", \");\n            }\n            content.replace(content.length() - 2, content.length(), \" }\");\n\n        }\n\n        StringBuilder buf = new StringBuilder(\"Seq \");\n\n        buf.append(_agentId).append(\"-\").append(_seq).append(\": \");\n\n        buf.append(msg);\n        buf.append(\" { \").append(getType());\n        buf.append(\", MgmtId: \").append(_mgmtId).append(\", via: \").append(_via);\n        buf.append(\", Ver: \").append(_ver.toString());\n        buf.append(\", Flags: \").append(Integer.toBinaryString(getFlags())).append(\", \");\n        buf.append(content);\n        buf.append(\" }\");\n        return buf.toString();\n    }","id":89418,"modified_method":"protected String log(String msg, boolean logContent, Level level) {\n        StringBuilder content = new StringBuilder();\n        if (logContent) {\n            if (_cmds == null) {\n                _cmds = s_gson.fromJson(_content, this instanceof Response ? Answer[].class : Command[].class);\n            }\n            try {\n                s_gogger.toJson(_cmds, content);\n            } catch (Throwable e) {\n                StringBuilder buff = new StringBuilder();\n                for (Command cmd : _cmds) {\n                    buff.append(cmd.getClass().getSimpleName()).append(\"/\");\n                }\n                s_logger.error(\"Gson serialization error \" + buff.toString(), e);\n                assert false : \"More gson errors on \" + buff.toString();\n                return \"\";\n            }\n            if (content.length() <= (1 + _cmds.length * 3)) {\n                return null;\n            }\n        } else {\n            if (_cmds == null) {\n                _cmds = s_gson.fromJson(_content, this instanceof Response ? Answer[].class : Command[].class);\n            }\n            content.append(\"{ \");\n            for (Command cmd : _cmds) {\n                content.append(cmd.getClass().getSimpleName()).append(\", \");\n            }\n            content.replace(content.length() - 2, content.length(), \" }\");\n\n        }\n\n        StringBuilder buf = new StringBuilder(\"Seq \");\n\n        buf.append(_agentId).append(\"-\").append(_seq).append(\": \");\n\n        buf.append(msg);\n        buf.append(\" { \").append(getType());\n        buf.append(\", MgmtId: \").append(_mgmtId).append(\", via: \").append(_via);\n        buf.append(\", Ver: \").append(_ver.toString());\n        buf.append(\", Flags: \").append(Integer.toBinaryString(getFlags())).append(\", \");\n        buf.append(content);\n        buf.append(\" }\");\n        return buf.toString();\n    }","commit_id":"a0ce3da1913e580d767a0942de347b8cedf7a3f4","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Factory method for Request and Response. It expects the bytes to be\n     * correctly formed so it's possible that it throws underflow exceptions\n     * but you shouldn't be concerned about that since that all bytes sent in\n     * should already be formatted correctly.\n     * \n     * @param bytes bytes to be converted.\n     * @return Request or Response depending on the data.\n     * @throws ClassNotFoundException if the Command or Answer can not be formed.\n     * @throws\n     */\n    public static Request parse(final byte[] bytes) throws ClassNotFoundException, UnsupportedVersionException {\n        final ByteBuffer buff = ByteBuffer.wrap(bytes);\n        final byte ver = buff.get();\n        final Version version = Version.get(ver);\n        if (version.ordinal() != Version.v1.ordinal()) {\n            throw new UnsupportedVersionException(\"This version is no longer supported: \" + version.toString(), UnsupportedVersionException.IncompatibleVersion);\n        }\n        final byte reserved = buff.get(); // tossed away for now.\n        final short flags = buff.getShort();\n        final boolean isRequest = (flags & FLAG_REQUEST) > 0;\n\n        final long seq = buff.getLong();\n        final int size = buff.getInt();\n        final long mgmtId = buff.getLong();\n        final long agentId = buff.getLong();\n        final long via = buff.getLong();\n\n        byte[] command = null;\n        int offset = 0;\n        if (buff.hasArray()) {\n            command = buff.array();\n            offset = buff.arrayOffset() + buff.position();\n        } else {\n            command = new byte[buff.remaining()];\n            buff.get(command);\n            offset = 0;\n        }\n\n        final String content = new String(command, offset, command.length - offset);\n\n        if (isRequest) {\n            return new Request(version, seq, agentId, mgmtId, via, flags, content);\n        } else {\n            return new Response(Version.get(ver), seq, agentId, mgmtId, via, flags, content);\n        }\n    }","id":89419,"modified_method":"/**\n     * Factory method for Request and Response. It expects the bytes to be\n     * correctly formed so it's possible that it throws underflow exceptions\n     * but you shouldn't be concerned about that since that all bytes sent in\n     * should already be formatted correctly.\n     * \n     * @param bytes bytes to be converted.\n     * @return Request or Response depending on the data.\n     * @throws ClassNotFoundException if the Command or Answer can not be formed.\n     * @throws\n     */\n    public static Request parse(final byte[] bytes) throws ClassNotFoundException, UnsupportedVersionException {\n        final ByteBuffer buff = ByteBuffer.wrap(bytes);\n        final byte ver = buff.get();\n        final Version version = Version.get(ver);\n        if (version.ordinal() != Version.v1.ordinal() && version.ordinal() != Version.v3.ordinal()) {\n            throw new UnsupportedVersionException(\"This version is no longer supported: \" + version.toString(), UnsupportedVersionException.IncompatibleVersion);\n        }\n        final byte reserved = buff.get(); // tossed away for now.\n        final short flags = buff.getShort();\n        final boolean isRequest = (flags & FLAG_REQUEST) > 0;\n\n        final long seq = buff.getLong();\n        final int size = buff.getInt();\n        final long mgmtId = buff.getLong();\n        final long agentId = buff.getLong();\n        long via;\n        if (version.ordinal() == Version.v1.ordinal()) {\n            via = buff.getLong();\n        } else {\n            via = agentId;\n        }\n\n        byte[] command = null;\n        int offset = 0;\n        if (buff.hasArray()) {\n            command = buff.array();\n            offset = buff.arrayOffset() + buff.position();\n        } else {\n            command = new byte[buff.remaining()];\n            buff.get(command);\n            offset = 0;\n        }\n\n        final String content = new String(command, offset, command.length - offset);\n\n        if (isRequest) {\n            return new Request(version, seq, agentId, mgmtId, via, flags, content);\n        } else {\n            return new Response(Version.get(ver), seq, agentId, mgmtId, via, flags, content);\n        }\n    }","commit_id":"a0ce3da1913e580d767a0942de347b8cedf7a3f4","url":"https://github.com/apache/cloudstack"},{"original_method":"public void testSerDeser() {\n        s_logger.info(\"Testing serializing and deserializing works as expected\");\n        \n        s_logger.info(\"UpdateHostPasswordCommand should have two parameters that doesn't show in logging\");\n        UpdateHostPasswordCommand cmd1 = new UpdateHostPasswordCommand(\"abc\", \"def\");\n        s_logger.info(\"SecStorageFirewallCfgCommand has a context map that shouldn't show up in debug level\");\n        SecStorageFirewallCfgCommand cmd2 = new SecStorageFirewallCfgCommand();\n        s_logger.info(\"GetHostStatsCommand should not show up at all in debug level\");\n        GetHostStatsCommand cmd3 = new GetHostStatsCommand(\"hostguid\", \"hostname\", 101);\n        cmd2.addPortConfig(\"abc\", \"24\", true, \"eth0\");\n        cmd2.addPortConfig(\"127.0.0.1\", \"44\", false, \"eth1\");\n        Request sreq = new Request(2, 3, new Command[] { cmd1, cmd2, cmd3 }, true, true);\n        sreq.setSequence(1);\n\n        Logger logger = Logger.getLogger(GsonHelper.class);\n        Level level = logger.getLevel();\n\n        logger.setLevel(Level.DEBUG);\n        String log = sreq.log(\"Debug\", true, Level.DEBUG);\n        assert (log.contains(UpdateHostPasswordCommand.class.getSimpleName()));\n        assert (log.contains(SecStorageFirewallCfgCommand.class.getSimpleName()));\n        assert (!log.contains(GetHostStatsCommand.class.getSimpleName()));\n        assert (!log.contains(\"username\"));\n        assert (!log.contains(\"password\"));\n\n        logger.setLevel(Level.TRACE);\n        log = sreq.log(\"Trace\", true, Level.TRACE);\n        assert (log.contains(UpdateHostPasswordCommand.class.getSimpleName()));\n        assert (log.contains(SecStorageFirewallCfgCommand.class.getSimpleName()));\n        assert (log.contains(GetHostStatsCommand.class.getSimpleName()));\n        assert (!log.contains(\"username\"));\n        assert (!log.contains(\"password\"));\n\n        logger.setLevel(Level.INFO);\n        sreq.log(\"Info\", true, Level.INFO);\n        assert (log.contains(UpdateHostPasswordCommand.class.getSimpleName()));\n        assert (log.contains(SecStorageFirewallCfgCommand.class.getSimpleName()));\n        assert (!log.contains(GetHostStatsCommand.class.getSimpleName()));\n        assert (!log.contains(\"username\"));\n        assert (!log.contains(\"password\"));\n\n        logger.setLevel(level);\n\n        byte[] bytes = sreq.getBytes();\n        Request creq = null;\n        try {\n            creq = Request.parse(bytes);\n        } catch (ClassNotFoundException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        } catch (UnsupportedVersionException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        }\n\n        assert creq != null : \"Couldn't get the request back\";\n\n        compareRequest(creq, sreq);\n\n        Answer ans = new Answer(cmd1, true, \"No Problem\");\n        Response cresp = new Response(creq, ans);\n\n        bytes = cresp.getBytes();\n\n        Response sresp = null;\n        try {\n            sresp = Response.parse(bytes);\n        } catch (ClassNotFoundException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        } catch (UnsupportedVersionException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        }\n\n        assert sresp != null : \"Couldn't get the response back\";\n\n        compareRequest(cresp, sresp);\n    }","id":89420,"modified_method":"public void testSerDeser() {\n        s_logger.info(\"Testing serializing and deserializing works as expected\");\n        \n        s_logger.info(\"UpdateHostPasswordCommand should have two parameters that doesn't show in logging\");\n        UpdateHostPasswordCommand cmd1 = new UpdateHostPasswordCommand(\"abc\", \"def\");\n        s_logger.info(\"SecStorageFirewallCfgCommand has a context map that shouldn't show up in debug level\");\n        SecStorageFirewallCfgCommand cmd2 = new SecStorageFirewallCfgCommand();\n        s_logger.info(\"GetHostStatsCommand should not show up at all in debug level\");\n        GetHostStatsCommand cmd3 = new GetHostStatsCommand(\"hostguid\", \"hostname\", 101);\n        cmd2.addPortConfig(\"abc\", \"24\", true, \"eth0\");\n        cmd2.addPortConfig(\"127.0.0.1\", \"44\", false, \"eth1\");\n        Request sreq = new Request(2, 3, new Command[] { cmd1, cmd2, cmd3 }, true, true);\n        sreq.setSequence(1);\n\n        Logger logger = Logger.getLogger(GsonHelper.class);\n        Level level = logger.getLevel();\n\n        logger.setLevel(Level.DEBUG);\n        String log = sreq.log(\"Debug\", true, Level.DEBUG);\n        assert (log.contains(UpdateHostPasswordCommand.class.getSimpleName()));\n        assert (log.contains(SecStorageFirewallCfgCommand.class.getSimpleName()));\n        assert (!log.contains(GetHostStatsCommand.class.getSimpleName()));\n        assert (!log.contains(\"username\"));\n        assert (!log.contains(\"password\"));\n\n        logger.setLevel(Level.TRACE);\n        log = sreq.log(\"Trace\", true, Level.TRACE);\n        assert (log.contains(UpdateHostPasswordCommand.class.getSimpleName()));\n        assert (log.contains(SecStorageFirewallCfgCommand.class.getSimpleName()));\n        assert (log.contains(GetHostStatsCommand.class.getSimpleName()));\n        assert (!log.contains(\"username\"));\n        assert (!log.contains(\"password\"));\n\n        logger.setLevel(Level.INFO);\n        log = sreq.log(\"Info\", true, Level.INFO);\n        assert (log == null);\n\n        logger.setLevel(level);\n\n        byte[] bytes = sreq.getBytes();\n        \n        assert Request.getSequence(bytes) == 1;\n        assert Request.getManagementServerId(bytes) == 3;\n        assert Request.getAgentId(bytes) == 2;\n        assert Request.getViaAgentId(bytes) == 2;\n        Request creq = null;\n        try {\n            creq = Request.parse(bytes);\n        } catch (ClassNotFoundException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        } catch (UnsupportedVersionException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        }\n\n        assert creq != null : \"Couldn't get the request back\";\n\n        compareRequest(creq, sreq);\n\n        Answer ans = new Answer(cmd1, true, \"No Problem\");\n        Response cresp = new Response(creq, ans);\n\n        bytes = cresp.getBytes();\n\n        Response sresp = null;\n        try {\n            sresp = Response.parse(bytes);\n        } catch (ClassNotFoundException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        } catch (UnsupportedVersionException e) {\n            s_logger.error(\"Unable to parse bytes: \", e);\n        }\n\n        assert sresp != null : \"Couldn't get the response back\";\n\n        compareRequest(cresp, sresp);\n    }","commit_id":"a0ce3da1913e580d767a0942de347b8cedf7a3f4","url":"https://github.com/apache/cloudstack"},{"original_method":"private StatsCollector(Map<String, String> configs) {\r\n\t\tComponentLocator locator = ComponentLocator.getLocator(ManagementServer.Name);\r\n\t\t_agentMgr = locator.getManager(AgentManager.class);\n\t\t_userVmMgr = locator.getManager(UserVmManager.class);\r\n\t\t_hostDao = locator.getDao(HostDao.class);\n\t\t_userVmDao = locator.getDao(UserVmDao.class);\r\n\t\t_volsDao = locator.getDao(VolumeDao.class);\r\n\t\t_capacityDao = locator.getDao(CapacityDao.class);\r\n\t\t_storagePoolDao = locator.getDao(StoragePoolDao.class);\r\n\t\t_storageManager = locator.getManager(StorageManager.class);\n        _storagePoolHostDao  = locator.getDao(StoragePoolHostDao.class);\r\n\r\n\t\t_executor = Executors.newScheduledThreadPool(3, new NamedThreadFactory(\"StatsCollector\"));\r\n\r\n\t\t hostStatsInterval = NumbersUtil.parseLong(configs.get(\"host.stats.interval\"), 60000L);\n\t\t hostAndVmStatsInterval = NumbersUtil.parseLong(configs.get(\"vm.stats.interval\"), 60000L);\r\n\t\t storageStatsInterval = NumbersUtil.parseLong(configs.get(\"storage.stats.interval\"), 60000L);\r\n\t\t volumeStatsInterval = NumbersUtil.parseLong(configs.get(\"volume.stats.interval\"), -1L);\r\n\r\n\t\t_executor.scheduleWithFixedDelay(new HostCollector(), 15000L, hostStatsInterval, TimeUnit.MILLISECONDS);\n\t\t_executor.scheduleWithFixedDelay(new VmStatsCollector(), 15000L, hostAndVmStatsInterval, TimeUnit.MILLISECONDS);\r\n\t\t_executor.scheduleWithFixedDelay(new StorageCollector(), 15000L, storageStatsInterval, TimeUnit.MILLISECONDS);\r\n\t\t\r\n\t\t// -1 means we don't even start this thread to pick up any data.\r\n\t\tif (volumeStatsInterval > 0) {\r\n\t\t\t_executor.scheduleWithFixedDelay(new VolumeCollector(), 15000L, volumeStatsInterval, TimeUnit.MILLISECONDS);\r\n\t\t} else {\r\n\t\t\ts_logger.info(\"Disabling volume stats collector\");\r\n\t\t}\r\n\t}","id":89421,"modified_method":"private StatsCollector(Map<String, String> configs) {\r\n\t\tComponentLocator locator = ComponentLocator.getLocator(ManagementServer.Name);\r\n\t\t_agentMgr = locator.getManager(AgentManager.class);\n\t\t_userVmMgr = locator.getManager(UserVmManager.class);\r\n\t\t_hostDao = locator.getDao(HostDao.class);\n\t\t_userVmDao = locator.getDao(UserVmDao.class);\r\n\t\t_volsDao = locator.getDao(VolumeDao.class);\r\n\t\t_capacityDao = locator.getDao(CapacityDao.class);\r\n\t\t_storagePoolDao = locator.getDao(StoragePoolDao.class);\r\n\t\t_storageManager = locator.getManager(StorageManager.class);\n        _storagePoolHostDao  = locator.getDao(StoragePoolHostDao.class);\r\n\r\n\t\t_executor = Executors.newScheduledThreadPool(3, new NamedThreadFactory(\"StatsCollector\"));\r\n\r\n\t\t hostStatsInterval = NumbersUtil.parseLong(configs.get(\"host.stats.interval\"), 60000L);\n\t\t hostAndVmStatsInterval = NumbersUtil.parseLong(configs.get(\"vm.stats.interval\"), 60000L);\r\n\t\t storageStatsInterval = NumbersUtil.parseLong(configs.get(\"storage.stats.interval\"), 60000L);\r\n\t\t volumeStatsInterval = NumbersUtil.parseLong(configs.get(\"volume.stats.interval\"), -1L);\r\n\n\t\t if (hostStatsInterval > 0) {\r\n\t\t     _executor.scheduleWithFixedDelay(new HostCollector(), 15000L, hostStatsInterval, TimeUnit.MILLISECONDS);\n\t\t }\n\t\t \n\t\t if (hostAndVmStatsInterval > 0) {\n\t\t     _executor.scheduleWithFixedDelay(new VmStatsCollector(), 15000L, hostAndVmStatsInterval, TimeUnit.MILLISECONDS);\n\t\t }\n\t\t \n\t\t if (storageStatsInterval > 0) {\r\n\t\t     _executor.scheduleWithFixedDelay(new StorageCollector(), 15000L, storageStatsInterval, TimeUnit.MILLISECONDS);\n\t\t }\r\n\t\t\r\n\t\t// -1 means we don't even start this thread to pick up any data.\r\n\t\tif (volumeStatsInterval > 0) {\r\n\t\t\t_executor.scheduleWithFixedDelay(new VolumeCollector(), 15000L, volumeStatsInterval, TimeUnit.MILLISECONDS);\r\n\t\t} else {\r\n\t\t\ts_logger.info(\"Disabling volume stats collector\");\r\n\t\t}\r\n\t}","commit_id":"a0ce3da1913e580d767a0942de347b8cedf7a3f4","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Returns a client for the first working pod for the given replication controller\n     */\n    public J4pClient clientForReplicationController(ReplicationController replicationController) {\n        List<Pod> pods = KubernetesHelper.getPodsForReplicationController(replicationController, kubernetes.pods().list().getItems());\n        return clientForPod(pods);\n    }","id":89422,"modified_method":"/**\n     * Returns a client for the first working pod for the given replication controller\n     */\n    public J4pClient clientForReplicationController(ReplicationController replicationController) {\n        List<Pod> pods = KubernetesHelper.getPodsForReplicationController(replicationController, kubernetes.pods().inNamespace(replicationController.getMetadata().getNamespace()).list().getItems());\n        return clientForPod(pods);\n    }","commit_id":"29c5eb5c595513714de0efc081b31aaa26f623df","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Returns all the clients for the first working pod for the given replication controller\n     */\n    public List<J4pClient> clientsForReplicationController(ReplicationController replicationController) {\n        List<Pod> pods = KubernetesHelper.getPodsForReplicationController(replicationController, kubernetes.pods().list().getItems());\n        return clientsForPod(pods);\n    }","id":89423,"modified_method":"/**\n     * Returns all the clients for the first working pod for the given replication controller\n     */\n    public List<J4pClient> clientsForReplicationController(ReplicationController replicationController) {\n        List<Pod> pods = KubernetesHelper.getPodsForReplicationController(replicationController, kubernetes.pods().inNamespace(replicationController.getMetadata().getNamespace()).list().getItems());\n        return clientsForPod(pods);\n    }","commit_id":"29c5eb5c595513714de0efc081b31aaa26f623df","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Returns a client for the first working pod for the given service\n     */\n    public J4pClient clientForService(Service service) {\n        List<Pod> pods = KubernetesHelper.getPodsForService(service, kubernetes.pods().list().getItems());\n        return clientForPod(pods);\n    }","id":89424,"modified_method":"/**\n     * Returns a client for the first working pod for the given service\n     */\n    public J4pClient clientForService(Service service) {\n        List<Pod> pods = KubernetesHelper.getPodsForService(service, kubernetes.pods().inNamespace(service.getMetadata().getNamespace()).list().getItems());\n        return clientForPod(pods);\n    }","commit_id":"29c5eb5c595513714de0efc081b31aaa26f623df","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Returns all the clients the first working pod for the given service\n     */\n    public List<J4pClient> clientsForService(Service service) {\n        List<Pod> pods = KubernetesHelper.getPodsForService(service, kubernetes.pods().list().getItems());\n        return clientsForPod(pods);\n    }","id":89425,"modified_method":"/**\n     * Returns all the clients the first working pod for the given service\n     */\n    public List<J4pClient> clientsForService(Service service) {\n        List<Pod> pods = KubernetesHelper.getPodsForService(service, kubernetes.pods().inNamespace(service.getMetadata().getNamespace()).list().getItems());\n        return clientsForPod(pods);\n    }","commit_id":"29c5eb5c595513714de0efc081b31aaa26f623df","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void recycle() {\n        getAdapter().checkRecycled(request, response);\n\n        asyncStateMachine.recycle();\n\n        // Recycle Request object\n        first = true;\n        endOfStream = false;\n        waitingForBodyMessage = false;\n        empty = true;\n        replay = false;\n        finished = false;\n        request.recycle();\n        response.recycle();\n        certificates.recycle();\n        swallowResponse = false;\n        bytesWritten = 0;\n        resetErrorState();\n    }","id":89426,"modified_method":"@Override\n    public void recycle() {\n        getAdapter().checkRecycled(request, response);\n        asyncStateMachine.recycle();\n        request.recycle();\n        response.recycle();\n        first = true;\n        endOfStream = false;\n        waitingForBodyMessage = false;\n        empty = true;\n        replay = false;\n        finished = false;\n        certificates.recycle();\n        swallowResponse = false;\n        bytesWritten = 0;\n        resetErrorState();\n    }","commit_id":"75e0cf81192285e4b1732bdd7beb191d19cc8ec2","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public final void recycle() {\n        getAdapter().checkRecycled(request, response);\n\n        if (inputBuffer != null) {\n            inputBuffer.recycle();\n        }\n        if (outputBuffer != null) {\n            outputBuffer.recycle();\n        }\n        if (asyncStateMachine != null) {\n            asyncStateMachine.recycle();\n        }\n        httpUpgradeHandler = null;\n        resetErrorState();\n        socketWrapper = null;\n        sendfileData = null;\n    }","id":89427,"modified_method":"@Override\n    public final void recycle() {\n        getAdapter().checkRecycled(request, response);\n        asyncStateMachine.recycle();\n        inputBuffer.recycle();\n        outputBuffer.recycle();\n        httpUpgradeHandler = null;\n        socketWrapper = null;\n        sendfileData = null;\n        resetErrorState();\n    }","commit_id":"75e0cf81192285e4b1732bdd7beb191d19cc8ec2","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param packageDescr\n     */\n    private void processTypeDeclarations(final PackageDescr packageDescr) {\n        PackageRegistry defaultRegistry = this.pkgRegistryMap.get( packageDescr.getNamespace() );\n\n        PackageRegistry pkgRegistry = null;\n        for ( TypeDeclarationDescr typeDescr : packageDescr.getTypeDeclarations() ) {\n\n            int dotPos = typeDescr.getTypeName().lastIndexOf( '.' );\n            if ( dotPos >= 0 ) {\n                // see if this overwrites an existing bean, which also could be a nested class.\n                Class cls = null;\n                try {\n                    cls = Class.forName( typeDescr.getTypeName(),\n                                         true,\n                                         this.rootClassLoader );\n                } catch ( ClassNotFoundException e ) {\n                }\n\n                String qualifiedClass = typeDescr.getTypeName();\n                int lastIndex;\n                while ( cls == null && (lastIndex = qualifiedClass.lastIndexOf( '.' )) != -1 ) {\n                    try {\n\n                        qualifiedClass = qualifiedClass.substring( 0,\n                                                                   lastIndex ) + \"$\" + qualifiedClass.substring( lastIndex + 1 );\n                        cls = Class.forName( qualifiedClass,\n                                             true,\n                                             this.rootClassLoader );\n                    } catch ( final ClassNotFoundException e ) {\n                        cls = null;\n                    }\n                }\n\n                if ( cls != null ) {\n                    String str = ClassUtils.getPackage( cls );\n                    typeDescr.setNamespace( str );\n                    dotPos = cls.getName().lastIndexOf( '.' ); // reget dotPos, incase there were nested classes\n                    typeDescr.setTypeName( cls.getName().substring( dotPos + 1 ) );\n                } else {\n                    typeDescr.setNamespace( typeDescr.getTypeName().substring( 0,\n                                                                               dotPos ) );\n                    typeDescr.setTypeName( typeDescr.getTypeName().substring( dotPos + 1 ) );\n                }\n            }\n\n            if ( isEmpty( typeDescr.getNamespace() ) ) {\n                // check imports\n                try {\n                    Class< ? > cls = defaultRegistry.getTypeResolver().resolveType( typeDescr.getTypeName() );\n                    typeDescr.setNamespace( ClassUtils.getPackage( cls ) );\n                    String name = cls.getName();\n                    dotPos = name.lastIndexOf( '.' );\n                    typeDescr.setTypeName( name.substring( dotPos + 1 ) );\n                } catch ( ClassNotFoundException e ) {\n                    // swallow, as this isn't a mistake, it just means the type declaration is intended for the default namespace\n                    typeDescr.setNamespace( packageDescr.getNamespace() ); // set the default namespace\n                }\n            }\n\n            if ( isEmpty( typeDescr.getNamespace() ) ) {\n                for ( ImportDescr id : packageDescr.getImports() ) {\n                    String imp = id.getTarget();\n                    if ( imp.endsWith( typeDescr.getTypeName() ) ) {\n                        typeDescr.setNamespace( imp.substring( 0,\n                                                               imp.lastIndexOf( '.' ) ) );\n                    }\n                }\n            }\n\n            //identify superclass type and namespace\n            fillSuperType( typeDescr,\n                           packageDescr );\n\n            if ( !typeDescr.getNamespace().equals( packageDescr.getNamespace() ) ) {\n                // If the type declaration is for a different namespace, process that separately.\n                PackageDescr altDescr = new PackageDescr( typeDescr.getNamespace() );\n                altDescr.addTypeDeclaration( typeDescr );\n                for ( ImportDescr imp : packageDescr.getImports() ) {\n                    altDescr.addImport( imp );\n                }\n                if ( getPackageRegistry().containsKey( altDescr.getNamespace() ) ) {\n                    mergePackage( altDescr );\n                } else {\n                    newPackage( altDescr );\n                }\n            }\n\n        }\n\n        // sort declarations : superclasses must be generated first\n        Collection<TypeDeclarationDescr> sortedTypeDescriptors = sortByHierarchy( packageDescr.getTypeDeclarations() );\n\n        for ( TypeDeclarationDescr typeDescr : sortedTypeDescriptors ) {\n\n            if ( !typeDescr.getNamespace().equals( packageDescr.getNamespace() ) ) {\n                continue;\n            }\n\n            pkgRegistry = this.pkgRegistryMap.get( packageDescr.getNamespace() );\n\n            //descriptor needs fields inherited from superclass\n            if ( typeDescr.getSuperTypeName() != null ) {\n                //descriptor needs fields inherited from superclass\n                if ( mergeInheritedFields( typeDescr ) ) {\n                    //descriptor also needs metadata from superclass\n                    Iterator<TypeDeclarationDescr> iter = sortedTypeDescriptors.iterator();\n                    while ( iter.hasNext() ) {\n                        // sortedTypeDescriptors are sorted by inheritance order, so we'll always find the superClass (if any) before the subclass\n                        TypeDeclarationDescr descr = iter.next();\n                        if ( (typeDescr.getSuperTypeName().equals( descr.getTypeName() ) && typeDescr.getSuperTypeNamespace().equals( descr.getNamespace() )) ) {\n                            typeDescr.getAnnotations().putAll( descr.getAnnotations() );\n                            break;\n                        } else if ( (typeDescr.getTypeName().equals( descr.getTypeName() ) && typeDescr.getNamespace().equals( descr.getNamespace() )) ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Go on with the build\n            TypeDeclaration type = new TypeDeclaration( typeDescr.getTypeName() );\n            if ( resource != null ) {\n                type.setResource( this.resource );\n            }\n\n            // is it a regular fact or an event?\n            AnnotationDescr annotationDescr = typeDescr.getAnnotation( TypeDeclaration.Role.ID );\n            String role = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( role != null ) {\n                type.setRole( TypeDeclaration.Role.parseRole( role ) );\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_TYPESAFE );\n            String typesafe = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( typesafe != null ) {\n                type.setTypesafe( Boolean.parseBoolean( typesafe ) );\n            }\n\n            // is it a POJO or a template?\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_TEMPLATE );\n            String templateName = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( templateName != null ) {\n                type.setFormat( TypeDeclaration.Format.TEMPLATE );\n                FactTemplate template = pkgRegistry.getPackage().getFactTemplate( templateName );\n                if ( template != null ) {\n                    type.setTypeTemplate( template );\n                } else {\n                    this.results.add( new TypeDeclarationError( \"Template not found for TypeDeclaration '\" + template + \"' for type '\" + type.getTypeName() + \"'\",\n                                                                typeDescr.getLine() ) );\n                    continue;\n                }\n            } else {\n                annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_CLASS );\n                String className = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n\n                if ( StringUtils.isEmpty( className ) ) {\n                    className = type.getTypeName();\n                }\n                type.setFormat( TypeDeclaration.Format.POJO );\n                Class clazz;\n                try {\n\n                    // the type declaration is generated in any case (to be used by subclasses, if any)\n                    // the actual class will be generated only if needed\n                    generateDeclaredBean( typeDescr,\n                                          type,\n                                          pkgRegistry );\n\n                    clazz = pkgRegistry.getTypeResolver().resolveType( className );\n                    type.setTypeClass( clazz );\n\n                    if ( type.getTypeClassDef() != null ) {\n                        try {\n                            buildFieldAccessors( type,\n                                                 pkgRegistry );\n                        } catch ( Exception e ) {\n                            this.results.add( new TypeDeclarationError( \"Error creating field accessors for TypeDeclaration '\" + className + \"' for type '\" + type.getTypeName() + \"'\",\n                                                                        typeDescr.getLine() ) );\n                            continue;\n                        }\n                    }\n                } catch ( final ClassNotFoundException e ) {\n                    this.results.add( new TypeDeclarationError( \"Class '\" + className +\n                                                                        \"' not found for type declaration of '\" + type.getTypeName() + \"'\",\n                                                                typeDescr.getLine() ) );\n                    continue;\n                }\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_TIMESTAMP );\n            String timestamp = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( timestamp != null ) {\n                type.setTimestampAttribute( timestamp );\n                ClassDefinition cd = type.getTypeClassDef();\n                Package pkg = pkgRegistry.getPackage();\n                InternalReadAccessor reader = pkg.getClassFieldAccessorStore().getMVELReader( ClassUtils.getPackage( type.getTypeClass() ),\n                                                                                              type.getTypeClass().getName(),\n                                                                                              timestamp,\n                                                                                              type.isTypesafe() );\n                MVELDialectRuntimeData data = (MVELDialectRuntimeData) pkg.getDialectRuntimeRegistry().getDialectData( \"mvel\" );\n                data.addCompileable( (MVELCompileable) reader );\n                ((MVELCompileable) reader).compile( data );\n                type.setTimestampExtractor( reader );\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_DURATION );\n            String duration = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( duration != null ) {\n                type.setDurationAttribute( duration );\n                ClassDefinition cd = type.getTypeClassDef();\n                Package pkg = pkgRegistry.getPackage();\n                InternalReadAccessor reader = pkg.getClassFieldAccessorStore().getMVELReader( ClassUtils.getPackage( type.getTypeClass() ),\n                                                                                              type.getTypeClass().getName(),\n                                                                                              duration,\n                                                                                              type.isTypesafe() );\n                MVELDialectRuntimeData data = (MVELDialectRuntimeData) pkg.getDialectRuntimeRegistry().getDialectData( \"mvel\" );\n                data.addCompileable( (MVELCompileable) reader );\n                ((MVELCompileable) reader).compile( data );\n                type.setDurationExtractor( reader );\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_EXPIRE );\n            String expiration = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( expiration != null ) {\n                if ( timeParser == null ) {\n                    timeParser = new TimeIntervalParser();\n                }\n                type.setExpirationOffset( timeParser.parse( expiration )[0].longValue() );\n            }\n\n            boolean dynamic = typeDescr.getAnnotationNames().contains( TypeDeclaration.ATTR_PROP_CHANGE_SUPPORT );\n            type.setDynamic( dynamic );\n\n            pkgRegistry.getPackage().addTypeDeclaration( type );\n        }\n    }","id":89428,"modified_method":"/**\n     * @param packageDescr\n     */\n    private void processTypeDeclarations(final PackageDescr packageDescr) {\n        PackageRegistry defaultRegistry = this.pkgRegistryMap.get( packageDescr.getNamespace() );\n\n        PackageRegistry pkgRegistry = null;\n        for ( TypeDeclarationDescr typeDescr : packageDescr.getTypeDeclarations() ) {\n\n\n            if ( isEmpty( typeDescr.getNamespace() ) ) {\n                for ( ImportDescr id : packageDescr.getImports() ) {\n                    String imp = id.getTarget();\n                    if ( imp.endsWith( typeDescr.getTypeName() ) ) {\n                        typeDescr.setNamespace( imp.substring( 0,\n                                                               imp.lastIndexOf( '.' ) ) );\n                    }\n                }\n            }\n            String qName = typeDescr.getTypeName();\n            if ( typeDescr.getNamespace() != null ) {\n                qName = typeDescr.getNamespace() + \".\" + qName;\n            }\n\n            int dotPos = qName.lastIndexOf( '.' );\n            if ( dotPos >= 0 ) {\n                // see if this overwrites an existing bean, which also could be a nested class.\n                Class cls = null;\n                try {\n                    cls = Class.forName( typeDescr.getTypeName(),\n                                         true,\n                                         this.rootClassLoader );\n                } catch ( ClassNotFoundException e ) {\n                }\n\n                String qualifiedClass = qName;\n                int lastIndex;\n                while ( cls == null && (lastIndex = qualifiedClass.lastIndexOf( '.' )) != -1 ) {\n                    try {\n\n                        qualifiedClass = qualifiedClass.substring( 0,\n                                                                   lastIndex ) + \"$\" + qualifiedClass.substring( lastIndex + 1 );\n                        cls = Class.forName( qualifiedClass,\n                                             true,\n                                             this.rootClassLoader );\n                    } catch ( final ClassNotFoundException e ) {\n                        cls = null;\n                    }\n                }\n\n                if ( cls != null ) {\n                    String str = ClassUtils.getPackage( cls );\n                    typeDescr.setNamespace( str );\n                    dotPos = cls.getName().lastIndexOf( '.' ); // reget dotPos, incase there were nested classes\n                    typeDescr.setTypeName( cls.getName().substring( dotPos + 1 ) );\n                } else {\n                    typeDescr.setNamespace( qName.substring( 0,\n                                                                               dotPos ) );\n                    typeDescr.setTypeName( qName.substring( dotPos + 1 ) );\n                }\n            }\n\n\n            if ( isEmpty( typeDescr.getNamespace() ) ) {\n                typeDescr.setNamespace( packageDescr.getNamespace() ); // set the default namespace\n            }\n\n            //identify superclass type and namespace\n            fillSuperType( typeDescr,\n                           packageDescr );\n\n            if ( !typeDescr.getNamespace().equals( packageDescr.getNamespace() ) ) {\n                // If the type declaration is for a different namespace, process that separately.\n                PackageDescr altDescr = new PackageDescr( typeDescr.getNamespace() );\n                altDescr.addTypeDeclaration( typeDescr );\n                for ( ImportDescr imp : packageDescr.getImports() ) {\n                    altDescr.addImport( imp );\n                }\n                if ( getPackageRegistry().containsKey( altDescr.getNamespace() ) ) {\n                    mergePackage( altDescr );\n                } else {\n                    newPackage( altDescr );\n                }\n            }\n\n        }\n\n        // sort declarations : superclasses must be generated first\n        Collection<TypeDeclarationDescr> sortedTypeDescriptors = sortByHierarchy( packageDescr.getTypeDeclarations() );\n\n        for ( TypeDeclarationDescr typeDescr : sortedTypeDescriptors ) {\n\n            if ( !typeDescr.getNamespace().equals( packageDescr.getNamespace() ) ) {\n                continue;\n            }\n\n            pkgRegistry = this.pkgRegistryMap.get( packageDescr.getNamespace() );\n\n            //descriptor needs fields inherited from superclass\n            if ( typeDescr.getSuperTypeName() != null ) {\n                //descriptor needs fields inherited from superclass\n                if ( mergeInheritedFields( typeDescr ) ) {\n                    //descriptor also needs metadata from superclass\n                    Iterator<TypeDeclarationDescr> iter = sortedTypeDescriptors.iterator();\n                    while ( iter.hasNext() ) {\n                        // sortedTypeDescriptors are sorted by inheritance order, so we'll always find the superClass (if any) before the subclass\n                        TypeDeclarationDescr descr = iter.next();\n                        if ( (typeDescr.getSuperTypeName().equals( descr.getTypeName() ) && typeDescr.getSuperTypeNamespace().equals( descr.getNamespace() )) ) {\n                            typeDescr.getAnnotations().putAll( descr.getAnnotations() );\n                            break;\n                        } else if ( (typeDescr.getTypeName().equals( descr.getTypeName() ) && typeDescr.getNamespace().equals( descr.getNamespace() )) ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Go on with the build\n            TypeDeclaration type = new TypeDeclaration( typeDescr.getTypeName() );\n            if ( resource != null ) {\n                type.setResource( this.resource );\n            }\n\n            // is it a regular fact or an event?\n            AnnotationDescr annotationDescr = typeDescr.getAnnotation( TypeDeclaration.Role.ID );\n            String role = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( role != null ) {\n                type.setRole( TypeDeclaration.Role.parseRole( role ) );\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_TYPESAFE );\n            String typesafe = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( typesafe != null ) {\n                type.setTypesafe( Boolean.parseBoolean( typesafe ) );\n            }\n\n            // is it a POJO or a template?\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_TEMPLATE );\n            String templateName = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( templateName != null ) {\n                type.setFormat( TypeDeclaration.Format.TEMPLATE );\n                FactTemplate template = pkgRegistry.getPackage().getFactTemplate( templateName );\n                if ( template != null ) {\n                    type.setTypeTemplate( template );\n                } else {\n                    this.results.add( new TypeDeclarationError( \"Template not found for TypeDeclaration '\" + template + \"' for type '\" + type.getTypeName() + \"'\",\n                                                                typeDescr.getLine() ) );\n                    continue;\n                }\n            } else {\n                annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_CLASS );\n                String className = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n\n                if ( StringUtils.isEmpty( className ) ) {\n                    className = type.getTypeName();\n                }\n                type.setFormat( TypeDeclaration.Format.POJO );\n                Class clazz;\n                try {\n\n                    // the type declaration is generated in any case (to be used by subclasses, if any)\n                    // the actual class will be generated only if needed\n                    generateDeclaredBean( typeDescr,\n                                          type,\n                                          pkgRegistry );\n\n                    clazz = pkgRegistry.getTypeResolver().resolveType( className );\n                    type.setTypeClass( clazz );\n\n                    if ( type.getTypeClassDef() != null ) {\n                        try {\n                            buildFieldAccessors( type,\n                                                 pkgRegistry );\n                        } catch ( Exception e ) {\n                            this.results.add( new TypeDeclarationError( \"Error creating field accessors for TypeDeclaration '\" + className + \"' for type '\" + type.getTypeName() + \"'\",\n                                                                        typeDescr.getLine() ) );\n                            continue;\n                        }\n                    }\n                } catch ( final ClassNotFoundException e ) {\n                    this.results.add( new TypeDeclarationError( \"Class '\" + className +\n                                                                        \"' not found for type declaration of '\" + type.getTypeName() + \"'\",\n                                                                typeDescr.getLine() ) );\n                    continue;\n                }\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_TIMESTAMP );\n            String timestamp = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( timestamp != null ) {\n                type.setTimestampAttribute( timestamp );\n                ClassDefinition cd = type.getTypeClassDef();\n                Package pkg = pkgRegistry.getPackage();\n                InternalReadAccessor reader = pkg.getClassFieldAccessorStore().getMVELReader( ClassUtils.getPackage( type.getTypeClass() ),\n                                                                                              type.getTypeClass().getName(),\n                                                                                              timestamp,\n                                                                                              type.isTypesafe() );\n                MVELDialectRuntimeData data = (MVELDialectRuntimeData) pkg.getDialectRuntimeRegistry().getDialectData( \"mvel\" );\n                data.addCompileable( (MVELCompileable) reader );\n                ((MVELCompileable) reader).compile( data );\n                type.setTimestampExtractor( reader );\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_DURATION );\n            String duration = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( duration != null ) {\n                type.setDurationAttribute( duration );\n                ClassDefinition cd = type.getTypeClassDef();\n                Package pkg = pkgRegistry.getPackage();\n                InternalReadAccessor reader = pkg.getClassFieldAccessorStore().getMVELReader( ClassUtils.getPackage( type.getTypeClass() ),\n                                                                                              type.getTypeClass().getName(),\n                                                                                              duration,\n                                                                                              type.isTypesafe() );\n                MVELDialectRuntimeData data = (MVELDialectRuntimeData) pkg.getDialectRuntimeRegistry().getDialectData( \"mvel\" );\n                data.addCompileable( (MVELCompileable) reader );\n                ((MVELCompileable) reader).compile( data );\n                type.setDurationExtractor( reader );\n            }\n\n            annotationDescr = typeDescr.getAnnotation( TypeDeclaration.ATTR_EXPIRE );\n            String expiration = (annotationDescr != null) ? annotationDescr.getSingleValue() : null;\n            if ( expiration != null ) {\n                if ( timeParser == null ) {\n                    timeParser = new TimeIntervalParser();\n                }\n                type.setExpirationOffset( timeParser.parse( expiration )[0].longValue() );\n            }\n\n            boolean dynamic = typeDescr.getAnnotationNames().contains( TypeDeclaration.ATTR_PROP_CHANGE_SUPPORT );\n            type.setDynamic( dynamic );\n\n            pkgRegistry.getPackage().addTypeDeclaration( type );\n        }\n    }","commit_id":"7d6c8991403107e6cf9d967466ead87ef58f3fbf","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Checks whether a declaration is novel, or is a retagging of an external\n     * one\n     * \n     * @param typeDescr\n     * @return\n     */\n    private boolean isNovelClass(TypeDeclarationDescr typeDescr) {\n        try {\n            PackageRegistry reg = this.pkgRegistryMap.get( typeDescr.getNamespace() );\n            if ( reg != null ) {\n                Class< ? > resolvedType = reg.getTypeResolver().resolveType( typeDescr.getTypeName() );\n                if ( resolvedType != null && typeDescr.getFields().size() > 1 ) {\n                    this.results.add( new TypeDeclarationError( \"Duplicate type definition. A class with the name '\" + resolvedType.getName() + \"' was found in the classpath while trying to \" +\n                                                                        \"redefine the fields in the declare statement. Fields can only be defined for non-existing classes.\",\n                                                                typeDescr.getLine() ) );\n                }\n                return false;\n            } else {\n                return false;\n            }\n        } catch ( ClassNotFoundException cnfe ) {\n            return true;\n        }\n    }","id":89429,"modified_method":"/**\n     * Checks whether a declaration is novel, or is a retagging of an external\n     * one\n     * \n     * @param typeDescr\n     * @return\n     */\n    private boolean isNovelClass(TypeDeclarationDescr typeDescr) {\n        try {\n            PackageRegistry reg = this.pkgRegistryMap.get( typeDescr.getNamespace() );\n            if ( reg != null ) {\n                String availableName = typeDescr.getNamespace() != null\n                                       ? typeDescr.getNamespace() + \".\" + typeDescr.getTypeName()\n                                       : typeDescr.getTypeName();\n                Class< ? > resolvedType = reg.getTypeResolver().resolveType( availableName );\n                if ( resolvedType != null && typeDescr.getFields().size() > 1 ) {\n                    this.results.add( new TypeDeclarationError( \"Duplicate type definition. A class with the name '\" + resolvedType.getName() + \"' was found in the classpath while trying to \" +\n                                                                        \"redefine the fields in the declare statement. Fields can only be defined for non-existing classes.\",\n                                                                typeDescr.getLine() ) );\n                }\n                return false;\n            } else {\n                return false;\n            }\n        } catch ( ClassNotFoundException cnfe ) {\n            return true;\n        }\n    }","commit_id":"7d6c8991403107e6cf9d967466ead87ef58f3fbf","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Generates a JSON-Map for all available content types.\n     * \n     * @param types the gallery-types\n     * @return the content-types\n     * @throws CmsLoaderException if something goes wrong\n     * @throws JSONException if something goes wrong\n     */\n    private JSONArray buildJSONForTypes(List<I_CmsResourceType> types) throws JSONException {\n\n        JSONArray result = new JSONArray();\n        if (types == null) {\n            return result;\n        }\n        Iterator<I_CmsResourceType> it = types.iterator();\n        while (it.hasNext()) {\n            I_CmsResourceType type = it.next();\n            JSONObject jType = new JSONObject();\n            jType.put(JsonKeys.TITLE.getName(), type.getTypeName());\n            jType.put(JsonKeys.TYPEID.getName(), type.getTypeId());\n            JSONArray galleryIds = new JSONArray();\n            Iterator<I_CmsResourceType> galleryTypes = type.getGalleryTypes().iterator();\n            while (galleryTypes.hasNext()) {\n                I_CmsResourceType galleryType = galleryTypes.next();\n                galleryIds.put(galleryType.getTypeId());\n\n            }\n            jType.put(JsonKeys.GALLERYTYPEID.getName(), galleryIds);\n            result.put(jType);\n        }\n\n        return result;\n    }","id":89430,"modified_method":"/**\n     * Generates a JSON-Map for all available content types.\n     * \n     * @param types the gallery-types\n     * @return the content-types\n     * @throws CmsLoaderException if something goes wrong\n     * @throws JSONException if something goes wrong\n     */\n    private JSONArray buildJSONForTypes(List<I_CmsResourceType> types) throws JSONException {\n\n        JSONArray result = new JSONArray();\n        if (types == null) {\n            return result;\n        }\n        CmsWorkplaceManager wm = OpenCms.getWorkplaceManager();\n        Iterator<I_CmsResourceType> it = types.iterator();\n        while (it.hasNext()) {\n            I_CmsResourceType type = it.next();\n\n            JSONObject jType = new JSONObject();\n            CmsExplorerTypeSettings es = wm.getExplorerTypeSetting(type.getTypeName());\n            jType.put(JsonKeys.TITLE.getName(), (es.getKey() != null)\n            ? m_workplaceMessages.getString(es.getKey())\n            : type.getTypeName());\n            jType.put(JsonKeys.TYPEID.getName(), type.getTypeId());\n            jType.put(JsonKeys.INFO.getName(), (es.getInfo() != null)\n            ? m_workplaceMessages.getString(es.getInfo())\n            : \"\");\n            JSONArray galleryIds = new JSONArray();\n            Iterator<I_CmsResourceType> galleryTypes = type.getGalleryTypes().iterator();\n            while (galleryTypes.hasNext()) {\n                I_CmsResourceType galleryType = galleryTypes.next();\n                galleryIds.put(galleryType.getTypeId());\n\n            }\n            jType.put(JsonKeys.GALLERYTYPEID.getName(), galleryIds);\n            result.put(jType);\n        }\n\n        return result;\n    }","commit_id":"72a30fb4e7c86593aca0b0b5a3d254e171ec5cf7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public String build() {\n    final ChainIterable<String> reassignCat = new ChainIterable<String>(); // sequence for reassignment info, etc\n    PsiElement followed = resolveToDocStringOwner(reassignCat);\n\n    // check if we got a property ref.\n    // if so, element is an accessor, and originalElement if an identifier\n    // TODO: use messages from resources!\n    PyClass cls;\n    PsiElement outer = null;\n    boolean is_property = false;\n    String accessor_kind = \"None\";\n    if (myOriginalElement != null) {\n      String elementName = myOriginalElement.getText();\n      if (PyUtil.isPythonIdentifier(elementName)) {\n        outer = myOriginalElement.getParent();\n        if (outer instanceof PyQualifiedExpression) {\n          PyExpression qual = ((PyQualifiedExpression)outer).getQualifier();\n          if (qual != null) {\n            PyType type = qual.getType(TypeEvalContext.fast());\n            if (type instanceof PyClassType) {\n              cls = ((PyClassType)type).getPyClass();\n              Property property = cls.findProperty(elementName);\n              if (property != null) {\n                is_property = true;\n                final AccessDirection dir = AccessDirection.of((PyElement)outer);\n                Maybe<Callable> accessor = property.getByDirection(dir);\n                myProlog\n                  .addItem(\"property \").addWith(TagBold, $().addWith(TagCode, $(elementName)))\n                  .addItem(\" of \").add(PythonDocumentationProvider.describeClass(cls, TagCode, true, true))\n                ;\n                if (accessor.isDefined() && property.getDoc() != null) {\n                  myBody.addItem(\": \").addItem(property.getDoc()).addItem(BR);\n                }\n                else {\n                  final Callable getter = property.getGetter().valueOrNull();\n                  if (getter != null && getter != myElement && getter instanceof PyFunction) {\n                    // not in getter, getter's doc comment may be useful\n                    PyStringLiteralExpression docstring = ((PyFunction)getter).getDocStringExpression();\n                    if (docstring != null) {\n                      myProlog\n                        .addItem(BR).addWith(TagItalic, $(\"Copied from getter:\")).addItem(BR)\n                        .addItem(docstring.getStringValue())\n                      ;\n                    }\n                  }\n                  myBody.addItem(BR);\n                }\n                myBody.addItem(BR);\n                if (accessor.isDefined() && accessor.value() == null) followed = null;\n                if (dir == AccessDirection.READ) {\n                  accessor_kind = \"Getter\";\n                }\n                else if (dir == AccessDirection.WRITE) {\n                  accessor_kind = \"Setter\";\n                }\n                else {\n                  accessor_kind = \"Deleter\";\n                }\n                if (followed != null) myEpilog.addWith(TagSmall, $(BR, BR, accessor_kind, \" of property\")).addItem(BR);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (myProlog.isEmpty() && !is_property && !isAttribute()) {\n      myProlog.add(reassignCat);\n    }\n\n    // now followed may contain a doc string\n    if (followed instanceof PyDocStringOwner) {\n      String docString = null;\n      PyStringLiteralExpression doc_expr = ((PyDocStringOwner)followed).getDocStringExpression();\n      if (doc_expr != null) docString = doc_expr.getStringValue();\n      // doc of what?\n      if (followed instanceof PyClass) {\n        cls = (PyClass)followed;\n        myBody.add(PythonDocumentationProvider.describeDecorators(cls, TagItalic, BR, LCombUp));\n        myBody.add(PythonDocumentationProvider.describeClass(cls, TagBold, true, false));\n      }\n      else if (followed instanceof PyFunction) {\n        PyFunction fun = (PyFunction)followed;\n        if (!is_property) {\n          cls = fun.getContainingClass();\n          if (cls != null) {\n            myBody.addWith(TagSmall, PythonDocumentationProvider.describeClass(cls, TagCode, true, true)).addItem(BR).addItem(BR);\n          }\n        }\n        else {\n          cls = null;\n        }\n        myBody\n          .add(PythonDocumentationProvider.describeDecorators(fun, TagItalic, BR, LCombUp))\n          .add(PythonDocumentationProvider.describeFunction(fun, TagBold, LCombUp));\n        if (docString == null) {\n          addInheritedDocString(fun, cls);\n        }\n      }\n      else if (followed instanceof PyFile) {\n        addModulePath((PyFile)followed);\n      }\n      if (docString != null) {\n        myBody.addItem(BR);\n        addFormattedDocString(myElement, docString, myBody, myEpilog);\n      }\n    }\n    else if (is_property) {\n      // if it was a normal accessor, ti would be a function, handled by previous branch\n      String accessor_message;\n      if (followed != null) {\n        accessor_message = \"Declaration: \";\n      }\n      else {\n        accessor_message = accessor_kind + \" is not defined.\";\n      }\n      myBody.addWith(TagItalic, $(accessor_message)).addItem(BR);\n      if (followed != null) myBody.addItem(combUp(PyUtil.getReadableRepr(followed, false)));\n    }\n    else if (isAttribute()) {\n      addAttributeDoc();\n    }\n    else if (followed instanceof PyNamedParameter) {\n      myBody.addItem(combUp(\"Named parameter \" + PyUtil.getReadableRepr(followed, false)));\n      if (!addTypeAndDescriptionFromDocstring((PyNamedParameter)followed)) {\n        //didn't find type in docstring then infer element type\n        if (outer instanceof PyExpression) {\n          TypeEvalContext context = TypeEvalContext.slow();\n          PyType type = ((PyExpression)outer).getType(context);\n          if (type != null) {\n            String s;\n            if (type instanceof PyDynamicallyEvaluatedType) {\n              s = \"\\nDynamically inferred type: %s\";\n            }\n            else {\n              s = \"\\nReassigned value has type: %s\";\n            }\n            myBody\n              .addItem(combUp(String.format(s, PythonDocumentationProvider.getTypeName(type, context))));\n          }\n        }\n      }\n    }\n    else if (followed != null && outer instanceof PyReferenceExpression) {\n      myBody\n        .addItem(BR)\n        .addItem(combUp(PythonDocumentationProvider.describeExpressionType((PyReferenceExpression)outer)));\n    }\n    if (myBody.isEmpty() && myEpilog.isEmpty()) {\n      return null; // got nothing substantial to say!\n    }\n    else {\n      return myResult.toString();\n    }\n  }","id":89431,"modified_method":"public String build() {\n    final ChainIterable<String> reassignCat = new ChainIterable<String>(); // sequence for reassignment info, etc\n    PsiElement followed = resolveToDocStringOwner(reassignCat);\n\n    // check if we got a property ref.\n    // if so, element is an accessor, and originalElement if an identifier\n    // TODO: use messages from resources!\n    PyClass cls;\n    PsiElement outer = null;\n    boolean is_property = false;\n    String accessor_kind = \"None\";\n    if (myOriginalElement != null) {\n      String elementName = myOriginalElement.getText();\n      if (PyUtil.isPythonIdentifier(elementName)) {\n        outer = myOriginalElement.getParent();\n        if (outer instanceof PyQualifiedExpression) {\n          PyExpression qual = ((PyQualifiedExpression)outer).getQualifier();\n          if (qual != null) {\n            PyType type = qual.getType(TypeEvalContext.fast());\n            if (type instanceof PyClassType) {\n              cls = ((PyClassType)type).getPyClass();\n              Property property = cls.findProperty(elementName);\n              if (property != null) {\n                is_property = true;\n                final AccessDirection dir = AccessDirection.of((PyElement)outer);\n                Maybe<Callable> accessor = property.getByDirection(dir);\n                myProlog\n                  .addItem(\"property \").addWith(TagBold, $().addWith(TagCode, $(elementName)))\n                  .addItem(\" of \").add(PythonDocumentationProvider.describeClass(cls, TagCode, true, true))\n                ;\n                if (accessor.isDefined() && property.getDoc() != null) {\n                  myBody.addItem(\": \").addItem(property.getDoc()).addItem(BR);\n                }\n                else {\n                  final Callable getter = property.getGetter().valueOrNull();\n                  if (getter != null && getter != myElement && getter instanceof PyFunction) {\n                    // not in getter, getter's doc comment may be useful\n                    PyStringLiteralExpression docstring = ((PyFunction)getter).getDocStringExpression();\n                    if (docstring != null) {\n                      myProlog\n                        .addItem(BR).addWith(TagItalic, $(\"Copied from getter:\")).addItem(BR)\n                        .addItem(docstring.getStringValue())\n                      ;\n                    }\n                  }\n                  myBody.addItem(BR);\n                }\n                myBody.addItem(BR);\n                if (accessor.isDefined() && accessor.value() == null) followed = null;\n                if (dir == AccessDirection.READ) {\n                  accessor_kind = \"Getter\";\n                }\n                else if (dir == AccessDirection.WRITE) {\n                  accessor_kind = \"Setter\";\n                }\n                else {\n                  accessor_kind = \"Deleter\";\n                }\n                if (followed != null) myEpilog.addWith(TagSmall, $(BR, BR, accessor_kind, \" of property\")).addItem(BR);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (myProlog.isEmpty() && !is_property && !isAttribute()) {\n      myProlog.add(reassignCat);\n    }\n\n    // now followed may contain a doc string\n    if (followed instanceof PyDocStringOwner) {\n      String docString = null;\n      PyStringLiteralExpression doc_expr = ((PyDocStringOwner)followed).getDocStringExpression();\n      if (doc_expr != null) docString = doc_expr.getStringValue();\n      // doc of what?\n      if (followed instanceof PyClass) {\n        cls = (PyClass)followed;\n        myBody.add(PythonDocumentationProvider.describeDecorators(cls, TagItalic, BR, LCombUp));\n        myBody.add(PythonDocumentationProvider.describeClass(cls, TagBold, true, false));\n      }\n      else if (followed instanceof PyFunction) {\n        PyFunction fun = (PyFunction)followed;\n        if (!is_property) {\n          cls = fun.getContainingClass();\n          if (cls != null) {\n            myBody.addWith(TagSmall, PythonDocumentationProvider.describeClass(cls, TagCode, true, true)).addItem(BR).addItem(BR);\n          }\n        }\n        else {\n          cls = null;\n        }\n        myBody\n          .add(PythonDocumentationProvider.describeDecorators(fun, TagItalic, BR, LCombUp))\n          .add(PythonDocumentationProvider.describeFunction(fun, TagBold, LCombUp));\n        if (docString == null) {\n          addInheritedDocString(fun, cls);\n        }\n      }\n      else if (followed instanceof PyFile) {\n        addModulePath((PyFile)followed);\n      }\n      if (docString != null) {\n        myBody.addItem(BR);\n        addFormattedDocString(myElement, docString, myBody, myEpilog);\n      }\n    }\n    else if (is_property) {\n      // if it was a normal accessor, ti would be a function, handled by previous branch\n      String accessor_message;\n      if (followed != null) {\n        accessor_message = \"Declaration: \";\n      }\n      else {\n        accessor_message = accessor_kind + \" is not defined.\";\n      }\n      myBody.addWith(TagItalic, $(accessor_message)).addItem(BR);\n      if (followed != null) myBody.addItem(combUp(PyUtil.getReadableRepr(followed, false)));\n    }\n    else if (isAttribute()) {\n      addAttributeDoc();\n    }\n    else if (followed instanceof PyNamedParameter) {\n      myBody.addItem(combUp(\"Parameter \" + PyUtil.getReadableRepr(followed, false)));\n      boolean typeFromDocstringAdded = addTypeAndDescriptionFromDocstring((PyNamedParameter)followed);\n      if (outer instanceof PyExpression) {\n        TypeEvalContext context = TypeEvalContext.slow();\n        PyType type = ((PyExpression)outer).getType(context);\n        if (type != null) {\n          String s = null;\n          if (type instanceof PyDynamicallyEvaluatedType) {\n            if (!typeFromDocstringAdded) {\n              //don't add dynamic type if docstring type specified\n              s = \"\\nDynamically inferred type: \";\n            }\n          }\n          else {\n            if (outer.getReference() != null) {\n              PsiElement target = outer.getReference().resolve();\n\n              if (target instanceof PyTargetExpression &&\n                  ((PyTargetExpression)target).getName().equals(((PyNamedParameter)followed).getName())) {\n                s = \"\\nReassigned value has type: \";\n              }\n            }\n          }\n          if (s == null && !typeFromDocstringAdded) {\n            s = \"\\nInferred type: \";\n          }\n          if (s != null) {\n            String typeName = PythonDocumentationProvider.getTypeName(type, context);\n            myBody\n              .addItem(combUp(s)).addWith(new LinkWrapper(PythonDocumentationProvider.LINK_TYPE_TYPENAME + typeName),\n                                          $(typeName));\n          }\n        }\n      }\n    }\n    else if (followed != null && outer instanceof PyReferenceExpression) {\n      myBody\n        .addItem(BR)\n        .addItem(combUp(PythonDocumentationProvider.describeExpressionType((PyReferenceExpression)outer)));\n    }\n    if (myBody.isEmpty() && myEpilog.isEmpty()) {\n      return null; // got nothing substantial to say!\n    }\n    else {\n      return myResult.toString();\n    }\n  }","commit_id":"14767c11b7dacc87bb1e41961fbaa11c5460301d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement getDocumentationElementForLink(PsiManager psiManager, String link, PsiElement context) {\n    if (link.equals(LINK_TYPE_CLASS)) {\n      return inferContainingClassOf(context);\n    }\n    else if (link.equals(LINK_TYPE_PARAM)) {\n      return inferClassOfParameter(context);\n    }\n    else if (link.startsWith(LINK_TYPE_PARENT)) {\n      PyClass cls = inferContainingClassOf(context);\n      if (cls != null) {\n        String desired_name = link.substring(LINK_TYPE_PARENT.length());\n        for (PyClassRef parent : cls.iterateAncestors()) {\n          final String parent_name = parent.getClassName();\n          if (parent_name != null && parent_name.equals(desired_name)) return parent.getPyClass();\n        }\n      }\n    }\n    return null;\n  }","id":89432,"modified_method":"@Override\n  public PsiElement getDocumentationElementForLink(PsiManager psiManager, String link, PsiElement context) {\n    if (link.equals(LINK_TYPE_CLASS)) {\n      return inferContainingClassOf(context);\n    }\n    else if (link.equals(LINK_TYPE_PARAM)) {\n      return inferClassOfParameter(context);\n    }\n    else if (link.startsWith(LINK_TYPE_PARENT)) {\n      PyClass cls = inferContainingClassOf(context);\n      if (cls != null) {\n        String desired_name = link.substring(LINK_TYPE_PARENT.length());\n        for (PyClassRef parent : cls.iterateAncestors()) {\n          final String parent_name = parent.getClassName();\n          if (parent_name != null && parent_name.equals(desired_name)) return parent.getPyClass();\n        }\n      }\n    }\n    else if (link.startsWith(LINK_TYPE_TYPENAME)) {\n      String typeName = link.substring(LINK_TYPE_TYPENAME.length());\n      PyType type = PyTypeParser.getTypeByName(context, typeName);\n      if (type instanceof PyClassType) {\n        return ((PyClassType)type).getPyClass();\n      }\n    }\n    return null;\n  }","commit_id":"14767c11b7dacc87bb1e41961fbaa11c5460301d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void consistencyCheck(DocumentImpl doc) throws EXistException {\n    \tshort collectionId = doc.getCollection().getId();\n        Value ref = new ElementValue(collectionId);\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            ArrayList elements = dbElement.findKeys(query);\n            \n            Value key;\n            Value value;\n            byte[] data;\n            // byte[] ndata;\n            VariableByteArrayInput is;\n            int len;\n            int docId;\n            long delta;\n            long address;\n            long gid;\n            long last = 0;\n            Node node;\n            short symbol;\n            String nodeName;\n            StringBuffer msg = new StringBuffer();\n            for (int i = 0; i < elements.size(); i++) {\n                key = (Value) elements.get(i);\n                value = dbElement.get(key);\n                data = value.getData();\n                symbol = ByteConversion.byteToShort(key.data(), key.start() + 3);\n                nodeName = broker.getSymbols().getName(symbol);\n                msg.setLength(0);\n                msg.append(\"Checking \").append(nodeName).append(\": \");\n                \n                is = new VariableByteArrayInput(data);\n                try {\n                    while (is.available() > 0) {\n                        docId = is.readInt();\n                        len = is.readInt();\n                        is.readFixedInt();\n                        if (docId == doc.getDocId()) {\n                            for (int j = 0; j < len; j++) {\n                                delta = is.readLong();\n                                gid = last + delta;\n                                last = gid;\n                                address = StorageAddress.read(is);\n                                node = broker.objectWith(new NodeProxy(doc, gid, address));\n                                if(node == null) {\n                                \tthrow new EXistException(\"Node \" + gid + \" in document \" + doc.getFileName() + \" not found.\");\n                                }\n                                if(node.getNodeType() != Node.ELEMENT_NODE && node.getNodeType() != Node.ATTRIBUTE_NODE) {\n                                \tLOG.warn(\"Node \" + gid + \" in document \" + \n                                \t\t\tdoc.getFileName() + \" is not an element or attribute node.\");\n                                \tLOG.debug(\"Type = \" + node.getNodeType() + \"; name = \" + node.getNodeName() +\n                                \t\t\t\"; value = \" + node.getNodeValue());\n                                \tthrow new EXistException(\"Node \" + gid + \" in document \" + \n                                \t\t\tdoc.getFileName() + \" is not an element or attribute node.\");\n                                }\n                                if(!node.getLocalName().equals(nodeName)) {\n                                \tLOG.warn(\"Node name does not correspond to index entry. Expected \" + nodeName +\n                                \t\t\t\"; found \" + node.getLocalName());\n                                }\n                                msg.append(StorageAddress.toString(address)).append(' ');\n                            }\n                        } else\n                        \tis.skip(len * 4);\n                    }\n                } catch (EOFException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"removeDocument(String) - eof\", e);\n                    }\n                } catch (IOException e) {\n                    LOG.warn(\"removeDocument(String) \" + e.getMessage(), e);\n                }\n                LOG.debug(msg.toString());\n            }\n        } catch (LockException e) {\n            LOG.warn(\"removeDocument(String) - \"\n                    + \"could not acquire lock on elements\", e);\n        } catch (TerminatedException e) {\n            LOG.warn(\"method terminated\", e);\n        } catch (BTreeException e) {\n            LOG.warn(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.warn(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","id":89433,"modified_method":"public void consistencyCheck(DocumentImpl doc) throws EXistException {\n    \tshort collectionId = doc.getCollection().getId();\n        Value ref = new ElementValue(collectionId);\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            ArrayList elements = dbElement.findKeys(query);\n            \n            Value key;\n            Value value;\n            byte[] data;\n            // byte[] ndata;\n            VariableByteArrayInput is;\n            int len;\n            int docId;\n            long delta;\n            long address;\n            long gid;\n            long last = 0;\n            Node node;\n            short symbol;\n            String nodeName;\n            StringBuffer msg = new StringBuffer();\n            for (int i = 0; i < elements.size(); i++) {\n                key = (Value) elements.get(i);\n                value = dbElement.get(key);\n                data = value.getData();\n                symbol = ByteConversion.byteToShort(key.data(), key.start() + 3);\n                nodeName = broker.getSymbols().getName(symbol);\n                msg.setLength(0);\n                msg.append(\"Checking \").append(nodeName).append(\": \");\n                \n                is = new VariableByteArrayInput(data);\n                try {\n                    while (is.available() > 0) {\n                        docId = is.readInt();\n                        len = is.readInt();\n                        is.readFixedInt();\n                        if (docId == doc.getDocId()) {\n                            for (int j = 0; j < len; j++) {\n                                delta = is.readLong();\n                                gid = last + delta;\n                                last = gid;\n                                address = StorageAddress.read(is);\n                                node = broker.objectWith(new NodeProxy(doc, gid, address));\n                                if(node == null) {\n                                \tthrow new EXistException(\"Node \" + gid + \" in document \" + doc.getFileName() + \" not found.\");\n                                }\n                                if(node.getNodeType() != Node.ELEMENT_NODE && node.getNodeType() != Node.ATTRIBUTE_NODE) {\n                                \tLOG.warn(\"Node \" + gid + \" in document \" + \n                                \t\t\tdoc.getFileName() + \" is not an element or attribute node.\");\n                                \tLOG.debug(\"Type = \" + node.getNodeType() + \"; name = \" + node.getNodeName() +\n                                \t\t\t\"; value = \" + node.getNodeValue());\n                                \tthrow new EXistException(\"Node \" + gid + \" in document \" + \n                                \t\t\tdoc.getFileName() + \" is not an element or attribute node.\");\n                                }\n                                if(!node.getLocalName().equals(nodeName)) {\n                                \tLOG.warn(\"Node name does not correspond to index entry. Expected \" + nodeName +\n                                \t\t\t\"; found \" + node.getLocalName());\n                                }\n                                msg.append(StorageAddress.toString(address)).append(' ');\n                            }\n                        } else\n                        \tis.skip(len * 4);\n                    }\n                } catch (EOFException e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"removeDocument(String) - eof\", e);\n                    }\n                } catch (IOException e) {\n                    LOG.warn(\"removeDocument(String) \" + e.getMessage(), e);\n                }\n                LOG.debug(msg.toString());\n            }\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n        } catch (TerminatedException e) {\n            LOG.warn(\"method terminated\", e);\n        } catch (BTreeException e) {\n            LOG.warn(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.warn(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public Occurrences[] scanIndexedElements(Collection collection,\n            boolean inclusive) throws PermissionDeniedException {\n        if (!collection.getPermissions().validate(broker.getUser(),\n                Permission.READ))\n                throw new PermissionDeniedException(\n                        \"you don't have the permission\"\n                                + \" to read collection \" + collection.getName());\n        List collections = inclusive ? collection.getDescendants(broker, broker\n                .getUser()) : new ArrayList();\n        collections.add(collection);\n        TreeMap map = new TreeMap();\n        VariableByteArrayInput is;\n        int len, size;\n        // required for namespace lookups\n        XQueryContext context = new XQueryContext(broker);\n        final Lock lock = dbElement.getLock();\n        for (Iterator i = collections.iterator(); i.hasNext();) {\n            Collection current = (Collection) i.next();\n            short collectionId = current.getId();\n\n            ElementValue ref = new ElementValue(ElementValue.ELEMENT,\n                    collectionId);\n            IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n            try {\n                lock.acquire();\n                ArrayList values = dbElement.findEntries(query);\n                for (Iterator j = values.iterator(); j.hasNext();) {\n                    Value val[] = (Value[]) j.next();\n                    short elementId = ByteConversion.byteToShort(val[0]\n                            .getData(), 3);\n                    short nsSymbol = ByteConversion.byteToShort(val[0]\n                            .getData(), 5);\n\n                    String name = broker.getSymbols().getName(elementId);\n                    String namespace = nsSymbol == 0 ? \"\" : broker.getSymbols()\n                            .getNamespace(nsSymbol);\n                    QName qname = new QName(name, namespace);\n                    Occurrences oc = (Occurrences) map.get(qname);\n                    if (oc == null) {\n                        qname.setPrefix(context.getPrefixForURI(namespace));\n                        oc = new Occurrences(qname);\n                        map.put(qname, oc);\n                    }\n\n                    is = new VariableByteArrayInput(val[1].data(), val[1]\n                            .start(), val[1].getLength());\n                    try {\n                        while (is.available() > 0) { \n                        \tis.readInt();\n                            len = is.readInt();\n                            size = is.readFixedInt();\n                            oc.addOccurrences(len);\n                            is.skipBytes(size);\n                        }\n                    } catch (EOFException e) {\n                    } catch (IOException e) {\n                        LOG.warn(\"unexpected exception\", e);\n                    }\n                }\n            } catch (BTreeException e) {\n                LOG.warn(\"exception while reading element index\", e);\n            } catch (IOException e) {\n                LOG.warn(\"exception while reading element index\", e);\n            } catch (LockException e) {\n                LOG.warn(\"failed to acquire lock\", e);\n            } catch (TerminatedException e) {\n                LOG.warn(\"Method terminated\", e);\n            } finally {\n                lock.release();\n            }\n        }\n        Occurrences[] result = new Occurrences[map.size()];\n        return (Occurrences[]) map.values().toArray(result);\n    }","id":89434,"modified_method":"public Occurrences[] scanIndexedElements(Collection collection, boolean inclusive) \n            throws PermissionDeniedException {\n        if (!collection.getPermissions().validate(broker.getUser(), Permission.READ))\n                throw new PermissionDeniedException(\n                        \"you don't have the permission\"\n                                + \" to read collection \" + collection.getName());\n        List collections = inclusive ? collection.getDescendants(broker, broker\n                .getUser()) : new ArrayList();\n        collections.add(collection);\n        TreeMap map = new TreeMap();\n        VariableByteArrayInput is;\n        int len, size;\n        // required for namespace lookups\n        XQueryContext context = new XQueryContext(broker);\n        final Lock lock = dbElement.getLock();\n        for (Iterator i = collections.iterator(); i.hasNext();) {\n            Collection current = (Collection) i.next();\n            short collectionId = current.getId();\n\n            ElementValue ref = new ElementValue(ElementValue.ELEMENT,\n                    collectionId);\n            IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n            try {\n                lock.acquire();\n                ArrayList values = dbElement.findEntries(query);\n                for (Iterator j = values.iterator(); j.hasNext();) {\n                    Value val[] = (Value[]) j.next();\n                    short elementId = ByteConversion.byteToShort(val[0].getData(), 3);\n                    short nsSymbol = ByteConversion.byteToShort(val[0].getData(), 5);\n                    String name = broker.getSymbols().getName(elementId);\n                    String namespace = nsSymbol == 0 ? \"\" : broker.getSymbols().getNamespace(nsSymbol);\n                    QName qname = new QName(name, namespace);\n                    Occurrences oc = (Occurrences) map.get(qname);\n                    if (oc == null) {\n                        qname.setPrefix(context.getPrefixForURI(namespace));\n                        oc = new Occurrences(qname);\n                        map.put(qname, oc);\n                    }\n\n                    is = new VariableByteArrayInput(val[1].data(), val[1].start(), val[1].getLength());\n                    try {\n                        while (is.available() > 0) { \n                            is.readInt();\n                            len = is.readInt();\n                            size = is.readFixedInt();\n                            oc.addOccurrences(len);\n                            is.skipBytes(size);\n                        }\n                    } catch (EOFException e) {\n                    } catch (IOException e) {\n                        LOG.warn(\"unexpected exception\", e);\n                    }\n                }\n            } catch (BTreeException e) {\n                LOG.warn(\"exception while reading element index\", e);\n            } catch (IOException e) {\n                LOG.warn(\"exception while reading element index\", e);\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n            } catch (TerminatedException e) {\n                LOG.warn(\"Method terminated\", e);\n            } finally {\n                lock.release();\n            }\n        }\n        Occurrences[] result = new Occurrences[map.size()];\n        return (Occurrences[]) map.values().toArray(result);\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Drop all index entries for the given collection.\n     * \n     * @param collection\n     */\n    public void dropIndex(Collection collection) {\n        LOG.debug(\"removing elements ...\");\n        Value ref = new ElementValue(collection.getId());\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            dbElement.removeAll(query);\n        } catch (LockException e) {\n            LOG.error(\"could not acquire lock on elements index\", e);\n        } catch (BTreeException e) {\n            LOG.warn(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.warn(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","id":89435,"modified_method":"/**\n     * Drop all index entries for the given collection.\n     * \n     * @param collection\n     */\n    public void dropIndex(Collection collection) {\n        LOG.debug(\"removing elements ...\");\n        Value ref = new ElementValue(collection.getId());\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            dbElement.removeAll(query);\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n        } catch (BTreeException e) {\n            LOG.warn(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.warn(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public void sync() {\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            try {\n                dbElement.flush();\n            } catch (DBException dbe) {\n                LOG.warn(dbe);\n            }\n        } catch (LockException e) {\n            LOG.warn(\"could not acquire lock for elements\", e);\n        } finally {\n            lock.release();\n        }\n    }","id":89436,"modified_method":"public void sync() {\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            dbElement.flush();\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n        } catch (DBException e) {\n            LOG.warn(e.getMessage(), e);        \n        } finally {\n            lock.release();\n        }\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Find elements by their tag name. This method is comparable to the DOM's\n     * method call getElementsByTagName. All elements matching tagName and\n     * belonging to one of the documents in the DocumentSet docs are returned.\n     * \n     * @param docs\n     *                  Description of the Parameter\n     * @param tagName\n     *                  Description of the Parameter\n     * @return\n     */\n    public NodeSet findElementsByTagName(byte type, DocumentSet docs,\n            QName qname, NodeSelector selector) {\n//    \tfinal long start = System.currentTimeMillis();\n        final ExtArrayNodeSet result = new ExtArrayNodeSet(docs.getLength(),\n                256);\n        final SymbolTable symbols = broker.getSymbols();\n        DocumentImpl doc;\n        int docId;\n        int len, size;\n        short collectionId;\n        long gid;\n        VariableByteInput is = null;\n        ElementValue ref;\n        short sym, nsSym;\n        Collection collection;\n        NodeProxy p;\n        final short nodeType = (type == ElementValue.ATTRIBUTE ? Node.ATTRIBUTE_NODE\n                : Node.ELEMENT_NODE);\n        final Lock lock = dbElement.getLock();\n//        StringBuffer debug = new StringBuffer();\n//        debug.append(qname.toString()).append(\": \");\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            collection = (Collection) i.next();\n            collectionId = collection.getId();\n            if (type == ElementValue.ATTRIBUTE_ID) {\n                ref = new ElementValue((byte) type, collectionId, qname\n                        .getLocalName());\n            } else {\n                sym = symbols.getSymbol(qname.getLocalName());\n                nsSym = symbols.getNSSymbol(qname.getNamespaceURI());\n                ref = new ElementValue((byte) type, collectionId, sym, nsSym);\n            }\n            try {\n            \tlock.acquire(Lock.READ_LOCK);\n            \tis = dbElement.getAsStream(ref);\n            \t\n            \tif (is == null) continue;\n            \twhile (is.available() > 0) {\n            \t\tdocId = is.readInt();\n//                    debug.append(\"D\" + docId + \": \");\n            \t\tlen = is.readInt();\n                    size = is.readFixedInt();\n            \t\tif ((doc = docs.getDoc(docId)) == null) {\n                        is.skipBytes(size);\n            \t\t\tcontinue;\n            \t\t}\n            \t\tgid = 0;\n            \t\tfor (int k = 0; k < len; k++) {\n//            \t\t\tif(result.getLength() > 1000)\n//            \t\t\t\tcontinue;\n            \t\t\tgid = gid + is.readLong();\n            \t\t\tif(selector == null)\n            \t\t\t\tp = new NodeProxy(doc, gid, nodeType, StorageAddress.read(is));\n            \t\t\telse {\n            \t\t\t\tp = selector.match(doc, gid);\n            \t\t\t\tif(p != null) {\n            \t\t\t\t\tp.setInternalAddress(StorageAddress.read(is));\n            \t\t\t\t\tp.setNodeType(nodeType);\n            \t\t\t\t} else\n            \t\t\t\t\tis.skip(3);\n            \t\t\t}\n            \t\t\tif(p != null) {\n//            \t\t\t\tdebug.append(StorageAddress.toString(p.getInternalAddress())).append(':');\n//            \t\t\t\tdebug.append(gid).append(' ');\n            \t\t\t\tresult.add(p, len);\n            \t\t\t}\n            \t\t}\n            \t}\n            } catch (EOFException e) {\n            \t//EOFExceptions are expected here\n            } catch (LockException e) {\n                LOG.warn(\n                        \"findElementsByTagName(byte, DocumentSet, QName, NodeSelector) - \"\n                                + \"failed to acquire lock\", e);\n            } catch (IOException e) {\n                LOG.warn(\n                        \"findElementsByTagName(byte, DocumentSet, QName, NodeSelector) - \"\n                                + \"io exception while reading elements for \"\n                                + qname, e);\n            } finally {\n                lock.release();\n            }\n        }\n//        LOG.debug(debug.toString());\n        //\t\tresult.sort();\n//        count++;\n//        accTime += (System.currentTimeMillis() - start);\n//        LOG.debug(\n//        \t\t\"found \"\n//        \t\t+ qname\n//\t\t\t\t+ \": \"\n//\t\t\t\t+ result.getLength()\n//\t\t\t\t+ \" in \"\n//\t\t\t\t+ (System.currentTimeMillis() - start)\n//\t\t\t\t+ \"ms.\");\n        return result;\n    }","id":89437,"modified_method":"/**\n     * Find elements by their tag name. This method is comparable to the DOM's\n     * method call getElementsByTagName. All elements matching tagName and\n     * belonging to one of the documents in the DocumentSet docs are returned.\n     * \n     * @param docs\n     *                  Description of the Parameter\n     * @param tagName\n     *                  Description of the Parameter\n     * @return\n     */\n    public NodeSet findElementsByTagName(byte type, DocumentSet docs, QName qname, NodeSelector selector) {\n        final ExtArrayNodeSet result = new ExtArrayNodeSet(docs.getLength(), 256);\n        final SymbolTable symbols = broker.getSymbols();\n        DocumentImpl doc;\n        int docId;\n        int len, size;\n        short collectionId;\n        long gid;\n        VariableByteInput is = null;\n        ElementValue ref;\n        short sym, nsSym;\n        Collection collection;\n        NodeProxy p;\n        final short nodeType = (type == ElementValue.ATTRIBUTE ? Node.ATTRIBUTE_NODE\n                : Node.ELEMENT_NODE);\n        final Lock lock = dbElement.getLock();\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            collection = (Collection) i.next();\n            collectionId = collection.getId();\n            if (type == ElementValue.ATTRIBUTE_ID) {\n                ref = new ElementValue((byte) type, collectionId, qname.getLocalName());\n            } else {\n                sym = symbols.getSymbol(qname.getLocalName());\n                nsSym = symbols.getNSSymbol(qname.getNamespaceURI());\n                ref = new ElementValue((byte) type, collectionId, sym, nsSym);\n            }\n            try {\n                lock.acquire(Lock.READ_LOCK);\n                is = dbElement.getAsStream(ref);\n                \n                if (is == null) \n                    continue;\n                \n                while (is.available() > 0) {\n                    docId = is.readInt();\n                    len = is.readInt();\n                    size = is.readFixedInt();\n                    doc = docs.getDoc(docId);\n                    if (doc == null) {\n                        is.skipBytes(size);\n                        continue;\n                    }\n                    \n                    gid = 0;\n                    for (int k = 0; k < len; k++) {\n                        gid = gid + is.readLong();\n                        if (selector == null)\n                            p = new NodeProxy(doc, gid, nodeType, StorageAddress.read(is));\n                        else {\n                            p = selector.match(doc, gid);\n                            if (p == null) {\n                                is.skip(3);\n                            } else {\n                                p.setInternalAddress(StorageAddress.read(is));\n                                p.setNodeType(nodeType);                                \n                            }                                \n                        }\n                        if (p != null) {\n                            result.add(p, len);\n                        }\n                    }\n                }\n            } catch (EOFException e) {\n                //EOFExceptions are expected here\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.warn(\n                        \"findElementsByTagName(byte, DocumentSet, QName, NodeSelector) - \"\n                                + \"io exception while reading elements for \"\n                                + qname, e);\n            } finally {\n                lock.release();\n            }\n        }\n        return result;\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Drop all index entries for the given document.\n     * \n     * @param doc\n     * @throws ReadOnlyException\n     */\n    public void dropIndex(DocumentImpl doc) throws ReadOnlyException {\n        //\t  drop element-index\n        short collectionId = doc.getCollection().getId();\n        Value ref = new ElementValue(collectionId);\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            ArrayList elements = dbElement.findKeys(query);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"removeDocument() - \" + \"found \" + elements.size()\n                        + \" elements.\");\n            }\n\n            Value key;\n            VariableByteInput is;\n            int len, size;\n            int docId;\n            boolean changed;\n            for (int i = 0; i < elements.size(); i++) {\n                key = (Value) elements.get(i);\n                is = dbElement.getAsStream(key);\n                os.clear();\n                changed = false;\n                try {\n                    while (is.available() > 0) {\n                        docId = is.readInt();\n                        len = is.readInt();\n                        size = is.readFixedInt();\n                        if (docId != doc.getDocId()) {\n                            // copy data to new buffer\n                            os.writeInt(docId);\n                            os.writeInt(len);\n                            os.writeFixedInt(size);\n                            is.copyRaw(os, size);\n//                            is.copyTo(os, len * 4);\n                        } else {\n                            changed = true;\n                            // skip\n                            is.skipBytes(size);\n                        }\n                    }\n                } catch (EOFException e) {\n                    // EOF is expected here\n                } catch (IOException e) {\n                    LOG.warn(\"removeDocument(String) \" + e.getMessage(), e);\n                }\n                if (changed) {\n                    if (dbElement.put(key, os.data()) < 0)\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"removeDocument() - \"\n                                        + \"could not save element\");\n                            }\n                }\n            }\n        } catch (LockException e) {\n            LOG.warn(\"removeDocument(String) - \"\n                    + \"could not acquire lock on elements\", e);\n        } catch (TerminatedException e) {\n            LOG.warn(\"method terminated\", e);\n        } catch (BTreeException e) {\n            LOG.warn(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.warn(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","id":89438,"modified_method":"/**\n     * Drop all index entries for the given document.\n     * \n     * @param doc\n     * @throws ReadOnlyException\n     */\n    public void dropIndex(DocumentImpl doc) throws ReadOnlyException {\n        //\t  drop element-index\n        short collectionId = doc.getCollection().getId();\n        Value ref = new ElementValue(collectionId);\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbElement.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            ArrayList elements = dbElement.findKeys(query);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"removeDocument() - \" + \"found \" + elements.size()\n                        + \" elements.\");\n            }\n\n            Value key;\n            VariableByteInput is;\n            int len, size;\n            int docId;\n            boolean changed;\n            for (int i = 0; i < elements.size(); i++) {\n                key = (Value) elements.get(i);\n                is = dbElement.getAsStream(key);\n                os.clear();\n                changed = false;\n                try {\n                    while (is.available() > 0) {\n                        docId = is.readInt();\n                        len = is.readInt();\n                        size = is.readFixedInt();\n                        if (docId != doc.getDocId()) {\n                            // copy data to new buffer\n                            os.writeInt(docId);\n                            os.writeInt(len);\n                            os.writeFixedInt(size);\n                            is.copyRaw(os, size);\n//                            is.copyTo(os, len * 4);\n                        } else {\n                            changed = true;\n                            // skip\n                            is.skipBytes(size);\n                        }\n                    }\n                } catch (EOFException e) {\n                    // EOF is expected here\n                } catch (IOException e) {\n                    LOG.warn(\"removeDocument(String) \" + e.getMessage(), e);\n                }\n                if (changed) {\n                    if (dbElement.put(key, os.data()) == BFile.UNKNOWN_ADDRESS)\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"removeDocument() - \"\n                                        + \"could not save element\");\n                            }\n                }\n            }\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n        } catch (TerminatedException e) {\n            LOG.warn(\"method terminated\", e);\n        } catch (BTreeException e) {\n            LOG.warn(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.warn(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Flush all pending index entries. This method is called while\n     * a document is stored.\n     */\n    public void flush() {\n        if (elementIds.size() == 0) return;\n        final ProgressIndicator progress = new ProgressIndicator(elementIds\n                .size(), 5);\n\n        NodeProxy proxy;\n        QName qname;\n        ArrayList idList;\n        int count = 1, len;\n//        String name;\n        ElementValue ref;\n        Map.Entry entry;\n        // get collection id for this collection\n        long prevId;\n        long cid;\n        int lenOffset;\n        short collectionId = doc.getCollection().getId();\n        Lock lock = dbElement.getLock();\n        try {\n            for (Iterator i = elementIds.entrySet().iterator(); i.hasNext();) {\n                entry = (Map.Entry) i.next();\n                qname = (QName) entry.getKey();\n                idList = (ArrayList) entry.getValue();\n                os.clear();\n                FastQSort.sort(idList, 0, idList.size() - 1);\n                len = idList.size();\n                os.writeInt(doc.getDocId());\n                os.writeInt(len);\n                lenOffset = os.position();\n                os.writeFixedInt(0);\n                \n                prevId = 0;\n                for (int j = 0; j < len; j++) {\n                    proxy = (NodeProxy) idList.get(j);\n                    cid = proxy.getGID() - prevId;\n                    prevId = proxy.getGID();\n                    os.writeLong(cid);\n                    StorageAddress.write(proxy.getInternalAddress(), os);\n                }\n                \n                os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n                \n                if (qname.getNameType() != ElementValue.ATTRIBUTE_ID) {\n                    short sym = broker.getSymbols().getSymbol(\n                            qname.getLocalName());\n                    short nsSym = broker.getSymbols().getNSSymbol(\n                            qname.getNamespaceURI());\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            sym, nsSym);\n                } else {\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            qname.getLocalName());\n                }\n                try {\n                    lock.acquire(Lock.WRITE_LOCK);\n                    if (dbElement.append(ref, os.data()) < 0) {\n                        LOG.warn(\"could not save index for element \" + qname);\n                        continue;\n                    }\n                } catch (LockException e) {\n                    LOG.error(\"could not acquire lock on elements\", e);\n                } catch (IOException e) {\n                    LOG.error(\"io error while writing element \" + qname, e);\n                } finally {\n                    lock.release();\n                }\n                progress.setValue(count);\n                if (progress.changed()) {\n                    setChanged();\n                    notifyObservers(progress);\n                }\n                count++;\n            }\n        } catch (ReadOnlyException e) {\n            LOG.warn(\"database is read-only\");\n            return;\n        }\n        progress.finish();\n        setChanged();\n        notifyObservers(progress);\n        elementIds.clear();\n    }","id":89439,"modified_method":"/**\n     * Flush all pending index entries. This method is called while\n     * a document is stored.\n     */\n    public void flush() {\n        if (elementIds.size() == 0) \n            return;\n        \n        final ProgressIndicator progress = new ProgressIndicator(elementIds.size(), 5);\n\n        NodeProxy proxy;\n        QName qname;\n        ArrayList idList;\n        int count = 1, len;\n//        String name;\n        ElementValue ref;\n        Map.Entry entry;\n        // get collection id for this collection\n        long prevId;\n        long delta;\n        int lenOffset;\n        short collectionId = doc.getCollection().getId();\n        Lock lock = dbElement.getLock();\n        try {\n            for (Iterator i = elementIds.entrySet().iterator(); i.hasNext();) {\n                entry = (Map.Entry) i.next();\n                qname = (QName) entry.getKey();\n                idList = (ArrayList) entry.getValue();\n                os.clear();\n                FastQSort.sort(idList, 0, idList.size() - 1);\n                len = idList.size();\n                os.writeInt(doc.getDocId());\n                os.writeInt(len);\n                lenOffset = os.position();\n                os.writeFixedInt(0);\n                \n                prevId = 0;\n                for (int j = 0; j < len; j++) {\n                    proxy = (NodeProxy) idList.get(j);\n                    delta = proxy.getGID() - prevId;\n                    prevId = proxy.getGID();\n                    os.writeLong(delta);\n                    StorageAddress.write(proxy.getInternalAddress(), os);\n                }\n                \n                os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n                \n                if (qname.getNameType() != ElementValue.ATTRIBUTE_ID) {\n                    short sym = broker.getSymbols().getSymbol(\n                            qname.getLocalName());\n                    short nsSym = broker.getSymbols().getNSSymbol(\n                            qname.getNamespaceURI());\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            sym, nsSym);\n                } else {\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            qname.getLocalName());\n                }\n                try {\n                    lock.acquire(Lock.WRITE_LOCK);\n                    if (dbElement.append(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"could not save index for element \" + qname);\n                        continue;\n                    }\n                } catch (LockException e) {\n                    LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n                } catch (IOException e) {\n                    LOG.error(\"io error while writing element \" + qname, e);\n                } finally {\n                    lock.release();\n                }\n                progress.setValue(count);\n                if (progress.changed()) {\n                    setChanged();\n                    notifyObservers(progress);\n                }\n                count++;\n            }\n        } catch (ReadOnlyException e) {\n            LOG.warn(\"database is read-only\");\n            return;\n        }\n        progress.finish();\n        setChanged();\n        notifyObservers(progress);\n        elementIds.clear();\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public void remove() {\n        if (elementIds.size() == 0) return;\n        Lock lock = dbElement.getLock();\n        Map.Entry entry;\n        QName qname;\n        List newList = new ArrayList(), idList;\n        NodeProxy p;\n        VariableByteArrayInput is;\n        int len, size, docId, lenOffset;\n        byte[] data;\n        Value ref;\n        Value val;\n        short sym, nsSym;\n        short collectionId = doc.getCollection().getId();\n        long delta, last, gid, address;\n        try {\n            // iterate through elements\n            for (Iterator i = elementIds.entrySet().iterator(); i.hasNext();) {\n                try {\n                    lock.acquire(Lock.WRITE_LOCK);\n                    entry = (Map.Entry) i.next();\n                    idList = (ArrayList) entry.getValue();\n                    qname = (QName) entry.getKey();\n                    if (qname.getNameType() != ElementValue.ATTRIBUTE_ID) {\n                        sym = broker.getSymbols().getSymbol(qname.getLocalName());\n                        nsSym = broker.getSymbols().getNSSymbol(\n                                qname.getNamespaceURI());\n                        ref = new ElementValue(qname.getNameType(), collectionId,\n                                sym, nsSym);\n                    } else {\n                        ref = new ElementValue(qname.getNameType(), collectionId,\n                                qname.getLocalName());\n                    }\n                    val = dbElement.get(ref);\n                    os.clear();\n                    newList.clear();\n                    if (val != null) {\n                        // add old entries to the new list\n                        data = val.getData();\n                        is = new VariableByteArrayInput(data);\n                        try {\n                            while (is.available() > 0) {\n                                docId = is.readInt();\n                                len = is.readInt();\n                                size = is.readFixedInt();\n                                if (docId != doc.getDocId()) {\n                                    // section belongs to another document:\n                                    // copy data to new buffer\n                                    os.writeInt(docId);\n                                    os.writeInt(len);\n                                    os.writeFixedInt(size);\n                                    try {\n                                        is.copyRaw(os, size);\n                                    } catch(EOFException e) {\n                                        LOG.error(\"EOF while copying: expected: \" + len);\n                                    }\n                                } else {\n                                    // copy nodes to new list\n                                    last = 0;\n                                    for (int j = 0; j < len; j++) {\n                                        delta = is.readLong();\n                                        gid = last + delta;\n                                        last = gid;\n                                        address = StorageAddress.read(is);\n                                        if (!containsNode(idList, gid)) {\n                                            newList.add(new NodeProxy(doc, gid,\n                                                    address));\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (EOFException e) {\n                            LOG\n                            .error(\"end-of-file while updating index for element \"\n                                    + qname);\n                        } catch (IOException e) {\n                            LOG.error(\"io-error while updating index for element \"\n                                    + qname);\n                        }\n                    }\n                    // write out the updated list\n                    FastQSort.sort(newList, 0, newList.size() - 1);\n                    len = newList.size();\n                    os.writeInt(doc.getDocId());\n                    os.writeInt(len);\n                    lenOffset = os.position();\n                    os.writeFixedInt(0);\n                    last = 0;\n                    for (int j = 0; j < len; j++) {\n                        p = (NodeProxy) newList.get(j);\n                        delta = p.getGID() - last;\n                        last = p.getGID();\n                        os.writeLong(delta);\n                        StorageAddress.write(p.getInternalAddress(), os);\n                    }\n                    \n                    os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n                    \n                    if (val == null) {\n                    \tdbElement.put(ref, os.data());\n                    } else {\n                    \tdbElement.update(val.getAddress(), ref, os.data());\n                    }\n                } catch (LockException e) {\n                    LOG.error(\"could not acquire lock on elements\", e);\n                } finally {\n                    lock.release();\n                }\n            }\n        } catch (ReadOnlyException e) {\n            LOG.warn(\"database is read only\");\n        }\n        elementIds.clear();\n    }","id":89440,"modified_method":"public void remove() {\n        if (elementIds.size() == 0) return;\n        Lock lock = dbElement.getLock();\n        Map.Entry entry;\n        QName qname;\n        List newList = new ArrayList(), idList;\n        NodeProxy p;\n        VariableByteArrayInput is;\n        int len, size, docId, lenOffset;\n        byte[] data;\n        Value ref;\n        Value val;\n        short sym, nsSym;\n        short collectionId = doc.getCollection().getId();\n        long delta, last, gid, address;\n        try {\n            // iterate through elements\n            for (Iterator i = elementIds.entrySet().iterator(); i.hasNext();) {\n                try {\n                    lock.acquire(Lock.WRITE_LOCK);\n                    entry = (Map.Entry) i.next();\n                    idList = (ArrayList) entry.getValue();\n                    qname = (QName) entry.getKey();\n                    if (qname.getNameType() != ElementValue.ATTRIBUTE_ID) {\n                        sym = broker.getSymbols().getSymbol(qname.getLocalName());\n                        nsSym = broker.getSymbols().getNSSymbol(\n                                qname.getNamespaceURI());\n                        ref = new ElementValue(qname.getNameType(), collectionId,\n                                sym, nsSym);\n                    } else {\n                        ref = new ElementValue(qname.getNameType(), collectionId,\n                                qname.getLocalName());\n                    }\n                    val = dbElement.get(ref);\n                    os.clear();\n                    newList.clear();\n                    if (val != null) {\n                        // add old entries to the new list\n                        data = val.getData();\n                        is = new VariableByteArrayInput(data);\n                        try {\n                            while (is.available() > 0) {\n                                docId = is.readInt();\n                                len = is.readInt();\n                                size = is.readFixedInt();\n                                if (docId != doc.getDocId()) {\n                                    // section belongs to another document:\n                                    // copy data to new buffer\n                                    os.writeInt(docId);\n                                    os.writeInt(len);\n                                    os.writeFixedInt(size);\n                                    try {\n                                        is.copyRaw(os, size);\n                                    } catch(EOFException e) {\n                                        LOG.error(\"EOF while copying: expected: \" + len);\n                                    }\n                                } else {\n                                    // copy nodes to new list\n                                    last = 0;\n                                    for (int j = 0; j < len; j++) {\n                                        delta = is.readLong();\n                                        gid = last + delta;\n                                        last = gid;\n                                        address = StorageAddress.read(is);\n                                        if (!containsNode(idList, gid)) {\n                                            newList.add(new NodeProxy(doc, gid,\n                                                    address));\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (EOFException e) {\n                            LOG\n                            .error(\"end-of-file while updating index for element \"\n                                    + qname);\n                        } catch (IOException e) {\n                            LOG.error(\"io-error while updating index for element \"\n                                    + qname);\n                        }\n                    }\n                    // write out the updated list\n                    FastQSort.sort(newList, 0, newList.size() - 1);\n                    len = newList.size();\n                    os.writeInt(doc.getDocId());\n                    os.writeInt(len);\n                    lenOffset = os.position();\n                    os.writeFixedInt(0);\n                    last = 0;\n                    for (int j = 0; j < len; j++) {\n                        p = (NodeProxy) newList.get(j);\n                        delta = p.getGID() - last;\n                        last = p.getGID();\n                        os.writeLong(delta);\n                        StorageAddress.write(p.getInternalAddress(), os);\n                    }\n                    \n                    os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n                    \n                    if (val == null) {\n                        dbElement.put(ref, os.data());\n                    } else {\n                        dbElement.update(val.getAddress(), ref, os.data());\n                    }\n                } catch (LockException e) {\n                    LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n                } finally {\n                    lock.release();\n                }\n            }\n        } catch (ReadOnlyException e) {\n            LOG.warn(\"database is read only\");\n        }\n        elementIds.clear();\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/** Called by {@link NativeBroker.reIndex} */\n    public void reindex(DocumentImpl oldDoc, NodeImpl node) {\n        if (elementIds.size() == 0) return;\n        Lock lock = dbElement.getLock();\n        Map.Entry entry;\n        QName qname;\n        List oldList = new ArrayList(), idList;\n        NodeProxy p;\n        VariableByteInput is = null;\n        int len, size, lenOffset, docId;\n//        byte[] data;\n        Value ref;\n//        Value val;\n        short sym, nsSym;\n        short collectionId = oldDoc.getCollection().getId();\n        long delta, last, gid, address;\n        try {\n            // iterate through elements\n            for (Iterator i = elementIds.entrySet().iterator(); i.hasNext();) {\n                entry = (Map.Entry) i.next();\n                idList = (ArrayList) entry.getValue();\n                qname = (QName) entry.getKey();\n                if (qname.getNameType() != ElementValue.ATTRIBUTE_ID) {\n                    sym = broker.getSymbols().getSymbol(qname.getLocalName());\n                    nsSym = broker.getSymbols().getNSSymbol(\n                            qname.getNamespaceURI());\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            sym, nsSym);\n                } else\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            qname.getLocalName());\n                // try to retrieve old index entry for the element\n                try {\n                    lock.acquire(Lock.WRITE_LOCK);\n                    is = dbElement.getAsStream(ref);\n                    os.clear();\n                    oldList.clear();\n                    if (is != null) {\n                        // add old entries to the new list\n                        try {\n                            while (is.available() > 0) {\n                                docId = is.readInt();\n                                len = is.readInt();\n                                size = is.readFixedInt();\n                                if (docId != oldDoc.getDocId()) {\n                                    // section belongs to another document:\n                                    // copy data to new buffer\n                                    os.writeInt(docId);\n                                    os.writeInt(len);\n                                    os.writeFixedInt(size);\n                                    is.copyTo(os, len * 4);\n                                } else {\n                                    // copy nodes to new list\n                                    last = 0;\n                                    for (int j = 0; j < len; j++) {\n                                        delta = is.readLong();\n                                        gid = last + delta;\n                                        last = gid;\n                                        address = StorageAddress.read(is);\n                                        if (node == null\n                                                && oldDoc.getTreeLevel(gid) < oldDoc\n                                                .reindexRequired()) {\n                                            idList.add(new NodeProxy(oldDoc, gid,\n                                                    address));\n                                        } else if (node != null\n                                                && (!XMLUtil.isDescendant(oldDoc,\n                                                        node.getGID(), gid))) {\n                                            oldList.add(new NodeProxy(oldDoc, gid,\n                                                    address));\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (EOFException e) {\n                        } catch (IOException e) {\n                            LOG.error(\"io-error while updating index for element \"\n                                    + qname);\n                        }\n                    }\n                    if (node != null) idList.addAll(oldList);\n                    // write out the updated list\n                    FastQSort.sort(idList, 0, idList.size() - 1);\n                    len = idList.size();\n                    os.writeInt(doc.getDocId());\n                    os.writeInt(len);\n                    lenOffset = os.position();\n                    os.writeFixedInt(0);\n                    last = 0;\n                    for (int j = 0; j < len; j++) {\n                        p = (NodeProxy) idList.get(j);\n                        delta = p.getGID() - last;\n                        last = p.getGID();\n                        os.writeLong(delta);\n                        StorageAddress.write(p.getInternalAddress(), os);\n                    }\n                    \n                    os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n                    \n                    if (is == null)\n                        dbElement.put(ref, os.data());\n                    else {\n                        address = ((BFile.PageInputStream) is).getAddress();\n                        dbElement.update(address, ref, os.data());\n                    }\n                } catch (LockException e) {\n                    LOG.error(\"could not acquire lock for index on \" + qname);\n                    return;\n                } catch (IOException e) {\n                    LOG.error(\"io error while reindexing \" + qname, e);\n                    is = null;\n                } finally {\n                    lock.release(Lock.WRITE_LOCK);\n                }\n            }\n        } catch (ReadOnlyException e) {\n            LOG.warn(\"database is read only\");\n        }\n        elementIds.clear();\n    }","id":89441,"modified_method":"/** Called by {@link NativeBroker.reIndex} */\n    public void reindex(DocumentImpl oldDoc, NodeImpl node) {\n        if (elementIds.size() == 0) return;\n        Lock lock = dbElement.getLock();\n        Map.Entry entry;\n        QName qname;\n        List oldList = new ArrayList(), idList;\n        NodeProxy p;\n        VariableByteInput is = null;\n        int len, size, lenOffset, docId;\n//        byte[] data;\n        Value ref;\n//        Value val;\n        short sym, nsSym;\n        short collectionId = oldDoc.getCollection().getId();\n        long delta, last, gid, address;\n        try {\n            // iterate through elements\n            for (Iterator i = elementIds.entrySet().iterator(); i.hasNext();) {\n                entry = (Map.Entry) i.next();\n                idList = (ArrayList) entry.getValue();\n                qname = (QName) entry.getKey();\n                if (qname.getNameType() != ElementValue.ATTRIBUTE_ID) {\n                    sym = broker.getSymbols().getSymbol(qname.getLocalName());\n                    nsSym = broker.getSymbols().getNSSymbol(\n                            qname.getNamespaceURI());\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            sym, nsSym);\n                } else\n                    ref = new ElementValue(qname.getNameType(), collectionId,\n                            qname.getLocalName());\n                // try to retrieve old index entry for the element\n                try {\n                    lock.acquire(Lock.WRITE_LOCK);\n                    is = dbElement.getAsStream(ref);\n                    os.clear();\n                    oldList.clear();\n                    if (is != null) {\n                        // add old entries to the new list\n                        try {\n                            while (is.available() > 0) {\n                                docId = is.readInt();\n                                len = is.readInt();\n                                size = is.readFixedInt();\n                                if (docId != oldDoc.getDocId()) {\n                                    // section belongs to another document:\n                                    // copy data to new buffer\n                                    os.writeInt(docId);\n                                    os.writeInt(len);\n                                    os.writeFixedInt(size);\n                                    is.copyTo(os, len * 4);\n                                } else {\n                                    // copy nodes to new list\n                                    last = 0;\n                                    for (int j = 0; j < len; j++) {\n                                        delta = is.readLong();\n                                        gid = last + delta;\n                                        last = gid;\n                                        address = StorageAddress.read(is);\n                                        if (node == null\n                                                && oldDoc.getTreeLevel(gid) < oldDoc\n                                                .reindexRequired()) {\n                                            idList.add(new NodeProxy(oldDoc, gid,\n                                                    address));\n                                        } else if (node != null\n                                                && (!XMLUtil.isDescendant(oldDoc,\n                                                        node.getGID(), gid))) {\n                                            oldList.add(new NodeProxy(oldDoc, gid,\n                                                    address));\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (EOFException e) {\n                        } catch (IOException e) {\n                            LOG.error(\"io-error while updating index for element \"\n                                    + qname);\n                        }\n                    }\n                    if (node != null) idList.addAll(oldList);\n                    // write out the updated list\n                    FastQSort.sort(idList, 0, idList.size() - 1);\n                    len = idList.size();\n                    os.writeInt(doc.getDocId());\n                    os.writeInt(len);\n                    lenOffset = os.position();\n                    os.writeFixedInt(0);\n                    last = 0;\n                    for (int j = 0; j < len; j++) {\n                        p = (NodeProxy) idList.get(j);\n                        delta = p.getGID() - last;\n                        last = p.getGID();\n                        os.writeLong(delta);\n                        StorageAddress.write(p.getInternalAddress(), os);\n                    }\n                    \n                    os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n                    \n                    if (is == null)\n                        dbElement.put(ref, os.data());\n                    else {\n                        address = ((BFile.PageInputStream) is).getAddress();\n                        dbElement.update(address, ref, os.data());\n                    }\n                } catch (LockException e) {\n                    LOG.warn(\"Failed to acquire lock for '\" + dbElement.getFile().getName() + \"'\", e);\n                    return;\n                } catch (IOException e) {\n                    LOG.error(\"io error while reindexing \" + qname, e);\n                    is = null;\n                } finally {\n                    lock.release(Lock.WRITE_LOCK);\n                }\n            }\n        } catch (ReadOnlyException e) {\n            LOG.warn(\"database is read only\");\n        }\n        elementIds.clear();\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public ValueOccurrences[] scanIndexKeys(DocumentSet docs, NodeSet contextSet,\n            Indexable start) {\n        long t0 = System.currentTimeMillis();\n        final Lock lock = db.getLock();\n        short collectionId;\n        Collection current;\n        IndexQuery query;\n        int type = ((Item) start).getType();\n        boolean stringType = Type.subTypeOf(type, Type.STRING);\n        IndexScanCallback cb = new IndexScanCallback(docs, contextSet, type);\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            current = (Collection) i.next();\n            collectionId = current.getId();\n            byte[] startKey = start.serialize(collectionId, caseSensitive);\n            int op = stringType ? IndexQuery.TRUNC_RIGHT : IndexQuery.GEQ;\n            query = new IndexQuery(op, new Value(startKey));\n            Value prefix = getPrefixValue(start.getType(), collectionId);\n            try {\n                lock.acquire();\n                if (stringType)\n                    db.query(query, cb);\n                else\n                    db.query(query, prefix, cb);\n            } catch (LockException e) {\n                LOG.warn(\"cannot get lock on words\", e);\n            } catch (IOException e) {\n                LOG.warn(\"error while reading words\", e);\n            } catch (BTreeException e) {\n                LOG.warn(\"error while reading words\", e);\n            } catch (TerminatedException e) {\n                LOG.warn(\"Method terminated\", e);\n            } finally {\n                lock.release();\n            }\n        }\n        Map map = cb.map;\n        ValueOccurrences[] result = new ValueOccurrences[map.size()];\n        LOG.debug(\"Found \" + result.length + \" in \" + (System.currentTimeMillis() - t0));\n        return (ValueOccurrences[]) map.values().toArray(result);\n    }","id":89442,"modified_method":"public ValueOccurrences[] scanIndexKeys(DocumentSet docs, NodeSet contextSet, Indexable start) {        \n        final int type = ((Item) start).getType();\n        final boolean stringType = Type.subTypeOf(type, Type.STRING);\n        final IndexScanCallback cb = new IndexScanCallback(docs, contextSet, type);\n        final Lock lock = db.getLock();\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            Collection current = (Collection) i.next();\n            short collectionId = current.getId();\n            int op = stringType ? IndexQuery.TRUNC_RIGHT : IndexQuery.GEQ;\n            byte[] startKey = start.serialize(collectionId, caseSensitive);            \n            IndexQuery query = new IndexQuery(op, new Value(startKey));            \n            try {\n                lock.acquire();               \n                if (stringType)\n                    db.query(query, cb);\n                else {\n                    Value prefix = getValuePrefix(start.getType(), collectionId);\n                    db.query(query, prefix, cb);\n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n            } catch (BTreeException e) {\n                LOG.error(e.getMessage(), e);\n            } catch (TerminatedException e) {\n                LOG.warn(e.getMessage(), e);\n            } finally {\n                lock.release();\n            }\n        }\n        Map map = cb.map;\n        ValueOccurrences[] result = new ValueOccurrences[map.size()];        \n        return (ValueOccurrences[]) map.values().toArray(result);\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public void sync() {\n        Lock lock = db.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            try {\n                db.flush();\n            } catch (DBException dbe) {\n                LOG.warn(dbe);\n            }\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);\n            //TODO : throw an exception ? -pb\n        } finally {\n            lock.release();\n        }\n    }","id":89443,"modified_method":"public void sync() {\n        Lock lock = db.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            db.flush();            \n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);\n            //TODO : throw an exception ? -pb\n        } catch (DBException dbe) {\n            LOG.warn(dbe);                   \n        } finally {\n            lock.release();\n        }\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public void reindex(DocumentImpl document, NodeImpl node) {\n        if (pending.size() == 0) \n            return;        \n        Indexable indexable;\n        LongLinkedList currentGIDList;\n        LongLinkedList newGIDList;\n        long[] gids;        \n        int gidsCount;\n        long currentGID;\n        long previousGID;        \n        long delta;        \n        Value ref;\n        Map.Entry entry;        \n        VariableByteInput is;        \n        int currentDocId;\n        long address;\n        final short collectionId = doc.getCollection().getId();\n        final Lock lock = db.getLock();        \n        // iterate through elements\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            entry = (Map.Entry) i.next();\n            indexable = (Indexable) entry.getKey();\n            currentGIDList = (LongLinkedList) entry.getValue();\n            ref = new Value(indexable.serialize(collectionId, caseSensitive));                \n            // Retrieve old index entry for the element\n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                is = db.getAsStream(ref);\n                os.clear();\n                newGIDList = new LongLinkedList();\n                if (is != null) {\n                    // add old entries to the new list\n                    try {\n                        while (is.available() > 0) {\n                            currentDocId = is.readInt();\n                            gidsCount = is.readInt();\n                            if (currentDocId != document.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(gidsCount);\n                                os.writeInt(gidsCount);\n                                is.copyTo(os, gidsCount);\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs                                    \n                                previousGID = 0;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    delta = is.readLong();\n                                    currentGID = previousGID + delta;    \n                                    if (node == null) {\n                                        if (document.getTreeLevel(currentGID) < document.reindexRequired())\n                                            currentGIDList.add(currentGID);\n                                    } else {\n                                         if (!XMLUtil.isDescendant(document, node.getGID(), currentGID))\n                                             //TO UNDERSTAND : what will these GIDs become ? -pb\n                                             newGIDList.add(currentGID);\n                                    }\n                                    previousGID = currentGID;\n                                }\n                            }\n                        }\n                    } catch (EOFException e) {\n                        LOG.warn(\"Could not save index data for value '\" +  ref + \"'\");\n                    } catch (IOException e) {\n                        LOG.error(\"io-error while updating index for value\", e);\n                    }\n                }\n                // append the new list to any existing data\n                gids = currentGIDList.getData();\n                gidsCount = gids.length;\n                //Don't forget this one\n                Arrays.sort(gids);\n                os.writeInt(doc.getDocId());\n                os.writeInt(gidsCount);\n                previousGID = 0;\n                for (int j = 0; j < gidsCount; j++) {\n                    delta = gids[j] - previousGID;                        \n                    os.writeLong(delta);\n                    previousGID = gids[j];\n                }\n                //Store the data\n                if (is == null)\n                    if (db.put(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not put index data for value '\" +  ref + \"'\");\n                    }\n                else {\n                    address = ((BFile.PageInputStream) is).getAddress();\n                    if (db.update(address, ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not update index data for value '\" +  ref + \"'\");\n                    }\n                }\n                \n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);     \n                return;\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n                is = null;\n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(e.getMessage(), e);  \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n            }\n        }\n        pending.clear();\n    }","id":89444,"modified_method":"public void reindex(DocumentImpl document, NodeImpl node) {\n        if (pending.size() == 0) \n            return;        \n        Indexable indexable;\n        LongLinkedList currentGIDList;\n        LongLinkedList newGIDList;\n        long[] gids;        \n        int gidsCount;\n        long currentGID;\n        long previousGID;        \n        long delta;        \n        Value ref;\n        Map.Entry entry;        \n        VariableByteInput is;        \n        int currentDocId;\n        long address;\n        final short collectionId = doc.getCollection().getId();\n        final Lock lock = db.getLock();              \n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            entry = (Map.Entry) i.next();\n            indexable = (Indexable) entry.getKey();\n            currentGIDList = (LongLinkedList) entry.getValue();\n            ref = new Value(indexable.serialize(collectionId, caseSensitive));                \n            // Retrieve old index entry for the element\n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                is = db.getAsStream(ref);\n                os.clear();\n                newGIDList = new LongLinkedList();\n                if (is != null) {                    \n                    try {\n                        while (is.available() > 0) {\n                            currentDocId = is.readInt();\n                            gidsCount = is.readInt();\n                            if (currentDocId != document.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(gidsCount);\n                                os.writeInt(gidsCount);\n                                is.copyTo(os, gidsCount);\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs                                    \n                                previousGID = 0;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    delta = is.readLong();\n                                    currentGID = previousGID + delta;    \n                                    if (node == null) {\n                                        if (document.getTreeLevel(currentGID) < document.reindexRequired())\n                                            currentGIDList.add(currentGID);\n                                    } else {\n                                         if (!XMLUtil.isDescendant(document, node.getGID(), currentGID))\n                                             //TO UNDERSTAND : what will these GIDs become ? -pb\n                                             newGIDList.add(currentGID);\n                                    }\n                                    previousGID = currentGID;\n                                }\n                            }\n                        }\n                    } catch (EOFException e) {\n                        LOG.warn(\"Could not save index data for value '\" +  ref + \"'\");\n                    } catch (IOException e) {\n                        LOG.error(\"io-error while updating index for value\", e);\n                    }\n                }\n                // append the new list to any existing data\n                gids = currentGIDList.getData();\n                gidsCount = gids.length;\n                //Don't forget this one\n                Arrays.sort(gids);\n                os.writeInt(doc.getDocId());\n                os.writeInt(gidsCount);\n                previousGID = 0;\n                for (int j = 0; j < gidsCount; j++) {\n                    delta = gids[j] - previousGID;                        \n                    os.writeLong(delta);\n                    previousGID = gids[j];\n                }\n                //Store the data\n                if (is == null) {\n                    if (db.put(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not put index data for value '\" +  ref + \"'\");\n                    }\n                } else {\n                    address = ((BFile.PageInputStream) is).getAddress();\n                    if (db.update(address, ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not update index data for value '\" +  ref + \"'\");\n                    }\n                }\n                \n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);     \n                return;\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n                is = null;\n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(e.getMessage(), e);  \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n            }\n        }\n        pending.clear();\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Returns a key containing type and collectionId.\n     */\n    private Value getPrefixValue(int type, short collectionId) {\n        byte[] data = new byte[3];\n        ByteConversion.shortToByte(collectionId, data, 0);\n        data[2] = (byte) type;\n        return new Value(data);\n    }","id":89445,"modified_method":"/**\n     * Returns a search key for a collectionId/type combination.\n     */\n    private Value getValuePrefix(int type, short collectionId) {\n        byte[] data = new byte[3];\n        ByteConversion.shortToByte(collectionId, data, 0);\n        data[2] = (byte) type;\n        return new Value(data);\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/** Regular expression search\n\t * @param type  like type argument for {@link RegexMatcher} constructor\n\t * @param flags like flags argument for {@link RegexMatcher} constructor\n\t *  */\n    public NodeSet match(DocumentSet docs, NodeSet contextSet, String expr, int type, int flags, boolean caseSensitiveQuery)\n    throws TerminatedException, EXistException {\n    \t// if the regexp starts with a char sequence, we restrict the index scan to entries starting with\n    \t// the same sequence. Otherwise, we have to scan the whole index.\n        StringValue startTerm = null;\n        if (expr.startsWith(\"^\") && caseSensitiveQuery == caseSensitive) {\n        \tStringBuffer term = new StringBuffer();\n    \t\tfor (int j = 1; j < expr.length(); j++)\n    \t\t\tif (Character.isLetterOrDigit(expr.charAt(j)))\n    \t\t\t\tterm.append(expr.charAt(j));\n    \t\t\telse\n    \t\t\t\tbreak;\n    \t\tif(term.length() > 0) {\n    \t\t\tstartTerm = new StringValue(term.toString());\n    \t\t}\n        }\n        \n\t\tTermMatcher comparator = new RegexMatcher(expr, type, flags);\n        NodeSet result = new ExtArrayNodeSet();\n        RegexCallback callback = new RegexCallback(docs, contextSet, result, comparator);\n        Lock lock = db.getLock();\n        for (Iterator iter = docs.getCollectionIterator(); iter.hasNext();) {\n\t\t\tCollection collection = (Collection) iter.next();\n\t\t\tshort collectionId = collection.getId();\n\t\t\tbyte[] key;\n\t\t\tif(startTerm != null)\n\t\t\t\tkey = startTerm.serialize(collectionId, caseSensitive);\n\t\t\telse {\n\t\t\t\tkey = new byte[3];\n\t\t\t\tByteConversion.shortToByte(collectionId, key, 0);\n\t\t\t\tkey[2] = (byte) Type.STRING;\n\t\t\t}\n\t\t\tIndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, new Value(key));\n\t\t\ttry {\n\t\t\t\tlock.acquire();\n\t\t\t\ttry {\n\t\t\t\t\tdb.query(query, callback);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tLOG.debug(ioe);\n\t\t\t\t} catch (BTreeException bte) {\n\t\t\t\t\tLOG.debug(bte);\n\t\t\t\t}\n\t\t\t} catch (LockException e) {\n\t\t\t\tLOG.debug(e);\n\t\t\t} finally {\n\t\t\t\tlock.release();\n\t\t\t}\n        }\n        return result;\n    }","id":89446,"modified_method":"/** Regular expression search\n\t * @param type  like type argument for {@link RegexMatcher} constructor\n\t * @param flags like flags argument for {@link RegexMatcher} constructor\n\t *  */\n    public NodeSet match(DocumentSet docs, NodeSet contextSet, String expr, int type, int flags, boolean caseSensitiveQuery)\n        throws TerminatedException, EXistException {\n        \n    \t// if the regexp starts with a char sequence, we restrict the index scan to entries starting with\n    \t// the same sequence. Otherwise, we have to scan the whole index.\n        StringValue startTerm = null;\n        if (expr.startsWith(\"^\") && caseSensitiveQuery == caseSensitive) {\n        \tStringBuffer term = new StringBuffer();\n    \t\tfor (int j = 1; j < expr.length(); j++)\n    \t\t\tif (Character.isLetterOrDigit(expr.charAt(j)))\n    \t\t\t\tterm.append(expr.charAt(j));\n    \t\t\telse\n    \t\t\t\tbreak;\n    \t\tif(term.length() > 0) {\n                startTerm = new StringValue(term.toString());\n                LOG.debug(\"Match will begin index scan at '\" + startTerm + \"'\");\n    \t\t}\n        }\n        \n\t\tTermMatcher comparator = new RegexMatcher(expr, type, flags);\n        NodeSet result = new ExtArrayNodeSet();\n        RegexCallback callback = new RegexCallback(docs, contextSet, result, comparator);\n        final Lock lock = db.getLock();\n        for (Iterator iter = docs.getCollectionIterator(); iter.hasNext();) {\n\t\t\tCollection collection = (Collection) iter.next();\n\t\t\tshort collectionId = collection.getId();\n\t\t\tValue value;\n\t\t\tif (startTerm != null) {\n                byte[] key = startTerm.serialize(collectionId, caseSensitive);\n                value = new Value(key);\n            } else {\n                value = getValuePrefix(Type.STRING, collectionId);                \n\t\t\t\t//key = new byte[3];\n\t\t\t\t//ByteConversion.shortToByte(collectionId, key, 0);\n\t\t\t\t//key[2] = (byte) Type.STRING;\n\t\t\t}\n\t\t\tIndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, value);\n\t\t\ttry {\n\t\t\t\tlock.acquire();\n\t\t\t\ttry {\n\t\t\t\t\tdb.query(query, callback);\n\t\t\t\t} catch (IOException e) {\n                    LOG.error(e.getMessage(), e);\n\t\t\t\t} catch (BTreeException e) {\n                    LOG.warn(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t} catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);  \n\t\t\t} finally {\n\t\t\t\tlock.release();\n\t\t\t}\n        }\n        return result;\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/** find\n\t * @param relation binary operator used for the comparison\n\t * @param value right hand comparison value */\n    public NodeSet find(int relation, DocumentSet docs, NodeSet contextSet, Indexable value) \n    throws TerminatedException {\n        int idxOp =  checkRelationOp(relation);\n        NodeSet result = new ExtArrayNodeSet();\n        SearchCallback callback = new SearchCallback(docs, contextSet, result, true);\n        Lock lock = db.getLock();\n        for (Iterator iter = docs.getCollectionIterator(); iter.hasNext();) {\n\t\t\tCollection collection = (Collection) iter.next();\n\t\t\tshort collectionId = collection.getId();\n\t\t\tbyte[] key = value.serialize(collectionId, caseSensitive);\n\t\t\tIndexQuery query = new IndexQuery(idxOp, new Value(key));\n            Value prefix = getPrefixValue(value.getType(), collectionId);\n\t\t\ttry {\n\t\t\t\tlock.acquire();\n\t\t\t\ttry {\n\t\t\t\t\tdb.query(query, prefix, callback);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tLOG.debug(ioe);\n\t\t\t\t} catch (BTreeException bte) {\n\t\t\t\t\tLOG.debug(bte);\n\t\t\t\t}\n\t\t\t} catch (LockException e) {\n\t\t\t\tLOG.debug(e);\n\t\t\t} finally {\n\t\t\t\tlock.release();\n\t\t\t}\n        }\n        return result;\n    }","id":89447,"modified_method":"/** find\n\t * @param relation binary operator used for the comparison\n\t * @param value right hand comparison value */\n    public NodeSet find(int relation, DocumentSet docs, NodeSet contextSet, Indexable value) \n            throws TerminatedException {\n        final int idxOp =  checkRelationOp(relation);\n        final NodeSet result = new ExtArrayNodeSet();\n        final SearchCallback callback = new SearchCallback(docs, contextSet, result, true);\n        final Lock lock = db.getLock();\n        for (Iterator iter = docs.getCollectionIterator(); iter.hasNext();) {\n            Collection collection = (Collection) iter.next();\n            short collectionId = collection.getId();\n            byte[] key = value.serialize(collectionId, caseSensitive);\n\t\t\tIndexQuery query = new IndexQuery(idxOp, new Value(key));\n            Value prefix = getValuePrefix(value.getType(), collectionId);\n\t\t\ttry {\n\t\t\t\tlock.acquire();\n\t\t\t\ttry {\n\t\t\t\t\tdb.query(query, prefix, callback);\n\t\t\t\t} catch (IOException e) {\n                    LOG.error(e.getMessage(), e);\n\t\t\t\t} catch (BTreeException e) {\n                    LOG.warn(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t} catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + db.getFile().getName() + \"'\", e);  \n\t\t\t} finally {\n\t\t\t\tlock.release();\n\t\t\t}\n        }\n        return result;\n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean indexInfo(Value key, long pointer) throws TerminatedException {\n            AtomicValue atomic;\n            try {\n                atomic = ValueIndexFactory.deserialize(key.data(), key.start(), key.getLength());\n                if (atomic.getType() != type)\n                    return false;\n            } catch (EXistException e) {\n                LOG.warn(e.getMessage(), e);\n                return true;\n            }\n            ValueOccurrences oc = (ValueOccurrences) map.get(atomic);\n            \n            VariableByteInput is = null;\n            try {\n                is = db.getAsStream(pointer);\n            } catch (IOException ioe) {\n                LOG.warn(ioe.getMessage(), ioe);\n            }\n            if (is == null)\n                return true;\n            try {\n                int docId;\n                int len;\n                long gid;\n                DocumentImpl doc;\n                boolean include = true;\n                boolean docAdded;\n                while (is.available() > 0) {\n                    docId = is.readInt();\n                    len = is.readInt();\n                    if ((doc = docs.getDoc(docId)) == null) {\n                        is.skip(len);\n                        continue;\n                    }\n                    docAdded = false;\n                    gid = 0;\n                    for (int j = 0; j < len; j++) {\n                        gid += is.readLong();\n                        if (contextSet != null) {\n                            include = contextSet.parentWithChild(doc, gid, false, true) != null;\n                        }\n                        if (include) {\n                            if (oc == null) {\n                                oc = new ValueOccurrences(atomic);\n                                map.put(atomic, oc);\n                            }\n                            if (!docAdded) {\n                                oc.addDocument(doc);\n                                docAdded = true;\n                            }\n                            oc.addOccurrences(1);\n                        }\n                    }\n                }\n            } catch(EOFException e) {\n                LOG.warn(e.getMessage(), e);\n            } catch(IOException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n            return true;\n        }","id":89448,"modified_method":"public boolean indexInfo(Value key, long pointer) throws TerminatedException {\n            \n            AtomicValue atomic;\n            try {\n                atomic = ValueIndexFactory.deserialize(key.data(), key.start(), key.getLength());\n                if (atomic.getType() != type)\n                    return false;\n            } catch (EXistException e) {\n                LOG.warn(e.getMessage(), e);\n                return true;\n            }\n            \n            VariableByteInput is = null;\n            try {\n                is = db.getAsStream(pointer);\n            } catch (IOException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n            if (is == null)\n                return true;\n            \n            int currentDocId;\n            int gidsCount;\n            long currentGID; \n            long delta;       \n            DocumentImpl currentDocument;                \n            boolean docAdded;\n            ValueOccurrences oc = (ValueOccurrences) map.get(atomic);\n            try {\n                while (is.available() > 0) {\n                    currentDocId = is.readInt();\n                    gidsCount = is.readInt();\n                    currentDocument = docs.getDoc(currentDocId);                    \n                    if (currentDocument == null) {\n                        is.skip(gidsCount);\n                        continue;\n                    }\n                    docAdded = false;\n                    currentGID = 0;                    \n                    for (int j = 0; j < gidsCount; j++) {\n                        delta = is.readLong();\n                        currentGID = currentGID + delta;\n                        //TODO : what if contextSet == null ? -pb\n                        //See above where we have this behaviour :\n                        //otherwise, we add all nodes without check\n                        if (contextSet != null) {\n                            if (contextSet.parentWithChild(currentDocument, currentGID, false, true) != null) {\n                                if (oc == null) {\n                                    oc = new ValueOccurrences(atomic);\n                                    map.put(atomic, oc);\n                                }\n                                if (!docAdded) {\n                                    oc.addDocument(currentDocument);\n                                    docAdded = true;\n                                }\n                                oc.addOccurrences(1);\n                            }\n                        }\n                    }\n                }\n            } catch(EOFException e) {\n                LOG.warn(e.getMessage(), e);\n            } catch(IOException e) {\n                LOG.warn(e.getMessage(), e);\n            }\n            return true;\n        }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @param xpathType\n     * @param value\n     * @return <code>null<\/null> if atomization fails or if the atomic value is not indexable.\n     * Should we throw an exception instead ? -pb\n     */\n    private AtomicValue convertToAtomic(int xpathType, String value) {\n        AtomicValue atomic = null;\n        if(Type.subTypeOf(xpathType, Type.STRING)) {\n            atomic = new StringValue(value);\n        } else {\n            try {\n                atomic = new StringValue(value).convertTo(xpathType);\n            } catch (XPathException e) {\n                LOG.warn(\"Node value: '\" + value + \"' cannot be converted to type \" + \n                        Type.getTypeName(xpathType));\n            }\n        }\n        if(!(atomic instanceof Indexable)) {\n            LOG.warn(\"The specified type: '\" + Type.getTypeName(xpathType) +\n            \t\t\"' and value '\" + value + \"'\" +\n                    \" cannot be used as index key. It is null or does not implement interface Indexable.\");\n            atomic = null;\n        }\n        return atomic;        \n    }","id":89449,"modified_method":"/**\n     * @param xpathType\n     * @param value\n     * @return <code>null<\/null> if atomization fails or if the atomic value is not indexable.\n     * Should we throw an exception instead ? -pb\n     */\n    private AtomicValue convertToAtomic(int xpathType, String value) {\n        AtomicValue atomic = null;\n        if (Type.subTypeOf(xpathType, Type.STRING)) {\n            atomic = new StringValue(value);\n        } else {\n            try {\n                atomic = new StringValue(value).convertTo(xpathType);\n            } catch (XPathException e) {\n                LOG.warn(\"Node value '\" + value + \"' cannot be converted to \" + \n                        Type.getTypeName(xpathType));\n                return null;\n            }\n        }\n        if (atomic == null) {\n            LOG.warn(\"Node value '\" + Type.getTypeName(xpathType) + \"(\" + value + \")'\" +\n            \" cannot be used as index key. It is null.\");\n            return null;\n        }            \n        if (!(atomic instanceof Indexable)) {\n            LOG.warn(\"Node value '\" + Type.getTypeName(xpathType) + \"(\" + value + \")'\" +\n            \" cannot be used as index key. It does not implement \" + Indexable.class.getName());\n            return null;\n        }\n        return atomic;        \n    }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean indexInfo(Value value, long pointer)\n                throws TerminatedException {\n            VariableByteInput is = null;\n\t\t\ttry {\n\t\t\t\tis = db.getAsStream(pointer);\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tLOG.warn(ioe.getMessage(), ioe);\n\t\t\t}\n\t\t\tif (is == null)\n\t\t\t\treturn true;\n\t\t\ttry {\n                int sizeHint = -1;\n                while (is.available() > 0) {\n                \tint docId = is.readInt();\n                \tint len = is.readInt();\n                \tif ((doc = docs.getDoc(docId)) == null\n                \t\t\t|| (contextSet != null && !contextSet.containsDoc(doc))) {\n                \t\tis.skip(len);\n                \t\tcontinue;\n                \t}\n                \tif (contextSet != null)\n                \t\tsizeHint = contextSet.getSizeHint(doc);\n                \tlong gid = 0;\n                \tNodeProxy current, parent;\n                \tfor (int j = 0; j < len; j++) {\n                \t\tgid = gid + is.readLong();\n\t\t\t\t\t\t\n                \t\tcurrent = new NodeProxy(doc, gid);\n\t\t\t\t\t\t\n                \t\t// if a context set is specified, we can directly check if the\n                \t\t// matching node is a descendant of one of the nodes\n                \t\t// in the context set.\n                \t\tif (contextSet != null) {\n                \t\t\tparent = contextSet.parentWithChild(current, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n                \t\t\tif (parent != null) {\n                \t\t\t\tresult.add(returnAncestor ? parent : current, sizeHint);\n                \t\t\t}\n                \t\t// otherwise, we add all nodes without check\n                \t\t} else {\n                \t\t\tresult.add(current, sizeHint);\n                \t\t}\n                \t}\n                }\n\t\t\t} catch (EOFException e) {\n\t\t\t    // EOF is expected here\n            } catch (IOException e) {\n                LOG.warn(\"io error while reading index\", e);\n            }\n            return false;\n        }","id":89450,"modified_method":"public boolean indexInfo(Value value, long pointer) throws TerminatedException {\n            VariableByteInput is = null;\n\t\t\ttry {\n\t\t\t\tis = db.getAsStream(pointer);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.warn(e.getMessage(), e);\n\t\t\t}            \n\t\t\tif (is == null)\n\t\t\t\treturn true;\n            \n            int currentDocId;            \n            int gidsCount;\n            long currentGID;\n            long delta;  \n            DocumentImpl currentDocument;        \n            NodeProxy currentNode, parentNode;            \n\t\t\ttry {\n                int sizeHint = -1;\n                while (is.available() > 0) {\n                    currentDocId = is.readInt();\n                \tgidsCount = is.readInt();\n                    currentDocument = docs.getDoc(currentDocId);                    \n                \tif (currentDocument == null) {\n                        is.skip(gidsCount);\n                        continue;                        \n                    }                    \n                    \n                \tif (contextSet != null) { \n                \t    if (!contextSet.containsDoc(doc)) {\n                \t        is.skip(gidsCount);\n                \t        continue;\n                        }\n                        sizeHint = contextSet.getSizeHint(doc);\n                \t}\n\n                    currentGID = 0;                \t\n                \tfor (int j = 0; j < gidsCount; j++) {\n                        delta = is.readLong();\n                        currentGID = currentGID + delta;\n                        \n                        currentNode = new NodeProxy(doc, currentGID);\t\t\t\t\t\t\n                \t\t// if a context set is specified, we can directly check if the\n                \t\t// matching node is a descendant of one of the nodes\n                \t\t// in the context set.\n                \t\tif (contextSet != null) {\n                            if (returnAncestor) {\n                                parentNode = contextSet.parentWithChild(currentNode, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n                                if (parentNode != null) \n                                    result.add(parentNode, sizeHint);\n                \t\t\t} else\n                                result.add(currentNode, sizeHint);\n                \t\t// otherwise, we add all nodes without check\n                \t\t} else {\n                \t\t\tresult.add(currentNode, sizeHint);\n                \t\t}\n                \t}\n                }\n\t\t\t} catch (EOFException e) {\n\t\t\t    // EOF is expected here\n            } catch (IOException e) {                \n                LOG.warn(e.getMessage(), e);\n            }\n            return false;\n        }","commit_id":"085e38e4871e810c1af3ca10964fac6deb0c134b","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\n        Permanent EyeOfTheStorm = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        Player controller = game.getPlayer(source.getControllerId());\n\n        if (controller != null && spell != null && EyeOfTheStorm != null) {\n            Card card = spell.getCard();\n            if (card == null || !instantOrSorceryfilter.match(card, game)) {\n                return false;\n            }\n\n            UUID exileZoneId = CardUtil.getExileZoneId(game, source.getSourceId(), EyeOfTheStorm.getZoneChangeCounter(game));\n            if (controller.moveCardsToExile(spell, source, game, true, exileZoneId, EyeOfTheStorm.getIdName())) {\n                EyeOfTheStorm.imprint(card.getId(), game);\n\n                if (EyeOfTheStorm != null && EyeOfTheStorm.getImprinted() != null && EyeOfTheStorm.getImprinted().size() > 0 && controller != null) {\n                    CardsImpl copiedCards = new CardsImpl();\n                    for (UUID uuid : EyeOfTheStorm.getImprinted()) {\n                        card = game.getCard(uuid);\n\n                        // Check if owner of card is still in game\n                        if (card != null && game.getPlayer(card.getOwnerId()) != null) {\n                            if (card.isSplitCard()) {\n                                copiedCards.add(((SplitCard) card).getLeftHalfCard());\n                                copiedCards.add(((SplitCard) card).getRightHalfCard());\n                            } else {\n                                copiedCards.add(card);\n                            }\n                        }\n                    }\n\n                    boolean continueCasting = true;\n                    while (continueCasting) {\n                        continueCasting = copiedCards.size() > 1 && controller.chooseUse(outcome, \"Cast one of the copied cards without paying its mana cost?\", source, game);\n\n                        Card cardToCopy;\n                        if (copiedCards.size() == 1) {\n                            cardToCopy = copiedCards.getCards(game).iterator().next();\n                        } else {\n                            TargetCard target = new TargetCard(1, Zone.EXILED, new FilterCard(\"card to copy\"));\n                            controller.choose(Outcome.Copy, copiedCards, target, game);\n                            cardToCopy = copiedCards.get(target.getFirstTarget(), game);\n                            copiedCards.remove(cardToCopy);\n                        }\n                        if (cardToCopy != null) {\n                            Card copy = game.copyCard(cardToCopy, source, source.getControllerId());\n                            if (controller.chooseUse(outcome, \"Cast the copied card without paying mana cost?\", source, game)) {\n                                controller.cast(copy.getSpellAbility(), game, true);\n                            }\n                        }\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":89451,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\n        Permanent eyeOfTheStorm = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        if (spell != null && eyeOfTheStorm != null) {\n            Player spellController = game.getPlayer(spell.getControllerId());\n            Card card = spell.getCard();\n            if (spellController == null || card == null || !instantOrSorceryfilter.match(card, game)) {\n                return false;\n            }\n\n            UUID exileZoneId = CardUtil.getExileZoneId(game, source.getSourceId(), eyeOfTheStorm.getZoneChangeCounter(game));\n            if (spellController.moveCardsToExile(spell, source, game, true, exileZoneId, eyeOfTheStorm.getIdName())) {\n                eyeOfTheStorm.imprint(card.getId(), game);\n\n                if (eyeOfTheStorm.getImprinted() != null && eyeOfTheStorm.getImprinted().size() > 0) {\n                    CardsImpl copiedCards = new CardsImpl();\n                    for (UUID uuid : eyeOfTheStorm.getImprinted()) {\n                        card = game.getCard(uuid);\n\n                        // Check if owner of card is still in game\n                        if (card != null && game.getPlayer(card.getOwnerId()) != null) {\n                            if (card.isSplitCard()) {\n                                copiedCards.add(((SplitCard) card).getLeftHalfCard());\n                                copiedCards.add(((SplitCard) card).getRightHalfCard());\n                            } else {\n                                copiedCards.add(card);\n                            }\n                        }\n                    }\n\n                    boolean continueCasting = true;\n                    while (continueCasting) {\n                        continueCasting = copiedCards.size() > 1 && spellController.chooseUse(outcome, \"Cast one of the copied cards without paying its mana cost?\", source, game);\n\n                        Card cardToCopy;\n                        if (copiedCards.size() == 1) {\n                            cardToCopy = copiedCards.getCards(game).iterator().next();\n                        } else {\n                            TargetCard target = new TargetCard(1, Zone.EXILED, new FilterCard(\"card to copy\"));\n                            spellController.choose(Outcome.Copy, copiedCards, target, game);\n                            cardToCopy = copiedCards.get(target.getFirstTarget(), game);\n                            copiedCards.remove(cardToCopy);\n                        }\n                        if (cardToCopy != null) {\n                            Card copy = game.copyCard(cardToCopy, source, source.getControllerId());\n                            if (spellController.chooseUse(outcome, \"Cast the copied card without paying mana cost?\", source, game)) {\n                                spellController.cast(copy.getSpellAbility(), game, true);\n                            }\n                        }\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"c84180b0f778c2da08eac9538e1359a45e2ec128","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (event.getZone() == Zone.HAND) {\n            Spell spell = game.getStack().getSpell(event.getTargetId());\n            if (spell != null && (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY))) {\n                for (Effect effect : this.getEffects()) {\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":89452,"modified_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (event.getZone() == Zone.HAND) {\n            Spell spell = game.getStack().getSpell(event.getTargetId());\n            if (spell != null && !spell.isCopy()\n                    && (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY))) {\n                for (Effect effect : this.getEffects()) {\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"c84180b0f778c2da08eac9538e1359a45e2ec128","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        if (sourcePermanent != null && controller != null && controller.getLibrary().size() > 0) {\n            Library library = controller.getLibrary();\n            Card card = library.removeFromTop(game);\n            if (card != null) {\n                String exileName = new StringBuilder(sourcePermanent.getIdName()).append(\" <this card may be played the turn it was exiled>\").toString();\n                controller.moveCardToExileWithInfo(card, source.getSourceId(), exileName, source.getSourceId(), game, Zone.LIBRARY, true);\n                ContinuousEffect effect = new StromkirkOccultistPlayFromExileEffect();\n                effect.setTargetPointer(new FixedTarget(card.getId()));\n                game.addEffect(effect, source);\n            }\n            return true;\n        }\n        return false;\n    }","id":89453,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        if (sourcePermanent != null && controller != null && controller.getLibrary().size() > 0) {\n            Card card = controller.getLibrary().getFromTop(game);\n            if (card != null) {\n                String exileName = new StringBuilder(sourcePermanent.getIdName()).append(\" <this card may be played the turn it was exiled>\").toString();\n                if (controller.moveCardToExileWithInfo(card, source.getSourceId(), exileName, source.getSourceId(), game, Zone.LIBRARY, true)) {\n                    ContinuousEffect effect = new StromkirkOccultistPlayFromExileEffect();\n                    effect.setTargetPointer(new FixedTarget(card.getId()));\n                    game.addEffect(effect, source);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"c84180b0f778c2da08eac9538e1359a45e2ec128","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            if (permanent != null) {\n                Zone currentZone = game.getState().getZone(permanent.getId());\n                if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(Zone.BATTLEFIELD))) {\n                    return controller.moveCardToExileWithInfo(permanent, exileId, exileZone, source.getSourceId(), game, onlyFromZone);\n                }\n            } else {\n                Card card = game.getCard(targetPointer.getFirst(game, source));                \n                if (card != null) {\n                    Zone currentZone = game.getState().getZone(card.getId());\n                    if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(currentZone))) {\n                        return controller.moveCardToExileWithInfo(card, exileId, exileZone, source.getSourceId(), game, onlyFromZone);\n                    }\n                }\n            }\n        }\n        return false;\n    }","id":89454,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            for (UUID targetId : getTargetPointer().getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(targetId);\n                if (permanent != null) {\n                    Zone currentZone = game.getState().getZone(permanent.getId());\n                    if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(Zone.BATTLEFIELD))) {\n                        controller.moveCardToExileWithInfo(permanent, exileId, exileZone, source.getSourceId(), game, currentZone);\n                    }\n                } else {\n                    Card card = game.getCard(targetId);\n                    if (card != null) {\n                        Zone currentZone = game.getState().getZone(card.getId());\n                        if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(currentZone))) {\n                            controller.moveCardToExileWithInfo(card, exileId, exileZone, source.getSourceId(), game, currentZone);\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"c077a17d86a5b30cd740e3aa515e04363a5fd599","url":"https://github.com/magefree/mage"},{"original_method":"public Skullsnatcher(UUID ownerId) {\r\n        super(ownerId, 84, \"Skullsnatcher\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}\");\r\n        this.expansionSetCode = \"BOK\";\r\n        this.subtype.add(\"Rat\");\r\n        this.subtype.add(\"Ninja\");\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Ninjutsu {B} ({B}, Return an unblocked attacker you control to hand: Put this card onto the battlefield from your hand tapped and attacking.)\r\n        this.addAbility(new NinjutsuAbility(new ManaCostsImpl(\"{B\")));\r\n        \r\n        // Whenever Skullsnatcher deals combat damage to a player, exile up to two target cards from that player's graveyard.\r\n        this.addAbility(new SkullsnatcherTriggeredAbility());\r\n    }","id":89455,"modified_method":"public Skullsnatcher(UUID ownerId) {\r\n        super(ownerId, 84, \"Skullsnatcher\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}\");\r\n        this.expansionSetCode = \"BOK\";\r\n        this.subtype.add(\"Rat\");\r\n        this.subtype.add(\"Ninja\");\r\n        this.color.setBlack(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Ninjutsu {B} ({B}, Return an unblocked attacker you control to hand: Put this card onto the battlefield from your hand tapped and attacking.)\r\n        this.addAbility(new NinjutsuAbility(new ManaCostsImpl(\"{B\")));\r\n        \r\n        // Whenever Skullsnatcher deals combat damage to a player, exile up to two target cards from that player's graveyard.\r\n        Effect effect = new ExileTargetEffect(null, \"\", Zone.GRAVEYARD);\r\n        effect.setText(\"exile up to two target cards from that player's graveyard\");\r\n        this.addAbility(new SkullsnatcherTriggeredAbility(effect));\r\n    }","commit_id":"c077a17d86a5b30cd740e3aa515e04363a5fd599","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public SkullsnatcherTriggeredAbility copy() {\r\n        return new SkullsnatcherTriggeredAbility(this);\r\n    }","id":89456,"modified_method":"SkullsnatcherTriggeredAbility(Effect effect) {\r\n        super(Zone.BATTLEFIELD, effect, false);\r\n    }","commit_id":"c077a17d86a5b30cd740e3aa515e04363a5fd599","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public String getRule() {\r\n        return \"Whenever {this} deals combat damage to a player, exile up to two target cards from that player's graveyard.\";\r\n    }","id":89457,"modified_method":"@Override\r\n    public String getRule() {\r\n        return \"Whenever {this} deals combat damage to a player, \" + super.getRule();\r\n   }","commit_id":"c077a17d86a5b30cd740e3aa515e04363a5fd599","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean canTarget(UUID id, Ability source, Game game) {\r\n        Card card = game.getCard(id);\r\n        if (card != null && game.getState().getZone(card.getId()) == Zone.GRAVEYARD) {\r\n            if (game.getPlayer(source.getControllerId()).hasOpponent(card.getOwnerId(), game)) {\r\n                if (allFromOneOpponent && !targets.isEmpty()) {\r\n                    Card firstCard = game.getCard((UUID)targets.keySet().iterator().next());\r\n                    if (firstCard != null && !card.getOwnerId().equals(firstCard.getOwnerId())) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return filter.match(card, game);\r\n            }\r\n        }\r\n        return false;\r\n    }","id":89458,"modified_method":"@Override\r\n    public boolean canTarget(UUID id, Ability source, Game game) {\r\n        Card card = game.getCard(id);\r\n        if (card != null && game.getState().getZone(card.getId()) == Zone.GRAVEYARD) {\r\n            if (game.getPlayer(source.getControllerId()).hasOpponent(card.getOwnerId(), game)) {\r\n                if (allFromOneOpponent && !targets.isEmpty()) {\r\n                    Card firstCard = game.getCard(targets.keySet().iterator().next());\r\n                    if (firstCard != null && !card.getOwnerId().equals(firstCard.getOwnerId())) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return filter.match(card, game);\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"c077a17d86a5b30cd740e3aa515e04363a5fd599","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Builds universal EJB meta data model that is AS agnostic.\n     *\n     * @param dep\n     *            webservice deployment\n     * @return universal EJB meta data model\n     */\n    final EJBArchiveMetaData create(final Deployment dep) {\n        WSLogger.ROOT_LOGGER.tracef(\"Building JBoss agnostic meta data for EJB webservice deployment: %s\", dep.getSimpleName());\n        final EJBArchiveMetaData.Builder ejbArchiveMDBuilder = new EJBArchiveMetaData.Builder();\n\n        this.buildEnterpriseBeansMetaData(dep, ejbArchiveMDBuilder);\n        this.buildWebservicesMetaData(dep, ejbArchiveMDBuilder);\n\n        return ejbArchiveMDBuilder.build();\n    }","id":89459,"modified_method":"/**\n     * Builds universal EJB meta data model that is AS agnostic.\n     *\n     * @param dep\n     *            webservice deployment\n     * @return universal EJB meta data model\n     */\n    final EJBArchiveMetaData create(final Deployment dep) {\n        if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n            WSLogger.ROOT_LOGGER.tracef(\"Building JBoss agnostic meta data for EJB webservice deployment: %s\", dep.getSimpleName());\n        }\n        final EJBArchiveMetaData.Builder ejbArchiveMDBuilder = new EJBArchiveMetaData.Builder();\n\n        this.buildEnterpriseBeansMetaData(dep, ejbArchiveMDBuilder);\n        this.buildWebservicesMetaData(dep, ejbArchiveMDBuilder);\n\n        return ejbArchiveMDBuilder.build();\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Builds universal JSE meta data model that is AS agnostic.\n     *\n     * @param dep webservice deployment\n     * @return universal JSE meta data model\n     */\n    JSEArchiveMetaData create(final Deployment dep) {\n        WSLogger.ROOT_LOGGER.tracef(\"Creating JBoss agnostic meta data for POJO webservice deployment: %s\", dep.getSimpleName());\n        final JBossWebMetaData jbossWebMD = WSHelper.getRequiredAttachment(dep, JBossWebMetaData.class);\n        final DeploymentUnit unit = WSHelper.getRequiredAttachment(dep, DeploymentUnit.class);\n        final List<POJOEndpoint> pojoEndpoints = getPojoEndpoints(unit);\n        final JSEArchiveMetaData.Builder builder = new JSEArchiveMetaData.Builder();\n\n        // set context root\n        final String contextRoot = getContextRoot(dep, jbossWebMD);\n        builder.setContextRoot(contextRoot);\n        WSLogger.ROOT_LOGGER.tracef(\"Setting context root: %s\", contextRoot);\n\n        // set servlet url patterns mappings\n        final Map<String, String> servletMappings = getServletUrlPatternsMappings(jbossWebMD, pojoEndpoints);\n        builder.setServletMappings(servletMappings);\n\n        // set servlet class names mappings\n        final Map<String, String> servletClassNamesMappings = getServletClassMappings(jbossWebMD, pojoEndpoints);\n        builder.setServletClassNames(servletClassNamesMappings);\n\n        // set security domain\n        final String securityDomain = jbossWebMD.getSecurityDomain();\n        builder.setSecurityDomain(securityDomain);\n\n        // set wsdl location resolver\n        final JBossWebservicesMetaData jbossWebservicesMD = WSHelper.getOptionalAttachment(dep, JBossWebservicesMetaData.class);\n        if (jbossWebservicesMD != null) {\n            final PublishLocationAdapter resolver = new PublishLocationAdapterImpl(jbossWebservicesMD.getWebserviceDescriptions());\n            builder.setPublishLocationAdapter(resolver);\n        }\n\n        // set security meta data\n        final List<JSESecurityMetaData> jseSecurityMDs = getSecurityMetaData(jbossWebMD.getSecurityConstraints());\n        builder.setSecurityMetaData(jseSecurityMDs);\n\n        // set config name and file\n        setConfigNameAndFile(builder, jbossWebMD, jbossWebservicesMD);\n\n        return builder.build();\n    }","id":89460,"modified_method":"/**\n     * Builds universal JSE meta data model that is AS agnostic.\n     *\n     * @param dep webservice deployment\n     * @return universal JSE meta data model\n     */\n    JSEArchiveMetaData create(final Deployment dep) {\n        if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n            WSLogger.ROOT_LOGGER.tracef(\"Creating JBoss agnostic meta data for POJO webservice deployment: %s\", dep.getSimpleName());\n        }\n        final JBossWebMetaData jbossWebMD = WSHelper.getRequiredAttachment(dep, JBossWebMetaData.class);\n        final DeploymentUnit unit = WSHelper.getRequiredAttachment(dep, DeploymentUnit.class);\n        final List<POJOEndpoint> pojoEndpoints = getPojoEndpoints(unit);\n        final JSEArchiveMetaData.Builder builder = new JSEArchiveMetaData.Builder();\n\n        // set context root\n        final String contextRoot = getContextRoot(dep, jbossWebMD);\n        builder.setContextRoot(contextRoot);\n        WSLogger.ROOT_LOGGER.tracef(\"Setting context root: %s\", contextRoot);\n\n        // set servlet url patterns mappings\n        final Map<String, String> servletMappings = getServletUrlPatternsMappings(jbossWebMD, pojoEndpoints);\n        builder.setServletMappings(servletMappings);\n\n        // set servlet class names mappings\n        final Map<String, String> servletClassNamesMappings = getServletClassMappings(jbossWebMD, pojoEndpoints);\n        builder.setServletClassNames(servletClassNamesMappings);\n\n        // set security domain\n        final String securityDomain = jbossWebMD.getSecurityDomain();\n        builder.setSecurityDomain(securityDomain);\n\n        // set wsdl location resolver\n        final JBossWebservicesMetaData jbossWebservicesMD = WSHelper.getOptionalAttachment(dep, JBossWebservicesMetaData.class);\n        if (jbossWebservicesMD != null) {\n            final PublishLocationAdapter resolver = new PublishLocationAdapterImpl(jbossWebservicesMD.getWebserviceDescriptions());\n            builder.setPublishLocationAdapter(resolver);\n        }\n\n        // set security meta data\n        final List<JSESecurityMetaData> jseSecurityMDs = getSecurityMetaData(jbossWebMD.getSecurityConstraints());\n        builder.setSecurityMetaData(jseSecurityMDs);\n\n        // set config name and file\n        setConfigNameAndFile(builder, jbossWebMD, jbossWebservicesMD);\n\n        return builder.build();\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(final Deployment dep) {\n        if (WSHelper.isJaxwsJseDeployment(dep)) {\n            if (WSHelper.hasAttachment(dep, JBossWebMetaData.class)) {\n                WSLogger.ROOT_LOGGER.tracef(\"Creating JBoss agnostic JAXWS POJO meta data for deployment: %s\", dep.getSimpleName());\n                final JSEArchiveMetaData jseMetaData = jaxwsPojoMDBuilder.create(dep);\n                dep.addAttachment(JSEArchiveMetaData.class, jseMetaData);\n            }\n        }\n        if (WSHelper.isJaxwsEjbDeployment(dep)) {\n            WSLogger.ROOT_LOGGER.tracef(\"Creating JBoss agnostic JAXWS EJB meta data for deployment: %s\", dep.getSimpleName());\n            final EJBArchiveMetaData ejbMetaData = jaxwsEjbMDBuilder.create(dep);\n            dep.addAttachment(EJBArchiveMetaData.class, ejbMetaData);\n        }\n    }","id":89461,"modified_method":"@Override\n    public void start(final Deployment dep) {\n        if (WSHelper.isJaxwsJseDeployment(dep)) {\n            if (WSHelper.hasAttachment(dep, JBossWebMetaData.class)) {\n                if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n                    WSLogger.ROOT_LOGGER.tracef(\"Creating JBoss agnostic JAXWS POJO meta data for deployment: %s\", dep.getSimpleName());\n                }\n                final JSEArchiveMetaData jseMetaData = jaxwsPojoMDBuilder.create(dep);\n                dep.addAttachment(JSEArchiveMetaData.class, jseMetaData);\n            }\n        }\n        if (WSHelper.isJaxwsEjbDeployment(dep)) {\n            if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n                WSLogger.ROOT_LOGGER.tracef(\"Creating JBoss agnostic JAXWS EJB meta data for deployment: %s\", dep.getSimpleName());\n            }\n            final EJBArchiveMetaData ejbMetaData = jaxwsEjbMDBuilder.create(dep);\n            dep.addAttachment(EJBArchiveMetaData.class, ejbMetaData);\n        }\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"private UnifiedVirtualFile findChild(String child, boolean throwExceptionIfNotFound) throws IOException {\n        final VirtualFile virtualFile = getFile();\n        final VirtualFile childFile = file.getChild(child);\n        if (!childFile.exists()) {\n            if (throwExceptionIfNotFound) {\n                throw WSLogger.ROOT_LOGGER.missingChild(child, virtualFile);\n            } else {\n                if (WSLogger.ROOT_LOGGER.isTraceEnabled()) WSLogger.ROOT_LOGGER.tracef(\"Child '%s' not found for VirtualFile: %s\", child, virtualFile);\n                return null;\n            }\n        }\n        return new VirtualFileAdaptor(childFile);\n    }","id":89462,"modified_method":"private UnifiedVirtualFile findChild(String child, boolean throwExceptionIfNotFound) throws IOException {\n        final VirtualFile virtualFile = getFile();\n        final VirtualFile childFile = file.getChild(child);\n        if (!childFile.exists()) {\n            if (throwExceptionIfNotFound) {\n                throw WSLogger.ROOT_LOGGER.missingChild(child, virtualFile);\n            } else {\n                WSLogger.ROOT_LOGGER.tracef(\"Child '%s' not found for VirtualFile: %s\", child, virtualFile);\n                return null;\n            }\n        }\n        return new VirtualFileAdaptor(childFile);\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void verifyEndpoint(final AbstractEndpoint pojoEndpoint, final ClassLoader moduleClassLoader,\n            final DeploymentReflectionIndex deploymentReflectionIndex) throws DeploymentUnitProcessingException {\n        WSLogger.ROOT_LOGGER.tracef(\"Verifying web service endpoint class %s\", pojoEndpoint.getClassName());\n        try {\n            final Class<?> endpointClass = moduleClassLoader.loadClass(pojoEndpoint.getClassName());\n            final WebService webServiceAnnotation = endpointClass.getAnnotation(WebService.class);\n            if (webServiceAnnotation != null) {\n                verifyJwsEndpoint(endpointClass, webServiceAnnotation, moduleClassLoader, deploymentReflectionIndex);\n            } // otherwise it's probably a javax.xml.ws.Provider implementation\n        } catch (ClassNotFoundException e) {\n            throw WSLogger.ROOT_LOGGER.endpointClassNotFound(pojoEndpoint.getClassName());\n        }\n    }","id":89463,"modified_method":"private void verifyEndpoint(final AbstractEndpoint pojoEndpoint, final ClassLoader moduleClassLoader,\n            final DeploymentReflectionIndex deploymentReflectionIndex) throws DeploymentUnitProcessingException {\n        if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n            WSLogger.ROOT_LOGGER.tracef(\"Verifying web service endpoint class %s\", pojoEndpoint.getClassName());\n        }\n        try {\n            final Class<?> endpointClass = moduleClassLoader.loadClass(pojoEndpoint.getClassName());\n            final WebService webServiceAnnotation = endpointClass.getAnnotation(WebService.class);\n            if (webServiceAnnotation != null) {\n                verifyJwsEndpoint(endpointClass, webServiceAnnotation, moduleClassLoader, deploymentReflectionIndex);\n            } // otherwise it's probably a javax.xml.ws.Provider implementation\n        } catch (ClassNotFoundException e) {\n            throw WSLogger.ROOT_LOGGER.endpointClassNotFound(pojoEndpoint.getClassName());\n        }\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void addDeploymentProcessors(final DeploymentProcessorTarget processorTarget, final Phase phase, final int priority) {\n        int index = 1;\n        List<DeploymentAspect> aspects = DeploymentAspectsProvider.getSortedDeploymentAspects();\n        for (final DeploymentAspect da : aspects) {\n            WSLogger.ROOT_LOGGER.tracef(\"Installing aspect %s\", da.getClass().getName());\n            processorTarget.addDeploymentProcessor(WSExtension.SUBSYSTEM_NAME, phase, priority + index++, new AspectDeploymentProcessor(da));\n        }\n    }","id":89464,"modified_method":"private static void addDeploymentProcessors(final DeploymentProcessorTarget processorTarget, final Phase phase, final int priority) {\n        int index = 1;\n        List<DeploymentAspect> aspects = DeploymentAspectsProvider.getSortedDeploymentAspects();\n        for (final DeploymentAspect da : aspects) {\n            if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n                WSLogger.ROOT_LOGGER.tracef(\"Installing aspect %s\", da.getClass().getName());\n            }\n            processorTarget.addDeploymentProcessor(WSExtension.SUBSYSTEM_NAME, phase, priority + index++, new AspectDeploymentProcessor(da));\n        }\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(final Deployment dep) {\n        if (isEjbDeployment(dep)) {\n            WSLogger.ROOT_LOGGER.tracef(\"Creating web meta data for EJB webservice deployment: %s\", dep.getSimpleName());\n           webMetaDataCreator.create(dep);\n        }\n    }","id":89465,"modified_method":"@Override\n    public void start(final Deployment dep) {\n        if (isEjbDeployment(dep)) {\n            if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n                WSLogger.ROOT_LOGGER.tracef(\"Creating web meta data for EJB webservice deployment: %s\", dep.getSimpleName());\n            }\n            webMetaDataCreator.create(dep);\n        }\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Modifies context root.\n     *\n     * @param dep webservice deployment\n     * @param jbossWebMD web meta data\n     */\n    private void modifyContextRoot(final Deployment dep, final JBossWebMetaData jbossWebMD) {\n        final String contextRoot = dep.getService().getContextRoot();\n        WSLogger.ROOT_LOGGER.tracef(\"Setting context root: %s for deployment: %s\", contextRoot, dep.getSimpleName());\n        jbossWebMD.setContextRoot(contextRoot);\n    }","id":89466,"modified_method":"/**\n     * Modifies context root.\n     *\n     * @param dep webservice deployment\n     * @param jbossWebMD web meta data\n     */\n    private void modifyContextRoot(final Deployment dep, final JBossWebMetaData jbossWebMD) {\n        final String contextRoot = dep.getService().getContextRoot();\n        if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n            WSLogger.ROOT_LOGGER.tracef(\"Setting context root: %s for deployment: %s\", contextRoot, dep.getSimpleName());\n        }\n        jbossWebMD.setContextRoot(contextRoot);\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(final Deployment dep) {\n        WSLogger.ROOT_LOGGER.tracef(\"Modifying web meta data for webservice deployment: %s\", dep.getSimpleName());\n        webMetaDataModifier.modify(dep);\n    }","id":89467,"modified_method":"@Override\n    public void start(final Deployment dep) {\n        if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {\n            WSLogger.ROOT_LOGGER.tracef(\"Modifying web meta data for webservice deployment: %s\", dep.getSimpleName());\n        }\n        webMetaDataModifier.modify(dep);\n    }","commit_id":"1ba5ff502e921af267250638ef968cf6d4798032","url":"https://github.com/wildfly/wildfly"},{"original_method":"@NotNull\n  @Override\n  public ResolveResult[] multiResolve(boolean incompleteCode) {\n    ResolveResult[] results = super.multiResolve(incompleteCode);\n    if (results.length == 0) {\n      PsiFile file = myElement.getContainingFile();\n      final InjectedLanguageManager languageManager = InjectedLanguageManager.getInstance(myElement.getProject());\n      final PsiLanguageInjectionHost host = languageManager.getInjectionHost(myElement);\n      if (host != null) file = host.getContainingFile();\n      final String referencedName = myElement.getReferencedName();\n      if (referencedName == null) return ResolveResult.EMPTY_ARRAY;\n\n      if (host != null) {\n        final List<Pair<PsiElement,TextRange>> files = languageManager.getInjectedPsiFiles(host);\n        if (files != null) {\n          for (Pair<PsiElement, TextRange> pair : files) {\n            ResolveProcessor processor = new ResolveProcessor(referencedName);\n\n            PyResolveUtil.scopeCrawlUp(processor, (ScopeOwner)pair.getFirst(), referencedName, pair.getFirst());\n            final List<RatedResolveResult> resultList = getResultsFromProcessor(referencedName, processor, pair.getFirst(),\n                                                                                         pair.getFirst());\n            if (resultList.size() > 0)\n              return resultList.toArray(new RatedResolveResult[resultList.size()]);\n          }\n        }\n      }\n\n      ResolveProcessor processor = new ResolveProcessor(referencedName);\n\n      PyResolveUtil.scopeCrawlUp(processor, (ScopeOwner)file, referencedName, file);\n      final List<RatedResolveResult> resultList = getResultsFromProcessor(referencedName, processor, file, file);\n      if (resultList.size() > 0)\n        return resultList.toArray(new RatedResolveResult[resultList.size()]);\n    }\n    return results;\n  }","id":89468,"modified_method":"@NotNull\n  @Override\n  public ResolveResult[] multiResolve(boolean incompleteCode) {\n    ResolveResult[] results = super.multiResolve(incompleteCode);\n    if (results.length == 0) {\n      PsiFile file = myElement.getContainingFile();\n      final InjectedLanguageManager languageManager = InjectedLanguageManager.getInstance(myElement.getProject());\n      final PsiLanguageInjectionHost host = languageManager.getInjectionHost(myElement);\n      if (host != null) file = host.getContainingFile();\n      final String referencedName = myElement.getReferencedName();\n      if (referencedName == null) return ResolveResult.EMPTY_ARRAY;\n\n      if (host != null) {\n        final List<Pair<PsiElement,TextRange>> files = languageManager.getInjectedPsiFiles(host);\n        if (files != null) {\n          for (Pair<PsiElement, TextRange> pair : files) {\n            ResolveProcessor processor = new ResolveProcessor(referencedName);\n\n            PyResolveUtil.scopeCrawlUp(processor, (ScopeOwner)pair.getFirst(), referencedName, pair.getFirst());\n            final List<RatedResolveResult> resultList = getResultsFromProcessor(referencedName, processor, pair.getFirst(),\n                                                                                         pair.getFirst());\n            if (resultList.size() > 0)\n              return resultList.toArray(new RatedResolveResult[resultList.size()]);\n          }\n        }\n      }\n\n      ResolveProcessor processor = new ResolveProcessor(referencedName);\n\n      final ScopeOwner scopeOwner = ScopeUtil.getScopeOwner(myElement);\n      PyResolveUtil.scopeCrawlUp(processor, scopeOwner != null? scopeOwner : (ScopeOwner)file, referencedName, file);\n      final List<RatedResolveResult> resultList = getResultsFromProcessor(referencedName, processor, file, file);\n      if (resultList.size() > 0)\n        return resultList.toArray(new RatedResolveResult[resultList.size()]);\n    }\n    return results;\n  }","commit_id":"a647dd4499d954c7941a526d8300a6d8b27d1610","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement create(ASTNode node) {\n    IElementType type = node.getElementType();\n\n    if (type == DIRECTIVE_BLOCK) {\n      return new RestDirectiveBlock(node);\n    }\n    if (type == REFERENCE_NAME) {\n      return new RestReference(node);\n    }\n    if (type == REFERENCE_TARGET) {\n      return new RestReferenceTarget(node);\n    }\n    if (type == TITLE) {\n      return new RestTitle(node);\n    }\n    if (type == FIELD) {\n      return new RestRole(node);\n    }\n    if (type == INLINE_BLOCK) {\n      return new RestInlineBlock(node);\n    }\n    return new ASTWrapperPsiElement(node);\n  }","id":89469,"modified_method":"public PsiElement create(ASTNode node) {\n    IElementType type = node.getElementType();\n\n    if (type == DIRECTIVE_BLOCK) {\n      return new RestDirectiveBlock(node);\n    }\n    if (type == REFERENCE_NAME) {\n      return new RestReference(node);\n    }\n    if (type == REFERENCE_TARGET) {\n      return new RestReferenceTarget(node);\n    }\n    if (type == TITLE) {\n      return new RestTitle(node);\n    }\n    if (type == FIELD) {\n      return new RestRole(node);\n    }\n    if (type == INLINE_BLOCK) {\n      return new RestInlineBlock(node);\n    }\n    if (type == LINE_TEXT) {\n      return new RestLine(node);\n    }\n    return new ASTWrapperPsiElement(node);\n  }","commit_id":"a647dd4499d954c7941a526d8300a6d8b27d1610","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public ASTNode parse(IElementType root, PsiBuilder builder) {\n    final PsiBuilder.Marker rootMarker = builder.mark();\n    while (!builder.eof()) {\n      IElementType type = builder.getTokenType();\n      if (type == RestTokenTypes.EXPLISIT_MARKUP_START) {\n        builder.advanceLexer();\n        parseMarkup(builder);\n      }\n      else if (type == RestTokenTypes.REFERENCE_NAME || type == RestTokenTypes.SUBSTITUTION) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestTokenTypes.REFERENCE_NAME);\n      }\n      else if (type == RestTokenTypes.TITLE) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestTokenTypes.TITLE);\n      }\n      else if (type == RestTokenTypes.FIELD) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestTokenTypes.FIELD);\n      }\n      else if (type == RestTokenTypes.INLINE_LINE) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestElementTypes.INLINE_BLOCK);\n      }\n      else if (type == RestTokenTypes.ANONYMOUS_HYPERLINK) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestElementTypes.REFERENCE_TARGET);\n      }\n      else\n        builder.advanceLexer();\n    }\n    rootMarker.done(root);\n    return builder.getTreeBuilt();\n  }","id":89470,"modified_method":"@NotNull\n  public ASTNode parse(IElementType root, PsiBuilder builder) {\n    final PsiBuilder.Marker rootMarker = builder.mark();\n    while (!builder.eof()) {\n      IElementType type = builder.getTokenType();\n      if (type == RestTokenTypes.EXPLISIT_MARKUP_START) {\n        builder.advanceLexer();\n        parseMarkup(builder);\n      }\n      else if (type == RestTokenTypes.REFERENCE_NAME || type == RestTokenTypes.SUBSTITUTION) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestTokenTypes.REFERENCE_NAME);\n      }\n      else if (type == RestTokenTypes.TITLE) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestTokenTypes.TITLE);\n      }\n      else if (type == RestTokenTypes.FIELD) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestTokenTypes.FIELD);\n      }\n      else if (type == RestTokenTypes.INLINE_LINE) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestElementTypes.INLINE_BLOCK);\n      }\n      else if (type == RestTokenTypes.ANONYMOUS_HYPERLINK) {\n        PsiBuilder.Marker marker = builder.mark();\n        builder.advanceLexer();\n        marker.done(RestElementTypes.REFERENCE_TARGET);\n      }\n      else if (type == RestTokenTypes.LINE) {\n        PsiBuilder.Marker marker = builder.mark();\n        while (type == RestTokenTypes.LINE || type == RestTokenTypes.WHITESPACE) {\n          builder.advanceLexer();\n          type = builder.getTokenType();\n        }\n\n        marker.done(RestElementTypes.LINE_TEXT);\n      }\n      else\n        builder.advanceLexer();\n    }\n    rootMarker.done(root);\n    return builder.getTreeBuilt();\n  }","commit_id":"a647dd4499d954c7941a526d8300a6d8b27d1610","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void advance() {\n    myBuilder.advanceLexer();\n  }","id":89471,"modified_method":"public void advance() {\n    myBuilder.advanceLexer();\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean assertToken(final PrattTokenType type) {\n    return checkToken(type, true);\n  }","id":89472,"modified_method":"public boolean assertToken(final PrattTokenType type) {\n    return _checkToken(type, true);\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public IElementType parse(int rightPriority) {\n    IElementType tokenType = getTokenType();\n    if (tokenType == null) return null;\n\n    PsiBuilder.Marker marker = myBuilder.mark();\n    myBuilder.advanceLexer();\n    IElementType left = tokenType instanceof PrattTokenType ? ((PrattTokenType)tokenType).parsePrefix(this) : null;\n\n    while (left != null) {\n      final PsiBuilder.Marker marker1 = marker.precede();\n      marker.done(left);\n      marker = marker1;\n\n      tokenType = myBuilder.getTokenType();\n      if (tokenType == null || tokenType instanceof PrattTokenType && rightPriority >= ((PrattTokenType)tokenType).getPriority()) break;\n\n      final PsiBuilder.Marker oldMarker = myPrevMarker;\n      myPrevMarker = myBuilder.mark();\n      try {\n        myBuilder.advanceLexer();\n        if (!(tokenType instanceof PrattTokenType)) break;\n\n        left = ((PrattTokenType)tokenType).parseInfix(left, this);\n      }\n      finally {\n        myPrevMarker.drop();\n        myPrevMarker = oldMarker;\n      }\n\n    }\n    marker.drop();\n\n    return left;\n  }","id":89473,"modified_method":"@Nullable\n  public IElementType parse(int rightPriority) {\n    IElementType tokenType = getTokenType();\n    if (tokenType == null) return null;\n\n    if (!(tokenType instanceof PrattTokenType) || ((PrattTokenType)tokenType).getPriority() <= rightPriority) {\n      myBuilder.error(JavaErrorMessages.message(\"unexpected.token\"));\n      return null;\n    }\n\n    final Nud nud = ((PrattTokenType)tokenType).getNud();\n    if (nud == null) {\n      myBuilder.error(JavaErrorMessages.message(\"unexpected.token\"));\n      return null;\n    }\n\n    PsiBuilder.Marker marker = myBuilder.mark();\n\n    ParseResult left;\n    IElementType result;\n\n    final PsiBuilder.Marker oldMarker = myPrevMarker;\n    myPrevMarker = myBuilder.mark();\n    try {\n      myBuilder.advanceLexer();\n      left = nud.parsePrefix(this);\n      result = left.getDoneType();\n    }\n    finally {\n      myPrevMarker.drop();\n      myPrevMarker = oldMarker;\n    }\n\n    while (!left.isError()) {\n      tokenType = myBuilder.getTokenType();\n      if (!(tokenType instanceof PrattTokenType) || rightPriority >= ((PrattTokenType)tokenType).getPriority()) break;\n\n      final Led led = ((PrattTokenType)tokenType).getLed();\n      if (led == null) break;\n\n      myPrevMarker = myBuilder.mark();\n      try {\n        myBuilder.advanceLexer();\n\n        left = led.parseInfix(result, this);\n\n        if (result != null && left.getDoneType() != null) {\n          final PsiBuilder.Marker marker1 = marker.precede();\n          marker.doneBefore(result, myPrevMarker);\n          marker = marker1;\n          result = left.getDoneType();\n        }\n      }\n      finally {\n        myPrevMarker.drop();\n        myPrevMarker = oldMarker;\n      }\n\n    }\n    if (result != null) {\n      marker.done(result);\n    } else {\n      marker.drop();\n    }\n\n    return result;\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEof() {\n    return getTokenType() == null;\n  }","id":89474,"modified_method":"public boolean isEof() {\n    return isToken(null);\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean checkToken(final PrattTokenType type, final boolean error) {\n    if (getTokenType() == type) {\n      advance();\n      return true;\n    }\n    if (error) {\n      myBuilder.error(type.getExpectedText());\n    }\n    return false;\n  }","id":89475,"modified_method":"private boolean _checkToken(final PrattTokenType type, final boolean error) {\n    if (isToken(type)) {\n      advance();\n      return true;\n    }\n    if (error) {\n      myBuilder.error(type.getExpectedText());\n    }\n    return false;\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PrattTokenType(@NotNull final String tokenName,\n                          @Nullable final Language language, final int priority, @NotNull final Led led) {\n    this(tokenName, language, priority, Nud.EMPTY, led);\n  }","id":89476,"modified_method":"public PrattTokenType(@NotNull final String tokenName,\n                          @Nullable final Language language, final int priority, @Nullable final Led led) {\n    this(tokenName, language, priority, null, led);\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PrattTokenType(@NotNull final String tokenName,\n                          @Nullable final Language language, final int priority) {\n    this(tokenName, language, priority, Nud.EMPTY, Led.EMPTY);\n  }","id":89477,"modified_method":"public PrattTokenType(@NotNull final String tokenName,\n                          @Nullable final Language language, final int priority) {\n    this(tokenName, language, priority, null, null);\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PrattTokenType(@NotNull final String tokenName,\n                          @Nullable final Language language, final int priority, @NotNull final Nud nud) {\n    this(tokenName, language, priority, nud, Led.EMPTY);\n  }","id":89478,"modified_method":"public PrattTokenType(@NotNull final String tokenName,\n                          @Nullable final Language language, final int priority, @Nullable final Nud nud) {\n    this(tokenName, language, priority, nud, null);\n  }","commit_id":"0f30d6a4d5bdeb96e07e972dec31561cbc4b7bc8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitMessageFormatExpression(@NotNull final AngularJSMessageFormatExpression expression) {\n    final AngularJSMessageFormatParser.ExtensionType type = expression.getExtensionType();\n    if (type == null) myHolder.createErrorAnnotation(expression, \"missing or unknown message format extension\");// will not happen, but\n    final List<PsiElement> elements = expression.getSelectionKeywordElements();\n    final List<String> selectionKeywords = ContainerUtil.map(elements, new Function<PsiElement, String>() {\n      @Override\n      public String fun(PsiElement element) {\n        return element.getText();\n      }\n    });\n\n    checkForRequiredSelectionKeywords(type, expression, selectionKeywords);\n    checkForDuplicateSelectionKeywords(selectionKeywords, elements);\n    checkForSelectionKeywordValues(type, selectionKeywords, elements);\n  }","id":89479,"modified_method":"@Override\n  public void visitMessageFormatExpression(@NotNull final AngularJSMessageFormatExpression expression) {\n    final AngularJSMessageFormatParser.ExtensionType type = expression.getExtensionType();\n    if (type == null) myHolder.createErrorAnnotation(expression, \"missing or unknown message format extension\");// will not happen, but\n    final List<PsiElement> elements = expression.getSelectionKeywordElements();\n    final List<String> selectionKeywords = ContainerUtil.map(elements, new Function<PsiElement, String>() {\n      @Override\n      public String fun(PsiElement element) {\n        return element.getText();\n      }\n    });\n\n    checkOptions(type, expression);\n    checkForRequiredSelectionKeywords(type, expression, selectionKeywords);\n    checkForDuplicateSelectionKeywords(selectionKeywords, elements);\n    checkForSelectionKeywordValues(type, selectionKeywords, elements);\n  }","commit_id":"91b0739bffc52611f3480694fc0fbcdfcb70ea35","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private boolean parseOffsetOption() {\n    if (isIdentifierToken(builder.getTokenType()) && OFFSET_OPTION.equals(builder.getTokenText())) {\n      if (builder.lookAhead(1) != JSTokenTypes.COLON || builder.lookAhead(2) != JSTokenTypes.NUMERIC_LITERAL) {\n        return true;\n      }\n      final PsiBuilder.Marker mark = builder.mark();\n      builder.advanceLexer();// offset\n      builder.advanceLexer();// colon\n      builder.advanceLexer();// numeric literal\n      mark.done(AngularJSElementTypes.MESSAGE_FORMAT_OPTION);\n      if (builder.getTokenType() != JSTokenTypes.COMMA) {\n        builder.error(\"expected comma\");\n        return false;\n      }\n      builder.advanceLexer();\n    }\n    return true;\n  }","id":89480,"modified_method":"private boolean parseOffsetOption() {\n    if (isIdentifierToken(builder.getTokenType()) && OFFSET_OPTION.equals(builder.getTokenText())) {\n      if (builder.lookAhead(1) != JSTokenTypes.COLON) {\n        return true;\n      }\n      final IElementType third = builder.lookAhead(2);\n      boolean commaIsAfterColon = third == JSTokenTypes.COMMA;\n      if (!commaIsAfterColon && builder.lookAhead(3) != JSTokenTypes.COMMA) {\n        return true;\n      }\n      if (!commaIsAfterColon && !JSTokenTypes.LITERALS.contains(third) && JSTokenTypes.IDENTIFIER != third) {\n        return true;\n      }\n      final PsiBuilder.Marker mark = builder.mark();\n      builder.advanceLexer();// offset\n      builder.advanceLexer();// colon\n      if (!commaIsAfterColon) {\n        builder.advanceLexer();// literal\n      }\n      mark.done(AngularJSElementTypes.MESSAGE_FORMAT_OPTION);\n      if (builder.getTokenType() != JSTokenTypes.COMMA) {\n        builder.error(\"expected comma\");\n        return false;\n      }\n      builder.advanceLexer();\n    }\n    return true;\n  }","commit_id":"91b0739bffc52611f3480694fc0fbcdfcb70ea35","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static boolean nextTokenIsInner(PsiBuilder builder_, IElementType token, boolean force) {\n    ErrorState state = ErrorState.get(builder_);\n    if (state.completionState != null && !force) return true;\n    IElementType tokenType = builder_.getTokenType();\n    if (!state.suppressErrors && state.predicateCount < 2) {\n      addVariant(builder_, state, token);\n    }\n    return token == tokenType;\n  }","id":89481,"modified_method":"public static int nextTokenIsFast(PsiBuilder builder_, String tokenText, boolean caseSensitive) {\n    CharSequence sequence = builder_.getOriginalText();\n    int offset = builder_.getCurrentOffset();\n    int endOffset = offset + tokenText.length();\n    CharSequence subSequence = sequence.subSequence(offset, Math.min(endOffset, sequence.length()));\n\n    if (!Comparing.equal(subSequence, tokenText, caseSensitive)) return 0;\n\n    int count = 0;\n    while (true) {\n      int nextOffset = builder_.rawTokenTypeStart(++count);\n      if (nextOffset > endOffset) {\n        return -count;\n      }\n      else if (nextOffset == endOffset) {\n        break;\n      }\n    }\n    return count;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokenSmart(PsiBuilder builder_, IElementType token) {\n    builder_.eof(); // skip whitespaces\n    ErrorState state = ErrorState.get(builder_);\n    CompletionState completionState = state.completionState;\n    if (completionState != null && state.predicateCount == 0) {\n      addCompletionVariant(builder_, completionState, token);\n    }\n    return consumeTokenFast(builder_, token);\n  }","id":89482,"modified_method":"public static boolean consumeTokenSmart(PsiBuilder builder_, IElementType token) {\n    addCompletionVariantSmart(builder_, token);\n    return consumeTokenFast(builder_, token);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean consumeTokens(PsiBuilder builder_, boolean smart, int pin_, IElementType... tokens_) {\n    ErrorState state = ErrorState.get(builder_);\n    if (state.completionState != null && state.predicateCount == 0) {\n      addCompletionVariant(builder_, state.completionState, tokens_);\n    }\n    // suppress single token completion\n    CompletionState completionState = state.completionState;\n    state.completionState = null;\n    boolean result_ = true;\n    boolean pinned_ = false;\n    for (int i = 0, tokensLength = tokens_.length; i < tokensLength; i++) {\n      if (pin_ > 0 && i == pin_) pinned_ = result_;\n      if ((result_ || pinned_) && !consumeInner(builder_, smart, i, tokens_)) {\n        result_ = false;\n        if (pin_ < 0 || pinned_) report_error_(builder_, state, false);\n      }\n    }\n    state.completionState = completionState;\n    return pinned_ || result_;\n  }","id":89483,"modified_method":"private static boolean consumeTokens(PsiBuilder builder_, boolean smart, int pin, IElementType... tokens) {\n    ErrorState state = ErrorState.get(builder_);\n    if (state.completionState != null && state.predicateCount == 0) {\n      addCompletionVariant(builder_, state.completionState, tokens);\n    }\n    // suppress single token completion\n    CompletionState completionState = state.completionState;\n    state.completionState = null;\n    boolean result_ = true;\n    boolean pinned_ = false;\n    for (int i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n      if (pin > 0 && i == pin) pinned_ = result_;\n      if (result_ || pinned_) {\n        boolean fast = smart && i == 0;\n        if (!(fast ? consumeTokenFast(builder_, tokens[i]) : consumeToken(builder_, tokens[i]))) {\n          result_ = false;\n          if (pin < 0 || pinned_) report_error_(builder_, state, false);\n        }\n      }\n    }\n    state.completionState = completionState;\n    return pinned_ || result_;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokenFast(PsiBuilder builder_, String text) {\n    if (Comparing.strEqual(builder_.getTokenText(), text, ErrorState.get(builder_).caseSensitive)) {\n      builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","id":89484,"modified_method":"public static boolean consumeTokenFast(PsiBuilder builder_, String text) {\n    int count = nextTokenIsFast(builder_, text, ErrorState.get(builder_).caseSensitive);\n    if (count > 0) {\n      while (count-- > 0) builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean consumeInner(PsiBuilder builder_, boolean smart, int i, IElementType[] tokens_) {\n    if (smart) return i == 0 ? consumeTokenFast(builder_, tokens_[i]) : consumeToken(builder_, tokens_[i]);\n    return consumeToken(builder_, tokens_[i]);\n  }","id":89485,"modified_method":"public static boolean parseTokens(PsiBuilder builder_, boolean smart, int pin_, IElementType... tokens) {\n    PsiBuilder.Marker marker_ = builder_.mark();\n    boolean result_ = consumeTokens(builder_, smart, pin_, tokens);\n    if (!result_) {\n      marker_.rollbackTo();\n    }\n    else {\n      marker_.drop();\n    }\n    return result_;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokensSmart(PsiBuilder builder_, int pin_, IElementType... tokens_) {\n    return consumeTokens(builder_, true, pin_, tokens_);\n  }","id":89486,"modified_method":"public static boolean consumeTokensSmart(PsiBuilder builder_, int pin_, IElementType... token) {\n    return consumeTokens(builder_, true, pin_, token);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeToken(PsiBuilder builder_, String text) {\n    ErrorState state = ErrorState.get(builder_);\n    if (!state.suppressErrors && state.predicateCount < 2) {\n      addVariant(builder_, state, text);\n    }\n    return consumeTokenInner(builder_, text, state.caseSensitive);\n  }","id":89487,"modified_method":"public static boolean consumeToken(PsiBuilder builder_, String text) {\n    return consumeToken(builder_, text, ErrorState.get(builder_).caseSensitive);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokenInner(PsiBuilder builder_, String text, boolean caseSensitive) {\n    final CharSequence sequence = builder_.getOriginalText();\n    final int offset = builder_.getCurrentOffset();\n    final int endOffset = offset + text.length();\n    CharSequence tokenText = sequence.subSequence(offset, Math.min(endOffset, sequence.length()));\n\n    if (Comparing.equal(text, tokenText, caseSensitive)) {\n      int count = 0;\n      while (true) {\n        final int nextOffset = builder_.rawTokenTypeStart(++ count);\n        if (nextOffset > endOffset) {\n          return false;\n        }\n        else if (nextOffset == endOffset) {\n          break;\n        }\n      }\n      while (count-- > 0) builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","id":89488,"modified_method":"public static boolean consumeToken(PsiBuilder builder_, String text, boolean caseSensitive) {\n    addVariantSmart(builder_, text, true);\n    int count = nextTokenIsFast(builder_, text, caseSensitive);\n    if (count > 0) {\n      while (count-- > 0) builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Deprecated\n  public static boolean replaceVariants(PsiBuilder builder_, int variantCount, String frameName) {\n    ErrorState state = ErrorState.get(builder_);\n    if (!state.suppressErrors && state.predicateCount < 2 && state.predicateSign) {\n      state.clearVariants(true, state.variants.size() - variantCount);\n      addVariantInner(state, builder_.rawTokenIndex(), frameName);\n    }\n    return true;\n  }","id":89489,"modified_method":"public static boolean nextTokenIs(PsiBuilder builder_, String tokenText) {\n    if (!addVariantSmart(builder_, tokenText, false)) return true;\n    return nextTokenIsFast(builder_, tokenText, ErrorState.get(builder_).caseSensitive) > 0;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokenSmart(PsiBuilder builder_, String token) {\n    return consumeTokenFast(builder_, token);\n  }","id":89490,"modified_method":"public static boolean consumeTokenSmart(PsiBuilder builder_, String token) {\n    addCompletionVariantSmart(builder_, token);\n    return consumeTokenFast(builder_, token);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean parseTokens(PsiBuilder builder_, int pin_, IElementType... tokens_) {\n    PsiBuilder.Marker marker_ = builder_.mark();\n    boolean result_ = consumeTokens(builder_, pin_, tokens_);\n    if (!result_) {\n      marker_.rollbackTo();\n    }\n    else {\n      marker_.drop();\n    }\n    return result_;\n  }","id":89491,"modified_method":"public static boolean parseTokens(PsiBuilder builder_, int pin_, IElementType... tokens) {\n    return parseTokens(builder_, false, pin_, tokens);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokens(PsiBuilder builder_, int pin_, IElementType... tokens_) {\n    return consumeTokens(builder_, false, pin_, tokens_);\n  }","id":89492,"modified_method":"public static boolean consumeTokens(PsiBuilder builder_, int pin_, IElementType... token) {\n    return consumeTokens(builder_, false, pin_, token);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeToken(PsiBuilder builder_, IElementType token) {\n    if (nextTokenIsInner(builder_, token, true)) {\n      builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","id":89493,"modified_method":"public static boolean consumeToken(PsiBuilder builder_, IElementType token) {\n    addVariantSmart(builder_, token, true);\n    if (nextTokenIsFast(builder_, token)) {\n      builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean nextTokenIs(PsiBuilder builder_, IElementType token) {\n    return nextTokenIsInner(builder_, token, false);\n  }","id":89494,"modified_method":"public static boolean nextTokenIs(PsiBuilder builder_, IElementType token) {\n    if (!addVariantSmart(builder_, token, false)) return true;\n    return nextTokenIsFast(builder_, token);\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean consumeTokenFast(PsiBuilder builder_, IElementType token) {\n    if (builder_.getTokenType() == token) {\n      builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","id":89495,"modified_method":"public static boolean consumeTokenFast(PsiBuilder builder_, IElementType token) {\n    if (nextTokenIsFast(builder_, token)) {\n      builder_.advanceLexer();\n      return true;\n    }\n    return false;\n  }","commit_id":"cdca7835c24b43351d8c6f43f275e03a7b7aeb3c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @see org.opencms.xml.A_CmsXmlDocument#initDocument(org.dom4j.Document, java.lang.String, org.opencms.xml.CmsXmlContentDefinition)\n     */\n    @Override\n    protected void initDocument(Document document, String encoding, CmsXmlContentDefinition definition) {\n\n        m_document = document;\n        m_contentDefinition = definition;\n        m_encoding = CmsEncoder.lookupEncoding(encoding, encoding);\n        m_elementLocales = new HashMap<String, Set<Locale>>();\n        m_elementNames = new HashMap<Locale, Set<String>>();\n        m_locales = new HashSet<Locale>();\n        m_cntPages = new HashMap<Locale, CmsContainerPageBean>();\n        clearBookmarks();\n\n        // initialize the bookmarks\n        for (Iterator<Element> itCntPages = CmsXmlGenericWrapper.elementIterator(m_document.getRootElement()); itCntPages.hasNext();) {\n            Element cntPage = itCntPages.next();\n\n            try {\n                Locale locale = CmsLocaleManager.getLocale(cntPage.attribute(\n                    CmsXmlContentDefinition.XSD_ATTRIBUTE_VALUE_LANGUAGE).getValue());\n\n                addLocale(locale);\n\n                List<CmsContainerBean> containers = new ArrayList<CmsContainerBean>();\n                for (Iterator<Element> itCnts = CmsXmlGenericWrapper.elementIterator(\n                    cntPage,\n                    XmlNode.CONTAINER.getName()); itCnts.hasNext();) {\n                    Element container = itCnts.next();\n\n                    // container itself\n                    int cntIndex = CmsXmlUtils.getXpathIndexInt(container.getUniquePath(cntPage));\n                    String cntPath = CmsXmlUtils.createXpathElement(container.getName(), cntIndex);\n                    I_CmsXmlSchemaType cntSchemaType = definition.getSchemaType(container.getName());\n                    I_CmsXmlContentValue cntValue = cntSchemaType.createValue(this, container, locale);\n                    addBookmark(cntPath, locale, true, cntValue);\n                    CmsXmlContentDefinition cntDef = ((CmsXmlNestedContentDefinition)cntSchemaType).getNestedContentDefinition();\n\n                    // name\n                    Element name = container.element(XmlNode.NAME.getName());\n                    createBookmark(name, locale, container, cntPath, cntDef);\n\n                    // type\n                    Element type = container.element(XmlNode.TYPE.getName());\n                    createBookmark(type, locale, container, cntPath, cntDef);\n\n                    List<CmsContainerElementBean> elements = new ArrayList<CmsContainerElementBean>();\n                    // Elements\n                    for (Iterator<Element> itElems = CmsXmlGenericWrapper.elementIterator(\n                        container,\n                        XmlNode.ELEMENT.getName()); itElems.hasNext();) {\n                        Element element = itElems.next();\n\n                        // element itself\n                        int elemIndex = CmsXmlUtils.getXpathIndexInt(element.getUniquePath(container));\n                        String elemPath = CmsXmlUtils.concatXpath(cntPath, CmsXmlUtils.createXpathElement(\n                            element.getName(),\n                            elemIndex));\n                        I_CmsXmlSchemaType elemSchemaType = cntDef.getSchemaType(element.getName());\n                        I_CmsXmlContentValue elemValue = elemSchemaType.createValue(this, element, locale);\n                        addBookmark(elemPath, locale, true, elemValue);\n                        CmsXmlContentDefinition elemDef = ((CmsXmlNestedContentDefinition)elemSchemaType).getNestedContentDefinition();\n\n                        // uri\n                        Element uri = element.element(XmlNode.URI.getName());\n                        createBookmark(uri, locale, element, elemPath, elemDef);\n                        Element uriLink = uri.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID elementId = null;\n                        if (uriLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            elementId = new CmsLink(uriLink).getStructureId();\n                        }\n\n                        // formatter\n                        Element formatter = element.element(XmlNode.FORMATTER.getName());\n                        createBookmark(formatter, locale, element, elemPath, elemDef);\n                        Element formatterLink = formatter.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID formatterId = null;\n                        if (formatterLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            formatterId = new CmsLink(formatterLink).getStructureId();\n                        }\n\n                        Map<String, String> propertiesMap = new HashMap<String, String>();\n\n                        // Properties\n                        for (Iterator<Element> itProps = CmsXmlGenericWrapper.elementIterator(\n                            element,\n                            XmlNode.PROPERTIES.getName()); itProps.hasNext();) {\n                            Element property = itProps.next();\n\n                            // property itself\n                            int propIndex = CmsXmlUtils.getXpathIndexInt(property.getUniquePath(element));\n                            String propPath = CmsXmlUtils.concatXpath(elemPath, CmsXmlUtils.createXpathElement(\n                                property.getName(),\n                                propIndex));\n                            I_CmsXmlSchemaType propSchemaType = elemDef.getSchemaType(property.getName());\n                            I_CmsXmlContentValue propValue = propSchemaType.createValue(this, property, locale);\n                            addBookmark(propPath, locale, true, propValue);\n                            CmsXmlContentDefinition propDef = ((CmsXmlNestedContentDefinition)propSchemaType).getNestedContentDefinition();\n\n                            // name\n                            Element propName = property.element(XmlNode.NAME.getName());\n                            createBookmark(propName, locale, property, propPath, propDef);\n\n                            // choice value \n                            Element value = property.element(XmlNode.VALUE.getName());\n                            int valueIndex = CmsXmlUtils.getXpathIndexInt(value.getUniquePath(property));\n                            String valuePath = CmsXmlUtils.concatXpath(propPath, CmsXmlUtils.createXpathElement(\n                                value.getName(),\n                                valueIndex));\n                            I_CmsXmlSchemaType valueSchemaType = propDef.getSchemaType(value.getName());\n                            I_CmsXmlContentValue valueValue = valueSchemaType.createValue(this, value, locale);\n                            addBookmark(valuePath, locale, true, valueValue);\n                            CmsXmlContentDefinition valueDef = ((CmsXmlNestedContentDefinition)valueSchemaType).getNestedContentDefinition();\n\n                            String val = null;\n                            Element string = value.element(XmlNode.STRING.getName());\n                            if (string != null) {\n                                // string value\n                                createBookmark(string, locale, value, valuePath, valueDef);\n                                val = string.getTextTrim();\n                            } else {\n                                // file list value\n                                Element valueFileList = value.element(XmlNode.FILELIST.getName());\n                                int valueFileListIndex = CmsXmlUtils.getXpathIndexInt(valueFileList.getUniquePath(value));\n                                String valueFileListPath = CmsXmlUtils.concatXpath(\n                                    valuePath,\n                                    CmsXmlUtils.createXpathElement(valueFileList.getName(), valueFileListIndex));\n                                I_CmsXmlSchemaType valueFileListSchemaType = valueDef.getSchemaType(valueFileList.getName());\n                                I_CmsXmlContentValue valueFileListValue = valueFileListSchemaType.createValue(\n                                    this,\n                                    valueFileList,\n                                    locale);\n                                addBookmark(valueFileListPath, locale, true, valueFileListValue);\n                                CmsXmlContentDefinition valueFileListDef = ((CmsXmlNestedContentDefinition)valueFileListSchemaType).getNestedContentDefinition();\n\n                                List<CmsUUID> idList = new ArrayList<CmsUUID>();\n                                // files\n                                for (Iterator<Element> itFiles = CmsXmlGenericWrapper.elementIterator(\n                                    valueFileList,\n                                    XmlNode.URI.getName()); itFiles.hasNext();) {\n\n                                    Element valueUri = itFiles.next();\n                                    createBookmark(valueUri, locale, value, valueFileListPath, valueFileListDef);\n                                    Element valueUriLink = valueUri.element(CmsXmlPage.NODE_LINK);\n                                    idList.add(new CmsLink(valueUriLink).getStructureId());\n                                }\n                                // comma separated list of UUIDs\n                                val = CmsStringUtil.listAsString(idList, \",\");\n                            }\n\n                            propertiesMap.put(propName.getTextTrim(), val);\n                        }\n                        if (elementId != null) {\n                            elements.add(new CmsContainerElementBean(elementId, formatterId, propertiesMap));\n                        }\n                    }\n\n                    containers.add(new CmsContainerBean(name.getText(), type.getText(), -1, elements));\n                }\n\n                m_cntPages.put(locale, new CmsContainerPageBean(locale, containers));\n            } catch (NullPointerException e) {\n                LOG.error(org.opencms.xml.content.Messages.get().getBundle().key(\n                    org.opencms.xml.content.Messages.LOG_XMLCONTENT_INIT_BOOKMARKS_0), e);\n            }\n        }\n    }","id":89496,"modified_method":"/**\n     * @see org.opencms.xml.A_CmsXmlDocument#initDocument(org.dom4j.Document, java.lang.String, org.opencms.xml.CmsXmlContentDefinition)\n     */\n    @Override\n    protected void initDocument(Document document, String encoding, CmsXmlContentDefinition definition) {\n\n        m_document = document;\n        m_contentDefinition = definition;\n        m_encoding = CmsEncoder.lookupEncoding(encoding, encoding);\n        m_elementLocales = new HashMap<String, Set<Locale>>();\n        m_elementNames = new HashMap<Locale, Set<String>>();\n        m_locales = new HashSet<Locale>();\n        m_cntPages = new HashMap<Locale, CmsContainerPageBean>();\n        clearBookmarks();\n\n        // initialize the bookmarks\n        for (Iterator<Element> itCntPages = CmsXmlGenericWrapper.elementIterator(m_document.getRootElement()); itCntPages.hasNext();) {\n            Element cntPage = itCntPages.next();\n\n            try {\n                Locale locale = CmsLocaleManager.getLocale(cntPage.attribute(\n                    CmsXmlContentDefinition.XSD_ATTRIBUTE_VALUE_LANGUAGE).getValue());\n\n                addLocale(locale);\n\n                List<CmsContainerBean> containers = new ArrayList<CmsContainerBean>();\n                for (Iterator<Element> itCnts = CmsXmlGenericWrapper.elementIterator(\n                    cntPage,\n                    XmlNode.CONTAINER.getName()); itCnts.hasNext();) {\n                    Element container = itCnts.next();\n\n                    // container itself\n                    int cntIndex = CmsXmlUtils.getXpathIndexInt(container.getUniquePath(cntPage));\n                    String cntPath = CmsXmlUtils.createXpathElement(container.getName(), cntIndex);\n                    I_CmsXmlSchemaType cntSchemaType = definition.getSchemaType(container.getName());\n                    I_CmsXmlContentValue cntValue = cntSchemaType.createValue(this, container, locale);\n                    addBookmark(cntPath, locale, true, cntValue);\n                    CmsXmlContentDefinition cntDef = ((CmsXmlNestedContentDefinition)cntSchemaType).getNestedContentDefinition();\n\n                    // name\n                    Element name = container.element(XmlNode.NAME.getName());\n                    createBookmark(name, locale, container, cntPath, cntDef);\n\n                    // type\n                    Element type = container.element(XmlNode.TYPE.getName());\n                    createBookmark(type, locale, container, cntPath, cntDef);\n\n                    List<CmsContainerElementBean> elements = new ArrayList<CmsContainerElementBean>();\n                    // Elements\n                    for (Iterator<Element> itElems = CmsXmlGenericWrapper.elementIterator(\n                        container,\n                        XmlNode.ELEMENT.getName()); itElems.hasNext();) {\n                        Element element = itElems.next();\n\n                        // element itself\n                        int elemIndex = CmsXmlUtils.getXpathIndexInt(element.getUniquePath(container));\n                        String elemPath = CmsXmlUtils.concatXpath(cntPath, CmsXmlUtils.createXpathElement(\n                            element.getName(),\n                            elemIndex));\n                        I_CmsXmlSchemaType elemSchemaType = cntDef.getSchemaType(element.getName());\n                        I_CmsXmlContentValue elemValue = elemSchemaType.createValue(this, element, locale);\n                        addBookmark(elemPath, locale, true, elemValue);\n                        CmsXmlContentDefinition elemDef = ((CmsXmlNestedContentDefinition)elemSchemaType).getNestedContentDefinition();\n\n                        // uri\n                        Element uri = element.element(XmlNode.URI.getName());\n                        createBookmark(uri, locale, element, elemPath, elemDef);\n                        Element uriLink = uri.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID elementId = null;\n                        if (uriLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            elementId = new CmsLink(uriLink).getStructureId();\n                        }\n\n                        // formatter\n                        Element formatter = element.element(XmlNode.FORMATTER.getName());\n                        createBookmark(formatter, locale, element, elemPath, elemDef);\n                        Element formatterLink = formatter.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID formatterId = null;\n                        if (formatterLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            formatterId = new CmsLink(formatterLink).getStructureId();\n                        }\n\n                        Map<String, String> propertiesMap = new HashMap<String, String>();\n\n                        // Properties\n                        for (Iterator<Element> itProps = CmsXmlGenericWrapper.elementIterator(\n                            element,\n                            XmlNode.PROPERTIES.getName()); itProps.hasNext();) {\n                            Element property = itProps.next();\n\n                            // property itself\n                            int propIndex = CmsXmlUtils.getXpathIndexInt(property.getUniquePath(element));\n                            String propPath = CmsXmlUtils.concatXpath(elemPath, CmsXmlUtils.createXpathElement(\n                                property.getName(),\n                                propIndex));\n                            I_CmsXmlSchemaType propSchemaType = elemDef.getSchemaType(property.getName());\n                            I_CmsXmlContentValue propValue = propSchemaType.createValue(this, property, locale);\n                            addBookmark(propPath, locale, true, propValue);\n                            CmsXmlContentDefinition propDef = ((CmsXmlNestedContentDefinition)propSchemaType).getNestedContentDefinition();\n\n                            // name\n                            Element propName = property.element(XmlNode.NAME.getName());\n                            createBookmark(propName, locale, property, propPath, propDef);\n\n                            // choice value \n                            Element value = property.element(XmlNode.VALUE.getName());\n                            if (value == null) {\n                                // this can happen when adding the elements node to the xml content\n                                continue;\n                            }\n                            int valueIndex = CmsXmlUtils.getXpathIndexInt(value.getUniquePath(property));\n                            String valuePath = CmsXmlUtils.concatXpath(propPath, CmsXmlUtils.createXpathElement(\n                                value.getName(),\n                                valueIndex));\n                            I_CmsXmlSchemaType valueSchemaType = propDef.getSchemaType(value.getName());\n                            I_CmsXmlContentValue valueValue = valueSchemaType.createValue(this, value, locale);\n                            addBookmark(valuePath, locale, true, valueValue);\n                            CmsXmlContentDefinition valueDef = ((CmsXmlNestedContentDefinition)valueSchemaType).getNestedContentDefinition();\n\n                            String val = null;\n                            Element string = value.element(XmlNode.STRING.getName());\n                            if (string != null) {\n                                // string value\n                                createBookmark(string, locale, value, valuePath, valueDef);\n                                val = string.getTextTrim();\n                            } else {\n                                // file list value\n                                Element valueFileList = value.element(XmlNode.FILELIST.getName());\n                                if (valueFileList == null) {\n                                    // this can happen when adding the elements node to the xml content\n                                    continue;\n                                }\n                                int valueFileListIndex = CmsXmlUtils.getXpathIndexInt(valueFileList.getUniquePath(value));\n                                String valueFileListPath = CmsXmlUtils.concatXpath(\n                                    valuePath,\n                                    CmsXmlUtils.createXpathElement(valueFileList.getName(), valueFileListIndex));\n                                I_CmsXmlSchemaType valueFileListSchemaType = valueDef.getSchemaType(valueFileList.getName());\n                                I_CmsXmlContentValue valueFileListValue = valueFileListSchemaType.createValue(\n                                    this,\n                                    valueFileList,\n                                    locale);\n                                addBookmark(valueFileListPath, locale, true, valueFileListValue);\n                                CmsXmlContentDefinition valueFileListDef = ((CmsXmlNestedContentDefinition)valueFileListSchemaType).getNestedContentDefinition();\n\n                                List<CmsUUID> idList = new ArrayList<CmsUUID>();\n                                // files\n                                for (Iterator<Element> itFiles = CmsXmlGenericWrapper.elementIterator(\n                                    valueFileList,\n                                    XmlNode.URI.getName()); itFiles.hasNext();) {\n\n                                    Element valueUri = itFiles.next();\n                                    createBookmark(valueUri, locale, valueFileList, valueFileListPath, valueFileListDef);\n                                    Element valueUriLink = valueUri.element(CmsXmlPage.NODE_LINK);\n                                    CmsUUID fileId = null;\n                                    if (valueUriLink == null) {\n                                        // this can happen when adding the elements node to the xml content\n                                        // it is not dangerous since the link has to be set before saving \n                                    } else {\n                                        fileId = new CmsLink(valueUriLink).getStructureId();\n                                    }\n                                    idList.add(fileId);\n                                }\n                                // comma separated list of UUIDs\n                                val = CmsStringUtil.listAsString(idList, IDS_SEPARATOR);\n                            }\n\n                            propertiesMap.put(propName.getTextTrim(), val);\n                        }\n                        if (elementId != null) {\n                            elements.add(new CmsContainerElementBean(elementId, formatterId, propertiesMap));\n                        }\n                    }\n\n                    containers.add(new CmsContainerBean(name.getText(), type.getText(), -1, elements));\n                }\n\n                m_cntPages.put(locale, new CmsContainerPageBean(locale, containers));\n            } catch (NullPointerException e) {\n                LOG.error(org.opencms.xml.content.Messages.get().getBundle().key(\n                    org.opencms.xml.content.Messages.LOG_XMLCONTENT_INIT_BOOKMARKS_0), e);\n            }\n        }\n    }","commit_id":"0482d1c35f48b423f5092607647c68121f9ad2c8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Recursive method to retrieve the site entries with sub entries from the raw XML structure.<p>\n     * \n     * @param rootElem the root element\n     * @param rootPath the root path\n     * @param rootDef the root content definition\n     * @param locale the current locale\n     * \n     * @return the site entries with sub entries\n     */\n    protected List<CmsSiteEntryBean> readSiteEntries(\n        Element rootElem,\n        String rootPath,\n        CmsXmlContentDefinition rootDef,\n        Locale locale) {\n\n        List<CmsSiteEntryBean> entries = new ArrayList<CmsSiteEntryBean>();\n        for (Iterator<Element> itCnts = CmsXmlGenericWrapper.elementIterator(rootElem, XmlNode.SITEENTRY.getName()); itCnts.hasNext();) {\n            Element entry = itCnts.next();\n\n            // entry itself\n            int entryIndex = CmsXmlUtils.getXpathIndexInt(entry.getUniquePath(rootElem));\n            String entryPath = CmsXmlUtils.concatXpath(rootPath, CmsXmlUtils.createXpathElement(\n                entry.getName(),\n                entryIndex));\n            if (entryPath.startsWith(\"/\")) {\n                // this will happen when root path is empty\n                entryPath = entryPath.substring(1);\n            }\n            I_CmsXmlSchemaType entrySchemaType = rootDef.getSchemaType(entry.getName());\n            I_CmsXmlContentValue entryValue = entrySchemaType.createValue(this, entry, locale);\n            addBookmark(entryPath, locale, true, entryValue);\n            CmsXmlContentDefinition entryDef = ((CmsXmlNestedContentDefinition)entrySchemaType).getNestedContentDefinition();\n\n            // name\n            Element name = entry.element(XmlNode.NAME.getName());\n            createBookmark(name, locale, entry, entryPath, entryDef);\n            String entryName = name.getTextTrim();\n\n            // title\n            Element title = entry.element(XmlNode.TITLE.getName());\n            createBookmark(title, locale, entry, entryPath, entryDef);\n            String titleValue = title.getTextTrim();\n\n            // vfs file\n            Element uri = entry.element(XmlNode.VFSFILE.getName());\n            createBookmark(uri, locale, entry, entryPath, entryDef);\n            Element uriLink = uri.element(CmsXmlPage.NODE_LINK);\n            CmsUUID entryId = null;\n            if (uriLink == null) {\n                // this can happen when adding the entry node to the xml content\n                // it is not dangerous since the link has to be set before saving \n            } else {\n                entryId = new CmsLink(uriLink).getStructureId();\n            }\n\n            Map<String, String> propertiesMap = new HashMap<String, String>();\n\n            // Properties\n            for (Iterator<Element> itProps = CmsXmlGenericWrapper.elementIterator(entry, XmlNode.PROPERTIES.getName()); itProps.hasNext();) {\n                Element property = itProps.next();\n\n                // property itself\n                int propIndex = CmsXmlUtils.getXpathIndexInt(property.getUniquePath(entry));\n                String propPath = CmsXmlUtils.concatXpath(entryPath, CmsXmlUtils.createXpathElement(\n                    property.getName(),\n                    propIndex));\n                I_CmsXmlSchemaType propSchemaType = entryDef.getSchemaType(property.getName());\n                I_CmsXmlContentValue propValue = propSchemaType.createValue(this, property, locale);\n                addBookmark(propPath, locale, true, propValue);\n                CmsXmlContentDefinition propDef = ((CmsXmlNestedContentDefinition)propSchemaType).getNestedContentDefinition();\n\n                // name\n                Element propName = property.element(XmlNode.NAME.getName());\n                createBookmark(propName, locale, property, propPath, propDef);\n\n                // choice value \n                Element value = property.element(XmlNode.VALUE.getName());\n                int valueIndex = CmsXmlUtils.getXpathIndexInt(value.getUniquePath(property));\n                String valuePath = CmsXmlUtils.concatXpath(propPath, CmsXmlUtils.createXpathElement(\n                    value.getName(),\n                    valueIndex));\n                I_CmsXmlSchemaType valueSchemaType = propDef.getSchemaType(value.getName());\n                I_CmsXmlContentValue valueValue = valueSchemaType.createValue(this, value, locale);\n                addBookmark(valuePath, locale, true, valueValue);\n                CmsXmlContentDefinition valueDef = ((CmsXmlNestedContentDefinition)valueSchemaType).getNestedContentDefinition();\n\n                String val = null;\n                Element string = value.element(XmlNode.STRING.getName());\n                if (string != null) {\n                    // string value\n                    createBookmark(string, locale, value, valuePath, valueDef);\n                    val = string.getTextTrim();\n                } else {\n                    // file list value\n                    Element valueFileList = value.element(XmlNode.FILELIST.getName());\n                    int valueFileListIndex = CmsXmlUtils.getXpathIndexInt(valueFileList.getUniquePath(value));\n                    String valueFileListPath = CmsXmlUtils.concatXpath(valuePath, CmsXmlUtils.createXpathElement(\n                        valueFileList.getName(),\n                        valueFileListIndex));\n                    I_CmsXmlSchemaType valueFileListSchemaType = valueDef.getSchemaType(valueFileList.getName());\n                    I_CmsXmlContentValue valueFileListValue = valueFileListSchemaType.createValue(\n                        this,\n                        valueFileList,\n                        locale);\n                    addBookmark(valueFileListPath, locale, true, valueFileListValue);\n                    CmsXmlContentDefinition valueFileListDef = ((CmsXmlNestedContentDefinition)valueFileListSchemaType).getNestedContentDefinition();\n\n                    List<CmsUUID> idList = new ArrayList<CmsUUID>();\n                    // files\n                    for (Iterator<Element> itFiles = CmsXmlGenericWrapper.elementIterator(\n                        valueFileList,\n                        XmlNode.URI.getName()); itFiles.hasNext();) {\n\n                        Element valueUri = itFiles.next();\n                        createBookmark(valueUri, locale, value, valueFileListPath, valueFileListDef);\n                        Element valueUriLink = valueUri.element(CmsXmlPage.NODE_LINK);\n                        idList.add(new CmsLink(valueUriLink).getStructureId());\n                    }\n                    // comma separated list of UUIDs\n                    val = CmsStringUtil.listAsString(idList, \",\");\n                }\n\n                propertiesMap.put(propName.getTextTrim(), val);\n            }\n\n            List<CmsSiteEntryBean> subEntries = readSiteEntries(entry, entryPath, entryDef, locale);\n\n            entries.add(new CmsSiteEntryBean(entryId, entryName, titleValue, propertiesMap, subEntries));\n        }\n        return entries;\n    }","id":89497,"modified_method":"/**\n     * Recursive method to retrieve the site entries with sub entries from the raw XML structure.<p>\n     * \n     * @param rootElem the root element\n     * @param rootPath the root path\n     * @param rootDef the root content definition\n     * @param locale the current locale\n     * \n     * @return the site entries with sub entries\n     */\n    protected List<CmsSiteEntryBean> readSiteEntries(\n        Element rootElem,\n        String rootPath,\n        CmsXmlContentDefinition rootDef,\n        Locale locale) {\n\n        List<CmsSiteEntryBean> entries = new ArrayList<CmsSiteEntryBean>();\n        for (Iterator<Element> itCnts = CmsXmlGenericWrapper.elementIterator(rootElem, XmlNode.SITEENTRY.getName()); itCnts.hasNext();) {\n            Element entry = itCnts.next();\n\n            // entry itself\n            int entryIndex = CmsXmlUtils.getXpathIndexInt(entry.getUniquePath(rootElem));\n            String entryPath = CmsXmlUtils.concatXpath(rootPath, CmsXmlUtils.createXpathElement(\n                entry.getName(),\n                entryIndex));\n            if (entryPath.startsWith(\"/\")) {\n                // this will happen when root path is empty\n                entryPath = entryPath.substring(1);\n            }\n            I_CmsXmlSchemaType entrySchemaType = rootDef.getSchemaType(entry.getName());\n            I_CmsXmlContentValue entryValue = entrySchemaType.createValue(this, entry, locale);\n            addBookmark(entryPath, locale, true, entryValue);\n            CmsXmlContentDefinition entryDef = ((CmsXmlNestedContentDefinition)entrySchemaType).getNestedContentDefinition();\n\n            // name\n            Element name = entry.element(XmlNode.NAME.getName());\n            createBookmark(name, locale, entry, entryPath, entryDef);\n            String entryName = name.getTextTrim();\n\n            // title\n            Element title = entry.element(XmlNode.TITLE.getName());\n            createBookmark(title, locale, entry, entryPath, entryDef);\n            String titleValue = title.getTextTrim();\n\n            // vfs file\n            Element uri = entry.element(XmlNode.VFSFILE.getName());\n            createBookmark(uri, locale, entry, entryPath, entryDef);\n            Element uriLink = uri.element(CmsXmlPage.NODE_LINK);\n            CmsUUID entryId = null;\n            if (uriLink == null) {\n                // this can happen when adding the entry node to the xml content\n                // it is not dangerous since the link has to be set before saving \n            } else {\n                entryId = new CmsLink(uriLink).getStructureId();\n            }\n\n            Map<String, String> propertiesMap = new HashMap<String, String>();\n\n            // Properties\n            for (Iterator<Element> itProps = CmsXmlGenericWrapper.elementIterator(entry, XmlNode.PROPERTIES.getName()); itProps.hasNext();) {\n                Element property = itProps.next();\n\n                // property itself\n                int propIndex = CmsXmlUtils.getXpathIndexInt(property.getUniquePath(entry));\n                String propPath = CmsXmlUtils.concatXpath(entryPath, CmsXmlUtils.createXpathElement(\n                    property.getName(),\n                    propIndex));\n                I_CmsXmlSchemaType propSchemaType = entryDef.getSchemaType(property.getName());\n                I_CmsXmlContentValue propValue = propSchemaType.createValue(this, property, locale);\n                addBookmark(propPath, locale, true, propValue);\n                CmsXmlContentDefinition propDef = ((CmsXmlNestedContentDefinition)propSchemaType).getNestedContentDefinition();\n\n                // name\n                Element propName = property.element(XmlNode.NAME.getName());\n                createBookmark(propName, locale, property, propPath, propDef);\n\n                // choice value \n                Element value = property.element(XmlNode.VALUE.getName());\n                if (value == null) {\n                    // this can happen when adding the elements node to the xml content\n                    continue;\n                }\n                int valueIndex = CmsXmlUtils.getXpathIndexInt(value.getUniquePath(property));\n                String valuePath = CmsXmlUtils.concatXpath(propPath, CmsXmlUtils.createXpathElement(\n                    value.getName(),\n                    valueIndex));\n                I_CmsXmlSchemaType valueSchemaType = propDef.getSchemaType(value.getName());\n                I_CmsXmlContentValue valueValue = valueSchemaType.createValue(this, value, locale);\n                addBookmark(valuePath, locale, true, valueValue);\n                CmsXmlContentDefinition valueDef = ((CmsXmlNestedContentDefinition)valueSchemaType).getNestedContentDefinition();\n\n                String val = null;\n                Element string = value.element(XmlNode.STRING.getName());\n                if (string != null) {\n                    // string value\n                    createBookmark(string, locale, value, valuePath, valueDef);\n                    val = string.getTextTrim();\n                } else {\n                    // file list value\n                    Element valueFileList = value.element(XmlNode.FILELIST.getName());\n                    if (valueFileList == null) {\n                        // this can happen when adding the elements node to the xml content\n                        continue;\n                    }\n                    int valueFileListIndex = CmsXmlUtils.getXpathIndexInt(valueFileList.getUniquePath(value));\n                    String valueFileListPath = CmsXmlUtils.concatXpath(valuePath, CmsXmlUtils.createXpathElement(\n                        valueFileList.getName(),\n                        valueFileListIndex));\n                    I_CmsXmlSchemaType valueFileListSchemaType = valueDef.getSchemaType(valueFileList.getName());\n                    I_CmsXmlContentValue valueFileListValue = valueFileListSchemaType.createValue(\n                        this,\n                        valueFileList,\n                        locale);\n                    addBookmark(valueFileListPath, locale, true, valueFileListValue);\n                    CmsXmlContentDefinition valueFileListDef = ((CmsXmlNestedContentDefinition)valueFileListSchemaType).getNestedContentDefinition();\n\n                    List<CmsUUID> idList = new ArrayList<CmsUUID>();\n                    // files\n                    for (Iterator<Element> itFiles = CmsXmlGenericWrapper.elementIterator(\n                        valueFileList,\n                        XmlNode.URI.getName()); itFiles.hasNext();) {\n\n                        Element valueUri = itFiles.next();\n                        createBookmark(valueUri, locale, valueFileList, valueFileListPath, valueFileListDef);\n                        Element valueUriLink = valueUri.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID fileId = null;\n                        if (valueUriLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            fileId = new CmsLink(valueUriLink).getStructureId();\n                        }\n                        idList.add(fileId);\n                    }\n                    // comma separated list of UUIDs\n                    val = CmsStringUtil.listAsString(idList, \",\");\n                }\n\n                propertiesMap.put(propName.getTextTrim(), val);\n            }\n\n            List<CmsSiteEntryBean> subEntries = readSiteEntries(entry, entryPath, entryDef, locale);\n\n            entries.add(new CmsSiteEntryBean(entryId, entryName, titleValue, propertiesMap, subEntries));\n        }\n        return entries;\n    }","commit_id":"0482d1c35f48b423f5092607647c68121f9ad2c8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected String getMessageText(Game game) {\n        StringBuilder sb = new StringBuilder();\n        MageObject object = game.getObject(this.sourceId);\n        if (object == null) {\n            object = game.getLastKnownInformation(this.sourceId, Zone.BATTLEFIELD);\n        }\n        if (object != null) {\n            if (object instanceof StackAbility) {\n                Card card = game.getCard(((StackAbility) object).getSourceId());\n                if (card != null) {\n                    sb.append(card.getName());\n                } else {\n                    sb.append(object.getName());\n                }\n            } else {\n                if (object instanceof Spell) {\n                    Spell<?> spell = (Spell<?>) object;\n                    String castText = spell.getSpellAbility().toString();\n                    sb.append((castText.startsWith(\"Cast \") ? castText.substring(5):castText));\n                    if (spell.getFromZone() == Zone.GRAVEYARD) {\n                        sb.append(\" from graveyard\");\n                    }\n                    sb.append(getOptionalTextSuffix(game, spell));\n                } else {\n                    sb.append(object.getName());\n                }\n            }\n        } else {\n            sb.append(\"unknown\");\n        }\n        if (object instanceof Spell && ((Spell) object).getSpellAbilities().size() > 1) {\n            if (((Spell) object).getSpellAbility().getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {\n                Spell<?> spell = (Spell<?>) object;\n                int i = 0;\n                for (SpellAbility spellAbility : spell.getSpellAbilities()) {\n                    i++;\n                    String half;\n                    if (i == 1) {\n                        half = \" left\";\n                    } else {\n                        half = \" right\";\n                    }\n                    if (spellAbility.getTargets().size() > 0) {\n                        sb.append(half).append(\" half targeting \");\n                        for (Target target: spellAbility.getTargets()) {\n                            sb.append(target.getTargetedName(game));\n                        }\n                    }\n                }\n            } else {\n                Spell<?> spell = (Spell<?>) object;\n                int i = 0;\n                for (SpellAbility spellAbility : spell.getSpellAbilities()) {\n                    i++;\n                    if ( i > 1) {\n                        sb.append(\" splicing \");\n                        if (spellAbility.name.length() > 5 && spellAbility.name.startsWith(\"Cast \")) {\n                            sb.append(spellAbility.name.substring(5));\n                        } else {\n                            sb.append(spellAbility.name);\n                        }\n                    }\n                    appendTargetDescriptionForLog(sb, spellAbility.getTargets(), game);\n                }\n            }\n        } else if (object instanceof Spell && ((Spell) object).getSpellAbility().getModes().size() > 1) {\n            Modes spellModes = ((Spell) object).getSpellAbility().getModes();\n            int item = 0;\n            for (Mode mode : spellModes.values()) {\n                item++;\n                if (spellModes.getSelectedModes().contains(mode.getId())) {\n                    spellModes.setMode(mode);\n                    sb.append(\" (mode \").append(item).append(\")\");\n                    appendTargetDescriptionForLog(sb, getTargets(), game);\n                }\n            }\n        } else {\n            appendTargetDescriptionForLog(sb, getTargets(), game);\n        }\n        for (Choice choice :this.getChoices()) {\n            sb.append(\" - \").append(choice.getMessage()).append(\": \").append(choice.getChoice());\n        }\n        return sb.toString();\n    }","id":89498,"modified_method":"protected String getMessageText(Game game) {\n        StringBuilder sb = new StringBuilder();\n        MageObject object = game.getObject(this.sourceId);\n        if (object == null) {\n            object = game.getLastKnownInformation(this.sourceId, Zone.BATTLEFIELD);\n        }\n        if (object != null) {\n            if (object instanceof StackAbility) {\n                Card card = game.getCard(((StackAbility) object).getSourceId());\n                if (card != null) {\n                    sb.append(card.getName());\n                } else {\n                    sb.append(object.getName());\n                }\n            } else {\n                if (object instanceof Spell) {\n                    Spell<?> spell = (Spell<?>) object;\n                    String castText = spell.getSpellAbility().toString();\n                    sb.append((castText.startsWith(\"Cast \") ? castText.substring(5):castText));\n                    if (spell.getFromZone() == Zone.GRAVEYARD) {\n                        sb.append(\" from graveyard\");\n                    }\n                    sb.append(getOptionalTextSuffix(game, spell));\n                } else {\n                    sb.append(object.getName());\n                }\n            }\n        } else {\n            sb.append(\"unknown\");\n        }\n        if (object instanceof Spell && ((Spell) object).getSpellAbilities().size() > 1) {\n            if (((Spell) object).getSpellAbility().getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {\n                Spell<?> spell = (Spell<?>) object;\n                int i = 0;\n                for (SpellAbility spellAbility : spell.getSpellAbilities()) {\n                    i++;\n                    String half;\n                    if (i == 1) {\n                        half = \" left\";\n                    } else {\n                        half = \" right\";\n                    }\n                    if (spellAbility.getTargets().size() > 0) {\n                        sb.append(half).append(\" half targeting \");\n                        for (Target target: spellAbility.getTargets()) {\n                            sb.append(target.getTargetedName(game));\n                        }\n                    }\n                }\n            } else {\n                Spell<?> spell = (Spell<?>) object;\n                int i = 0;\n                for (SpellAbility spellAbility : spell.getSpellAbilities()) {\n                    i++;\n                    if ( i > 1) {\n                        sb.append(\" splicing \");\n                        if (spellAbility.name.length() > 5 && spellAbility.name.startsWith(\"Cast \")) {\n                            sb.append(spellAbility.name.substring(5));\n                        } else {\n                            sb.append(spellAbility.name);\n                        }\n                    }\n                    sb.append(getTargetDescriptionForLog(spellAbility.getTargets(), game));\n                }\n            }\n        } else if (object instanceof Spell && ((Spell) object).getSpellAbility().getModes().size() > 1) {\n            Modes spellModes = ((Spell) object).getSpellAbility().getModes();\n            int item = 0;\n            for (Mode mode : spellModes.values()) {\n                item++;\n                if (spellModes.getSelectedModes().contains(mode.getId())) {\n                    spellModes.setMode(mode);\n                    sb.append(\" (mode \").append(item).append(\")\");\n                    sb.append(getTargetDescriptionForLog(getTargets(), game));\n                }\n            }\n        } else {\n            sb.append(getTargetDescriptionForLog(getTargets(), game));\n        }\n        return sb.toString();\n    }","commit_id":"20453be5ffce028c3c8fe0c1d9db56cf88794f48","url":"https://github.com/magefree/mage"},{"original_method":"protected void appendTargetDescriptionForLog(StringBuilder sb, Targets targets, Game game) {\n        if (targets.size() > 0) {\n            String usedVerb = null;\n            for (Target target : targets) {\n                if (!target.isNotTarget()) {\n                    if (usedVerb == null || usedVerb.equals(\" choosing \")) {\n                        usedVerb = \" targeting \";\n                        sb.append(usedVerb);\n                    }\n                } else if (target.isNotTarget() && (usedVerb == null || usedVerb.equals(\" targeting \"))) {\n                    usedVerb = \" choosing \";\n                    sb.append(usedVerb);\n                }\n                sb.append(target.getTargetedName(game));\n            }\n        }\n    }","id":89499,"modified_method":"protected String getTargetDescriptionForLog(Targets targets, Game game) {\n        StringBuilder sb = new StringBuilder();\n        if (targets.size() > 0) {\n            String usedVerb = null;\n            for (Target target : targets) {\n                if (!target.isNotTarget()) {\n                    if (usedVerb == null || usedVerb.equals(\" choosing \")) {\n                        usedVerb = \" targeting \";\n                        sb.append(usedVerb);\n                    }\n                } else if (target.isNotTarget() && (usedVerb == null || usedVerb.equals(\" targeting \"))) {\n                    usedVerb = \" choosing \";\n                    sb.append(usedVerb);\n                }\n                sb.append(target.getTargetedName(game));\n            }\n        }\n        for (Choice choice :this.getChoices()) {\n            sb.append(\" - \").append(choice.getMessage()).append(\": \").append(choice.getChoice());\n        }        \n        return sb.toString();\n    }","commit_id":"20453be5ffce028c3c8fe0c1d9db56cf88794f48","url":"https://github.com/magefree/mage"},{"original_method":"public TriggeredAbilityImpl(final TriggeredAbilityImpl ability) {\n        super(ability);\n        this.optional = ability.optional;\n    }","id":89500,"modified_method":"public TriggeredAbilityImpl(final TriggeredAbilityImpl<T> ability) {\n        super(ability);\n        this.optional = ability.optional;\n    }","commit_id":"20453be5ffce028c3c8fe0c1d9db56cf88794f48","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getGameLogMessage(Game game) {\n        MageObject object = game.getObject(sourceId);\n        StringBuilder sb = new StringBuilder();\n        if (object != null) {\n            sb.append(object.getName()).append(\" - ability triggered: \").append(this.getRule(object.getName()));\n        } else {\n            sb.append(\"Ability triggered: \").append(this.getRule());\n        }\n        return sb.toString();\n    }","id":89501,"modified_method":"@Override\n    public String getGameLogMessage(Game game) {\n        MageObject object = game.getObject(sourceId);\n        StringBuilder sb = new StringBuilder();\n        if (object != null) {\n            sb.append(\"Ability triggers: \").append(object.getName()).append(\" - \").append(this.getRule(object.getName()));\n        } else {\n            sb.append(\"Ability triggers: \").append(this.getRule());\n        }        \n        String targetText = getTargetDescriptionForLog(getTargets(), game);\n        if (!targetText.isEmpty()) {\n            sb.append(\" - \").append(targetText);\n        }        \n        return sb.toString();\n    }","commit_id":"20453be5ffce028c3c8fe0c1d9db56cf88794f48","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n        // System.out.printf(\"%3d %12s %s%n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n\n        if (seen == LDC || seen == LDC_W || seen == LDC2_W) {\n            Constant c = getConstantRefOperand();\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT)) {\n                BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                        .addString(\"Did you mean MICROS_PER_DAY\").addInt(MICROS_PER_DAY_OVERFLOWED_AS_INT)\n                        .describe(IntAnnotation.INT_VALUE);\n                accumulator.accumulateBug(bug, this);\n            }\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == Integer.MIN_VALUE\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == Long.MIN_VALUE)) {\n                sawLoadOfMinValue = true;\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n                absoluteValueAccumulator.clearBugs();\n            }\n        }\n\n\n        if (seen == LCMP) {\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            checkForCompatibleLongComparison(left, right);\n            checkForCompatibleLongComparison(right, left);\n        }\n\n        if (stack.getStackDepth() >= 2)\n            switch (seen) {\n            case IF_ICMPEQ:\n            case IF_ICMPNE:\n            case IF_ICMPLE:\n            case IF_ICMPGE:\n            case IF_ICMPLT:\n            case IF_ICMPGT:\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item0.getConstant() instanceof Integer) {\n                    OpcodeStack.Item tmp = item0;\n                    item0 = item1;\n                    item1 = tmp;\n                }\n                Object constant1 = item1.getConstant();\n                XMethod returnValueOf = item0.getReturnValueOf();\n                if (constant1 instanceof Integer\n                        && returnValueOf != null\n                        && returnValueOf.getName().equals(\"getYear\")\n                        && (returnValueOf.getClassName().equals(\"java.util.Date\") || returnValueOf.getClassName().equals(\n                                \"java.sql.Date\"))) {\n                    int year = (Integer) constant1;\n                    if (year > 1900)\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                                        .addString(\"Comparison of getYear does understand that it returns year-1900\")\n                                        .addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addInt(year)\n                                        .describe(IntAnnotation.INT_VALUE), this);\n                }\n            }\n\n        // System.out.printf(\"%4d %10s: %s\\n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n        if (seen == IFLT && stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n            sawCheckForNonNegativeSignedByte = getPC();\n        }\n\n        if (pendingAbsoluteValueBug != null) {\n            if (opcodesSincePendingAbsoluteValueBug == 0) {\n                opcodesSincePendingAbsoluteValueBug++;\n            } else {\n                if (seen == IREM) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    Object constantValue = top.getConstant();\n                    if (constantValue instanceof Number && Util.isPowerOfTwo(((Number) constantValue).intValue())) {\n                        pendingAbsoluteValueBug.setPriority(Priorities.LOW_PRIORITY);\n                    }\n                }\n                if (false)\n                    try {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen] + \":\"\n                                + OPCODE_NAMES[getNextOpcode()]);\n                    } catch (Exception e) {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen]);\n\n                    }\n                absoluteValueAccumulator.accumulateBug(pendingAbsoluteValueBug, pendingAbsoluteValueBugSourceLine);\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n            }\n        }\n\n        if (seen == INVOKESTATIC\n                && getClassConstantOperand().equals(\"org/easymock/EasyMock\")\n                && (getNameConstantOperand().equals(\"replay\") || getNameConstantOperand().equals(\"verify\") || getNameConstantOperand()\n                        .startsWith(\"reset\")) && getSigConstantOperand().equals(\"([Ljava/lang/Object;)V\")\n                && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0)\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD\", NORMAL_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        \n        if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"com/google/common/base/Preconditions\")\n             && getNameConstantOperand().equals(\"checkNotNull\")) {\n                      int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n\n                     OpcodeStack.Item item =  stack.getStackItem(args-1);\n                     Object o = item.getConstant();\n                     if (o instanceof String)\n                         accumulator.accumulateBug(new BugInstance(this, args > 1 ? \"DMI_ARGUMENTS_WRONG_ORDER\" : \"DMI_DOH\", NORMAL_PRIORITY)\n                         .addClassAndMethod(this).addCalledMethod(this)\n                         .addString((String)o).describe(StringAnnotation.STRING_CONSTANT_ROLE), \n                         this);\n                 \n\n            \n        }\n\n        if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)\n                && getSigConstantOperand().indexOf(\"Ljava/lang/Runnable;\") >= 0) {\n            SignatureParser parser = new SignatureParser(getSigConstantOperand());\n            int count = 0;\n            for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {\n                String parameter = i.next();\n                if (parameter.equals(\"Ljava/lang/Runnable;\")) {\n                    OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);\n                    if (\"Ljava/lang/Thread;\".equals(item.getSignature())) {\n                        accumulator.accumulateBug(new BugInstance(this, \"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED\",\n                                NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this), this);\n                    }\n\n                }\n            }\n\n        }\n\n        if (prevOpcode == I2L && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/Double\")\n                && getNameConstantOperand().equals(\"longBitsToDouble\")) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT\", HIGH_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && (freshRandomOnTos || freshRandomOneBelowTos)) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_RANDOM_USED_ONLY_ONCE\", HIGH_PRIORITY).addClassAndMethod(this)\n                    .addCalledMethod(this), this);\n\n        }\n\n        freshRandomOneBelowTos = freshRandomOnTos && isRegisterLoad();\n        freshRandomOnTos = seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && getNameConstantOperand().equals(\"<init>\");\n\n        if ((seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashMap\") && getNameConstantOperand().equals(\n                \"get\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Map\") && getNameConstantOperand()\n                        .equals(\"get\"))\n                || (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashSet\") && getNameConstantOperand()\n                        .equals(\"contains\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Set\") && getNameConstantOperand()\n                        .equals(\"contains\"))) {\n            OpcodeStack.Item top = stack.getStackItem(0);\n            if (top.getSignature().equals(\"Ljava/net/URL;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_COLLECTION_OF_URLS\", HIGH_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n        }\n\n        /**\n         * Since you can change the number of core threads for a scheduled\n         * thread pool executor, disabling this for now\n         */\n        if (false && seen == INVOKESPECIAL\n                && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"<init>\")) {\n\n            int arguments = getNumberArguments(getSigConstantOperand());\n            OpcodeStack.Item item = stack.getStackItem(arguments - 1);\n            Object value = item.getConstant();\n            if (value instanceof Integer && ((Integer) value).intValue() == 0)\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS\",\n                        HIGH_PRIORITY).addClassAndMethod(this), this);\n\n        }\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"setMaximumPoolSize\")) {\n            accumulator.accumulateBug(new BugInstance(this,\n                    \"DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR\", HIGH_PRIORITY)\n                    .addClassAndMethod(this), this);\n        }\n        if (isEqualsObject && !reportedBadCastInEquals) {\n            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"isInstance\")\n                    && getClassConstantOperand().equals(\"java/lang/Class\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INSTANCEOF || seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"getClass\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INVOKESPECIAL && getNameConstantOperand().equals(\"equals\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item1.getRegisterNumber() + item0.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == CHECKCAST && !sawInstanceofCheck) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    if (getSizeOfSurroundingTryBlock(getPC()) == Integer.MAX_VALUE) {\n                        accumulator.accumulateBug(new BugInstance(this, \"BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS\",\n                                NORMAL_PRIORITY).addClassAndMethod(this), this);\n                    }\n\n                    reportedBadCastInEquals = true;\n                }\n            }\n        }\n        {\n            boolean foundVacuousComparison = false;\n            if (seen == IF_ICMPGT || seen == IF_ICMPLE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (seen == IF_ICMPLT || seen == IF_ICMPGE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (foundVacuousComparison) {\n                accumulator.accumulateBug(new BugInstance(this, \"INT_VACUOUS_COMPARISON\", getBranchOffset() < 0 ? HIGH_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), this);\n            }\n\n        }\n\n        if (!sawLoadOfMinValue && seen == INVOKESTATIC && \n                ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"abs\")\n                ) {\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            int special = item0.getSpecialKind();\n            if (special == OpcodeStack.Item.RANDOM_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_RANDOM_INT\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n            else if (special == OpcodeStack.Item.HASHCODE_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_HASHCODE\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n        }\n\n        try {\n            int stackLoc = stackEntryThatMustBeNonnegative(seen);\n            if (stackLoc >= 0) {\n                OpcodeStack.Item tos = stack.getStackItem(stackLoc);\n                switch (tos.getSpecialKind()) {\n                case OpcodeStack.Item.HASHCODE_INT_REMAINDER:\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_REM_OF_HASHCODE\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n\n                    break;\n                case OpcodeStack.Item.RANDOM_INT:\n                case OpcodeStack.Item.RANDOM_INT_REMAINDER:\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"RV_REM_OF_RANDOM_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n\n                    break;\n                }\n\n            }\n            if (seen == IREM) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                Object constant0 = item0.getConstant();\n                if (constant0 instanceof Integer && ((Integer) constant0).intValue() == 1) {\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_REM_BY_1\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n\n            if (stack.getStackDepth() >= 1 && (seen == LOOKUPSWITCH || seen == TABLESWITCH)) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n                    int[] switchLabels = getSwitchLabels();\n                    int[] switchOffsets = getSwitchOffsets();\n                    for (int i = 0; i < switchLabels.length; i++) {\n                        int v = switchLabels[i];\n                        if (v <= -129 || v >= 128) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", HIGH_PRIORITY)\n                                    .addClassAndMethod(this).addInt(v).describe(IntAnnotation.INT_VALUE),\n                                    SourceLineAnnotation.fromVisitedInstruction(this, getPC() + switchOffsets[i]));\n                        }\n\n                    }\n                }\n            }\n            // check for use of signed byte where is it assumed it can be out of\n            // the -128...127 range\n            if (stack.getStackDepth() >= 2) {\n                switch (seen) {\n                case IF_ICMPEQ:\n                case IF_ICMPNE:\n                case IF_ICMPLT:\n                case IF_ICMPLE:\n                case IF_ICMPGE:\n                case IF_ICMPGT:\n                    OpcodeStack.Item item0 = stack.getStackItem(0);\n                    OpcodeStack.Item item1 = stack.getStackItem(1);\n                    int seen2 = seen;\n                    if (item0.getConstant() != null) {\n                        OpcodeStack.Item tmp = item0;\n                        item0 = item1;\n                        item1 = tmp;\n                        switch (seen) {\n                        case IF_ICMPLT:\n                            seen2 = IF_ICMPGT;\n                            break;\n                        case IF_ICMPGE:\n                            seen2 = IF_ICMPLE;\n                            break;\n                        case IF_ICMPGT:\n                            seen2 = IF_ICMPLT;\n                            break;\n                        case IF_ICMPLE:\n                            seen2 = IF_ICMPGE;\n                            break;\n\n                        }\n                    }\n                    Object constant1 = item1.getConstant();\n                    if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 <= -129 || v1 >= 128 || v1 == 127 && !(seen2 == IF_ICMPEQ || seen2 == IF_ICMPNE\n\n                        )) {\n                            int priority = HIGH_PRIORITY;\n                            if (v1 == 127) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 127 > x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 127 >= x : always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 127 < x : never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 127 <= x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 == 128) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 128 > x; always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 128 >= x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 128 < x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 128 <= x; never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 <= -129) {\n                                priority = NORMAL_PRIORITY;\n                            }\n\n                            if (getPC() - sawCheckForNonNegativeSignedByte < 10)\n                                priority++;\n\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", priority)\n                                    .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n\n                        }\n                    } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 < 0) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n                        }\n\n                    }\n\n                }\n            }\n\n            switch (seen) {\n            case IAND:\n            case LAND:\n            case IOR:\n            case LOR:\n            case IXOR:\n            case LXOR:\n                long badValue = (seen == IAND || seen == LAND) ? -1 : 0;\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                int prevOpcode = getPrevOpcode(1);\n                int prevPrevOpcode = getPrevOpcode(2);\n                if (rhs.hasConstantValue(badValue)\n                        && (prevOpcode == LDC || prevOpcode == ICONST_0 || prevOpcode == ICONST_M1 || prevOpcode == LCONST_0)\n                        && prevPrevOpcode != GOTO)\n                    reportVacuousBitOperation(seen, lhs);\n\n            }\n\n            if (checkForBitIorofSignedByte && seen != I2B) {\n                String pattern = (prevOpcode == LOR || prevOpcode == IOR) ? \"BIT_IOR_OF_SIGNED_BYTE\" : \"BIT_ADD_OF_SIGNED_BYTE\";\n                int priority = (prevOpcode == LOR || prevOpcode == LADD) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n                accumulator.accumulateBug(new BugInstance(this, pattern, priority).addClassAndMethod(this), this);\n\n                checkForBitIorofSignedByte = false;\n            } else if ((seen == IOR || seen == LOR || seen == IADD || seen == LADD) && stack.getStackDepth() >= 2) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n\n                int special0 = item0.getSpecialKind();\n                int special1 = item1.getSpecialKind();\n                if (special0 == OpcodeStack.Item.SIGNED_BYTE && special1 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item1.hasConstantValue(256) || special0 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item0.hasConstantValue(256) && special1 == OpcodeStack.Item.SIGNED_BYTE) {\n                    checkForBitIorofSignedByte = true;\n                } else {\n                    checkForBitIorofSignedByte = false;\n                }\n            } else {\n                checkForBitIorofSignedByte = false;\n            }\n\n            if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/String\") && getSigConstantOperand().startsWith(\"()\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"NP_IMMEDIATE_DEREFERENCE_OF_READLINE\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/io/BufferedReader\")\n                    && getNameConstantOperand().equals(\"ready\") && getSigConstantOperand().equals(\"()Z\")) {\n                sinceBufferedInputStreamReady = 0;\n            } else {\n                sinceBufferedInputStreamReady++;\n            }\n\n            prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n                    && getNameConstantOperand().equals(\"readLine\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\");\n\n            // System.out.println(randomNextIntState + \" \" + OPCODE_NAMES[seen]\n            // + \" \" + getMethodName());\n            switch (randomNextIntState) {\n            case 0:\n                if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                        && getNameConstantOperand().equals(\"nextDouble\") || seen == INVOKESTATIC\n                        && ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"random\")) {\n                    randomNextIntState = 1;\n                }\n                break;\n            case 1:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_01_TO_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    randomNextIntState = 0;\n                } else if (seen == DMUL)\n                    randomNextIntState = 4;\n                else if (seen == LDC2_W && getConstantRefOperand() instanceof ConstantDouble\n                        && ((ConstantDouble) getConstantRefOperand()).getBytes() == Integer.MIN_VALUE)\n                    randomNextIntState = 0;\n                else\n                    randomNextIntState = 2;\n\n                break;\n            case 2:\n                if (seen == I2D) {\n                    randomNextIntState = 3;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 3:\n                if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 4:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"DM_NEXTINT_VIA_NEXTDOUBLE\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n                }\n                randomNextIntState = 0;\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            if (isPublicStaticVoidMain\n                    && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().startsWith(\"javax/swing/\")\n                    && (getNameConstantOperand().equals(\"show\") && getSigConstantOperand().equals(\"()V\")\n                            || getNameConstantOperand().equals(\"pack\") && getSigConstantOperand().equals(\"()V\") || getNameConstantOperand()\n                            .equals(\"setVisible\") && getSigConstantOperand().equals(\"(Z)V\"))) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            // if ((seen == INVOKEVIRTUAL)\n            // && getClassConstantOperand().equals(\"java/lang/String\")\n            // && getNameConstantOperand().equals(\"substring\")\n            // && getSigConstantOperand().equals(\"(I)Ljava/lang/String;\")\n            // && stack.getStackDepth() > 1) {\n            // OpcodeStack.Item item = stack.getStackItem(0);\n            // Object o = item.getConstant();\n            // if (o != null && o instanceof Integer) {\n            // int v = ((Integer) o).intValue();\n            // if (v == 0)\n            // accumulator.accumulateBug(new BugInstance(this,\n            // \"DMI_USELESS_SUBSTRING\", NORMAL_PRIORITY)\n            // .addClassAndMethod(this)\n            // .addSourceLine(this));\n            // }\n            // }\n\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"isAnnotationPresent\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Class;)Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                Object value = item.getConstant();\n                if (value instanceof String) {\n                    String annotationClassName = (String) value;\n                    boolean lacksClassfileRetention = AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()\n                            .lacksRuntimeRetention(annotationClassName.replace('/', '.'));\n                    if (lacksClassfileRetention) {\n                        ClassDescriptor annotationClass = DescriptorFactory.createClassDescriptor(annotationClassName);\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION\", HIGH_PRIORITY)\n                                        .addClassAndMethod(this).addCalledMethod(this).addClass(annotationClass)\n                                        .describe(ClassAnnotation.ANNOTATION_ROLE), this);\n                    }\n\n                }\n\n            }\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"next\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Object;\") && getMethodName().equals(\"hasNext\")\n                    && getMethodSig().equals(\"()Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_CALLING_NEXT_FROM_HASNEXT\", item.isInitialParameter()\n                        && item.getRegisterNumber() == 0 ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(Ljava/lang/String;)V\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\") || seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/Runtime\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_RUN_FINALIZERS_ON_EXIT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"()V\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n\n            }\n\n            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"exit\") && !getMethodName().equals(\"processWindowEvent\")\n                    && !getMethodName().startsWith(\"windowClos\") && getMethodName().indexOf(\"exit\") == -1\n                    && getMethodName().indexOf(\"Exit\") == -1 && getMethodName().indexOf(\"crash\") == -1\n                    && getMethodName().indexOf(\"Crash\") == -1 && getMethodName().indexOf(\"die\") == -1\n                    && getMethodName().indexOf(\"Die\") == -1 && getMethodName().indexOf(\"main\") == -1) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_EXIT\", getMethod().isStatic() ? LOW_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));\n            }\n            if (((seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")) || (seen == INVOKEVIRTUAL && getClassConstantOperand()\n                    .equals(\"java/lang/Runtime\")))\n                    && getNameConstantOperand().equals(\"gc\")\n                    && getSigConstantOperand().equals(\"()V\")\n                    && !getDottedClassName().startsWith(\"java.lang\")\n                    && !getMethodName().startsWith(\"gc\") && !getMethodName().endsWith(\"gc\")) {\n                if (gcInvocationBugReport == null) {\n                    // System.out.println(\"Saw call to GC\");\n                    if (isPublicStaticVoidMain) {\n                        // System.out.println(\"Skipping GC complaint in main method\");\n                        return;\n                    }\n                    if (isTestMethod(getMethod())) {\n                        return;\n                    }\n                    // Just save this report in a field; it will be flushed\n                    // IFF there were no calls to System.currentTimeMillis();\n                    // in the method.\n                    gcInvocationBugReport = new BugInstance(this, \"DM_GC\", HIGH_PRIORITY).addClassAndMethod(this).addSourceLine(\n                            this);\n                    gcInvocationPC = getPC();\n                    // System.out.println(\"GC invocation at pc \" + PC);\n                }\n            }\n            if (!isSynthetic && (seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/Boolean\")\n                    && getNameConstantOperand().equals(\"<init>\") && !getClassName().equals(\"java/lang/Boolean\")) {\n                int majorVersion = getThisClass().getMajor();\n                if (majorVersion >= MAJOR_1_4) {\n                    accumulator.accumulateBug(new BugInstance(this, \"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals(\"java/lang/System\")\n                    && (getNameConstantOperand().equals(\"currentTimeMillis\") || getNameConstantOperand().equals(\"nanoTime\"))) {\n                sawCurrentTimeMillis = true;\n            }\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"toString\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator\n                        .accumulateBug(new BugInstance(this, \"DM_STRING_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && (getNameConstantOperand().equals(\"toUpperCase\") || getNameConstantOperand().equals(\"toLowerCase\"))\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_CONVERT_CASE\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                String cls = getClassConstantOperand();\n                String sig = getSigConstantOperand();\n                if ((cls.equals(\"java/lang/Integer\") && sig.equals(\"(I)V\"))\n                        || (cls.equals(\"java/lang/Float\") && sig.equals(\"(F)V\"))\n                        || (cls.equals(\"java/lang/Double\") && sig.equals(\"(D)V\"))\n                        || (cls.equals(\"java/lang/Long\") && sig.equals(\"(J)V\"))\n                        || (cls.equals(\"java/lang/Byte\") && sig.equals(\"(B)V\"))\n                        || (cls.equals(\"java/lang/Character\") && sig.equals(\"(C)V\"))\n                        || (cls.equals(\"java/lang/Short\") && sig.equals(\"(S)V\"))\n                        || (cls.equals(\"java/lang/Boolean\") && sig.equals(\"(Z)V\"))) {\n                    primitiveObjCtorSeen = cls;\n                } else {\n                    primitiveObjCtorSeen = null;\n                }\n            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"toString\")\n                    && getClassConstantOperand().equals(primitiveObjCtorSeen)\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                primitiveObjCtorSeen = null;\n            } else {\n                primitiveObjCtorSeen = null;\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                ctorSeen = true;\n            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/Object\")\n                    && getNameConstantOperand().equals(\"getClass\") && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_NEW_FOR_GETCLASS\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n                ctorSeen = false;\n            } else {\n                ctorSeen = false;\n            }\n\n            if (jdk15ChecksEnabled && (seen == INVOKEVIRTUAL) && isMonitorWait(getNameConstantOperand(), getSigConstantOperand())) {\n                checkMonitorWait();\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")\n                    && getClassConstantOperand().equals(\"java/lang/Thread\")) {\n                String sig = getSigConstantOperand();\n                if (sig.equals(\"()V\") || sig.equals(\"(Ljava/lang/String;)V\")\n                        || sig.equals(\"(Ljava/lang/ThreadGroup;Ljava/lang/String;)V\")) {\n                    OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);\n                    if (!getMethodName().equals(\"<init>\") || invokedOn.getRegisterNumber() != 0) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DM_USELESS_THREAD\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                    }\n                }\n            }\n\n            if (seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/math/BigDecimal\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(D)V\")) {\n                OpcodeStack.Item top = stack.getStackItem(0);\n                Object value = top.getConstant();\n                if (value instanceof Double) {\n                    double arg = ((Double) value).doubleValue();\n                    String dblString = Double.toString(arg);\n                    String bigDecimalString = new BigDecimal(arg).toString();\n                    boolean ok = dblString.equals(bigDecimalString) || dblString.equals(bigDecimalString + \".0\");\n\n                    if (!ok) {\n                        boolean scary = dblString.length() <= 8 && bigDecimalString.length() > 12\n                                && dblString.toUpperCase().indexOf(\"E\") == -1;\n                        bugReporter.reportBug(new BugInstance(this, \"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE\",\n                                scary ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this).addCalledMethod(this)\n                                .addMethod(\"java.math.BigDecimal\", \"valueOf\", \"(D)Ljava/math/BigDecimal;\", true)\n                                .describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET).addString(dblString)\n                                .addString(bigDecimalString).addSourceLine(this));\n                    }\n                }\n\n            }\n\n        } finally {\n            prevOpcode = seen;\n        }\n    }","id":89502,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n        // System.out.printf(\"%3d %12s %s%n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n\n        if (seen == LDC || seen == LDC_W || seen == LDC2_W) {\n            Constant c = getConstantRefOperand();\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT)) {\n                BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                        .addString(\"Did you mean MICROS_PER_DAY\").addInt(MICROS_PER_DAY_OVERFLOWED_AS_INT)\n                        .describe(IntAnnotation.INT_VALUE);\n                accumulator.accumulateBug(bug, this);\n            }\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == Integer.MIN_VALUE\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == Long.MIN_VALUE)) {\n                sawLoadOfMinValue = true;\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n                absoluteValueAccumulator.clearBugs();\n            }\n        }\n\n\n        if (seen == LCMP) {\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            checkForCompatibleLongComparison(left, right);\n            checkForCompatibleLongComparison(right, left);\n        }\n\n        if (stack.getStackDepth() >= 2)\n            switch (seen) {\n            case IF_ICMPEQ:\n            case IF_ICMPNE:\n            case IF_ICMPLE:\n            case IF_ICMPGE:\n            case IF_ICMPLT:\n            case IF_ICMPGT:\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item0.getConstant() instanceof Integer) {\n                    OpcodeStack.Item tmp = item0;\n                    item0 = item1;\n                    item1 = tmp;\n                }\n                Object constant1 = item1.getConstant();\n                XMethod returnValueOf = item0.getReturnValueOf();\n                if (constant1 instanceof Integer\n                        && returnValueOf != null\n                        && returnValueOf.getName().equals(\"getYear\")\n                        && (returnValueOf.getClassName().equals(\"java.util.Date\") || returnValueOf.getClassName().equals(\n                                \"java.sql.Date\"))) {\n                    int year = (Integer) constant1;\n                    if (year > 1900)\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                                        .addString(\"Comparison of getYear does understand that it returns year-1900\")\n                                        .addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addInt(year)\n                                        .describe(IntAnnotation.INT_VALUE), this);\n                }\n            }\n\n        // System.out.printf(\"%4d %10s: %s\\n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n        if (seen == IFLT && stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n            sawCheckForNonNegativeSignedByte = getPC();\n        }\n\n        if (pendingAbsoluteValueBug != null) {\n            if (opcodesSincePendingAbsoluteValueBug == 0) {\n                opcodesSincePendingAbsoluteValueBug++;\n            } else {\n                if (seen == IREM) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    Object constantValue = top.getConstant();\n                    if (constantValue instanceof Number && Util.isPowerOfTwo(((Number) constantValue).intValue())) {\n                        pendingAbsoluteValueBug.setPriority(Priorities.LOW_PRIORITY);\n                    }\n                }\n                if (false)\n                    try {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen] + \":\"\n                                + OPCODE_NAMES[getNextOpcode()]);\n                    } catch (Exception e) {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen]);\n\n                    }\n                absoluteValueAccumulator.accumulateBug(pendingAbsoluteValueBug, pendingAbsoluteValueBugSourceLine);\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n            }\n        }\n\n        if (seen == INVOKESTATIC\n                && getClassConstantOperand().equals(\"org/easymock/EasyMock\")\n                && (getNameConstantOperand().equals(\"replay\") || getNameConstantOperand().equals(\"verify\") || getNameConstantOperand()\n                        .startsWith(\"reset\")) && getSigConstantOperand().equals(\"([Ljava/lang/Object;)V\")\n                && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0)\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD\", NORMAL_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        \n        if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"com/google/common/base/Preconditions\")\n             && getNameConstantOperand().equals(\"checkNotNull\")) {\n                      int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n\n            OpcodeStack.Item item = stack.getStackItem(args - 1);\n            Object o = item.getConstant();\n            if (o instanceof String) {\n\n                OpcodeStack.Item secondArgument = null;\n                String bugPattern = \"DMI_DOH\";\n                if (args > 1) {\n                    secondArgument = stack.getStackItem(args - 2);\n                    Object o2 = item.getConstant();\n                    if (!(o2 instanceof String)) {\n                        bugPattern = \"DMI_ARGUMENTS_WRONG_ORDER\";\n                    }\n                }\n\n                BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this).addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE)\n                        .addValueSource(secondArgument, this);\n\n                accumulator.accumulateBug(bug, this);\n            }\n\n            \n        }\n\n        if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)\n                && getSigConstantOperand().indexOf(\"Ljava/lang/Runnable;\") >= 0) {\n            SignatureParser parser = new SignatureParser(getSigConstantOperand());\n            int count = 0;\n            for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {\n                String parameter = i.next();\n                if (parameter.equals(\"Ljava/lang/Runnable;\")) {\n                    OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);\n                    if (\"Ljava/lang/Thread;\".equals(item.getSignature())) {\n                        accumulator.accumulateBug(new BugInstance(this, \"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED\",\n                                NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this), this);\n                    }\n\n                }\n            }\n\n        }\n\n        if (prevOpcode == I2L && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/Double\")\n                && getNameConstantOperand().equals(\"longBitsToDouble\")) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT\", HIGH_PRIORITY)\n                    .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && (freshRandomOnTos || freshRandomOneBelowTos)) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_RANDOM_USED_ONLY_ONCE\", HIGH_PRIORITY).addClassAndMethod(this)\n                    .addCalledMethod(this), this);\n\n        }\n\n        freshRandomOneBelowTos = freshRandomOnTos && isRegisterLoad();\n        freshRandomOnTos = seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/util/Random\")\n                && getNameConstantOperand().equals(\"<init>\");\n\n        if ((seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashMap\") && getNameConstantOperand().equals(\n                \"get\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Map\") && getNameConstantOperand()\n                        .equals(\"get\"))\n                || (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/HashSet\") && getNameConstantOperand()\n                        .equals(\"contains\"))\n                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals(\"java/util/Set\") && getNameConstantOperand()\n                        .equals(\"contains\"))) {\n            OpcodeStack.Item top = stack.getStackItem(0);\n            if (top.getSignature().equals(\"Ljava/net/URL;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_COLLECTION_OF_URLS\", HIGH_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n        }\n\n        /**\n         * Since you can change the number of core threads for a scheduled\n         * thread pool executor, disabling this for now\n         */\n        if (false && seen == INVOKESPECIAL\n                && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"<init>\")) {\n\n            int arguments = getNumberArguments(getSigConstantOperand());\n            OpcodeStack.Item item = stack.getStackItem(arguments - 1);\n            Object value = item.getConstant();\n            if (value instanceof Integer && ((Integer) value).intValue() == 0)\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS\",\n                        HIGH_PRIORITY).addClassAndMethod(this), this);\n\n        }\n        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"setMaximumPoolSize\")) {\n            accumulator.accumulateBug(new BugInstance(this,\n                    \"DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR\", HIGH_PRIORITY)\n                    .addClassAndMethod(this), this);\n        }\n        if (isEqualsObject && !reportedBadCastInEquals) {\n            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"isInstance\")\n                    && getClassConstantOperand().equals(\"java/lang/Class\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INSTANCEOF || seen == INVOKEVIRTUAL && getNameConstantOperand().equals(\"getClass\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == INVOKESPECIAL && getNameConstantOperand().equals(\"equals\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item1.getRegisterNumber() + item0.getRegisterNumber() == 1) {\n                    sawInstanceofCheck = true;\n                }\n            } else if (seen == CHECKCAST && !sawInstanceofCheck) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                if (item.getRegisterNumber() == 1) {\n                    if (getSizeOfSurroundingTryBlock(getPC()) == Integer.MAX_VALUE) {\n                        accumulator.accumulateBug(new BugInstance(this, \"BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS\",\n                                NORMAL_PRIORITY).addClassAndMethod(this), this);\n                    }\n\n                    reportedBadCastInEquals = true;\n                }\n            }\n        }\n        {\n            boolean foundVacuousComparison = false;\n            if (seen == IF_ICMPGT || seen == IF_ICMPLE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (seen == IF_ICMPLT || seen == IF_ICMPGE) {\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                Object rhsConstant = rhs.getConstant();\n                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MIN_VALUE) {\n                    foundVacuousComparison = true;\n                }\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                Object lhsConstant = lhs.getConstant();\n                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MAX_VALUE) {\n                    foundVacuousComparison = true;\n                }\n\n            }\n            if (foundVacuousComparison) {\n                accumulator.accumulateBug(new BugInstance(this, \"INT_VACUOUS_COMPARISON\", getBranchOffset() < 0 ? HIGH_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), this);\n            }\n\n        }\n\n        if (!sawLoadOfMinValue && seen == INVOKESTATIC && \n                ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"abs\")\n                ) {\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            int special = item0.getSpecialKind();\n            if (special == OpcodeStack.Item.RANDOM_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_RANDOM_INT\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n            else if (special == OpcodeStack.Item.HASHCODE_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_HASHCODE\", HIGH_PRIORITY)\n                        .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n        }\n\n        try {\n            int stackLoc = stackEntryThatMustBeNonnegative(seen);\n            if (stackLoc >= 0) {\n                OpcodeStack.Item tos = stack.getStackItem(stackLoc);\n                switch (tos.getSpecialKind()) {\n                case OpcodeStack.Item.HASHCODE_INT_REMAINDER:\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_REM_OF_HASHCODE\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n\n                    break;\n                case OpcodeStack.Item.RANDOM_INT:\n                case OpcodeStack.Item.RANDOM_INT_REMAINDER:\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"RV_REM_OF_RANDOM_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n\n                    break;\n                }\n\n            }\n            if (seen == IREM) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                Object constant0 = item0.getConstant();\n                if (constant0 instanceof Integer && ((Integer) constant0).intValue() == 1) {\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_REM_BY_1\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n\n            if (stack.getStackDepth() >= 1 && (seen == LOOKUPSWITCH || seen == TABLESWITCH)) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n                    int[] switchLabels = getSwitchLabels();\n                    int[] switchOffsets = getSwitchOffsets();\n                    for (int i = 0; i < switchLabels.length; i++) {\n                        int v = switchLabels[i];\n                        if (v <= -129 || v >= 128) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", HIGH_PRIORITY)\n                                    .addClassAndMethod(this).addInt(v).describe(IntAnnotation.INT_VALUE),\n                                    SourceLineAnnotation.fromVisitedInstruction(this, getPC() + switchOffsets[i]));\n                        }\n\n                    }\n                }\n            }\n            // check for use of signed byte where is it assumed it can be out of\n            // the -128...127 range\n            if (stack.getStackDepth() >= 2) {\n                switch (seen) {\n                case IF_ICMPEQ:\n                case IF_ICMPNE:\n                case IF_ICMPLT:\n                case IF_ICMPLE:\n                case IF_ICMPGE:\n                case IF_ICMPGT:\n                    OpcodeStack.Item item0 = stack.getStackItem(0);\n                    OpcodeStack.Item item1 = stack.getStackItem(1);\n                    int seen2 = seen;\n                    if (item0.getConstant() != null) {\n                        OpcodeStack.Item tmp = item0;\n                        item0 = item1;\n                        item1 = tmp;\n                        switch (seen) {\n                        case IF_ICMPLT:\n                            seen2 = IF_ICMPGT;\n                            break;\n                        case IF_ICMPGE:\n                            seen2 = IF_ICMPLE;\n                            break;\n                        case IF_ICMPGT:\n                            seen2 = IF_ICMPLT;\n                            break;\n                        case IF_ICMPLE:\n                            seen2 = IF_ICMPGE;\n                            break;\n\n                        }\n                    }\n                    Object constant1 = item1.getConstant();\n                    if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 <= -129 || v1 >= 128 || v1 == 127 && !(seen2 == IF_ICMPEQ || seen2 == IF_ICMPNE\n\n                        )) {\n                            int priority = HIGH_PRIORITY;\n                            if (v1 == 127) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 127 > x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 127 >= x : always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 127 < x : never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 127 <= x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 == 128) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 128 > x; always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 128 >= x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 128 < x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 128 <= x; never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 <= -129) {\n                                priority = NORMAL_PRIORITY;\n                            }\n\n                            if (getPC() - sawCheckForNonNegativeSignedByte < 10)\n                                priority++;\n\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", priority)\n                                    .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n\n                        }\n                    } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 < 0) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n                        }\n\n                    }\n\n                }\n            }\n\n            switch (seen) {\n            case IAND:\n            case LAND:\n            case IOR:\n            case LOR:\n            case IXOR:\n            case LXOR:\n                long badValue = (seen == IAND || seen == LAND) ? -1 : 0;\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                int prevOpcode = getPrevOpcode(1);\n                int prevPrevOpcode = getPrevOpcode(2);\n                if (rhs.hasConstantValue(badValue)\n                        && (prevOpcode == LDC || prevOpcode == ICONST_0 || prevOpcode == ICONST_M1 || prevOpcode == LCONST_0)\n                        && prevPrevOpcode != GOTO)\n                    reportVacuousBitOperation(seen, lhs);\n\n            }\n\n            if (checkForBitIorofSignedByte && seen != I2B) {\n                String pattern = (prevOpcode == LOR || prevOpcode == IOR) ? \"BIT_IOR_OF_SIGNED_BYTE\" : \"BIT_ADD_OF_SIGNED_BYTE\";\n                int priority = (prevOpcode == LOR || prevOpcode == LADD) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n                accumulator.accumulateBug(new BugInstance(this, pattern, priority).addClassAndMethod(this), this);\n\n                checkForBitIorofSignedByte = false;\n            } else if ((seen == IOR || seen == LOR || seen == IADD || seen == LADD) && stack.getStackDepth() >= 2) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n\n                int special0 = item0.getSpecialKind();\n                int special1 = item1.getSpecialKind();\n                if (special0 == OpcodeStack.Item.SIGNED_BYTE && special1 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item1.hasConstantValue(256) || special0 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item0.hasConstantValue(256) && special1 == OpcodeStack.Item.SIGNED_BYTE) {\n                    checkForBitIorofSignedByte = true;\n                } else {\n                    checkForBitIorofSignedByte = false;\n                }\n            } else {\n                checkForBitIorofSignedByte = false;\n            }\n\n            if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/String\") && getSigConstantOperand().startsWith(\"()\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"NP_IMMEDIATE_DEREFERENCE_OF_READLINE\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/io/BufferedReader\")\n                    && getNameConstantOperand().equals(\"ready\") && getSigConstantOperand().equals(\"()Z\")) {\n                sinceBufferedInputStreamReady = 0;\n            } else {\n                sinceBufferedInputStreamReady++;\n            }\n\n            prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n                    && getNameConstantOperand().equals(\"readLine\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\");\n\n            // System.out.println(randomNextIntState + \" \" + OPCODE_NAMES[seen]\n            // + \" \" + getMethodName());\n            switch (randomNextIntState) {\n            case 0:\n                if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(\"java/util/Random\")\n                        && getNameConstantOperand().equals(\"nextDouble\") || seen == INVOKESTATIC\n                        && ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals(\"random\")) {\n                    randomNextIntState = 1;\n                }\n                break;\n            case 1:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_01_TO_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    randomNextIntState = 0;\n                } else if (seen == DMUL)\n                    randomNextIntState = 4;\n                else if (seen == LDC2_W && getConstantRefOperand() instanceof ConstantDouble\n                        && ((ConstantDouble) getConstantRefOperand()).getBytes() == Integer.MIN_VALUE)\n                    randomNextIntState = 0;\n                else\n                    randomNextIntState = 2;\n\n                break;\n            case 2:\n                if (seen == I2D) {\n                    randomNextIntState = 3;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 3:\n                if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 4:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"DM_NEXTINT_VIA_NEXTDOUBLE\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n                }\n                randomNextIntState = 0;\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            if (isPublicStaticVoidMain\n                    && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().startsWith(\"javax/swing/\")\n                    && (getNameConstantOperand().equals(\"show\") && getSigConstantOperand().equals(\"()V\")\n                            || getNameConstantOperand().equals(\"pack\") && getSigConstantOperand().equals(\"()V\") || getNameConstantOperand()\n                            .equals(\"setVisible\") && getSigConstantOperand().equals(\"(Z)V\"))) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            // if ((seen == INVOKEVIRTUAL)\n            // && getClassConstantOperand().equals(\"java/lang/String\")\n            // && getNameConstantOperand().equals(\"substring\")\n            // && getSigConstantOperand().equals(\"(I)Ljava/lang/String;\")\n            // && stack.getStackDepth() > 1) {\n            // OpcodeStack.Item item = stack.getStackItem(0);\n            // Object o = item.getConstant();\n            // if (o != null && o instanceof Integer) {\n            // int v = ((Integer) o).intValue();\n            // if (v == 0)\n            // accumulator.accumulateBug(new BugInstance(this,\n            // \"DMI_USELESS_SUBSTRING\", NORMAL_PRIORITY)\n            // .addClassAndMethod(this)\n            // .addSourceLine(this));\n            // }\n            // }\n\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"isAnnotationPresent\")\n                    && getSigConstantOperand().equals(\"(Ljava/lang/Class;)Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                Object value = item.getConstant();\n                if (value instanceof String) {\n                    String annotationClassName = (String) value;\n                    boolean lacksClassfileRetention = AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()\n                            .lacksRuntimeRetention(annotationClassName.replace('/', '.'));\n                    if (lacksClassfileRetention) {\n                        ClassDescriptor annotationClass = DescriptorFactory.createClassDescriptor(annotationClassName);\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION\", HIGH_PRIORITY)\n                                        .addClassAndMethod(this).addCalledMethod(this).addClass(annotationClass)\n                                        .describe(ClassAnnotation.ANNOTATION_ROLE), this);\n                    }\n\n                }\n\n            }\n            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"next\")\n                    && getSigConstantOperand().equals(\"()Ljava/lang/Object;\") && getMethodName().equals(\"hasNext\")\n                    && getMethodSig().equals(\"()Z\") && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_CALLING_NEXT_FROM_HASNEXT\", item.isInitialParameter()\n                        && item.getRegisterNumber() == 0 ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(Ljava/lang/String;)V\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if (seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\") || seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().equals(\"java/lang/Runtime\")\n                    && getNameConstantOperand().equals(\"runFinalizersOnExit\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_RUN_FINALIZERS_ON_EXIT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n            }\n\n            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"()V\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n\n            }\n\n            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")\n                    && getNameConstantOperand().equals(\"exit\") && !getMethodName().equals(\"processWindowEvent\")\n                    && !getMethodName().startsWith(\"windowClos\") && getMethodName().indexOf(\"exit\") == -1\n                    && getMethodName().indexOf(\"Exit\") == -1 && getMethodName().indexOf(\"crash\") == -1\n                    && getMethodName().indexOf(\"Crash\") == -1 && getMethodName().indexOf(\"die\") == -1\n                    && getMethodName().indexOf(\"Die\") == -1 && getMethodName().indexOf(\"main\") == -1) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_EXIT\", getMethod().isStatic() ? LOW_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));\n            }\n            if (((seen == INVOKESTATIC && getClassConstantOperand().equals(\"java/lang/System\")) || (seen == INVOKEVIRTUAL && getClassConstantOperand()\n                    .equals(\"java/lang/Runtime\")))\n                    && getNameConstantOperand().equals(\"gc\")\n                    && getSigConstantOperand().equals(\"()V\")\n                    && !getDottedClassName().startsWith(\"java.lang\")\n                    && !getMethodName().startsWith(\"gc\") && !getMethodName().endsWith(\"gc\")) {\n                if (gcInvocationBugReport == null) {\n                    // System.out.println(\"Saw call to GC\");\n                    if (isPublicStaticVoidMain) {\n                        // System.out.println(\"Skipping GC complaint in main method\");\n                        return;\n                    }\n                    if (isTestMethod(getMethod())) {\n                        return;\n                    }\n                    // Just save this report in a field; it will be flushed\n                    // IFF there were no calls to System.currentTimeMillis();\n                    // in the method.\n                    gcInvocationBugReport = new BugInstance(this, \"DM_GC\", HIGH_PRIORITY).addClassAndMethod(this).addSourceLine(\n                            this);\n                    gcInvocationPC = getPC();\n                    // System.out.println(\"GC invocation at pc \" + PC);\n                }\n            }\n            if (!isSynthetic && (seen == INVOKESPECIAL) && getClassConstantOperand().equals(\"java/lang/Boolean\")\n                    && getNameConstantOperand().equals(\"<init>\") && !getClassName().equals(\"java/lang/Boolean\")) {\n                int majorVersion = getThisClass().getMajor();\n                if (majorVersion >= MAJOR_1_4) {\n                    accumulator.accumulateBug(new BugInstance(this, \"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals(\"java/lang/System\")\n                    && (getNameConstantOperand().equals(\"currentTimeMillis\") || getNameConstantOperand().equals(\"nanoTime\"))) {\n                sawCurrentTimeMillis = true;\n            }\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && getNameConstantOperand().equals(\"toString\") && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator\n                        .accumulateBug(new BugInstance(this, \"DM_STRING_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/String\")\n                    && (getNameConstantOperand().equals(\"toUpperCase\") || getNameConstantOperand().equals(\"toLowerCase\"))\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_CONVERT_CASE\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                String cls = getClassConstantOperand();\n                String sig = getSigConstantOperand();\n                if ((cls.equals(\"java/lang/Integer\") && sig.equals(\"(I)V\"))\n                        || (cls.equals(\"java/lang/Float\") && sig.equals(\"(F)V\"))\n                        || (cls.equals(\"java/lang/Double\") && sig.equals(\"(D)V\"))\n                        || (cls.equals(\"java/lang/Long\") && sig.equals(\"(J)V\"))\n                        || (cls.equals(\"java/lang/Byte\") && sig.equals(\"(B)V\"))\n                        || (cls.equals(\"java/lang/Character\") && sig.equals(\"(C)V\"))\n                        || (cls.equals(\"java/lang/Short\") && sig.equals(\"(S)V\"))\n                        || (cls.equals(\"java/lang/Boolean\") && sig.equals(\"(Z)V\"))) {\n                    primitiveObjCtorSeen = cls;\n                } else {\n                    primitiveObjCtorSeen = null;\n                }\n            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && getNameConstantOperand().equals(\"toString\")\n                    && getClassConstantOperand().equals(primitiveObjCtorSeen)\n                    && getSigConstantOperand().equals(\"()Ljava/lang/String;\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                primitiveObjCtorSeen = null;\n            } else {\n                primitiveObjCtorSeen = null;\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")) {\n                ctorSeen = true;\n            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && getClassConstantOperand().equals(\"java/lang/Object\")\n                    && getNameConstantOperand().equals(\"getClass\") && getSigConstantOperand().equals(\"()Ljava/lang/Class;\")) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_NEW_FOR_GETCLASS\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n                ctorSeen = false;\n            } else {\n                ctorSeen = false;\n            }\n\n            if (jdk15ChecksEnabled && (seen == INVOKEVIRTUAL) && isMonitorWait(getNameConstantOperand(), getSigConstantOperand())) {\n                checkMonitorWait();\n            }\n\n            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals(\"<init>\")\n                    && getClassConstantOperand().equals(\"java/lang/Thread\")) {\n                String sig = getSigConstantOperand();\n                if (sig.equals(\"()V\") || sig.equals(\"(Ljava/lang/String;)V\")\n                        || sig.equals(\"(Ljava/lang/ThreadGroup;Ljava/lang/String;)V\")) {\n                    OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);\n                    if (!getMethodName().equals(\"<init>\") || invokedOn.getRegisterNumber() != 0) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DM_USELESS_THREAD\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                    }\n                }\n            }\n\n            if (seen == INVOKESPECIAL && getClassConstantOperand().equals(\"java/math/BigDecimal\")\n                    && getNameConstantOperand().equals(\"<init>\") && getSigConstantOperand().equals(\"(D)V\")) {\n                OpcodeStack.Item top = stack.getStackItem(0);\n                Object value = top.getConstant();\n                if (value instanceof Double) {\n                    double arg = ((Double) value).doubleValue();\n                    String dblString = Double.toString(arg);\n                    String bigDecimalString = new BigDecimal(arg).toString();\n                    boolean ok = dblString.equals(bigDecimalString) || dblString.equals(bigDecimalString + \".0\");\n\n                    if (!ok) {\n                        boolean scary = dblString.length() <= 8 && bigDecimalString.length() > 12\n                                && dblString.toUpperCase().indexOf(\"E\") == -1;\n                        bugReporter.reportBug(new BugInstance(this, \"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE\",\n                                scary ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this).addCalledMethod(this)\n                                .addMethod(\"java.math.BigDecimal\", \"valueOf\", \"(D)Ljava/math/BigDecimal;\", true)\n                                .describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET).addString(dblString)\n                                .addString(bigDecimalString).addSourceLine(this));\n                    }\n                }\n\n            }\n\n        } finally {\n            prevOpcode = seen;\n        }\n    }","commit_id":"da0904b491e419e40deec6be1cdcbced0aa15649","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void visit(Code obj) {\n        if (isInnerClass  && !BCELUtil.isSynthetic(getMethod())) {\n            //            System.out.println(getFullyQualifiedMethodName());\n            super.visit(obj);\n        }\n    }","id":89503,"modified_method":"@Override\n    public void visit(Code obj) {\n        if (isInnerClass  && !BCELUtil.isSynthetic(getMethod())) {\n            super.visit(obj);\n            iteratorBug = null;\n        }\n    }","commit_id":"a62701213ceaf1ec200089fd1c4c2da70740294f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n        //        System.out.printf(\"%3d : %s%n\", getPC(), OPCODE_NAMES[seen]);\n        if (seen != INVOKEVIRTUAL) {\n            return;\n        }\n        if (!getClassName().equals(getClassConstantOperand())) {\n            return;\n        }\n        XMethod invokedMethod = XFactory.createXMethod(getDottedClassConstantOperand(), getNameConstantOperand(),\n                getSigConstantOperand(), false);\n        if (invokedMethod.isResolved() && invokedMethod.getClassName().equals(getDottedClassConstantOperand())\n                || invokedMethod.isSynthetic()) {\n            return;\n        }\n        if(getStack().getStackItem(getNumberArguments(getSigConstantOperand())).getRegisterNumber() != 0) {\n            // called not for this object\n            return;\n        }\n        // method is inherited\n        String possibleTargetClass = getDottedClassName();\n        String superClassName = getDottedSuperclassName();\n        while (true) {\n            int i = possibleTargetClass.lastIndexOf('$');\n            if (i <= 0) {\n                break;\n            }\n            possibleTargetClass = possibleTargetClass.substring(0, i);\n            if (possibleTargetClass.equals(superClassName)) {\n                break;\n            }\n            XMethod alternativeMethod = XFactory.createXMethod(possibleTargetClass, getNameConstantOperand(),\n                    getSigConstantOperand(), false);\n            if (alternativeMethod.isResolved() && alternativeMethod.getClassName().equals(possibleTargetClass)) {\n                String targetPackage = invokedMethod.getPackageName();\n                String alternativePackage = alternativeMethod.getPackageName();\n                int priority = HIGH_PRIORITY;\n                if (targetPackage.equals(alternativePackage)) {\n                    priority++;\n                }\n                if (targetPackage.startsWith(\"javax.swing\") || targetPackage.startsWith(\"java.awt\")) {\n                    priority += 2;\n                }\n                if (invokedMethod.getName().equals(getMethodName())) {\n                    priority++;\n                }\n\n                //                System.out.println(\"Found it\");\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD\", priority)\n                        .addClassAndMethod(this).addMethod(invokedMethod).describe(\"METHOD_INHERITED\")\n                        .addMethod(alternativeMethod).describe(\"METHOD_ALTERNATIVE_TARGET\"), this);\n                break;\n            }\n        }\n\n    }","id":89504,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n        if (iteratorBug != null) {\n            if (isRegisterStore()) {\n                LocalVariableTable lvt = getMethod().getLocalVariableTable();\n                if (lvt != null) {\n                    LocalVariable localVariable = lvt.getLocalVariable(getRegisterOperand(), getNextPC());\n                    if(localVariable == null || localVariable.getName().endsWith(\"$\")) {\n                        // iterator() result is stored to the synthetic variable which has no name in LVT or name is suffixed with '$'\n                        // Looks like it's for-each cycle like for(Object obj : this)\n                        // Do not report such case\n                        iteratorBug = null;\n                    }\n                }\n            }\n            if(iteratorBug != null) {\n                bugAccumulator.accumulateBug(iteratorBug, this);\n            }\n            iteratorBug = null;\n        }\n        if (seen != INVOKEVIRTUAL) {\n            return;\n        }\n        if (!getClassName().equals(getClassConstantOperand())) {\n            return;\n        }\n        XMethod invokedMethod = XFactory.createXMethod(getDottedClassConstantOperand(), getNameConstantOperand(),\n                getSigConstantOperand(), false);\n        if (invokedMethod.isResolved() && invokedMethod.getClassName().equals(getDottedClassConstantOperand())\n                || invokedMethod.isSynthetic()) {\n            return;\n        }\n        if(getStack().getStackItem(getNumberArguments(getSigConstantOperand())).getRegisterNumber() != 0) {\n            // called not for this object\n            return;\n        }\n        // method is inherited\n        String possibleTargetClass = getDottedClassName();\n        String superClassName = getDottedSuperclassName();\n        while (true) {\n            int i = possibleTargetClass.lastIndexOf('$');\n            if (i <= 0) {\n                break;\n            }\n            possibleTargetClass = possibleTargetClass.substring(0, i);\n            if (possibleTargetClass.equals(superClassName)) {\n                break;\n            }\n            XMethod alternativeMethod = XFactory.createXMethod(possibleTargetClass, getNameConstantOperand(),\n                    getSigConstantOperand(), false);\n            if (alternativeMethod.isResolved() && alternativeMethod.getClassName().equals(possibleTargetClass)) {\n                String targetPackage = invokedMethod.getPackageName();\n                String alternativePackage = alternativeMethod.getPackageName();\n                int priority = HIGH_PRIORITY;\n                if (targetPackage.equals(alternativePackage)) {\n                    priority++;\n                }\n                if (targetPackage.startsWith(\"javax.swing\") || targetPackage.startsWith(\"java.awt\")) {\n                    priority += 2;\n                }\n                if (invokedMethod.getName().equals(getMethodName())) {\n                    priority++;\n                }\n\n                BugInstance bug = new BugInstance(this, \"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD\", priority)\n                .addClassAndMethod(this).addMethod(invokedMethod).describe(\"METHOD_INHERITED\")\n                .addMethod(alternativeMethod).describe(\"METHOD_ALTERNATIVE_TARGET\");\n                if(invokedMethod.getName().equals(\"iterator\") && invokedMethod.getSignature().equals(\"()Ljava/util/Iterator;\")\n                        && Subtypes2.instanceOf(getDottedClassName(), \"java.lang.Iterable\")) {\n                    iteratorBug = bug;\n                } else {\n                    bugAccumulator.accumulateBug(bug, this);\n                }\n                break;\n            }\n        }\n    }","commit_id":"a62701213ceaf1ec200089fd1c4c2da70740294f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public final void reportBug(BugInstance bugInstance) {\n\t\tif (priorityThreshold == 0) {\n\t\t\tthrow new IllegalStateException(\"Priority threshold not set\");\n\t\t}\n\t\tif (!analysisUnderway) {\n\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\trelaxed = true;\n\t\t\t}\n\n\t\t\tanalysisUnderway = true;\n\t\t}\n\t\tClassAnnotation primaryClass = bugInstance.getPrimaryClass();\n\t\tif (primaryClass != null && !AnalysisContext.currentAnalysisContext().isApplicationClass(primaryClass.getClassName())) {\n\t\t\tif(DEBUG) {\n\t\t\t\tSystem.out.println(\"AbstractBugReporter: Filtering due to non-primary class\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (bugInstance.getPriority() <= priorityThreshold  && bugInstance.getBugRank() <= rankThreshold \n\t\t\t\t|| relaxed) {\n\t\t\tdoReportBug(bugInstance);\n\t\t} else {\n\t\t\tif(DEBUG) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"AbstractBugReporter: Filtering due to priorityThreshold \" +\n\t\t\t\t\tbugInstance.getPriority() + \" > \" + priorityThreshold);\n\t\t\t}\n\t\t}\n\t}","id":89505,"modified_method":"public final void reportBug(BugInstance bugInstance) {\n\t\tif (priorityThreshold == 0) {\n\t\t\tthrow new IllegalStateException(\"Priority threshold not set\");\n\t\t}\n\t\tif (!analysisUnderway) {\n\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\trelaxed = true;\n\t\t\t}\n\n\t\t\tanalysisUnderway = true;\n\t\t}\n\t\tClassAnnotation primaryClass = bugInstance.getPrimaryClass();\n\t\tif (primaryClass != null && !AnalysisContext.currentAnalysisContext().isApplicationClass(primaryClass.getClassName())) {\n\t\t\tif(DEBUG) {\n\t\t\t\tSystem.out.println(\"AbstractBugReporter: Filtering due to non-primary class\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint priority = bugInstance.getPriority();\n\t\tint bugRank = bugInstance.getBugRank();\n\t\tif (priority <= priorityThreshold  && bugRank <= rankThreshold \n\t\t\t\t|| relaxed) {\n\t\t\tdoReportBug(bugInstance);\n\t\t} else {\n\t\t\tif(DEBUG) {\n\t\t\t\tif (priority <= priorityThreshold) \n\t\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"AbstractBugReporter: Filtering due to priorityThreshold \" +\n\t\t\t\t\tpriority + \" > \" + priorityThreshold);\n\t\t\t\telse System.out.println(\n\t\t\t\t\t\t\"AbstractBugReporter: Filtering due to rankThreshold \" +\n\t\t\t\t\t\tbugRank + \" > \" + rankThreshold);\n\t\t\t}\n\t\t}\n\t}","commit_id":"bdb91b8b5e0dc0cc9fcedc7c02c18586aadc7ddc","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n  public void sawOpcode(int seen) {\n\t// only acts on constructor invoke\n\tif (seen != INVOKESPECIAL) {\n\t  return;\n\t}\n\n\tif (!\"<init>\".equals(getNameConstantOperand())) {\n\t  return;\n\t}\n\tString cls = getClassConstantOperand(); \n\tXMethod shouldCall = boxClasses.get(cls);\n\tif (shouldCall == null) {\n\t  return;\n\t}\n\n\tif (!shouldCall.getSignature().substring(0,3).equals(getSigConstantOperand().substring(0,3))) {\n\t  return;\n\t}\n\n\tint prio;\n\tString type;\n\tif (cls.equals(\"java/lang/Float\") || cls.equals(\"java/lang/Double\")) {\n\t  prio = LOW_PRIORITY;\n\t  type = \"DM_FP_NUMBER_CTOR\";\n\t} else {\n\t  prio = NORMAL_PRIORITY;\n\t  type = \"DM_NUMBER_CTOR\";\n\t}\n\n\tbugAccumulator.accumulateBug(\n\t\t\tnew BugInstance(this, type, prio)\n\t\t\t  .addClass(this)\n\t\t\t  .addMethod(this)\n\t\t\t  .addCalledMethod(this)\n\t\t\t  .addMethod(shouldCall).describe(\"SHOULD_CALL\"), \n\t\t\tthis);\n  }","id":89506,"modified_method":"@Override\n  public void sawOpcode(int seen) {\n\t// only acts on constructor invoke\n\tif (seen != INVOKESPECIAL) {\n\t  return;\n\t}\n\n\tif (!\"<init>\".equals(getNameConstantOperand())) {\n\t  return;\n\t}\n\tString cls = getClassConstantOperand(); \n\tXMethod shouldCall = boxClasses.get(cls);\n\tif (shouldCall == null) {\n\t  return;\n\t}\n\n\tif (!shouldCall.getSignature().substring(0,3).equals(getSigConstantOperand().substring(0,3))) {\n\t  return;\n\t}\n\n\tint prio;\n\tString type;\n\tif (cls.equals(\"java/lang/Float\") || cls.equals(\"java/lang/Double\")) {\n\t  prio = LOW_PRIORITY;\n\t  type = \"DM_FP_NUMBER_CTOR\";\n\t} else {\n\t  prio = NORMAL_PRIORITY;\n\t  type = \"DM_NUMBER_CTOR\";\n\t}\n\n\tBugInstance bug = new BugInstance(this, type, prio)\n      .addClass(this)\n      .addMethod(this)\n      .addCalledMethod(this)\n      .addMethod(shouldCall).describe(\"SHOULD_CALL\");\n\tbugAccumulator.accumulateBug(\n\t\t\tbug, \n\t\t\tthis);\n  }","commit_id":"bdb91b8b5e0dc0cc9fcedc7c02c18586aadc7ddc","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Test\n    public void producedStringMessageIsReceivedByKafka() throws InterruptedException, IOException {\n        int messageInTopic = 10;\n        int messageInOtherTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);\n\n        sendMessagesInRoute(messageInTopic, stringsTemplate, \"IT test message\", KafkaConstants.PARTITION_KEY, \"1\");\n        sendMessagesInRoute(messageInOtherTopic, stringsTemplate, \"IT test message in other topic\", KafkaConstants.PARTITION_KEY, \"1\", KafkaConstants.TOPIC, TOPIC_STRINGS_IN_HEADER);\n\n        createKafkaMessageConsumer(stringsConsumerConn, TOPIC_STRINGS, TOPIC_STRINGS_IN_HEADER, messagesLatch);\n\n        boolean allMessagesReceived = messagesLatch.await(200, TimeUnit.MILLISECONDS);\n\n        assertTrue(\"Not all messages were published to the kafka topics. Not received: \" + messagesLatch.getCount(), allMessagesReceived);\n    }","id":89507,"modified_method":"@Test\n    public void producedStringMessageIsReceivedByKafka() throws InterruptedException, IOException {\n        int messageInTopic = 10;\n        int messageInOtherTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);\n\n        sendMessagesInRoute(messageInTopic, stringsTemplate, \"IT test message\", KafkaConstants.PARTITION_KEY, \"1\");\n        sendMessagesInRoute(messageInOtherTopic, stringsTemplate, \"IT test message in other topic\", KafkaConstants.PARTITION_KEY, \"1\", KafkaConstants.TOPIC, TOPIC_STRINGS_IN_HEADER);\n\n        createKafkaMessageConsumer(stringsConsumerConn, TOPIC_STRINGS, TOPIC_STRINGS_IN_HEADER, messagesLatch);\n\n        boolean allMessagesReceived = messagesLatch.await(200, TimeUnit.MILLISECONDS);\n\n        assertTrue(\"Not all messages were published to the kafka topics. Not received: \" + messagesLatch.getCount(), allMessagesReceived);\n\n        List<Exchange> exchangeList= mockEndpoint.getExchanges();\n        assertEquals(\"Fifteen Exchanges are expected\",exchangeList.size(),15);\n        for (Exchange exchange : exchangeList) {\n            List<RecordMetadata> recordMetaData1 =  (List<RecordMetadata>)(exchange.getIn().getHeader(KafkaConstants.KAFKA_RECORDMETA));\n            assertEquals(\"One RecordMetadata is expected.\",recordMetaData1.size(),1);\n            assertTrue(\"Offset is positive\",recordMetaData1.get(0).offset() >= 0);\n            assertTrue(\"Topic Name start with 'test'\",recordMetaData1.get(0).topic().startsWith(\"test\"));\n\n        }\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void producedStringCollectionMessageIsReceivedByKafka() throws InterruptedException, IOException {\n        int messageInTopic = 10;\n        int messageInOtherTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);\n\n        List<String> msgs = new ArrayList<String>();\n        for (int x = 0; x < messageInTopic; x++) {\n            msgs.add(\"Message \" + x);\n        }\n        \n        sendMessagesInRoute(1, stringsTemplate, msgs, KafkaConstants.PARTITION_KEY, \"1\");\n        msgs = new ArrayList<String>();\n        for (int x = 0; x < messageInOtherTopic; x++) {\n            msgs.add(\"Other Message \" + x);\n        }\n        sendMessagesInRoute(1, stringsTemplate, msgs, KafkaConstants.PARTITION_KEY, \"1\", KafkaConstants.TOPIC, TOPIC_STRINGS_IN_HEADER);\n\n        createKafkaMessageConsumer(stringsConsumerConn, TOPIC_STRINGS, TOPIC_STRINGS_IN_HEADER, messagesLatch);\n\n        boolean allMessagesReceived = messagesLatch.await(200, TimeUnit.MILLISECONDS);\n\n        assertTrue(\"Not all messages were published to the kafka topics. Not received: \" + messagesLatch.getCount(), allMessagesReceived);\n    }","id":89508,"modified_method":"@Test\n    public void producedStringCollectionMessageIsReceivedByKafka() throws InterruptedException, IOException {\n        int messageInTopic = 10;\n        int messageInOtherTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);\n\n        List<String> msgs = new ArrayList<String>();\n        for (int x = 0; x < messageInTopic; x++) {\n            msgs.add(\"Message \" + x);\n        }\n\n        sendMessagesInRoute(1, stringsTemplate, msgs, KafkaConstants.PARTITION_KEY, \"1\");\n        msgs = new ArrayList<String>();\n        for (int x = 0; x < messageInOtherTopic; x++) {\n            msgs.add(\"Other Message \" + x);\n        }\n        sendMessagesInRoute(1, stringsTemplate, msgs, KafkaConstants.PARTITION_KEY, \"1\", KafkaConstants.TOPIC, TOPIC_STRINGS_IN_HEADER);\n\n        createKafkaMessageConsumer(stringsConsumerConn, TOPIC_STRINGS, TOPIC_STRINGS_IN_HEADER, messagesLatch);\n\n        boolean allMessagesReceived = messagesLatch.await(200, TimeUnit.MILLISECONDS);\n\n        assertTrue(\"Not all messages were published to the kafka topics. Not received: \" + messagesLatch.getCount(), allMessagesReceived);\n        List<Exchange> exchangeList= mockEndpoint.getExchanges();\n        assertEquals(\"Two Exchanges are expected\",exchangeList.size(),2);\n        Exchange e1 = exchangeList.get(0);\n        List<RecordMetadata> recordMetaData1 =  (List<RecordMetadata>)(e1.getIn().getHeader(KafkaConstants.KAFKA_RECORDMETA));\n        assertEquals(\"Ten RecordMetadata is expected.\",recordMetaData1.size(),10);\n        for (RecordMetadata recordMeta : recordMetaData1) {\n            assertTrue(\"Offset is positive\",recordMeta.offset() >= 0);\n            assertTrue(\"Topic Name start with 'test'\",recordMeta.topic().startsWith(\"test\"));\n        }\n        Exchange e2 = exchangeList.get(1);\n        List<RecordMetadata> recordMetaData2 =  (List<RecordMetadata>)(e2.getIn().getHeader(KafkaConstants.KAFKA_RECORDMETA));\n        assertEquals(\"Five RecordMetadata is expected.\",recordMetaData2.size(),5);\n        for (RecordMetadata recordMeta : recordMetaData2) {\n            assertTrue(\"Offset is positive\",recordMeta.offset() >= 0);\n            assertTrue(\"Topic Name start with 'test'\",recordMeta.topic().startsWith(\"test\"));\n        }\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"direct:startStrings\").to(toStrings);\n\n                from(\"direct:startBytes\").to(toBytes);\n            }\n        };\n    }","id":89509,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"direct:startStrings\").to(toStrings).to(mockEndpoint);\n\n                from(\"direct:startBytes\").to(toBytes).to(mockEndpoint);\n            }\n        };\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void producedBytesMessageIsReceivedByKafka() throws InterruptedException, IOException {\n        int messageInTopic = 10;\n        int messageInOtherTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);\n\n        Map<String, Object> inTopicHeaders = new HashMap<String, Object>();\n        inTopicHeaders.put(KafkaConstants.PARTITION_KEY, \"1\".getBytes());\n        sendMessagesInRoute(messageInTopic, bytesTemplate, \"IT test message\".getBytes(), inTopicHeaders);\n\n        Map<String, Object> otherTopicHeaders = new HashMap<String, Object>();\n        otherTopicHeaders.put(KafkaConstants.PARTITION_KEY, \"1\".getBytes());\n        otherTopicHeaders.put(KafkaConstants.TOPIC, TOPIC_BYTES_IN_HEADER);\n        sendMessagesInRoute(messageInOtherTopic, bytesTemplate, \"IT test message in other topic\".getBytes(), otherTopicHeaders);\n\n        createKafkaBytesMessageConsumer(bytesConsumerConn, TOPIC_BYTES, TOPIC_BYTES_IN_HEADER, messagesLatch);\n\n        boolean allMessagesReceived = messagesLatch.await(200, TimeUnit.MILLISECONDS);\n\n        assertTrue(\"Not all messages were published to the kafka topics. Not received: \" + messagesLatch.getCount(), allMessagesReceived);\n    }","id":89510,"modified_method":"@Test\n    public void producedBytesMessageIsReceivedByKafka() throws InterruptedException, IOException {\n        int messageInTopic = 10;\n        int messageInOtherTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);\n\n        Map<String, Object> inTopicHeaders = new HashMap<String, Object>();\n        inTopicHeaders.put(KafkaConstants.PARTITION_KEY, \"1\".getBytes());\n        sendMessagesInRoute(messageInTopic, bytesTemplate, \"IT test message\".getBytes(), inTopicHeaders);\n\n        Map<String, Object> otherTopicHeaders = new HashMap<String, Object>();\n        otherTopicHeaders.put(KafkaConstants.PARTITION_KEY, \"1\".getBytes());\n        otherTopicHeaders.put(KafkaConstants.TOPIC, TOPIC_BYTES_IN_HEADER);\n        sendMessagesInRoute(messageInOtherTopic, bytesTemplate, \"IT test message in other topic\".getBytes(), otherTopicHeaders);\n\n        createKafkaBytesMessageConsumer(bytesConsumerConn, TOPIC_BYTES, TOPIC_BYTES_IN_HEADER, messagesLatch);\n\n        boolean allMessagesReceived = messagesLatch.await(200, TimeUnit.MILLISECONDS);\n\n        assertTrue(\"Not all messages were published to the kafka topics. Not received: \" + messagesLatch.getCount(), allMessagesReceived);\n\n        List<Exchange> exchangeList= mockEndpoint.getExchanges();\n        assertEquals(\"Fifteen Exchanges are expected\",exchangeList.size(),15);\n        for (Exchange exchange : exchangeList) {\n            List<RecordMetadata> recordMetaData1 =  (List<RecordMetadata>)(exchange.getIn().getHeader(KafkaConstants.KAFKA_RECORDMETA));\n            assertEquals(\"One RecordMetadata is expected.\",recordMetaData1.size(),1);\n            assertTrue(\"Offset is positive\",recordMetaData1.get(0).offset() >= 0);\n            assertTrue(\"Topic Name start with 'test'\",recordMetaData1.get(0).topic().startsWith(\"test\"));\n\n        }\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings({\"unchecked\"})\n    public KafkaProducerTest() throws Exception {\n        endpoint = new KafkaEndpoint(\n                \"kafka:broker1:1234,broker2:4567?topic=sometopic\", null);\n        endpoint.setBrokers(\"broker1:1234,broker2:4567\");\n        producer = new KafkaProducer(endpoint);\n\n        RecordMetadata rm = new RecordMetadata(null, 1, 1);\n        Future future = Mockito.mock(Future.class);\n        Mockito.when(future.get()).thenReturn(rm);\n        org.apache.kafka.clients.producer.KafkaProducer kp = Mockito.mock(org.apache.kafka.clients.producer.KafkaProducer.class);\n        Mockito.when(kp.send(Mockito.any(ProducerRecord.class))).thenReturn(future);\n\n        producer.setKafkaProducer(kp);\n    }","id":89511,"modified_method":"@SuppressWarnings({\"unchecked\"})\n    public KafkaProducerTest() throws Exception {\n        endpoint = new KafkaEndpoint(\n                \"kafka:broker1:1234,broker2:4567?topic=sometopic\", null);\n        endpoint.setBrokers(\"broker1:1234,broker2:4567\");\n        producer = new KafkaProducer(endpoint);\n\n        RecordMetadata rm = new RecordMetadata(null, 1, 1);\n        Future future = Mockito.mock(Future.class);\n        Mockito.when(future.get()).thenReturn(rm);\n        org.apache.kafka.clients.producer.KafkaProducer kp = Mockito.mock(org.apache.kafka.clients.producer.KafkaProducer.class);\n        Mockito.when(kp.send(Mockito.any(ProducerRecord.class))).thenReturn(future);\n\n        producer.setKafkaProducer(kp);\n        producer.setWorkerPool(Executors.newFixedThreadPool(1));\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processSendsMessageWithTopicHeaderAndNoTopicInEndPoint() throws Exception {\n        endpoint.setTopic(null);\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        in.setHeader(KafkaConstants.TOPIC, \"anotherTopic\");\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        producer.process(exchange);\n\n        verifySendMessage(\"anotherTopic\");\n    }","id":89512,"modified_method":"@Test\n    public void processSendsMessageWithTopicHeaderAndNoTopicInEndPoint() throws Exception {\n        endpoint.setTopic(null);\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        in.setHeader(KafkaConstants.TOPIC, \"anotherTopic\");\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        producer.process(exchange);\n\n        verifySendMessage(\"anotherTopic\");\n        assertRecordMetadataExists();\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processSendsMesssageWithPartitionKeyHeader() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n        producer.process(exchange);\n        verifySendMessage(\"4\", \"someTopic\", \"someKey\");\n    }","id":89513,"modified_method":"@Test\n    public void processSendsMesssageWithPartitionKeyHeader() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n\n        producer.process(exchange);\n\n        verifySendMessage(\"4\", \"someTopic\", \"someKey\");\n        assertRecordMetadataExists();\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test(expected = Exception.class)\n    @SuppressWarnings({\"unchecked\"})\n    public void processSendsMessageWithException() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        // setup the exception here\n        org.apache.kafka.clients.producer.KafkaProducer kp = producer.getKafkaProducer();\n        Mockito.when(kp.send(Mockito.any(ProducerRecord.class))).thenThrow(new ApiException());\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange);\n    }","id":89514,"modified_method":"@Test(expected = Exception.class)\n    @SuppressWarnings({\"unchecked\"})\n    public void processSendsMessageWithException() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        // setup the exception here\n        org.apache.kafka.clients.producer.KafkaProducer kp = producer.getKafkaProducer();\n        Mockito.when(kp.send(Mockito.any(ProducerRecord.class))).thenThrow(new ApiException());\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange);\n\n        assertRecordMetadataExists();\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test(expected = CamelException.class)\n    public void processRequiresTopicInEndpointOrInHeader() throws Exception {\n        endpoint.setTopic(null);\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n        producer.process(exchange);\n    }","id":89515,"modified_method":"@Test(expected = CamelException.class)\n    public void processRequiresTopicInEndpointOrInHeader() throws Exception {\n        endpoint.setTopic(null);\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange);\n\n        assertRecordMetadataExists();\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processAsyncSendsMessage() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange, callback);\n\n        Mockito.verify(producer.getKafkaProducer()).send(Matchers.any(ProducerRecord.class), Matchers.any(Callback.class));\n    }","id":89516,"modified_method":"@Test\n    public void processAsyncSendsMessage() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange, callback);\n\n        ArgumentCaptor<Callback> callBackCaptor = ArgumentCaptor.forClass(Callback.class);\n        Mockito.verify(producer.getKafkaProducer()).send(Matchers.any(ProducerRecord.class), callBackCaptor.capture());\n        Callback kafkaCallback = callBackCaptor.getValue();\n        kafkaCallback.onCompletion(new RecordMetadata(null, 1, 1),null);\n        assertRecordMetadataExists();\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processSendsMesssageWithMessageKeyHeader() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n\n        producer.process(exchange);\n\n        verifySendMessage(\"someTopic\", \"someKey\");\n    }","id":89517,"modified_method":"@Test\n    public void processSendsMesssageWithMessageKeyHeader() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n\n        producer.process(exchange);\n\n        verifySendMessage(\"someTopic\", \"someKey\");\n        assertRecordMetadataExists();\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processSendMessageWithBridgeEndpoint() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        endpoint.setBridgeEndpoint(true);\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n        in.setHeader(KafkaConstants.TOPIC, \"anotherTopic\");\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n        producer.process(exchange);\n\n        verifySendMessage(\"4\", \"someTopic\", \"someKey\");\n    }","id":89518,"modified_method":"@Test\n    public void processSendMessageWithBridgeEndpoint() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        endpoint.setBridgeEndpoint(true);\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n        in.setHeader(KafkaConstants.TOPIC, \"anotherTopic\");\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange);\n\n        verifySendMessage(\"4\", \"someTopic\", \"someKey\");\n        assertRecordMetadataExists();\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processAsyncSendsMessageWithException() throws Exception {\n\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        // setup the exception here\n        org.apache.kafka.clients.producer.KafkaProducer kp = producer.getKafkaProducer();\n        Mockito.when(kp.send(Mockito.any(ProducerRecord.class), Mockito.any(Callback.class))).thenThrow(new ApiException());\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange, callback);\n\n        Mockito.verify(producer.getKafkaProducer()).send(Matchers.any(ProducerRecord.class), Matchers.any(Callback.class));\n        Mockito.verify(exchange).setException(Matchers.isA(ApiException.class));\n        Mockito.verify(callback).done(Matchers.eq(true));\n    }","id":89519,"modified_method":"@Test\n    public void processAsyncSendsMessageWithException() throws Exception {\n\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        // setup the exception here\n        org.apache.kafka.clients.producer.KafkaProducer kp = producer.getKafkaProducer();\n        Mockito.when(kp.send(Mockito.any(ProducerRecord.class), Mockito.any(Callback.class))).thenThrow(new ApiException());\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange, callback);\n\n        ArgumentCaptor<Callback> callBackCaptor = ArgumentCaptor.forClass(Callback.class);\n        Mockito.verify(producer.getKafkaProducer()).send(Matchers.any(ProducerRecord.class), callBackCaptor.capture());\n        Mockito.verify(exchange).setException(Matchers.isA(ApiException.class));\n        Mockito.verify(callback).done(Matchers.eq(true));\n        Callback kafkaCallback = callBackCaptor.getValue();\n        kafkaCallback.onCompletion(new RecordMetadata(null, 1, 1),null);\n        assertRecordMetadataExists();\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    @SuppressWarnings({\"unchecked\"})\n    public void processSendsMessage() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange);\n        Mockito.verify(producer.getKafkaProducer()).send(Matchers.any(ProducerRecord.class));\n    }","id":89520,"modified_method":"@Test\n    @SuppressWarnings({\"unchecked\"})\n    public void processSendsMessage() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n\n        producer.process(exchange);\n        Mockito.verify(producer.getKafkaProducer()).send(Matchers.any(ProducerRecord.class));\n        assertRecordMetadataExists();\n\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processSendsMessageWithTopicHeaderAndEndPoint() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n        in.setHeader(KafkaConstants.TOPIC, \"anotherTopic\");\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n\n        producer.process(exchange);\n\n        verifySendMessage(\"4\", \"anotherTopic\", \"someKey\");\n    }","id":89521,"modified_method":"@Test\n    public void processSendsMessageWithTopicHeaderAndEndPoint() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        in.setHeader(KafkaConstants.PARTITION_KEY, \"4\");\n        in.setHeader(KafkaConstants.TOPIC, \"anotherTopic\");\n        in.setHeader(KafkaConstants.KEY, \"someKey\");\n\n        producer.process(exchange);\n\n        verifySendMessage(\"4\", \"anotherTopic\", \"someKey\");\n        assertRecordMetadataExists();\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test // Message and Topic Name alone\n    public void processSendsMesssageWithMessageTopicName() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        producer.process(exchange);\n\n        verifySendMessage(\"someTopic\");\n    }","id":89522,"modified_method":"@Test // Message and Topic Name alone\n    public void processSendsMesssageWithMessageTopicName() throws Exception {\n        endpoint.setTopic(\"someTopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        producer.process(exchange);\n\n        verifySendMessage(\"someTopic\");\n        assertRecordMetadataExists();\n\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void processDoesNotRequirePartitionHeader() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        producer.process(exchange);\n    }","id":89523,"modified_method":"@Test\n    public void processDoesNotRequirePartitionHeader() throws Exception {\n        endpoint.setTopic(\"sometopic\");\n        Mockito.when(exchange.getIn()).thenReturn(in);\n        Mockito.when(exchange.getOut()).thenReturn(out);\n\n        producer.process(exchange);\n\n        assertRecordMetadataExists();\n    }","commit_id":"a48c022c3d8424d65a6d23b3edf8854f0f38eaca","url":"https://github.com/apache/camel"},{"original_method":"@Override\n        public StreamFrameListener onSyn(final Stream stream, SynInfo synInfo)\n        {\n            // Every time we have a SYN, it maps to a HTTP request.\n            // We can have multiple concurrent SYNs on the same connection,\n            // and this is very different from HTTP, where only one request\n            // can arrive on the same connection, so we need to create an\n            // HttpChannel for each SYN in order to run concurrently.\n\n            logger.debug(\"Received {} on {}\", synInfo, stream);\n\n            Fields headers = synInfo.getHeaders();\n            // According to SPDY/3 spec section 3.2.1 user-agents MUST support gzip compression. Firefox omits the\n            // accept-encoding header as it is redundant to negotiate gzip compression support with the server,\n            // if clients have to accept it.\n            // So we inject the accept-encoding header here, even if not set by the client. This will enforce SPDY\n            // clients to follow the spec and enable gzip compression if GzipFilter or the like is enabled.\n            if (!(headers.get(\"accept-encoding\") != null && headers.get(\"accept-encoding\").value().contains\n                    (\"gzip\")))\n                headers.add(\"accept-encoding\", \"gzip\");\n            HttpTransportOverSPDY transport = new HttpTransportOverSPDY(connector, httpConfiguration, endPoint, pushStrategy, stream, headers);\n            HttpInputOverSPDY input = new HttpInputOverSPDY();\n            HttpChannelOverSPDY channel = new HttpChannelOverSPDY(connector, httpConfiguration, endPoint, transport, input, stream);\n            stream.setAttribute(CHANNEL_ATTRIBUTE, channel);\n\n            channel.requestStart(headers, synInfo.isClose());\n\n            if (headers.isEmpty())\n            {\n                // If the SYN has no headers, they may come later in a HEADERS frame\n                return this;\n            }\n            else\n            {\n                if (synInfo.isClose())\n                    return null;\n                else\n                    return this;\n            }\n        }","id":89524,"modified_method":"@Override\n        public StreamFrameListener onSyn(final Stream stream, SynInfo synInfo)\n        {\n            // Every time we have a SYN, it maps to a HTTP request.\n            // We can have multiple concurrent SYNs on the same connection,\n            // and this is very different from HTTP, where only one request\n            // can arrive on the same connection, so we need to create an\n            // HttpChannel for each SYN in order to run concurrently.\n\n            logger.debug(\"Received {} on {}\", synInfo, stream);\n\n            Fields headers = synInfo.getHeaders();\n            // According to SPDY/3 spec section 3.2.1 user-agents MUST support gzip compression. Firefox omits the\n            // accept-encoding header as it is redundant to negotiate gzip compression support with the server,\n            // if clients have to accept it.\n            // So we inject the accept-encoding header here, even if not set by the client. This will enforce SPDY\n            // clients to follow the spec and enable gzip compression if GzipFilter or the like is enabled.\n            if (!(headers.get(\"accept-encoding\") != null && headers.get(\"accept-encoding\").value().contains\n                    (\"gzip\")))\n                headers.add(\"accept-encoding\", \"gzip\");\n            HttpTransportOverSPDY transport = new HttpTransportOverSPDY(connector, httpConfiguration, endPoint,\n                    pushStrategy, stream, headers, getVersion());\n            HttpInputOverSPDY input = new HttpInputOverSPDY();\n            HttpChannelOverSPDY channel = new HttpChannelOverSPDY(connector, httpConfiguration, endPoint, transport, input, stream);\n            stream.setAttribute(CHANNEL_ATTRIBUTE, channel);\n\n            channel.requestStart(headers, synInfo.isClose());\n\n            if (headers.isEmpty())\n            {\n                // If the SYN has no headers, they may come later in a HEADERS frame\n                return this;\n            }\n            else\n            {\n                if (synInfo.isClose())\n                    return null;\n                else\n                    return this;\n            }\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private Fields createPushHeaders(Fields.Field scheme, Fields.Field host, String pushResourcePath)\n        {\n            final Fields pushHeaders = new Fields();\n            short version = stream.getSession().getVersion();\n            if (version == SPDY.V2)\n                pushHeaders.put(HTTPSPDYHeader.URI.name(version), scheme.value() + \"://\" + host.value() + pushResourcePath);\n            else\n            {\n                pushHeaders.put(HTTPSPDYHeader.URI.name(version), pushResourcePath);\n                pushHeaders.put(scheme);\n                pushHeaders.put(host);\n            }\n            return pushHeaders;\n        }","id":89525,"modified_method":"private Fields createPushHeaders(Fields.Field scheme, Fields.Field host, String pushResourcePath)\n        {\n            final Fields pushHeaders = new Fields();\n            if (version == SPDY.V2)\n                pushHeaders.put(HTTPSPDYHeader.URI.name(version), scheme.value() + \"://\" + host.value() + pushResourcePath);\n            else\n            {\n                pushHeaders.put(HTTPSPDYHeader.URI.name(version), pushResourcePath);\n                pushHeaders.put(scheme);\n                pushHeaders.put(host);\n            }\n            return pushHeaders;\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public HttpTransportOverSPDY(Connector connector, HttpConfiguration configuration, EndPoint endPoint, PushStrategy pushStrategy, Stream stream, Fields requestHeaders)\n    {\n        this.connector = connector;\n        this.configuration = configuration;\n        this.endPoint = endPoint;\n        this.pushStrategy = pushStrategy == null ? new PushStrategy.None() : pushStrategy;\n        this.stream = stream;\n        this.requestHeaders = requestHeaders;\n    }","id":89526,"modified_method":"public HttpTransportOverSPDY(Connector connector, HttpConfiguration configuration, EndPoint endPoint, PushStrategy pushStrategy, Stream stream, Fields requestHeaders, short version)\n    {\n        this.connector = connector;\n        this.configuration = configuration;\n        this.endPoint = endPoint;\n        this.pushStrategy = pushStrategy == null ? new PushStrategy.None() : pushStrategy;\n        this.stream = stream;\n        this.requestHeaders = requestHeaders;\n        this.version = version;\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private HttpChannelOverSPDY newHttpChannelOverSPDY(Stream pushStream, Fields pushRequestHeaders)\n        {\n            HttpTransport transport = new PushHttpTransportOverSPDY(connector, configuration, endPoint, pushStrategy,\n                    pushStream, pushRequestHeaders, this);\n            HttpInputOverSPDY input = new HttpInputOverSPDY();\n            return new HttpChannelOverSPDY(connector, configuration, endPoint, transport, input, pushStream);\n        }","id":89527,"modified_method":"private HttpChannelOverSPDY newHttpChannelOverSPDY(Stream pushStream, Fields pushRequestHeaders)\n        {\n            HttpTransport transport = new PushHttpTransportOverSPDY(connector, configuration, endPoint, pushStrategy,\n                    pushStream, pushRequestHeaders, this, version);\n            HttpInputOverSPDY input = new HttpInputOverSPDY();\n            return new HttpChannelOverSPDY(connector, configuration, endPoint, transport, input, pushStream);\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private Fields createRequestHeaders(Fields.Field scheme, Fields.Field host, Fields.Field uri, String pushResourcePath)\n        {\n            final Fields newRequestHeaders = new Fields(requestHeaders, false);\n            short version = stream.getSession().getVersion();\n            newRequestHeaders.put(HTTPSPDYHeader.METHOD.name(version), \"GET\");\n            newRequestHeaders.put(HTTPSPDYHeader.VERSION.name(version), \"HTTP/1.1\");\n            newRequestHeaders.put(scheme);\n            newRequestHeaders.put(host);\n            newRequestHeaders.put(HTTPSPDYHeader.URI.name(version), pushResourcePath);\n            String referrer = scheme.value() + \"://\" + host.value() + uri.value();\n            newRequestHeaders.put(\"referer\", referrer);\n            newRequestHeaders.put(\"x-spdy-push\", \"true\");\n            return newRequestHeaders;\n        }","id":89528,"modified_method":"private Fields createRequestHeaders(Fields.Field scheme, Fields.Field host, Fields.Field uri, String pushResourcePath)\n        {\n            final Fields newRequestHeaders = new Fields(requestHeaders, false);\n            newRequestHeaders.put(HTTPSPDYHeader.METHOD.name(version), \"GET\");\n            newRequestHeaders.put(HTTPSPDYHeader.VERSION.name(version), \"HTTP/1.1\");\n            newRequestHeaders.put(scheme);\n            newRequestHeaders.put(host);\n            newRequestHeaders.put(HTTPSPDYHeader.URI.name(version), pushResourcePath);\n            String referrer = scheme.value() + \"://\" + host.value() + uri.value();\n            newRequestHeaders.put(\"referer\", referrer);\n            newRequestHeaders.put(\"x-spdy-push\", \"true\");\n            return newRequestHeaders;\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void completed()\n        {\n            Stream stream = getStream();\n            LOG.debug(\"Resource pushed for {} on {}\",\n                    getRequestHeaders().get(HTTPSPDYHeader.URI.name(stream.getSession().getVersion())), stream);\n            coordinator.complete();\n        }","id":89529,"modified_method":"@Override\n        public void completed()\n        {\n            Stream stream = getStream();\n            LOG.debug(\"Resource pushed for {} on {}\",\n                    getRequestHeaders().get(HTTPSPDYHeader.URI.name(version)), stream);\n            coordinator.complete();\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void send(HttpGenerator.ResponseInfo info, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Sending {} {} {} {} last={}\", this, stream, info, BufferUtil.toDetailString(content), lastContent);\n\n        if (stream.isClosed() || stream.isReset())\n        {\n            EofException exception = new EofException(\"stream closed\");\n            callback.failed(exception);\n            return;\n        }\n\n        // info==null content==null lastContent==false          should not happen\n        // info==null content==null lastContent==true           signals no more content - complete\n        // info==null content!=null lastContent==false          send data on committed response\n        // info==null content!=null lastContent==true           send last data on committed response - complete\n        // info!=null content==null lastContent==false          reply, commit\n        // info!=null content==null lastContent==true           reply, commit and complete\n        // info!=null content!=null lastContent==false          reply, commit with content\n        // info!=null content!=null lastContent==true           reply, commit with content and complete\n\n        short version = stream.getSession().getVersion();\n        boolean isHeadRequest = HttpMethod.HEAD.name().equalsIgnoreCase(requestHeaders.get(HTTPSPDYHeader.METHOD.name(version)).value());\n        boolean hasContent = BufferUtil.hasContent(content) && !isHeadRequest;\n\n        if (info != null)\n        {\n            if (!committed.compareAndSet(false, true))\n            {\n                StreamException exception = new StreamException(stream.getId(), StreamStatus.PROTOCOL_ERROR,\n                        \"Stream already committed!\");\n                callback.failed(exception);\n                LOG.warn(\"Committed response twice.\", exception);\n                return;\n            }\n            Fields headers = new Fields();\n\n            HttpVersion httpVersion = HttpVersion.HTTP_1_1;\n            headers.put(HTTPSPDYHeader.VERSION.name(version), httpVersion.asString());\n\n            int status = info.getStatus();\n            StringBuilder httpStatus = new StringBuilder().append(status);\n            String reason = info.getReason();\n            if (reason == null)\n                reason = HttpStatus.getMessage(status);\n            if (reason != null)\n                httpStatus.append(\" \").append(reason);\n            headers.put(HTTPSPDYHeader.STATUS.name(version), httpStatus.toString());\n            LOG.debug(\"HTTP < {} {}\", httpVersion, httpStatus);\n\n            // TODO merge the two Field classes into one\n            HttpFields fields = info.getHttpFields();\n            if (fields != null)\n            {\n                for (int i = 0; i < fields.size(); ++i)\n                {\n                    HttpField field = fields.getField(i);\n                    String name = field.getName();\n                    String value = field.getValue();\n                    headers.add(name, value);\n                    LOG.debug(\"HTTP < {}: {}\", name, value);\n                }\n            }\n\n            if (configuration.getSendServerVersion())\n                headers.add(HttpHeader.SERVER.asString(), HttpConfiguration.SERVER_VERSION);\n            if(configuration.getSendXPoweredBy())\n                headers.add(HttpHeader.X_POWERED_BY.asString(), HttpConfiguration.SERVER_VERSION);\n            \n            boolean close = !hasContent && lastContent;\n            ReplyInfo reply = new ReplyInfo(headers, close);\n            reply(stream, reply);\n        }\n\n        // Do we have some content to send as well\n        if (hasContent)\n        {\n            // Is the stream still open?\n            if (stream.isClosed() || stream.isReset())\n                // tell the callback about the EOF\n                callback.failed(new EofException(\"stream closed\"));\n            else\n                // send the data and let it call the callback\n                stream.data(new ByteBufferDataInfo(endPoint.getIdleTimeout(), TimeUnit.MILLISECONDS, content, lastContent\n                ), callback);\n        }\n        // else do we need to close\n        else if (lastContent)\n        {\n            // Are we closed ?\n            if (stream.isClosed() || stream.isReset())\n                // already closed by reply, so just tell callback we are complete\n                callback.succeeded();\n            else\n                // send empty data to close and let the send call the callback\n                stream.data(new ByteBufferDataInfo(endPoint.getIdleTimeout(), TimeUnit.MILLISECONDS,\n                        BufferUtil.EMPTY_BUFFER, lastContent), callback);\n        }\n        else\n            // No data and no close so tell callback we are completed\n            callback.succeeded();\n    }","id":89530,"modified_method":"@Override\n    public void send(HttpGenerator.ResponseInfo info, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Sending {} {} {} {} last={}\", this, stream, info, BufferUtil.toDetailString(content), lastContent);\n\n        if (stream.isClosed() || stream.isReset())\n        {\n            EofException exception = new EofException(\"stream closed\");\n            callback.failed(exception);\n            return;\n        }\n\n        // info==null content==null lastContent==false          should not happen\n        // info==null content==null lastContent==true           signals no more content - complete\n        // info==null content!=null lastContent==false          send data on committed response\n        // info==null content!=null lastContent==true           send last data on committed response - complete\n        // info!=null content==null lastContent==false          reply, commit\n        // info!=null content==null lastContent==true           reply, commit and complete\n        // info!=null content!=null lastContent==false          reply, commit with content\n        // info!=null content!=null lastContent==true           reply, commit with content and complete\n\n        boolean isHeadRequest = HttpMethod.HEAD.name().equalsIgnoreCase(requestHeaders.get(HTTPSPDYHeader.METHOD.name(version)).value());\n        boolean hasContent = BufferUtil.hasContent(content) && !isHeadRequest;\n        boolean close = !hasContent && lastContent;\n\n        if (info != null)\n        {\n            if (!committed.compareAndSet(false, true))\n            {\n                StreamException exception = new StreamException(stream.getId(), StreamStatus.PROTOCOL_ERROR,\n                        \"Stream already committed!\");\n                callback.failed(exception);\n                LOG.warn(\"Committed response twice.\", exception);\n                return;\n            }\n            sendReply(info, lastContent && !hasContent ? callback : new Callback.Adapter(), close);\n        }\n\n        // Do we have some content to send as well\n        if (hasContent)\n        {\n            LOG.debug(\"Send content: {} on stream: {} lastContent={}\", BufferUtil.toDetailString(content), stream,\n                    lastContent);\n\n            // send the data and let it call the callback\n            stream.data(new ByteBufferDataInfo(endPoint.getIdleTimeout(), TimeUnit.MILLISECONDS, content, lastContent\n            ), callback);\n        }\n        // else do we need to close\n        else if (lastContent && info == null)\n        {\n            LOG.debug(\"No content and lastContent=true. Sending empty ByteBuffer to close stream: {}\", stream);\n            // send empty data to close and let the send call the callback\n            stream.data(new ByteBufferDataInfo(endPoint.getIdleTimeout(), TimeUnit.MILLISECONDS,\n                    BufferUtil.EMPTY_BUFFER, lastContent), callback);\n        }\n        else if(!lastContent)\n            callback.succeeded();\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void reply(Stream stream, ReplyInfo replyInfo)\n    {\n        if (!stream.isUnidirectional())\n            stream.reply(replyInfo, new Callback.Adapter());\n        else\n            stream.headers(new HeadersInfo(replyInfo.getHeaders(), replyInfo.isClose()), new Callback.Adapter());\n\n        Fields responseHeaders = replyInfo.getHeaders();\n        short version = stream.getSession().getVersion();\n        if (responseHeaders.get(HTTPSPDYHeader.STATUS.name(version)).value().startsWith(\"200\") && !stream.isClosed())\n        {\n            Set<String> pushResources = pushStrategy.apply(stream, requestHeaders, responseHeaders);\n            if (pushResources.size() > 0)\n            {\n                PushResourceCoordinator pushResourceCoordinator = new PushResourceCoordinator(pushResources);\n                pushResourceCoordinator.coordinate();\n            }\n        }\n    }","id":89531,"modified_method":"private void reply(Stream stream, ReplyInfo replyInfo, Callback callback)\n    {\n        if (!stream.isUnidirectional())\n            stream.reply(replyInfo, callback);\n        else\n            stream.headers(new HeadersInfo(replyInfo.getHeaders(), replyInfo.isClose()), callback);\n\n        Fields responseHeaders = replyInfo.getHeaders();\n        if (responseHeaders.get(HTTPSPDYHeader.STATUS.name(version)).value().startsWith(\"200\") && !stream.isClosed())\n        {\n            Set<String> pushResources = pushStrategy.apply(stream, requestHeaders, responseHeaders);\n            if (pushResources.size() > 0)\n            {\n                PushResourceCoordinator pushResourceCoordinator = new PushResourceCoordinator(pushResources);\n                pushResourceCoordinator.coordinate();\n            }\n        }\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void pushResource(String pushResource)\n        {\n            final short version = stream.getSession().getVersion();\n            Fields.Field scheme = requestHeaders.get(HTTPSPDYHeader.SCHEME.name(version));\n            Fields.Field host = requestHeaders.get(HTTPSPDYHeader.HOST.name(version));\n            Fields.Field uri = requestHeaders.get(HTTPSPDYHeader.URI.name(version));\n            final Fields pushHeaders = createPushHeaders(scheme, host, pushResource);\n            final Fields pushRequestHeaders = createRequestHeaders(scheme, host, uri, pushResource);\n\n            stream.push(new PushInfo(pushHeaders, false), new Promise<Stream>()\n            {\n                @Override\n                public void succeeded(Stream pushStream)\n                {\n                    LOG.debug(\"Headers pushed for {} on {}\", pushHeaders.get(HTTPSPDYHeader.URI.name(version)), pushStream);\n                    queue.offer(new PushResource(pushStream, pushRequestHeaders));\n                    sendNextResourceData();\n                }\n\n                @Override\n                public void failed(Throwable x)\n                {\n                    LOG.debug(\"Creating push stream failed.\", x);\n                }\n            });\n        }","id":89532,"modified_method":"private void pushResource(String pushResource)\n        {\n            Fields.Field scheme = requestHeaders.get(HTTPSPDYHeader.SCHEME.name(version));\n            Fields.Field host = requestHeaders.get(HTTPSPDYHeader.HOST.name(version));\n            Fields.Field uri = requestHeaders.get(HTTPSPDYHeader.URI.name(version));\n            final Fields pushHeaders = createPushHeaders(scheme, host, pushResource);\n            final Fields pushRequestHeaders = createRequestHeaders(scheme, host, uri, pushResource);\n\n            stream.push(new PushInfo(pushHeaders, false), new Promise<Stream>()\n            {\n                @Override\n                public void succeeded(Stream pushStream)\n                {\n                    LOG.debug(\"Headers pushed for {} on {}\", pushHeaders.get(HTTPSPDYHeader.URI.name(version)), pushStream);\n                    queue.offer(new PushResource(pushStream, pushRequestHeaders));\n                    sendNextResourceData();\n                }\n\n                @Override\n                public void failed(Throwable x)\n                {\n                    LOG.debug(\"Creating push stream failed.\", x);\n                }\n            });\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private PushHttpTransportOverSPDY(Connector connector, HttpConfiguration configuration, EndPoint endPoint,\n                                          PushStrategy pushStrategy, Stream stream, Fields requestHeaders,\n                                          PushResourceCoordinator coordinator)\n        {\n            super(connector, configuration, endPoint, pushStrategy, stream, requestHeaders);\n            this.coordinator = coordinator;\n        }","id":89533,"modified_method":"private PushHttpTransportOverSPDY(Connector connector, HttpConfiguration configuration, EndPoint endPoint,\n                                          PushStrategy pushStrategy, Stream stream, Fields requestHeaders,\n                                          PushResourceCoordinator coordinator, short version)\n        {\n            super(connector, configuration, endPoint, pushStrategy, stream, requestHeaders, version);\n            this.coordinator = coordinator;\n            this.version = version;\n        }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoNullAndContentAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n        boolean lastContent = false;\n        \n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"lastContent is false\", dataInfoCaptor.getValue().isClose(), is(false));\n        assertThat(\"ByteBuffer is empty\", dataInfoCaptor.getValue().length(), is(4096));\n    }","id":89534,"modified_method":"@Test\n    public void testSendWithResponseInfoNullAndContentAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n        boolean lastContent = false;\n        \n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        verify(callback, times(1)).succeeded();\n        assertThat(\"lastContent is false\", dataInfoCaptor.getValue().isClose(), is(false));\n        assertThat(\"ByteBuffer is empty\", dataInfoCaptor.getValue().length(), is(4096));\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoAndContentAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n\n        boolean lastContent = true;\n        \n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"ReplyInfo close is false\", replyInfoCaptor.getValue().isClose(), is(false));\n\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer length is 4096\", dataInfoCaptor.getValue().length(), is(4096));\n    }","id":89535,"modified_method":"@Test\n    public void testSendWithResponseInfoAndContentAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n        boolean lastContent = true;\n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        assertThat(\"ReplyInfo close is false\", replyInfoCaptor.getValue().isClose(), is(false));\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer length is 4096\", dataInfoCaptor.getValue().length(), is(4096));\n        verify(callback, times(1)).succeeded();\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoNullAndContentNullAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = false;\n        \n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        verify(stream, times(0)).data(any(ByteBufferDataInfo.class), any(Callback.class));\n    }","id":89536,"modified_method":"@Test\n    public void testSendWithResponseInfoNullAndContentNullAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = false;\n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        verify(callback, times(1)).succeeded();\n        verify(stream, times(0)).data(any(ByteBufferDataInfo.class), any(Callback.class));\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoAndContentNullAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = false;\n        \n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"ReplyInfo close is true\", replyInfoCaptor.getValue().isClose(), is(false));\n\n        verify(stream, times(0)).data(any(ByteBufferDataInfo.class), any(Callback.class));\n    }","id":89537,"modified_method":"@Test\n    public void testSendWithResponseInfoAndContentNullAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = false;\n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        assertThat(\"ReplyInfo close is true\", replyInfoCaptor.getValue().isClose(), is(false));\n\n        verify(stream, times(0)).data(any(ByteBufferDataInfo.class), any(Callback.class));\n        verify(callback, times(1)).succeeded();\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoAndContentNullAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = true;\n        \n        // when stream.isClosed() is called a 2nd time, the reply has closed the stream already\n        when(stream.isClosed()).thenReturn(false).thenReturn(true);\n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"ReplyInfo close is true\", replyInfoCaptor.getValue().isClose(), is(true));\n\n        verify(callback, times(1)).succeeded();\n    }","id":89538,"modified_method":"@Test\n    public void testSendWithResponseInfoAndContentNullAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = true;\n        \n        // when stream.isClosed() is called a 2nd time, the reply has closed the stream already\n        when(stream.isClosed()).thenReturn(false).thenReturn(true);\n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        assertThat(\"ReplyInfo close is true\", replyInfoCaptor.getValue().isClose(), is(true));\n\n        verify(callback, times(1)).succeeded();\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        Fields requestHeaders = new Fields();\n        requestHeaders.add(HTTPSPDYHeader.METHOD.name(SPDY.V3),\"GET\");\n        httpTransportOverSPDY = new HttpTransportOverSPDY(connector, httpConfiguration, endPoint, pushStrategy,\n                stream, requestHeaders);\n        when(responseInfo.getStatus()).thenReturn(HttpStatus.OK_200);\n        when(stream.getSession()).thenReturn(session);\n        when(session.getVersion()).thenReturn(SPDY.V3);\n        when(stream.isClosed()).thenReturn(false);\n    }","id":89539,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        Fields requestHeaders = new Fields();\n        requestHeaders.add(HTTPSPDYHeader.METHOD.name(version), \"GET\");\n        httpTransportOverSPDY = new HttpTransportOverSPDY(connector, httpConfiguration, endPoint, pushStrategy,\n                stream, requestHeaders, version);\n        when(responseInfo.getStatus()).thenReturn(HttpStatus.OK_200);\n        when(stream.getSession()).thenReturn(session);\n        when(session.getVersion()).thenReturn(SPDY.V3);\n        when(stream.isClosed()).thenReturn(false);\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoNullAndContentAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n\n        boolean lastContent = true;\n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer length is 4096\", dataInfoCaptor.getValue().length(), is(4096));\n    }","id":89540,"modified_method":"@Test\n    public void testSendWithResponseInfoNullAndContentAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n\n        boolean lastContent = true;\n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        verify(callback, times(1)).succeeded();\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer length is 4096\", dataInfoCaptor.getValue().length(), is(4096));\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoNullAndEmptyContentAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = BufferUtil.EMPTY_BUFFER;\n        boolean lastContent = true;\n        \n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer is empty\", dataInfoCaptor.getValue().length(), is(0));\n    }","id":89541,"modified_method":"@Test\n    public void testSendWithResponseInfoNullAndEmptyContentAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = BufferUtil.EMPTY_BUFFER;\n        boolean lastContent = true;\n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        verify(callback, times(1)).succeeded();\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer is empty\", dataInfoCaptor.getValue().length(), is(0));\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoAndContentAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n\n        boolean lastContent = false;\n        \n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"ReplyInfo close is false\", replyInfoCaptor.getValue().isClose(), is(false));\n\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"lastContent is false\", dataInfoCaptor.getValue().isClose(), is(false));\n        assertThat(\"ByteBuffer length is 4096\", dataInfoCaptor.getValue().length(), is(4096));\n    }","id":89542,"modified_method":"@Test\n    public void testSendWithResponseInfoAndContentAndLastContentFalse() throws Exception\n    {\n        ByteBuffer content = createRandomByteBuffer();\n        boolean lastContent = false;\n\n        httpTransportOverSPDY.send(responseInfo, content, lastContent, callback);\n        ArgumentCaptor<ReplyInfo> replyInfoCaptor = ArgumentCaptor.forClass(ReplyInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).reply(replyInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        assertThat(\"ReplyInfo close is false\", replyInfoCaptor.getValue().isClose(), is(false));\n\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        assertThat(\"lastContent is false\", dataInfoCaptor.getValue().isClose(), is(false));\n        assertThat(\"ByteBuffer length is 4096\", dataInfoCaptor.getValue().length(), is(4096));\n\n        verify(callback, times(1)).succeeded();\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSendWithResponseInfoNullAndContentNullAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = true;\n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), any(Callback.class));\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer is empty\", dataInfoCaptor.getValue().length(), is(0));\n    }","id":89543,"modified_method":"@Test\n    public void testSendWithResponseInfoNullAndContentNullAndLastContentTrue() throws Exception\n    {\n        ByteBuffer content = null;\n        boolean lastContent = true;\n\n        httpTransportOverSPDY.send(null, content, lastContent, callback);\n        ArgumentCaptor<ByteBufferDataInfo> dataInfoCaptor = ArgumentCaptor.forClass(ByteBufferDataInfo.class);\n        ArgumentCaptor<Callback> callbackCaptor = ArgumentCaptor.forClass(Callback.class);\n        verify(stream, times(1)).data(dataInfoCaptor.capture(), callbackCaptor.capture());\n        callbackCaptor.getValue().succeeded();\n        verify(callback, times(1)).succeeded();\n        assertThat(\"lastContent is true\", dataInfoCaptor.getValue().isClose(), is(true));\n        assertThat(\"ByteBuffer is empty\", dataInfoCaptor.getValue().length(), is(0));\n    }","commit_id":"205ef85ead2c7ea169e4aebdabcf9f24b66de15d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void applyDecorator(Page page, Decorator decorator, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \tif(decorator.getURIPath().endsWith(\".gsp\")) {\n    \t\trequest.setAttribute(PAGE, page);\n            ServletContext context = filterConfig.getServletContext();\n            // see if the URI path (webapp) is set\n            if (decorator.getURIPath() != null) {\n                // in a security conscious environment, the servlet container\n                // may return null for a given URL\n                if (context.getContext(decorator.getURIPath()) != null) {\n                    context = context.getContext(decorator.getURIPath());\n                }\n            }    \t\t\n            \n            if(LOG.isDebugEnabled()) {\n            \tLOG.debug(\"Rendering layout using include: \" + decorator.getURIPath());\n            }\n            RequestDispatcher rd = request.getRequestDispatcher(decorator.getURIPath());\n            rd.forward(request, response);\n    \t\t\n            // set the headers specified as decorator init params\n            while (decorator.getInitParameterNames().hasNext()) {\n                String initParam = (String) decorator.getInitParameterNames().next();\n                if (initParam.startsWith(\"header.\")) {\n                    response.setHeader(initParam.substring(initParam.indexOf('.')), decorator.getInitParameter(initParam));\n                }\n            }\n\n            request.removeAttribute(PAGE);        \t\t        \t\t\n    \t}\n    \telse {\n    \t\t\n    \t\tsuper.applyDecorator(page, decorator, request, response);\n    \t\t\n    \t}\n\t}","id":89544,"modified_method":"protected void applyDecorator(Page page, Decorator decorator, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \tif(decorator.getURIPath().endsWith(\".gsp\")) {\n    \t\trequest.setAttribute(PAGE, page);\n            ServletContext context = filterConfig.getServletContext();\n            // see if the URI path (webapp) is set\n            if (decorator.getURIPath() != null) {\n                // in a security conscious environment, the servlet container\n                // may return null for a given URL\n                if (context.getContext(decorator.getURIPath()) != null) {\n                    context = context.getContext(decorator.getURIPath());\n                }\n            }    \t\t\n                      \n            RequestDispatcher rd = request.getRequestDispatcher(decorator.getURIPath());\n            if(!response.isCommitted()) {\n                if(LOG.isDebugEnabled()) {\n                \tLOG.debug(\"Rendering layout using forward: \" + decorator.getURIPath());\n                }            \t            \t\n            \trd.forward(request, response);\n            } \n            else {\n                if(LOG.isDebugEnabled()) {\n                \tLOG.debug(\"Rendering layout using include: \" + decorator.getURIPath());\n                }\n                request.setAttribute(GrailsApplicationAttributes.GSP_TO_RENDER,decorator.getURIPath());\n                rd.include(request,response);\n                request.removeAttribute(GrailsApplicationAttributes.GSP_TO_RENDER);\n            }\n            \n            // set the headers specified as decorator init params\n            while (decorator.getInitParameterNames().hasNext()) {\n                String initParam = (String) decorator.getInitParameterNames().next();\n                if (initParam.startsWith(\"header.\")) {\n                    response.setHeader(initParam.substring(initParam.indexOf('.')), decorator.getInitParameter(initParam));\n                }\n            }\n            request.removeAttribute(PAGE);        \t\t        \t\t\n    \t}\n    \telse {\n    \t\t\n    \t\tsuper.applyDecorator(page, decorator, request, response);\n    \t\t\n    \t}\n\t}","commit_id":"415fbc95bde1b5076f72b02297c8ce832c6ebad5","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Execute page and produce output.\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doPage(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \trequest.setAttribute(GrailsApplicationAttributes.REQUEST_SCOPE_ID, grailsAttributes);\n    \t\n        this.engine = grailsAttributes.getPagesTemplateEngine();\n        this.engine.setShowSource(this.showSource);\n        \n        \n        String pageId = (String)request.getAttribute(GrailsApplicationAttributes.GSP_TO_RENDER);\n        if(pageId == null)\n        \tpageId = engine.getPageId(request);\n        URL pageUrl = engine.getPageUrl(context,pageId);\n        if (pageUrl == null) {\n            context.log(\"GroovyPagesServlet:  \\\"\" + pageUrl + \"\\\" not found\");\n            response.sendError(404, \"\\\"\" + pageUrl + \"\\\" not found.\");\n            return;\n        }\n\n        Template t = engine.createTemplate(context,request,response);\n        if(t == null) {\n            context.log(\"GroovyPagesServlet:  \\\"\" + pageUrl + \"\\\" not found\");\n            response.sendError(404, \"\\\"\" + pageUrl + \"\\\" not found.\");\n            return;        \t\n        }\n        Writable w = t.make();\n        Writer out = GSPResonseWriter.getInstance(response, 8192);\n        try {\n            w.writeTo(out);\n        }\n        catch(Exception e) {\n        \tLOG.debug(\"Error processing GSP: \" + e.getMessage(), e);\n            request.setAttribute(\"exception\",new GrailsWrappedRuntimeException(context,e));\n            RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/grails-app/views/error.jsp\");\n            rd.forward(request,response);\n        }\n        finally {\n            if (out != null) out.close();\n        }\n    }","id":89545,"modified_method":"/**\n     * Execute page and produce output.\n     * @param request\n     * @param response\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void doPage(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \trequest.setAttribute(GrailsApplicationAttributes.REQUEST_SCOPE_ID, grailsAttributes);\n    \t\n        this.engine = grailsAttributes.getPagesTemplateEngine();\n        this.engine.setShowSource(this.showSource);\n        \n        \n        String pageId = (String)request.getAttribute(GrailsApplicationAttributes.GSP_TO_RENDER);\n        if(pageId == null)\n        \tpageId = engine.getPageId(request);\n        URL pageUrl = engine.getPageUrl(context,pageId);\n        if (pageUrl == null) {\n            context.log(\"GroovyPagesServlet:  \\\"\" + pageUrl + \"\\\" not found\");\n            response.sendError(404, \"\\\"\" + pageUrl + \"\\\" not found.\");\n            return;\n        }\n\n        Template t = engine.createTemplate(context,request,response);\n        if(t == null) {\n            context.log(\"GroovyPagesServlet:  \\\"\" + pageUrl + \"\\\" not found\");\n            response.sendError(404, \"\\\"\" + pageUrl + \"\\\" not found.\");\n            return;        \t\n        }\n        Writable w = t.make();\n        Writer out = GSPResonseWriter.getInstance(response, 8192);\n        try {\n            w.writeTo(out);\n        }\n        catch(Exception e) {\n        \tLOG.debug(\"Error processing GSP: \" + e.getMessage(), e);\n            request.setAttribute(\"exception\",new GrailsWrappedRuntimeException(context,e));\n            RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/grails-app/views/error.jsp\");\n            if(response.isCommitted()) {\n                rd.include(request,response);\n            }\n            else {\n                rd.forward(request,response);\n            }\n        }\n        finally {\n            if (out != null) out.close();\n        }\n    }","commit_id":"ca095159072c5532dad73e010d09356e28d2e1b3","url":"https://github.com/grails/grails-core"},{"original_method":"protected void redirect(HttpServletRequest request, HttpServletResponse response, String pathInfo) \n        throws ServletException {\n        boolean customServletPath = dispatcherServletPath != null;\n        String theServletPath = customServletPath ? dispatcherServletPath : \"/\";\n        \n        ServletContext sc = super.getServletContext();\n        RequestDispatcher rd = dispatcherServletName != null \n            ? sc.getNamedDispatcher(dispatcherServletName) \n            : sc.getRequestDispatcher((theServletPath + pathInfo).replace(\"//\", \"/\"));\n        if (rd == null) {\n            String errorMessage = \"No RequestDispatcher can be created for path \" + pathInfo;\n            if (dispatcherServletName != null) {\n                errorMessage += \", dispatcher name: \" + dispatcherServletName;\n            }\n            throw new ServletException(errorMessage);\n        }\n        try {\n            for (Map.Entry<String, String> entry : redirectAttributes.entrySet()) {\n                request.setAttribute(entry.getKey(), entry.getValue());\n            }\n            HttpServletRequest servletRequest = \n                new HttpServletRequestRedirectFilter(request, pathInfo, theServletPath, customServletPath);\n            rd.forward(servletRequest, response);\n        } catch (Throwable ex) {\n            throw new ServletException(\"RequestDispatcher for path \" + pathInfo + \" has failed\", ex);\n        }   \n    }","id":89546,"modified_method":"protected void redirect(HttpServletRequest request, HttpServletResponse response, String pathInfo) \n        throws ServletException {\n        boolean customServletPath = dispatcherServletPath != null;\n        String theServletPath = customServletPath ? dispatcherServletPath : \"/\";\n        \n        ServletContext sc = super.getServletContext();\n        RequestDispatcher rd = dispatcherServletName != null \n            ? sc.getNamedDispatcher(dispatcherServletName) \n            : sc.getRequestDispatcher((theServletPath + pathInfo).replace(\"//\", \"/\"));\n        if (rd == null) {\n            String errorMessage = \"No RequestDispatcher can be created for path \" + pathInfo;\n            if (dispatcherServletName != null) {\n                errorMessage += \", dispatcher name: \" + dispatcherServletName;\n            }\n            throw new ServletException(errorMessage);\n        }\n        try {\n            for (Map.Entry<String, String> entry : redirectAttributes.entrySet()) {\n                request.setAttribute(entry.getKey(), entry.getValue());\n            }\n            HttpServletRequest servletRequest = \n                new HttpServletRequestRedirectFilter(request, pathInfo, theServletPath, customServletPath);\n            if (PropertyUtils.isTrue(getServletConfig().getInitParameter(REDIRECT_WITH_INCLUDE_PARAMETER))) {\n                rd.include(servletRequest, response);\n            } else {\n                rd.forward(servletRequest, response);\n            }\n        } catch (Throwable ex) {\n            throw new ServletException(\"RequestDispatcher for path \" + pathInfo + \" has failed\", ex);\n        }   \n    }","commit_id":"1946e323a0df6e5f9748af82106cff39d7b5d01f","url":"https://github.com/apache/cxf"},{"original_method":"protected void serveStaticContent(HttpServletRequest request, \n                                      HttpServletResponse response,\n                                      String pathInfo) throws ServletException {\n        InputStream is = getResourceAsStream(pathInfo);\n        if (is == null) {\n            throw new ServletException(\"Static resource \" + pathInfo + \" is not available\");\n        }\n        try {\n            int ind = pathInfo.lastIndexOf(\".\");\n            if (ind != -1 && ind < pathInfo.length()) {\n                String type = getStaticResourceContentType(pathInfo.substring(ind + 1));\n                if (type != null) {\n                    response.setContentType(type);\n                }\n            }\n            \n            ServletOutputStream os = response.getOutputStream();\n            IOUtils.copy(is, os);\n            os.flush();\n        } catch (IOException ex) {\n            throw new ServletException(\"Static resource \" + pathInfo \n                                       + \" can not be written to the output stream\");\n        }\n        \n    }","id":89547,"modified_method":"protected void serveStaticContent(HttpServletRequest request, \n                                      HttpServletResponse response,\n                                      String pathInfo) throws ServletException {\n        InputStream is = getResourceAsStream(pathInfo);\n        if (is == null) {\n            throw new ServletException(\"Static resource \" + pathInfo + \" is not available\");\n        }\n        try {\n            int ind = pathInfo.lastIndexOf(\".\");\n            if (ind != -1 && ind < pathInfo.length()) {\n                String type = getStaticResourceContentType(pathInfo.substring(ind + 1));\n                if (type != null) {\n                    response.setContentType(type);\n                }\n            }\n            String cacheControl = getServletConfig().getInitParameter(STATIC_CACHE_CONTROL);\n            if (cacheControl != null) {\n                response.setHeader(\"Cache-Control\", cacheControl.trim());\n            }\n            ServletOutputStream os = response.getOutputStream();\n            IOUtils.copy(is, os);\n            os.flush();\n        } catch (IOException ex) {\n            throw new ServletException(\"Static resource \" + pathInfo \n                                       + \" can not be written to the output stream\");\n        }\n        \n    }","commit_id":"1946e323a0df6e5f9748af82106cff39d7b5d01f","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testGetBookHTML() throws Exception {\n        String endpointAddress =\n            \"http://localhost:\" + PORT + \"/the/bookstore1/books/html/123\"; \n        WebClient client = WebClient.create(endpointAddress);\n        client.accept(\"text/html\");\n        WebClient.getConfig(client).getHttpConduit().getClient().setReceiveTimeout(100000000);\n        XMLSource source = client.accept(\"text/html\").get(XMLSource.class);\n        Map<String, String> namespaces = new HashMap<String, String>();\n        namespaces.put(\"xhtml\", \"http://www.w3.org/1999/xhtml\");\n        namespaces.put(\"books\", \"http://www.w3.org/books\");\n        String value = source.getValue(\"xhtml:html/xhtml:body/xhtml:ul/books:bookTag\", namespaces);\n        assertEquals(\"CXF Rocks\", value);\n        String ct = client.getResponse().getMetadata().getFirst(\"Content-Type\").toString();\n        assertEquals(\"text/html\", ct);\n    }","id":89548,"modified_method":"@Test\n    public void testGetBookHTML() throws Exception {\n        String endpointAddress =\n            \"http://localhost:\" + PORT + \"/the/bookstore1/books/html/123\"; \n        doTestGetBookHTML(endpointAddress);\n    }","commit_id":"1946e323a0df6e5f9748af82106cff39d7b5d01f","url":"https://github.com/apache/cxf"},{"original_method":"public void writeTo(Object o, Class<?> clazz, Type genericType, Annotation[] annotations, \n                        MediaType type, MultivaluedMap<String, Object> headers, OutputStream os)\n        throws IOException {\n        \n        ServletContext sc = getServletContext();\n        HttpServletRequest servletRequest = mc.getHttpServletRequest();\n        \n        String path = getResourcePath(clazz, o);\n        \n        String theServletPath = servletPath != null ? servletPath \n            : useCurrentServlet ? servletRequest.getServletPath() : \"/\";\n                \n        if (theServletPath.endsWith(\"/\") && path != null && path.startsWith(\"/\")) {\n            theServletPath = theServletPath.length() == 1 ? \"\" \n                : theServletPath.substring(0, theServletPath.length() - 1);\n        } else if (!theServletPath.endsWith(\"/\") && path != null && !path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n        \n        \n        RequestDispatcher rd = getRequestDispatcher(sc, clazz, theServletPath + path);\n        \n        try {\n            mc.put(AbstractHTTPDestination.REQUEST_REDIRECTED, Boolean.TRUE);\n            \n            HttpServletRequestFilter requestFilter = new HttpServletRequestFilter(\n                servletRequest, path, theServletPath, saveParametersAsAttributes);\n            String attributeName = getBeanName(o);\n            if (REQUEST_SCOPE.equals(scope)) {\n                requestFilter.setAttribute(attributeName, o);\n            } else if (SESSION_SCOPE.equals(scope)) {\n                requestFilter.getSession(true).setAttribute(attributeName, o);\n            } \n            setRequestParameters(requestFilter);\n            logRedirection(path, attributeName, o);\n            rd.forward(requestFilter, mc.getHttpServletResponse());\n        } catch (Throwable ex) {\n            mc.put(AbstractHTTPDestination.REQUEST_REDIRECTED, Boolean.FALSE);\n            ex.printStackTrace();\n            throw ExceptionUtils.toInternalServerErrorException(ex, null); \n        }\n    }","id":89549,"modified_method":"public void writeTo(Object o, Class<?> clazz, Type genericType, Annotation[] annotations, \n                        MediaType type, MultivaluedMap<String, Object> headers, OutputStream os)\n        throws IOException {\n        \n        ServletContext sc = getServletContext();\n        HttpServletRequest servletRequest = mc.getHttpServletRequest();\n        \n        String path = getResourcePath(clazz, o);\n        \n        String theServletPath = servletPath != null ? servletPath \n            : useCurrentServlet ? servletRequest.getServletPath() : \"/\";\n                \n        if (theServletPath.endsWith(\"/\") && path != null && path.startsWith(\"/\")) {\n            theServletPath = theServletPath.length() == 1 ? \"\" \n                : theServletPath.substring(0, theServletPath.length() - 1);\n        } else if (!theServletPath.endsWith(\"/\") && path != null && !path.startsWith(\"/\")) {\n            path = \"/\" + path;\n        }\n        \n        \n        RequestDispatcher rd = getRequestDispatcher(sc, clazz, theServletPath + path);\n        \n        try {\n            if (!includeResource) {\n                mc.put(AbstractHTTPDestination.REQUEST_REDIRECTED, Boolean.TRUE);\n            }\n            \n            HttpServletRequestFilter requestFilter = new HttpServletRequestFilter(\n                servletRequest, path, theServletPath, saveParametersAsAttributes);\n            String attributeName = getBeanName(o);\n            if (REQUEST_SCOPE.equals(scope)) {\n                requestFilter.setAttribute(attributeName, o);\n            } else if (SESSION_SCOPE.equals(scope)) {\n                requestFilter.getSession(true).setAttribute(attributeName, o);\n            } \n            setRequestParameters(requestFilter);\n            logRedirection(path, attributeName, o);\n            if (includeResource) {\n                rd.include(requestFilter, mc.getHttpServletResponse());\n            } else {\n                rd.forward(requestFilter, mc.getHttpServletResponse());\n            }\n        } catch (Throwable ex) {\n            mc.put(AbstractHTTPDestination.REQUEST_REDIRECTED, Boolean.FALSE);\n            ex.printStackTrace();\n            throw ExceptionUtils.toInternalServerErrorException(ex, null); \n        }\n    }","commit_id":"1946e323a0df6e5f9748af82106cff39d7b5d01f","url":"https://github.com/apache/cxf"},{"original_method":"public void testLimitsInFlightRequests() throws Exception {\n        ensureGreen();\n\n        // we use the limit size as a (very) rough indication on how many requests we should sent to hit the limit\n        int numRequests = LIMIT.bytesAsInt() / 50;\n\n        StringBuilder bulkRequest = new StringBuilder();\n        for (int i = 0; i < numRequests; i++) {\n            bulkRequest.append(\"{\\\"index\\\": {}}\");\n            bulkRequest.append(System.lineSeparator());\n            bulkRequest.append(\"{ \\\"field\\\" : \\\"value\\\" }\");\n            bulkRequest.append(System.lineSeparator());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Tuple<String, CharSequence>[] requests = new Tuple[] {\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest)\n        };\n\n        HttpServerTransport httpServerTransport = internalCluster().getInstance(HttpServerTransport.class);\n        InetSocketTransportAddress inetSocketTransportAddress = (InetSocketTransportAddress) randomFrom(httpServerTransport.boundAddress\n            ().boundAddresses());\n\n        try (NettyHttpClient nettyHttpClient = new NettyHttpClient()) {\n            Collection<HttpResponse> singleResponse = nettyHttpClient.post(inetSocketTransportAddress.address(), requests[0]);\n            assertThat(singleResponse, hasSize(1));\n            assertAtLeastOnceExpectedStatus(singleResponse, HttpResponseStatus.OK);\n\n            Collection<HttpResponse> multipleResponses = nettyHttpClient.post(inetSocketTransportAddress.address(), requests);\n            assertThat(multipleResponses, hasSize(requests.length));\n            assertAtLeastOnceExpectedStatus(multipleResponses, HttpResponseStatus.SERVICE_UNAVAILABLE);\n        }\n    }","id":89550,"modified_method":"public void testLimitsInFlightRequests() throws Exception {\n        ensureGreen();\n\n        // we use the limit size as a (very) rough indication on how many requests we should sent to hit the limit\n        int numRequests = LIMIT.bytesAsInt() / 100;\n\n        StringBuilder bulkRequest = new StringBuilder();\n        for (int i = 0; i < numRequests; i++) {\n            bulkRequest.append(\"{\\\"index\\\": {}}\");\n            bulkRequest.append(System.lineSeparator());\n            bulkRequest.append(\"{ \\\"field\\\" : \\\"value\\\" }\");\n            bulkRequest.append(System.lineSeparator());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Tuple<String, CharSequence>[] requests = new Tuple[] {\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest),\n            Tuple.tuple(\"/index/type/_bulk\", bulkRequest)\n        };\n\n        HttpServerTransport httpServerTransport = internalCluster().getInstance(HttpServerTransport.class);\n        InetSocketTransportAddress inetSocketTransportAddress = (InetSocketTransportAddress) randomFrom(httpServerTransport.boundAddress\n            ().boundAddresses());\n\n        try (NettyHttpClient nettyHttpClient = new NettyHttpClient()) {\n            Collection<HttpResponse> singleResponse = nettyHttpClient.post(inetSocketTransportAddress.address(), requests[0]);\n            assertThat(singleResponse, hasSize(1));\n            assertAtLeastOnceExpectedStatus(singleResponse, HttpResponseStatus.OK);\n\n            Collection<HttpResponse> multipleResponses = nettyHttpClient.post(inetSocketTransportAddress.address(), requests);\n            assertThat(multipleResponses, hasSize(requests.length));\n            assertAtLeastOnceExpectedStatus(multipleResponses, HttpResponseStatus.SERVICE_UNAVAILABLE);\n        }\n    }","commit_id":"b9faa13274a23c810acbc4fb58593f969db5ef4a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static boolean checkGStringInjectionForUnnecessaryBraces(PsiElement element) {\n    if (!(element instanceof GrStringInjection)) return false;\n    GrStringInjection injection = (GrStringInjection)element;\n    final GrClosableBlock block = injection.getClosableBlock();\n    if (block == null) return false;\n\n    final GrStatement[] statements = block.getStatements();\n    if (statements.length != 1) return false;\n\n    if (!(statements[0] instanceof GrReferenceExpression)) return false;\n\n    final PsiElement next = injection.getNextSibling();\n    if (!(next instanceof LeafPsiElement)) return false;\n\n    char nextChar = next.getText().charAt(0);\n    if (nextChar == '\"' || nextChar == '$') {\n      return true;\n    }\n    final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(element.getProject());\n    final GrExpression gString = elementFactory.createExpressionFromText(\"\\\"$\" + statements[0].getText() + nextChar + '\"');\n    final GrReferenceExpression refExpr = (GrReferenceExpression)statements[0];\n    final PsiElement refExprCopy = ((GrStringInjection)gString.getChildren()[0]).getReferenceExpression();\n    if (!(refExprCopy instanceof GrReferenceExpression)) return false;\n\n    return Comparing.equal(refExpr.getName(), ((GrReferenceExpression)refExprCopy).getName());\n  }","id":89551,"modified_method":"public static boolean checkGStringInjectionForUnnecessaryBraces(PsiElement element) {\n    if (!(element instanceof GrStringInjection)) return false;\n    GrStringInjection injection = (GrStringInjection)element;\n    final GrClosableBlock block = injection.getClosableBlock();\n    if (block == null) return false;\n\n    final GrStatement[] statements = block.getStatements();\n    if (statements.length != 1) return false;\n\n    if (!(statements[0] instanceof GrReferenceExpression)) return false;\n\n    final PsiElement next = injection.getNextSibling();\n    if (!(next instanceof LeafPsiElement)) return false;\n\n    char nextChar = next.getText().charAt(0);\n    if (nextChar == '\"' || nextChar == '$') {\n      return true;\n    }\n    final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(element.getProject());\n    final GrExpression gString;\n    try {\n      gString = elementFactory.createExpressionFromText(\"\\\"$\" + statements[0].getText() + nextChar + '\"');\n    }\n    catch (Exception e) {\n      return false;\n    }\n    if (!(gString instanceof GrString)) return false;\n\n    final PsiElement child = gString.getChildren()[0];\n    if (!(child instanceof GrStringInjection)) return false;\n\n    final PsiElement refExprCopy = ((GrStringInjection)child).getReferenceExpression();\n    if (!(refExprCopy instanceof GrReferenceExpression)) return false;\n\n    final GrReferenceExpression refExpr = (GrReferenceExpression)statements[0];\n    return Comparing.equal(refExpr.getName(), ((GrReferenceExpression)refExprCopy).getName());\n  }","commit_id":"ca3f1e3b5f53c376ba70054abe654a78be40db29","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkForVirtual(PsiMethodCallExpression methodCall) {\n      PsiReferenceExpression methodExpr = methodCall.getMethodExpression();\n      PsiExpression qualifier = methodExpr.getQualifierExpression();\n      if (!(qualifier instanceof PsiParenthesizedExpression)) return;\n      PsiExpression operand = ((PsiParenthesizedExpression)qualifier).getExpression();\n      if (!(operand instanceof PsiTypeCastExpression)) return;\n      PsiTypeCastExpression typeCast = (PsiTypeCastExpression)operand;\n      PsiExpression castOperand = typeCast.getOperand();\n      if (castOperand == null) return;\n\n      PsiType type = castOperand.getType();\n      if (type == null) return;\n      if (type instanceof PsiPrimitiveType) return;\n\n      final JavaResolveResult resolveResult = methodExpr.advancedResolve(false);\n      PsiMethod targetMethod = (PsiMethod)resolveResult.getElement();\n      if (targetMethod == null) return;\n      if (targetMethod.hasModifierProperty(PsiModifier.STATIC)) return;\n\n      try {\n        PsiManager manager = methodExpr.getManager();\n        PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n        PsiMethodCallExpression newCall = (PsiMethodCallExpression)factory.createExpressionFromText(methodCall.getText(), methodCall);\n        PsiExpression newQualifier = newCall.getMethodExpression().getQualifierExpression();\n        PsiExpression newOperand = ((PsiTypeCastExpression)((PsiParenthesizedExpression)newQualifier).getExpression()).getOperand();\n        newQualifier.replace(newOperand);\n\n        final JavaResolveResult newResult = newCall.getMethodExpression().advancedResolve(false);\n        if (!newResult.isValidResult()) return;\n        final PsiMethod newTargetMethod = (PsiMethod)newResult.getElement();\n        final PsiType newReturnType = newResult.getSubstitutor().substitute(newTargetMethod.getReturnType());\n        final PsiType oldReturnType = resolveResult.getSubstitutor().substitute(targetMethod.getReturnType());\n        if (Comparing.equal(newReturnType, oldReturnType)) {\n          if (newTargetMethod.equals(targetMethod) ||\n              (newTargetMethod.getSignature(newResult.getSubstitutor()).equals(targetMethod.getSignature(resolveResult.getSubstitutor())) &&\n               !(newTargetMethod.isDeprecated() && !targetMethod.isDeprecated()) &&  // see SCR11555, SCR14559\n               areThrownExceptionsCompatible(targetMethod, newTargetMethod))) {\n            addToResults(typeCast);\n          }\n        }\n      }\n      catch (IncorrectOperationException ignore) { }\n    }","id":89552,"modified_method":"private void checkForVirtual(PsiMethodCallExpression methodCall) {\n      PsiReferenceExpression methodExpr = methodCall.getMethodExpression();\n      PsiExpression qualifier = methodExpr.getQualifierExpression();\n      if (!(qualifier instanceof PsiParenthesizedExpression)) return;\n      PsiExpression operand = ((PsiParenthesizedExpression)qualifier).getExpression();\n      if (!(operand instanceof PsiTypeCastExpression)) return;\n      PsiTypeCastExpression typeCast = (PsiTypeCastExpression)operand;\n      PsiExpression castOperand = typeCast.getOperand();\n      if (castOperand == null) return;\n\n      PsiType type = castOperand.getType();\n      if (type == null) return;\n      if (type instanceof PsiPrimitiveType) return;\n\n      final JavaResolveResult resolveResult = methodExpr.advancedResolve(false);\n      PsiMethod targetMethod = (PsiMethod)resolveResult.getElement();\n      if (targetMethod == null) return;\n      if (targetMethod.hasModifierProperty(PsiModifier.STATIC)) return;\n\n      try {\n        PsiManager manager = methodExpr.getManager();\n        PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n        final PsiExpression expressionFromText = factory.createExpressionFromText(methodCall.getText(), methodCall);\n        if (!(expressionFromText instanceof PsiMethodCallExpression)) return;\n        PsiMethodCallExpression newCall = (PsiMethodCallExpression)expressionFromText;\n        PsiExpression newQualifier = newCall.getMethodExpression().getQualifierExpression();\n        PsiExpression newOperand = ((PsiTypeCastExpression)((PsiParenthesizedExpression)newQualifier).getExpression()).getOperand();\n        newQualifier.replace(newOperand);\n\n        final JavaResolveResult newResult = newCall.getMethodExpression().advancedResolve(false);\n        if (!newResult.isValidResult()) return;\n        final PsiMethod newTargetMethod = (PsiMethod)newResult.getElement();\n        final PsiType newReturnType = newResult.getSubstitutor().substitute(newTargetMethod.getReturnType());\n        final PsiType oldReturnType = resolveResult.getSubstitutor().substitute(targetMethod.getReturnType());\n        if (Comparing.equal(newReturnType, oldReturnType)) {\n          if (newTargetMethod.equals(targetMethod) ||\n              (newTargetMethod.getSignature(newResult.getSubstitutor()).equals(targetMethod.getSignature(resolveResult.getSubstitutor())) &&\n               !(newTargetMethod.isDeprecated() && !targetMethod.isDeprecated()) &&  // see SCR11555, SCR14559\n               areThrownExceptionsCompatible(targetMethod, newTargetMethod))) {\n            addToResults(typeCast);\n          }\n        }\n      }\n      catch (IncorrectOperationException ignore) { }\n    }","commit_id":"4ae52a9873b2a52f2b762ad099e9aade4745c0cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isPrimitiveNumericCastNecessary(PsiTypeCastExpression expression) {\n    final PsiType castType = expression.getType();\n    if (castType == null) {\n      return true;\n    }\n    final PsiExpression operand = expression.getOperand();\n    if (operand == null) {\n      return true;\n    }\n    final PsiType operandType = operand.getType();\n    PsiElement parent = expression.getParent();\n    while (parent instanceof PsiParenthesizedExpression) {\n      parent = parent.getParent();\n    }\n    if (parent instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)parent;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      if (binaryPromotionOperators.contains(tokenType)) {\n        if (TypeUtils.isNarrowingConversion(operandType, castType)) {\n          return true;\n        }\n        if (PsiType.INT.equals(castType)) {\n          return PsiType.LONG.equals(operandType) || PsiType.FLOAT.equals(operandType) || PsiType.DOUBLE.equals(operandType);\n        }\n        if (PsiType.LONG.equals(castType) || PsiType.FLOAT.equals(castType) || PsiType.DOUBLE.equals(castType)) {\n          final PsiExpression[] operands = polyadicExpression.getOperands();\n          for (PsiExpression operand1 : operands) {\n            if (PsiTreeUtil.isAncestor(operand1, expression, false)) {\n              continue;\n            }\n            final PsiType type = operand1.getType();\n            if (castType.equals(type)) {\n              return false;\n            }\n          }\n        }\n      }\n      else if (JavaTokenType.GTGT.equals(tokenType) || JavaTokenType.GTGTGT.equals(tokenType) || JavaTokenType.LTLT.equals(tokenType)) {\n        final PsiExpression firstOperand = polyadicExpression.getOperands()[0];\n        if (!PsiTreeUtil.isAncestor(firstOperand, expression, false)) {\n          return false;\n        }\n        return PsiType.LONG.equals(castType) || !isLegalWideningConversion(operand, PsiType.INT);\n      }\n      return true;\n    }\n    else if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)parent;\n      final PsiType lhsType = assignmentExpression.getType();\n      return !castType.equals(lhsType) || !isLegalAssignmentConversion(operand, lhsType);\n    }\n    else if (parent instanceof PsiVariable) {\n      final PsiVariable variable = (PsiVariable)parent;\n      final PsiType lhsType = variable.getType();\n      return !castType.equals(lhsType) || !isLegalAssignmentConversion(operand, lhsType);\n    }\n    else if (parent instanceof PsiExpressionList) {\n      final PsiExpressionList expressionList = (PsiExpressionList)parent;\n      final PsiElement grandParent = expressionList.getParent();\n      if (!(grandParent instanceof PsiCallExpression)) {\n        return true;\n      }\n      final PsiCallExpression callExpression = (PsiCallExpression)grandParent;\n      final PsiMethod targetMethod = callExpression.resolveMethod();\n      if (targetMethod == null) {\n        return true;\n      }\n      final PsiElement[] children = callExpression.getChildren();\n      final StringBuilder newMethodCallText = new StringBuilder();\n      for (PsiElement child : children) {\n        if (child != expressionList) {\n          newMethodCallText.append(child.getText());\n          continue;\n        }\n        newMethodCallText.append('(');\n        final PsiExpression[] arguments = expressionList.getExpressions();\n        boolean comma = false;\n        for (PsiExpression argument : arguments) {\n          if (comma) {\n            newMethodCallText.append(',');\n          }\n          else {\n            comma = true;\n          }\n          if (PsiTreeUtil.isAncestor(argument, expression, false)) {\n            newMethodCallText.append(operand.getText());\n          }\n          else {\n            newMethodCallText.append(argument.getText());\n          }\n        }\n        newMethodCallText.append(')');\n      }\n      final Project project = expression.getProject();\n      final JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);\n      final PsiElementFactory factory = javaPsiFacade.getElementFactory();\n      final PsiCallExpression newMethodCall = (PsiCallExpression)\n        factory.createExpressionFromText(newMethodCallText.toString(), expression);\n      if (targetMethod != newMethodCall.resolveMethod()) {\n        return true;\n      }\n    }\n    final PsiType expectedType = ExpectedTypeUtils.findExpectedType(expression, false);\n    return !castType.equals(expectedType) || !isLegalWideningConversion(operand, castType);\n  }","id":89553,"modified_method":"public static boolean isPrimitiveNumericCastNecessary(PsiTypeCastExpression expression) {\n    final PsiType castType = expression.getType();\n    if (castType == null) {\n      return true;\n    }\n    final PsiExpression operand = expression.getOperand();\n    if (operand == null) {\n      return true;\n    }\n    final PsiType operandType = operand.getType();\n    PsiElement parent = expression.getParent();\n    while (parent instanceof PsiParenthesizedExpression) {\n      parent = parent.getParent();\n    }\n    if (parent instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)parent;\n      final IElementType tokenType = polyadicExpression.getOperationTokenType();\n      if (binaryPromotionOperators.contains(tokenType)) {\n        if (TypeUtils.isNarrowingConversion(operandType, castType)) {\n          return true;\n        }\n        if (PsiType.INT.equals(castType)) {\n          return PsiType.LONG.equals(operandType) || PsiType.FLOAT.equals(operandType) || PsiType.DOUBLE.equals(operandType);\n        }\n        if (PsiType.LONG.equals(castType) || PsiType.FLOAT.equals(castType) || PsiType.DOUBLE.equals(castType)) {\n          final PsiExpression[] operands = polyadicExpression.getOperands();\n          for (PsiExpression operand1 : operands) {\n            if (PsiTreeUtil.isAncestor(operand1, expression, false)) {\n              continue;\n            }\n            final PsiType type = operand1.getType();\n            if (castType.equals(type)) {\n              return false;\n            }\n          }\n        }\n      }\n      else if (JavaTokenType.GTGT.equals(tokenType) || JavaTokenType.GTGTGT.equals(tokenType) || JavaTokenType.LTLT.equals(tokenType)) {\n        final PsiExpression firstOperand = polyadicExpression.getOperands()[0];\n        if (!PsiTreeUtil.isAncestor(firstOperand, expression, false)) {\n          return false;\n        }\n        return PsiType.LONG.equals(castType) || !isLegalWideningConversion(operand, PsiType.INT);\n      }\n      return true;\n    }\n    else if (parent instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)parent;\n      final PsiType lhsType = assignmentExpression.getType();\n      return !castType.equals(lhsType) || !isLegalAssignmentConversion(operand, lhsType);\n    }\n    else if (parent instanceof PsiVariable) {\n      final PsiVariable variable = (PsiVariable)parent;\n      final PsiType lhsType = variable.getType();\n      return !castType.equals(lhsType) || !isLegalAssignmentConversion(operand, lhsType);\n    }\n    else if (parent instanceof PsiExpressionList) {\n      final PsiExpressionList expressionList = (PsiExpressionList)parent;\n      final PsiElement grandParent = expressionList.getParent();\n      if (!(grandParent instanceof PsiCallExpression)) {\n        return true;\n      }\n      final PsiCallExpression callExpression = (PsiCallExpression)grandParent;\n      final PsiMethod targetMethod = callExpression.resolveMethod();\n      if (targetMethod == null) {\n        return true;\n      }\n      final PsiElement[] children = callExpression.getChildren();\n      final StringBuilder newMethodCallText = new StringBuilder();\n      for (PsiElement child : children) {\n        if (child != expressionList) {\n          newMethodCallText.append(child.getText());\n          continue;\n        }\n        newMethodCallText.append('(');\n        final PsiExpression[] arguments = expressionList.getExpressions();\n        boolean comma = false;\n        for (PsiExpression argument : arguments) {\n          if (comma) {\n            newMethodCallText.append(',');\n          }\n          else {\n            comma = true;\n          }\n          if (PsiTreeUtil.isAncestor(argument, expression, false)) {\n            newMethodCallText.append(operand.getText());\n          }\n          else {\n            newMethodCallText.append(argument.getText());\n          }\n        }\n        newMethodCallText.append(')');\n      }\n      final Project project = expression.getProject();\n      final JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);\n      final PsiElementFactory factory = javaPsiFacade.getElementFactory();\n      final PsiExpression expressionFromText = factory.createExpressionFromText(newMethodCallText.toString(), expression);\n      if (expressionFromText instanceof PsiCallExpression) {\n        final PsiCallExpression newMethodCall = (PsiCallExpression)expressionFromText;\n        if (targetMethod != newMethodCall.resolveMethod()) {\n          return true;\n        }\n      }\n    }\n    final PsiType expectedType = ExpectedTypeUtils.findExpectedType(expression, false);\n    return !castType.equals(expectedType) || !isLegalWideningConversion(operand, castType);\n  }","commit_id":"ffa841ab44f6a167648c10897796dc539cad7bec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void store(BridgeElement bridge) {\n        // TODO Auto-generated method stub\n\n    }","id":89554,"modified_method":"@Override\n    public synchronized void parse(int nodeid,BridgeElement element) {\n        if (!m_notYetParsedEleMap.containsKey(nodeid))\n            m_notYetParsedEleMap.put(nodeid, new ArrayList<BridgeElement>());\n        m_notYetParsedEleMap.get(nodeid).add(element);\n        \n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void walked(int nodeid) {\n        // TODO Auto-generated method stub\n\n    }","id":89555,"modified_method":"@Override\n    public synchronized void walked(int nodeid) {\n        BroadcastDomain elemdomain = null;\n        for (BroadcastDomain domain: m_domains) {\n            if (domain.containBridgeId(nodeid)) {\n                elemdomain = domain;\n                break;\n            }\n        }\n        if (elemdomain != null) {\n            elemdomain.deleteBridge(nodeid);\n            if (elemdomain.isEmpty())\n                m_domains.remove(elemdomain);\n        }        \n\n        List<BridgeMacLink> bft = m_notYetParsedBFTMap.remove(nodeid);\n        BroadcastDomain bftdomain = null;\n        for (BroadcastDomain domain: m_domains) {\n            if (domain.checkBridgeOnDomain(bft)) {\n                bftdomain = domain;\n                break;\n            }\n        }\n        if (bftdomain == null) {\n            bftdomain = new BroadcastDomain();\n            m_domains.add(bftdomain);\n        }\n        for (BridgeElement element: m_notYetParsedEleMap.remove(nodeid))\n            bftdomain.addBridgeElement(element);\n        bftdomain.loadBFT(nodeid,bft,m_notYetParsedSTPMap.remove(nodeid));\n\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public BroadcastDomain getBroadcastDomain(int nodeid) {\n        // TODO Auto-generated method stub\n        return null;\n    }","id":89556,"modified_method":"@Override\n    public synchronized BroadcastDomain getBroadcastDomain(int nodeid) {\n        for (BroadcastDomain domain: m_domains) {\n            if (domain.containBridgeId(nodeid))\n                return domain;\n        }\n        return null;\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void delete(int nodeid) {\n        // TODO Auto-generated method stub\n    }","id":89557,"modified_method":"@Override\n    public synchronized void delete(int nodeid) {\n        BroadcastDomain domain = getBroadcastDomain(nodeid);\n        if (domain != null)\n            domain.deleteBridge(nodeid);\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void parse(int nodeid, BridgeStpLink stplink) {\n        // TODO Auto-generated method stub\n\n    }","id":89558,"modified_method":"@Override\n    public synchronized void parse(int nodeid, BridgeStpLink stplink) {\n        if (!m_notYetParsedSTPMap.containsKey(nodeid))\n            m_notYetParsedSTPMap.put(nodeid, new ArrayList<BridgeStpLink>());\n        m_notYetParsedSTPMap.get(nodeid).add(stplink);\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void parse(int nodeid,BridgeMacLink maclink) {\n        // TODO Auto-generated method stub\n\n    }","id":89559,"modified_method":"@Override\n    public synchronized void parse(int nodeid,BridgeMacLink maclink) {\n        if (!m_notYetParsedBFTMap.containsKey(nodeid))\n            m_notYetParsedBFTMap.put(nodeid, new ArrayList<BridgeMacLink>());\n        m_notYetParsedBFTMap.get(nodeid).add(maclink);\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((m_id == null) ? 0 : m_id.hashCode());\n            return result;\n        }","id":89560,"modified_method":"@Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + getOuterType().hashCode();\n            result = prime * result + ((m_id == null) ? 0 : m_id.hashCode());\n            return result;\n        }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Set<String> getBridgeIds() {\n            return m_bridgeIds;\n        }","id":89561,"modified_method":"public Set<BridgeElement> getBridgeElementIds() {\n            return m_bridgeIds;\n        }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Date getUpdateTime(int nodeid) {\n        return null;\n    }","id":89562,"modified_method":"public synchronized Date getUpdateTime() {\n        return null;\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Set<String> getMacsOnDomain() {\n        Set<String>macs = new HashSet<String>();\n        return macs;\n    }","id":89563,"modified_method":"public synchronized Set<String> getMacsOnDomain() {\n        Set<String>macs = new HashSet<String>();\n        for (SharedSegment segment: m_topology) \n            macs.addAll(segment.getMacsOnSegment());\n        return macs;\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean topologyChanged(int nodeid) {\n        return false;\n    }","id":89564,"modified_method":"public synchronized boolean topologyChanged() {\n        return m_topologyChanged;\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void addBridge(Bridge bridge) {\n        m_bridges.add(bridge);\n    }","id":89565,"modified_method":"public synchronized void addBridgeElement(BridgeElement bridgeElement) {\n        for (Bridge bridge: m_bridges) {\n            if (bridge.getId() == bridgeElement.getNode().getId()) {\n                bridge.addBridgeElement(bridgeElement);\n            }\n        }\n        m_bridges.add(new Bridge(bridgeElement));\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Bridge other = (Bridge) obj;\n            if (m_id == null) {\n                if (other.m_id != null)\n                    return false;\n            } else if (!m_id.equals(other.m_id))\n                return false;\n            return true;\n        }","id":89566,"modified_method":"@Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Bridge other = (Bridge) obj;\n            if (!getOuterType().equals(other.getOuterType()))\n                return false;\n            if (m_id == null) {\n                if (other.m_id != null)\n                    return false;\n            } else if (!m_id.equals(other.m_id))\n                return false;\n            return true;\n        }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<SharedSegment> getTopology() {\n        return null;\n    }","id":89567,"modified_method":"public synchronized List<SharedSegment> getTopology() {\n        return m_topology;\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<Integer> getUpdatedNodes(int nodeid) {\n      return null;  \n    }","id":89568,"modified_method":"public synchronized Set<Integer> getUpdatedNodes() {\n      return m_updatedNodes;  \n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void loadBridgeTopology() {\n\t    for (BridgeElement bridge: m_bridgeElementDao.findAll())\n\t        m_bridgeTopologyDao.store(bridge);\n\n\t    for (BridgeMacLink link: m_bridgeMacLinkDao.findAll()) \n\t        m_bridgeTopologyDao.store(link);\n\n\t    for (BridgeBridgeLink link: m_bridgeBridgeLinkDao.findAll()) \n\t        m_bridgeTopologyDao.store(link);\n\t}","id":89569,"modified_method":"public void loadBridgeTopology() {\n\t        m_bridgeTopologyDao.loadTopology(m_bridgeElementDao.findAll(),\n\t                                         m_bridgeMacLinkDao.findAll(), \n\t                                         m_bridgeBridgeLinkDao.findAll());\t}","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Transactional\n    protected void saveBridgeMacLink(int nodeId, final BridgeMacLink saveMe) {\n\t\tnew UpsertTemplate<BridgeMacLink, BridgeMacLinkDao>(m_transactionManager,m_bridgeMacLinkDao) {\n\n\t\t\t@Override\n\t\t\tprotected BridgeMacLink query() {\n\t\t\t\treturn m_dao.getByNodeIdBridgePortMac(nodeId,saveMe.getBridgePort(),saveMe.getMacAddress());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeMacLink doUpdate(BridgeMacLink link) {\n\t\t\t\tlink.merge(saveMe);\n\t\t\t\tm_dao.update(link);\n\t\t\t\tm_dao.flush();\n\t\t\t\treturn link;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeMacLink doInsert() {\n                            final OnmsNode node = m_nodeDao.get(nodeId);\n                            if ( node == null )\n                                    return null;\n                            saveMe.setNode(node);\n                            saveMe.setBridgeMacLinkLastPollTime(saveMe.getBridgeMacLinkCreateTime());\n                            m_dao.saveOrUpdate(saveMe);\n                            m_dao.flush();\n                            return saveMe;\n\t\t\t}\n\t\t\t\n\t\t}.execute();\n\t}","id":89570,"modified_method":"@Transactional\n    protected void saveBridgeMacLink(final BridgeMacLink saveMe) {\n\t\tnew UpsertTemplate<BridgeMacLink, BridgeMacLinkDao>(m_transactionManager,m_bridgeMacLinkDao) {\n\n\t\t\t@Override\n\t\t\tprotected BridgeMacLink query() {\n\t\t\t\treturn m_dao.getByNodeIdBridgePortMac(saveMe.getNode().getId(),saveMe.getBridgePort(),saveMe.getMacAddress());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeMacLink doUpdate(BridgeMacLink link) {\n\t\t\t\tlink.merge(saveMe);\n\t\t\t\tm_dao.update(link);\n\t\t\t\tm_dao.flush();\n\t\t\t\treturn link;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeMacLink doInsert() {\n                            final OnmsNode node = m_nodeDao.get(saveMe.getNode().getId());\n                            if ( node == null )\n                                    return null;\n                            saveMe.setNode(node);\n                            m_dao.saveOrUpdate(saveMe);\n                            m_dao.flush();\n                            return saveMe;\n\t\t\t}\n\t\t\t\n\t\t}.execute();\n\t}","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Transactional\n    protected void saveBridgeBridgeLink(int nodeId, final BridgeBridgeLink saveMe) {\n\t\tnew UpsertTemplate<BridgeBridgeLink, BridgeBridgeLinkDao>(m_transactionManager,m_bridgeBridgeLinkDao) {\n\n\t\t\t@Override\n\t\t\tprotected BridgeBridgeLink query() {\n\t\t\t\treturn m_dao.getByNodeIdBridgePort(nodeId,saveMe.getBridgePort());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeBridgeLink doUpdate(BridgeBridgeLink link) {\n\t\t\t\tlink.merge(saveMe);\n\t\t\t\tm_dao.update(link);\n\t\t\t\tm_dao.flush();\n\t\t\t\treturn link;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeBridgeLink doInsert() {\n                            final OnmsNode node = m_nodeDao.get(nodeId);\n                            if ( node == null )\n                                    return null;\n                            saveMe.setNode(node);\n                            saveMe.setBridgeBridgeLinkLastPollTime(saveMe.getBridgeBridgeLinkCreateTime());\n                            m_dao.saveOrUpdate(saveMe);\n                            m_dao.flush();\n                            return saveMe;\n\t\t\t}\n\t\t\t\n\t\t}.execute();\n\t}","id":89571,"modified_method":"@Transactional\n    protected void saveBridgeBridgeLink(final BridgeBridgeLink saveMe) {\n\t\tnew UpsertTemplate<BridgeBridgeLink, BridgeBridgeLinkDao>(m_transactionManager,m_bridgeBridgeLinkDao) {\n\n\t\t\t@Override\n\t\t\tprotected BridgeBridgeLink query() {\n\t\t\t\treturn m_dao.getByNodeIdBridgePort(saveMe.getNode().getId(),saveMe.getBridgePort());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeBridgeLink doUpdate(BridgeBridgeLink link) {\n\t\t\t\tlink.merge(saveMe);\n\t\t\t\tm_dao.update(link);\n\t\t\t\tm_dao.flush();\n\t\t\t\treturn link;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected BridgeBridgeLink doInsert() {\n                            final OnmsNode node = m_nodeDao.get(saveMe.getNode().getId());\n                            if ( node == null )\n                                    return null;\n                            saveMe.setNode(node);\n                            m_dao.saveOrUpdate(saveMe);\n                            m_dao.flush();\n                            return saveMe;\n\t\t\t}\n\t\t\t\n\t\t}.execute();\n\t}","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n        public void storeBridgeTopology(int nodeId) {\n            \n            BroadcastDomain domain = m_bridgeTopologyDao.getBroadcastDomain(nodeId);\n            if (!domain.topologyChanged(nodeId))\n                return;\n            for (SharedSegment segment: domain.getTopology()) {\n                if (segment.noMacsOnSegment()) {\n                    for (BridgeBridgeLink link: segment.getBridgeBridgeLinks()) \n                        saveBridgeBridgeLink(nodeId, link);\n                } else {\n                    for (BridgeMacLink link: segment.getBridgeMacLinks())\n                        saveBridgeMacLink(nodeId,link);\n                }\n            }\n            \n            Date updatedate=domain.getUpdateTime(nodeId);\n            for (Integer curNodeId: domain.getUpdatedNodes(nodeId)) {\n                m_bridgeMacLinkDao.deleteByNodeIdOlderThen(curNodeId, updatedate);\n                m_bridgeMacLinkDao.flush();\n                m_bridgeBridgeLinkDao.deleteByNodeIdOlderThen(curNodeId, updatedate);\n                m_bridgeBridgeLinkDao.deleteByDesignatedNodeIdOlderThen(curNodeId, updatedate);\n                m_bridgeBridgeLinkDao.flush();\n            }\n\n        }","id":89572,"modified_method":"@Override\n        public BroadcastDomain getBridgeTopologyBroadcastDomain(int nodeId) {\n            return m_bridgeTopologyDao.getBroadcastDomain(nodeId);\n        }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void store(int nodeId, BridgeElement bridge) {\n\t\tif (bridge == null)\n\t\t\treturn;\n\t\tsaveBridgeElement(nodeId, bridge);\n\t\tm_bridgeTopologyDao.store(bridge);\n\t}","id":89573,"modified_method":"@Override\n\tpublic void store(int nodeId, BridgeElement bridge) {\n\t\tif (bridge == null)\n\t\t\treturn;\n\t\tsaveBridgeElement(nodeId, bridge);\n\t\tm_bridgeTopologyDao.parse(nodeId,bridge);\n\t}","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void runCollection() {\n        m_linkd.getQueryManager().storeBridgeTopology(getNodeId());\n    }","id":89574,"modified_method":"@Override\n    protected void runCollection() {\n        \n        final Date now = new Date();\n\n\n        BroadcastDomain domain = m_linkd.getQueryManager().getBridgeTopologyBroadcastDomain(getNodeId());\n        if (domain == null ) {\n            LOG.warn(\"run: no broadcast domain found fir node: {}\", getNodeId());\n            return;\n        }\n        if (!domain.topologyChanged()) {\n            LOG.info(\"run: broadcast domain with no topology change found for node: {}. exiting...\", getNodeId());\n            return;\n        }\n        LOG.info(\"run: calculating broadcast domain with topology change found for node: {}. nodes in domain {}\", getNodeId(),\n                 domain.getUpdatedNodes());\n        domain.calculate();\n        LOG.info(\"run: broadcast domain topology for node: {}. calculated.\", getNodeId());\n        LOG.info(\"run: saving broadcast domain topology for node: {}.\", getNodeId());\n        m_linkd.getQueryManager().store(domain, now);\n        LOG.info(\"run: saved broadcast domain topology for node: {}.\", getNodeId());\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void add(BridgeBridgeLink link) {\n        \n    }","id":89575,"modified_method":"public void add(BridgeBridgeLink link) {\n        m_bridgeportsOnLink.add(link);\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void add(BridgeMacLink link) {\n        \n    }","id":89576,"modified_method":"public void add(BridgeMacLink link) {\n        m_bridgeportsOnSegment.add(link);\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean containsMac(String mac) {\n        for (BridgeMacLink link: m_bridgeportsOnSegment) {\n            if (mac != null && mac.equals(link.getMacAddress()))\n                return true;\n        }\n        return false;\n    }","id":89577,"modified_method":"public boolean containsMac(String mac) {\n        if ( mac == null) \n            return false;\n        for (BridgeMacLink link: m_bridgeportsOnSegment) {\n            if (mac.equals(link.getMacAddress()))\n                return true;\n        }\n        return false;\n    }","commit_id":"72613d726718ebc9ae1eb03d65f697304a7e09d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Nullable\n  @Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n    ExecutionResult executionResult = state.execute(executor, this);\n    if (executionResult == null) return null;\n\n    final RunContentBuilder contentBuilder = new RunContentBuilder(project, this, executor, executionResult, env);\n    return contentBuilder.showRunContent(contentToReuse);\n  }","id":89578,"modified_method":"@Nullable\n  @Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n    ExecutionResult executionResult = state.execute(executor, this);\n    if (executionResult == null) return null;\n    KarmaServer karmaServer = null;\n    if (state instanceof KarmaTestRunnerState) {\n      karmaServer = ((KarmaTestRunnerState) state).getKarmaServer();\n    }\n\n    final RunContentBuilder contentBuilder = new RunContentBuilder(project, this, executor, executionResult, env);\n    RunContentDescriptor descriptor = contentBuilder.showRunContent(contentToReuse);\n    if (karmaServer != null) {\n      KarmaServerLogComponent logComponent = new KarmaServerLogComponent(project, karmaServer);\n      contentBuilder.addAdditionalTabComponent(logComponent, karmaServer.getConfigurationFile().getAbsolutePath());\n    }\n    return descriptor;\n  }","commit_id":"1a0208bbefd64a807cf54a7edcc3c599d5052bce","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public KarmaServer(@NotNull File nodeInterpreter,\n                     @NotNull File karmaPackageDir,\n                     @NotNull File configurationFile) throws IOException {\n    /* 'nodeInterpreter', 'karmaPackageDir' and 'configurationFile'\n        are already checked in KarmaRunConfiguration.checkConfiguration */\n    myConfigurationFile = configurationFile;\n    myKarmaIntellijDir = findKarmaIntellijDir(karmaPackageDir);\n    myProcessHandler = startServer(nodeInterpreter, configurationFile);\n    Disposer.register(ApplicationManager.getApplication(), this);\n  }","id":89579,"modified_method":"public KarmaServer(@NotNull File nodeInterpreter,\n                     @NotNull File karmaPackageDir,\n                     @NotNull File configurationFile) throws IOException {\n    /* 'nodeInterpreter', 'karmaPackageDir' and 'configurationFile'\n        are already checked in KarmaRunConfiguration.checkConfiguration */\n    myConfigurationFile = configurationFile;\n    myKarmaIntellijDir = findKarmaIntellijDir(karmaPackageDir);\n    myProcessHandler = startServer(nodeInterpreter, configurationFile);\n    Disposer.register(ApplicationManager.getApplication(), new Disposable() {\n      @Override\n      public void dispose() {\n        myProcessHandler.destroyProcess();\n      }\n    });\n  }","commit_id":"1a0208bbefd64a807cf54a7edcc3c599d5052bce","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private KillableColoredProcessHandler startServer(@NotNull File nodeInterpreter,\n                                                    @NotNull File configurationFile) throws IOException {\n    GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setPassParentEnvironment(true);\n    commandLine.setWorkDirectory(configurationFile.getParentFile());\n    commandLine.setExePath(nodeInterpreter.getAbsolutePath());\n    File serverFile = getServerAppFile();\n    commandLine.addParameter(serverFile.getAbsolutePath());\n    commandLine.addParameter(\"--configFile=\" + configurationFile.getAbsolutePath());\n\n    try {\n      Process process = commandLine.createProcess();\n      KillableColoredProcessHandler processHandler = new KillableColoredProcessHandler(process, commandLine.getCommandLineString(), CharsetToolkit.UTF8_CHARSET);\n\n      processHandler.addProcessListener(new ProcessAdapter() {\n        @Override\n        public void onTextAvailable(ProcessEvent event, Key outputType) {\n          String text = event.getText().trim();\n          if (text != null && outputType == ProcessOutputTypes.STDOUT) {\n            handleStdout(text);\n          }\n        }\n\n        @Override\n        public void processTerminated(ProcessEvent event) {\n          myTerminated = true;\n          KarmaServerRegistry.serverTerminated(KarmaServer.this);\n        }\n      });\n      processHandler.startNotify();\n      processHandler.setShouldDestroyProcessRecursively(true);\n      return processHandler;\n    }\n    catch (ExecutionException e) {\n      throw new IOException(\"Can not create karma server process\", e);\n    }\n  }","id":89580,"modified_method":"private KillableColoredProcessHandler startServer(@NotNull File nodeInterpreter,\n                                                    @NotNull File configurationFile) throws IOException {\n    GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setPassParentEnvironment(true);\n    commandLine.setWorkDirectory(configurationFile.getParentFile());\n    commandLine.setExePath(nodeInterpreter.getAbsolutePath());\n    File serverFile = getServerAppFile();\n    commandLine.addParameter(serverFile.getAbsolutePath());\n    commandLine.addParameter(\"--configFile=\" + configurationFile.getAbsolutePath());\n\n    try {\n      LOG.info(\"Starting karma server: \" + commandLine.getCommandLineString());\n      Process originalProcess = commandLine.createProcess();\n      Process eventEmitterProcess = new EventEmitterProcess(originalProcess);\n      KillableColoredProcessHandler processHandler = new KillableColoredProcessHandler(\n        eventEmitterProcess,\n        commandLine.getCommandLineString(),\n        CharsetToolkit.UTF8_CHARSET\n      );\n\n      processHandler.addProcessListener(new ProcessAdapter() {\n        @Override\n        public void onTextAvailable(ProcessEvent event, Key outputType) {\n          String text = event.getText().trim();\n          if (text != null && outputType == ProcessOutputTypes.STDOUT) {\n            handleStdout(text);\n          }\n        }\n\n        @Override\n        public void processTerminated(ProcessEvent event) {\n          KarmaServerRegistry.serverTerminated(KarmaServer.this);\n        }\n      });\n      processHandler.startNotify();\n      processHandler.setShouldDestroyProcessRecursively(true);\n      ProcessTerminatedListener.attach(processHandler);\n      return processHandler;\n    }\n    catch (ExecutionException e) {\n      throw new IOException(\"Can not create karma server process\", e);\n    }\n  }","commit_id":"1a0208bbefd64a807cf54a7edcc3c599d5052bce","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public KarmaTestRunnerProcess(@NotNull Process process) {\n    myProcess = process;\n    InputStream inputStream = process.getInputStream();\n    myFilteringInputStream = new CommandInputStream(inputStream, CharsetToolkit.UTF8_CHARSET);\n    myOutputStream = process.getOutputStream();\n  }","id":89581,"modified_method":"public KarmaTestRunnerProcess(@NotNull Process process) {\n    myProcess = process;\n    InputStream inputStream = process.getInputStream();\n    myFilteringInputStream = new EventEmitterInputStream(inputStream, CharsetToolkit.UTF8_CHARSET);\n    myOutputStream = process.getOutputStream();\n  }","commit_id":"1a0208bbefd64a807cf54a7edcc3c599d5052bce","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public CommandInputStream getInputStream() {\n    return myFilteringInputStream;\n  }","id":89582,"modified_method":"@Override\n  public EventEmitterInputStream getInputStream() {\n    return myFilteringInputStream;\n  }","commit_id":"1a0208bbefd64a807cf54a7edcc3c599d5052bce","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  @NotNull\n  public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    File configurationFile = new File(myRunSettings.getConfigPath());\n    KarmaServer server = KarmaServerRegistry.getServerByConfigurationFile(configurationFile);\n    if (server == null) {\n      try {\n        server = new KarmaServer(new File(myNodeInterpreterPath), new File(myKarmaPackageDir), configurationFile);\n        KarmaServerRegistry.registerServer(server);\n      }\n      catch (IOException e) {\n        throw new ExecutionException(e);\n      }\n    }\n    ProcessHandler processHandler = startProcess(server);\n    ConsoleView consoleView = createConsole(myProject, myExecutionEnvironment, executor);\n    consoleView.attachToProcess(processHandler);\n\n    DefaultExecutionResult executionResult = new DefaultExecutionResult(consoleView, processHandler);\n    executionResult.setRestartActions(new ToggleAutoTestAction());\n    return executionResult;\n  }","id":89583,"modified_method":"@Override\n  @NotNull\n  public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    File configurationFile = new File(myRunSettings.getConfigPath());\n    KarmaServer server = KarmaServerRegistry.getServerByConfigurationFile(configurationFile);\n    if (server == null) {\n      try {\n        server = new KarmaServer(new File(myNodeInterpreterPath), new File(myKarmaPackageDir), configurationFile);\n        KarmaServerRegistry.registerServer(server);\n      }\n      catch (IOException e) {\n        throw new ExecutionException(e);\n      }\n    }\n    myKarmaServer = server;\n    ProcessHandler processHandler = startProcess(server);\n    ConsoleView consoleView = createConsole(myProject, myExecutionEnvironment, executor);\n    consoleView.attachToProcess(processHandler);\n\n    DefaultExecutionResult executionResult = new DefaultExecutionResult(consoleView, processHandler);\n    executionResult.setRestartActions(new ToggleAutoTestAction());\n    return executionResult;\n  }","commit_id":"1a0208bbefd64a807cf54a7edcc3c599d5052bce","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Load channel configuration.\n     * \n     * @param channelId the identifier of the channel\n     * @return the channel configuration\n     * @throws IOException failed to load configuration file\n     * @throws ChannelException failed to creation channel configuration\n     */\n    private ProtocolStackConfigurator loadChannelConfiguration(String channelId) throws IOException, ChannelException\n    {\n        String channelFile = channelId + \".xml\";\n        String path = \"/WEB-INF/\" + CONFIGURATION_PATH + channelFile;\n\n        InputStream is = null;\n        try {\n            Environment environment = this.componentManager.getInstance(Environment.class);\n            is = environment.getResourceAsStream(path);\n        } catch (ComponentLookupException e) {\n            // Environment not found, continue by fallbacking on JGroups's standard configuration.\n            this.logger.debug(\"Failed to lookup the Environment component.\", e);\n        }\n\n        if (is == null) {\n            // Fallback on JGroups standard configuration locations\n            is = ConfiguratorFactory.getConfigStream(channelFile);\n\n            if (is == null && !JChannel.DEFAULT_PROTOCOL_STACK.equals(channelFile)) {\n                // Fallback on default JGroups configuration\n                is = ConfiguratorFactory.getConfigStream(JChannel.DEFAULT_PROTOCOL_STACK);\n            }\n        }\n\n        return XmlConfigurator.getInstance(is);\n    }","id":89584,"modified_method":"/**\n     * Load channel configuration.\n     * \n     * @param channelId the identifier of the channel\n     * @return the channel configuration\n     * @throws IOException failed to load configuration file\n     */\n    private ProtocolStackConfigurator loadChannelConfiguration(String channelId) throws IOException\n    {\n        String channelFile = channelId + \".xml\";\n        String path = \"/WEB-INF/\" + CONFIGURATION_PATH + channelFile;\n\n        InputStream is = null;\n        try {\n            Environment environment = this.componentManager.getInstance(Environment.class);\n            is = environment.getResourceAsStream(path);\n        } catch (ComponentLookupException e) {\n            // Environment not found, continue by fallbacking on JGroups's standard configuration.\n            this.logger.debug(\"Failed to lookup the Environment component.\", e);\n        }\n\n        if (is == null) {\n            // Fallback on JGroups standard configuration locations\n            is = ConfiguratorFactory.getConfigStream(channelFile);\n\n            if (is == null && !JChannel.DEFAULT_PROTOCOL_STACK.equals(channelFile)) {\n                // Fallback on default JGroups configuration\n                is = ConfiguratorFactory.getConfigStream(JChannel.DEFAULT_PROTOCOL_STACK);\n            }\n        }\n\n        return XmlConfigurator.getInstance(is);\n    }","commit_id":"c8aa989c146347812920a92287f8a55b2540bfa5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create a new channel.\n     * \n     * @param channelId the identifier of the channel to create\n     * @return the new channel\n     * @throws ComponentLookupException failed to get default {@link JGroupsReceiver}\n     * @throws ChannelException failed to create channel\n     */\n    private JChannel createChannel(String channelId) throws ComponentLookupException, ChannelException\n    {\n        // load configuration\n        ProtocolStackConfigurator channelConf;\n        try {\n            channelConf = loadChannelConfiguration(channelId);\n        } catch (IOException e) {\n            throw new ChannelException(\"Failed to load configuration for the channel [\" + channelId + \"]\", e);\n        }\n\n        // get Receiver\n        JGroupsReceiver channelReceiver;\n        try {\n            channelReceiver = this.componentManager.getInstance(JGroupsReceiver.class, channelId);\n        } catch (ComponentLookupException e) {\n            channelReceiver = this.componentManager.getInstance(JGroupsReceiver.class);\n        }\n\n        // create channel\n        JChannel channel = new JChannel(channelConf);\n\n        channel.setReceiver(channelReceiver);\n        channel.setOpt(JChannel.LOCAL, false);\n\n        return channel;\n    }","id":89585,"modified_method":"/**\n     * Create a new channel.\n     * \n     * @param channelId the identifier of the channel to create\n     * @return the new channel\n     * @throws Exception failed to create new channel\n     */\n    private JChannel createChannel(String channelId) throws Exception\n    {\n        // load configuration\n        ProtocolStackConfigurator channelConf = loadChannelConfiguration(channelId);\n\n        // get Receiver\n        JGroupsReceiver channelReceiver;\n        try {\n            channelReceiver = this.componentManager.getInstance(JGroupsReceiver.class, channelId);\n        } catch (ComponentLookupException e) {\n            channelReceiver = this.componentManager.getInstance(JGroupsReceiver.class);\n        }\n\n        // create channel\n        JChannel channel = new JChannel(channelConf);\n\n        channel.setReceiver(channelReceiver);\n        channel.setDiscardOwnMessages(true);\n\n        return channel;\n    }","commit_id":"c8aa989c146347812920a92287f8a55b2540bfa5","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#stopChannel(java.lang.String)\n     */\n    public void stopChannel(String channelId) throws RemoteEventException\n    {\n        JChannel channel = this.channels.get(channelId);\n\n        if (channel == null) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] is not started\", channelId));\n        }\n\n        channel.close();\n\n        this.channels.remove(channelId);\n\n        // Unregister the channel from the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.unregister(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to unregister channel [\" + channelId + \"] from the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] stopped\", channelId);\n    }","id":89586,"modified_method":"@Override\n    public void stopChannel(String channelId) throws RemoteEventException\n    {\n        JChannel channel = this.channels.get(channelId);\n\n        if (channel == null) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] is not started\", channelId));\n        }\n\n        channel.close();\n\n        this.channels.remove(channelId);\n\n        // Unregister the channel from the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.unregister(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to unregister channel [\" + channelId + \"] from the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] stopped\", channelId);\n    }","commit_id":"247b868ee3d2f31816bc05d7b7b455fba457b0ad","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#stopAllChannels()\n     */\n    public void stopAllChannels() throws RemoteEventException\n    {\n        for (Map.Entry<String, JChannel> channelEntry : this.channels.entrySet()) {\n            channelEntry.getValue().close();\n        }\n\n        this.channels.clear();\n\n        this.logger.info(\"All channels stopped\");\n    }","id":89587,"modified_method":"@Override\n    public void stopAllChannels() throws RemoteEventException\n    {\n        for (Map.Entry<String, JChannel> channelEntry : this.channels.entrySet()) {\n            channelEntry.getValue().close();\n        }\n\n        this.channels.clear();\n\n        this.logger.info(\"All channels stopped\");\n    }","commit_id":"247b868ee3d2f31816bc05d7b7b455fba457b0ad","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#startChannel(java.lang.String)\n     */\n    public void startChannel(String channelId) throws RemoteEventException\n    {\n        if (this.channels.containsKey(channelId)) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] already started\", channelId));\n        }\n\n        JChannel channel;\n        try {\n            channel = createChannel(channelId);\n            channel.connect(\"event\");\n\n            this.channels.put(channelId, channel);\n        } catch (Exception e) {\n            throw new RemoteEventException(\"Failed to create channel [\" + channelId + \"]\", e);\n        }\n\n        // Register the channel against the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.registerChannel(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to register channel [\" + channelId + \"] against the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] started\", channelId);\n    }","id":89588,"modified_method":"@Override\n    public void startChannel(String channelId) throws RemoteEventException\n    {\n        if (this.channels.containsKey(channelId)) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] already started\", channelId));\n        }\n\n        JChannel channel;\n        try {\n            channel = createChannel(channelId);\n            channel.connect(\"event\");\n\n            this.channels.put(channelId, channel);\n        } catch (Exception e) {\n            throw new RemoteEventException(\"Failed to create channel [\" + channelId + \"]\", e);\n        }\n\n        // Register the channel against the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.registerChannel(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to register channel [\" + channelId + \"] against the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] started\", channelId);\n    }","commit_id":"247b868ee3d2f31816bc05d7b7b455fba457b0ad","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#send(org.xwiki.observation.remote.RemoteEventData)\n     */\n    public void send(RemoteEventData remoteEvent)\n    {\n        this.logger.debug(\"Send JGroups remote event [\" + remoteEvent + \"]\");\n\n        // Send the message to the whole group\n        Message message = new Message(null, null, remoteEvent);\n\n        // Send message to jgroups channels\n        for (Map.Entry<String, JChannel> entry : this.channels.entrySet()) {\n            try {\n                entry.getValue().send(message);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to send message [\" + remoteEvent + \"] to the channel [\" + entry.getKey()\n                    + \"]\", e);\n            }\n        }\n    }","id":89589,"modified_method":"@Override\n    public void send(RemoteEventData remoteEvent)\n    {\n        this.logger.debug(\"Send JGroups remote event [\" + remoteEvent + \"]\");\n\n        // Send the message to the whole group\n        Message message = new Message(null, null, remoteEvent);\n\n        // Send message to JGroups channels\n        for (Map.Entry<String, JChannel> entry : this.channels.entrySet()) {\n            try {\n                entry.getValue().send(message);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to send message [\" + remoteEvent + \"] to the channel [\" + entry.getKey()\n                    + \"]\", e);\n            }\n        }\n    }","commit_id":"247b868ee3d2f31816bc05d7b7b455fba457b0ad","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Load channel configuration.\n     * \n     * @param channelId the identifier of the channel\n     * @return the channel configuration\n     * @throws IOException failed to load configuration file\n     * @throws ChannelException failed to creation channel configuration\n     */\n    private ProtocolStackConfigurator loadChannelConfiguration(String channelId) throws IOException, ChannelException\n    {\n        String channelFile = channelId + \".xml\";\n        String path = \"/WEB-INF/\" + CONFIGURATION_PATH + channelFile;\n\n        InputStream is = null;\n        try {\n            Container container = this.componentManager.lookup(Container.class);\n            ApplicationContext applicationContext = container.getApplicationContext();\n\n            if (applicationContext != null) {\n                is = applicationContext.getResourceAsStream(path);\n            }\n        } catch (ComponentLookupException e) {\n            this.logger.debug(\"Failed to lookup Container component.\");\n        }\n\n        if (is == null) {\n            // Fallback on JGroups standard configuraton locations\n            is = ConfiguratorFactory.getConfigStream(channelFile);\n\n            if (is == null && !JChannel.DEFAULT_PROTOCOL_STACK.equals(channelFile)) {\n                // Fallback on default JGroups configuration\n                is = ConfiguratorFactory.getConfigStream(JChannel.DEFAULT_PROTOCOL_STACK);\n            }\n        }\n\n        return XmlConfigurator.getInstance(is);\n    }","id":89590,"modified_method":"/**\n     * Load channel configuration.\n     * \n     * @param channelId the identifier of the channel\n     * @return the channel configuration\n     * @throws IOException failed to load configuration file\n     */\n    private ProtocolStackConfigurator loadChannelConfiguration(String channelId) throws IOException\n    {\n        String channelFile = channelId + \".xml\";\n        String path = \"/WEB-INF/\" + CONFIGURATION_PATH + channelFile;\n\n        InputStream is = null;\n        try {\n            Container container = this.componentManager.lookup(Container.class);\n            ApplicationContext applicationContext = container.getApplicationContext();\n\n            if (applicationContext != null) {\n                is = applicationContext.getResourceAsStream(path);\n            }\n        } catch (ComponentLookupException e) {\n            this.logger.debug(\"Failed to lookup Container component.\");\n        }\n\n        if (is == null) {\n            // Fallback on JGroups standard configuration locations\n            is = ConfiguratorFactory.getConfigStream(channelFile);\n\n            if (is == null && !JChannel.DEFAULT_PROTOCOL_STACK.equals(channelFile)) {\n                // Fallback on default JGroups configuration\n                is = ConfiguratorFactory.getConfigStream(JChannel.DEFAULT_PROTOCOL_STACK);\n            }\n        }\n\n        return XmlConfigurator.getInstance(is);\n    }","commit_id":"247b868ee3d2f31816bc05d7b7b455fba457b0ad","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create a new channel.\n     * \n     * @param channelId the identifier of the channel to create\n     * @return the new channel\n     * @throws ComponentLookupException failed to get default {@link JGroupsReceiver}\n     * @throws ChannelException failed to create channel\n     */\n    private JChannel createChannel(String channelId) throws ComponentLookupException, ChannelException\n    {\n        // load configuration\n        ProtocolStackConfigurator channelConf;\n        try {\n            channelConf = loadChannelConfiguration(channelId);\n        } catch (IOException e) {\n            throw new ChannelException(\"Failed to load configuration for the channel [\" + channelId + \"]\", e);\n        }\n\n        // get Receiver\n        JGroupsReceiver channelReceiver;\n        try {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class, channelId);\n        } catch (ComponentLookupException e) {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class);\n        }\n\n        // create channel\n        JChannel channel = new JChannel(channelConf);\n\n        channel.setReceiver(channelReceiver);\n        channel.setOpt(JChannel.LOCAL, false);\n\n        return channel;\n    }","id":89591,"modified_method":"/**\n     * Create a new channel.\n     * \n     * @param channelId the identifier of the channel to create\n     * @return the new channel\n     * @throws Exception failed to create new channel\n     */\n    private JChannel createChannel(String channelId) throws Exception\n    {\n        // load configuration\n        ProtocolStackConfigurator channelConf = loadChannelConfiguration(channelId);\n\n        // get Receiver\n        JGroupsReceiver channelReceiver;\n        try {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class, channelId);\n        } catch (ComponentLookupException e) {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class);\n        }\n\n        // create channel\n        JChannel channel = new JChannel(channelConf);\n\n        channel.setReceiver(channelReceiver);\n        channel.setDiscardOwnMessages(true);\n\n        return channel;\n    }","commit_id":"247b868ee3d2f31816bc05d7b7b455fba457b0ad","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void startChannel(String channelId) throws RemoteEventException\n    {\n        if (this.channels.containsKey(channelId)) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] already started\", channelId));\n        }\n\n        JChannel channel;\n        try {\n            channel = createChannel(channelId);\n            channel.connect(\"event\");\n\n            this.channels.put(channelId, channel);\n        } catch (Exception e) {\n            throw new RemoteEventException(\"Failed to create channel [\" + channelId + \"]\", e);\n        }\n\n        // Register the channel against the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.registerChannel(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to register channel [\" + channelId + \"] against the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] started\", channelId);\n    }","id":89592,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#startChannel(java.lang.String)\n     */\n    public void startChannel(String channelId) throws RemoteEventException\n    {\n        if (this.channels.containsKey(channelId)) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] already started\", channelId));\n        }\n\n        JChannel channel;\n        try {\n            channel = createChannel(channelId);\n            channel.connect(\"event\");\n\n            this.channels.put(channelId, channel);\n        } catch (Exception e) {\n            throw new RemoteEventException(\"Failed to create channel [\" + channelId + \"]\", e);\n        }\n\n        // Register the channel against the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.registerChannel(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to register channel [\" + channelId + \"] against the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] started\", channelId);\n    }","commit_id":"06b4a9f8715eb717112323437991eab5a7971101","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void stopChannel(String channelId) throws RemoteEventException\n    {\n        JChannel channel = this.channels.get(channelId);\n\n        if (channel == null) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] is not started\", channelId));\n        }\n\n        channel.close();\n\n        this.channels.remove(channelId);\n\n        // Unregister the channel from the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.unregister(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to unregister channel [\" + channelId + \"] from the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] stopped\", channelId);\n    }","id":89593,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#stopChannel(java.lang.String)\n     */\n    public void stopChannel(String channelId) throws RemoteEventException\n    {\n        JChannel channel = this.channels.get(channelId);\n\n        if (channel == null) {\n            throw new RemoteEventException(MessageFormat.format(\"Channel [{0}] is not started\", channelId));\n        }\n\n        channel.close();\n\n        this.channels.remove(channelId);\n\n        // Unregister the channel from the JMX Server\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            JmxConfigurator.unregister(channel, mbs, channel.getClusterName());\n        } catch (Exception e) {\n            this.logger.warn(\"Failed to unregister channel [\" + channelId + \"] from the JMX Server\", e);\n        }\n\n        this.logger.info(\"Channel [{}] stopped\", channelId);\n    }","commit_id":"06b4a9f8715eb717112323437991eab5a7971101","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Load channel configuration.\n     * \n     * @param channelId the identifier of the channel\n     * @return the channel configuration\n     * @throws IOException failed to load configuration file\n     */\n    private ProtocolStackConfigurator loadChannelConfiguration(String channelId) throws IOException\n    {\n        String channelFile = channelId + \".xml\";\n        String path = \"/WEB-INF/\" + CONFIGURATION_PATH + channelFile;\n\n        InputStream is = null;\n        try {\n            Container container = this.componentManager.lookup(Container.class);\n            ApplicationContext applicationContext = container.getApplicationContext();\n\n            if (applicationContext != null) {\n                is = applicationContext.getResourceAsStream(path);\n            }\n        } catch (ComponentLookupException e) {\n            this.logger.debug(\"Failed to lookup Container component.\");\n        }\n\n        if (is == null) {\n            // Fallback on JGroups standard configuration locations\n            is = ConfiguratorFactory.getConfigStream(channelFile);\n\n            if (is == null && !JChannel.DEFAULT_PROTOCOL_STACK.equals(channelFile)) {\n                // Fallback on default JGroups configuration\n                is = ConfiguratorFactory.getConfigStream(JChannel.DEFAULT_PROTOCOL_STACK);\n            }\n        }\n\n        return XmlConfigurator.getInstance(is);\n    }","id":89594,"modified_method":"/**\n     * Load channel configuration.\n     * \n     * @param channelId the identifier of the channel\n     * @return the channel configuration\n     * @throws IOException failed to load configuration file\n     * @throws ChannelException failed to creation channel configuration\n     */\n    private ProtocolStackConfigurator loadChannelConfiguration(String channelId) throws IOException, ChannelException\n    {\n        String channelFile = channelId + \".xml\";\n        String path = \"/WEB-INF/\" + CONFIGURATION_PATH + channelFile;\n\n        InputStream is = null;\n        try {\n            Container container = this.componentManager.lookup(Container.class);\n            ApplicationContext applicationContext = container.getApplicationContext();\n\n            if (applicationContext != null) {\n                is = applicationContext.getResourceAsStream(path);\n            }\n        } catch (ComponentLookupException e) {\n            this.logger.debug(\"Failed to lookup Container component.\");\n        }\n\n        if (is == null) {\n            // Fallback on JGroups standard configuraton locations\n            is = ConfiguratorFactory.getConfigStream(channelFile);\n\n            if (is == null && !JChannel.DEFAULT_PROTOCOL_STACK.equals(channelFile)) {\n                // Fallback on default JGroups configuration\n                is = ConfiguratorFactory.getConfigStream(JChannel.DEFAULT_PROTOCOL_STACK);\n            }\n        }\n\n        return XmlConfigurator.getInstance(is);\n    }","commit_id":"06b4a9f8715eb717112323437991eab5a7971101","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void stopAllChannels() throws RemoteEventException\n    {\n        for (Map.Entry<String, JChannel> channelEntry : this.channels.entrySet()) {\n            channelEntry.getValue().close();\n        }\n\n        this.channels.clear();\n\n        this.logger.info(\"All channels stopped\");\n    }","id":89595,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#stopAllChannels()\n     */\n    public void stopAllChannels() throws RemoteEventException\n    {\n        for (Map.Entry<String, JChannel> channelEntry : this.channels.entrySet()) {\n            channelEntry.getValue().close();\n        }\n\n        this.channels.clear();\n\n        this.logger.info(\"All channels stopped\");\n    }","commit_id":"06b4a9f8715eb717112323437991eab5a7971101","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void send(RemoteEventData remoteEvent)\n    {\n        this.logger.debug(\"Send JGroups remote event [\" + remoteEvent + \"]\");\n\n        // Send the message to the whole group\n        Message message = new Message(null, null, remoteEvent);\n\n        // Send message to JGroups channels\n        for (Map.Entry<String, JChannel> entry : this.channels.entrySet()) {\n            try {\n                entry.getValue().send(message);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to send message [\" + remoteEvent + \"] to the channel [\" + entry.getKey()\n                    + \"]\", e);\n            }\n        }\n    }","id":89596,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.NetworkAdapter#send(org.xwiki.observation.remote.RemoteEventData)\n     */\n    public void send(RemoteEventData remoteEvent)\n    {\n        this.logger.debug(\"Send JGroups remote event [\" + remoteEvent + \"]\");\n\n        // Send the message to the whole group\n        Message message = new Message(null, null, remoteEvent);\n\n        // Send message to jgroups channels\n        for (Map.Entry<String, JChannel> entry : this.channels.entrySet()) {\n            try {\n                entry.getValue().send(message);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to send message [\" + remoteEvent + \"] to the channel [\" + entry.getKey()\n                    + \"]\", e);\n            }\n        }\n    }","commit_id":"06b4a9f8715eb717112323437991eab5a7971101","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create a new channel.\n     * \n     * @param channelId the identifier of the channel to create\n     * @return the new channel\n     * @throws Exception failed to create new channel\n     */\n    private JChannel createChannel(String channelId) throws Exception\n    {\n        // load configuration\n        ProtocolStackConfigurator channelConf = loadChannelConfiguration(channelId);\n\n        // get Receiver\n        JGroupsReceiver channelReceiver;\n        try {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class, channelId);\n        } catch (ComponentLookupException e) {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class);\n        }\n\n        // create channel\n        JChannel channel = new JChannel(channelConf);\n\n        channel.setReceiver(channelReceiver);\n        channel.setDiscardOwnMessages(true);\n\n        return channel;\n    }","id":89597,"modified_method":"/**\n     * Create a new channel.\n     * \n     * @param channelId the identifier of the channel to create\n     * @return the new channel\n     * @throws ComponentLookupException failed to get default {@link JGroupsReceiver}\n     * @throws ChannelException failed to create channel\n     */\n    private JChannel createChannel(String channelId) throws ComponentLookupException, ChannelException\n    {\n        // load configuration\n        ProtocolStackConfigurator channelConf;\n        try {\n            channelConf = loadChannelConfiguration(channelId);\n        } catch (IOException e) {\n            throw new ChannelException(\"Failed to load configuration for the channel [\" + channelId + \"]\", e);\n        }\n\n        // get Receiver\n        JGroupsReceiver channelReceiver;\n        try {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class, channelId);\n        } catch (ComponentLookupException e) {\n            channelReceiver = this.componentManager.lookup(JGroupsReceiver.class);\n        }\n\n        // create channel\n        JChannel channel = new JChannel(channelConf);\n\n        channel.setReceiver(channelReceiver);\n        channel.setOpt(JChannel.LOCAL, false);\n\n        return channel;\n    }","commit_id":"06b4a9f8715eb717112323437991eab5a7971101","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob) throws KettleException \n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tResult result = previousResult;\n\n\t    List<RowMetaAndData> rows = result.getRows();\n\t    RowMetaAndData resultRow = null;\n\t\t\n\t    NrErrors=0;\r\n\t    NrSuccess=0;\r\n\t\tDoNotProcessRest=false;\r\n\t\t\r\n\t\tif(log.isDetailed())\r\n\t\t{\r\n\t\t\tif(simulate) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.SimulationOn\"));\r\n\t\t}\r\n\t\t\r\n\t\tString MoveToFolder=environmentSubstitute(destinationFolder);\n\t\t// Get source and destination files, also wildcard\n\t\tString vsourcefilefolder[] = source_filefolder;\n\t\tString vdestinationfilefolder[] = destination_filefolder;\n\t\tString vwildcard[] = wildcard;\n\t\t\n\t\tresult.setResult( true );\n\t\t\r\n\t\tif(iffileexists.equals(\"move_file\"))\r\n\t\t{\r\n\t\t\tif(Const.isEmpty(MoveToFolder))\r\n\t\t\t{\r\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.MoveToFolderMissing\"));\r\n\t\t\t\tresult.setResult( false );\r\n\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\treturn result;\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\t FileObject folder = null;\r\n\t\t\t try{\r\n\t\t\t\t folder = KettleVFS.getFileObject(MoveToFolder);\r\n\t\t\t\t if(!folder.exists())\r\n\t\t\t\t {\r\n\t\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.Error.FolderMissing\",MoveToFolder));\r\n\t\t\t\t\t if(create_move_to_folder)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t folder.createFolder();\r\n\t\t\t\t\t }else\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t log.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.FolderMissing\",MoveToFolder));\r\n\t\t\t\t\t\t result.setResult( false );\r\n\t\t\t\t\t\t result.setNrErrors(1);\r\n\t\t\t\t\t\t return result; \r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t\t if(!folder.getType().equals(FileType.FOLDER))\r\n\t\t\t\t {\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.NotFolder\",MoveToFolder));\r\n\t\t\t\t\tresult.setResult( false );\r\n\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\treturn result; \r\n\t\t\t\t }\r\n\t\t\t }catch (Exception e)\r\n\t\t\t {\r\n\t\t\t\t log.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.GettingMoveToFolder\",MoveToFolder,e.getMessage()));\r\n\t\t\t\t result.setResult( false );\r\n\t\t\t\t result.setNrErrors(1);\r\n\t\t\t\t return result; \r\n\t\t\t }finally{\r\n\t\t\t\t if ( folder != null )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry  \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfolder.close();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t\t\t} \r\n\t\t\t }\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\n\t\t\t\n\t\tif (arg_from_previous)\n\t\t{\n\t\t\tif (log.isDetailed())\r\n\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.ArgFromPrevious.Found\",(rows!=null?rows.size():0)+ \"\"));\n\t\t\t\n\t\t}\n\t\tif (arg_from_previous && rows!=null) // Copy the input row to the (command line) arguments\n\t\t{\n\t\t\tfor (int iteration=0;iteration<rows.size();iteration++) \n\t\t\t{\n\t\t\t\n\t\t\t\tresultRow = rows.get(iteration);\n\t\t\t\n\t\t\t\t// Get source and destination file names, also wildcard\n\t\t\t\tString vsourcefilefolder_previous = resultRow.getString(0,null);\n\t\t\t\tString vdestinationfilefolder_previous = resultRow.getString(1,null);\n\t\t\t\tString vwildcard_previous = resultRow.getString(2,null);\n\n\t\t\t\tif(!Const.isEmpty(vsourcefilefolder_previous) &&  !Const.isEmpty(vdestinationfilefolder_previous))\n\t\t\t\t{\n\t\t\t\t\tif(!DoNotProcessRest)\r\n\t           \t\t{\n\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.ProcessingRow\",vsourcefilefolder_previous, vdestinationfilefolder_previous, vwildcard_previous));\n\n\t\t\t\t\t\tif(! ProcessFileFolder(vsourcefilefolder_previous,vdestinationfilefolder_previous,vwildcard_previous,parentJob,result,MoveToFolder))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The move process fail\n\t\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\t\tupdateErrors();\n\t\t\t\t\t\t}\r\n\t           \t\t}else\r\n\t           \t\t{\r\n\t           \t\t\tif(log.isDetailed()) \r\n\t           \t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobEntryMoveFiles.log.IgnoringFile\",vsourcefilefolder_previous));\r\n\t           \t\r\n\t           \t\t}\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t \n\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.IgnoringRow\",vsourcefilefolder[iteration],vdestinationfilefolder[iteration],vwildcard[iteration]));\n\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (vsourcefilefolder!=null && vdestinationfilefolder!=null)\n\t\t{\n\t\t\tfor (int i=0;i<vsourcefilefolder.length;i++)\n\t\t\t{\n\t\t\t\tif(!Const.isEmpty(vsourcefilefolder[i]) && !Const.isEmpty(vdestinationfilefolder[i]))\n\t\t\t\t{\n\n\t\t\t\t\t// ok we can process this file/folder\n\t\t\t\t\tif(!DoNotProcessRest)\r\n\t           \t\t{\n\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.ProcessingRow\",vsourcefilefolder[i],vdestinationfilefolder[i],vwildcard[i]));\n\t\t\t\t\t\n\t\t\t\t\t\tif(!ProcessFileFolder(vsourcefilefolder[i],vdestinationfilefolder[i],vwildcard[i],parentJob,result,MoveToFolder))\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\t\tupdateErrors();\n\t\t\t\t\t\t}\r\n\t           \t\t}else\r\n\t           \t\t{\r\n\t           \t\t\tif(log.isDetailed()) log.logDetailed(toString(),Messages.getString(\"JobEntryMoveFiles.log.IgnoringFile\",vsourcefilefolder[i]));\r\n\t           \t\r\n\t           \t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.IgnoringRow\",vsourcefilefolder[i],vdestinationfilefolder[i],vwildcard[i]));\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\r\n\t\t\n\t\t// Success Condition\r\n\t\tif (getStatus())\r\n\t\t{\r\n\t\t\tresult.setResult( false );\r\n\t\t\tresult.setNrErrors(NrErrors);\t\r\n\t\t}else\r\n\t\t\tresult.setResult(true);\r\n\t\t\n\t\tresult.setNrLinesWritten(NrSuccess);\r\n\t\t\r\n\t\tif(log.isDetailed())\r\n\t\t{\r\n\t\t\tlog.logDetailed(toString(), \"=======================================\");\r\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.Info.FilesInError\",\"\" + NrErrors));\r\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.Info.FilesInSuccess\",\"\" + NrSuccess));\r\n\t\t\tlog.logDetailed(toString(), \"=======================================\");\r\n\t\t}\n\t\t\n\t\treturn result;\n\t}","id":89598,"modified_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob) throws KettleException \r\n\t{\r\n\t\tLogWriter log = LogWriter.getInstance();\r\n\t\tResult result = previousResult;\r\n\t    List<RowMetaAndData> rows = result.getRows();\r\n\t    RowMetaAndData resultRow = null; \r\n\t\t\r\n\t    NrErrors=0;\r\n\t    NrSuccess=0;\r\n\t\tDoNotProcessRest=false;\r\n\t\t\r\n\t\tif(simulate)\r\n\t\t{\r\n\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.SimulationOn\"));\r\n\t\t}\r\n\t\tif(include_subfolders)\r\n\t\t{\r\n\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.IncludeSubFoldersOn\"));\r\n\t\t}\t\r\n\t\t\r\n\t\tString MoveToFolder=environmentSubstitute(destinationFolder);\r\n\t\t// Get source and destination files, also wildcard\r\n\t\tString vsourcefilefolder[] = source_filefolder;\r\n\t\tString vdestinationfilefolder[] = destination_filefolder;\r\n\t\tString vwildcard[] = wildcard;\r\n\t\t\r\n\t\tresult.setResult( true );\r\n\t\t\r\n\t\tif(iffileexists.equals(\"move_file\"))\r\n\t\t{\r\n\t\t\tif(Const.isEmpty(MoveToFolder))\r\n\t\t\t{\r\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.MoveToFolderMissing\"));\r\n\t\t\t\tresult.setResult( false );\r\n\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\treturn result;\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\t FileObject folder = null;\r\n\t\t\t try{\r\n\t\t\t\t folder = KettleVFS.getFileObject(MoveToFolder);\r\n\t\t\t\t if(!folder.exists())\r\n\t\t\t\t {\r\n\t\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.Error.FolderMissing\",MoveToFolder));\r\n\t\t\t\t\t if(create_move_to_folder)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t folder.createFolder();\r\n\t\t\t\t\t }else\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t log.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.FolderMissing\",MoveToFolder));\r\n\t\t\t\t\t\t result.setResult( false );\r\n\t\t\t\t\t\t result.setNrErrors(1);\r\n\t\t\t\t\t\t return result; \r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t\t if(!folder.getType().equals(FileType.FOLDER))\r\n\t\t\t\t {\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.NotFolder\",MoveToFolder));\r\n\t\t\t\t\tresult.setResult( false );\r\n\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\treturn result; \r\n\t\t\t\t }\r\n\t\t\t }catch (Exception e)\r\n\t\t\t {\r\n\t\t\t\t log.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error.GettingMoveToFolder\",MoveToFolder,e.getMessage()));\r\n\t\t\t\t result.setResult( false );\r\n\t\t\t\t result.setNrErrors(1);\r\n\t\t\t\t return result; \r\n\t\t\t }finally{\r\n\t\t\t\t if ( folder != null )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry  \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfolder.close();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t\t\t} \r\n\t\t\t }\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\t\r\n\t\tif (arg_from_previous)\r\n\t\t{\r\n\t\t\tif (log.isDetailed())\r\n\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.ArgFromPrevious.Found\",(rows!=null?rows.size():0)+ \"\"));\r\n\t\t\t\r\n\t\t}\r\n\t\tif (arg_from_previous && rows!=null) // Copy the input row to the (command line) arguments\r\n\t\t{\r\n\t\t\tfor (int iteration=0;iteration<rows.size();iteration++) \r\n\t\t\t{\t\t\t\r\n\t\t\t\tresultRow = rows.get(iteration);\r\n\t\t\t\r\n\t\t\t\t// Get source and destination file names, also wildcard\r\n\t\t\t\tString vsourcefilefolder_previous = resultRow.getString(0,null);\r\n\t\t\t\tString vdestinationfilefolder_previous = resultRow.getString(1,null);\r\n\t\t\t\tString vwildcard_previous = resultRow.getString(2,null);\r\n\r\n\t\t\t\tif(!Const.isEmpty(vsourcefilefolder_previous) &&  !Const.isEmpty(vdestinationfilefolder_previous))\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!DoNotProcessRest)\r\n\t           \t\t{\r\n\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.ProcessingRow\",vsourcefilefolder_previous, vdestinationfilefolder_previous, vwildcard_previous));\r\n\r\n\t\t\t\t\t\tif(! ProcessFileFolder(vsourcefilefolder_previous,vdestinationfilefolder_previous,vwildcard_previous,parentJob,result,MoveToFolder))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// The move process fail\r\n\t\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\t\tupdateErrors();\r\n\t\t\t\t\t\t}\r\n\t           \t\t}else\r\n\t           \t\t{\r\n\t           \t\t\tif(log.isDetailed()) \r\n\t           \t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobEntryMoveFiles.log.IgnoringFile\",vsourcefilefolder_previous));\r\n\t           \t\r\n\t           \t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t \r\n\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.IgnoringRow\",vsourcefilefolder[iteration],vdestinationfilefolder[iteration],vwildcard[iteration]));\r\n\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (vsourcefilefolder!=null && vdestinationfilefolder!=null)\r\n\t\t{\r\n\t\t\tfor (int i=0;i<vsourcefilefolder.length;i++)\r\n\t\t\t{\r\n\t\t\t\tif(!Const.isEmpty(vsourcefilefolder[i]) && !Const.isEmpty(vdestinationfilefolder[i]))\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\t// ok we can process this file/folder\r\n\t\t\t\t\tif(!DoNotProcessRest)\r\n\t           \t\t{\r\n\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.ProcessingRow\",vsourcefilefolder[i],vdestinationfilefolder[i],vwildcard[i]));\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif(!ProcessFileFolder(vsourcefilefolder[i],vdestinationfilefolder[i],vwildcard[i],parentJob,result,MoveToFolder))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\t\tupdateErrors();\r\n\t\t\t\t\t\t}\r\n\t           \t\t}else\r\n\t           \t\t{\r\n\t           \t\t\tif(log.isDetailed()) log.logDetailed(toString(),Messages.getString(\"JobEntryMoveFiles.log.IgnoringFile\",vsourcefilefolder[i]));\r\n\t           \t\r\n\t           \t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.IgnoringRow\",vsourcefilefolder[i],vdestinationfilefolder[i],vwildcard[i]));\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\r\n\t\t\r\n\t\t// Success Condition\r\n\t\tif (getStatus())\r\n\t\t{\r\n\t\t\tresult.setResult( false );\r\n\t\t\tresult.setNrErrors(NrErrors);\t\r\n\t\t}else\r\n\t\t\tresult.setResult(true);\r\n\t\t\r\n\t\tresult.setNrLinesWritten(NrSuccess);\r\n\t\t\r\n\t\tif(log.isDetailed())\r\n\t\t{\r\n\t\t\tlog.logDetailed(toString(), \"=======================================\");\r\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.Info.FilesInError\",\"\" + NrErrors));\r\n\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.Info.FilesInSuccess\",\"\" + NrSuccess));\r\n\t\t\tlog.logDetailed(toString(), \"=======================================\");\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn result;\r\n\t}","commit_id":"a05cabac45d5da5426c3ba7ace0ac834289d362d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean MoveFile(String shortfilename,FileObject sourcefilename,\r\n\t\t\tFileObject destinationfilename,FileObject movetofolderfolder,\r\n\t\t\tLogWriter log,Job parentJob,Result result)\r\n\t{\r\n\t\tFileObject destinationfile=null;\r\n\t\tboolean retval =false;\r\n\t\ttry{\r\n\t\tif(!destinationfilename.exists())\r\n\t\t{\r\n\t\t\tsourcefilename.moveTo(destinationfilename);\r\n\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",sourcefilename.getName().toString(),destinationfilename.getName().toString()));\r\n\t\t\r\n\t\t\t// add filename to result filename\r\n\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\taddFileToResultFilenames(destinationfilename.toString(),log,result,parentJob);\r\n\t\t\t\r\n\t\t\tupdateSuccess();\r\n\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileExists\",destinationfilename.toString()));\r\n\t\t\tif(iffileexists.equals(\"overwrite_file\"))\r\n\t\t\t{\r\n\t\t\t\tsourcefilename.moveTo(destinationfilename);\r\n\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",destinationfilename.getName().toString()));\r\n\t\t\t\r\n\t\t\t\t// add filename to result filename\r\n\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\taddFileToResultFilenames(destinationfilename.toString(),log,result,parentJob);\r\n\t\t\t\t\r\n\t\t\t\tupdateSuccess();\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"unique_name\"))\r\n\t\t\t{\r\n\t\t\t\tString short_filename=shortfilename;\r\n\t\t\t\t\r\n\t\t\t\t// return destination short filename\r\n\t\t\t\ttry{\r\n\t\t\t\t\tshort_filename=getMoveDestinationFilename(short_filename,\"ddMMyyyy_HHmmssSSS\");\r\n\t\t\t\t}catch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",short_filename)));\r\n\t\t\t\t\treturn retval;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\r\n\t\t\t\tString movetofilenamefull=destinationfilename.getParent().toString()+Const.FILE_SEPARATOR+short_filename;\r\n\t\t\t\tdestinationfile = KettleVFS.getFileObject(movetofilenamefull);\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tsourcefilename.moveTo(destinationfile);\r\n\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",sourcefilename.getName().toString(),destinationfile.getName().toString()));\r\n\t\t\t\t\r\n\t\t\t\t// add filename to result filename\r\n\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\r\n\t\t\t\t\r\n\t\t\t\tupdateSuccess();\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"delete_file\"))\r\n\t\t\t{\r\n\t\t\t\tdestinationfilename.delete();\r\n\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileDeleted\",destinationfilename.getName().toString()));\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"move_file\"))\r\n\t\t\t{\r\n\t\t\t\tString short_filename=shortfilename;\t\r\n\t\t\t\t// return destination short filename\r\n\t\t\t\ttry{\r\n\t\t\t\t\tshort_filename=getMoveDestinationFilename(short_filename,null);\r\n\t\t\t\t}catch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",short_filename)));\r\n\t\t\t\t\treturn retval;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tString movetofilenamefull=movetofolderfolder.toString()+Const.FILE_SEPARATOR+short_filename;\r\n\t\t\t\tdestinationfile = KettleVFS.getFileObject(movetofilenamefull);\r\n\t\t\t\t\r\n\t\t\t\tif(!destinationfile.exists())\r\n\t\t\t\t{\r\n\t\t\t\t\t//sourcefilename.moveTo(destinationfile);\r\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",sourcefilename.getName().toString(),destinationfile.getName().toString()));\r\n\t\t\t\t\r\n\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tupdateSuccess();\r\n\t\t\t\t\t\r\n\t\t\t\t}else\r\n\t\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t\tif(ifmovedfileexists.equals(\"overwrite_file\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsourcefilename.moveTo(destinationfile);\r\n\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",destinationfile.getName().toString()));\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tupdateSuccess();\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(ifmovedfileexists.equals(\"unique_name\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSimpleDateFormat daf  = new SimpleDateFormat();\r\n\t\t\t\t\t\tDate now = new Date();\r\n\t\t\t\t\t\tdaf.applyPattern(\"ddMMyyyy_HHmmssSSS\");\r\n\t\t\t\t\t\tString dt = daf.format(now);\r\n\t\t\t\t\t\tshort_filename+=\"_\"+dt;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tString destinationfilenamefull=movetofolderfolder.toString()+Const.FILE_SEPARATOR+short_filename;\r\n\t\t\t\t\t\tdestinationfile= KettleVFS.getFileObject(destinationfilenamefull);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tsourcefilename.moveTo(destinationfile);\r\n\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",destinationfile.getName().toString()));\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tupdateSuccess();\r\n\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(ifmovedfileexists.equals(\"fail\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\tupdateErrors();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"fail\"))\r\n\t\t\t{\r\n            \t// Update Errors\r\n\t\t\t\tupdateErrors();\t\r\n\t\t\t}\r\n\t\t\t\r\n\r\n\t\t}\r\n\t\t}catch (Exception e)\r\n\t\t{\r\n\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.Exception.MoveProcessError\",sourcefilename.toString(),destinationfilename.toString(),e.getMessage()));\r\n\t\t}\r\n\t\tfinally \r\n\t\t{\r\n\t\t\tif ( destinationfile != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tdestinationfile.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\r\n\t\t}\r\n\t\treturn retval;\r\n\t}","id":89599,"modified_method":"private boolean MoveFile(String shortfilename,FileObject sourcefilename,\r\n\t\t\tFileObject destinationfilename,FileObject movetofolderfolder,\r\n\t\t\tLogWriter log,Job parentJob,Result result)\r\n\t{\r\n\t\t\r\n\t\tFileObject destinationfile=null;\r\n\t\tboolean retval =false;\r\n\t\ttry{\r\n\t\tif(!destinationfilename.exists())\r\n\t\t{\r\n\t\t\tif(!simulate) sourcefilename.moveTo(destinationfilename);\r\n\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",sourcefilename.getName().toString(),destinationfilename.getName().toString()));\r\n\t\t\r\n\t\t\t// add filename to result filename\r\n\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\taddFileToResultFilenames(destinationfilename.toString(),log,result,parentJob);\r\n\t\t\t\r\n\t\t\tupdateSuccess();\r\n\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileExists\",destinationfilename.toString()));\r\n\t\t\tif(iffileexists.equals(\"overwrite_file\"))\r\n\t\t\t{\r\n\t\t\t\tif(!simulate) sourcefilename.moveTo(destinationfilename);\r\n\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",destinationfilename.getName().toString()));\r\n\t\t\t\r\n\t\t\t\t// add filename to result filename\r\n\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\taddFileToResultFilenames(destinationfilename.toString(),log,result,parentJob);\r\n\t\t\t\t\r\n\t\t\t\tupdateSuccess();\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"unique_name\"))\r\n\t\t\t{\r\n\t\t\t\tString short_filename=shortfilename;\r\n\t\t\t\t\r\n\t\t\t\t// return destination short filename\r\n\t\t\t\ttry{\r\n\t\t\t\t\tshort_filename=getMoveDestinationFilename(short_filename,\"ddMMyyyy_HHmmssSSS\");\r\n\t\t\t\t}catch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",short_filename)));\r\n\t\t\t\t\treturn retval;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\r\n\t\t\t\tString movetofilenamefull=destinationfilename.getParent().toString()+Const.FILE_SEPARATOR+short_filename;\r\n\t\t\t\tdestinationfile = KettleVFS.getFileObject(movetofilenamefull);\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif(!simulate) sourcefilename.moveTo(destinationfile);\r\n\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",sourcefilename.getName().toString(),destinationfile.getName().toString()));\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// add filename to result filename\r\n\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tupdateSuccess();\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"delete_file\"))\r\n\t\t\t{\r\n\t\t\t\tif(!simulate) destinationfilename.delete();\r\n\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileDeleted\",destinationfilename.getName().toString()));\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"move_file\"))\r\n\t\t\t{\r\n\t\t\t\tString short_filename=shortfilename;\t\r\n\t\t\t\t// return destination short filename\r\n\t\t\t\ttry{\r\n\t\t\t\t\tshort_filename=getMoveDestinationFilename(short_filename,null);\r\n\t\t\t\t}catch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",short_filename)));\r\n\t\t\t\t\treturn retval;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tString movetofilenamefull=movetofolderfolder.toString()+Const.FILE_SEPARATOR+short_filename;\r\n\t\t\t\tdestinationfile = KettleVFS.getFileObject(movetofilenamefull);\r\n\t\t\t\tif(!destinationfile.exists())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!simulate) sourcefilename.moveTo(destinationfile);\r\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",sourcefilename.getName().toString(),destinationfile.getName().toString()));\r\n\t\t\t\t\r\n\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\t\r\n\t\t\t\t\t\r\n\t\t\t\t}else\r\n\t\t\t\t{\r\n\t\t\t\t\tif(ifmovedfileexists.equals(\"overwrite_file\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(!simulate) sourcefilename.moveTo(destinationfile);\r\n\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",destinationfile.getName().toString()));\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tupdateSuccess();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(ifmovedfileexists.equals(\"unique_name\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSimpleDateFormat daf  = new SimpleDateFormat();\r\n\t\t\t\t\t\tDate now = new Date();\r\n\t\t\t\t\t\tdaf.applyPattern(\"ddMMyyyy_HHmmssSSS\");\r\n\t\t\t\t\t\tString dt = daf.format(now);\r\n\t\t\t\t\t\tshort_filename+=\"_\"+dt;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tString destinationfilenamefull=movetofolderfolder.toString()+Const.FILE_SEPARATOR+short_filename;\r\n\t\t\t\t\t\tdestinationfile= KettleVFS.getFileObject(destinationfilenamefull);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!simulate) sourcefilename.moveTo(destinationfile);\r\n\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",destinationfile.getName().toString()));\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\taddFileToResultFilenames(destinationfile.toString(),log,result,parentJob);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tupdateSuccess();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(ifmovedfileexists.equals(\"fail\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\tupdateErrors();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(iffileexists.equals(\"fail\"))\r\n\t\t\t{\r\n            \t// Update Errors\r\n\t\t\t\tupdateErrors();\t\r\n\t\t\t}\r\n\t\t\t\r\n\r\n\t\t}\r\n\t\t}catch (Exception e)\r\n\t\t{\r\n\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.Exception.MoveProcessError\",sourcefilename.toString(),destinationfilename.toString(),e.getMessage()));\r\n\t\t}\r\n\t\tfinally \r\n\t\t{\r\n\t\t\tif ( destinationfile != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tdestinationfile.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\r\n\t\t}\r\n\t\treturn retval;\r\n\t}","commit_id":"a05cabac45d5da5426c3ba7ace0ac834289d362d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addFileToResultFilenames(String fileaddentry,LogWriter log,Result result,Job parentJob)\r\n\t{\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(fileaddentry), parentJob.getName(), toString());\r\n\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n\t    \r\n\t\t\tif(log.isDetailed())\r\n\t\t\t{\r\n\t\t\t\tlog.logDetailed(toString(),\" ------ \");\r\n\t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobMoveFiles.Log.FileAddedToResultFilesName\",fileaddentry));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}catch (Exception e)\r\n\t\t{\r\n\t\t\tlog.logError(toString(),Messages.getString(\"JobMoveFiles.Error.AddingToFilenameResult\"),fileaddentry,e.getMessage());\r\n\t\t}\r\n\r\n}","id":89600,"modified_method":"private void addFileToResultFilenames(String fileaddentry,LogWriter log,Result result,Job parentJob)\r\n\t{\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(fileaddentry), parentJob.getName(), toString());\r\n\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n\t    \r\n\t\t\tif(log.isDetailed())\r\n\t\t\t{\r\n\t\t\t\tlog.logDetailed(toString(),\" ------ \");\r\n\t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobMoveFiles.Log.FileAddedToResultFilesName\",fileaddentry));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}catch (Exception e)\r\n\t\t{\r\n\t\t\tlog.logError(Messages.getString(\"JobMoveFiles.Error.AddingToFilenameResult\"),fileaddentry + \"\"+e.getMessage());\r\n\t\t}\r\n\r\n}","commit_id":"a05cabac45d5da5426c3ba7ace0ac834289d362d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean MoveOneFile(FileObject Currentfile, FileObject sourcefilefolder,String realDestinationFilefoldername, \r\n\t\t\t\t\t\tString realWildcard,LogWriter log,Job parentJob,Result result, FileObject movetofolderfolder)\r\n\t{\r\n\t\tboolean entrystatus=false;\r\n\t\tFileObject file_name=null;\r\n\ttry {\r\n     \tif (!Currentfile.toString().equals(sourcefilefolder.toString()))\r\n\t\t{\r\n\t\t\t// Pass over the Base folder itself\r\n\t\t\t\r\n    \t\t// return destination short filename\r\n    \t\tString shortfilename=Currentfile.getName().getBaseName();\r\n\t\t\ttry{\r\n\t\t\t  shortfilename=getDestinationFilename(Currentfile.getName().getBaseName());\r\n\t\t\t}catch (Exception e)\r\n\t\t\t{\r\n\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",Currentfile.getName().getBaseName(),e.toString())));\r\n\t\t\t\treturn entrystatus;\r\n\t\t\t}\r\n\t\t\t//log.logBasic(\"-----Current-------\", Currentfile.getName().getBaseName());\r\n\t\t\tint lenCurrent=Currentfile.getName().getBaseName().length();\r\n\t\t\t//log.logBasic(\"-----short_filename-------\", shortfilename);\r\n\t\t\tString short_filename_from_basefolder=shortfilename;\r\n\t\t\tif(!isDoNotKeepFolderStructure())\t\r\n\t\t\t\tshort_filename_from_basefolder=Currentfile.toString().substring(sourcefilefolder.toString().length(),Currentfile.toString().length());        \t\t\t\t\t\r\n\t\t\t//log.logBasic(\"-----short_filename_from_basefolder-------\", short_filename_from_basefolder);\r\n\t\t\tshort_filename_from_basefolder=short_filename_from_basefolder.substring(0,short_filename_from_basefolder.length()-lenCurrent)+shortfilename;\r\n\t\t\t//log.logBasic(\"-----short_filename_from_basefolder-------\", short_filename_from_basefolder);\r\n\t\t\t// Built destination filename\r\n\t\t\tfile_name=KettleVFS.getFileObject(realDestinationFilefoldername + Const.FILE_SEPARATOR + short_filename_from_basefolder); \r\n\t\t\t\r\n\t\t\tif (!Currentfile.getParent().toString().equals(sourcefilefolder.toString()))\r\n\t\t\t {\r\n\t\t\t\t// Not in the Base Folder..Only if include sub folders  \r\n\t\t\t\t if (include_subfolders)\r\n\t\t\t\t {\r\n\t\t\t\t\t// Folders..only if include subfolders\r\n\t\t\t\t\t if (Currentfile.getType() == FileType.FOLDER)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t if (include_subfolders && move_empty_folders && Const.isEmpty(wildcard))\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t\t/* if (!file_name.exists())\r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t// Move Folder\r\n\t\t\t\t\t\t\t\tCurrentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t {\t                \t\t\t\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FolderMoved\",Currentfile.getName().toString(),file_name.getName().toString()));\r\n\r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && !iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t else\r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t if(log.isDetailed()) \r\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FolderExists\", file_name.toString()));\r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t\t\tif (overwrite_files)\r\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",file_name.getName().toString()));\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t } */\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t }\r\n\t\t\t\t\t else\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\tif (GetFileWildcard(shortfilename,realWildcard))\r\n\t\t\t\t\t\t{\t\r\n\t\t\t\t\t\t\tentrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t\t// Check if the file exists\r\n\t\t\t\t\t\t\t /*if (!file_name.exists())\r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\tif(log.isDetailed()) \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tlog.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",Currentfile.toString(),file_name.toString()));\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// add filename to result filename\r\n\t\t\t\t\t\t\t\tif(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t\taddFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t else\r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t if(log.isDetailed()) \r\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileExists\",file_name.getName().toString()));\r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t if (overwrite_files)\r\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",file_name.toString()));\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\t\t \r\n\r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t }*/\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t\t// In the Base Folder...\r\n\t\t\t\t// Folders..only if include subfolders\r\n\t\t\t\t if (Currentfile.getType() == FileType.FOLDER)\r\n\t\t\t\t {\r\n\t\t\t\t\t if (include_subfolders && move_empty_folders  && Const.isEmpty(wildcard))\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t /*if (!file_name.exists())\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t if(log.isDetailed())  \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",Currentfile.toString(),file_name.toString()));\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t else\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t if(log.isDetailed())  \r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileExists\",file_name.getName().toString()));\r\n\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t if (overwrite_files)\r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t if(log.isDetailed())  log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",file_name.toString()));\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\t  \r\n\r\n\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t }*/\r\n\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t\t else\r\n\t\t\t\t {\r\n\t\t\t\t\t // file...Check if exists\r\n\t\t\t\t\t if (GetFileWildcard(shortfilename,realWildcard))\r\n\t\t\t\t\t {\t\r\n\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t /*if (!file_name.exists())\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t if(log.isDetailed())  \r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileMoved\",Currentfile.toString(),file_name.toString()));\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t }\t\r\n\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t else\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t if(log.isDetailed())  \r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(),\" ------ \");\r\n\t\t\t\t\t\t\t\t log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileExists\",file_name.getName().toString()));\r\n\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t \r\n\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t if (overwrite_files)\r\n\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t // Move File\r\n\t\t\t\t\t\t\t\t Currentfile.moveTo(file_name);\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(), Messages.getString(\"JobMoveFiles.Log.FileOverwrite\",file_name.toString()));\r\n\t\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t // add filename to result filename\r\n\t\t\t\t\t\t\t\t if(add_result_filesname && !iffileexists.equals(\"fail\") && iffileexists.equals(\"do_nothing\")) \r\n\t\t\t\t\t\t\t\t\t addFileToResultFilenames(file_name.toString(),log,result,parentJob);\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t } \r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t }*/\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\r\n\t\t\t }\r\n\t\t\t\r\n\t\t}\r\n     \tentrystatus=true;\r\n    \r\n\t}catch (Exception e)\r\n\t{\r\n\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error\",e.toString()));\r\n\t}\r\n\tfinally \r\n\t{\r\n\t\tif ( file_name != null )\r\n\t\t{\r\n\t\t\ttry  \r\n\t\t\t{\r\n\t\t\t\tfile_name.close();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcatch ( IOException ex ) {};\r\n\t\t}\r\n\t\r\n\t}\r\n return entrystatus;\r\n }","id":89601,"modified_method":"private boolean MoveOneFile(FileObject Currentfile, FileObject sourcefilefolder,String realDestinationFilefoldername, \r\n\t\t\t\t\t\tString realWildcard,LogWriter log,Job parentJob,Result result, FileObject movetofolderfolder)\r\n\t{\r\n\t\tboolean entrystatus=false;\r\n\t\tFileObject file_name=null;\r\n\t\t\r\n\ttry {\r\n     \tif (!Currentfile.toString().equals(sourcefilefolder.toString()))\r\n\t\t{\r\n\t\t\t// Pass over the Base folder itself\r\n\t\t\t\r\n    \t\t// return destination short filename\r\n     \t\tString sourceshortfilename=Currentfile.getName().getBaseName();\r\n    \t\tString shortfilename=sourceshortfilename;\r\n\t\t\ttry{\r\n\t\t\t  shortfilename=getDestinationFilename(sourceshortfilename);\r\n\t\t\t}catch (Exception e)\r\n\t\t\t{\r\n\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",Currentfile.getName().getBaseName(),e.toString())));\r\n\t\t\t\treturn entrystatus;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//log.logBasic(\"-----Current-------\", Currentfile.getName().getBaseName());\r\n\t\t\tint lenCurrent=sourceshortfilename.length();\r\n\t\t\t//log.logBasic(\"-----short_filename-------\", shortfilename);\r\n\t\t\tString short_filename_from_basefolder=shortfilename;\r\n\t\t\tif(!isDoNotKeepFolderStructure())\t\r\n\t\t\t\tshort_filename_from_basefolder=Currentfile.toString().substring(sourcefilefolder.toString().length(),Currentfile.toString().length());        \t\t\t\t\t\r\n\t\t\t//log.logBasic(\"-----short_filename_from_basefolder-------\", short_filename_from_basefolder);\r\n\t\t\tshort_filename_from_basefolder=short_filename_from_basefolder.substring(0,short_filename_from_basefolder.length()-lenCurrent)+shortfilename;\r\n\t\t\t//log.logBasic(\"-----short_filename_from_basefolder-------\", short_filename_from_basefolder);\r\n\t\t\t// Built destination filename\r\n\t\t\tfile_name=KettleVFS.getFileObject(realDestinationFilefoldername + Const.FILE_SEPARATOR + short_filename_from_basefolder); \r\n\t\t\t \r\n\r\n\t\t\t\r\n\t\t\tif (!Currentfile.getParent().toString().equals(sourcefilefolder.toString()))\r\n\t\t\t {\r\n\t\t\t\t\r\n\t\t\t\t// Not in the Base Folder..Only if include sub folders  \r\n\t\t\t\t if (include_subfolders)\r\n\t\t\t\t {\r\n\t\t\t\t\t// Folders..only if include subfolders\r\n\t\t\t\t\t if (Currentfile.getType() == FileType.FOLDER)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t if (include_subfolders && move_empty_folders && Const.isEmpty(wildcard))\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t }\r\n\t\t\t\t\t else\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (GetFileWildcard(sourceshortfilename,realWildcard))\r\n\t\t\t\t\t\t{\t\r\n\t\t\t\t\t\t\tentrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t\t// In the Base Folder...\r\n\t\t\t\t// Folders..only if include subfolders\r\n\t\t\t\t if (Currentfile.getType() == FileType.FOLDER)\r\n\t\t\t\t {\r\n\t\t\t\t\t if (include_subfolders && move_empty_folders  && Const.isEmpty(wildcard))\r\n\t\t\t\t\t {\r\n\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t\t else\r\n\t\t\t\t {\r\n\r\n\t\t\t\t\t // file...Check if exists\r\n\t\t\t\t\t if (GetFileWildcard(sourceshortfilename,realWildcard))\r\n\t\t\t\t\t {\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t entrystatus=MoveFile(shortfilename,Currentfile,file_name,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\r\n\t\t\t }\r\n\t\t\t\r\n\t\t}\r\n     \tentrystatus=true;\r\n    \r\n\t}catch (Exception e)\r\n\t{\r\n\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Log.Error\",e.toString()));\r\n\t}\r\n\tfinally \r\n\t{\r\n\t\tif ( file_name != null )\r\n\t\t{\r\n\t\t\ttry  \r\n\t\t\t{\r\n\t\t\t\tfile_name.close();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcatch ( IOException ex ) {};\r\n\t\t}\r\n\t\r\n\t}\r\n return entrystatus;\r\n }","commit_id":"a05cabac45d5da5426c3ba7ace0ac834289d362d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean ProcessFileFolder(String sourcefilefoldername,String destinationfilefoldername,String wildcard,Job parentJob,Result result,String MoveToFolder)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tboolean entrystatus = false ;\n\t\tFileObject sourcefilefolder = null;\n\t\tFileObject destinationfilefolder = null;\r\n\t\tFileObject movetofolderfolder = null;\r\n\t\tFileObject Currentfile =null;\n\t\t\n\t\t// Get real source, destination file and wilcard\n\t\tString realSourceFilefoldername = environmentSubstitute(sourcefilefoldername);\n\t\tString realDestinationFilefoldername = environmentSubstitute(destinationfilefoldername);\n\t\tString realWildcard=environmentSubstitute(wildcard);\n\n\t\ttry\n\t\t{\n\t\t\t\n\t\t     // Here gc() is explicitly called if e.g. createfile is used in the same\n\t\t     // job for the same file. The problem is that after creating the file the\n\t\t     // file object is not properly garbaged collected and thus the file cannot\n\t\t     // be deleted anymore. This is a known problem in the JVM.\n\n\t\t     System.gc();\n\t\t      \n\t\t\tsourcefilefolder = KettleVFS.getFileObject(realSourceFilefoldername);\n\t\t\tdestinationfilefolder = KettleVFS.getFileObject(realDestinationFilefoldername);\r\n\t\t\tmovetofolderfolder   =KettleVFS.getFileObject(MoveToFolder);\n\t\t\t\n\t\t\tif (sourcefilefolder.exists())\n\t\t\t{\n\t\t\t\n\t\t\t\t// Check if destination folder/parent folder exists !\n\t\t\t\t// If user wanted and if destination folder does not exist\n\t\t\t\t// PDI will create it\n\t\t\t\tif(CreateDestinationFolder(destinationfilefolder))\n\t\t\t\t{\n\n\t\t\t\t\t// Basic Tests\n\t\t\t\t\tif (sourcefilefolder.getType().equals(FileType.FOLDER) && destination_is_a_file)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Source is a folder, destination is a file\n\t\t\t\t\t\t// WARNING !!! CAN NOT MOVE FOLDER TO FILE !!!\n\t\t\t\t\t\t\n\t\t\t\t\t\tlog.logError(Messages.getString(\"JobMoveFiles.Log.Forbidden\"), Messages.getString(\"JobMoveFiles.Log.CanNotMoveFolderToFile\",realSourceFilefoldername,realDestinationFilefoldername));\t\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Update Errors\n\t\t\t\t\t\tupdateErrors();\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif (destinationfilefolder.getType().equals(FileType.FOLDER) && sourcefilefolder.getType().equals(FileType.FILE) )\n\t\t\t\t\t\t{\t\t\t\t\n\t\t\t\t\t\t\t// Source is a file, destination is a folder\r\n\t\t\t\t\t\t\t// return destination short filename\r\n\t\t\t\t\t\t\tString shortfilename=sourcefilefolder.getName().getBaseName();\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t shortfilename=getDestinationFilename(sourcefilefolder.getName().getBaseName());\r\n\t\t\t\t\t\t\t}catch (Exception e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",sourcefilefolder.getName().getBaseName(),e.toString())));\r\n\t\t\t\t\t\t\t\treturn entrystatus;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Move the file to the destination folder\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tString destinationfilenamefull=destinationfilefolder.toString()+Const.FILE_SEPARATOR+shortfilename;\r\n\t\t\t\t\t\t\tFileObject destinationfile= KettleVFS.getFileObject(destinationfilenamefull);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tentrystatus=MoveFile(shortfilename,sourcefilefolder,destinationfile,movetofolderfolder,log,parentJob,result);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sourcefilefolder.getType().equals(FileType.FILE) && destination_is_a_file)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Source is a file, destination is a file\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tFileObject destinationfile= KettleVFS.getFileObject(realDestinationFilefoldername);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// return destination short filename\r\n\t\t\t\t\t\t\tString shortfilename=destinationfile.getName().getBaseName();\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t shortfilename=getDestinationFilename(destinationfile.getName().getBaseName());\r\n\t\t\t\t\t\t\t}catch (Exception e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",sourcefilefolder.getName().getBaseName(),e.toString())));\r\n\t\t\t\t\t\t\t\treturn entrystatus;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tString destinationfilenamefull=destinationfilefolder.getParent().toString()+Const.FILE_SEPARATOR+shortfilename;\r\n\t\t\t\t\t\t\tdestinationfile= KettleVFS.getFileObject(destinationfilenamefull);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tentrystatus=MoveFile(shortfilename,sourcefilefolder,destinationfile,movetofolderfolder,log,parentJob,result);\r\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Both source and destination are folders\n\t\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logDetailed(toString(),\"  \");\r\n\t\t\t\t\t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobMoveFiles.Log.FetchFolder\",sourcefilefolder.toString()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tFileObject[] fileObjects = sourcefilefolder.findFiles(\r\n\t                                new AllFileSelector() \r\n\t                                {\t\r\n\t                                    public boolean traverseDescendents(FileSelectInfo info)\r\n\t                                    {\r\n\t                                        return true;\r\n\t                                    }\r\n\t                                    \r\n\t                                    public boolean includeFile(FileSelectInfo info)\r\n\t                                    {\r\n\t                                    \r\n\t                                    \tFileObject fileObject = info.getFile();\r\n\t                                    \ttry {\r\n\t                                    \t    if ( fileObject == null) return false;\r\n\t                                    \t}\r\n\t                                    \tcatch (Exception ex)\r\n\t                                    \t{\r\n\t                                    \t\t// Upon error don't process the file.\r\n\t                                    \t\treturn false;\r\n\t                                    \t}\r\n\t                                    \t\r\n\t                                    \tfinally \r\n\t                                \t\t{\r\n\t                                \t\t\tif ( fileObject != null )\r\n\t                                \t\t\t{\r\n\t                                \t\t\t\ttry  {fileObject.close();} catch ( IOException ex ) {};\r\n\t                                \t\t\t}\r\n\t           \r\n\t                                \t\t}\r\n\t                                    \treturn true;\r\n\t                                    }\r\n\t                                }\r\n\t                            );\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (fileObjects != null) \r\n\t                        {\r\n\t                            for (int j = 0; j < fileObjects.length; j++)\r\n\t                            {\r\n\t                            \t// Fetch files list one after one ...\r\n\t                                Currentfile=fileObjects[j];\r\n\t                                if(!DoNotProcessRest)\r\n\t    \t\t\t           \t\t{\r\n\t\t                                if(!MoveOneFile(Currentfile, sourcefilefolder,realDestinationFilefoldername, \r\n\t\t                \t\t\t\t\t\trealWildcard,log,parentJob,result,movetofolderfolder))\r\n\t\t                                {\r\n\t\t                                \t// Update Errors\r\n\t\t        \t\t\t\t\t\t\tupdateErrors();\r\n\t\t                                }\r\n\t    \t\t\t           \t\t}else\r\n\t    \t\t\t           \t\t{\r\n\t    \t\t\t           \t\t\tif(log.isDetailed()) log.logDetailed(toString(),Messages.getString(\"JobEntryMoveFiles.log.IgnoringFile\",Currentfile.toString()));\r\n\t    \t\t\t           \t\r\n\t    \t\t\t           \t\t}\r\n\t                            }\n\t                        }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tentrystatus = true ;\n\t\t\t\t} // end if\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Destination Folder or Parent folder is missing\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.DestinationFolderNotFound\",realDestinationFilefoldername));\t\t\t\t\t\n\t\t\t\t\t\r\n\t\t\t\t\t// Update Errors\r\n\t\t\t\t\tupdateErrors();\n\t\t\t\t}\t\n\t\t\t} // end if\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.SourceFileNotExists\",realSourceFilefoldername));\t\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t// Update Errors\r\n\t\t\t\tupdateErrors();\n\t\t\t}\n\t\t} // end try\n\t\n\t\tcatch (IOException e) \n\t\t{\n\n\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.Exception.MoveProcess\",realSourceFilefoldername.toString(),destinationfilefolder.toString(), e.getMessage()));\t\t\t\t\t\n\t\t\t// Update Errors\r\n\t\t\tupdateErrors();\r\n\t\t}\n\t\tfinally \n\t\t{\n\t\t\tif ( sourcefilefolder != null )\n\t\t\t{\n\t\t\t\ttry  \n\t\t\t\t{\n\t\t\t\t\tsourcefilefolder.close();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t}\n\t\t\tif ( destinationfilefolder != null )\n\t\t\t{\n\t\t\t\ttry  \n\t\t\t\t{\n\t\t\t\t\tdestinationfilefolder.close();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t}\r\n\t\t\tif ( Currentfile != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tCurrentfile.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\tif ( movetofolderfolder != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tmovetofolderfolder.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n\t\t}\n\n\t\treturn entrystatus;\n\t}","id":89602,"modified_method":"private boolean ProcessFileFolder(String sourcefilefoldername,String destinationfilefoldername,String wildcard,Job parentJob,Result result,String MoveToFolder)\r\n\t{\r\n\t\tLogWriter log = LogWriter.getInstance();\r\n\t\tboolean entrystatus = false ;\r\n\t\tFileObject sourcefilefolder = null;\r\n\t\tFileObject destinationfilefolder = null;\r\n\t\tFileObject movetofolderfolder = null;\r\n\t\tFileObject Currentfile =null;\r\n\t\t\r\n\t\t// Get real source, destination file and wilcard\r\n\t\tString realSourceFilefoldername = environmentSubstitute(sourcefilefoldername);\r\n\t\tString realDestinationFilefoldername = environmentSubstitute(destinationfilefoldername);\r\n\t\tString realWildcard=environmentSubstitute(wildcard);\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\t\r\n\t\t     // Here gc() is explicitly called if e.g. createfile is used in the same\r\n\t\t     // job for the same file. The problem is that after creating the file the\r\n\t\t     // file object is not properly garbaged collected and thus the file cannot\r\n\t\t     // be deleted anymore. This is a known problem in the JVM.\r\n\r\n\t\t     System.gc();\r\n\t\t      \r\n\t\t\tsourcefilefolder = KettleVFS.getFileObject(realSourceFilefoldername);\r\n\t\t\tdestinationfilefolder = KettleVFS.getFileObject(realDestinationFilefoldername);\r\n\t\t\tif(!Const.isEmpty(MoveToFolder)) movetofolderfolder  =KettleVFS.getFileObject(MoveToFolder);\r\n\t\t\t\r\n\t\t\tif (sourcefilefolder.exists())\r\n\t\t\t{\r\n\t\t\t\r\n\t\t\t\t// Check if destination folder/parent folder exists !\r\n\t\t\t\t// If user wanted and if destination folder does not exist\r\n\t\t\t\t// PDI will create it\r\n\t\t\t\tif(CreateDestinationFolder(destinationfilefolder))\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\t// Basic Tests\r\n\t\t\t\t\tif (sourcefilefolder.getType().equals(FileType.FOLDER) && destination_is_a_file)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Source is a folder, destination is a file\r\n\t\t\t\t\t\t// WARNING !!! CAN NOT MOVE FOLDER TO FILE !!!\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlog.logError(Messages.getString(\"JobMoveFiles.Log.Forbidden\"), Messages.getString(\"JobMoveFiles.Log.CanNotMoveFolderToFile\",realSourceFilefoldername,realDestinationFilefoldername));\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Update Errors\r\n\t\t\t\t\t\tupdateErrors();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\tif (destinationfilefolder.getType().equals(FileType.FOLDER) && sourcefilefolder.getType().equals(FileType.FILE) )\r\n\t\t\t\t\t\t{\t\t\t\t\r\n\t\t\t\t\t\t\t// Source is a file, destination is a folder\r\n\t\t\t\t\t\t\t// return destination short filename\r\n\t\t\t\t\t\t\tString shortfilename=sourcefilefolder.getName().getBaseName();\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t//String SubFolders=sourcefilefolder.toString().substring(0, sourcefilefolder.toString().lastIndexOf(Const.FILE_SEPARATOR));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t//log.logBasic(toString(), \"Base folder : \"+ SubFolders);\r\n\t\t\t\t\t\t\t//SubFolders=SubFolders.substring(sourcefilefolder.getName().getBaseName().length(),SubFolders.length());\r\n\t\t\t\t\t\t\t//log.logBasic(toString(), \"SubFolders : \"+ SubFolders);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t shortfilename=getDestinationFilename(sourcefilefolder.getName().getBaseName());\r\n\t\t\t\t\t\t\t}catch (Exception e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",sourcefilefolder.getName().getBaseName(),e.toString())));\r\n\t\t\t\t\t\t\t\treturn entrystatus;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Move the file to the destination folder\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tString destinationfilenamefull=destinationfilefolder.toString()+Const.FILE_SEPARATOR+shortfilename;\r\n\t\t\t\t\t\t\tFileObject destinationfile= KettleVFS.getFileObject(destinationfilenamefull);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tentrystatus=MoveFile(shortfilename,sourcefilefolder,destinationfile,movetofolderfolder,log,parentJob,result);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (sourcefilefolder.getType().equals(FileType.FILE) && destination_is_a_file)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Source is a file, destination is a file\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tFileObject destinationfile= KettleVFS.getFileObject(realDestinationFilefoldername);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// return destination short filename\r\n\t\t\t\t\t\t\tString shortfilename=destinationfile.getName().getBaseName();\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t shortfilename=getDestinationFilename(destinationfile.getName().getBaseName());\r\n\t\t\t\t\t\t\t}catch (Exception e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logError(toString(), Messages.getString(Messages.getString(\"JobMoveFiles.Error.GettingFilename\",sourcefilefolder.getName().getBaseName(),e.toString())));\r\n\t\t\t\t\t\t\t\treturn entrystatus;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tString destinationfilenamefull=destinationfilefolder.getParent().toString()+Const.FILE_SEPARATOR+shortfilename;\r\n\t\t\t\t\t\t\tdestinationfile= KettleVFS.getFileObject(destinationfilenamefull);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tentrystatus=MoveFile(shortfilename,sourcefilefolder,destinationfile,movetofolderfolder,log,parentJob,result);\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Both source and destination are folders\r\n\t\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logDetailed(toString(),\"  \");\r\n\t\t\t\t\t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobMoveFiles.Log.FetchFolder\",sourcefilefolder.toString()));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tFileObject[] fileObjects = sourcefilefolder.findFiles(\r\n\t                                new AllFileSelector() \r\n\t                                {\t\r\n\t                                    public boolean traverseDescendents(FileSelectInfo info)\r\n\t                                    {\r\n\t                                        return true;\r\n\t                                    }\r\n\t                                    \r\n\t                                    public boolean includeFile(FileSelectInfo info)\r\n\t                                    {\r\n\t                                    \r\n\t                                    \tFileObject fileObject = info.getFile();\r\n\t                                    \ttry {\r\n\t                                    \t    if ( fileObject == null) return false;\r\n\t                                    \t}\r\n\t                                    \tcatch (Exception ex)\r\n\t                                    \t{\r\n\t                                    \t\t// Upon error don't process the file.\r\n\t                                    \t\treturn false;\r\n\t                                    \t}\r\n\t                                    \t\r\n\t                                    \tfinally \r\n\t                                \t\t{\r\n\t                                \t\t\tif ( fileObject != null )\r\n\t                                \t\t\t{\r\n\t                                \t\t\t\ttry  {fileObject.close();} catch ( IOException ex ) {};\r\n\t                                \t\t\t}\r\n\t           \r\n\t                                \t\t}\r\n\t                                    \treturn true;\r\n\t                                    }\r\n\t                                }\r\n\t                            );\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (fileObjects != null) \r\n\t                        {\r\n\t                            for (int j = 0; j < fileObjects.length; j++)\r\n\t                            {\r\n\r\n\t                            \t// Fetch files in list one after one ...\r\n\t                                Currentfile=fileObjects[j];\r\n\t                                if(!DoNotProcessRest)\r\n\t    \t\t\t           \t\t{\r\n\t\t                                if(!MoveOneFile(Currentfile, sourcefilefolder,realDestinationFilefoldername, \r\n\t\t                \t\t\t\t\t\trealWildcard,log,parentJob,result,movetofolderfolder))\r\n\t\t                                {\r\n\t\t                                \t// Update Errors\r\n\t\t        \t\t\t\t\t\t\tupdateErrors();\r\n\t\t                                }\r\n\t    \t\t\t           \t\t}else\r\n\t    \t\t\t           \t\t{\r\n\t    \t\t\t           \t\t\tif(log.isDetailed()) log.logDetailed(toString(),Messages.getString(\"JobEntryMoveFiles.log.IgnoringFile\",Currentfile.toString()));\r\n\t    \t\t\t           \t\r\n\t    \t\t\t           \t\t}\r\n\t                            }\r\n\t                        }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentrystatus = true ;\r\n\t\t\t\t} // end if\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// Destination Folder or Parent folder is missing\r\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.DestinationFolderNotFound\",realDestinationFilefoldername));\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Update Errors\r\n\t\t\t\t\tupdateErrors();\r\n\t\t\t\t}\t\r\n\t\t\t} // end if\r\n\t\t\telse\r\n\t\t\t{\t\r\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.SourceFileNotExists\",realSourceFilefoldername));\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// Update Errors\r\n\t\t\t\tupdateErrors();\r\n\t\t\t}\r\n\t\t} // end try\r\n\t\r\n\t\tcatch (IOException e) \r\n\t\t{\r\n\r\n\t\t\tlog.logError(toString(), Messages.getString(\"JobMoveFiles.Error.Exception.MoveProcess\",realSourceFilefoldername.toString(),destinationfilefolder.toString(), e.getMessage()));\t\t\t\t\t\r\n\t\t\t// Update Errors\r\n\t\t\tupdateErrors();\r\n\t\t}\r\n\t\tfinally \r\n\t\t{\r\n\t\t\tif ( sourcefilefolder != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tsourcefilefolder.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\tif ( destinationfilefolder != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tdestinationfilefolder.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\tif ( Currentfile != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tCurrentfile.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t\tif ( movetofolderfolder != null )\r\n\t\t\t{\r\n\t\t\t\ttry  \r\n\t\t\t\t{\r\n\t\t\t\t\tmovetofolderfolder.close();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\r\n\t\treturn entrystatus;\r\n\t}","commit_id":"a05cabac45d5da5426c3ba7ace0ac834289d362d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Includes the js and css resources for the dashboard macro.\n     * \n     * @param editMode whether the dashboard is in edit mode or not (js resources need to be loaded only in edit mode)\n     */\n    protected void includeResources(boolean editMode)\n    {\n        Map<String, Object> fxParamsForceSkinAction = new HashMap<String, Object>();\n        fxParamsForceSkinAction.put(\"forceSkinAction\", true);\n        ssfx.use(\"uicomponents/dashboard/dashboard.css\", fxParamsForceSkinAction);\n        // include the js resources, for editing, in edit mode only\n        if (editMode) {\n            // include the effects.js and dragdrop.js that are needed by the dashboard js\n            jsfx.use(\"js/scriptaculous/effects.js\");\n            jsfx.use(\"js/scriptaculous/dragdrop.js\");\n            Map<String, Object> fxParamsNonDeferred = new HashMap<String, Object>();\n            fxParamsNonDeferred.putAll(fxParamsForceSkinAction);\n            fxParamsNonDeferred.put(\"defer\", false);\n            jsfx.use(\"js/xwiki/wysiwyg/xwe/XWikiWysiwyg.js\", fxParamsNonDeferred);\n            jsfx.use(\"uicomponents/dashboard/dashboard.js\", fxParamsForceSkinAction);\n        }\n    }","id":89603,"modified_method":"/**\n     * Includes the js and css resources for the dashboard macro.\n     * \n     * @param editMode whether the dashboard is in edit mode or not (js resources need to be loaded only in edit mode)\n     */\n    protected void includeResources(boolean editMode)\n    {\n        Map<String, Object> fxParamsForceSkinAction = new HashMap<String, Object>();\n        fxParamsForceSkinAction.put(\"forceSkinAction\", true);\n        ssfx.use(\"uicomponents/dashboard/dashboard.css\", fxParamsForceSkinAction);\n        // include the js resources, for editing, in edit mode only\n        if (editMode) {\n            // include the effects.js and dragdrop.js that are needed by the dashboard js\n            jsfx.use(\"js/scriptaculous/effects.js\");\n            jsfx.use(\"js/scriptaculous/dragdrop.js\");\n            Map<String, Object> fxParamsNonDeferred = new HashMap<String, Object>();\n            fxParamsNonDeferred.put(\"defer\", false);\n            Map<String, Object> fxParamsNonDeferredForceSkinAction = new HashMap<String, Object>();\n            fxParamsNonDeferredForceSkinAction.putAll(fxParamsForceSkinAction);\n            fxParamsNonDeferredForceSkinAction.putAll(fxParamsNonDeferred);\n            // include the smart client as well since it injects stuff in the GWT and then onModuleLoad cannot be ran\n            // without. See XWIKI-6620 for details\n            jsfx.use(\"js/smartclient/initsc.js\", fxParamsNonDeferredForceSkinAction);\n            jsfx.use(\"js/smartclient/modules/ISC_Core.js\", fxParamsNonDeferred);\n            jsfx.use(\"js/smartclient/overwritesc.js\", fxParamsNonDeferred);\n            jsfx.use(\"js/smartclient/modules/ISC_Foundation.js\", fxParamsNonDeferred);\n            jsfx.use(\"js/smartclient/modules/ISC_Containers.js\", fxParamsNonDeferred);\n            // this is the only file that seems to be not really needed. I am including it though since I'm including\n            // all others anyway and maybe there's a case I didn't see\n            jsfx.use(\"js/smartclient/modules/ISC_Grids.js\", fxParamsNonDeferred);\n            jsfx.use(\"js/smartclient/modules/ISC_Forms.js\", fxParamsNonDeferred);\n            jsfx.use(\"js/smartclient/modules/ISC_DataBinding.js\", fxParamsNonDeferred);\n            jsfx.use(\"js/xwiki/wysiwyg/xwe/XWikiWysiwyg.js\", fxParamsNonDeferredForceSkinAction);\n            jsfx.use(\"uicomponents/dashboard/dashboard.js\", fxParamsForceSkinAction);\n        }\n    }","commit_id":"257bf6fa647f245c47d50e5145ef50f96d03a165","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        // Since we have a dependency on xwiki-core the Context Component Manager will be found and the test will try\n        // to look up the Dashboard macro in the User and Wiki Component Manager and thus need a Current User and a\n        // Current Wiki. It's easier for this test to simply unregister the Context Component Manager rather than\n        // have to provide mocks for them.\n        componentManager.unregisterComponent(ComponentManager.class, \"context\");\n\n        final SkinExtension mockSsfx = mockery.mock(SkinExtension.class, \"ssfxMock\");\n        final SkinExtension mockJsfx = mockery.mock(SkinExtension.class, \"jsfxMock\");\n        mockery.checking(new Expectations()\n        {\n            {\n                allowing(mockSsfx).use(with(\"uicomponents/container/columns.css\"), with(any(Map.class)));\n                allowing(mockSsfx).use(with(\"uicomponents/dashboard/dashboard.css\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/scriptaculous/dragdrop.js\"));\n                allowing(mockJsfx).use(with(\"js/scriptaculous/effects.js\"));\n                allowing(mockJsfx).use(with(\"js/xwiki/wysiwyg/xwe/XWikiWysiwyg.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"uicomponents/dashboard/dashboard.js\"), with(any(Map.class)));\n            }\n        });\n        DefaultComponentDescriptor<SkinExtension> ssfxDesc = new DefaultComponentDescriptor<SkinExtension>();\n        ssfxDesc.setRole(SkinExtension.class);\n        ssfxDesc.setRoleHint(\"ssfx\");\n        componentManager.registerComponent(ssfxDesc, mockSsfx);\n        DefaultComponentDescriptor<SkinExtension> jsfxDesc = new DefaultComponentDescriptor<SkinExtension>();\n        jsfxDesc.setRole(SkinExtension.class);\n        jsfxDesc.setRoleHint(\"jsfx\");\n        componentManager.registerComponent(jsfxDesc, mockJsfx);\n\n        final GadgetSource mockGadgetSource = mockery.mock(GadgetSource.class);\n        mockery.checking(new Expectations()\n        {\n            {\n                allowing(mockGadgetSource).getGadgets(with(any(String.class)),\n                    with(any(MacroTransformationContext.class)));\n                will(returnValue(Arrays.asList(new Gadget(\"0\", Arrays.<Block>asList(new WordBlock(\"title\")), Arrays\n                    .<Block>asList(new WordBlock(\"content\")), \"1,1\"))));\n                allowing(mockGadgetSource).getDashboardSourceMetadata(with(any(String.class)),\n                    with(any(MacroTransformationContext.class)));\n                will(returnValue(Collections.<Block> emptyList()));\n                allowing(mockGadgetSource).isEditing();\n                // return true on is editing, to take as many paths possible\n                will(returnValue(true));\n            }\n        });\n        DefaultComponentDescriptor<GadgetSource> descriptorGR = new DefaultComponentDescriptor<GadgetSource>();\n        descriptorGR.setRole(GadgetSource.class);\n        componentManager.registerComponent(descriptorGR, mockGadgetSource);\n    }","id":89604,"modified_method":"@RenderingTestSuite.Initialized\n    public void initialize(ComponentManager componentManager) throws Exception\n    {\n        Mockery mockery = new JUnit4Mockery();\n\n        // Since we have a dependency on xwiki-core the Context Component Manager will be found and the test will try\n        // to look up the Dashboard macro in the User and Wiki Component Manager and thus need a Current User and a\n        // Current Wiki. It's easier for this test to simply unregister the Context Component Manager rather than\n        // have to provide mocks for them.\n        componentManager.unregisterComponent(ComponentManager.class, \"context\");\n\n        final SkinExtension mockSsfx = mockery.mock(SkinExtension.class, \"ssfxMock\");\n        final SkinExtension mockJsfx = mockery.mock(SkinExtension.class, \"jsfxMock\");\n        mockery.checking(new Expectations()\n        {\n            {\n                allowing(mockSsfx).use(with(\"uicomponents/container/columns.css\"), with(any(Map.class)));\n                allowing(mockSsfx).use(with(\"uicomponents/dashboard/dashboard.css\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/scriptaculous/dragdrop.js\"));\n                allowing(mockJsfx).use(with(\"js/scriptaculous/effects.js\"));\n                allowing(mockJsfx).use(with(\"js/smartclient/initsc.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/modules/ISC_Core.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/overwritesc.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/modules/ISC_Foundation.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/modules/ISC_Containers.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/modules/ISC_Grids.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/modules/ISC_Forms.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"js/smartclient/modules/ISC_DataBinding.js\"), with(any(Map.class)));                \n                allowing(mockJsfx).use(with(\"js/xwiki/wysiwyg/xwe/XWikiWysiwyg.js\"), with(any(Map.class)));\n                allowing(mockJsfx).use(with(\"uicomponents/dashboard/dashboard.js\"), with(any(Map.class)));\n            }\n        });\n        DefaultComponentDescriptor<SkinExtension> ssfxDesc = new DefaultComponentDescriptor<SkinExtension>();\n        ssfxDesc.setRole(SkinExtension.class);\n        ssfxDesc.setRoleHint(\"ssfx\");\n        componentManager.registerComponent(ssfxDesc, mockSsfx);\n        DefaultComponentDescriptor<SkinExtension> jsfxDesc = new DefaultComponentDescriptor<SkinExtension>();\n        jsfxDesc.setRole(SkinExtension.class);\n        jsfxDesc.setRoleHint(\"jsfx\");\n        componentManager.registerComponent(jsfxDesc, mockJsfx);\n\n        final GadgetSource mockGadgetSource = mockery.mock(GadgetSource.class);\n        mockery.checking(new Expectations()\n        {\n            {\n                allowing(mockGadgetSource).getGadgets(with(any(String.class)),\n                    with(any(MacroTransformationContext.class)));\n                will(returnValue(Arrays.asList(new Gadget(\"0\", Arrays.<Block>asList(new WordBlock(\"title\")), Arrays\n                    .<Block>asList(new WordBlock(\"content\")), \"1,1\"))));\n                allowing(mockGadgetSource).getDashboardSourceMetadata(with(any(String.class)),\n                    with(any(MacroTransformationContext.class)));\n                will(returnValue(Collections.<Block> emptyList()));\n                allowing(mockGadgetSource).isEditing();\n                // return true on is editing, to take as many paths possible\n                will(returnValue(true));\n            }\n        });\n        DefaultComponentDescriptor<GadgetSource> descriptorGR = new DefaultComponentDescriptor<GadgetSource>();\n        descriptorGR.setRole(GadgetSource.class);\n        componentManager.registerComponent(descriptorGR, mockGadgetSource);\n    }","commit_id":"257bf6fa647f245c47d50e5145ef50f96d03a165","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@BeforeMethod\n   public void beforeTest()\n   {\n      MockitoAnnotations.initMocks(this);\n\n      seam.reset();\n      seam.ignoreNonResolvable()\n      .use(\"identity\", identity)\n      .use(\"projectIterationDAO\", projectIterationDAO)\n      .use(\"translationFileServiceImpl\", translationFileService)\n      .use(\"documentServiceImpl\", documentService)\n      .use(\"documentDAO\", documentDAO)\n      .use(\"filePersistService\", filePersistService)\n      .allowCycles();\n\n      fileService = seam.autowire(FileService.class);\n   }","id":89605,"modified_method":"@BeforeMethod\n   public void beforeTest()\n   {\n      MockitoAnnotations.initMocks(this);\n\n      seam.reset();\n      seam.ignoreNonResolvable()\n            .use(\"sourceDocumentUploader\", sourceUploader)\n            .allowCycles();\n\n      fileService = seam.autowire(FileService.class);\n   }","commit_id":"903c0171b05127643dfb14401090e58a6ec08a89","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public GetLocaleListResult execute(GetLocaleList action,\n    ExecutionContext context) throws ActionException {\n        identity.checkLoggedIn();\n\n        iterationId = action.getWorkspaceId().getProjectIterationId();\n        projectSlug = iterationId.getProjectSlug();\n\n        List<Locale> locales = new ArrayList<Locale>();\n\n        List<HLocale> hLocales = getLocaleList();\n\n        for (HLocale hLocale : hLocales) {\n            Locale locale = new Locale(new IdForLocale(hLocale.getId(),\n                    hLocale.getLocaleId()), hLocale.retrieveDisplayName());\n            locales.add(locale);\n        }\n        return new GetLocaleListResult(locales);\n    }","id":89606,"modified_method":"@Override\n    public GetLocaleListResult execute(GetLocaleList action,\n            ExecutionContext context) throws ActionException {\n        identity.checkLoggedIn();\n\n        ProjectIterationId iterationId =\n                action.getWorkspaceId().getProjectIterationId();\n        String projectSlug = iterationId.getProjectSlug();\n\n        List<HLocale> hLocales =\n                localeServiceImpl.getSupportedLanguageByProjectIteration(\n                        projectSlug, iterationId.getIterationSlug());\n\n        List<Locale> locales = Lists.newArrayList();\n        for (HLocale hLocale : hLocales) {\n            Locale locale =\n                    new Locale(new IdForLocale(hLocale.getId(),\n                            hLocale.getLocaleId()),\n                            hLocale.retrieveDisplayName());\n            locales.add(locale);\n        }\n        return new GetLocaleListResult(locales);\n    }","commit_id":"78e782ac9ed454aa4c6bef8fc7ba520bab6245e6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        // @formatter:off\n        handler = SeamAutowire.instance()\n                .reset()\n                .use(\"identity\", identity)\n                .use(\"projectIterationDAO\", projectIterationDAO)\n                .use(\"projectDAO\", projectDAO)\n                .use(\"localeDAO\", localeDAO)\n                .ignoreNonResolvable()\n                .autowire(GetLocaleListHandler.class);\n        // @formatter:on\n\n        WorkspaceId workspaceId = TestFixture.workspaceId();\n        action = new GetLocaleList();\n        action.setWorkspaceId(workspaceId);\n\n        Set<HLocale> iterationLocales = new HashSet<HLocale>();\n        iterationLocales.add(new HLocale(LocaleId.EN_US));\n        iterationLocales.add(new HLocale(LocaleId.DE));\n        when(hProjectIteration.getId()).thenReturn(1L);\n        when(hProjectIteration.getCustomizedLocales())\n                .thenReturn(iterationLocales);\n        when(projectIterationDAO.getBySlug(\"project\", \"master\"))\n                .thenReturn(hProjectIteration);\n\n        Set<HLocale> projectLocales = new HashSet<HLocale>();\n        projectLocales.add(new HLocale(LocaleId.ES));\n        when(hProject.getId()).thenReturn(1L);\n        when(hProject.getCustomizedLocales()).thenReturn(projectLocales);\n        when(projectDAO.getBySlug(\"project\")).thenReturn(hProject);\n\n        List<HLocale> defaultLocales = new ArrayList<HLocale>();\n        defaultLocales.add(new HLocale(LocaleId.FR));\n        defaultLocales.add(new HLocale(LocaleId.EN));\n        defaultLocales.add(new HLocale(LocaleId.DE));\n        when(localeDAO.findAllActiveAndEnabledByDefault())\n                .thenReturn(defaultLocales);\n    }","id":89607,"modified_method":"@BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        // @formatter:off\n        handler = SeamAutowire.instance()\n                .reset()\n                .use(\"identity\", identity)\n                .use(\"localeServiceImpl\", localeServiceImpl)\n                .ignoreNonResolvable()\n                .autowire(GetLocaleListHandler.class);\n        // @formatter:on\n\n        WorkspaceId workspaceId = TestFixture.workspaceId();\n        action = new GetLocaleList();\n        action.setWorkspaceId(workspaceId);\n        when(\n                localeServiceImpl.getSupportedLanguageByProjectIteration(\n                        \"project\", \"master\")).thenReturn(getHLocaleList());\n    }","commit_id":"78e782ac9ed454aa4c6bef8fc7ba520bab6245e6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void testExecute() throws Exception {\n        when(hProjectIteration.isOverrideLocales()).thenReturn(false);\n        when(hProject.isOverrideLocales()).thenReturn(false);\n\n        GetLocaleListResult result = handler.execute(action, null);\n        verify(identity).checkLoggedIn();\n        assertThat(result.getLocales(), Matchers.hasSize(3));\n\n        assertThat(result.getLocales().get(0).getId().getLocaleId(),\n                Matchers.equalTo(LocaleId.FR));\n        assertThat(result.getLocales().get(1).getId().getLocaleId(),\n                Matchers.equalTo(LocaleId.EN));\n        assertThat(result.getLocales().get(2).getId().getLocaleId(),\n                Matchers.equalTo(LocaleId.DE));\n    }","id":89608,"modified_method":"@Test\n    public void testExecute() throws Exception {\n        GetLocaleListResult result = handler.execute(action, null);\n        verify(identity).checkLoggedIn();\n        assertThat(result.getLocales(), Matchers.hasSize(5));\n    }","commit_id":"78e782ac9ed454aa4c6bef8fc7ba520bab6245e6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void testGetAllJavaLanguages() throws Exception {\n        List<LocaleId> loc = this.testLocaleServiceImpl.getAllJavaLanguages();\n        StringBuilder st = new StringBuilder(\"\");\n        for (LocaleId localeId : loc) {\n            st.append(localeId.getId() + \",\");\n        }\n\n        Assert.assertTrue(loc.contains(LocaleId.DE));\n        Assert.assertTrue(loc.contains(LocaleId.EN));\n        Assert.assertTrue(loc.contains(LocaleId.EN_US));\n        Assert.assertTrue(loc.contains(LocaleId.ES));\n        Assert.assertTrue(loc.contains(LocaleId.FR));\n    }","id":89609,"modified_method":"@Test\n    public void testGetAllJavaLanguages() throws Exception {\n        List<LocaleId> loc = testLocaleServiceImpl.getAllJavaLanguages();\n        StringBuilder st = new StringBuilder(\"\");\n        for (LocaleId localeId : loc) {\n            st.append(localeId.getId() + \",\");\n        }\n\n        Assert.assertTrue(loc.contains(LocaleId.DE));\n        Assert.assertTrue(loc.contains(LocaleId.EN));\n        Assert.assertTrue(loc.contains(LocaleId.EN_US));\n        Assert.assertTrue(loc.contains(LocaleId.ES));\n        Assert.assertTrue(loc.contains(LocaleId.FR));\n    }","commit_id":"78e782ac9ed454aa4c6bef8fc7ba520bab6245e6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod(firstTimeOnly = true)\n    public void setup() {\n        MockitoAnnotations.initMocks(this);\n        this.testLocaleServiceImpl = new LocaleServiceImpl();\n        this.testLocaleServiceImpl.setLocaleDAO(mockDAO);\n    }","id":89610,"modified_method":"@BeforeMethod(firstTimeOnly = true)\n    public void setup() {\n        MockitoAnnotations.initMocks(this);\n\n        this.testLocaleServiceImpl = new LocaleServiceImpl();\n        this.testLocaleServiceImpl.setProjectIterationDAO(projectIterationDAO);\n        this.testLocaleServiceImpl.setProjectDAO(projectDAO);\n        this.testLocaleServiceImpl.setLocaleDAO(localeDAO);\n\n        Set<HLocale> iterationLocales = new HashSet<HLocale>();\n        iterationLocales.add(new HLocale(LocaleId.EN_US));\n        iterationLocales.add(new HLocale(LocaleId.DE));\n\n        when(hProjectIteration.getId()).thenReturn(1L);\n        when(hProjectIteration.getCustomizedLocales()).thenReturn(\n                iterationLocales);\n        when(projectIterationDAO.getBySlug(projectSlug, versionSlug))\n                .thenReturn(hProjectIteration);\n\n        Set<HLocale> projectLocales = new HashSet<HLocale>();\n        projectLocales.add(new HLocale(LocaleId.ES));\n        when(hProject.getId()).thenReturn(1L);\n        when(hProject.getCustomizedLocales()).thenReturn(projectLocales);\n        when(projectDAO.getBySlug(projectSlug)).thenReturn(hProject);\n\n        List<HLocale> defaultLocales = new ArrayList<HLocale>();\n        defaultLocales.add(new HLocale(LocaleId.FR));\n        defaultLocales.add(new HLocale(LocaleId.EN));\n        defaultLocales.add(new HLocale(LocaleId.DE));\n        when(localeDAO.findAllActiveAndEnabledByDefault()).thenReturn(\n                defaultLocales);\n    }","commit_id":"78e782ac9ed454aa4c6bef8fc7ba520bab6245e6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void testGetAllSupportedLanguages() {\n        List<HLocale> lan = new ArrayList<HLocale>();\n        lan.add(new HLocale(new LocaleId(\"as-IN\")));\n        lan.add(new HLocale(new LocaleId(\"pt-BR\")));\n        when(mockDAO.findAll()).thenReturn(lan);\n        List<HLocale> sup = this.testLocaleServiceImpl.getAllLocales();\n        Assert.assertEquals(sup.size(), 2);\n        String loc1 = sup.get(0).getLocaleId().getId();\n        Assert.assertEquals(loc1, \"as-IN\");\n        String loc2 = sup.get(1).getLocaleId().getId();\n        Assert.assertEquals(loc2, \"pt-BR\");\n    }","id":89611,"modified_method":"@Test\n    public void testGetAllSupportedLanguages() {\n        List<HLocale> lan = new ArrayList<HLocale>();\n        lan.add(new HLocale(new LocaleId(\"as-IN\")));\n        lan.add(new HLocale(new LocaleId(\"pt-BR\")));\n        when(localeDAO.findAll()).thenReturn(lan);\n        List<HLocale> sup = testLocaleServiceImpl.getAllLocales();\n        Assert.assertEquals(sup.size(), 2);\n        String loc1 = sup.get(0).getLocaleId().getId();\n        Assert.assertEquals(loc1, \"as-IN\");\n        String loc2 = sup.get(1).getLocaleId().getId();\n        Assert.assertEquals(loc2, \"pt-BR\");\n    }","commit_id":"78e782ac9ed454aa4c6bef8fc7ba520bab6245e6","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Sets the label for which this {@link HasLink} will generate the link HTML.\n     * \n     * @param labelHTML the label's HTML value\n     * @param labelText the label's text value\n     */\n    public void setLabel(String labelHTML, String labelText)\n    {\n        setLabelHTML(labelHTML);\n        setLabelText(labelText);\n    }","id":89612,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see HasLink#setLabel(String, String, boolean)\n     */\n    public void setLabel(String labelHTML, String labelText, boolean readOnly)\n    {\n        setLabelHTML(labelHTML);\n        setLabelText(labelText);\n        this.labelTextBox.setReadOnly(readOnly);\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the extended outer HTML of this element, which includes meta data.\n     * @see #getString()\n     */\n    public final String xGetString()\n    {\n        String outerHTML;\n        if (hasChildNodes()) {\n            Element clone = Element.as(cloneNode(false));\n            clone.appendChild(getOwnerDocument().createTextNode(INNER_HTML_PLACEHOLDER));\n            outerHTML = clone.getString();\n            outerHTML = outerHTML.replace(INNER_HTML_PLACEHOLDER, xGetInnerHTML());\n        } else {\n            outerHTML = getString();\n        }\n        DocumentFragment metaData = getMetaData();\n        if (metaData != null) {\n            outerHTML = metaData.getInnerHTML().replace(INNER_HTML_PLACEHOLDER, outerHTML);\n        }\n        return unformat(outerHTML);\n    }","id":89613,"modified_method":"/**\n     * @return the extended outer HTML of this element, which includes meta data.\n     * @see #getString()\n     */\n    public final String xGetString()\n    {\n        String outerHTML;\n        // We need to remove the meta data attribute on serialization\n        String metaDataHTML = xGetAttribute(META_DATA);\n        if (!StringUtils.isEmpty(metaDataHTML)) {\n            // Remove the attribute from this element\n            removeAttribute(META_DATA);\n        }\n        if (hasChildNodes()) {\n            Element clone = Element.as(cloneNode(false));\n            clone.appendChild(getOwnerDocument().createTextNode(INNER_HTML_PLACEHOLDER));\n            outerHTML = clone.getString();\n            outerHTML = outerHTML.replace(INNER_HTML_PLACEHOLDER, xGetInnerHTML());\n        } else {\n            outerHTML = getString();\n        }\n        if (!StringUtils.isEmpty(metaDataHTML)) {\n            // Put the meta data attribute back\n            setAttribute(META_DATA, metaDataHTML);\n            outerHTML = metaDataHTML.replace(INNER_HTML_PLACEHOLDER, outerHTML);\n        }\n        return unformat(outerHTML);\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the meta data associated with this element.\n     */\n    public final native DocumentFragment getMetaData()\n    /*-{\n        return this.metaData;\n    }-*/;","id":89614,"modified_method":"/**\n     * @return the meta data associated with this element.\n     */\n    public final DocumentFragment getMetaData()\n    {\n        DocumentFragment metaData = (DocumentFragment) ((JavaScriptObject) cast()).get(META_DATA);\n        if (metaData == null) {\n            // There's no saved reference to the meta data.\n            // Test if this element has stored meta data.\n            String html = xGetAttribute(META_DATA);\n            if (!StringUtils.isEmpty(html)) {\n                // This element could be the result of node cloning or copy&paste.\n                // Let's update the cached meta data reference.\n                Element container = (Element) getOwnerDocument().createDivElement().cast();\n                container.xSetInnerHTML(html);\n                metaData = container.extractContents();\n                ((JavaScriptObject) cast()).set(META_DATA, metaData);\n            }\n        }\n        return metaData;\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Sets the meta data of this element.\n     * \n     * @param metaData a document fragment with additional information regarding this element.\n     */\n    public final native void setMetaData(DocumentFragment metaData)\n    /*-{\n        this.metaData = metaData;\n    }-*/;","id":89615,"modified_method":"/**\n     * Sets the meta data of this element.\n     * \n     * @param metaData a document fragment with additional information regarding this element.\n     */\n    public final void setMetaData(DocumentFragment metaData)\n    {\n        // Save a reference to the meta data for fast retrieval.\n        ((JavaScriptObject) cast()).set(META_DATA, metaData);\n        if (metaData != null) {\n            // We have to serialize the meta data and store it using a custom attribute to avoid loosing the meta data\n            // over node cloning or copy&paste. The custom attribute used for storing the meta data should be filtered\n            // when getting the outer HTML.\n            setAttribute(META_DATA, metaData.getInnerHTML());\n        } else {\n            removeAttribute(META_DATA);\n        }\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Fills this object with data from the passed JSON representation.\n     * \n     * @param json the JSON representation of this image config object.\n     */\n    public void fromJSON(String json)\n    {\n        JavaScriptObject jsObj = JavaScriptObject.fromJson(json);\n        setWiki(jsObj.get(\"wiki\"));\n        setSpace(jsObj.get(\"space\"));\n        setPage(jsObj.get(\"page\"));\n        setImageFileName(jsObj.get(\"filename\"));\n        setImageURL(jsObj.get(\"url\"));\n        setWidth(jsObj.get(\"width\"));\n        setHeight(jsObj.get(\"height\"));\n        setAltText(jsObj.get(\"alttext\"));\n        String foundAlignment = jsObj.get(\"alignment\");\n        if (foundAlignment != null) {\n            setAlignment(ImageAlignment.valueOf(foundAlignment));\n        }\n    }","id":89616,"modified_method":"/**\n     * Fills this object with data from the passed JSON representation.\n     * \n     * @param json the JSON representation of this image config object.\n     */\n    public void fromJSON(String json)\n    {\n        JavaScriptObject jsObj = JavaScriptObject.fromJson(json);\n        setWiki((String) jsObj.get(\"wiki\"));\n        setSpace((String) jsObj.get(\"space\"));\n        setPage((String) jsObj.get(\"page\"));\n        setImageFileName((String) jsObj.get(\"filename\"));\n        setImageURL((String) jsObj.get(\"url\"));\n        setWidth((String) jsObj.get(\"width\"));\n        setHeight((String) jsObj.get(\"height\"));\n        setAltText((String) jsObj.get(\"alttext\"));\n        String foundAlignment = (String) jsObj.get(\"alignment\");\n        if (foundAlignment != null) {\n            setAlignment(ImageAlignment.valueOf(foundAlignment));\n        }\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see ValidationRule#getFeatures()\n     */\n    public String[] getFeatures()\n    {\n        // TODO: remove the link from this list when issue XWIKI-3003 will be implemented.\n        return new String[] {\"bold\", \"italic\", \"underline\", \"strikethrough\", \"subscript\", \"superscript\",\n            \"unorderedlist\", \"orderedlist\", \"outdent\", \"indent\", \"format\", \"hr\", \"symbol\", \"inserttable\", \n            \"deletetable\", \"link\"};\n    }","id":89617,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see ValidationRule#getFeatures()\n     */\n    public String[] getFeatures()\n    {\n        return new String[] {\"bold\", \"italic\", \"underline\", \"strikethrough\", \"subscript\", \"superscript\",\n            \"unorderedlist\", \"orderedlist\", \"outdent\", \"indent\", \"format\", \"hr\", \"symbol\", \"inserttable\", \n            \"deletetable\"};\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Returns the value stored in this javascript object for the passed key.\n     * \n     * @param key the key whose value to return\n     * @return the value of the specified key.\n     */\n    public final native String get(String key)\n    /*-{\n        var value = this[key];\n        return value == null ? null : '' + value;\n    }-*/;","id":89618,"modified_method":"/**\n     * Returns the reference stored in this JavaScript object for the given key.\n     * \n     * @param key the key whose value to return\n     * @return the value of the specified key\n     */\n    public final native Object get(String key)\n    /*-{\n        return this[key];\n    }-*/;","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Builds the dialog to take data from the user for the creation of a link.\n     * \n     * @param currentWiki The name of current wiki.\n     * @param currentSpace The name of current space.\n     * @param currentPage The name of current page.\n     */\n    public LinkDialog(final String currentWiki, String currentSpace, String currentPage)\n    {\n        super(false, true);\n        LinkToWebPageTab linkToWebPageTab = new LinkToWebPageTab();\n        LinkToEmailAddressTab linkToEmailAddressTab = new LinkToEmailAddressTab();\n        LinkToNewPageTab linkToNewPageTab = new LinkToNewPageTab(currentWiki, currentSpace, currentPage);\n        LinkToExistingPageTab linkToExistingPageTab = new LinkToExistingPageTab(currentWiki, currentSpace, currentPage);\n\n        tabs = new TabPanel();\n        tabs.addTabListener(this);\n\n        addTab(linkToExistingPageTab, Strings.INSTANCE.linkExistingPageTab());        \n        addTab(linkToNewPageTab, Strings.INSTANCE.linkNewPageTab());\n        addTab(linkToWebPageTab, Strings.INSTANCE.linkWebPageTab());\n        addTab(linkToEmailAddressTab, Strings.INSTANCE.linkEmailTab());        \n\n        tabs.selectTab(0);\n        selectedTabIndex = 0;\n\n        getDialog().setText(Strings.INSTANCE.link());\n        getDialog().setAnimationEnabled(false);\n        getDialog().addStyleName(\"linkDialog\");\n\n        initWidget(tabs);\n\n        // set the initial label HTML to void string, as if no selection was made.\n        setLabel(\"\", \"\");\n    }","id":89619,"modified_method":"/**\n     * Builds the dialog to take data from the user for the creation of a link.\n     * \n     * @param currentWiki The name of current wiki.\n     * @param currentSpace The name of current space.\n     * @param currentPage The name of current page.\n     */\n    public LinkDialog(final String currentWiki, String currentSpace, String currentPage)\n    {\n        super(false, true);\n        LinkToWebPageTab linkToWebPageTab = new LinkToWebPageTab();\n        LinkToEmailAddressTab linkToEmailAddressTab = new LinkToEmailAddressTab();\n        LinkToNewPageTab linkToNewPageTab = new LinkToNewPageTab(currentWiki, currentSpace, currentPage);\n        LinkToExistingPageTab linkToExistingPageTab = new LinkToExistingPageTab(currentWiki, currentSpace, currentPage);\n\n        tabs = new TabPanel();\n        tabs.addTabListener(this);\n\n        addTab(linkToExistingPageTab, Strings.INSTANCE.linkExistingPageTab());        \n        addTab(linkToNewPageTab, Strings.INSTANCE.linkNewPageTab());\n        addTab(linkToWebPageTab, Strings.INSTANCE.linkWebPageTab());\n        addTab(linkToEmailAddressTab, Strings.INSTANCE.linkEmailTab());        \n\n        tabs.selectTab(0);\n        selectedTabIndex = 0;\n\n        getDialog().setText(Strings.INSTANCE.link());\n        getDialog().setAnimationEnabled(false);\n        getDialog().addStyleName(\"linkDialog\");\n\n        initWidget(tabs);\n\n        // set the initial label HTML to void string, as if no selection was made.\n        setLabel(\"\", \"\", false);\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Sets the label for the link created by this dialog. This label has an HTML form and a text form, the stripped\n     * version of the HTML version. If the text form is edited by the user, that label will be used, otherwise the HTML\n     * version, with formatting.\n     * \n     * @param labelHTML the HTML of the label for the created link.\n     * @param labelText the text of the label for the created link (stripped of HTML tags)\n     */\n    public void setLabel(String labelHTML, String labelText)\n    {\n        // pass the label to all the tabs in this dialog's tab panel\n        for (int i = 0; i < tabs.getWidgetCount(); i++) {\n            Widget tab = tabs.getWidget(i);\n            if (tab instanceof HasLink) {\n                ((HasLink) tab).setLabel(labelHTML, labelText);\n            }\n        }\n    }","id":89620,"modified_method":"/**\n     * Sets the label for the link created by this dialog. This label has an HTML form and a text form, the stripped\n     * version of the HTML version. If the text form is edited by the user, that label will be used, otherwise the HTML\n     * version, with formatting.\n     * \n     * @param labelHTML the HTML of the label for the created link.\n     * @param labelText the text of the label for the created link (stripped of HTML tags)\n     * @param readOnly specifies if the link label will be exposed as readonly to the user\n     */\n    public void setLabel(String labelHTML, String labelText, boolean readOnly)\n    {\n        // pass the label to all the tabs in this dialog's tab panel\n        for (int i = 0; i < tabs.getWidgetCount(); i++) {\n            Widget tab = tabs.getWidget(i);\n            if (tab instanceof HasLink) {\n                ((HasLink) tab).setLabel(labelHTML, labelText, readOnly);\n            }\n        }\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Depending on the passed parameter, the link dialog is displayed for the user to create a link or the created link\n     * is inserted in the document.\n     * \n     * @param show true if the link dialog must be shown, false otherwise\n     */\n    public void onLink(boolean show)\n    {\n        if (show) {\n            // save the selection\n            selectionPreserver.saveSelection();\n            // setup the dialog data\n            // use only the first range in the user selection\n            getLinkDialog().setLabel(getTextArea().getDocument().getSelection().getRangeAt(0).toHTML(),\n                getTextArea().getDocument().getSelection().getRangeAt(0).toString());\n            // show the dialog\n            getLinkDialog().center();\n        } else {\n            String url = getLinkDialog().getLink();\n            if (url != null) {\n                // restore selection to be sure to execute the command on the right selection, but don't reset the state\n                // of the preserver\n                selectionPreserver.restoreSelection(false);\n                getTextArea().getCommandManager().execute(Command.CREATE_LINK, url);\n            } else {\n                // We get here if the link dialog has been closed by clicking the close button.\n                // In this case we return the focus to the text area.\n                getTextArea().setFocus(true);\n            }\n            // restore the selection once again to select the inserted text or to have the initial selection back in\n            // place, this time resetting the state of the preserver.\n            selectionPreserver.restoreSelection();\n        }\n    }","id":89621,"modified_method":"/**\n     * Depending on the passed parameter, the link dialog is displayed for the user to create a link or the created link\n     * is inserted in the document.\n     * \n     * @param show true if the link dialog must be shown, false otherwise\n     */\n    public void onLink(boolean show)\n    {\n        if (show) {\n            // save the selection\n            selectionPreserver.saveSelection();\n            // setup the dialog data\n            // use only the first range in the user selection\n            // Check the special case when the selection is an image and add a link on an image\n            String imageParam =\n                (getTextArea().getCommandManager().getExecutable(Command.INSERT_IMAGE)).getParameter(getTextArea());\n            if (imageParam != null) {\n                // it's an image selection, set the label readonly and put the image filename in the label text\n                ImageConfig imgConfig = new ImageConfig();\n                imgConfig.fromJSON(imageParam);\n                getLinkDialog().setLabel(getTextArea().getDocument().getSelection().getRangeAt(0).toHTML(),\n                    imgConfig.getImageFileName(), true);\n            } else {\n                getLinkDialog().setLabel(getTextArea().getDocument().getSelection().getRangeAt(0).toHTML(),\n                    getTextArea().getDocument().getSelection().getRangeAt(0).toString(), false);\n            }\n            // show the dialog\n            getLinkDialog().center();\n        } else {\n            String url = getLinkDialog().getLink();\n            if (url != null) {\n                // restore selection to be sure to execute the command on the right selection, but don't reset the state\n                // of the preserver\n                selectionPreserver.restoreSelection(false);\n                getTextArea().getCommandManager().execute(Command.CREATE_LINK, url);\n            } else {\n                // We get here if the link dialog has been closed by clicking the close button.\n                // In this case we return the focus to the text area.\n                getTextArea().setFocus(true);\n            }\n            // restore the selection once again to select the inserted text or to have the initial selection back in\n            // place, this time resetting the state of the preserver.\n            selectionPreserver.restoreSelection();\n        }\n    }","commit_id":"ffc19036e7cb3e06734e25f1b72bcbb36d15b1a6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setFile(File file)\n    {\n        this.file = file;\n        setLabel(file.getName());\n    }","id":89622,"modified_method":"public void setFile(File file)\n    {\n        this.file = file;\n        if (file != null)\n            setLabel(file.getName());\n    }","commit_id":"de1757fb475664bebb1300b5a694d880ea04173b","url":"https://github.com/VUE/VUE"},{"original_method":"public void addViewer(MapViewer viewer)\n        {\n            Component c = viewer;\n            if (!this.name.startsWith(\"*\"))\n                c = new JScrollPane(viewer);\n            LWMap map = viewer.getMap();\n            addTab(map.getLabel(), c);\n            map.addLWCListener(this);\n            // todo perf: we should be able to ask to listen only\n            // for events from this object directly (that we don't\n            // care to hear from it's children), and even that\n            // we'd only like to see, e.g., LABEL events.\n            // -- create bit masks in LWCEvent\n            if (map.getFile() != null)\n                setToolTipTextAt(indexOfComponent(c), map.getFile().toString());\n        }","id":89623,"modified_method":"public void addViewer(MapViewer viewer)\n        {\n            Component c = viewer;\n            if (!this.name.startsWith(\"*\"))\n                c = new JScrollPane(viewer);\n            LWMap map = viewer.getMap();\n            addTab(mapToTabTitle(map), c);\n            map.addLWCListener(this);\n            // todo perf: we should be able to ask to listen only\n            // for events from this object directly (that we don't\n            // care to hear from it's children), and even that\n            // we'd only like to see, e.g., LABEL events.\n            // -- create bit masks in LWCEvent\n            if (map.getFile() != null)\n                setToolTipTextAt(indexOfComponent(c), map.getFile().toString());\n        }","commit_id":"de1757fb475664bebb1300b5a694d880ea04173b","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String[] args)\n    {\n        initUI();\n        \n        // loading preferences\n        prefs = java.util.prefs.Preferences.userRoot().node(\"/\");\n        try {\n            FileInputStream fis = new FileInputStream(getResource(VUE_CONF).getPath());\n            prefs.importPreferences(fis);\n        } catch (Exception e) { System.out.println(e);}\n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        mMapTabsLeft = new MapTabbedPane(\"*left\");\n        mMapTabsLeft.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsLeft.setPreferredSize(new Dimension(300,400));\n        \n        mMapTabsRight = new MapTabbedPane(\"right\");\n        mMapTabsRight.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsRight.setPreferredSize(new Dimension(300,400));\n\n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        //DRBrowser drBrowser = new DRBrowser();\n        DRBrowser drBrowser = null;\n        boolean nodr = (args.length > 0 && args[0].equals(\"-nodr\"));\n        if (!nodr)  {\n            try {\n                drBrowser = new DRBrowser();\n                toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                System.err.println(\"DR browser blowing up -- try another day.\");\n            }\n        } else {\n            //-------------------------------------------------------\n            // create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Test Nodes\");\n            //LWMap map2 = new LWMap(\"Example Map\");\n            //LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n\n            //installExampleNodes(map1);\n            installExampleMap(map2);\n\n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            //displayMap(map1);\n            displayMap(map2);\n        }\n        \n        // DEMO FIX:\n        // no lwinspector in left\n        //toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n\n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setRightComponent(mMapTabsRight);\n        // NOTE: set left component AFTER set right component -- the\n        // LAST set left/right call determines the default focus component!\n        // It needs to be the LEFT component as the right one isn't\n        // even visible at startup!\n        viewerSplit.setLeftComponent(mMapTabsLeft);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        //splitPane.setRightComponent(mMapTabsLeft);\n        splitPane.setRightComponent(viewerSplit);\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        \n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        \n        ToolWindow drBrowserTool  = new ToolWindow(\"DR Browser\", frame);\n        if (drBrowser != null)\n            drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = new ToolWindow( VueResources.getString(\"tbWindowName\"), frame);\n        VueToolbarController tbc = VueToolbarController.getController();\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n\n        boolean scottHack =\n            System.getProperty(\"user.name\").equals(\"sfraize\") &&\n            System.getProperty(\"scottHack\") != null;\n        // Need to factor some stuff out for the moment as has some bugs -- SMF 2003-12-29 21:32.39 Monday\n\n        if (!scottHack) ModelSelection.addListener(tbc);\n        \n        frame.getContentPane().add( tbc.getToolbar(), BorderLayout.NORTH);\n\t\t\n\t\t// Map Inspector\n\t\t\n\t\t// get the proper scree/main frame size\n\t\tToolWindow mapInspector = new ToolWindow(  VueResources.getString(\"mapInspectorTitle\"), frame);\n\t\tMapInspectorPanel mip = new MapInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener( mip);\n\t\tmapInspector.addTool( mip );\n\t\t\n\t\t//ToolWindow objectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspectorPanel = new ObjectInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener(objectInspectorPanel);\n\t\tsResourceSelection.addListener( objectInspectorPanel);\n\t\tobjectInspector.addTool(objectInspectorPanel);\n\t\t\n\t\t\n\t\tif( false) {\n\t\t\tJFrame testFrame = new JFrame(\"Debug\");\n\t\t\ttestFrame.setSize( 300,300);\n\t\t\t//testFrame.getContentPane().add( new NodeInspectorPanel() );\n\t\t\ttestFrame.getContentPane().add(objectInspectorPanel);\n\t\t\ttestFrame.show();\n\t\t}\n\t\t\n\t\t\n        //addtion by the power team\n        pathwayInspector = new LWPathwayInspector(frame);\n        //control = new PathwayControl(frame);\n        \n        //hierarchyTree = new LWHierarchyTree(frame);\n        hierarchyTree = new LWHierarchyTree();\n        ToolWindow htWindow = new ToolWindow(\"Hierarchy Tree\", frame);\n        htWindow.addTool(hierarchyTree);\n\n        outlineView = new LWOutlineView(frame);\n        //end of addition\n       \n        Window[] toolWindows = {\n            toolbarWindow,\n            pannerTool,\n            inspectorTool,\n            drBrowserTool,\n            pathwayInspector,\n            htWindow,\n            //hierarchyTree,\n            mapInspector,\n            objectInspector,\n            outlineView,\n        };\n        \n        // adding the menus and toolbars\n        setMenuToolbars(frame, toolWindows);\n        System.out.println(\"after setting menu toolbars...\");\n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        VueUtil.centerOnScreen(frame);\n        \n        // position inspectors pased on frame location\n        int inspectorx = frame.getX() + frame.getWidth() - mapInspector.getWidth();\n        mapInspector.setLocation( inspectorx, frame.getY());\n        objectInspector.setLocation( inspectorx, frame.getY() + mapInspector.getHeight() );\n        \n        frame.addWindowListener(new WindowAdapter() {\n                public void windowClosing(WindowEvent e) {\n                    System.out.println(e);\n                    ExitAction.exitVue();\n\n                    //-------------------------------------------------------\n                    // if we get here, it means exit was aborted.\n                    // (something wasn't saved & they decided to cancel or\n                    // there was an error during the save)\n                    //-------------------------------------------------------\n\n                    //frame.show();\n                    // not working!  How to cancel this windowClose?\n                    // According to WindowEvent.java &\n                    // WindowAdapter.java, canceling this\n                    // windowClosing is supposed to be possible, but\n                    // they don't mention how. Anyway, we've overriden\n                    // setVisible on VueFrame to make it impossible to\n                    // hide it, and that works, so this event just\n                    // becomes the they've pressed on the close button\n                    // event.\n                    \n                    return;\n                }\n                public void windowClosed(WindowEvent e) {\n                    // I've never see us even get this event...\n                    System.err.println(e);\n                    System.err.println(\"Too late: window disposed: exiting.\");\n                    System.exit(-1);\n                }\n                public void windowStateChanged(WindowEvent e) {\n                    System.out.println(e);\n                }\n            });\n\n        /*\n        frame.addComponentListener(new ComponentAdapter() {\n                public void componentShown(ComponentEvent e) { System.out.println(e); }\n                public void componentHidden(ComponentEvent e) { System.out.println(e); frame.show(); }\n            });\n        \n        */\n        frame.show();\n        System.out.println(\"after showing frame...\");\n        if (args.length > 0) {\n            try {\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    VUE.activateWaitCursor();\n                    LWMap map = OpenAction.loadMap(args[i]);\n                    if (map != null)\n                        displayMap(map);\n                }\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n        \n        if (!nodr) {\n            try {\n                OpenAction.displayMap(new File(VueResources.getURL(\"resource.startmap\").getFile()));// this will be loaded using vue resourece\n            } catch(Exception ex) {\n                VueUtil.alert(null, \"Cannot load the Start up map\", \"Start Up Map Error\");\n                ex.printStackTrace();\n            }\n        }            \n        //setViewerScrollbarsDisplayed(true);\n        System.out.println(\"VUE.main: loading fonts...\");\n        FontEditorPanel.getFontNames();\n        System.out.println(\"VUE.main completed.\");\n    }","id":89624,"modified_method":"public static void main(String[] args)\n    {\n        initUI();\n        \n        // loading preferences\n        prefs = java.util.prefs.Preferences.userRoot().node(\"/\");\n        try {\n            FileInputStream fis = new FileInputStream(getResource(VUE_CONF).getPath());\n            prefs.importPreferences(fis);\n        } catch (Exception e) { System.out.println(e);}\n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        mMapTabsLeft = new MapTabbedPane(\"*left\");\n        mMapTabsLeft.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsLeft.setPreferredSize(new Dimension(300,400));\n        \n        mMapTabsRight = new MapTabbedPane(\"right\");\n        mMapTabsRight.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsRight.setPreferredSize(new Dimension(300,400));\n\n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        //DRBrowser drBrowser = new DRBrowser();\n        DRBrowser drBrowser = null;\n        boolean nodr = (args.length > 0 && args[0].equals(\"-nodr\"));\n        if (!nodr)  {\n            try {\n                drBrowser = new DRBrowser();\n                toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                System.err.println(\"DR browser blowing up -- try another day.\");\n            }\n        } else {\n            //-------------------------------------------------------\n            // create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Test Nodes\");\n            //LWMap map2 = new LWMap(\"Example Map\");\n            //LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n\n            //installExampleNodes(map1);\n            installExampleMap(map2);\n\n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            //displayMap(map1);\n            displayMap(map2);\n        }\n        \n        // DEMO FIX:\n        // no lwinspector in left\n        //toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n\n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setRightComponent(mMapTabsRight);\n        // NOTE: set left component AFTER set right component -- the\n        // LAST set left/right call determines the default focus component!\n        // It needs to be the LEFT component as the right one isn't\n        // even visible at startup!\n        viewerSplit.setLeftComponent(mMapTabsLeft);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        //splitPane.setRightComponent(mMapTabsLeft);\n        splitPane.setRightComponent(viewerSplit);\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        \n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        \n        ToolWindow drBrowserTool  = new ToolWindow(\"DR Browser\", frame);\n        if (drBrowser != null)\n            drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = new ToolWindow( VueResources.getString(\"tbWindowName\"), frame);\n        VueToolbarController tbc = VueToolbarController.getController();\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n\n        boolean scottHack =\n            System.getProperty(\"user.name\").equals(\"sfraize\") &&\n            System.getProperty(\"scottHack\") != null;\n        // Need to factor some stuff out for the moment as has some bugs -- SMF 2003-12-29 21:32.39 Monday\n\n        if (!scottHack) ModelSelection.addListener(tbc);\n        \n        frame.getContentPane().add( tbc.getToolbar(), BorderLayout.NORTH);\n\t\t\n\t\t// Map Inspector\n\t\t\n\t\t// get the proper scree/main frame size\n\t\tToolWindow mapInspector = new ToolWindow(  VueResources.getString(\"mapInspectorTitle\"), frame);\n\t\tMapInspectorPanel mip = new MapInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener( mip);\n\t\tmapInspector.addTool( mip );\n\t\t\n\t\t//ToolWindow objectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspector = new ToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n\t\tobjectInspectorPanel = new ObjectInspectorPanel();\n\t\tif (!scottHack) ModelSelection.addListener(objectInspectorPanel);\n\t\tsResourceSelection.addListener( objectInspectorPanel);\n\t\tobjectInspector.addTool(objectInspectorPanel);\n\t\t\n\t\t\n\t\tif( false) {\n\t\t\tJFrame testFrame = new JFrame(\"Debug\");\n\t\t\ttestFrame.setSize( 300,300);\n\t\t\t//testFrame.getContentPane().add( new NodeInspectorPanel() );\n\t\t\ttestFrame.getContentPane().add(objectInspectorPanel);\n\t\t\ttestFrame.show();\n\t\t}\n\t\t\n\t\t\n        //addtion by the power team\n        pathwayInspector = new LWPathwayInspector(frame);\n        //control = new PathwayControl(frame);\n        \n        //hierarchyTree = new LWHierarchyTree(frame);\n        hierarchyTree = new LWHierarchyTree();\n        ToolWindow htWindow = new ToolWindow(\"Hierarchy Tree\", frame);\n        htWindow.addTool(hierarchyTree);\n\n        outlineView = new LWOutlineView(frame);\n        //end of addition\n       \n        Window[] toolWindows = {\n            toolbarWindow,\n            pannerTool,\n            inspectorTool,\n            drBrowserTool,\n            pathwayInspector,\n            htWindow,\n            //hierarchyTree,\n            mapInspector,\n            objectInspector,\n            outlineView,\n        };\n        \n        // adding the menus and toolbars\n        setMenuToolbars(frame, toolWindows);\n        System.out.println(\"after setting menu toolbars...\");\n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        VueUtil.centerOnScreen(frame);\n        \n        // position inspectors pased on frame location\n        int inspectorx = frame.getX() + frame.getWidth() - mapInspector.getWidth();\n        mapInspector.setLocation( inspectorx, frame.getY());\n        objectInspector.setLocation( inspectorx, frame.getY() + mapInspector.getHeight() );\n        \n        frame.addWindowListener(new WindowAdapter() {\n                public void windowClosing(WindowEvent e) {\n                    System.out.println(e);\n                    ExitAction.exitVue();\n\n                    //-------------------------------------------------------\n                    // if we get here, it means exit was aborted.\n                    // (something wasn't saved & they decided to cancel or\n                    // there was an error during the save)\n                    //-------------------------------------------------------\n\n                    //frame.show();\n                    // not working!  How to cancel this windowClose?\n                    // According to WindowEvent.java &\n                    // WindowAdapter.java, canceling this\n                    // windowClosing is supposed to be possible, but\n                    // they don't mention how. Anyway, we've overriden\n                    // setVisible on VueFrame to make it impossible to\n                    // hide it, and that works, so this event just\n                    // becomes the they've pressed on the close button\n                    // event.\n                    \n                    return;\n                }\n                public void windowClosed(WindowEvent e) {\n                    // I've never see us even get this event...\n                    System.err.println(e);\n                    System.err.println(\"Too late: window disposed: exiting.\");\n                    System.exit(-1);\n                }\n                public void windowStateChanged(WindowEvent e) {\n                    System.out.println(e);\n                }\n            });\n\n        /*\n        frame.addComponentListener(new ComponentAdapter() {\n                public void componentShown(ComponentEvent e) { System.out.println(e); }\n                public void componentHidden(ComponentEvent e) { System.out.println(e); frame.show(); }\n            });\n        \n        */\n        frame.show();\n        System.out.println(\"after showing frame...\");\n        if (args.length > 0) {\n            try {\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    VUE.activateWaitCursor();\n                    LWMap map = OpenAction.loadMap(args[i]);\n                    if (map != null)\n                        displayMap(map);\n                }\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n        \n        if (!nodr) {\n            try {\n                File startupFile = new File(VueResources.getURL(\"resource.startmap\").getFile());\n                LWMap startupMap = OpenAction.loadMap(startupFile.getAbsolutePath());\n                startupMap.setFile(null); // dissasociate startup map from it's file so we don't write over it\n                startupMap.setLabel(\"Welcome\");\n                displayMap(startupMap);\n            } catch(Exception ex) {\n                VueUtil.alert(null, \"Cannot load the Start up map\", \"Start Up Map Error\");\n                ex.printStackTrace();\n            }\n        }            \n        //setViewerScrollbarsDisplayed(true);\n        System.out.println(\"VUE.main: loading fonts...\");\n        FontEditorPanel.getFontNames();\n        System.out.println(\"VUE.main completed.\");\n    }","commit_id":"de1757fb475664bebb1300b5a694d880ea04173b","url":"https://github.com/VUE/VUE"},{"original_method":"public void LWCChanged(LWCEvent e)\n        {\n            LWComponent c = e.getComponent();\n            if (c instanceof LWMap && e.getWhat().equals(\"label\")) {\n                //System.out.println(\"MapTabbedPane \" + e);\n                LWMap map = (LWMap) c;\n                int i = findTabWithMap(map);\n                if (i >= 0) {\n                    setTitleAt(i, c.getLabel());\n                    if (map.getFile() != null)\n                        setToolTipTextAt(i, map.getFile().toString());\n                }\n            }\n        }","id":89625,"modified_method":"public void LWCChanged(LWCEvent e)\n        {\n            LWComponent c = e.getComponent();\n            if (c instanceof LWMap && e.getWhat().equals(\"label\")) {\n                //System.out.println(\"MapTabbedPane \" + e);\n                LWMap map = (LWMap) c;\n                int i = findTabWithMap(map);\n                if (i >= 0) {\n                    setTitleAt(i, mapToTabTitle(map));\n                    if (map.getFile() != null)\n                        setToolTipTextAt(i, map.getFile().toString());\n                }\n            }\n        }","commit_id":"de1757fb475664bebb1300b5a694d880ea04173b","url":"https://github.com/VUE/VUE"},{"original_method":"public void getFIBMCMCScores(HashMap publishedItemHash, HashMap publishedAnswerHash, \n    ArrayList scores, HistogramQuestionScoresBean qbean, ArrayList answers)\n  {\n    HashMap texts = new HashMap();\n    Iterator iter = answers.iterator();\n    HashMap results = new HashMap();\n    HashMap numStudentRespondedMap= new HashMap();   \n    while (iter.hasNext())\n    {\n      AnswerIfc answer = (AnswerIfc) iter.next();\n      texts.put(answer.getId(), answer);\n      results.put(answer.getId(), new Integer(0));\n    }\n    iter = scores.iterator();\n    while (iter.hasNext())\n    {\n      ItemGradingData data = (ItemGradingData) iter.next();\n      AnswerIfc answer = (AnswerIfc) publishedAnswerHash.get(data.getPublishedAnswerId());\n      if (answer != null)\n      {\n        //log.info(\"Rachel: looking for \" + answer.getId());\n        // found a response\n        Integer num = null;\n        // num is a counter\n        try {\n        // we found a response, now get existing count from the hashmap\n          num = (Integer) results.get(answer.getId());\n\n\n        } catch (Exception e) {\n          log.info(\"No results for \" + answer.getId());\n        }\n        if (num == null)\n          num = new Integer(0);\n\n    \t  ArrayList studentResponseList = (ArrayList)numStudentRespondedMap.get(data.getAssessmentGrading().getAssessmentGradingId());\n          if (studentResponseList==null) {\n    \t    studentResponseList = new ArrayList();\n          }\n          studentResponseList.add(data);\n          numStudentRespondedMap.put(data.getAssessmentGrading().getAssessmentGradingId(), studentResponseList);\n        // we found a response, and got the  existing num , now update one\n        if (qbean.getQuestionType().equals(\"8\"))\n        {\n          // for fib we only count the number of correct responses \n          Float autoscore = data.getAutoScore();\n          if (!(new Float(0)).equals(autoscore)) {\n            results.put(answer.getId(), new Integer(num.intValue() + 1));\n          }\n        }\n        else {  \n          // for mc, we count the number of all responses \n          results.put(answer.getId(), new Integer(num.intValue() + 1));\n        }\n      }\n    }\n    HistogramBarBean[] bars = new HistogramBarBean[results.keySet().size()];\n    int[] numarray = new int[results.keySet().size()];\n    iter = results.keySet().iterator();\n    int i = 0;\n    int responses = 0;\n    int correctresponses = 0;\n    while (iter.hasNext())\n    {\n      Long answerId = (Long) iter.next();\n      AnswerIfc answer = (AnswerIfc) texts.get(answerId);\n      int num = ((Integer) results.get(answerId)).intValue();\n      numarray[i] = num;\n      bars[i] = new HistogramBarBean();\n      bars[i].setLabel(answer.getText());\n\n      // this doens't not apply to fib , do not show checkmarks for FIB\n\tif (!qbean.getQuestionType().equals(\"8\"))\n      \t{\n\t  bars[i].setIsCorrect(answer.getIsCorrect());\n        }\n\n\n\tif ((num>1)||(num==0))\n          {\n              bars[i].setNumStudentsText(num + \" Responses\");\n          }\n      else\n          {\n              bars[i].setNumStudentsText(num + \" Response\");\n\n      }\n      bars[i].setNumStudents(num);\n      i++;\n    }\n\n\n    responses = numStudentRespondedMap.size();\n    Iterator mapiter = numStudentRespondedMap.keySet().iterator();\n    while (mapiter.hasNext())\n    {\n      Long assessmentGradingId= (Long)mapiter.next();\n      ArrayList resultsForOneStudent = (ArrayList)numStudentRespondedMap.get(assessmentGradingId);\n      boolean hasIncorrect = false;\n      Iterator listiter = resultsForOneStudent.iterator();\n      while (listiter.hasNext())\n      {\n        ItemGradingData item = (ItemGradingData)listiter.next();\n\tif (qbean.getQuestionType().equals(\"8\"))\n\t{\n          Float autoscore = item.getAutoScore();\n          if (!(new Float(0)).equals(autoscore)) {\n            hasIncorrect = true;\n            break;\n          }\n        }\n\telse if (qbean.getQuestionType().equals(\"2\"))\n      \t{\n\n\t  // only answered choices are created in the ItemGradingData_T, so we need to check\n\t  // if # of checkboxes the student checked is == the number of correct answers\n\t  // otherwise if a student only checked one of the multiple correct answers,\n\t  // it would count as a correct response\n\n          try {\n\t    ArrayList itemTextArray = ((ItemDataIfc)publishedItemHash.get(item.getPublishedItemId())).getItemTextArraySorted();\n    \t    ArrayList answerArray = ((ItemTextIfc)itemTextArray.get(0)).getAnswerArraySorted();\n\n            int corranswers = 0;\n            Iterator answeriter = answerArray.iterator();\n            while (answeriter.hasNext()){\n\t      AnswerIfc answerchoice = (AnswerIfc) answeriter.next();\n              if (answerchoice.getIsCorrect().booleanValue()){\n\t\tcorranswers++;\n\t      }\n            }\n            if (resultsForOneStudent.size() !=  corranswers){\n              hasIncorrect = true;\n              break;\n            }\n          }\n          catch (Exception e) {\n\t    e.printStackTrace();\n            throw new RuntimeException(\"error calculating mcmc question.\");\n\t  }\n\n          // now check each answer in MCMC \n\n          AnswerIfc answer = (AnswerIfc) publishedAnswerHash.get(item.getPublishedAnswerId());\n\t  if (answer.getIsCorrect() == null || (!answer.getIsCorrect().booleanValue()))\n  \t  {\n            hasIncorrect = true;\n            break;\n \t  }\n        }\n      }\n      if (!hasIncorrect) {\n        correctresponses = correctresponses + 1;\n      }\n    }\n    //NEW\n    System.out.println(\"NUMBER OF RESPONSEDS IN getFIBMCMCScores IS: \"+ responses);\n    int[] heights = calColumnHeight(numarray,responses);\n    // int[] heights = calColumnHeight(numarray);\n    for (i=0; i<bars.length; i++)\n      bars[i].setColumnHeight(new Integer(heights[i]).toString());\n    qbean.setHistogramBars(bars);\n    qbean.setNumResponses(responses);\n    if (responses > 0)\n      qbean.setPercentCorrect(new Integer((int)(((float) correctresponses/(float) responses) * 100)).toString());\n  }","id":89626,"modified_method":"public void getFIBMCMCScores(HashMap publishedItemHash, HashMap publishedAnswerHash, \n    ArrayList scores, HistogramQuestionScoresBean qbean, ArrayList answers)\n  {\n    HashMap texts = new HashMap();\n    Iterator iter = answers.iterator();\n    HashMap results = new HashMap();\n    HashMap numStudentRespondedMap= new HashMap();   \n    while (iter.hasNext())\n    {\n      AnswerIfc answer = (AnswerIfc) iter.next();\n      texts.put(answer.getId(), answer);\n      results.put(answer.getId(), new Integer(0));\n    }\n    iter = scores.iterator();\n    while (iter.hasNext())\n    {\n      ItemGradingData data = (ItemGradingData) iter.next();\n      AnswerIfc answer = (AnswerIfc) publishedAnswerHash.get(data.getPublishedAnswerId());\n      if (answer != null)\n      {\n        //log.info(\"Rachel: looking for \" + answer.getId());\n        // found a response\n        Integer num = null;\n        // num is a counter\n        try {\n        // we found a response, now get existing count from the hashmap\n          num = (Integer) results.get(answer.getId());\n\n\n        } catch (Exception e) {\n          log.info(\"No results for \" + answer.getId());\n        }\n        if (num == null)\n          num = new Integer(0);\n\n    \t  ArrayList studentResponseList = (ArrayList)numStudentRespondedMap.get(data.getAssessmentGrading().getAssessmentGradingId());\n          if (studentResponseList==null) {\n    \t    studentResponseList = new ArrayList();\n          }\n          studentResponseList.add(data);\n          numStudentRespondedMap.put(data.getAssessmentGrading().getAssessmentGradingId(), studentResponseList);\n        // we found a response, and got the  existing num , now update one\n        if (qbean.getQuestionType().equals(\"8\"))\n        {\n          // for fib we only count the number of correct responses \n          Float autoscore = data.getAutoScore();\n          if (!(new Float(0)).equals(autoscore)) {\n            results.put(answer.getId(), new Integer(num.intValue() + 1));\n          }\n        }\n        else {  \n          // for mc, we count the number of all responses \n          results.put(answer.getId(), new Integer(num.intValue() + 1));\n        }\n      }\n    }\n    HistogramBarBean[] bars = new HistogramBarBean[results.keySet().size()];\n    int[] numarray = new int[results.keySet().size()];\n    iter = results.keySet().iterator();\n    int i = 0;\n    int responses = 0;\n    int correctresponses = 0;\n    while (iter.hasNext())\n    {\n      Long answerId = (Long) iter.next();\n      AnswerIfc answer = (AnswerIfc) texts.get(answerId);\n      int num = ((Integer) results.get(answerId)).intValue();\n      numarray[i] = num;\n      bars[i] = new HistogramBarBean();\n      if(answer != null)\n      \tbars[i].setLabel(answer.getText());\n\n      // this doens't not apply to fib , do not show checkmarks for FIB\n    \tif (!qbean.getQuestionType().equals(\"8\") && answer != null)\n      \t{\n\t  bars[i].setIsCorrect(answer.getIsCorrect());\n        }\n\n\n\tif ((num>1)||(num==0))\n          {\n              bars[i].setNumStudentsText(num + \" Responses\");\n          }\n      else\n          {\n              bars[i].setNumStudentsText(num + \" Response\");\n\n      }\n      bars[i].setNumStudents(num);\n      i++;\n    }\n\n\n    responses = numStudentRespondedMap.size();\n    Iterator mapiter = numStudentRespondedMap.keySet().iterator();\n    while (mapiter.hasNext())\n    {\n      Long assessmentGradingId= (Long)mapiter.next();\n      ArrayList resultsForOneStudent = (ArrayList)numStudentRespondedMap.get(assessmentGradingId);\n      boolean hasIncorrect = false;\n      Iterator listiter = resultsForOneStudent.iterator();\n      while (listiter.hasNext())\n      {\n        ItemGradingData item = (ItemGradingData)listiter.next();\n\tif (qbean.getQuestionType().equals(\"8\"))\n\t{\n          Float autoscore = item.getAutoScore();\n          if (!(new Float(0)).equals(autoscore)) {\n            hasIncorrect = true;\n            break;\n          }\n        }\n\telse if (qbean.getQuestionType().equals(\"2\"))\n      \t{\n\n\t  // only answered choices are created in the ItemGradingData_T, so we need to check\n\t  // if # of checkboxes the student checked is == the number of correct answers\n\t  // otherwise if a student only checked one of the multiple correct answers,\n\t  // it would count as a correct response\n\n          try {\n\t    ArrayList itemTextArray = ((ItemDataIfc)publishedItemHash.get(item.getPublishedItemId())).getItemTextArraySorted();\n    \t    ArrayList answerArray = ((ItemTextIfc)itemTextArray.get(0)).getAnswerArraySorted();\n\n            int corranswers = 0;\n            Iterator answeriter = answerArray.iterator();\n            while (answeriter.hasNext()){\n\t      AnswerIfc answerchoice = (AnswerIfc) answeriter.next();\n              if (answerchoice.getIsCorrect().booleanValue()){\n\t\tcorranswers++;\n\t      }\n            }\n            if (resultsForOneStudent.size() !=  corranswers){\n              hasIncorrect = true;\n              break;\n            }\n          }\n          catch (Exception e) {\n\t    e.printStackTrace();\n            throw new RuntimeException(\"error calculating mcmc question.\");\n\t  }\n\n          // now check each answer in MCMC \n\n          AnswerIfc answer = (AnswerIfc) publishedAnswerHash.get(item.getPublishedAnswerId());\n      \t  if ( answer != null && (answer.getIsCorrect() == null || (!answer.getIsCorrect().booleanValue())))\n  \t  {\n            hasIncorrect = true;\n            break;\n \t  }\n        }\n      }\n      if (!hasIncorrect) {\n        correctresponses = correctresponses + 1;\n      }\n    }\n    //NEW\n    System.out.println(\"NUMBER OF RESPONSEDS IN getFIBMCMCScores IS: \"+ responses);\n    int[] heights = calColumnHeight(numarray,responses);\n    // int[] heights = calColumnHeight(numarray);\n    for (i=0; i<bars.length; i++)\n      bars[i].setColumnHeight(new Integer(heights[i]).toString());\n    qbean.setHistogramBars(bars);\n    qbean.setNumResponses(responses);\n    if (responses > 0)\n      qbean.setPercentCorrect(new Integer((int)(((float) correctresponses/(float) responses) * 100)).toString());\n  }","commit_id":"8e114717688ea64425e9ee0f7c88c818731e191b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {\n        boolean exists = super.existsProperty(pexp, checkForReadOnly, visitor);\n        if (exists) {\n            Expression objectExpression = pexp.getObjectExpression();\n            ClassNode objectExpressionType = getType(objectExpression);\n            if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(objectExpressionType, ClassHelper.LIST_TYPE)) {\n                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.int_TYPE));\n            }\n        }\n        return exists;\n    }","id":89627,"modified_method":"@Override\n    protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {\n        Expression objectExpression = pexp.getObjectExpression();\n        ClassNode objectExpressionType = getType(objectExpression);\n        final Reference<ClassNode> rType = new Reference<ClassNode>(objectExpressionType);\n        ClassCodeVisitorSupport receiverMemoizer = new ClassCodeVisitorSupport() {\n            @Override\n            protected SourceUnit getSourceUnit() {\n                return null;\n            }\n\n            public void visitField(final FieldNode node) {\n                if (visitor!=null) visitor.visitField(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n\n            public void visitMethod(final MethodNode node) {\n                if (visitor!=null) visitor.visitMethod(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n\n            @Override\n            public void visitProperty(final PropertyNode node) {\n                if (visitor!=null) visitor.visitProperty(node);\n                ClassNode declaringClass = node.getDeclaringClass();\n                if (declaringClass!=null) rType.set(declaringClass);\n            }\n        };\n        boolean exists = super.existsProperty(pexp, checkForReadOnly, receiverMemoizer);\n        if (exists) {\n            objectExpression.putNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER, rType.get());\n            if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(objectExpressionType, ClassHelper.LIST_TYPE)) {\n                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.int_TYPE));\n            }\n        }\n        return exists;\n    }","commit_id":"740ae7c25684d52d531b98aca4a0dd3c939d0bd6","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void makeGetPropertySite(Expression receiver, final String methodName, final boolean safe, final boolean implicitThis) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode receiverType = typeChooser.resolveType(receiver, classNode);\n        Object type = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (type==null && receiver instanceof VariableExpression) {\n            Variable variable = ((VariableExpression) receiver).getAccessedVariable();\n            if (variable instanceof Expression) {\n                type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n            }\n        }\n        if (type!=null) {\n            // in case a \"flow type\" is found, it is preferred to use it instead of\n            // the declaration type\n            receiverType = (ClassNode) type;\n        }\n        boolean isClassReceiver = false;\n        if (receiverType.equals(CLASS_Type)\n                && receiverType.getGenericsTypes()!=null\n                && !receiverType.getGenericsTypes()[0].isPlaceholder()) {\n            isClassReceiver = true;\n            receiverType = receiverType.getGenericsTypes()[0].getType();\n        }\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        if (receiverType.isArray() && methodName.equals(\"length\")) {\n            receiver.visit(controller.getAcg());\n            ClassNode arrayGetReturnType = typeChooser.resolveType(receiver, classNode);\n            controller.getOperandStack().doGroovyCast(arrayGetReturnType);\n            mv.visitInsn(ARRAYLENGTH);\n            controller.getOperandStack().replace(int_TYPE);\n            return;\n        } else if (\n                (receiverType.implementsInterface(COLLECTION_TYPE)\n                        || COLLECTION_TYPE.equals(receiverType)) && (\"size\".equals(methodName) || \"length\".equals(methodName))) {\n            MethodCallExpression expr = new MethodCallExpression(\n                    receiver,\n                    \"size\",\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            expr.setMethodTarget(COLLECTION_SIZE_METHOD);\n            expr.setImplicitThis(implicitThis);\n            expr.setSafe(safe);\n            expr.visit(controller.getAcg());\n            return;\n        }\n        if (makeGetPropertyWithGetter(receiver, receiverType, methodName, safe, implicitThis)) return;\n        if (makeGetField(receiver, receiverType, methodName, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;\n        if (receiverType.isEnum()) {\n            mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(receiverType), methodName, BytecodeHelper.getTypeDescription(receiverType));\n            controller.getOperandStack().push(receiverType);\n            return;\n        }\n        if (receiver instanceof ClassExpression) {\n            if (makeGetField(receiver, receiver.getType(), methodName, implicitThis, samePackages(receiver.getType().getPackageName(), classNode.getPackageName()))) return;\n            if (makeGetPropertyWithGetter(receiver, receiver.getType(), methodName, safe, implicitThis)) return;\n            if (makeGetPrivateFieldWithBridgeMethod(receiver, receiver.getType(), methodName, safe, implicitThis)) return;\n        }\n        if (isClassReceiver) {\n            // we are probably looking for a property of the class\n            if (makeGetPropertyWithGetter(receiver, CLASS_Type, methodName, safe, implicitThis)) return;\n            if (makeGetField(receiver, CLASS_Type, methodName, false, true)) return;\n        }\n        if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, methodName, safe, implicitThis)) return;\n\n        // GROOVY-5580, it is still possible that we're calling a superinterface property\n        String getterName = \"get\" + MetaClassHelper.capitalize(methodName);\n        if (receiverType.isInterface()) {\n            Set<ClassNode> allInterfaces = receiverType.getAllInterfaces();\n            MethodNode getterMethod = null;\n            for (ClassNode anInterface : allInterfaces) {\n                getterMethod = anInterface.getGetterMethod(getterName);\n                if (getterMethod!=null) break;\n            }\n            // GROOVY-5585\n            if (getterMethod==null) {\n                getterMethod = OBJECT_TYPE.getGetterMethod(getterName);\n            }\n\n            if (getterMethod!=null) {\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getterMethod);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n\n        }\n\n        // GROOVY-5568, we would be facing a DGM call, but instead of foo.getText(), have foo.text\n        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, getterName, ClassNode.EMPTY_ARRAY);\n        if (!methods.isEmpty()) {\n            List<MethodNode> methodNodes = chooseBestMethod(receiverType, methods, ClassNode.EMPTY_ARRAY);\n            if (methodNodes.size()==1) {\n                MethodNode getter = methodNodes.get(0);\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getter);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n        }\n\n        boolean isStaticProperty = receiver instanceof ClassExpression\n                && (receiverType.isDerivedFrom(receiver.getType()) || receiverType.implementsInterface(receiver.getType()));\n\n        if (!isStaticProperty) {\n            if (receiverType.implementsInterface(MAP_TYPE) || MAP_TYPE.equals(receiverType)) {\n                // for maps, replace map.foo with map.get('foo')\n                writeMapDotProperty(receiver, methodName, mv);\n                return;\n            }\n            if (receiverType.implementsInterface(LIST_TYPE) || LIST_TYPE.equals(receiverType)) {\n                writeListDotProperty(receiver, methodName, mv);\n                return;\n            }\n        }\n\n\n        controller.getSourceUnit().addError(\n                new SyntaxException(\"Access to \"+\n                                                (receiver instanceof ClassExpression ?receiver.getType():receiverType).toString(false)\n                                                +\"#\"+methodName+\" is forbidden\", receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber())\n        );\n        controller.getMethodVisitor().visitInsn(ACONST_NULL);\n        controller.getOperandStack().push(OBJECT_TYPE);\n    }","id":89628,"modified_method":"@Override\n    public void makeGetPropertySite(Expression receiver, final String methodName, final boolean safe, final boolean implicitThis) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode receiverType = (ClassNode) receiver.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);\n        if (receiverType==null) {\n            receiverType = typeChooser.resolveType(receiver, classNode);\n        }\n        Object type = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (type==null && receiver instanceof VariableExpression) {\n            Variable variable = ((VariableExpression) receiver).getAccessedVariable();\n            if (variable instanceof Expression) {\n                type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n            }\n        }\n        if (type!=null) {\n            // in case a \"flow type\" is found, it is preferred to use it instead of\n            // the declaration type\n            receiverType = (ClassNode) type;\n        }\n        boolean isClassReceiver = false;\n        if (receiverType.equals(CLASS_Type)\n                && receiverType.getGenericsTypes()!=null\n                && !receiverType.getGenericsTypes()[0].isPlaceholder()) {\n            isClassReceiver = true;\n            receiverType = receiverType.getGenericsTypes()[0].getType();\n        }\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        if (receiverType.isArray() && methodName.equals(\"length\")) {\n            receiver.visit(controller.getAcg());\n            ClassNode arrayGetReturnType = typeChooser.resolveType(receiver, classNode);\n            controller.getOperandStack().doGroovyCast(arrayGetReturnType);\n            mv.visitInsn(ARRAYLENGTH);\n            controller.getOperandStack().replace(int_TYPE);\n            return;\n        } else if (\n                (receiverType.implementsInterface(COLLECTION_TYPE)\n                        || COLLECTION_TYPE.equals(receiverType)) && (\"size\".equals(methodName) || \"length\".equals(methodName))) {\n            MethodCallExpression expr = new MethodCallExpression(\n                    receiver,\n                    \"size\",\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            expr.setMethodTarget(COLLECTION_SIZE_METHOD);\n            expr.setImplicitThis(implicitThis);\n            expr.setSafe(safe);\n            expr.visit(controller.getAcg());\n            return;\n        }\n        if (makeGetPropertyWithGetter(receiver, receiverType, methodName, safe, implicitThis)) return;\n        if (makeGetField(receiver, receiverType, methodName, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;\n        if (receiverType.isEnum()) {\n            mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(receiverType), methodName, BytecodeHelper.getTypeDescription(receiverType));\n            controller.getOperandStack().push(receiverType);\n            return;\n        }\n        if (receiver instanceof ClassExpression) {\n            if (makeGetField(receiver, receiver.getType(), methodName, implicitThis, samePackages(receiver.getType().getPackageName(), classNode.getPackageName()))) return;\n            if (makeGetPropertyWithGetter(receiver, receiver.getType(), methodName, safe, implicitThis)) return;\n            if (makeGetPrivateFieldWithBridgeMethod(receiver, receiver.getType(), methodName, safe, implicitThis)) return;\n        }\n        if (isClassReceiver) {\n            // we are probably looking for a property of the class\n            if (makeGetPropertyWithGetter(receiver, CLASS_Type, methodName, safe, implicitThis)) return;\n            if (makeGetField(receiver, CLASS_Type, methodName, false, true)) return;\n        }\n        if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, methodName, safe, implicitThis)) return;\n\n        // GROOVY-5580, it is still possible that we're calling a superinterface property\n        String getterName = \"get\" + MetaClassHelper.capitalize(methodName);\n        if (receiverType.isInterface()) {\n            Set<ClassNode> allInterfaces = receiverType.getAllInterfaces();\n            MethodNode getterMethod = null;\n            for (ClassNode anInterface : allInterfaces) {\n                getterMethod = anInterface.getGetterMethod(getterName);\n                if (getterMethod!=null) break;\n            }\n            // GROOVY-5585\n            if (getterMethod==null) {\n                getterMethod = OBJECT_TYPE.getGetterMethod(getterName);\n            }\n\n            if (getterMethod!=null) {\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getterMethod);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n\n        }\n\n        // GROOVY-5568, we would be facing a DGM call, but instead of foo.getText(), have foo.text\n        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, getterName, ClassNode.EMPTY_ARRAY);\n        if (!methods.isEmpty()) {\n            List<MethodNode> methodNodes = chooseBestMethod(receiverType, methods, ClassNode.EMPTY_ARRAY);\n            if (methodNodes.size()==1) {\n                MethodNode getter = methodNodes.get(0);\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getter);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n        }\n\n        boolean isStaticProperty = receiver instanceof ClassExpression\n                && (receiverType.isDerivedFrom(receiver.getType()) || receiverType.implementsInterface(receiver.getType()));\n\n        if (!isStaticProperty) {\n            if (receiverType.implementsInterface(MAP_TYPE) || MAP_TYPE.equals(receiverType)) {\n                // for maps, replace map.foo with map.get('foo')\n                writeMapDotProperty(receiver, methodName, mv);\n                return;\n            }\n            if (receiverType.implementsInterface(LIST_TYPE) || LIST_TYPE.equals(receiverType)) {\n                writeListDotProperty(receiver, methodName, mv);\n                return;\n            }\n        }\n\n\n        controller.getSourceUnit().addError(\n                new SyntaxException(\"Access to \"+\n                                                (receiver instanceof ClassExpression ?receiver.getType():receiverType).toString(false)\n                                                +\"#\"+methodName+\" is forbidden\", receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber())\n        );\n        controller.getMethodVisitor().visitInsn(ACONST_NULL);\n        controller.getOperandStack().push(OBJECT_TYPE);\n    }","commit_id":"740ae7c25684d52d531b98aca4a0dd3c939d0bd6","url":"https://github.com/apache/groovy"},{"original_method":"protected boolean writeDirectMethodCall(MethodNode target, boolean implicitThis,  Expression receiver, TupleExpression args) {\n        if (target==null) return false;\n        \n        String methodName = target.getName();\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode declaringClass = target.getDeclaringClass();\n        ClassNode classNode = controller.getClassNode();\n\n        MethodVisitor mv = controller.getMethodVisitor();\n        int opcode = INVOKEVIRTUAL;\n        if (target.isStatic()) {\n            opcode = INVOKESTATIC;\n        } else if (target.isPrivate() || ((receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression()))) {\n            opcode = INVOKESPECIAL;\n        } else if (declaringClass.isInterface()) {\n            opcode = INVOKEINTERFACE;\n        }\n\n        // handle receiver\n        int argumentsToRemove = 0;\n        if (opcode!=INVOKESTATIC) {\n            if (receiver!=null) {\n                // load receiver if not static invocation\n                // todo: fix inner class case\n                if (implicitThis\n                        && !classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    // we are calling an outer class method\n                    compileStack.pushImplicitThis(false);\n                    if (controller.isInClosure()) {\n                        new VariableExpression(\"thisObject\").visit(controller.getAcg());\n                    } else {\n                        Expression expr = new PropertyExpression(new ClassExpression(declaringClass), \"this\");\n                        expr.visit(controller.getAcg());\n                    }\n                } else {\n                    compileStack.pushImplicitThis(implicitThis);\n                    receiver.visit(controller.getAcg());\n                }\n                operandStack.doGroovyCast(declaringClass);\n                compileStack.popImplicitThis();\n                argumentsToRemove++;\n            } else {\n                mv.visitIntInsn(ALOAD,0);\n            }\n        }\n\n        int stackSize = operandStack.getStackLength();\n        loadArguments(args.getExpressions(), target.getParameters());\n\n\n        String owner = BytecodeHelper.getClassInternalName(declaringClass);\n        ClassNode receiverType = receiver!=null?controller.getTypeChooser().resolveType(receiver, classNode):target.getDeclaringClass();\n        if (opcode==INVOKEVIRTUAL\n                && target.isPublic()\n                && (!Modifier.isPublic(declaringClass.getModifiers())\n                && !receiverType.equals(declaringClass))\n                && receiverType.isDerivedFrom(declaringClass)\n                && !receiverType.getPackageName().equals(classNode.getPackageName())) {\n            // package private class, public method\n            // see GROOVY-6962\n            owner = BytecodeHelper.getClassInternalName(receiverType);\n        }\n        String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());\n        mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);\n        ClassNode ret = target.getReturnType().redirect();\n        if (ret==ClassHelper.VOID_TYPE) {\n            ret = ClassHelper.OBJECT_TYPE;\n            mv.visitInsn(ACONST_NULL);\n        }\n        argumentsToRemove += (operandStack.getStackLength()-stackSize);\n        controller.getOperandStack().remove(argumentsToRemove);\n        controller.getOperandStack().push(ret);\n        return true;\n    }","id":89629,"modified_method":"protected boolean writeDirectMethodCall(MethodNode target, boolean implicitThis,  Expression receiver, TupleExpression args) {\n        if (target==null) return false;\n        \n        String methodName = target.getName();\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n        ClassNode declaringClass = target.getDeclaringClass();\n        ClassNode classNode = controller.getClassNode();\n\n        MethodVisitor mv = controller.getMethodVisitor();\n        int opcode = INVOKEVIRTUAL;\n        if (target.isStatic()) {\n            opcode = INVOKESTATIC;\n        } else if (target.isPrivate() || ((receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression()))) {\n            opcode = INVOKESPECIAL;\n        } else if (declaringClass.isInterface()) {\n            opcode = INVOKEINTERFACE;\n        }\n\n        // handle receiver\n        int argumentsToRemove = 0;\n        if (opcode!=INVOKESTATIC) {\n            if (receiver!=null) {\n                // load receiver if not static invocation\n                // todo: fix inner class case\n                if (implicitThis\n                        && !classNode.isDerivedFrom(declaringClass)\n                        && !classNode.implementsInterface(declaringClass)\n                        && classNode instanceof InnerClassNode) {\n                    // we are calling an outer class method\n                    compileStack.pushImplicitThis(false);\n                    if (controller.isInClosure()) {\n                        new VariableExpression(\"thisObject\").visit(controller.getAcg());\n                    } else {\n                        Expression expr = new PropertyExpression(new ClassExpression(declaringClass), \"this\");\n                        expr.visit(controller.getAcg());\n                    }\n                } else {\n                    compileStack.pushImplicitThis(implicitThis);\n                    receiver.visit(controller.getAcg());\n                }\n                operandStack.doGroovyCast(declaringClass);\n                compileStack.popImplicitThis();\n                argumentsToRemove++;\n            } else {\n                mv.visitIntInsn(ALOAD,0);\n                operandStack.push(classNode);\n                argumentsToRemove++;\n            }\n        }\n\n        int stackSize = operandStack.getStackLength();\n\n        String owner = BytecodeHelper.getClassInternalName(declaringClass);\n        ClassNode receiverType = receiver!=null?controller.getTypeChooser().resolveType(receiver, classNode):target.getDeclaringClass();\n        if (opcode == INVOKEVIRTUAL) {\n            if (!receiverType.equals(declaringClass)\n                    && !receiverType.isArray()\n                    && !receiverType.isInterface()\n                    && !ClassHelper.isPrimitiveType(receiverType) // e.g int.getClass()\n                    && receiverType.isDerivedFrom(declaringClass)) {\n\n                owner = BytecodeHelper.getClassInternalName(receiverType);\n                ClassNode top = operandStack.getTopOperand();\n                if (!receiverType.equals(top)) {\n                    mv.visitTypeInsn(CHECKCAST, owner);\n                }\n            } else if (target.isPublic()\n                    && (!Modifier.isPublic(declaringClass.getModifiers())\n                    && !receiverType.equals(declaringClass))\n                    && receiverType.isDerivedFrom(declaringClass)\n                    && !receiverType.getPackageName().equals(classNode.getPackageName())) {\n                // package private class, public method\n                // see GROOVY-6962\n                owner = BytecodeHelper.getClassInternalName(receiverType);\n            }\n        }\n\n        loadArguments(args.getExpressions(), target.getParameters());\n\n        String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());\n        mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);\n        ClassNode ret = target.getReturnType().redirect();\n        if (ret==ClassHelper.VOID_TYPE) {\n            ret = ClassHelper.OBJECT_TYPE;\n            mv.visitInsn(ACONST_NULL);\n        }\n        argumentsToRemove += (operandStack.getStackLength()-stackSize);\n        controller.getOperandStack().remove(argumentsToRemove);\n        controller.getOperandStack().push(ret);\n        return true;\n    }","commit_id":"8e7893897e61380f56b4aaa6e828b90b35c8d63b","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visit(final GroovyCodeVisitor visitor) {\n            receiver.visit(visitor);\n            if (visitor instanceof AsmClassGenerator) {\n                ClassNode topOperand = controller.getOperandStack().getTopOperand();\n                ClassNode type;\n                if (target instanceof ExtensionMethodNode) {\n                    type = ((ExtensionMethodNode) target).getExtensionMethodNode().getDeclaringClass();\n                } else {\n                    type = target.getDeclaringClass();\n                }\n                if (ClassHelper.GSTRING_TYPE.equals(topOperand) && ClassHelper.STRING_TYPE.equals(type)) {\n                    // perform regular type conversion\n                    controller.getOperandStack().doGroovyCast(type);\n                    return;\n                }\n                if (ClassHelper.isPrimitiveType(topOperand) && !ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().box();\n                } else if (!ClassHelper.isPrimitiveType(topOperand) && ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().doGroovyCast(type);\n                }\n                if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(topOperand, type)) return;\n                controller.getMethodVisitor().visitTypeInsn(CHECKCAST, type.isArray() ?\n                        BytecodeHelper.getTypeDescription(type) :\n                        BytecodeHelper.getClassInternalName(type.getName()));\n                controller.getOperandStack().replace(type);\n            }\n        }","id":89630,"modified_method":"@Override\n        public void visit(final GroovyCodeVisitor visitor) {\n            receiver.visit(visitor);\n            if (visitor instanceof AsmClassGenerator) {\n                ClassNode topOperand = controller.getOperandStack().getTopOperand();\n                ClassNode type = getType();\n                if (ClassHelper.GSTRING_TYPE.equals(topOperand) && ClassHelper.STRING_TYPE.equals(type)) {\n                    // perform regular type conversion\n                    controller.getOperandStack().doGroovyCast(type);\n                    return;\n                }\n                if (ClassHelper.isPrimitiveType(topOperand) && !ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().box();\n                } else if (!ClassHelper.isPrimitiveType(topOperand) && ClassHelper.isPrimitiveType(type)) {\n                    controller.getOperandStack().doGroovyCast(type);\n                }\n                if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(topOperand, type)) return;\n                controller.getMethodVisitor().visitTypeInsn(CHECKCAST, type.isArray() ?\n                        BytecodeHelper.getTypeDescription(type) :\n                        BytecodeHelper.getClassInternalName(type.getName()));\n                controller.getOperandStack().replace(type);\n            }\n        }","commit_id":"8e7893897e61380f56b4aaa6e828b90b35c8d63b","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public ClassNode getType() {\n            return controller.getTypeChooser().resolveType(receiver, controller.getClassNode());\n        }","id":89631,"modified_method":"@Override\n        public ClassNode getType() {\n            if (resolvedType!=null) {\n                return resolvedType;\n            }\n            ClassNode type;\n            if (target instanceof ExtensionMethodNode) {\n                type = ((ExtensionMethodNode) target).getExtensionMethodNode().getDeclaringClass();\n            } else {\n                type = getWrapper(controller.getTypeChooser().resolveType(receiver, controller.getClassNode()));\n                ClassNode declaringClass = target.getDeclaringClass();\n                if (type.getClass() != ClassNode.class && type.getClass() !=InnerClassNode.class) {\n                    type = declaringClass; // ex: LUB type\n                }\n                if (OBJECT_TYPE.equals(type) && !OBJECT_TYPE.equals(declaringClass)) {\n                    // can happen for compiler rewritten code, where type information is missing\n                    type = declaringClass;\n                }\n            }\n            resolvedType = type;\n            return type;\n        }","commit_id":"8e7893897e61380f56b4aaa6e828b90b35c8d63b","url":"https://github.com/apache/groovy"},{"original_method":"private void createDirectCallMethod(final ClassNode closureClass, final MethodNode doCallMethod) {\n        // in case there is no \"call\" method on the closure, we can create a \"fast invocation\" paths\n        // to avoid going through ClosureMetaClass by call(Object...) method\n\n        // we can't have a specialized version of call(Object...) because the dispatch logic in ClosureMetaClass\n        // is too complex!\n\n        // call(Object)\n        Parameter args = new Parameter(ClassHelper.OBJECT_TYPE, \"args\");\n        MethodCallExpression doCall1arg = new MethodCallExpression(\n                new VariableExpression(\"this\"),\n                \"doCall\",\n                new ArgumentListExpression(new VariableExpression(args))\n        );\n        doCall1arg.setImplicitThis(true);\n        doCall1arg.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        new Parameter[]{args},\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCall1arg)));\n\n        // call()\n        MethodCallExpression doCallNoArgs = new MethodCallExpression(new VariableExpression(\"this\"), \"doCall\", new ArgumentListExpression(new ConstantExpression(null)));\n        doCallNoArgs.setImplicitThis(true);\n        doCallNoArgs.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCallNoArgs)));\n    }","id":89632,"modified_method":"private void createDirectCallMethod(final ClassNode closureClass, final MethodNode doCallMethod) {\n        // in case there is no \"call\" method on the closure, we can create a \"fast invocation\" paths\n        // to avoid going through ClosureMetaClass by call(Object...) method\n\n        // we can't have a specialized version of call(Object...) because the dispatch logic in ClosureMetaClass\n        // is too complex!\n\n        // call(Object)\n        Parameter args = new Parameter(ClassHelper.OBJECT_TYPE, \"args\");\n        MethodCallExpression doCall1arg = new MethodCallExpression(\n                new VariableExpression(\"this\", closureClass),\n                \"doCall\",\n                new ArgumentListExpression(new VariableExpression(args))\n        );\n        doCall1arg.setImplicitThis(true);\n        doCall1arg.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        new Parameter[]{args},\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCall1arg)));\n\n        // call()\n        MethodCallExpression doCallNoArgs = new MethodCallExpression(new VariableExpression(\"this\", closureClass), \"doCall\", new ArgumentListExpression(new ConstantExpression(null)));\n        doCallNoArgs.setImplicitThis(true);\n        doCallNoArgs.setMethodTarget(doCallMethod);\n        closureClass.addMethod(\n                new MethodNode(\"call\",\n                        Opcodes.ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        new ReturnStatement(doCallNoArgs)));\n    }","commit_id":"8e7893897e61380f56b4aaa6e828b90b35c8d63b","url":"https://github.com/apache/groovy"},{"original_method":"public <A, B extends IOException> List<?> genericMethod(A a) throws B {\n        return null;\n    }","id":89633,"modified_method":"public <A, B extends IOException> List<?> genericMethod(A a, int[] array) throws B {\n        return null;\n    }","commit_id":"8ad93881b437e3a0cc189db2d4059f29cd4b366c","url":"https://github.com/apache/groovy"},{"original_method":"static MethodNode createMethodNode(AsmReferenceResolver resolver, MethodStub method) {\n        //todo method generics\n        Type[] argumentTypes = Type.getArgumentTypes(method.desc);\n        Parameter[] parameters = new Parameter[argumentTypes.length];\n        for (int i = 0; i < argumentTypes.length; i++) {\n            parameters[i] = new Parameter(resolver.resolveType(argumentTypes[i]), \"param\" + i);\n        }\n\n        for (Map.Entry<Integer, List<AnnotationStub>> entry : method.parameterAnnotations.entrySet()) {\n            for (AnnotationStub stub : entry.getValue()) {\n                parameters[entry.getKey()].addAnnotation(Annotations.createAnnotationNode(stub, resolver));\n            }\n        }\n\n        ClassNode[] exceptions = new ClassNode[method.exceptions.length];\n        for (int i = 0; i < method.exceptions.length; i++) {\n            exceptions[i] = resolver.resolveClass(AsmDecompiler.fromInternalName(method.exceptions[i]));\n        }\n\n        return \"<init>\".equals(method.methodName) ?\n                new ConstructorNode(method.accessModifiers, parameters, exceptions, null) :\n                new MethodNode(method.methodName, method.accessModifiers, resolver.resolveType(Type.getReturnType(method.desc)), parameters, exceptions, null);\n    }","id":89634,"modified_method":"static MethodNode createMethodNode(final AsmReferenceResolver resolver, MethodStub method) {\n        GenericsType[] typeParameters = null;\n\n        Type[] argumentTypes = Type.getArgumentTypes(method.desc);\n\n        final ClassNode[] parameterTypes = new ClassNode[argumentTypes.length];\n        final ClassNode[] exceptions = new ClassNode[method.exceptions.length];\n        final Reference<ClassNode> returnType = new Reference<>();\n\n        if (method.signature != null) {\n            FormalParameterParser v = new FormalParameterParser(resolver) {\n                int paramIndex = 0;\n                @Override\n                public SignatureVisitor visitParameterType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            parameterTypes[paramIndex++] = result;\n                        }\n                    };\n                }\n\n                @Override\n                public SignatureVisitor visitReturnType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            returnType.set(result);\n                        }\n                    };\n                }\n\n                int exceptionIndex = 0;\n                @Override\n                public SignatureVisitor visitExceptionType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            exceptions[exceptionIndex++] = result;\n                        }\n                    };\n                }\n            };\n            new SignatureReader(method.signature).accept(v);\n            typeParameters = v.getTypeParameters();\n        } else {\n            for (int i = 0; i < argumentTypes.length; i++) {\n                parameterTypes[i] = resolver.resolveType(argumentTypes[i]);\n            }\n\n            for (int i = 0; i < method.exceptions.length; i++) {\n                exceptions[i] = resolver.resolveClass(AsmDecompiler.fromInternalName(method.exceptions[i]));\n            }\n        }\n\n\n        Parameter[] parameters = new Parameter[parameterTypes.length];\n        for (int i = 0; i < parameterTypes.length; i++) {\n            parameters[i] = new Parameter(parameterTypes[i], \"param\" + i);\n        }\n\n        for (Map.Entry<Integer, List<AnnotationStub>> entry : method.parameterAnnotations.entrySet()) {\n            for (AnnotationStub stub : entry.getValue()) {\n                parameters[entry.getKey()].addAnnotation(Annotations.createAnnotationNode(stub, resolver));\n            }\n        }\n\n        MethodNode result;\n        if (\"<init>\".equals(method.methodName)) {\n            result = new ConstructorNode(method.accessModifiers, parameters, exceptions, null);\n        } else {\n            if (returnType.get() == null) {\n                returnType.set(resolver.resolveType(Type.getReturnType(method.desc)));\n            }\n            result = new MethodNode(method.methodName, method.accessModifiers, returnType.get(), parameters, exceptions, null);\n        }\n        result.setGenericsTypes(typeParameters);\n        return result;\n    }","commit_id":"8ad93881b437e3a0cc189db2d4059f29cd4b366c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitBaseType(char descriptor) {\n        throw new UnsupportedOperationException(); //todo\n    }","id":89635,"modified_method":"@Override\n    public void visitBaseType(char descriptor) {\n        finished(resolver.resolveType(Type.getType(String.valueOf(descriptor))));\n    }","commit_id":"8ad93881b437e3a0cc189db2d4059f29cd4b366c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public SignatureVisitor visitArrayType() {\n        throw new UnsupportedOperationException(); //todo\n    }","id":89636,"modified_method":"@Override\n    public SignatureVisitor visitArrayType() {\n        final TypeSignatureParser outer = this;\n        return new TypeSignatureParser(resolver) {\n            @Override\n            void finished(ClassNode result) {\n                outer.finished(result.makeArray());\n            }\n        };\n    }","commit_id":"8ad93881b437e3a0cc189db2d4059f29cd4b366c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitTypeArgument() {\n//            todo ?\n    }","id":89637,"modified_method":"@Override\n    public void visitTypeArgument() {\n        arguments.add(createWildcard(new ClassNode[]{ClassHelper.OBJECT_TYPE}, null));\n    }","commit_id":"8ad93881b437e3a0cc189db2d4059f29cd4b366c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public SignatureVisitor visitTypeArgument(final char wildcard) {\n        return new TypeSignatureParser(resolver) {\n            @Override\n            void finished(ClassNode result) {\n                if (wildcard == INSTANCEOF) {\n                    arguments.add(new GenericsType(result));\n                    return;\n                }\n\n                //todo duplicates Java 5\n                ClassNode base = ClassHelper.makeWithoutCaching(\"?\");\n                base.setRedirect(ClassHelper.OBJECT_TYPE);\n\n                ClassNode[] upper = wildcard == EXTENDS ? new ClassNode[]{result} : null;\n                ClassNode lower = wildcard == SUPER ? result : null;\n                GenericsType t = new GenericsType(base, upper, lower);\n                t.setWildcard(true);\n                arguments.add(t);\n            }\n        };\n    }","id":89638,"modified_method":"@Override\n    public SignatureVisitor visitTypeArgument(final char wildcard) {\n        return new TypeSignatureParser(resolver) {\n            @Override\n            void finished(ClassNode result) {\n                if (wildcard == INSTANCEOF) {\n                    arguments.add(new GenericsType(result));\n                    return;\n                }\n\n                ClassNode[] upper = wildcard == EXTENDS ? new ClassNode[]{result} : null;\n                ClassNode lower = wildcard == SUPER ? result : null;\n                arguments.add(createWildcard(upper, lower));\n            }\n        };\n    }","commit_id":"8ad93881b437e3a0cc189db2d4059f29cd4b366c","url":"https://github.com/apache/groovy"},{"original_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, SideMenuPresenter.Display sideMenuView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n      initWidget(uiBinder.createAndBindUi(this));\n\n      readOnlyLabel.setText(\"[\" + messages.readOnly() + \"]\");\n\n      keyShortcuts.setTitle(messages.availableKeyShortcutsTitle());\n\n      resize.setTitle(messages.maximize());\n      resize.addStyleName(STYLE_MAXIMIZE);\n\n      sideMenuContainer.add(sideMenuView.asWidget());\n\n      searchAndReplaceTab.setTitle(messages.projectWideSearchAndReplace());\n      documentListTab.setTitle(messages.documentListTitle());\n      editorTab.setTitle(messages.editor());\n\n      contentBody.add(documentListView.asWidget());\n      contentBody.add(translationView.asWidget());\n      contentBody.add(searchResultsView.asWidget());\n      \n      Window.enableScrolling(false);\n   }","id":89639,"modified_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, SideMenuPresenter.Display sideMenuView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n      initWidget(uiBinder.createAndBindUi(this));\n\n      readOnlyLabel.setText(\"[\" + messages.readOnly() + \"]\");\n\n      keyShortcuts.setTitle(messages.availableKeyShortcutsTitle());\n\n      resize.setTitle(messages.maximize());\n      resize.addStyleName(STYLE_MAXIMIZE);\n\n      sideMenuContainer.add(sideMenuView.asWidget());\n\n      searchAndReplaceTab.setTitle(messages.projectWideSearchAndReplace());\n      documentListTab.setTitle(messages.documentListTitle());\n      editorTab.setTitle(messages.editor());\n\n      content.add(documentListView.asWidget());\n      content.add(translationView.asWidget());\n      content.add(searchResultsView.asWidget());\n      \n      Window.enableScrolling(false);\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void showSideMenu(boolean isShowing)\n   {\n      rootContainer.forceLayout();\n      if (isShowing)\n      {\n         rootContainer.setWidgetLeftRight(contentBody, 0.0, Unit.PX, MINIMISED_EDITOR_RIGHT, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, EXPENDED_MENU_RIGHT, Unit.PX);\n      }\n      else\n      {\n         rootContainer.setWidgetLeftRight(contentBody, 0.0, Unit.PX, 0.0, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, MIN_MENU_WIDTH, Unit.PX);\n      }\n      rootContainer.animate(ANIMATE_DURATION);\n   }","id":89640,"modified_method":"@Override\n   public void showSideMenu(boolean isShowing)\n   {\n      rootContainer.forceLayout();\n      if (isShowing)\n      {\n         rootContainer.setWidgetLeftRight(contentContainer, 0.0, Unit.PX, MINIMISED_EDITOR_RIGHT, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, EXPENDED_MENU_RIGHT, Unit.PX);\n      }\n      else\n      {\n         rootContainer.setWidgetLeftRight(contentContainer, 0.0, Unit.PX, 0.0, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, MIN_MENU_WIDTH, Unit.PX);\n      }\n      rootContainer.animate(ANIMATE_DURATION);\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void showInMainView(MainView view)\n   {\n      switch (view)\n      {\n      case Documents:\n         contentBody.selectTab(DOCUMENT_VIEW);\n         setSelectedTab(documentListTab);\n         break;\n      case Search:\n         contentBody.selectTab(SEARCH_AND_REPLACE_VIEW);\n         setSelectedTab(searchAndReplaceTab);\n         break;\n      case Editor:\n         contentBody.selectTab(EDITOR_VIEW);\n         setSelectedTab(editorTab);\n         break;\n      }\n   }","id":89641,"modified_method":"@Override\n   public void showInMainView(MainView view)\n   {\n      switch (view)\n      {\n      case Documents:\n         content.selectTab(DOCUMENT_VIEW);\n         setSelectedTab(documentListTab);\n         break;\n      case Search:\n         content.selectTab(SEARCH_AND_REPLACE_VIEW);\n         setSelectedTab(searchAndReplaceTab);\n         break;\n      case Editor:\n         content.selectTab(EDITOR_VIEW);\n         setSelectedTab(editorTab);\n         break;\n      }\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      editorOptionsPresenter.bind();\n      validationOptionsPresenter.bind();\n      workspaceUsersPresenter.bind();\n      notificationPresenter.bind();\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            userWorkspaceContext.setProjectActive(event.isProjectActive());\n\n            display.getContainer().setVisible(!userWorkspaceContext.hasReadOnlyAccess());\n            display.getChatTab().setVisible(!userWorkspaceContext.hasReadOnlyAccess());\n            display.getEditorOptionsTab().setVisible(!userWorkspaceContext.hasReadOnlyAccess());\n            display.getValidationOptionsTab().setVisible(!userWorkspaceContext.hasReadOnlyAccess());\n         }\n      }));\n\n      display.getEditorOptionsButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Tab.EDITOR_OPTION);\n               }\n               else if (display.getCurrentTab() != Tab.EDITOR_OPTION)\n               {\n                  display.setSelectedTab(Tab.EDITOR_OPTION);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      display.getValidationOptionsButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Tab.VALIDATION_OPTION);\n               }\n               else if (display.getCurrentTab() != Tab.VALIDATION_OPTION)\n               {\n                  display.setSelectedTab(Tab.VALIDATION_OPTION);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      display.getChatButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Tab.CHAT);\n               }\n               else if (display.getCurrentTab() != Tab.CHAT)\n               {\n                  display.setSelectedTab(Tab.CHAT);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      display.getNotificationButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Tab.NOTIFICATION);\n               }\n               else if (display.getCurrentTab() != Tab.NOTIFICATION)\n               {\n                  display.setSelectedTab(Tab.NOTIFICATION);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      notificationPresenter.setNotificationListener(this);\n\n      // We won't receive the EnterWorkspaceEvent generated by our own login,\n      // because this presenter is not bound until we get the callback from\n      // EventProcessor.\n      // Thus we load the translator list here.\n      loadTranslatorList();\n   }","id":89642,"modified_method":"@Override\n   protected void onBind()\n   {\n      editorOptionsPresenter.bind();\n      validationOptionsPresenter.bind();\n      workspaceUsersPresenter.bind();\n      notificationPresenter.bind();\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            userWorkspaceContext.setProjectActive(event.isProjectActive());\n            setReadOnly(userWorkspaceContext.hasReadOnlyAccess());\n         }\n      }));\n\n      setReadOnly(userWorkspaceContext.hasReadOnlyAccess());\n\n      display.getEditorOptionsButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Display.EDITOR_OPTION_VIEW);\n               }\n               else if (display.getCurrentTab() != Display.EDITOR_OPTION_VIEW)\n               {\n                  display.setSelectedTab(Display.EDITOR_OPTION_VIEW);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      display.getValidationOptionsButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Display.VALIDATION_OPTION_VIEW);\n               }\n               else if (display.getCurrentTab() != Display.VALIDATION_OPTION_VIEW)\n               {\n                  display.setSelectedTab(Display.VALIDATION_OPTION_VIEW);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      display.getChatButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!userWorkspaceContext.hasReadOnlyAccess())\n            {\n               if (!isExpended)\n               {\n                  expendSideMenu(true);\n                  display.setSelectedTab(Display.WORKSPACEUSER_VIEW);\n               }\n               else if (display.getCurrentTab() != Display.WORKSPACEUSER_VIEW)\n               {\n                  display.setSelectedTab(Display.WORKSPACEUSER_VIEW);\n               }\n               else\n               {\n                  expendSideMenu(false);\n               }\n            }\n         }\n      });\n\n      display.getNotificationButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            if (!isExpended)\n            {\n               expendSideMenu(true);\n               display.setSelectedTab(Display.NOTIFICATION_VIEW);\n            }\n            else if (display.getCurrentTab() != Display.NOTIFICATION_VIEW)\n            {\n               display.setSelectedTab(Display.NOTIFICATION_VIEW);\n            }\n            else\n            {\n               expendSideMenu(false);\n            }\n         }\n      });\n\n      notificationPresenter.setNotificationListener(this);\n\n      // We won't receive the EnterWorkspaceEvent generated by our own login,\n      // because this presenter is not bound until we get the callback from\n      // EventProcessor.\n      // Thus we load the translator list here.\n      loadTranslatorList();\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"Tab getCurrentTab();","id":89643,"modified_method":"int getCurrentTab();","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void showNotification()\n   {\n      if (!userWorkspaceContext.hasReadOnlyAccess())\n      {\n         if (!isExpended)\n         {\n            expendSideMenu(true);\n            display.setSelectedTab(Tab.NOTIFICATION);\n         }\n         else if (display.getCurrentTab() != Tab.NOTIFICATION)\n         {\n            display.setSelectedTab(Tab.NOTIFICATION);\n         }\n      }\n   }","id":89644,"modified_method":"@Override\n   public void showNotification()\n   {\n      if (!isExpended)\n      {\n         expendSideMenu(true);\n         display.setSelectedTab(Display.NOTIFICATION_VIEW);\n      }\n      else if (display.getCurrentTab() != Display.NOTIFICATION_VIEW)\n      {\n         display.setSelectedTab(Display.NOTIFICATION_VIEW);\n      }\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"void setSelectedTab(Tab tab);","id":89645,"modified_method":"void setSelectedTab(int view);","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void loadTranslatorList()\n   {\n      dispatcher.execute(new GetTranslatorList(), new AsyncCallback<GetTranslatorListResult>()\n      {\n         @Override\n         public void onFailure(Throwable caught)\n         {\n            Log.error(\"error fetching translators list: \" + caught.getMessage());\n         }\n\n         @Override\n         public void onSuccess(GetTranslatorListResult result)\n         {\n            workspaceUsersPresenter.initUserList(result.getTranslatorList());\n         }\n      });\n\n      registerHandler(eventBus.addHandler(ExitWorkspaceEvent.getType(), new ExitWorkspaceEventHandler()\n      {\n         @Override\n         public void onExitWorkspace(ExitWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.removeTranslator(event.getEditorClientId(), event.getPerson());\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(EnterWorkspaceEvent.getType(), new EnterWorkspaceEventHandler()\n      {\n         @Override\n         public void onEnterWorkspace(EnterWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.addTranslator(event.getEditorClientId(), event.getPerson(), null);\n            workspaceUsersPresenter.dispatchChatAction(null, messages.hasJoinedWorkspace(event.getPerson().getId().toString()), MESSAGE_TYPE.SYSTEM_MSG);\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(PublishWorkspaceChatEvent.getType(), new PublishWorkspaceChatEventHandler()\n      {\n         @Override\n         public void onPublishWorkspaceChat(PublishWorkspaceChatEvent event)\n         {\n            if (display.getCurrentTab() != Tab.CHAT)\n            {\n               display.setChatTabAlert(true);\n            }\n         }\n      }));\n   }","id":89646,"modified_method":"private void loadTranslatorList()\n   {\n      dispatcher.execute(new GetTranslatorList(), new AsyncCallback<GetTranslatorListResult>()\n      {\n         @Override\n         public void onFailure(Throwable caught)\n         {\n            Log.error(\"error fetching translators list: \" + caught.getMessage());\n         }\n\n         @Override\n         public void onSuccess(GetTranslatorListResult result)\n         {\n            workspaceUsersPresenter.initUserList(result.getTranslatorList());\n         }\n      });\n\n      registerHandler(eventBus.addHandler(ExitWorkspaceEvent.getType(), new ExitWorkspaceEventHandler()\n      {\n         @Override\n         public void onExitWorkspace(ExitWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.removeTranslator(event.getEditorClientId(), event.getPerson());\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(EnterWorkspaceEvent.getType(), new EnterWorkspaceEventHandler()\n      {\n         @Override\n         public void onEnterWorkspace(EnterWorkspaceEvent event)\n         {\n            workspaceUsersPresenter.addTranslator(event.getEditorClientId(), event.getPerson(), null);\n            workspaceUsersPresenter.dispatchChatAction(null, messages.hasJoinedWorkspace(event.getPerson().getId().toString()), MESSAGE_TYPE.SYSTEM_MSG);\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(PublishWorkspaceChatEvent.getType(), new PublishWorkspaceChatEventHandler()\n      {\n         @Override\n         public void onPublishWorkspaceChat(PublishWorkspaceChatEvent event)\n         {\n            if (display.getCurrentTab() != Display.WORKSPACEUSER_VIEW)\n            {\n               display.setChatTabAlert(true);\n            }\n         }\n      }));\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void expendSideMenu(boolean isExpend)\n   {\n      isExpended = isExpend;\n      eventBus.fireEvent(new ShowSideMenuEvent(isExpended));\n      if(!isExpended)\n      {\n         display.setSelectedTab(Tab.NONE);\n      }\n   }","id":89647,"modified_method":"private void expendSideMenu(boolean isExpend)\n   {\n      isExpended = isExpend;\n      eventBus.fireEvent(new ShowSideMenuEvent(isExpended));\n      if (!isExpended)\n      {\n         display.setSelectedTab(Display.EMPTY_VIEW);\n      }\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void showEditorMenu(boolean showEditorMenu)\n   {\n      display.getEditorOptionsTab().setVisible(showEditorMenu);\n      display.getValidationOptionsTab().setVisible(showEditorMenu);\n\n      if (showEditorMenu && isExpended)\n      {\n         display.setSelectedTab(Tab.CHAT);\n      }\n      else\n      {\n         display.setSelectedTab(Tab.NONE);\n      }\n   }","id":89648,"modified_method":"public void showEditorMenu(boolean showEditorMenu)\n   {\n      if (!userWorkspaceContext.hasReadOnlyAccess())\n      {\n         display.getEditorOptionsTab().setVisible(showEditorMenu);\n         display.getValidationOptionsTab().setVisible(showEditorMenu);\n\n         if (showEditorMenu && isExpended)\n         {\n            display.setSelectedTab(Display.NOTIFICATION_VIEW);\n         }\n         else\n         {\n            display.setSelectedTab(Display.EMPTY_VIEW);\n         }\n      }\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void setSelectedTab(Tab tab)\n   {\n      editorOptionsTab.removeStyleName(style.selectedButton());\n      validationOptionsTab.removeStyleName(style.selectedButton());\n      chatTab.removeStyleName(style.selectedButton());\n      notificationTab.removeStyleName(style.selectedButton());\n      \n      container.clear();\n      \n      switch (tab)\n      {\n         case EDITOR_OPTION: \n            container.add(editorOptionView);\n            editorOptionsTab.addStyleName(style.selectedButton());\n            break;\n         case VALIDATION_OPTION: \n            container.add(validationOptionView);\n            validationOptionsTab.addStyleName(style.selectedButton());\n            break;\n         case CHAT: \n            container.add(workspaceUsersView);\n            chatTab.addStyleName(style.selectedButton());\n            setChatTabAlert(false);\n            break;\n      case NOTIFICATION:\n         container.add(notificationView);\n         notificationTab.addStyleName(style.selectedButton());\n         break;\n         default:\n            break;\n      }\n   }","id":89649,"modified_method":"@Override\n   public void setSelectedTab(int view)\n   {\n      editorOptionsTab.removeStyleName(style.selectedButton());\n      validationOptionsTab.removeStyleName(style.selectedButton());\n      chatTab.removeStyleName(style.selectedButton());\n      notificationTab.removeStyleName(style.selectedButton());\n      \n      switch (view)\n      {\n         case EDITOR_OPTION_VIEW: \n            container.selectTab(EDITOR_OPTION_VIEW);\n            editorOptionsTab.addStyleName(style.selectedButton());\n            break;\n         case VALIDATION_OPTION_VIEW: \n            container.selectTab(VALIDATION_OPTION_VIEW);\n            validationOptionsTab.addStyleName(style.selectedButton());\n            break;\n         case WORKSPACEUSER_VIEW: \n            container.selectTab(WORKSPACEUSER_VIEW);\n            chatTab.addStyleName(style.selectedButton());\n            setChatTabAlert(false);\n            break;\n         case NOTIFICATION_VIEW:\n            container.selectTab(NOTIFICATION_VIEW);\n            notificationTab.addStyleName(style.selectedButton());\n         break;\n         default:\n            break;\n      }\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public Tab getCurrentTab()\n   {\n      if (notificationTab.getStyleName().contains(style.selectedButton()))\n      {\n         return Tab.NOTIFICATION;\n      }\n      else if (chatTab.getStyleName().contains(style.selectedButton()))\n      {\n         return Tab.CHAT;\n      }\n      else if (editorOptionsTab.getStyleName().contains(style.selectedButton()))\n      {\n         return Tab.EDITOR_OPTION;\n      }\n      else if (validationOptionsTab.getStyleName().contains(style.selectedButton()))\n      {\n         return Tab.VALIDATION_OPTION;\n      }\n      return null;\n   }","id":89650,"modified_method":"@Override\n   public int getCurrentTab()\n   {\n      return container.getSelectedIndex();\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public SideMenuView(final WebTransMessages messages, final EditorOptionsDisplay editorOptionView, final ValidationOptionsPresenter.Display validationOptionView, final WorkspaceUsersPresenter.Display workspaceUsersView, final NotificationPresenter.Display notificationView)\n   {\n      initWidget(uiBinder.createAndBindUi(this));\n      notificationTab.setTitle(messages.notification());\n      editorOptionsTab.setTitle(messages.editorOptions());\n      validationOptionsTab.setTitle(messages.validationOptions());\n      chatTab.setTitle(messages.chatRoom());\n      \n      this.editorOptionView = editorOptionView.asWidget();\n      this.validationOptionView = validationOptionView.asWidget();\n      this.workspaceUsersView = workspaceUsersView.asWidget();\n      this.notificationView = notificationView.asWidget();\n   }","id":89651,"modified_method":"@Inject\n   public SideMenuView(final WebTransMessages messages, final EditorOptionsDisplay editorOptionView, final ValidationOptionsPresenter.Display validationOptionView, final WorkspaceUsersPresenter.Display workspaceUsersView, final NotificationPresenter.Display notificationView)\n   {\n      initWidget(uiBinder.createAndBindUi(this));\n      notificationTab.setTitle(messages.notification());\n      editorOptionsTab.setTitle(messages.editorOptions());\n      validationOptionsTab.setTitle(messages.validationOptions());\n      chatTab.setTitle(messages.chatRoom());\n      \n      this.editorOptionView = editorOptionView.asWidget();\n      this.validationOptionView = validationOptionView.asWidget();\n      this.workspaceUsersView = workspaceUsersView.asWidget();\n      this.notificationView = notificationView.asWidget();\n      \n      container.add(notificationView.asWidget());\n      container.add(workspaceUsersView.asWidget());\n      container.add(editorOptionView.asWidget());\n      container.add(validationOptionView.asWidget());\n   }","commit_id":"6e5d9af2df2120f870bff27f0987da9f8a69813c","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DocumentStats() {\r\n    }","id":89652,"modified_method":"/**\r\n     * Default {@link DocumentStats} constructor.\r\n     */\r\n    public DocumentStats()\r\n    {\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getUniqueVisitors() {\r\n        return getIntValue(\"uniqueVisitors\");\r\n    }","id":89653,"modified_method":"/**\r\n     * @return the number of unique visitors.\r\n     */\r\n    public int getUniqueVisitors()\r\n    {\r\n        return getIntValue(Property.uniqueVisitors.toString());\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getVisits() {\r\n        return getIntValue(\"visits\");\r\n    }","id":89654,"modified_method":"/**\r\n     * @return the number of visits.\r\n     */\r\n    public int getVisits()\r\n    {\r\n        return getIntValue(Property.visits.toString());\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  incUniqueVisitors() {\r\n        setIntValue(\"uniqueVisitors\", getUniqueVisitors() + 1);\r\n    }","id":89655,"modified_method":"/**\r\n     * Add 1 to the number of unique visitors.\r\n     */\r\n    public void incUniqueVisitors()\r\n    {\r\n        setIntValue(Property.uniqueVisitors.toString(), getUniqueVisitors() + 1);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  incVisits() {\r\n        setIntValue(\"visits\", getVisits() + 1);\r\n    }","id":89656,"modified_method":"/**\r\n     * Add 1 to the number of visits.\r\n     */\r\n    public void incVisits()\r\n    {\r\n        setIntValue(Property.visits.toString(), getVisits() + 1);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getAction() {\r\n        return getStringValue(\"action\");\r\n    }","id":89657,"modified_method":"/**\r\n     * @return the action made on the document (\"view\", \"save\", ...).\r\n     */\r\n    public String getAction()\r\n    {\r\n        return getStringValue(Property.action.toString());\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setUniqueVisitors(int uniqueVisitors) {\r\n        setIntValue(\"uniqueVisitors\", uniqueVisitors);\r\n    }","id":89658,"modified_method":"/**\r\n     * @param uniqueVisitors the number of unique visitors.\r\n     */\r\n    public void setUniqueVisitors(int uniqueVisitors)\r\n    {\r\n        setIntValue(Property.uniqueVisitors.toString(), uniqueVisitors);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setVisits(int visits) {\r\n        setIntValue(\"visits\", visits);\r\n    }","id":89659,"modified_method":"/**\r\n     * @param visits the number of visits.\r\n     */\r\n    public void setVisits(int visits)\r\n    {\r\n        setIntValue(Property.visits.toString(), visits);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setAction(String action) {\r\n        setStringValue(\"action\", action);\r\n    }","id":89660,"modified_method":"/**\r\n     * @param action the action made on the document (\"view\", \"save\", ...).\r\n     */\r\n    public void setAction(String action)\r\n    {\r\n        setStringValue(Property.action.toString(), action);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DocumentStats(String docName, String action, Date period, int periodtype) {\r\n        super(period, periodtype);\r\n        setName(docName);\r\n        setClassName(\"internal\");\r\n        String nb = action + getPeriod();\r\n        setNumber(nb.hashCode());\r\n        setAction(action);\r\n    }","id":89661,"modified_method":"/**\r\n     * @param docName the name of the wiki/space/document.\r\n     * @param action the action made on the document (\"view\", \"save\", ...).\r\n     * @param periodDate the date of the period.\r\n     * @param periodType the type of the period.\r\n     */\r\n    public DocumentStats(String docName, String action, Date periodDate, PeriodType periodType)\r\n    {\r\n        super(periodDate, periodType);\r\n        \r\n        setName(docName);\r\n        setClassName(\"internal\");\r\n        String nb = action + getPeriod();\r\n        setNumber(nb.hashCode());\r\n        setAction(action);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setReferer(String referer) {\r\n        setStringValue(\"referer\", referer);\r\n    }","id":89662,"modified_method":"/**\r\n     * @param referer the referer.\r\n     */\r\n    public void setReferer(String referer)\r\n    {\r\n        setStringValue(Property.referer.toString(), referer);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getReferer() {\r\n        return getStringValue(\"referer\");\r\n    }","id":89663,"modified_method":"/**\r\n     * @return the referer.\r\n     */\r\n    public String getReferer()\r\n    {\r\n        return getStringValue(Property.referer.toString());\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public RefererStats(String docName, String referer, Date period, int periodtype) {\r\n        super(period, periodtype);\r\n        setName(docName);\r\n        setClassName(\"internal\");\r\n        String nb = referer + getPeriod();\r\n        setNumber(nb.hashCode());\r\n        setReferer(referer);\r\n    }","id":89664,"modified_method":"/**\r\n     * @param docName the name of the wiki/space/document.\r\n     * @param referer the referer.\r\n     * @param periodDate the date of the period.\r\n     * @param periodType the type of the period.\r\n     */\r\n    public RefererStats(String docName, String referer, Date periodDate, PeriodType periodType)\r\n    {\r\n        super(periodDate, periodType);\r\n\r\n        setName(docName);\r\n        setClassName(\"internal\");\r\n        String nb = referer + getPeriod();\r\n        setNumber(nb.hashCode());\r\n        setReferer(referer);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public URL getURL()\r\n    {\r\n        try {\r\n            return new URL(getReferer());\r\n        } catch (MalformedURLException e) {\r\n            return null;\r\n        }\r\n    }","id":89665,"modified_method":"/**\r\n     * @return the referer URL.\r\n     */\r\n    public URL getURL()\r\n    {\r\n        URL url = null;\r\n\r\n        try {\r\n            url = new URL(getReferer());\r\n        } catch (MalformedURLException e) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Failed to construct URL from referer\", e);\r\n            }\r\n        }\r\n\r\n        return url;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public RefererStats() {\r\n        super();\r\n    }","id":89666,"modified_method":"/**\r\n     * Default {@link RefererStats} constructor.\r\n     */\r\n    public RefererStats()\r\n    {\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setRegEx(String regEx) {\r\n        this.regEx = regEx;\r\n    }","id":89667,"modified_method":"/**\r\n     * @param regEx the regular expression to match.\r\n     */\r\n    public void setRegEx(String regEx)\r\n    {\r\n        this.regEx = regEx;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getHost() {\r\n        return host;\r\n    }","id":89668,"modified_method":"/**\r\n     * @return the search engine server address.\r\n     */\r\n    public String getHost()\r\n    {\r\n        return host;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public SearchEngineRule(String host, String regEx) {\r\n     this.setRegEx(regEx);\r\n     this.setHost(host);\r\n    }","id":89669,"modified_method":"/**\r\n     * @param host the search engine server address.\r\n     * @param regEx the regular expression to match.\r\n     */\r\n    public SearchEngineRule(String host, String regEx)\r\n    {\r\n        setRegEx(regEx);\r\n        setHost(host);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setHost(String host) {\r\n        this.host = host;\r\n    }","id":89670,"modified_method":"/**\r\n     * @param host the search engine server address.\r\n     */\r\n    public void setHost(String host)\r\n    {\r\n        this.host = host;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getRegEx() {\r\n        return regEx;\r\n    }","id":89671,"modified_method":"/**\r\n     * @return the regular expression to match.\r\n     */\r\n    public String getRegEx()\r\n    {\r\n        return regEx;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Shows how the statistics for the specified action have evolved over the specified period of\n     * time.\n     * \n     * @param action The action for which to retrieve statistics\n     * @param scope The set of documents to consider\n     * @param period The period of time\n     * @param step The step used for sampling the period\n     * @return A map of (date, actionCount) pairs\n     */\n    public Map getActionStatistics(String action, Scope scope, Period period, Duration step)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_MAP;\n        return stats.getActionStatistics(action, scope, period, step, getXWikiContext());\n    }","id":89672,"modified_method":"/**\n     * Shows how the statistics for the specified action have evolved over the specified period of\n     * time.\n     * \n     * @param action the action for which to retrieve statistics.\n     * @param scope the set of documents to consider.\n     * @param period the period of time.\n     * @param step the step used for sampling the period.\n     * @return a map of (date, actionCount) pairs.\n     */\n    public Map< ? , ? > getActionStatistics(String action, Scope scope, Period period,\n        Duration step)\n    {\n        Map< ? , ? > stats = Collections.emptyMap();\n\n        XWikiStatsService statsService =\n            getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (statsService != null) {\n            stats =\n                statsService.getActionStatistics(action, scope, period, step, getXWikiContext());\n        }\n\n        return stats;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieves visit statistics\n     * \n     * @param action The action the results should be ordered by. It can be one of: \"view\", \"save\"\n     *            or \"download\". If the action is \"view\" then the visitors are ordered by the number\n     *            of pages they have viewed so far.\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of VisitStats objects\n     */\n    public List getVisitStatistics(String action, Period period, Range range)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getVisitStatistics(action, period, range, getXWikiContext());\n    }","id":89673,"modified_method":"/**\n     * Retrieves visit statistics.\n     * \n     * @param action The action the results should be ordered by. It can be one of: \"view\", \"save\"\n     *            or \"download\". If the action is \"view\" then the visitors are ordered by the number\n     *            of pages they have viewed so far.\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of VisitStats objects\n     */\n    public List< ? > getVisitStatistics(String action, Period period, Range range)\n    {\n        List< ? > stats = Collections.emptyList();\n\n        XWikiStatsService statsService =\n            getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (statsService != null) {\n            stats = statsService.getVisitStatistics(action, period, range, getXWikiContext());\n        }\n\n        return stats;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieves back-link statistics.\n     * \n     * @param domain The domain used for filtering the results\n     * @param scope The scope of referred documents for which to retrieve statistics.\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of DocumentStats objects\n     */\n    public List getBackLinkStatistics(String domain, Scope scope, Period period, Range range)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getBackLinkStatistics(domain, scope, period, range, getXWikiContext());\n    }","id":89674,"modified_method":"/**\n     * Retrieves back-link statistics.\n     * \n     * @param domain the domain used for filtering the results\n     * @param scope the scope of referred documents for which to retrieve statistics.\n     * @param period the period of time\n     * @param range the sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return a list of DocumentStats objects\n     */\n    public List< ? > getBackLinkStatistics(String domain, Scope scope, Period period, Range range)\n    {\n        List< ? > stats = Collections.emptyList();\n\n        XWikiStatsService statsService =\n            getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (statsService != null) {\n            stats =\n                statsService.getBackLinkStatistics(domain, scope, period, range,\n                    getXWikiContext());\n        }\n\n        return stats;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieves referrer statistics.\n     * \n     * @param domain The domain for which to retrieve statistics. To retrieve statistics for all\n     *            domains use the empty string.\n     * @param scope The scope of referred documents to use for filtering the results.\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of RefererStats objects\n     */\n    public List getRefererStatistics(String domain, Scope scope, Period period, Range range)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getRefererStatistics(domain, scope, period, range, getXWikiContext());\n    }","id":89675,"modified_method":"/**\n     * Retrieves referrer statistics.\n     * \n     * @param domain The domain for which to retrieve statistics. To retrieve statistics for all\n     *            domains use the empty string.\n     * @param scope The scope of referred documents to use for filtering the results.\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of RefererStats objects\n     */\n    public List< ? > getRefererStatistics(String domain, Scope scope, Period period, Range range)\n    {\n        List< ? > stats = Collections.emptyList();\n\n        XWikiStatsService statsService =\n            getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (statsService != null) {\n            stats =\n                statsService\n                    .getRefererStatistics(domain, scope, period, range, getXWikiContext());\n        }\n\n        return stats;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public StatsService(XWikiContext context)\n    {\n        super(context);\n    }","id":89676,"modified_method":"/**\n     * Create new StatsService instance.\n     * \n     * @param context the XWiki context.\n     */\n    public StatsService(XWikiContext context)\n    {\n        super(context);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieves document statistics.\n     * \n     * @param action The action the results should be ordered by. It can be one of: \"view\", \"save\"\n     *            or \"download\". If the action is \"view\" then the documents are ordered by the\n     *            number of times they have been viewed so far.\n     * @param scope The set of documents for which to retrieve statistics\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of DocumentStats objects\n     */\n    public List getDocumentStatistics(String action, Scope scope, Period period, Range range)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getDocumentStatistics(action, scope, period, range, getXWikiContext());\n    }","id":89677,"modified_method":"/**\n     * Retrieves document statistics.\n     * \n     * @param action The action the results should be ordered by. It can be one of: \"view\", \"save\"\n     *            or \"download\". If the action is \"view\" then the documents are ordered by the\n     *            number of times they have been viewed so far.\n     * @param scope The set of documents for which to retrieve statistics\n     * @param period The period of time\n     * @param range The sub-range to return from the entire result set. Use this parameter for\n     *            pagination\n     * @return A list of DocumentStats objects\n     */\n    public List< ? > getDocumentStatistics(String action, Scope scope, Period period, Range range)\n    {\n        List< ? > stats = Collections.emptyList();\n\n        XWikiStatsService statsService =\n            getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (statsService != null) {\n            stats =\n                statsService.getDocumentStatistics(action, scope, period, range,\n                    getXWikiContext());\n        }\n\n        return stats;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Returns the recently visited pages for a specific action\n     * \n     * @param action (\"view\" or \"edit\")\n     * @param size how many recent actions to retrieve\n     * @return a ArrayList of document names\n     */\n    public java.util.Collection getRecentActions(String action, int size)\n    {\n        XWikiStatsService stats = getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (stats == null)\n            return Collections.EMPTY_LIST;\n        return stats.getRecentActions(action, size, getXWikiContext());\n    }","id":89678,"modified_method":"/**\n     * Returns the recently visited pages for a specific action.\n     * \n     * @param action (\"view\" or \"edit\").\n     * @param size how many recent actions to retrieve.\n     * @return a ArrayList of document names.\n     */\n    public java.util.Collection< ? > getRecentActions(String action, int size)\n    {\n        java.util.Collection< ? > stats = Collections.emptyList();\n\n        XWikiStatsService statsService =\n            getXWikiContext().getWiki().getStatsService(getXWikiContext());\n        if (statsService != null) {\n            stats = statsService.getRecentActions(action, size, getXWikiContext());\n        }\n\n        return stats;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Computes an integer representation of the passed date using the following format:\n     * <ul>\n     *   <li>\"yyyMMdd\" for {@link #PERIOD_DAY}<\/li>\n     *   <li>\"yyyMM\" for {@link #PERIOD_MONTH}<\/li>\n     * <\/ul>\n     * \n     * @param date the date for which to return an integer representation\n     * @param type the date type. It can be {@link #PERIOD_DAY} or {@link #PERIOD_MONTH}\n     * @return the integer representation of the specified date\n     * @see java.text.SimpleDateFormat\n     */\n    public static int getPeriodAsInt(Date date, int type)\n    {\n        Calendar cal = Calendar.getInstance();\n        if (date != null) {\n            cal.setTime(date);\n        }\n        if (type == PERIOD_MONTH) {\n            // The first month of the year is JANUARY which is 0\n            return cal.get(Calendar.YEAR) * 100 + (cal.get(Calendar.MONTH) + 1);\n        } else {\n            // The first day of the month has value 1\n            return cal.get(Calendar.YEAR) * 10000 + (cal.get(Calendar.MONTH) + 1) * 100\n                + cal.get(Calendar.DAY_OF_MONTH);\n        }\n    }","id":89679,"modified_method":"/**\n     * Computes an integer representation of the passed date using the following format:\n     * <ul>\n     * <li>\"yyyMMdd\" for {@link PeriodType#DAY}<\/li>\n     * <li>\"yyyMM\" for {@link PeriodType#MONTH}<\/li>\n     * <\/ul>.\n     * \n     * @param date the date for which to return an integer representation.\n     * @param type the date type. It can be {@link PeriodType#DAY} or {@link PeriodType#MONTH}.\n     * @return the integer representation of the specified date.\n     * @see java.text.SimpleDateFormat\n     */\n    public static int getPeriodAsInt(Date date, PeriodType type)\n    {\n        int period;\n\n        Calendar cal = Calendar.getInstance();\n        if (date != null) {\n            cal.setTime(date);\n        }\n\n        if (type == PeriodType.MONTH) {\n            // The first month of the year is JANUARY which is 0\n            period = cal.get(Calendar.YEAR) * 100 + (cal.get(Calendar.MONTH) + 1);\n        } else {\n            // The first day of the month has value 1\n            period =\n                cal.get(Calendar.YEAR) * 10000 + (cal.get(Calendar.MONTH) + 1) * 100\n                    + cal.get(Calendar.DAY_OF_MONTH);\n        }\n\n        return period;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Test for the {@link StatsUtil#getPeriodAsInt(java.util.Date, int)}\n     */\n    public void testGetPeriodAsInt()\n    {\n        Calendar cal = Calendar.getInstance();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMM\");\n        String a = sdf.format(cal.getTime());\n        String b = StatsUtil.getPeriodAsInt(cal.getTime(), StatsUtil.PERIOD_MONTH) + \"\";\n        assertEquals(\"Wrong month period format\", a, b);\n\n        sdf = new SimpleDateFormat(\"yyyyMMdd\");\n        a = sdf.format(cal.getTime());\n        b = StatsUtil.getPeriodAsInt(cal.getTime(), StatsUtil.PERIOD_DAY) + \"\";\n        assertEquals(\"Wrong day period format\", a, b);\n    }","id":89680,"modified_method":"/**\n     * Test for the {@link StatsUtil#getPeriodAsInt(java.util.Date, PeriodType)}.\n     */\n    public void testGetPeriodAsInt()\n    {\n        Calendar cal = Calendar.getInstance();\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMM\");\n        String a = sdf.format(cal.getTime());\n        String b = StatsUtil.getPeriodAsInt(cal.getTime(), PeriodType.MONTH) + \"\";\n        assertEquals(\"Wrong month period format\", a, b);\n\n        sdf = new SimpleDateFormat(\"yyyyMMdd\");\n        a = sdf.format(cal.getTime());\n        b = StatsUtil.getPeriodAsInt(cal.getTime(), PeriodType.DAY) + \"\";\n        assertEquals(\"Wrong day period format\", a, b);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Date getEndDate() {\n        return getDateValue(\"endDate\");\n    }","id":89681,"modified_method":"/**\n     * @return the ending date of the user visit.\n     */\n    public Date getEndDate()\n    {\n        return getDateValue(Property.endDate.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setPageSaves(int pageSaves) {\n        setIntValue(\"pageSaves\", pageSaves);\n    }","id":89682,"modified_method":"/**\n     * @param pageSaves the number of saved pages during this visit.\n     */\n    public void setPageSaves(int pageSaves)\n    {\n        setIntValue(Property.pageSaves.toString(), pageSaves);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setDownloads(int downloads) {\n        setIntValue(\"downloads\", downloads);\n    }","id":89683,"modified_method":"/**\n     * @param downloads the number of downloaded pages during this visit.\n     */\n    public void setDownloads(int downloads)\n    {\n        setIntValue(Property.downloads.toString(), downloads);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public VisitStats getOldObject() {\n        return oldObject;\n    }","id":89684,"modified_method":"/**\n     * @return the previous visit object.\n     */\n    public VisitStats getOldObject()\n    {\n        return oldObject;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setEndDate(Date endDate) {\n        setDateValue(\"endDate\", endDate);\n    }","id":89685,"modified_method":"/**\n     * @param endDate the ending date of the user visit.\n     */\n    public void setEndDate(Date endDate)\n    {\n        setDateValue(Property.endDate.toString(), endDate);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getIP() {\n        return getStringValue(\"ip\");\n    }","id":89686,"modified_method":"/**\n     * @return the IP address of the user.\n     */\n    public String getIP()\n    {\n        return getStringValue(Property.ip.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  incDownloads() {\n        setIntValue(\"downloads\", getDownloads() + 1);\n    }","id":89687,"modified_method":"/**\n     * Add 1 to the number of downloaded pages during this visit.\n     */\n    public void incDownloads()\n    {\n        setIntValue(Property.downloads.toString(), getDownloads() + 1);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setUniqueID(String uniqueID) {\n        // Changing the unique ID is changing the number\n        if (getStartDate()!=null) {\n         String nb =  uniqueID + getStartDate().getTime();\n         setNumber(nb.hashCode());\n        }\n        setStringValue(\"uniqueID\", uniqueID);\n    }","id":89688,"modified_method":"/**\n     * @param uniqueID the unique id of the user visit.\n     */\n    public void setUniqueID(String uniqueID)\n    {\n        // Changing the unique ID is changing the number\n        if (getStartDate() != null) {\n            String nb = uniqueID + getStartDate().getTime();\n            setNumber(nb.hashCode());\n        }\n\n        setStringValue(Property.uniqueID.toString(), uniqueID);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getUniqueID() {\n        return getStringValue(\"uniqueID\");\n    }","id":89689,"modified_method":"/**\n     * @return the unique id of the user visit.\n     */\n    public String getUniqueID()\n    {\n        return getStringValue(Property.uniqueID.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getDownloads() {\n        return getIntValue(\"downloads\");\n    }","id":89690,"modified_method":"/**\n     * @return the number of downloaded pages during this visit.\n     */\n    public int getDownloads()\n    {\n        return getIntValue(Property.downloads.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void unrememberOldObject() {\n        oldObject=null;\n    }","id":89691,"modified_method":"/**\n     * Set old visit object to null.\n     */\n    public void unrememberOldObject()\n    {\n        oldObject = null;\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  incPageSaves() {\n        setIntValue(\"pageSaves\", getPageSaves() + 1);\n    }","id":89692,"modified_method":"/**\n     * Add 1 to the number of saved pages during this visit.\n     */\n    public void incPageSaves()\n    {\n        setIntValue(Property.pageSaves.toString(), getPageSaves() + 1);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getUserAgent() {\n        return getStringValue(\"userAgent\");\n    }","id":89693,"modified_method":"/**\n     * @return the user agent of the user.\n     */\n    public String getUserAgent()\n    {\n        return getStringValue(Property.userAgent.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Date getStartDate() {\n        return getDateValue(\"startDate\");\n    }","id":89694,"modified_method":"/**\n     * @return the starting date of the user visit.\n     */\n    public Date getStartDate()\n    {\n        return getDateValue(Property.startDate.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setUserAgent(String userAgent) {\n        setStringValue(\"userAgent\", StringUtils.defaultString(userAgent));\n    }","id":89695,"modified_method":"/**\n     * @param userAgent the user agent of the user.\n     */\n    public void setUserAgent(String userAgent)\n    {\n        setStringValue(Property.userAgent.toString(), StringUtils.defaultString(userAgent));\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getPageSaves() {\n        return getIntValue(\"pageSaves\");\n    }","id":89696,"modified_method":"/**\n     * @return the number of saved pages during this visit.\n     */\n    public int getPageSaves()\n    {\n        return getIntValue(Property.pageSaves.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public VisitStats(String user, String uniqueID, String cookie, String ip, String userAgent, Date startDate, int periodtype) {\n        super(startDate, periodtype);\n        setName(user);\n        setClassName(\"internal\");\n        setStartDate(startDate);\n        setUniqueID(uniqueID);\n        setCookie(cookie);\n        setIP(ip);\n        setUserAgent(userAgent);\n    }","id":89697,"modified_method":"/**\n     * @param user the user name.\n     * @param uniqueID the visit object unique id.\n     * @param cookie the cookie id.\n     * @param ip the IP of the user.\n     * @param userAgent the user agent of the user.\n     * @param startDate the starting date of the visit.\n     * @param periodType the type of the period.\n     */\n    public VisitStats(String user, String uniqueID, String cookie, String ip, String userAgent,\n        Date startDate, PeriodType periodType)\n    {\n        super(startDate, periodType);\n\n        setName(user);\n        setClassName(\"internal\");\n        setStartDate(startDate);\n        setUniqueID(uniqueID);\n        setCookie(cookie);\n        setIP(ip);\n        setUserAgent(userAgent);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public VisitStats() {\n    }","id":89698,"modified_method":"/**\n     * Default {@link VisitStats} constructor.\n     */\n    public VisitStats()\n    {\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getCookie() {\n        return getStringValue(\"cookie\");\n    }","id":89699,"modified_method":"/**\n     * @return the cookie id of the user.\n     */\n    public String getCookie()\n    {\n        return getStringValue(Property.cookie.toString());\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setStartDate(Date startDate) {\n        setDateValue(\"startDate\", startDate);\n    }","id":89700,"modified_method":"/**\n     * @param startDate the starting date of the user visit.\n     */\n    public void setStartDate(Date startDate)\n    {\n        setDateValue(Property.startDate.toString(), startDate);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setIP(String ip) {\n        setStringValue(\"ip\", ip);\n    }","id":89701,"modified_method":"/**\n     * @param ip the IP address of the user.\n     */\n    public void setIP(String ip)\n    {\n        setStringValue(Property.ip.toString(), ip);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setUser(String user) {\n        setName(user);\n    }","id":89702,"modified_method":"/**\n     * @param user the user name.\n     */\n    public void setUser(String user)\n    {\n        setName(user);\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getUser() {\n        return getName();\n    }","id":89703,"modified_method":"/**\n     * @return the user name.\n     */\n    public String getUser()\n    {\n        return getName();\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void rememberOldObject(VisitStats vobject) {\n        if (oldObject==null)\n         oldObject = vobject;\n    }","id":89704,"modified_method":"/**\n     * Store previous object to be able to remove it from the database later.\n     * \n     * @param vobject the previous object.\n     */\n    public void rememberOldObject(VisitStats vobject)\n    {\n        if (oldObject == null) {\n            oldObject = vobject;\n        }\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setCookie(String cookie) {\n        setStringValue(\"cookie\", StringUtils.defaultString(cookie));\n    }","id":89705,"modified_method":"/**\n     * @param cookie the cookie id of the user.\n     */\n    public void setCookie(String cookie)\n    {\n        setStringValue(Property.cookie.toString(), StringUtils.defaultString(cookie));\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setId(int id) {\r\n    }","id":89706,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.objects.BaseCollection#setId(int)\r\n     */\r\n    @Override\r\n    public void setId(int id)\r\n    {\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public XWikiStats() {\r\n        super();\r\n    }","id":89707,"modified_method":"/**\r\n     * Default constructor.\r\n     */\r\n    public XWikiStats()\r\n    {\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getPageViews() {\r\n        return getIntValue(\"pageViews\");\r\n    }","id":89708,"modified_method":"/**\r\n     * @return the counter of view action of this statistic.\r\n     */\r\n    public int getPageViews()\r\n    {\r\n        return getIntValue(Property.pageViews.toString());\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public XWikiStats(Date period, int periodtype) {\r\n        setPeriod(StatsUtil.getPeriodAsInt(period, periodtype));\r\n    }","id":89709,"modified_method":"/**\r\n     * @param periodDate the period date.\r\n     * @param periodtype the period type.\r\n     */\r\n    public XWikiStats(Date periodDate, PeriodType periodtype)\r\n    {\r\n        setPeriod(StatsUtil.getPeriodAsInt(periodDate, periodtype));\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void fromXML(Element oel) throws XWikiException {\r\n        Element cel = oel.element(\"class\");\r\n        BaseClass bclass = new BaseClass();\r\n        if (cel!=null) {\r\n            bclass.fromXML(cel);\r\n            setClassName(bclass.getName());\r\n        }\r\n\r\n        setName(oel.element(\"name\").getText());\r\n        List list = oel.elements(\"property\");\r\n        for (int i=0;i<list.size();i++) {\r\n            Element pcel = (Element)((Element) list.get(i)).elements().get(0);\r\n            String name = pcel.getName();\r\n            PropertyClass pclass = (PropertyClass) bclass.get(name);\r\n            if (pclass!=null) {\r\n                BaseProperty property = pclass.newPropertyfromXML(pcel);\r\n                property.setName(name);\r\n                property.setObject(this);\r\n                safeput(name, property);\r\n            }\r\n        }\r\n    }","id":89710,"modified_method":"/**\r\n     * Initialize statistics object from XML schema.\r\n     * \r\n     * @param oel the XML root node containing statistics datas.\r\n     * @throws XWikiException error when parsing XML schema.\r\n     */\r\n    public void fromXML(Element oel) throws XWikiException\r\n    {\r\n        Element cel = oel.element(\"class\");\r\n        BaseClass bclass = new BaseClass();\r\n        if (cel != null) {\r\n            bclass.fromXML(cel);\r\n            setClassName(bclass.getName());\r\n        }\r\n\r\n        setName(oel.element(XMLNODE_NAME).getText());\r\n        List< ? > list = oel.elements(XMLNODE_PROPERTY);\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Element pcel = (Element) ((Element) list.get(i)).elements().get(0);\r\n            String name = pcel.getName();\r\n            PropertyClass pclass = (PropertyClass) bclass.get(name);\r\n            if (pclass != null) {\r\n                BaseProperty property = pclass.newPropertyfromXML(pcel);\r\n                property.setName(name);\r\n                property.setObject(this);\r\n                safeput(name, property);\r\n            }\r\n        }\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void setPeriod(int period) {\r\n        setIntValue(\"period\", period);\r\n    }","id":89711,"modified_method":"/**\r\n     * @param period the time when statistic was stored.\r\n     */\r\n    public void setPeriod(int period)\r\n    {\r\n        setIntValue(Property.period.toString(), period);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Element toXML(BaseClass bclass) {\r\n        Element oel = new DOMElement(\"object\");\r\n\r\n        // Add Class\r\n        if (bclass!=null) {\r\n        Collection fields = bclass.getFieldList();\r\n        if (fields.size()>0) {\r\n            oel.add(bclass.toXML());\r\n          }\r\n        }\r\n\r\n        Element el = new DOMElement(\"name\");\r\n        el.addText(getName());\r\n        oel.add(el);\r\n\r\n        el = new DOMElement(\"number\");\r\n        el.addText(getNumber() + \"\");\r\n        oel.add(el);\r\n\r\n        el = new DOMElement(\"className\");\r\n        el.addText(getClassName());\r\n        oel.add(el);\r\n\r\n        Iterator it = getFieldList().iterator();\r\n        while (it.hasNext()) {\r\n            Element pel = new DOMElement(\"property\");\r\n            PropertyInterface bprop = (PropertyInterface)it.next();\r\n            pel.add(bprop.toXML());\r\n            oel.add(pel);\r\n        }\r\n        return oel;\r\n    }","id":89712,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.objects.BaseCollection#toXML(com.xpn.xwiki.objects.classes.BaseClass)\r\n     */\r\n    @Override\r\n    public Element toXML(BaseClass bclass)\r\n    {\r\n        Element oel = new DOMElement(XMLNODE_OBJECT);\r\n\r\n        // Add Class\r\n        if (bclass != null) {\r\n            if (bclass.getFieldList().size() > 0) {\r\n                oel.add(bclass.toXML());\r\n            }\r\n        }\r\n\r\n        Element el = new DOMElement(XMLNODE_NAME);\r\n        el.addText(getName());\r\n        oel.add(el);\r\n\r\n        el = new DOMElement(XMLNODE_NUMBER);\r\n        el.addText(getNumber() + \"\");\r\n        oel.add(el);\r\n\r\n        el = new DOMElement(XMLNODE_CLASSNAME);\r\n        el.addText(getClassName());\r\n        oel.add(el);\r\n\r\n        for (Iterator< ? > it = getFieldList().iterator(); it.hasNext();) {\r\n            Element pel = new DOMElement(XMLNODE_PROPERTY);\r\n            PropertyInterface bprop = (PropertyInterface) it.next();\r\n            pel.add(bprop.toXML());\r\n            oel.add(pel);\r\n        }\r\n\r\n        return oel;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Object clone() {\r\n        BaseCollection object = (BaseCollection) super.clone();\r\n        return object;\r\n    }","id":89713,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.objects.BaseCollection#clone()\r\n     */\r\n    @Override\r\n    public Object clone()\r\n    {\r\n        BaseCollection object = (BaseCollection) super.clone();\r\n        return object;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getPeriod() {\r\n        return getIntValue(\"period\");\r\n    }","id":89714,"modified_method":"/**\r\n     * @return the time when statistic was stored.\r\n     */\r\n    public int getPeriod()\r\n    {\r\n        return getIntValue(Property.period.toString());\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean equals(Object obj) {\r\n        if (!super.equals(obj))\r\n            return false;\r\n\r\n        if (getNumber()!=((BaseCollection)obj).getNumber())\r\n            return false;\r\n\r\n        return true;\r\n    }","id":89715,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.objects.BaseCollection#equals(java.lang.Object)\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj)\r\n    {\r\n        if (!super.equals(obj)) {\r\n            return false;\r\n        }\r\n\r\n        if (getNumber() != ((BaseCollection) obj).getNumber()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  setPageViews(int pageViews) {\r\n        setIntValue(\"pageViews\", pageViews);\r\n    }","id":89716,"modified_method":"/**\r\n     * @param pageViews the counter of view action of this statistic.\r\n     */\r\n    public void setPageViews(int pageViews)\r\n    {\r\n        setIntValue(Property.pageViews.toString(), pageViews);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int hashCode() {\r\n        return (getName() + getClassName() + \"_\" + getNumber()).hashCode();\r\n    }","id":89717,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.objects.BaseCollection#hashCode()\r\n     */\r\n    @Override\r\n    public int hashCode()\r\n    {\r\n        return (getName() + getClassName() + \"_\" + getNumber()).hashCode();\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void  incPageViews() {\r\n        setIntValue(\"pageViews\", getPageViews() + 1);\r\n    }","id":89718,"modified_method":"/**\r\n     * Add 1 to the counter of view action of this statistic.\r\n     */\r\n    public void incPageViews()\r\n    {\r\n        setIntValue(Property.pageViews.toString(), getPageViews() + 1);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getDocumentStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    public List getDocumentStatistics(String action, Scope scope, Period period,\r\n        Range range, XWikiContext context)\r\n    {\r\n        String nameFilter = \"name like :name\";\r\n        boolean hasNameParam = true;\r\n        if (scope.getType() == Scope.SPACE_SCOPE && \"\".equals(scope.getName())) {\r\n            nameFilter = \"name not like '%.%' and name <> ''\";\r\n            hasNameParam = false;\r\n        }\r\n        String sortOrder = \"desc\";\r\n        if (range.getSize() < 0) {\r\n            sortOrder = \"asc\";\r\n        }\r\n        XWikiHibernateStore store = null;\r\n        try {\r\n            store = context.getWiki().getHibernateStore();\r\n            store.beginTransaction(context);\r\n            Session session = store.getSession(context);\r\n            Query query =\r\n                session\r\n                    .createQuery(\"select name, sum(pageViews) from DocumentStats where action=:action and \"\r\n                        + nameFilter\r\n                        + \" and :startDate <= period and period <= :endDate group by name order by sum(pageViews) \"\r\n                        + sortOrder);\r\n            query.setString(\"action\", action);\r\n            if (hasNameParam) {\r\n                query.setString(\"name\", scope.getPattern());\r\n            }\r\n            query.setInteger(\"startDate\", period.getStartCode());\r\n            query.setInteger(\"endDate\", period.getEndCode());\r\n\r\n            List results =\r\n                getDocumentStatistics(store.search(query, range.getAbsoluteSize(), range\r\n                    .getAbsoluteStart(), context), action);\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(results);\r\n            }\r\n            return results;\r\n        } catch (XWikiException e) {\r\n            return Collections.EMPTY_LIST;\r\n        } finally {\r\n            try {\r\n                store.endTransaction(context, false);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }","id":89719,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getDocumentStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    public List<DocumentStats> getDocumentStatistics(String action, Scope scope, Period period,\r\n        Range range, XWikiContext context)\r\n    {\r\n        List<DocumentStats> documentStatsList;\r\n\r\n        List<Object> paramList = new ArrayList<Object>(4);\r\n\r\n        String nameFilter = getHqlNameFilterFromScope(scope, paramList);\r\n\r\n        String sortOrder = getHqlSortOrderFromRange(range);\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n\r\n        try {\r\n            String query =\r\n                MessageFormat.format(\"select name, sum(pageViews) from DocumentStats\"\r\n                    + \" where {0} and action=? and ? <= period and period <= ?\"\r\n                    + \" group by name order by sum(pageViews) {1}\", nameFilter, sortOrder);\r\n\r\n            paramList.add(action);\r\n            paramList.add(period.getStartCode());\r\n            paramList.add(period.getEndCode());\r\n\r\n            List< ? > solist =\r\n                store.search(query, range.getAbsoluteSize(), range.getAbsoluteStart(), paramList,\r\n                    context);\r\n\r\n            documentStatsList = getDocumentStatistics(solist, action);\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(documentStatsList);\r\n            }\r\n        } catch (XWikiException e) {\r\n            documentStatsList = Collections.emptyList();\r\n        }\r\n\r\n        return documentStatsList;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Converts the rows retrieved from the database to a list of DocumentStats instances\r\n     * \r\n     * @param resultSet the result of a database query for document statistics\r\n     * @param action the action for which the statistics were retrieved\r\n     * @return a list of {@link com.xpn.xwiki.stats.impl.DocumentStats} objects\r\n     * @see #getDocumentStatistics(String, Scope, com.xpn.xwiki.criteria.impl.Period , Range , XWikiContext)\r\n     */\r\n    private List getDocumentStatistics(List resultSet, String action)\r\n    {\r\n        Date now = Calendar.getInstance().getTime();\r\n        List stats = new ArrayList(resultSet.size());\r\n        Iterator it = resultSet.iterator();\r\n        while (it.hasNext()) {\r\n            Object[] result = (Object[]) it.next();\r\n            // We can't represent a custom period (e.g. year, week or some time interval) in the\r\n            // database and thus we use a default one, which sould be ignored\r\n            DocumentStats docStats =\r\n                new DocumentStats((String) result[0], action, now, StatsUtil.PERIOD_DAY);\r\n            docStats.setPageViews(((Number) result[1]).intValue());\r\n            stats.add(docStats);\r\n        }\r\n        return stats;\r\n    }","id":89720,"modified_method":"/**\r\n     * Converts the rows retrieved from the database to a list of DocumentStats instances.\r\n     * \r\n     * @param resultSet the result of a database query for document statistics.\r\n     * @param action the action for which the statistics were retrieved.\r\n     * @return a list of {@link com.xpn.xwiki.stats.impl.DocumentStats} objects.\r\n     * @see #getDocumentStatistics(String, Scope, com.xpn.xwiki.criteria.impl.Period , Range ,\r\n     *      XWikiContext)\r\n     */\r\n    private List<DocumentStats> getDocumentStatistics(List< ? > resultSet, String action)\r\n    {\r\n        List<DocumentStats> documentStatsList = new ArrayList<DocumentStats>(resultSet.size());\r\n\r\n        Date now = Calendar.getInstance().getTime();\r\n\r\n        for (Iterator< ? > it = resultSet.iterator(); it.hasNext();) {\r\n            Object[] result = (Object[]) it.next();\r\n            // We can't represent a custom period (e.g. year, week or some time interval) in the\r\n            // database and thus we use a default one, which sould be ignored\r\n            DocumentStats docStats =\r\n                new DocumentStats((String) result[0], action, now, PeriodType.DAY);\r\n            docStats.setPageViews(((Number) result[1]).intValue());\r\n            documentStatsList.add(docStats);\r\n        }\r\n\r\n        return documentStatsList;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Collection getRecentActions(String action, int size, XWikiContext context) {\r\n        ArrayList list = new ArrayList();\r\n        if ((action.equals(\"view\")||(action.equals(\"save\")))) {\r\n            HttpSession session = context.getRequest().getSession();\r\n            Collection actions = (Collection) session.getAttribute(\"recent_\" + action);\r\n\r\n            if (actions!=null) {\r\n               Object[] actionsarray = actions.toArray();\r\n               CollectionUtils.reverseArray(actionsarray);\r\n               int nb = Math.min(actions.size(), size);\r\n               for (int i=0;i<nb;i++)\r\n                    list.add(actionsarray[i]);\r\n               }\r\n        }\r\n        return list;\r\n    }","id":89721,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.stats.api.XWikiStatsService#getRecentActions(java.lang.String, int,\r\n     *      com.xpn.xwiki.XWikiContext)\r\n     */\r\n    public Collection<Object> getRecentActions(String action, int size, XWikiContext context)\r\n    {\r\n        List<Object> list = new ArrayList<Object>();\r\n\r\n        if ((action.equals(ViewAction.VIEW_ACTION) || (action.equals(SaveAction.ACTION_NAME)))) {\r\n            HttpSession session = context.getRequest().getSession();\r\n            Collection< ? > actions =\r\n                (Collection< ? >) session.getAttribute(SESSPROP_RECENT_PREFFIX + action);\r\n\r\n            if (actions != null) {\r\n                Object[] actionsarray = actions.toArray();\r\n                CollectionUtils.reverseArray(actionsarray);\r\n                int nb = Math.min(actions.size(), size);\r\n                for (int i = 0; i < nb; i++) {\r\n                    list.add(actionsarray[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return list;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getActionStatistics(String, Scope, com.xpn.xwiki.criteria.impl.Period , com.xpn.xwiki.criteria.impl.Duration , XWikiContext)\r\n     */\r\n    public Map getActionStatistics(String action, Scope scope, Period period, Duration step,\r\n        XWikiContext context)\r\n    {\r\n        DateTime stepStart = new DateTime(period.getStart());\r\n        DateTime periodEnd = new DateTime(period.getEnd());\r\n        org.joda.time.Period stepDuration =\r\n            new org.joda.time.Period(step.getYears(), step.getMonths(), step.getWeeks(), step\r\n                .getDays(), 0, 0, 0, 0);\r\n        Map activity = new HashMap();\r\n        while (stepStart.compareTo(periodEnd) < 0) {\r\n            DateTime stepEnd = stepStart.plus(stepDuration);\r\n            if (stepEnd.compareTo(periodEnd) > 0) {\r\n                stepEnd = periodEnd;\r\n            }\r\n            List stats =\r\n                this.getDocumentStatistics(action, scope, new Period(stepStart.getMillis(),\r\n                    stepEnd.getMillis()), RangeFactory.FIRST, context);\r\n            int actionCount = 0;\r\n            if (stats.size() > 0) {\r\n                actionCount = ((DocumentStats) stats.get(0)).getPageViews();\r\n            }\r\n            activity.put(stepStart, new Integer(actionCount));\r\n            stepStart = stepEnd;\r\n        }\r\n        return activity;\r\n    }","id":89722,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getActionStatistics(String, Scope, com.xpn.xwiki.criteria.impl.Period ,\r\n     *      com.xpn.xwiki.criteria.impl.Duration , XWikiContext)\r\n     */\r\n    public Map<DateTime, Integer> getActionStatistics(String action, Scope scope, Period period,\r\n        Duration step, XWikiContext context)\r\n    {\r\n        DateTime stepStart = new DateTime(period.getStart());\r\n        DateTime periodEnd = new DateTime(period.getEnd());\r\n        org.joda.time.Period stepDuration =\r\n            new org.joda.time.Period(step.getYears(), step.getMonths(), step.getWeeks(), step\r\n                .getDays(), 0, 0, 0, 0);\r\n\r\n        Map<DateTime, Integer> activity = new HashMap<DateTime, Integer>();\r\n        while (stepStart.compareTo(periodEnd) < 0) {\r\n            DateTime stepEnd = stepStart.plus(stepDuration);\r\n            if (stepEnd.compareTo(periodEnd) > 0) {\r\n                stepEnd = periodEnd;\r\n            }\r\n            List<DocumentStats> stats =\r\n                getDocumentStatistics(action, scope, new Period(stepStart.getMillis(), stepEnd\r\n                    .getMillis()), RangeFactory.FIRST, context);\r\n            int actionCount = 0;\r\n            if (stats.size() > 0) {\r\n                actionCount = stats.get(0).getPageViews();\r\n            }\r\n            activity.put(stepStart, new Integer(actionCount));\r\n            stepStart = stepEnd;\r\n        }\r\n\r\n        return activity;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Converts the rows retrieved from the database to a list of VisitStats instances\r\n     * \r\n     * @param resultSet the result of a database query for visitor statistics\r\n     * @param startDate the start date used in the query\r\n     * @param endDate the end date used in the query\r\n     * @return a list of {@link com.xpn.xwiki.stats.impl.VisitStats} objects\r\n     * @see #getVisitStatistics(com.xpn.xwiki.criteria.impl.Period , Range , XWikiContext)\r\n     */\r\n    private List getVisitStatistics(List resultSet, DateTime startDate, DateTime endDate)\r\n    {\r\n        List stats = new ArrayList(resultSet.size());\r\n        Iterator it = resultSet.iterator();\r\n        while (it.hasNext()) {\r\n            Object[] result = (Object[]) it.next();\r\n            String name = (String) result[0];\r\n            String uniqueID = \"\";\r\n            String cookie = \"\";\r\n            String ip = \"\";\r\n            String userAgent = \"\";\r\n            int pageSaves = ((Number) result[1]).intValue();\r\n            int pageViews = ((Number) result[2]).intValue();\r\n            int downloads = ((Number) result[3]).intValue();\r\n            VisitStats vs =\r\n                new VisitStats(name, uniqueID, cookie, ip, userAgent, new Date(startDate\r\n                    .getMillis()), StatsUtil.PERIOD_DAY);\r\n            vs.setStartDate(new Date(startDate.getMillis()));\r\n            vs.setEndDate(new Date(endDate.getMillis()));\r\n            vs.setPageSaves(pageSaves);\r\n            vs.setPageViews(pageViews);\r\n            vs.setDownloads(downloads);\r\n            stats.add(vs);\r\n        }\r\n        return stats;\r\n    }","id":89723,"modified_method":"/**\r\n     * Converts the rows retrieved from the database to a list of VisitStats instances.\r\n     * \r\n     * @param resultSet the result of a database query for visitor statistics.\r\n     * @param startDate the start date used in the query.\r\n     * @param endDate the end date used in the query.\r\n     * @return a list of {@link com.xpn.xwiki.stats.impl.VisitStats} objects.\r\n     * @see #getVisitStatistics(com.xpn.xwiki.criteria.impl.Period , Range , XWikiContext)\r\n     */\r\n    private List<VisitStats> getVisitStatistics(List< ? > resultSet, DateTime startDate,\r\n        DateTime endDate)\r\n    {\r\n        List<VisitStats> stats = new ArrayList<VisitStats>(resultSet.size());\r\n\r\n        for (Iterator< ? > it = resultSet.iterator(); it.hasNext();) {\r\n            Object[] result = (Object[]) it.next();\r\n\r\n            String name = (String) result[0];\r\n            String uniqueID = \"\";\r\n            String cookie = \"\";\r\n            String ip = \"\";\r\n            String userAgent = \"\";\r\n            int pageSaves = ((Number) result[1]).intValue();\r\n            int pageViews = ((Number) result[2]).intValue();\r\n            int downloads = ((Number) result[3]).intValue();\r\n\r\n            VisitStats vs =\r\n                new VisitStats(name, uniqueID, cookie, ip, userAgent, new Date(startDate\r\n                    .getMillis()), PeriodType.DAY);\r\n            vs.setStartDate(new Date(startDate.getMillis()));\r\n            vs.setEndDate(new Date(endDate.getMillis()));\r\n            vs.setPageSaves(pageSaves);\r\n            vs.setPageViews(pageViews);\r\n            vs.setDownloads(downloads);\r\n\r\n            stats.add(vs);\r\n        }\r\n\r\n        return stats;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Converts the rows retrieved from the database to a list of\r\n     * {@link com.xpn.xwiki.stats.impl.RefererStats} instances\r\n     * \r\n     * @param resultSet The result of a database query for referer statistics\r\n     * @return A list of {@link com.xpn.xwiki.stats.impl.RefererStats} objects\r\n     * @see #getRefererStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    private List getRefererStatistics(List resultSet)\r\n    {\r\n        Date now = Calendar.getInstance().getTime();\r\n        List stats = new ArrayList(resultSet.size());\r\n        Iterator it = resultSet.iterator();\r\n        while (it.hasNext()) {\r\n            Object[] result = (Object[]) it.next();\r\n            // We can't represent a custom period (e.g. year, week or some time interval) in the\r\n            // database and thus we use a default one, which sould be ignored\r\n            RefererStats refStats =\r\n                new RefererStats(\"\", (String) result[0], now, StatsUtil.PERIOD_DAY);\r\n            refStats.setPageViews(((Number) result[1]).intValue());\r\n            stats.add(refStats);\r\n        }\r\n        return stats;\r\n    }","id":89724,"modified_method":"/**\r\n     * Converts the rows retrieved from the database to a list of\r\n     * {@link com.xpn.xwiki.stats.impl.RefererStats} instances.\r\n     * \r\n     * @param resultSet The result of a database query for referer statistics\r\n     * @return A list of {@link com.xpn.xwiki.stats.impl.RefererStats} objects\r\n     * @see #getRefererStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    private List<RefererStats> getRefererStatistics(List< ? > resultSet)\r\n    {\r\n        Date now = Calendar.getInstance().getTime();\r\n        List<RefererStats> stats = new ArrayList<RefererStats>(resultSet.size());\r\n\r\n        for (Iterator< ? > it = resultSet.iterator(); it.hasNext();) {\r\n            Object[] result = (Object[]) it.next();\r\n\r\n            // We can't represent a custom period (e.g. year, week or some time interval) in the\r\n            // database and thus we use a default one, which sould be ignored\r\n            RefererStats refStats = new RefererStats(\"\", (String) result[0], now, PeriodType.DAY);\r\n            refStats.setPageViews(((Number) result[1]).intValue());\r\n            stats.add(refStats);\r\n        }\r\n\r\n        return stats;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n      * Try to find the cookie of the current request or create it\r\n      *\r\n      * @param context The context of this request.\r\n      * @return The visiting session, retrieved from the database or created.\r\n      */\r\n    private boolean findCookie(XWikiContext context) {\r\n        if (context.get(\"stats_cookie\")!=null)\r\n         return false;\r\n\r\n        Cookie cookie = Util.getCookie(\"visitid\", context);\r\n        boolean newcookie = false;\r\n\r\n        // If the cookie does not exist we need to set it\r\n        if (cookie==null) {\r\n            cookie = addCookie(context);\r\n            newcookie = true;\r\n        }\r\n\r\n        context.put(\"stats_cookie\", cookie);\r\n        context.put(\"stats_newcookie\", new Boolean(newcookie));\r\n        return true;\r\n    }","id":89725,"modified_method":"/**\r\n     * Try to find the cookie of the current request or create it.\r\n     * \r\n     * @param context The context of this request.\r\n     * @return The visiting session, retrieved from the database or created.\r\n     */\r\n    private boolean findCookie(XWikiContext context)\r\n    {\r\n        if (context.get(CONTPROP_STATS_COOKIE) != null) {\r\n            return false;\r\n        }\r\n\r\n        Cookie cookie = Util.getCookie(COOKPROP_VISITID, context);\r\n        boolean newcookie = false;\r\n\r\n        // If the cookie does not exist we need to set it\r\n        if (cookie == null) {\r\n            cookie = addCookie(context);\r\n            newcookie = true;\r\n        }\r\n\r\n        context.put(CONTPROP_STATS_COOKIE, cookie);\r\n        context.put(CONTPROP_STATS_NEWCOOKIE, Boolean.valueOf(newcookie));\r\n\r\n        return true;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Initializes the Stats Service by inserting the notification rule\r\n     * to be notified of all actions on documents\r\n     * @param context\r\n     */\r\n    public void init(XWikiContext context) {\r\n        // Let's init the expirationDate for the cookie\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.set(2030,0,0);\r\n        expirationDate = cal.getTime();\r\n\r\n        cookieDomains = StringUtils.split(context.getWiki().Param(\"xwiki.authentication.cookiedomains\"),\",\");\r\n\r\n        // Adding the rule which will allow this module to be called on each page view\r\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.stats\",\"1\")))\r\n         context.getWiki().getNotificationManager().addGeneralRule(new XWikiActionRule(this, true, true));\r\n    }","id":89726,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.stats.api.XWikiStatsService#init(com.xpn.xwiki.XWikiContext)\r\n     */\r\n    public void init(XWikiContext context)\r\n    {\r\n        // Let's init the expirationDate for the cookie\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.set(2030, 0, 0);\r\n        cookieExpirationDate = cal.getTime();\r\n\r\n        cookieDomains = StringUtils.split(context.getWiki().Param(CFGPROP_COOKIEDOMAINS), \",\");\r\n\r\n        if (\"1\".equals(context.getWiki().Param(CFGPROP_STATS, \"1\"))) {\r\n            // Start statistics store thread\r\n            statsRegister = new XWikiStatsStoreService(context);\r\n            statsRegister.start();\r\n\r\n            // Adding the rule which will allow this module to be called on each page view\r\n            context.getWiki().getNotificationManager().addGeneralRule(\r\n                new XWikiActionRule(this, true, true));\r\n        }\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String getReferer(XWikiContext context) {\r\n        String referer = context.getRequest().getHeader(\"referer\");\r\n        try {\r\n            URL url = new URL(referer);\r\n            URL baseurl = context.getURL();\r\n            if (baseurl.getHost().equals(url.getHost()))\r\n                return null;\r\n            return referer;\r\n        } catch (MalformedURLException e) {\r\n            return null;\r\n        }\r\n    }","id":89727,"modified_method":"/**\r\n     * @param context the XWiki context.\r\n     * @return the referer.\r\n     */\r\n    private String getReferer(XWikiContext context)\r\n    {\r\n        String referer = context.getRequest().getHeader(REQPROP_REFERER);\r\n\r\n        try {\r\n            URL url = new URL(referer);\r\n            URL baseurl = context.getURL();\r\n            if (baseurl.getHost().equals(url.getHost())) {\r\n                referer = null;\r\n            }\r\n        } catch (MalformedURLException e) {\r\n            referer = null;\r\n        }\r\n\r\n        return referer;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected VisitStats findVisitByIPUA(String ipua, XWikiContext context) throws XWikiException {\r\n    \tDate cdate = new Date();\r\n        cdate = new Date(cdate.getTime() - 30 * 60 * 1000);\r\n    \tif (context.getWiki().getNotCacheStore() instanceof XWikiJcrStore) {\r\n    \t\tXWikiJcrStore store = (XWikiJcrStore) context.getWiki().getNotCacheStore();    \t\t\r\n    \t\ttry {\r\n    \t\t\tQueryManager qm = store.getObjectQueryManager(context);\r\n\t\t\t\tFilter filter = qm.createFilter(VisitStats.class)\r\n\t\t\t\t\t.addEqualTo(\"uniqueID\", ipua)\r\n\t\t\t\t\t.addGreaterThan(\"endDate\", cdate);\r\n\t\t\t\torg.apache.portals.graffito.jcr.query.Query query = qm.createQuery(filter);\r\n\t\t\t\tquery.addOrderByDescending(\"endDate\");\r\n\t\t\t\tList solist = store.getObjects(query, context);\r\n\t\t\t\tif (solist.size()>0)\r\n\t\t\t\t\treturn (VisitStats) solist.get(0);\r\n\t\t\t    else\r\n\t\t\t    \treturn null;\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n    \t}\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        try {\r\n        store.beginTransaction(context);\r\n        Session session = store.getSession(context);\r\n        Query query = session.createQuery(\"from VisitStats as obj where obj.uniqueID=:ipua and obj.endDate > :cdate order by obj.endDate desc\");\r\n        query.setString(\"ipua\", ipua);\r\n        query.setDate(\"cdate\", cdate);\r\n\r\n        List solist = store.search(query, 0, 0, context);\r\n        if (solist.size()>0)\r\n         return (VisitStats) solist.get(0);\r\n        else\r\n         return null;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        } finally {\r\n            try {\r\n            store.endTransaction(context, false);\r\n            } catch (Exception e) {}\r\n        }\r\n    }","id":89728,"modified_method":"/**\r\n     * Search visit statistics object in the database based on visit unique id.\r\n     * \r\n     * @param uniqueID the visit unique id.\r\n     * @param context the XWiki context.\r\n     * @return the visit object.\r\n     * @throws XWikiException error when searching for visit object.\r\n     */\r\n    protected VisitStats findVisitByIPUA(String uniqueID, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        return findVisitByField(\"uniqueID\", uniqueID, context);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Cookie addCookie(XWikiContext context) {\r\n      Cookie cookie = new Cookie(\"visitid\", RandomStringUtils.randomAlphanumeric(32).toUpperCase());\r\n      cookie.setPath(\"/\");\r\n\r\n     int time = (int)(expirationDate.getTime() - (new Date()).getTime())/1000;\r\n     cookie.setMaxAge(time);\r\n\r\n     String cookieDomain = null;\r\n     if (cookieDomains!=null) {\r\n        String servername = context.getRequest().getServerName();\r\n        for (int i=0;i<cookieDomains.length;i++) {\r\n         if (servername.indexOf(cookieDomains[i])!=-1) {\r\n           cookieDomain = cookieDomains[i];\r\n           break;\r\n         }\r\n        }\r\n    }\r\n\r\n    if (cookieDomain!=null) {\r\n            cookie.setDomain(cookieDomain);\r\n    }\r\n\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Setting cookie \" + cookie.getValue() + \" for name \" + cookie.getName()\r\n                + \" with domain \" + cookie.getDomain() + \" and path \" + cookie.getPath()\r\n                + \" and maxage \" + cookie.getMaxAge());\r\n    }\r\n\r\n    context.getResponse().addCookie(cookie);\r\n    return cookie;\r\n   }","id":89729,"modified_method":"/**\r\n     * Create a new visit cookie and return it.\r\n     * \r\n     * @param context the XWiki context.\r\n     * @return the newly created cookie.\r\n     */\r\n    protected Cookie addCookie(XWikiContext context)\r\n    {\r\n        Cookie cookie =\r\n            new Cookie(COOKPROP_VISITID, RandomStringUtils.randomAlphanumeric(32).toUpperCase());\r\n        cookie.setPath(\"/\");\r\n\r\n        int time = (int) (cookieExpirationDate.getTime() - (new Date()).getTime()) / 1000;\r\n        cookie.setMaxAge(time);\r\n\r\n        String cookieDomain = null;\r\n        if (cookieDomains != null) {\r\n            String servername = context.getRequest().getServerName();\r\n            for (int i = 0; i < cookieDomains.length; i++) {\r\n                if (servername.indexOf(cookieDomains[i]) != -1) {\r\n                    cookieDomain = cookieDomains[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (cookieDomain != null) {\r\n            cookie.setDomain(cookieDomain);\r\n        }\r\n\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Setting cookie \" + cookie.getValue() + \" for name \" + cookie.getName()\r\n                + \" with domain \" + cookie.getDomain() + \" and path \" + cookie.getPath()\r\n                + \" and maxage \" + cookie.getMaxAge());\r\n        }\r\n\r\n        context.getResponse().addCookie(cookie);\r\n\r\n        return cookie;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Gets monthly statistics on a document for a specific action\r\n     * @param docname\r\n     * @param action\r\n     * @param month\r\n     * @param context\r\n     * @return\r\n     */\r\n    public DocumentStats getDocMonthStats(String docname, String action, Date month, XWikiContext context) {\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        DocumentStats object = new DocumentStats(docname, action, month, StatsUtil.PERIOD_MONTH);\r\n        try {\r\n            store.loadXWikiCollection(object, context, true);\r\n            return object;\r\n        } catch (XWikiException e) {\r\n            e.printStackTrace();\r\n            return new DocumentStats();\r\n        }\r\n    }","id":89730,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.stats.api.XWikiStatsService#getDocMonthStats(java.lang.String,\r\n     *      java.lang.String, java.util.Date, com.xpn.xwiki.XWikiContext)\r\n     */\r\n    @Deprecated\r\n    public DocumentStats getDocMonthStats(String docname, String action, Date month,\r\n        XWikiContext context)\r\n    {\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        DocumentStats object = new DocumentStats(docname, action, month, PeriodType.MONTH);\r\n        try {\r\n            store.loadXWikiCollection(object, context, true);\r\n            return object;\r\n        } catch (XWikiException e) {\r\n            e.printStackTrace();\r\n            return new DocumentStats();\r\n        }\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n      * Try to find the visiting session of the current request, or create a new one\r\n      * if this request is not part of a visit.\r\n      *\r\n      * The session is searched in the following way:\r\n      * <ol><li>the java session is searched for the visit object<\/li>\r\n      * <li>try to find the stored session using the cookie<\/li>\r\n      * <li>try to find the session by matching the IP and User Agent<\/li><\/ol>\r\n      * The session is invalidated if:\r\n      * <ul><li>the cookie is not the same as the stored cookie<\/li>\r\n      * <li>more than 30 minutes have elapsed from the previos request<\/li>\r\n      * <li>the user is not the same<\/li><\/ul>\r\n      *\r\n      * @param context The context of this request.\r\n      * @return The visiting session, retrieved from the database or created.\r\n      */\r\n    private VisitStats findVisit(XWikiContext context) {\r\n        XWikiRequest request = context.getRequest();\r\n        HttpSession session = request.getSession(true);\r\n        String ip = null, ua = null;\r\n\r\n        VisitStats vobject = (VisitStats) session.getAttribute(\"visitObject\");\r\n\r\n        Date nowDate = new Date();\r\n        Cookie cookie = (Cookie) context.get(\"stats_cookie\");\r\n        boolean newcookie = ((Boolean)context.get(\"stats_newcookie\")).booleanValue();\r\n\r\n        if (vobject==null) {\r\n           if (!newcookie) {\r\n               try {\r\n                   vobject = findVisitByCookie(cookie.getValue(), context);\r\n               } catch (XWikiException e) {\r\n                   e.printStackTrace();\r\n               }\r\n           } else {\r\n               try {\r\n                   ip = request.getRemoteAddr();\r\n                   ua = request.getHeader(\"User-Agent\");\r\n                   vobject = findVisitByIPUA(ip + ua, context);\r\n               } catch (XWikiException e) {\r\n                   e.printStackTrace();\r\n               }\r\n\r\n           }\r\n        }\r\n\r\n        if (vobject!=null) {\r\n            // Let's verify if the session is valid\r\n            // If the cookie is not the same\r\n            if (!vobject.getCookie().equals(cookie.getValue())) {\r\n                // Let's log a message here\r\n                // Since the session is also maintained using a cookie\r\n                // then there is something wrong here\r\n                if (log.isDebugEnabled())\r\n                  log.debug(\"Found visit with cookie \" + vobject.getCookie() + \" in session \"\r\n                           + session.getId() + \" for request with cookie \" + cookie.getValue());\r\n                // And forget about this session\r\n                vobject = null;\r\n            } else if ((nowDate.getTime() - vobject.getEndDate().getTime()) > 30 * 60 * 1000) {\r\n                // If session is longer than 30 minutes we should invalidate it\r\n                // and create a new one\r\n                vobject = null;\r\n            } else if(vobject != null && !context.getUser().equals(vobject.getName())) {\r\n                // If the user is not the same, we should invalidate the session\r\n                // and create a new one\r\n                vobject = null;\r\n            }\r\n        }\r\n\r\n        if (vobject==null) {\r\n            // we need to create the session\r\n            if (ip == null) ip = request.getRemoteAddr();\r\n            if (ua == null) ua = request.getHeader(\"User-Agent\");\r\n            if (ua == null) {\r\n                ua = \"\";\r\n            }\r\n            String uniqueID;\r\n\r\n            if (newcookie) {\r\n                // We cannot yet ID the user using the cookie\r\n                // we need to use the IP and UA\r\n                uniqueID = ip + ua;\r\n            } else {\r\n             // In this case we got the cookie from the request\r\n             // so we id the user using the cookie\r\n              uniqueID = cookie.getValue();\r\n            }\r\n\r\n            vobject = new VisitStats(context.getUser(), uniqueID, cookie.getValue(),\r\n                                     ip, ua, nowDate, StatsUtil.PERIOD_MONTH);\r\n            vobject.setEndDate(nowDate);\r\n        } else {\r\n            if (!newcookie) {\r\n             // If the cookie is not yet the unique ID we need to change that\r\n             String uniqueID = vobject.getUniqueID();\r\n             String oldcookie = vobject.getCookie();\r\n\r\n             if (!uniqueID.equals(oldcookie)) {\r\n              // We need to store the oldID so that we can remove the older entry\r\n              // since the entry identifiers are changing\r\n              VisitStats newvobject = (VisitStats) vobject.clone();\r\n              newvobject.rememberOldObject(vobject);\r\n              newvobject.setUniqueID(cookie.getValue());\r\n              vobject = newvobject;\r\n             }\r\n            }\r\n\r\n            if ((!context.getUser().equals(\"XWiki.XWikiGuest\"))\r\n                 &&(vobject.getUser().equals(\"XWiki.XWikiGuest\")))\r\n            {\r\n              // The user has changed from guest to an authenticated user\r\n              // We want to record this\r\n                VisitStats newvobject = vobject;\r\n                newvobject.rememberOldObject(vobject);\r\n                newvobject.setName(context.getUser());\r\n                vobject = newvobject;\r\n            }\r\n        }\r\n\r\n        // Keep the visit object in the session\r\n        session.setAttribute(\"visitObject\", vobject);\r\n        return vobject;\r\n    }","id":89731,"modified_method":"/**\r\n     * Try to find the visiting session of the current request, or create a new one if this request\r\n     * is not part of a visit. The session is searched in the following way:\r\n     * <ol>\r\n     * <li>the java session is searched for the visit object<\/li>\r\n     * <li>try to find the stored session using the cookie<\/li>\r\n     * <li>try to find the session by matching the IP and User Agent<\/li>\r\n     * <\/ol>\r\n     * The session is invalidated if:\r\n     * <ul>\r\n     * <li>the cookie is not the same as the stored cookie<\/li>\r\n     * <li>more than 30 minutes have elapsed from the previous request<\/li>\r\n     * <li>the user is not the same<\/li>\r\n     * <\/ul>\r\n     * \r\n     * @param context The context of this request.\r\n     * @return The visiting session, retrieved from the database or created.\r\n     */\r\n    private VisitStats findVisit(XWikiContext context)\r\n    {\r\n        XWikiRequest request = context.getRequest();\r\n        HttpSession session = request.getSession(true);\r\n        String ip = null;\r\n        String ua = null;\r\n\r\n        VisitStats visitObject = (VisitStats) session.getAttribute(SESSPROP_VISITOBJECT);\r\n\r\n        Date nowDate = new Date();\r\n        Cookie cookie = (Cookie) context.get(CONTPROP_STATS_COOKIE);\r\n        boolean newcookie = ((Boolean) context.get(CONTPROP_STATS_NEWCOOKIE)).booleanValue();\r\n\r\n        if (visitObject == null) {\r\n            if (!newcookie) {\r\n                try {\r\n                    visitObject = findVisitByCookie(cookie.getValue(), context);\r\n                } catch (XWikiException e) {\r\n                    LOG.error(\"Failed to find visit by cookie\", e);\r\n                }\r\n            } else {\r\n                try {\r\n                    ip = request.getRemoteAddr();\r\n                    ua = request.getHeader(REQPROP_USERAGENT);\r\n                    visitObject = findVisitByIPUA(ip + ua, context);\r\n                } catch (XWikiException e) {\r\n                    LOG.error(\"Failed to find visit by unique id\", e);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        if (visitObject != null) {\r\n            // Let's verify if the session is valid\r\n            // If the cookie is not the same\r\n            if (!visitObject.getCookie().equals(cookie.getValue())) {\r\n                // Let's log a message here\r\n                // Since the session is also maintained using a cookie\r\n                // then there is something wrong here\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Found visit with cookie \" + visitObject.getCookie()\r\n                        + \" in session \" + session.getId() + \" for request with cookie \"\r\n                        + cookie.getValue());\r\n                }\r\n\r\n                // And forget about this session\r\n                visitObject = null;\r\n            } else if ((nowDate.getTime() - visitObject.getEndDate().getTime()) > 30 * 60 * 1000) {\r\n                // If session is longer than 30 minutes we should invalidate it\r\n                // and create a new one\r\n                visitObject = null;\r\n            } else if (visitObject != null && !context.getUser().equals(visitObject.getName())) {\r\n                // If the user is not the same, we should invalidate the session\r\n                // and create a new one\r\n                visitObject = null;\r\n            }\r\n        }\r\n\r\n        if (visitObject == null) {\r\n            // we need to create the session\r\n            if (ip == null) {\r\n                ip = request.getRemoteAddr();\r\n            }\r\n            if (ua == null) {\r\n                ua = request.getHeader(REQPROP_USERAGENT);\r\n            }\r\n            if (ua == null) {\r\n                ua = \"\";\r\n            }\r\n            String uniqueID;\r\n\r\n            if (newcookie) {\r\n                // We cannot yet ID the user using the cookie\r\n                // we need to use the IP and UA\r\n                uniqueID = ip + ua;\r\n            } else {\r\n                // In this case we got the cookie from the request\r\n                // so we id the user using the cookie\r\n                uniqueID = cookie.getValue();\r\n            }\r\n\r\n            visitObject =\r\n                new VisitStats(context.getUser(), uniqueID, cookie.getValue(), ip, ua, nowDate,\r\n                    PeriodType.MONTH);\r\n            visitObject.setEndDate(nowDate);\r\n        } else {\r\n            if (!newcookie) {\r\n                // If the cookie is not yet the unique ID we need to change that\r\n                String uniqueID = visitObject.getUniqueID();\r\n                String oldcookie = visitObject.getCookie();\r\n\r\n                if (!uniqueID.equals(oldcookie)) {\r\n                    // We need to store the oldID so that we can remove the older entry\r\n                    // since the entry identifiers are changing\r\n                    VisitStats newVisitObject = (VisitStats) visitObject.clone();\r\n                    newVisitObject.rememberOldObject(visitObject);\r\n                    newVisitObject.setUniqueID(cookie.getValue());\r\n                    visitObject = newVisitObject;\r\n                }\r\n            }\r\n\r\n            if ((!context.getUser().equals(GUEST_FULLNAME))\r\n                && (visitObject.getUser().equals(GUEST_FULLNAME))) {\r\n                // The user has changed from guest to an authenticated user\r\n                // We want to record this\r\n                VisitStats newVisitObject = visitObject;\r\n                newVisitObject.rememberOldObject(visitObject);\r\n                newVisitObject.setName(context.getUser());\r\n                visitObject = newVisitObject;\r\n            }\r\n        }\r\n\r\n        // Keep the visit object in the session\r\n        session.setAttribute(SESSPROP_VISITOBJECT, visitObject);\r\n\r\n        return visitObject;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getBackLinkStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    public List getBackLinkStatistics(String domain, Scope scope, Period period,\r\n        Range range, XWikiContext context)\r\n    {\r\n        if (domain == null || domain.trim().length() == 0) {\r\n            domain = \"%\";\r\n        }\r\n        String nameFilter = \"name like :name\";\r\n        boolean hasNameParam = true;\r\n        if (scope.getType() == Scope.SPACE_SCOPE && \"\".equals(scope.getName())) {\r\n            nameFilter = \"name not like '%.%' and name <> ''\";\r\n            hasNameParam = false;\r\n        }\r\n        String sortOrder = \"desc\";\r\n        if (range.getSize() < 0) {\r\n            sortOrder = \"asc\";\r\n        }\r\n        XWikiHibernateStore store = null;\r\n        try {\r\n            store = context.getWiki().getHibernateStore();\r\n            store.beginTransaction(context);\r\n            Session session = store.getSession(context);\r\n            Query query =\r\n                session\r\n                    .createQuery(\"select name, sum(pageViews) from RefererStats where \"\r\n                        + nameFilter\r\n                        + \" and referer like :referer and :startDate <= period and period <= :endDate group by name order by sum(pageViews) \"\r\n                        + sortOrder);\r\n            if (hasNameParam) {\r\n                query.setString(\"name\", scope.getPattern());\r\n            }\r\n            query.setString(\"referer\", domain);\r\n            query.setInteger(\"startDate\", period.getStartCode());\r\n            query.setInteger(\"endDate\", period.getEndCode());\r\n\r\n            List results =\r\n                getDocumentStatistics(store.search(query, range.getAbsoluteSize(), range\r\n                    .getAbsoluteStart(), context), \"refer\");\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(results);\r\n            }\r\n            return results;\r\n        } catch (XWikiException e) {\r\n            return Collections.EMPTY_LIST;\r\n        } finally {\r\n            try {\r\n                store.endTransaction(context, false);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }","id":89732,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getBackLinkStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    public List<DocumentStats> getBackLinkStatistics(String domain, Scope scope, Period period,\r\n        Range range, XWikiContext context)\r\n    {\r\n        List<DocumentStats> documentStatsList;\r\n\r\n        List<Object> paramList = new ArrayList<Object>(4);\r\n\r\n        String nameFilter = getHqlNameFilterFromScope(scope, paramList);\r\n\r\n        String sortOrder = getHqlSortOrderFromRange(range);\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        try {\r\n            String query =\r\n                MessageFormat.format(\"select name, sum(pageViews) from RefererStats\"\r\n                    + \" where {0} and referer like ? and ? <= period and period <= ?\"\r\n                    + \" group by name order by sum(pageViews) {1}\", nameFilter, sortOrder);\r\n\r\n            paramList.add(getHqlValidDomain(domain));\r\n            paramList.add(period.getStartCode());\r\n            paramList.add(period.getEndCode());\r\n\r\n            List< ? > solist =\r\n                store.search(query, range.getAbsoluteSize(), range.getAbsoluteStart(), paramList,\r\n                    context);\r\n\r\n            documentStatsList = getDocumentStatistics(solist, \"refer\");\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(documentStatsList);\r\n            }\r\n        } catch (XWikiException e) {\r\n            documentStatsList = Collections.emptyList();\r\n        }\r\n\r\n        return documentStatsList;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Gets total statistics on a document for a specific action\r\n     *\r\n     * @param docname fully qualified document named\r\n     * @param action can be \"view\", \"edit\", \"save\", etc..\r\n     * @param context\r\n     * @return DocStats - statistics object\r\n     */\r\n    public DocumentStats getDocTotalStats(String docname, String action, XWikiContext context) {\r\n        return new DocumentStats();\r\n    }","id":89733,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.stats.api.XWikiStatsService#getDocTotalStats(java.lang.String,\r\n     *      java.lang.String, com.xpn.xwiki.XWikiContext)\r\n     */\r\n    @Deprecated\r\n    public DocumentStats getDocTotalStats(String docname, String action, XWikiContext context)\r\n    {\r\n        return new DocumentStats();\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Gets daily statistics on a document for a specific action\r\n     * @param docname\r\n     * @param action\r\n     * @param day\r\n     * @param context\r\n     * @return\r\n     */\r\n    public DocumentStats getDocDayStats(String docname, String action, Date day, XWikiContext context) {\r\n        return new DocumentStats();\r\n    }","id":89734,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.stats.api.XWikiStatsService#getDocDayStats(java.lang.String,\r\n     *      java.lang.String, java.util.Date, com.xpn.xwiki.XWikiContext)\r\n     */\r\n    @Deprecated\r\n    public DocumentStats getDocDayStats(String docname, String action, Date day,\r\n        XWikiContext context)\r\n    {\r\n        return new DocumentStats();\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Notification rule to store usage statistics\r\n     * @param rule\r\n     * @param doc\r\n     * @param action\r\n     * @param context\r\n     */\r\n    public void notify(XWikiNotificationRule rule, XWikiDocument doc, String action, XWikiContext context) {\r\n\r\n        if (context.getWiki().isReadOnly()) {\r\n            // the server is in read-only mode, forget about the statistics\r\n            return;\r\n        }\r\n        // Unless this is a \"view\", \"save\" or \"download\" action, we are not interested\r\n        if (!(action.equals(\"view\")||action.equals(\"save\")||action.equals(\"download\")))\r\n            return;\r\n\r\n        if (findCookie(context)) {\r\n            return;\r\n        }\r\n\r\n        // Let's save in the session the last elements view, saved\r\n        synchronized (this) {\r\n            if (!action.equals(\"download\")) {\r\n                HttpSession session = context.getRequest().getSession();\r\n                Collection actions = (Collection) session.getAttribute(\"recent_\" + action);\r\n                if (actions==null) {\r\n                    actions = new CircularFifoBuffer(context.getWiki().getXWikiPreferenceAsInt(\"recent_visits_size\", 20, context));\r\n                    session.setAttribute(\"recent_\" + action, actions);\r\n                }\r\n                String element = context.getDatabase() + \":\" + doc.getFullName();\r\n                if (actions.contains(element))\r\n                    actions.remove(element);\r\n                actions.add(element);\r\n            }\r\n        }\r\n\r\n        // Let's check if this wiki should have statistics disabled\r\n        String statsdefault = context.getWiki().Param(\"xwiki.stats.default\");\r\n        String statsactive = context.getWiki().getXWikiPreference(\"statistics\", \"\", context);\r\n        if (\"0\".equals(statsactive))\r\n            return;\r\n        // If nothing is said we use the default parameter\r\n        if ((\"\".equals(statsactive))&&(\"0\".equals(statsdefault)))\r\n            return;\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        if (store == null) return;\r\n\r\n        VisitStats vobject = findVisit(context);\r\n        synchronized(vobject) {\r\n            // We count page views in the sessions only for the \"view\" action\r\n            if (action.equals(\"view\"))\r\n                vobject.incPageViews();\r\n                // We count \"save\" and \"download\" actions separately\r\n            else if (action.equals(\"save\"))\r\n                vobject.incPageSaves();\r\n            else if (action.equals(\"download\"))\r\n                vobject.incDownloads();\r\n\r\n            vobject.setEndDate(new Date());\r\n            try {\r\n                // In case we have store the old object\r\n                // then we need to remove it\r\n                // before saving the other one\r\n                // because the ID info have changed\r\n                VisitStats oldObject  = vobject.getOldObject();\r\n                if (oldObject!=null) {\r\n                    // Catch exception to not fail here\r\n                    try {\r\n                        store.deleteXWikiCollection(oldObject, context, true, true);\r\n                        vobject.unrememberOldObject();\r\n                    } catch (Exception e) {}\r\n                }\r\n\r\n                store.saveXWikiCollection(vobject, context, true);\r\n            } catch (XWikiException e) {\r\n                // Statistics should never make xwiki fail !\r\n                e.printStackTrace();\r\n            }\r\n\r\n            addPageView(doc.getFullName(), action, StatsUtil.PERIOD_MONTH, store, context, vobject);\r\n            addPageView(doc.getSpace(), action, StatsUtil.PERIOD_MONTH, store, context, vobject);\r\n            addPageView(\"\", action, StatsUtil.PERIOD_MONTH, store, context, vobject);\r\n            addPageView(doc.getFullName(), action, StatsUtil.PERIOD_DAY, store, context, vobject);\r\n            addPageView(doc.getSpace(), action, StatsUtil.PERIOD_DAY, store, context, vobject);\r\n            addPageView(\"\", action, StatsUtil.PERIOD_DAY, store, context, vobject);\r\n        }\r\n\r\n        // In case of a \"view\" action we want to store referer info\r\n        if (action.equals(\"view\")) {\r\n            String referer = getReferer(context);\r\n            if ((referer !=null)&&(!referer.equals(\"\"))) {\r\n                // Visits of the web\r\n                RefererStats robject = new RefererStats(doc.getFullName(), referer, new Date(), StatsUtil.PERIOD_MONTH);\r\n                synchronized(robject) {\r\n                    try {\r\n                        store.loadXWikiCollection(robject, context, true);\r\n                    } catch (XWikiException e) {\r\n                    }\r\n\r\n                    robject.incPageViews();\r\n                    try {\r\n                        store.saveXWikiCollection(robject, context, true);\r\n                    } catch (XWikiException e) {\r\n                        // Statistics should never make xwiki fail !\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }","id":89735,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.notify.XWikiActionNotificationInterface#notify(com.xpn.xwiki.notify.XWikiNotificationRule,\r\n     *      com.xpn.xwiki.doc.XWikiDocument, java.lang.String, com.xpn.xwiki.XWikiContext)\r\n     */\r\n    public void notify(XWikiNotificationRule rule, XWikiDocument doc, String action,\r\n        XWikiContext context)\r\n    {\r\n\r\n        if (context.getWiki().isReadOnly()) {\r\n            // the server is in read-only mode, forget about the statistics\r\n            return;\r\n        }\r\n        // Unless this is a \"view\", \"save\" or \"download\" action, we are not interested\r\n        if (!action.equals(ViewAction.VIEW_ACTION) && !action.equals(SaveAction.ACTION_NAME)\r\n            && !action.equals(DownloadAction.ACTION_NAME)) {\r\n            return;\r\n        }\r\n\r\n        if (findCookie(context)) {\r\n            return;\r\n        }\r\n\r\n        // Let's save in the session the last elements view, saved\r\n        synchronized (this) {\r\n            if (!action.equals(DownloadAction.ACTION_NAME)) {\r\n                HttpSession session = context.getRequest().getSession();\r\n                Collection actions =\r\n                    (Collection) session.getAttribute(SESSPROP_RECENT_PREFFIX + action);\r\n                if (actions == null) {\r\n                    actions =\r\n                        new CircularFifoBuffer(context.getWiki().getXWikiPreferenceAsInt(\r\n                            PREFPROP_RECENT_VISITS_SIZE, 20, context));\r\n                    session.setAttribute(SESSPROP_RECENT_PREFFIX + action, actions);\r\n                }\r\n\r\n                String element = context.getDatabase() + \":\" + doc.getFullName();\r\n                if (actions.contains(element)) {\r\n                    actions.remove(element);\r\n                }\r\n                actions.add(element);\r\n            }\r\n        }\r\n\r\n        // Let's check if this wiki should have statistics disabled\r\n        String statsdefault = context.getWiki().Param(CFGPROP_STATS_DEFAULT);\r\n        String statsactive =\r\n            context.getWiki().getXWikiPreference(PREFPROP_STATISTICS, \"\", context);\r\n        if (\"0\".equals(statsactive)) {\r\n            return;\r\n        }\r\n        // If nothing is said we use the default parameter\r\n        if ((\"\".equals(statsactive)) && (\"0\".equals(statsdefault))) {\r\n            return;\r\n        }\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        if (store == null) {\r\n            return;\r\n        }\r\n\r\n        VisitStats vobject = findVisit(context);\r\n        synchronized (vobject) {\r\n            if (action.equals(ViewAction.VIEW_ACTION)) {\r\n                // We count page views in the sessions only for the \"view\" action\r\n                vobject.incPageViews();\r\n            } else if (action.equals(SaveAction.ACTION_NAME)) {\r\n                // We count \"save\" and \"download\" actions separately\r\n                vobject.incPageSaves();\r\n            } else if (action.equals(DownloadAction.ACTION_NAME)) {\r\n                // We count \"save\" and \"download\" actions separately\r\n                vobject.incDownloads();\r\n            }\r\n\r\n            Date currentDate = new Date();\r\n\r\n            vobject.setEndDate(currentDate);\r\n            this.statsRegister.add(new VisitStatsStoreItem(vobject, context));\r\n            vobject.unrememberOldObject();\r\n\r\n            boolean isVisit =\r\n                (vobject.getPageViews() == 1) && (action.equals(ViewAction.VIEW_ACTION));\r\n\r\n            this.statsRegister.add(new DocumentStatsStoreItem(doc.getFullName(), currentDate,\r\n                PeriodType.MONTH, action, isVisit, context));\r\n            this.statsRegister.add(new DocumentStatsStoreItem(doc.getSpace(), currentDate,\r\n                PeriodType.MONTH, action, isVisit, context));\r\n            this.statsRegister.add(new DocumentStatsStoreItem(\"\", currentDate, PeriodType.MONTH,\r\n                action, false, context));\r\n            this.statsRegister.add(new DocumentStatsStoreItem(doc.getFullName(), currentDate,\r\n                PeriodType.DAY, action, isVisit, context));\r\n            this.statsRegister.add(new DocumentStatsStoreItem(doc.getSpace(), currentDate,\r\n                PeriodType.DAY, action, isVisit, context));\r\n            this.statsRegister.add(new DocumentStatsStoreItem(\"\", currentDate, PeriodType.DAY,\r\n                action, false, context));\r\n        }\r\n\r\n        // In case of a \"view\" action we want to store referer info\r\n        if (action.equals(ViewAction.VIEW_ACTION)) {\r\n            String referer = getReferer(context);\r\n            if ((referer != null) && (!referer.equals(\"\"))) {\r\n                this.statsRegister.add(new RefererStatsStoreItem(doc.getFullName(), new Date(),\r\n                    PeriodType.MONTH, referer, context));\r\n            }\r\n        }\r\n\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List getRefMonthStats(String docname, Date month, XWikiContext context) throws XWikiException {\r\n    \tXWikiStoreInterface store = context.getWiki().getNotCacheStore();\r\n    \tList solist = new ArrayList();\r\n    \tif (store instanceof XWikiHibernateStore) {\r\n    \t\tsolist = ((XWikiHibernateStore)store).search(\"from RefererStats as obj where obj.name='\" + Utils.SQLFilter(docname) + \"'\", 0, 0, context);\r\n    \t} else if (store instanceof XWikiJcrStore) {\r\n    \t\tsolist = ((XWikiJcrStore)store).getAllObjectsByClass(RefererStats.class, context);\r\n    \t}\r\n        return solist;\r\n    }","id":89736,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see com.xpn.xwiki.stats.api.XWikiStatsService#getRefMonthStats(java.lang.String,\r\n     *      java.util.Date, com.xpn.xwiki.XWikiContext)\r\n     */\r\n    @Deprecated\r\n    public List< ? > getRefMonthStats(String docname, Date month, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        XWikiStoreInterface store = context.getWiki().getNotCacheStore();\r\n\r\n        List< ? > solist;\r\n        if (store instanceof XWikiHibernateStore) {\r\n            solist =\r\n                ((XWikiHibernateStore) store).search(\"from RefererStats as obj where obj.name='\"\r\n                    + Utils.SQLFilter(docname) + \"'\", 0, 0, context);\r\n        } else if (store instanceof XWikiJcrStore) {\r\n            solist = ((XWikiJcrStore) store).getAllObjectsByClass(RefererStats.class, context);\r\n        } else {\r\n            solist = Collections.emptyList();\r\n        }\r\n\r\n        return solist;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getRefererStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    public List getRefererStatistics(String domain, Scope scope, Period period,\r\n        Range range, XWikiContext context)\r\n    {\r\n        if (domain == null || domain.trim().length() == 0) {\r\n            domain = \"%\";\r\n        }\r\n        String nameFilter = \"name like :name\";\r\n        boolean hasNameParam = true;\r\n        if (scope.getType() == Scope.SPACE_SCOPE && \"\".equals(scope.getName())) {\r\n            nameFilter = \"name not like '%.%' and name <> ''\";\r\n            hasNameParam = false;\r\n        }\r\n        String sortOrder = \"desc\";\r\n        if (range.getSize() < 0) {\r\n            sortOrder = \"asc\";\r\n        }\r\n        XWikiHibernateStore store = null;\r\n        try {\r\n            store = context.getWiki().getHibernateStore();\r\n            store.beginTransaction(context);\r\n            Session session = store.getSession(context);\r\n            Query query =\r\n                session\r\n                    .createQuery(\"select referer, sum(pageViews) from RefererStats where \"\r\n                        + nameFilter\r\n                        + \" and referer like :referer and :startDate <= period and period <= :endDate group by referer order by sum(pageViews) \"\r\n                        + sortOrder);\r\n            if (hasNameParam) {\r\n                query.setString(\"name\", scope.getPattern());\r\n            }\r\n            query.setString(\"referer\", domain);\r\n            query.setInteger(\"startDate\", period.getStartCode());\r\n            query.setInteger(\"endDate\", period.getEndCode());\r\n\r\n            List results =\r\n                getRefererStatistics(store.search(query, range.getAbsoluteSize(), range\r\n                    .getAbsoluteStart(), context));\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(results);\r\n            }\r\n            return results;\r\n        } catch (XWikiException e) {\r\n            return Collections.EMPTY_LIST;\r\n        } finally {\r\n            try {\r\n                store.endTransaction(context, false);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }","id":89737,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getRefererStatistics(String, Scope, Period, Range , XWikiContext)\r\n     */\r\n    public List<RefererStats> getRefererStatistics(String domain, Scope scope, Period period,\r\n        Range range, XWikiContext context)\r\n    {\r\n        List<RefererStats> refererList;\r\n\r\n        List<Object> paramList = new ArrayList<Object>(4);\r\n\r\n        String nameFilter = getHqlNameFilterFromScope(scope, paramList);\r\n\r\n        String sortOrder = getHqlSortOrderFromRange(range);\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        try {\r\n            String query =\r\n                MessageFormat.format(\"select referer, sum(pageViews) from RefererStats\"\r\n                    + \" where {0} and referer like ? and ? <= period and period <= ?\"\r\n                    + \" group by referer order by sum(pageViews) {1}\", nameFilter, sortOrder);\r\n\r\n            paramList.add(getHqlValidDomain(domain));\r\n            paramList.add(period.getStartCode());\r\n            paramList.add(period.getEndCode());\r\n\r\n            List< ? > solist =\r\n                store.search(query, range.getAbsoluteSize(), range.getAbsoluteStart(), paramList,\r\n                    context);\r\n\r\n            refererList = getRefererStatistics(solist);\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(refererList);\r\n            }\r\n        } catch (XWikiException e) {\r\n            refererList = Collections.emptyList();\r\n        }\r\n\r\n        return refererList;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected VisitStats findVisitByCookie(String cookie, XWikiContext context) throws XWikiException {\r\n    \tDate cdate = new Date();\r\n        cdate = new Date(cdate.getTime() - 30 * 60 * 1000);\r\n    \tif (context.getWiki().getNotCacheStore() instanceof XWikiJcrStore) {\r\n    \t\tXWikiJcrStore store = (XWikiJcrStore) context.getWiki().getNotCacheStore();\r\n    \t\ttry {\r\n    \t\t\tQueryManager qm = store.getObjectQueryManager(context);\r\n\t\t\t\tFilter filter = qm.createFilter(VisitStats.class)\r\n\t\t\t\t\t.addEqualTo(\"coockie\", cookie)\r\n\t\t\t\t\t.addGreaterThan(\"endDate\", cdate);\r\n\t\t\t\torg.apache.portals.graffito.jcr.query.Query query = qm.createQuery(filter);\r\n\t\t\t\tquery.addOrderByDescending(\"endDate\");\r\n\t\t\t\tList solist = store.getObjects(query, context);\r\n\t\t\t\tif (solist.size()>0)\r\n\t\t\t\t\treturn (VisitStats) solist.get(0);\r\n\t\t\t    else\r\n\t\t\t    \treturn null;\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n    \t}\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        try {\r\n        store.beginTransaction(context);\r\n        Session session = store.getSession(context);\r\n        Query query = session.createQuery(\"from VisitStats as obj where obj.cookie=:cookie and obj.endDate > :cdate order by obj.endDate desc\");\r\n        query.setString(\"cookie\", cookie);\r\n        query.setDate(\"cdate\", cdate);\r\n\r\n        List solist = store.search(query, 0, 0, context);\r\n        if (solist.size()>0)\r\n         return (VisitStats) solist.get(0);\r\n        else\r\n         return null;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        } finally {\r\n            try {\r\n            store.endTransaction(context, false);\r\n            } catch (Exception e) {}\r\n        }\r\n    }","id":89738,"modified_method":"/**\r\n     * Search visit statistics object in the database based on cookie name.\r\n     * \r\n     * @param cookie the cookie name.\r\n     * @param context the XWiki context.\r\n     * @return the visit object, null if no object was found.\r\n     * @throws XWikiException error when searching for visit object.\r\n     */\r\n    protected VisitStats findVisitByCookie(String cookie, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        return findVisitByField(\"cookie\", cookie, context);\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getVisitStatistics(String, com.xpn.xwiki.criteria.impl.Period , Range , XWikiContext)\r\n     */\r\n    public List getVisitStatistics(String action, Period period, Range range,\r\n        XWikiContext context)\r\n    {\r\n        String sortOrder = \"desc\";\r\n        if (range.getSize() < 0) {\r\n            sortOrder = \"asc\";\r\n        }\r\n        String orderByClause =\r\n            \"order by sum(pageSaves) \" + sortOrder + \", sum(pageViews) \" + sortOrder\r\n                + \", sum(downloads) \" + sortOrder;\r\n        if (action.equals(\"save\")) {\r\n            orderByClause = \"order by sum(pageSaves) \" + sortOrder;\r\n        } else if (action.equals(\"view\")) {\r\n            orderByClause = \"order by sum(pageViews) \" + sortOrder;\r\n        } else if (action.equals(\"download\")) {\r\n            orderByClause = \"order by sum(downloads) \" + sortOrder;\r\n        }\r\n        XWikiHibernateStore store = null;\r\n        try {\r\n            store = context.getWiki().getHibernateStore();\r\n            store.beginTransaction(context);\r\n            Session session = store.getSession(context);\r\n            Query query =\r\n                session\r\n                    .createQuery(\"select name, sum(pageSaves), sum(pageViews), sum(downloads) from VisitStats where :startDate <= startDate and endDate < :endDate group by name \"\r\n                        + orderByClause);\r\n            query.setDate(\"startDate\", new Date(period.getStart()));\r\n            query.setDate(\"endDate\", new Date(period.getEnd()));\r\n\r\n            List results =\r\n                getVisitStatistics(store.search(query, range.getAbsoluteSize(), range\r\n                    .getAbsoluteStart(), context), new DateTime(period.getStart()),\r\n                    new DateTime(period.getEnd()));\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(results);\r\n            }\r\n            return results;\r\n        } catch (XWikiException e) {\r\n            return Collections.EMPTY_LIST;\r\n        } finally {\r\n            try {\r\n                store.endTransaction(context, false);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }","id":89739,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     * \r\n     * @see XWikiStatsService#getVisitStatistics(String, com.xpn.xwiki.criteria.impl.Period , Range ,\r\n     *      XWikiContext)\r\n     */\r\n    public List<VisitStats> getVisitStatistics(String action, Period period, Range range,\r\n        XWikiContext context)\r\n    {\r\n        List<VisitStats> visiStatList;\r\n\r\n        List<Object> paramList = new ArrayList<Object>(2);\r\n\r\n        String sortOrder = getHqlSortOrderFromRange(range);\r\n\r\n        String orderByClause;\r\n        if (action.equals(SaveAction.ACTION_NAME)) {\r\n            orderByClause = \"order by sum(pageSaves) \" + sortOrder;\r\n        } else if (action.equals(ViewAction.VIEW_ACTION)) {\r\n            orderByClause = \"order by sum(pageViews) \" + sortOrder;\r\n        } else if (action.equals(DownloadAction.ACTION_NAME)) {\r\n            orderByClause = \"order by sum(downloads) \" + sortOrder;\r\n        } else {\r\n            orderByClause =\r\n                MessageFormat.format(\"order by sum(pageSaves) {0},\" + \" sum(pageViews) {0},\"\r\n                    + \" sum(downloads) {0}\", sortOrder);\r\n        }\r\n\r\n        XWikiHibernateStore store = context.getWiki().getHibernateStore();\r\n        try {\r\n            String query =\r\n                \"select name, sum(pageSaves), sum(pageViews), sum(downloads)\"\r\n                    + \" from VisitStats\" + \" where ? <= startDate and endDate < ? group by name \"\r\n                    + orderByClause;\r\n\r\n            paramList.add(new Date(period.getStart()));\r\n            paramList.add(new Date(period.getEnd()));\r\n\r\n            List< ? > solist =\r\n                store.search(query, range.getAbsoluteSize(), range.getAbsoluteStart(), paramList,\r\n                    context);\r\n\r\n            visiStatList =\r\n                getVisitStatistics(solist, new DateTime(period.getStart()), new DateTime(period\r\n                    .getEnd()));\r\n            if (range.getSize() < 0) {\r\n                Collections.reverse(visiStatList);\r\n            }\r\n        } catch (XWikiException e) {\r\n            visiStatList = Collections.emptyList();\r\n        }\r\n\r\n        return visiStatList;\r\n    }","commit_id":"ee7f5bbb2d6d4d3376fbe78564835045d9fc0d32","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Object[] addSearchResults(\n\t\tString keywords, int startPage, int itemsPerPage, int total,\n\t\tString title, String searchPath, ThemeDisplay themeDisplay) {\n\n\t\treturn addSearchResults(\n\t\t\tkeywords, startPage, itemsPerPage, null, title, searchPath,\n\t\t\tthemeDisplay);\n\t}","id":89740,"modified_method":"protected Object[] addSearchResults(\n\t\tString keywords, int startPage, int itemsPerPage, int total, int start,\n\t\tString title, String searchPath, ThemeDisplay themeDisplay) {\n\n\t\tint totalPages = 0;\n\n\t\tif (total % itemsPerPage == 0) {\n\t\t\ttotalPages = total / itemsPerPage;\n\t\t}\n\t\telse {\n\t\t\ttotalPages = (total / itemsPerPage) + 1;\n\t\t}\n\n\t\tint previousPage = startPage - 1;\n\t\tint nextPage = startPage + 1;\n\n\t\t// Create document\n\n\t\torg.dom4j.Document doc = DocumentHelper.createDocument();\n\n\t\t// feed\n\n\t\tElement root = doc.addElement(\"feed\");\n\n\t\troot.add(OpenSearchUtil.getNamespace(OpenSearchUtil.DEFAULT_NAMESPACE));\n\t\troot.add(OpenSearchUtil.getNamespace(OpenSearchUtil.OS_NAMESPACE));\n\t\troot.add(\n\t\t\tOpenSearchUtil.getNamespace(OpenSearchUtil.RELEVANCE_NAMESPACE));\n\n\t\t// title\n\n\t\tOpenSearchUtil.addElement(\n\t\t\troot, \"title\", OpenSearchUtil.DEFAULT_NAMESPACE, title);\n\n\t\t// updated\n\n\t\tOpenSearchUtil.addElement(\n\t\t\troot, \"updated\", OpenSearchUtil.DEFAULT_NAMESPACE, new Date());\n\n\t\t// author\n\n\t\tElement author = OpenSearchUtil.addElement(\n\t\t\troot, \"author\", OpenSearchUtil.DEFAULT_NAMESPACE);\n\n\t\t// name\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tauthor, \"name\", OpenSearchUtil.DEFAULT_NAMESPACE,\n\t\t\tthemeDisplay.getUserId());\n\n\t\t// id\n\n\t\tOpenSearchUtil.addElement(\n\t\t\troot, \"id\", OpenSearchUtil.DEFAULT_NAMESPACE,\n\t\t\t\"urn:uuid:\" + PortalUUIDUtil.generate());\n\n\t\t// opensearch:totalResults\n\n\t\tOpenSearchUtil.addElement(\n\t\t\troot, \"totalResults\", OpenSearchUtil.OS_NAMESPACE, total);\n\n\t\t// opensearch:startIndex\n\n\t\tOpenSearchUtil.addElement(\n\t\t\troot, \"startIndex\", OpenSearchUtil.OS_NAMESPACE, start + 1);\n\n\t\t// opensearch:itemsPerPage\n\n\t\tOpenSearchUtil.addElement(\n\t\t\troot, \"itemsPerPage\", OpenSearchUtil.OS_NAMESPACE, itemsPerPage);\n\n\t\t// opensearch:Query\n\n\t\tElement query = OpenSearchUtil.addElement(\n\t\t\troot, \"Query\", OpenSearchUtil.OS_NAMESPACE);\n\n\t\tquery.addAttribute(\"role\", \"request\");\n\t\tquery.addAttribute(\"searchTerms\", keywords);\n\t\tquery.addAttribute(\"startPage\", String.valueOf(startPage));\n\n\t\t// links\n\n\t\tString searchURL = themeDisplay.getURLPortal() + searchPath;\n\n\t\tOpenSearchUtil.addLink(\n\t\t\troot, searchURL, \"self\", keywords, startPage, itemsPerPage);\n\t\tOpenSearchUtil.addLink(\n\t\t\troot, searchURL, \"first\", keywords, 1, itemsPerPage);\n\n\t\tif (previousPage > 0) {\n\t\t\tOpenSearchUtil.addLink(\n\t\t\t\troot, searchURL, \"previous\", keywords, previousPage,\n\t\t\t\titemsPerPage);\n\t\t}\n\n\t\tif (nextPage <= totalPages) {\n\t\t\tOpenSearchUtil.addLink(\n\t\t\t\troot, searchURL, \"next\", keywords, nextPage, itemsPerPage);\n\t\t}\n\n\t\tOpenSearchUtil.addLink(\n\t\t\troot, searchURL, \"last\", keywords, totalPages, itemsPerPage);\n\n\t\tElement link = OpenSearchUtil.addElement(\n\t\t\troot, \"link\", OpenSearchUtil.DEFAULT_NAMESPACE);\n\n\t\tlink.addAttribute(\"rel\", \"search\");\n\t\tlink.addAttribute(\"href\", searchPath + \"_description.xml\");\n\t\tlink.addAttribute(\"type\", \"application/opensearchdescription+xml\");\n\n\t\treturn new Object[] {doc, root};\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn BlogsEntryLocalServiceUtil.search(\n\t\t\tcompanyId, 0, 0, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89741,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn BlogsEntryLocalServiceUtil.search(\n\t\t\tcompanyId, 0, 0, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn BookmarksFolderLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89742,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn BookmarksFolderLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn DLFolderLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89743,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn DLFolderLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _search(\n\t\t\tHttpServletRequest req, String keywords, int startPage,\n\t\t\tint itemsPerPage)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tint start = (startPage * itemsPerPage) - itemsPerPage;\n\t\tint end = startPage * itemsPerPage;\n\n\t\tList<User> results = UserLocalServiceUtil.search(\n\t\t\tthemeDisplay.getCompanyId(), keywords, Boolean.TRUE, null, start,\n\t\t\tend, new ContactLastNameComparator(true));\n\n\t\tint total = UserLocalServiceUtil.searchCount(\n\t\t\tthemeDisplay.getCompanyId(), keywords, Boolean.TRUE, null);\n\n\t\tObject[] values = addSearchResults(\n\t\t\tkeywords, startPage, itemsPerPage, total, null,\n\t\t\t\"Liferay Directory Search: \" + keywords, SEARCH_PATH, themeDisplay);\n\n\t\torg.dom4j.Document doc = (org.dom4j.Document)values[1];\n\t\tElement root = (Element)values[2];\n\n\t\tfor (User user : results) {\n\t\t\tString portletId = PortletKeys.DIRECTORY;\n\n\t\t\t//String portletTitle = PortalUtil.getPortletTitle(\n\t\t\t//\tportletId, themeDisplay.getUser());\n\n\t\t\tPortletURL portletURL = getPortletURL(req, portletId);\n\n\t\t\tString title = user.getFullName();\n\t\t\tString url = portletURL.toString();\n\t\t\tDate modifedDate = user.getModifiedDate();\n\t\t\tString content =\n\t\t\t\tuser.getFullName() + \" &lt;\" + user.getEmailAddress() + \"&gt;\";\n\t\t\tdouble score = 1.0;\n\n\t\t\taddSearchResult(root, title, url, modifedDate, content, score);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t}\n\n\t\treturn doc.asXML();\n\t}","id":89744,"modified_method":"private String _search(\n\t\t\tHttpServletRequest req, String keywords, int startPage,\n\t\t\tint itemsPerPage)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\tint start = (startPage * itemsPerPage) - itemsPerPage;\n\t\tint end = startPage * itemsPerPage;\n\n\t\tList<User> results = UserLocalServiceUtil.search(\n\t\t\tthemeDisplay.getCompanyId(), keywords, Boolean.TRUE, null, start,\n\t\t\tend, new ContactLastNameComparator(true));\n\n\t\tint total = UserLocalServiceUtil.searchCount(\n\t\t\tthemeDisplay.getCompanyId(), keywords, Boolean.TRUE, null);\n\n\t\tObject[] values = addSearchResults(\n\t\t\tkeywords, startPage, itemsPerPage, total, start,\n\t\t\t\"Liferay Directory Search: \" + keywords, SEARCH_PATH, themeDisplay);\n\n\t\torg.dom4j.Document doc = (org.dom4j.Document)values[0];\n\t\tElement root = (Element)values[1];\n\n\t\tfor (User user : results) {\n\t\t\tString portletId = PortletKeys.DIRECTORY;\n\n\t\t\t//String portletTitle = PortalUtil.getPortletTitle(\n\t\t\t//\tportletId, themeDisplay.getUser());\n\n\t\t\tPortletURL portletURL = getPortletURL(req, portletId);\n\n\t\t\tString title = user.getFullName();\n\t\t\tString url = portletURL.toString();\n\t\t\tDate modifedDate = user.getModifiedDate();\n\t\t\tString content =\n\t\t\t\tuser.getFullName() + \" &lt;\" + user.getEmailAddress() + \"&gt;\";\n\t\t\tdouble score = 1.0;\n\n\t\t\taddSearchResult(root, title, url, modifedDate, content, score);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t}\n\n\t\treturn doc.asXML();\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public abstract Hits getHits(long companyId, String keywords)\n\t\tthrows Exception;","id":89745,"modified_method":"public abstract Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception;","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String search(\n\t\t\tHttpServletRequest req, String keywords, int startPage,\n\t\t\tint itemsPerPage)\n\t\tthrows SearchException {\n\n\t\tHits hits = null;\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\thits = getHits(themeDisplay.getCompanyId(), keywords);\n\n\t\t\tObject[] values = addSearchResults(\n\t\t\t\tkeywords, startPage, itemsPerPage, hits, getTitle(keywords),\n\t\t\t\tgetSearchPath(), themeDisplay);\n\n\t\t\tHits results = (Hits)values[0];\n\t\t\torg.dom4j.Document doc = (org.dom4j.Document)values[1];\n\t\t\tElement root = (Element)values[2];\n\n\t\t\tfor (int i = 0; i < results.getLength(); i++) {\n\t\t\t\tDocument result = results.doc(i);\n\n\t\t\t\tString portletId = result.get(Field.PORTLET_ID);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tthemeDisplay.getCompanyId(), portletId);\n\n\t\t\t\t//String portletTitle = PortalUtil.getPortletTitle(\n\t\t\t\t//\tportletId, themeDisplay.getUser());\n\n\t\t\t\tlong groupId = GetterUtil.getLong(result.get(Field.GROUP_ID));\n\n\t\t\t\tPortletURL portletURL = getPortletURL(req, portletId, groupId);\n\n\t\t\t\tIndexer indexer = (Indexer)InstancePool.get(\n\t\t\t\t\tportlet.getIndexerClass());\n\n\t\t\t\tDocumentSummary docSummary = indexer.getDocumentSummary(\n\t\t\t\t\tresult, portletURL);\n\n\t\t\t\tString title = docSummary.getTitle();\n\t\t\t\tString url = getURL(themeDisplay, groupId, result, portletURL);\n\t\t\t\tDate modifedDate = DateTools.stringToDate(\n\t\t\t\t\tresult.get(Field.MODIFIED));\n\t\t\t\tString content = docSummary.getContent();\n\t\t\t\tdouble score = hits.score(i);\n\n\t\t\t\taddSearchResult(root, title, url, modifedDate, content, score);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (hits != null) {\n\t\t\t\thits.closeSearcher();\n\t\t\t}\n\t\t}\n\t}","id":89746,"modified_method":"public String search(\n\t\t\tHttpServletRequest req, String keywords, int startPage,\n\t\t\tint itemsPerPage)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tint start = (startPage * itemsPerPage) - itemsPerPage;\n\t\t\tint end = startPage * itemsPerPage;\n\n\t\t\tHits results = getHits(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords, start, end);\n\n\t\t\tint total = results.getLength();\n\n\t\t\tObject[] values = addSearchResults(\n\t\t\t\tkeywords, startPage, itemsPerPage, total, start,\n\t\t\t\tgetTitle(keywords), getSearchPath(), themeDisplay);\n\n\t\t\torg.dom4j.Document doc = (org.dom4j.Document)values[0];\n\t\t\tElement root = (Element)values[1];\n\n\t\t\tfor (int i = 0; i < results.getDocs().length; i++) {\n\t\t\t\tDocument result = results.doc(i);\n\n\t\t\t\tString portletId = result.get(Field.PORTLET_ID);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tthemeDisplay.getCompanyId(), portletId);\n\n\t\t\t\t//String portletTitle = PortalUtil.getPortletTitle(\n\t\t\t\t//\tportletId, themeDisplay.getUser());\n\n\t\t\t\tlong groupId = GetterUtil.getLong(result.get(Field.GROUP_ID));\n\n\t\t\t\tPortletURL portletURL = getPortletURL(req, portletId, groupId);\n\n\t\t\t\tIndexer indexer = (Indexer)InstancePool.get(\n\t\t\t\t\tportlet.getIndexerClass());\n\n\t\t\t\tDocumentSummary docSummary = indexer.getDocumentSummary(\n\t\t\t\t\tresult, portletURL);\n\n\t\t\t\tString title = docSummary.getTitle();\n\t\t\t\tString url = getURL(themeDisplay, groupId, result, portletURL);\n\t\t\t\tDate modifedDate = DateTools.stringToDate(\n\t\t\t\t\tresult.get(Field.MODIFIED));\n\t\t\t\tString content = docSummary.getContent();\n\t\t\t\tdouble score = results.score(i);\n\n\t\t\t\taddSearchResult(root, title, url, modifedDate, content, score);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn IGFolderLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89747,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn IGFolderLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn JournalArticleLocalServiceUtil.search(\n\t\t\tcompanyId, 0, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89748,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn JournalArticleLocalServiceUtil.search(\n\t\t\tcompanyId, 0, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn MBCategoryLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, 0, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89749,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn MBCategoryLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, 0, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String search(\n\t\t\tHttpServletRequest req, String keywords, int startPage,\n\t\t\tint itemsPerPage)\n\t\tthrows SearchException {\n\n\t\tHits hits = null;\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\thits = CompanyLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\tSearchEngineUtil.ALL_POS, SearchEngineUtil.ALL_POS);\n\n\t\t\tObject[] values = addSearchResults(\n\t\t\t\tkeywords, startPage, itemsPerPage, hits,\n\t\t\t\t\"Liferay Portal Search: \" + keywords, SEARCH_PATH,\n\t\t\t\tthemeDisplay);\n\n\t\t\tHits results = (Hits)values[0];\n\t\t\torg.dom4j.Document doc = (org.dom4j.Document)values[1];\n\t\t\tElement root = (Element)values[2];\n\n\t\t\tfor (int i = 0; i < results.getLength(); i++) {\n\t\t\t\tDocument result = results.doc(i);\n\n\t\t\t\tString portletId = result.get(Field.PORTLET_ID);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tthemeDisplay.getCompanyId(), portletId);\n\n\t\t\t\tif (portlet == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString portletTitle = PortalUtil.getPortletTitle(\n\t\t\t\t\tportletId, themeDisplay.getUser());\n\n\t\t\t\tlong groupId = GetterUtil.getLong(result.get(Field.GROUP_ID));\n\n\t\t\t\tString title = StringPool.BLANK;\n\n\t\t\t\tPortletURL portletURL = getPortletURL(req, portletId, groupId);\n\n\t\t\t\tString url = portletURL.toString();\n\n\t\t\t\tDate modifedDate = DateTools.stringToDate(\n\t\t\t\t\tresult.get(Field.MODIFIED));\n\n\t\t\t\tString content = StringPool.BLANK;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getIndexerClass())) {\n\t\t\t\t\tIndexer indexer = (Indexer)InstancePool.get(\n\t\t\t\t\t\tportlet.getIndexerClass());\n\n\t\t\t\t\tDocumentSummary docSummary = indexer.getDocumentSummary(\n\t\t\t\t\t\tresult, portletURL);\n\n\t\t\t\t\ttitle = docSummary.getTitle();\n\t\t\t\t\turl = portletURL.toString();\n\t\t\t\t\tcontent = docSummary.getContent();\n\n\t\t\t\t\tif (portlet.getPortletId().equals(PortletKeys.JOURNAL)) {\n\t\t\t\t\t\turl = getJournalURL(themeDisplay, groupId, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdouble score = hits.score(i);\n\n\t\t\t\taddSearchResult(\n\t\t\t\t\troot, portletTitle + \" &raquo; \" + title, url, modifedDate,\n\t\t\t\t\tcontent, score);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (hits != null) {\n\t\t\t\thits.closeSearcher();\n\t\t\t}\n\t\t}\n\t}","id":89750,"modified_method":"public String search(\n\t\t\tHttpServletRequest req, String keywords, int startPage,\n\t\t\tint itemsPerPage)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tint start = (startPage * itemsPerPage) - itemsPerPage;\n\t\t\tint end = startPage * itemsPerPage;\n\n\t\t\tHits results = CompanyLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), keywords, start, end);\n\n\t\t\tint total = results.getLength();\n\n\t\t\tObject[] values = addSearchResults(\n\t\t\t\tkeywords, startPage, itemsPerPage, total, start,\n\t\t\t\t\"Liferay Portal Search: \" + keywords, SEARCH_PATH,\n\t\t\t\tthemeDisplay);\n\n\t\t\torg.dom4j.Document doc = (org.dom4j.Document)values[0];\n\t\t\tElement root = (Element)values[1];\n\n\t\t\tfor (int i = 0; i < results.getDocs().length; i++) {\n\t\t\t\tDocument result = results.doc(i);\n\n\t\t\t\tString portletId = result.get(Field.PORTLET_ID);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tthemeDisplay.getCompanyId(), portletId);\n\n\t\t\t\tif (portlet == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString portletTitle = PortalUtil.getPortletTitle(\n\t\t\t\t\tportletId, themeDisplay.getUser());\n\n\t\t\t\tlong groupId = GetterUtil.getLong(result.get(Field.GROUP_ID));\n\n\t\t\t\tString title = StringPool.BLANK;\n\n\t\t\t\tPortletURL portletURL = getPortletURL(req, portletId, groupId);\n\n\t\t\t\tString url = portletURL.toString();\n\n\t\t\t\tDate modifedDate = DateTools.stringToDate(\n\t\t\t\t\tresult.get(Field.MODIFIED));\n\n\t\t\t\tString content = StringPool.BLANK;\n\n\t\t\t\tif (Validator.isNotNull(portlet.getIndexerClass())) {\n\t\t\t\t\tIndexer indexer = (Indexer)InstancePool.get(\n\t\t\t\t\t\tportlet.getIndexerClass());\n\n\t\t\t\t\tDocumentSummary docSummary = indexer.getDocumentSummary(\n\t\t\t\t\t\tresult, portletURL);\n\n\t\t\t\t\ttitle = docSummary.getTitle();\n\t\t\t\t\turl = portletURL.toString();\n\t\t\t\t\tcontent = docSummary.getContent();\n\n\t\t\t\t\tif (portlet.getPortletId().equals(PortletKeys.JOURNAL)) {\n\t\t\t\t\t\turl = getJournalURL(themeDisplay, groupId, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdouble score = results.score(i);\n\n\t\t\t\taddSearchResult(\n\t\t\t\t\troot, portletTitle + \" &raquo; \" + title, url, modifedDate,\n\t\t\t\t\tcontent, score);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits getHits(long companyId, String keywords) throws Exception {\n\t\treturn WikiNodeLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, SearchEngineUtil.ALL_POS,\n\t\t\tSearchEngineUtil.ALL_POS);\n\t}","id":89751,"modified_method":"public Hits getHits(\n\t\t\tlong companyId, String keywords, int start, int end)\n\t\tthrows Exception {\n\n\t\treturn WikiNodeLocalServiceUtil.search(\n\t\t\tcompanyId, 0, null, keywords, start, end);\n\t}","commit_id":"5b38c2d5fafef6090a99a1117bfd1c934cd58aec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns the user's groups &quot;sites&quot; associated with the group\n\t * entity class names, including the Control Panel group if the user is\n\t * permitted to view the Control Panel.\n\t *\n\t * <ul>\n\t * <li>\n\t * Class name &quot;User&quot; includes the user's layout set\n\t * group.\n\t * <\/li>\n\t * <li>\n\t * Class name &quot;Organization&quot; includes the user's\n\t * immediate organization groups and inherited organization groups.\n\t * <\/li>\n\t * <li>\n\t * Class name &quot;Group&quot; includes the user's immediate\n\t * organization groups and site groups.\n\t * <\/li>\n\t * <li>\n\t * A <code>classNames<\/code>\n\t * value of <code>null<\/code> includes the user's layout set group,\n\t * organization groups, inherited organization groups, and site groups.\n\t * <\/li>\n\t * <\/ul>\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  classNames the group entity class names (optionally\n\t *         <code>null<\/code>). For more information see {@link\n\t *         #getUserSitesGroups(long, String[], int)}.\n\t * @param  max the maximum number of groups to return\n\t * @return the user's groups &quot;sites&quot;\n\t * @throws PortalException if a portal exception occurred\n\t */\n\t@Override\n\tpublic List<Group> getUserSitesGroups(\n\t\t\tlong userId, String[] classNames, int max)\n\t\tthrows PortalException {\n\n\t\tUser user = userPersistence.fetchByPrimaryKey(userId);\n\n\t\tif (user.isDefaultUser()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Group> userSiteGroups = new ArrayList<>();\n\n\t\tint start = QueryUtil.ALL_POS;\n\t\tint end = QueryUtil.ALL_POS;\n\n\t\tif (max != QueryUtil.ALL_POS) {\n\t\t\tstart = 0;\n\t\t\tend = max;\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, User.class.getName())) {\n\n\t\t\tif (PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_ENABLED ||\n\t\t\t\tPropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_ENABLED) {\n\n\t\t\t\tGroup userGroup = user.getGroup();\n\n\t\t\t\tuserSiteGroups.add(userGroup);\n\n\t\t\t\tif ((max != QueryUtil.ALL_POS) &&\n\t\t\t\t\t(userSiteGroups.size() >= max)) {\n\n\t\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, Company.class.getName())) {\n\n\t\t\tuserSiteGroups.addAll(\n\t\t\t\tgroupLocalService.search(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tnew long[] {\n\t\t\t\t\t\tclassNameLocalService.getClassNameId(Company.class)\n\t\t\t\t\t},\n\t\t\t\t\tnull, new LinkedHashMap<String, Object>(), start, end));\n\n\t\t\tif ((max != QueryUtil.ALL_POS) && (userSiteGroups.size() >= max)) {\n\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t}\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, Group.class.getName())) {\n\n\t\t\tLinkedHashMap<String, Object> groupParams = new LinkedHashMap<>();\n\n\t\t\tgroupParams.put(\"active\", true);\n\t\t\tgroupParams.put(\"usersGroups\", userId);\n\n\t\t\tuserSiteGroups.addAll(\n\t\t\t\tgroupLocalService.search(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tnew long[] {\n\t\t\t\t\t\tclassNameLocalService.getClassNameId(Group.class)\n\t\t\t\t\t},\n\t\t\t\t\tnull, groupParams, start, end));\n\n\t\t\tif ((max != QueryUtil.ALL_POS) && (userSiteGroups.size() >= max)) {\n\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t}\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, Organization.class.getName())) {\n\n\t\t\tList<Organization> userOrgs =\n\t\t\t\torganizationLocalService.getOrganizations(\n\t\t\t\t\tuserId, QueryUtil.ALL_POS, QueryUtil.ALL_POS, null);\n\n\t\t\tfor (Organization organization : userOrgs) {\n\t\t\t\tGroup group = organization.getGroup();\n\n\t\t\t\tif (group.isActive() &&\n\t\t\t\t\t(group.hasPrivateLayouts() || group.hasPublicLayouts())) {\n\n\t\t\t\t\tuserSiteGroups.add(group);\n\t\t\t\t}\n\n\t\t\t\tif (!PropsValues.ORGANIZATIONS_MEMBERSHIP_STRICT) {\n\t\t\t\t\tfor (Organization ancestorOrganization :\n\t\t\t\t\t\t\torganization.getAncestors()) {\n\n\t\t\t\t\t\tGroup ancestorGroup = ancestorOrganization.getGroup();\n\n\t\t\t\t\t\tif (ancestorGroup.isActive() &&\n\t\t\t\t\t\t\t(ancestorGroup.hasPrivateLayouts() ||\n\t\t\t\t\t\t\t ancestorGroup.hasPublicLayouts())) {\n\n\t\t\t\t\t\t\tuserSiteGroups.add(ancestorOrganization.getGroup());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((max != QueryUtil.ALL_POS) &&\n\t\t\t\t\t(userSiteGroups.size() >= max)) {\n\n\t\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Collections.unmodifiableList(\n\t\t\tListUtil.subList(ListUtil.unique(userSiteGroups), start, end));\n\t}","id":89752,"modified_method":"/**\n\t * Returns the user's groups &quot;sites&quot; associated with the group\n\t * entity class names, including the Control Panel group if the user is\n\t * permitted to view the Control Panel.\n\t *\n\t * <ul>\n\t * <li>\n\t * Class name &quot;User&quot; includes the user's layout set\n\t * group.\n\t * <\/li>\n\t * <li>\n\t * Class name &quot;Organization&quot; includes the user's\n\t * immediate organization groups and inherited organization groups.\n\t * <\/li>\n\t * <li>\n\t * Class name &quot;Group&quot; includes the user's immediate\n\t * organization groups and site groups.\n\t * <\/li>\n\t * <li>\n\t * A <code>classNames<\/code>\n\t * value of <code>null<\/code> includes the user's layout set group,\n\t * organization groups, inherited organization groups, and site groups.\n\t * <\/li>\n\t * <\/ul>\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  classNames the group entity class names (optionally\n\t *         <code>null<\/code>). For more information see {@link\n\t *         #getUserSitesGroups(long, String[], int)}.\n\t * @param  max the maximum number of groups to return\n\t * @return the user's groups &quot;sites&quot;\n\t * @throws PortalException if a portal exception occurred\n\t */\n\t@Override\n\tpublic List<Group> getUserSitesGroups(\n\t\t\tlong userId, String[] classNames, int max)\n\t\tthrows PortalException {\n\n\t\tUser user = userPersistence.fetchByPrimaryKey(userId);\n\n\t\tif (user.isDefaultUser()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tList<Group> userSiteGroups = new ArrayList<>();\n\n\t\tint start = QueryUtil.ALL_POS;\n\t\tint end = QueryUtil.ALL_POS;\n\n\t\tif (max != QueryUtil.ALL_POS) {\n\t\t\tstart = 0;\n\t\t\tend = max;\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, User.class.getName())) {\n\n\t\t\tif (PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_ENABLED ||\n\t\t\t\tPropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_ENABLED) {\n\n\t\t\t\tGroup userGroup = user.getGroup();\n\n\t\t\t\tuserSiteGroups.add(userGroup);\n\n\t\t\t\tif ((max != QueryUtil.ALL_POS) &&\n\t\t\t\t\t(userSiteGroups.size() >= max)) {\n\n\t\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, Company.class.getName())) {\n\n\t\t\tuserSiteGroups.addAll(\n\t\t\t\tgroupLocalService.search(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tnew long[] {\n\t\t\t\t\t\tclassNameLocalService.getClassNameId(Company.class)\n\t\t\t\t\t},\n\t\t\t\t\tnull, new LinkedHashMap<String, Object>(), start, end));\n\n\t\t\tif ((max != QueryUtil.ALL_POS) && (userSiteGroups.size() >= max)) {\n\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t}\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, Group.class.getName())) {\n\n\t\t\tLinkedHashMap<String, Object> groupParams = new LinkedHashMap<>();\n\n\t\t\tgroupParams.put(\"active\", true);\n\t\t\tgroupParams.put(\"usersGroups\", userId);\n\n\t\t\tList<Group> groups = groupLocalService.search(\n\t\t\t\tuser.getCompanyId(),\n\t\t\t\tnew long[] {\n\t\t\t\t\tclassNameLocalService.getClassNameId(Group.class)\n\t\t\t\t},\n\t\t\t\tnull, groupParams, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tfor (Group group : groups) {\n\t\t\t\tif (group.hasPrivateLayouts() || group.hasPublicLayouts()) {\n\t\t\t\t\tuserSiteGroups.add(group);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((max != QueryUtil.ALL_POS) && (userSiteGroups.size() >= max)) {\n\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t}\n\t\t}\n\n\t\tif ((classNames == null) ||\n\t\t\tArrayUtil.contains(classNames, Organization.class.getName())) {\n\n\t\t\tList<Organization> userOrgs =\n\t\t\t\torganizationLocalService.getOrganizations(\n\t\t\t\t\tuserId, QueryUtil.ALL_POS, QueryUtil.ALL_POS, null);\n\n\t\t\tfor (Organization organization : userOrgs) {\n\t\t\t\tGroup group = organization.getGroup();\n\n\t\t\t\tif (group.isActive() &&\n\t\t\t\t\t(group.hasPrivateLayouts() || group.hasPublicLayouts())) {\n\n\t\t\t\t\tuserSiteGroups.add(group);\n\t\t\t\t}\n\n\t\t\t\tif (!PropsValues.ORGANIZATIONS_MEMBERSHIP_STRICT) {\n\t\t\t\t\tfor (Organization ancestorOrganization :\n\t\t\t\t\t\t\torganization.getAncestors()) {\n\n\t\t\t\t\t\tGroup ancestorGroup = ancestorOrganization.getGroup();\n\n\t\t\t\t\t\tif (ancestorGroup.isActive() &&\n\t\t\t\t\t\t\t(ancestorGroup.hasPrivateLayouts() ||\n\t\t\t\t\t\t\t ancestorGroup.hasPublicLayouts())) {\n\n\t\t\t\t\t\t\tuserSiteGroups.add(ancestorOrganization.getGroup());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((max != QueryUtil.ALL_POS) &&\n\t\t\t\t\t(userSiteGroups.size() >= max)) {\n\n\t\t\t\t\treturn Collections.unmodifiableList(\n\t\t\t\t\t\tListUtil.subList(\n\t\t\t\t\t\t\tListUtil.unique(userSiteGroups), start, end));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Collections.unmodifiableList(\n\t\t\tListUtil.subList(ListUtil.unique(userSiteGroups), start, end));\n\t}","commit_id":"7aa0f366ad49b30332373d2bafa4f07e04c6491c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tBookmarksEntry entry = (BookmarksEntry)obj;\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, entry);\n\n\t\tdocument.addText(Field.DESCRIPTION, entry.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, entry.getFolderId());\n\t\tdocument.addText(Field.TITLE, entry.getName());\n\t\tdocument.addKeyword(Field.TREE_PATH, entry.getTreePath());\n\t\tdocument.addText(Field.URL, entry.getUrl());\n\n\t\tif (!entry.isInTrash() && entry.isInTrashContainer()) {\n\t\t\tBookmarksFolder folder = entry.getTrashContainer();\n\n\t\t\taddTrashFields(\n\t\t\t\tdocument, BookmarksFolder.class.getName(), folder.getFolderId(),\n\t\t\t\tnull, null, BookmarksEntryAssetRendererFactory.TYPE);\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, BookmarksFolder.class.getName());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_PK, folder.getFolderId());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t}\n\n\t\treturn document;\n\t}","id":89753,"modified_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tBookmarksEntry entry = (BookmarksEntry)obj;\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, entry);\n\n\t\tdocument.addText(Field.DESCRIPTION, entry.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, entry.getFolderId());\n\t\tdocument.addText(Field.TITLE, entry.getName());\n\t\tdocument.addKeyword(\n\t\t\tField.TREE_PATH,\n\t\t\tStringUtil.split(entry.getTreePath(), CharPool.SLASH));\n\t\tdocument.addText(Field.URL, entry.getUrl());\n\n\t\tif (!entry.isInTrash() && entry.isInTrashContainer()) {\n\t\t\tBookmarksFolder folder = entry.getTrashContainer();\n\n\t\t\taddTrashFields(\n\t\t\t\tdocument, BookmarksFolder.class.getName(), folder.getFolderId(),\n\t\t\t\tnull, null, BookmarksEntryAssetRendererFactory.TYPE);\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, BookmarksFolder.class.getName());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_PK, folder.getFolderId());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"307379fce075b414d17464e1110449ceb68d3792","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tBookmarksFolder folder = (BookmarksFolder)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing folder \" + folder);\n\t\t}\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, folder);\n\n\t\tdocument.addText(Field.DESCRIPTION, folder.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, folder.getParentFolderId());\n\t\tdocument.addText(Field.TITLE, folder.getName());\n\t\tdocument.addKeyword(Field.TREE_PATH, folder.getTreePath());\n\n\t\tif (!folder.isInTrash() && folder.isInTrashContainer()) {\n\t\t\tBookmarksFolder trashedFolder = folder.getTrashContainer();\n\n\t\t\tif (trashedFolder != null) {\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, BookmarksFolder.class.getName(),\n\t\t\t\t\ttrashedFolder.getFolderId(), null, null,\n\t\t\t\t\tBookmarksFolderAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME,\n\t\t\t\t\tBookmarksFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, trashedFolder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Document \" + folder + \" indexed successfully\");\n\t\t}\n\n\t\treturn document;\n\t}","id":89754,"modified_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tBookmarksFolder folder = (BookmarksFolder)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing folder \" + folder);\n\t\t}\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, folder);\n\n\t\tdocument.addText(Field.DESCRIPTION, folder.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, folder.getParentFolderId());\n\t\tdocument.addText(Field.TITLE, folder.getName());\n\t\tdocument.addKeyword(\n\t\t\tField.TREE_PATH,\n\t\t\tStringUtil.split(folder.getTreePath(), CharPool.SLASH));\n\n\t\tif (!folder.isInTrash() && folder.isInTrashContainer()) {\n\t\t\tBookmarksFolder trashedFolder = folder.getTrashContainer();\n\n\t\t\tif (trashedFolder != null) {\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, BookmarksFolder.class.getName(),\n\t\t\t\t\ttrashedFolder.getFolderId(), null, null,\n\t\t\t\t\tBookmarksFolderAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME,\n\t\t\t\t\tBookmarksFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, trashedFolder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Document \" + folder + \" indexed successfully\");\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"307379fce075b414d17464e1110449ceb68d3792","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing document \" + dlFileEntry);\n\t\t}\n\n\t\tboolean indexContent = true;\n\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tif (PropsValues.DL_FILE_INDEXING_MAX_SIZE == 0) {\n\t\t\t\tindexContent = false;\n\t\t\t}\n\t\t\telse if (PropsValues.DL_FILE_INDEXING_MAX_SIZE != -1) {\n\t\t\t\tif (dlFileEntry.getSize() >\n\t\t\t\t\t\tPropsValues.DL_FILE_INDEXING_MAX_SIZE) {\n\n\t\t\t\t\tindexContent = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indexContent) {\n\t\t\t\tString[] ignoreExtensions = PrefsPropsUtil.getStringArray(\n\t\t\t\t\tPropsKeys.DL_FILE_INDEXING_IGNORE_EXTENSIONS,\n\t\t\t\t\tStringPool.COMMA);\n\n\t\t\t\tif (ArrayUtil.contains(\n\t\t\t\t\t\tignoreExtensions,\n\t\t\t\t\t\tStringPool.PERIOD + dlFileEntry.getExtension())) {\n\n\t\t\t\t\tindexContent = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indexContent) {\n\t\t\t\tis = dlFileEntry.getFileVersion().getContentStream(false);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tDLFileVersion dlFileVersion = dlFileEntry.getFileVersion();\n\n\t\ttry {\n\t\t\tDocument document = getBaseModelDocument(\n\t\t\t\tPORTLET_ID, dlFileEntry, dlFileVersion);\n\n\t\t\tif (indexContent) {\n\t\t\t\tif (is != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdocument.addFile(\n\t\t\t\t\t\t\tField.CONTENT, is, dlFileEntry.getTitle());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new SearchException(\n\t\t\t\t\t\t\t\"Cannot extract text from file\" + dlFileEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Document \" + dlFileEntry +\n\t\t\t\t\t\t\t\" does not have any content\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.CLASS_TYPE_ID, dlFileEntry.getFileEntryTypeId());\n\t\t\tdocument.addText(Field.DESCRIPTION, dlFileEntry.getDescription());\n\t\t\tdocument.addKeyword(Field.FOLDER_ID, dlFileEntry.getFolderId());\n\t\t\tdocument.addKeyword(Field.HIDDEN, dlFileEntry.isInHiddenFolder());\n\t\t\tdocument.addText(\n\t\t\t\tField.PROPERTIES, dlFileEntry.getLuceneProperties());\n\t\t\tdocument.addText(Field.TITLE, dlFileEntry.getTitle());\n\t\t\tdocument.addKeyword(Field.TREE_PATH, dlFileEntry.getTreePath());\n\n\t\t\tdocument.addKeyword(\n\t\t\t\t\"dataRepositoryId\", dlFileEntry.getDataRepositoryId());\n\t\t\tdocument.addKeyword(\"extension\", dlFileEntry.getExtension());\n\t\t\tdocument.addKeyword(\n\t\t\t\t\"fileEntryTypeId\", dlFileEntry.getFileEntryTypeId());\n\t\t\tdocument.addKeyword(\n\t\t\t\t\"mimeType\",\n\t\t\t\tStringUtil.replace(\n\t\t\t\t\tdlFileEntry.getMimeType(), CharPool.FORWARD_SLASH,\n\t\t\t\t\tCharPool.UNDERLINE));\n\t\t\tdocument.addKeyword(\"path\", dlFileEntry.getTitle());\n\t\t\tdocument.addKeyword(\"readCount\", dlFileEntry.getReadCount());\n\t\t\tdocument.addKeyword(\"size\", dlFileEntry.getSize());\n\n\t\t\tExpandoBridge expandoBridge =\n\t\t\t\tExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\t\tdlFileVersion.getFileVersionId());\n\n\t\t\tExpandoBridgeIndexerUtil.addAttributes(document, expandoBridge);\n\n\t\t\taddFileEntryTypeAttributes(document, dlFileVersion);\n\n\t\t\tif (dlFileEntry.isInHiddenFolder()) {\n\t\t\t\ttry {\n\t\t\t\t\tRepository repository =\n\t\t\t\t\t\tRepositoryLocalServiceUtil.getRepository(\n\t\t\t\t\t\t\tdlFileEntry.getRepositoryId());\n\n\t\t\t\t\tString portletId = repository.getPortletId();\n\n\t\t\t\t\tfor (Indexer indexer : IndexerRegistryUtil.getIndexers()) {\n\t\t\t\t\t\tif (portletId.equals(indexer.getPortletId())) {\n\t\t\t\t\t\t\tindexer.addRelatedEntryFields(document, obj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dlFileVersion.isInTrash() &&\n\t\t\t\tdlFileVersion.isInTrashContainer()) {\n\n\t\t\t\tDLFolder folder = dlFileVersion.getTrashContainer();\n\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, DLFolder.class.getName(), folder.getFolderId(),\n\t\t\t\t\tnull, null, DLFileEntryAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, DLFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, folder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Document \" + dlFileEntry + \" indexed successfully\");\n\t\t\t}\n\n\t\t\treturn document;\n\t\t}\n\t\tfinally {\n\t\t\tif (is != null) {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":89755,"modified_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing document \" + dlFileEntry);\n\t\t}\n\n\t\tboolean indexContent = true;\n\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tif (PropsValues.DL_FILE_INDEXING_MAX_SIZE == 0) {\n\t\t\t\tindexContent = false;\n\t\t\t}\n\t\t\telse if (PropsValues.DL_FILE_INDEXING_MAX_SIZE != -1) {\n\t\t\t\tif (dlFileEntry.getSize() >\n\t\t\t\t\t\tPropsValues.DL_FILE_INDEXING_MAX_SIZE) {\n\n\t\t\t\t\tindexContent = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indexContent) {\n\t\t\t\tString[] ignoreExtensions = PrefsPropsUtil.getStringArray(\n\t\t\t\t\tPropsKeys.DL_FILE_INDEXING_IGNORE_EXTENSIONS,\n\t\t\t\t\tStringPool.COMMA);\n\n\t\t\t\tif (ArrayUtil.contains(\n\t\t\t\t\t\tignoreExtensions,\n\t\t\t\t\t\tStringPool.PERIOD + dlFileEntry.getExtension())) {\n\n\t\t\t\t\tindexContent = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indexContent) {\n\t\t\t\tis = dlFileEntry.getFileVersion().getContentStream(false);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tDLFileVersion dlFileVersion = dlFileEntry.getFileVersion();\n\n\t\ttry {\n\t\t\tDocument document = getBaseModelDocument(\n\t\t\t\tPORTLET_ID, dlFileEntry, dlFileVersion);\n\n\t\t\tif (indexContent) {\n\t\t\t\tif (is != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdocument.addFile(\n\t\t\t\t\t\t\tField.CONTENT, is, dlFileEntry.getTitle());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new SearchException(\n\t\t\t\t\t\t\t\"Cannot extract text from file\" + dlFileEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Document \" + dlFileEntry +\n\t\t\t\t\t\t\t\" does not have any content\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.CLASS_TYPE_ID, dlFileEntry.getFileEntryTypeId());\n\t\t\tdocument.addText(Field.DESCRIPTION, dlFileEntry.getDescription());\n\t\t\tdocument.addKeyword(Field.FOLDER_ID, dlFileEntry.getFolderId());\n\t\t\tdocument.addKeyword(Field.HIDDEN, dlFileEntry.isInHiddenFolder());\n\t\t\tdocument.addText(\n\t\t\t\tField.PROPERTIES, dlFileEntry.getLuceneProperties());\n\t\t\tdocument.addText(Field.TITLE, dlFileEntry.getTitle());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.TREE_PATH,\n\t\t\t\tStringUtil.split(dlFileEntry.getTreePath(), CharPool.SLASH));\n\n\t\t\tdocument.addKeyword(\n\t\t\t\t\"dataRepositoryId\", dlFileEntry.getDataRepositoryId());\n\t\t\tdocument.addKeyword(\"extension\", dlFileEntry.getExtension());\n\t\t\tdocument.addKeyword(\n\t\t\t\t\"fileEntryTypeId\", dlFileEntry.getFileEntryTypeId());\n\t\t\tdocument.addKeyword(\n\t\t\t\t\"mimeType\",\n\t\t\t\tStringUtil.replace(\n\t\t\t\t\tdlFileEntry.getMimeType(), CharPool.FORWARD_SLASH,\n\t\t\t\t\tCharPool.UNDERLINE));\n\t\t\tdocument.addKeyword(\"path\", dlFileEntry.getTitle());\n\t\t\tdocument.addKeyword(\"readCount\", dlFileEntry.getReadCount());\n\t\t\tdocument.addKeyword(\"size\", dlFileEntry.getSize());\n\n\t\t\tExpandoBridge expandoBridge =\n\t\t\t\tExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\t\tdlFileVersion.getFileVersionId());\n\n\t\t\tExpandoBridgeIndexerUtil.addAttributes(document, expandoBridge);\n\n\t\t\taddFileEntryTypeAttributes(document, dlFileVersion);\n\n\t\t\tif (dlFileEntry.isInHiddenFolder()) {\n\t\t\t\ttry {\n\t\t\t\t\tRepository repository =\n\t\t\t\t\t\tRepositoryLocalServiceUtil.getRepository(\n\t\t\t\t\t\t\tdlFileEntry.getRepositoryId());\n\n\t\t\t\t\tString portletId = repository.getPortletId();\n\n\t\t\t\t\tfor (Indexer indexer : IndexerRegistryUtil.getIndexers()) {\n\t\t\t\t\t\tif (portletId.equals(indexer.getPortletId())) {\n\t\t\t\t\t\t\tindexer.addRelatedEntryFields(document, obj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dlFileVersion.isInTrash() &&\n\t\t\t\tdlFileVersion.isInTrashContainer()) {\n\n\t\t\t\tDLFolder folder = dlFileVersion.getTrashContainer();\n\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, DLFolder.class.getName(), folder.getFolderId(),\n\t\t\t\t\tnull, null, DLFileEntryAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, DLFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, folder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Document \" + dlFileEntry + \" indexed successfully\");\n\t\t\t}\n\n\t\t\treturn document;\n\t\t}\n\t\tfinally {\n\t\t\tif (is != null) {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"307379fce075b414d17464e1110449ceb68d3792","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tDLFolder dlFolder = (DLFolder)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing folder \" + dlFolder);\n\t\t}\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, dlFolder);\n\n\t\tdocument.addText(Field.DESCRIPTION, dlFolder.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, dlFolder.getParentFolderId());\n\t\tdocument.addKeyword(\n\t\t\tField.HIDDEN, (dlFolder.isHidden() || dlFolder.isInHiddenFolder()));\n\t\tdocument.addText(Field.TITLE, dlFolder.getName());\n\t\tdocument.addKeyword(Field.TREE_PATH, dlFolder.getTreePath());\n\n\t\tif (!dlFolder.isInTrash() && dlFolder.isInTrashContainer()) {\n\t\t\tDLFolder trashedFolder = dlFolder.getTrashContainer();\n\n\t\t\tif (trashedFolder != null) {\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, DLFolder.class.getName(),\n\t\t\t\t\ttrashedFolder.getFolderId(), null, null,\n\t\t\t\t\tDLFileEntryAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, DLFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, trashedFolder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Document \" + dlFolder + \" indexed successfully\");\n\t\t}\n\n\t\treturn document;\n\t}","id":89756,"modified_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tDLFolder dlFolder = (DLFolder)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing folder \" + dlFolder);\n\t\t}\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, dlFolder);\n\n\t\tdocument.addText(Field.DESCRIPTION, dlFolder.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, dlFolder.getParentFolderId());\n\t\tdocument.addKeyword(\n\t\t\tField.HIDDEN, (dlFolder.isHidden() || dlFolder.isInHiddenFolder()));\n\t\tdocument.addText(Field.TITLE, dlFolder.getName());\n\t\tdocument.addKeyword(Field.TREE_PATH, dlFolder.getTreePath());\n\t\tdocument.addKeyword(\n\t\t\tField.TREE_PATH,\n\t\t\tStringUtil.split(dlFolder.getTreePath(), CharPool.SLASH));\n\n\t\tif (!dlFolder.isInTrash() && dlFolder.isInTrashContainer()) {\n\t\t\tDLFolder trashedFolder = dlFolder.getTrashContainer();\n\n\t\t\tif (trashedFolder != null) {\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, DLFolder.class.getName(),\n\t\t\t\t\ttrashedFolder.getFolderId(), null, null,\n\t\t\t\t\tDLFileEntryAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, DLFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, trashedFolder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Document \" + dlFolder + \" indexed successfully\");\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"307379fce075b414d17464e1110449ceb68d3792","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tJournalArticle article = (JournalArticle)obj;\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, article);\n\n\t\tdocument.addUID(PORTLET_ID, article.getId());\n\n\t\tString articleDefaultLanguageId = LocalizationUtil.getDefaultLanguageId(\n\t\t\tarticle.getContent());\n\n\t\tLocale defaultLocale = LocaleUtil.getSiteDefault();\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(defaultLocale);\n\n\t\tString[] languageIds = getLanguageIds(\n\t\t\tdefaultLanguageId, article.getContent());\n\n\t\tfor (String languageId : languageIds) {\n\t\t\tString content = extractContent(article, languageId);\n\n\t\t\tString description = article.getDescription(languageId);\n\n\t\t\tString title = article.getTitle(languageId);\n\n\t\t\tif (languageId.equals(articleDefaultLanguageId)) {\n\t\t\t\tdocument.addText(Field.CONTENT, content);\n\t\t\t\tdocument.addText(Field.DESCRIPTION, description);\n\t\t\t\tdocument.addText(Field.TITLE, title);\n\t\t\t\tdocument.addText(\"defaultLanguageId\", languageId);\n\t\t\t}\n\n\t\t\tdocument.addText(\n\t\t\t\tField.CONTENT.concat(StringPool.UNDERLINE).concat(languageId),\n\t\t\t\tcontent);\n\t\t\tdocument.addText(\n\t\t\t\tField.DESCRIPTION.concat(StringPool.UNDERLINE).concat(\n\t\t\t\t\tlanguageId), description);\n\t\t\tdocument.addText(\n\t\t\t\tField.TITLE.concat(StringPool.UNDERLINE).concat(languageId),\n\t\t\t\ttitle);\n\t\t}\n\n\t\tdocument.addKeyword(Field.FOLDER_ID, article.getFolderId());\n\t\tdocument.addKeyword(Field.LAYOUT_UUID, article.getLayoutUuid());\n\t\tdocument.addKeyword(Field.TREE_PATH, article.getTreePath());\n\t\tdocument.addKeyword(Field.TYPE, article.getType());\n\t\tdocument.addKeyword(Field.VERSION, article.getVersion());\n\n\t\tString articleId = article.getArticleId();\n\n\t\tif (article.isInTrash()) {\n\t\t\tarticleId = TrashUtil.getOriginalTitle(articleId);\n\t\t}\n\n\t\tdocument.addKeyword(\"articleId\", articleId);\n\t\tdocument.addKeyword(\"ddmStructureKey\", article.getStructureId());\n\t\tdocument.addKeyword(\"ddmTemplateKey\", article.getTemplateId());\n\t\tdocument.addDate(\"displayDate\", article.getDisplayDate());\n\t\tdocument.addKeyword(\"head\", false);\n\n\t\taddDDMStructureAttributes(document, article);\n\n\t\tif (!article.isInTrash() && article.isInTrashContainer()) {\n\t\t\tJournalFolder folder = article.getTrashContainer();\n\n\t\t\taddTrashFields(\n\t\t\t\tdocument, JournalFolder.class.getName(), folder.getFolderId(),\n\t\t\t\tnull, null, JournalArticleAssetRendererFactory.TYPE);\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, JournalFolder.class.getName());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_PK, folder.getFolderId());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t}\n\n\t\treturn document;\n\t}","id":89757,"modified_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tJournalArticle article = (JournalArticle)obj;\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, article);\n\n\t\tdocument.addUID(PORTLET_ID, article.getId());\n\n\t\tString articleDefaultLanguageId = LocalizationUtil.getDefaultLanguageId(\n\t\t\tarticle.getContent());\n\n\t\tLocale defaultLocale = LocaleUtil.getSiteDefault();\n\n\t\tString defaultLanguageId = LocaleUtil.toLanguageId(defaultLocale);\n\n\t\tString[] languageIds = getLanguageIds(\n\t\t\tdefaultLanguageId, article.getContent());\n\n\t\tfor (String languageId : languageIds) {\n\t\t\tString content = extractContent(article, languageId);\n\n\t\t\tString description = article.getDescription(languageId);\n\n\t\t\tString title = article.getTitle(languageId);\n\n\t\t\tif (languageId.equals(articleDefaultLanguageId)) {\n\t\t\t\tdocument.addText(Field.CONTENT, content);\n\t\t\t\tdocument.addText(Field.DESCRIPTION, description);\n\t\t\t\tdocument.addText(Field.TITLE, title);\n\t\t\t\tdocument.addText(\"defaultLanguageId\", languageId);\n\t\t\t}\n\n\t\t\tdocument.addText(\n\t\t\t\tField.CONTENT.concat(StringPool.UNDERLINE).concat(languageId),\n\t\t\t\tcontent);\n\t\t\tdocument.addText(\n\t\t\t\tField.DESCRIPTION.concat(StringPool.UNDERLINE).concat(\n\t\t\t\t\tlanguageId), description);\n\t\t\tdocument.addText(\n\t\t\t\tField.TITLE.concat(StringPool.UNDERLINE).concat(languageId),\n\t\t\t\ttitle);\n\t\t}\n\n\t\tdocument.addKeyword(Field.FOLDER_ID, article.getFolderId());\n\t\tdocument.addKeyword(Field.LAYOUT_UUID, article.getLayoutUuid());\n\t\tdocument.addKeyword(\n\t\t\tField.TREE_PATH,\n\t\t\tStringUtil.split(article.getTreePath(), CharPool.SLASH));\n\t\tdocument.addKeyword(Field.TYPE, article.getType());\n\t\tdocument.addKeyword(Field.VERSION, article.getVersion());\n\n\t\tString articleId = article.getArticleId();\n\n\t\tif (article.isInTrash()) {\n\t\t\tarticleId = TrashUtil.getOriginalTitle(articleId);\n\t\t}\n\n\t\tdocument.addKeyword(\"articleId\", articleId);\n\t\tdocument.addKeyword(\"ddmStructureKey\", article.getStructureId());\n\t\tdocument.addKeyword(\"ddmTemplateKey\", article.getTemplateId());\n\t\tdocument.addDate(\"displayDate\", article.getDisplayDate());\n\t\tdocument.addKeyword(\"head\", false);\n\n\t\taddDDMStructureAttributes(document, article);\n\n\t\tif (!article.isInTrash() && article.isInTrashContainer()) {\n\t\t\tJournalFolder folder = article.getTrashContainer();\n\n\t\t\taddTrashFields(\n\t\t\t\tdocument, JournalFolder.class.getName(), folder.getFolderId(),\n\t\t\t\tnull, null, JournalArticleAssetRendererFactory.TYPE);\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, JournalFolder.class.getName());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ROOT_ENTRY_CLASS_PK, folder.getFolderId());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"307379fce075b414d17464e1110449ceb68d3792","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tJournalFolder folder = (JournalFolder)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing folder \" + folder);\n\t\t}\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, folder);\n\n\t\tdocument.addText(Field.DESCRIPTION, folder.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, folder.getParentFolderId());\n\t\tdocument.addText(Field.TITLE, folder.getName());\n\t\tdocument.addKeyword(Field.TREE_PATH, folder.getTreePath());\n\n\t\tif (!folder.isInTrash() && folder.isInTrashContainer()) {\n\t\t\tJournalFolder trashedFolder = folder.getTrashContainer();\n\n\t\t\tif (trashedFolder != null) {\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, JournalFolder.class.getName(),\n\t\t\t\t\ttrashedFolder.getFolderId(), null, null,\n\t\t\t\t\tJournalFolderAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, JournalFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, trashedFolder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Document \" + folder + \" indexed successfully\");\n\t\t}\n\n\t\treturn document;\n\t}","id":89758,"modified_method":"@Override\n\tprotected Document doGetDocument(Object obj) throws Exception {\n\t\tJournalFolder folder = (JournalFolder)obj;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Indexing folder \" + folder);\n\t\t}\n\n\t\tDocument document = getBaseModelDocument(PORTLET_ID, folder);\n\n\t\tdocument.addText(Field.DESCRIPTION, folder.getDescription());\n\t\tdocument.addKeyword(Field.FOLDER_ID, folder.getParentFolderId());\n\t\tdocument.addText(Field.TITLE, folder.getName());\n\t\tdocument.addKeyword(\n\t\t\tField.TREE_PATH,\n\t\t\tStringUtil.split(folder.getTreePath(), CharPool.SLASH));\n\n\t\tif (!folder.isInTrash() && folder.isInTrashContainer()) {\n\t\t\tJournalFolder trashedFolder = folder.getTrashContainer();\n\n\t\t\tif (trashedFolder != null) {\n\t\t\t\taddTrashFields(\n\t\t\t\t\tdocument, JournalFolder.class.getName(),\n\t\t\t\t\ttrashedFolder.getFolderId(), null, null,\n\t\t\t\t\tJournalFolderAssetRendererFactory.TYPE);\n\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_NAME, JournalFolder.class.getName());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.ROOT_ENTRY_CLASS_PK, trashedFolder.getFolderId());\n\t\t\t\tdocument.addKeyword(\n\t\t\t\t\tField.STATUS, WorkflowConstants.STATUS_IN_TRASH);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Document \" + folder + \" indexed successfully\");\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"307379fce075b414d17464e1110449ceb68d3792","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void printDiagnostics() {\n        m_out.println(\"* using '\" + m_user + \"' as the PostgreSQL \"\n                + \"user for OpenNMS\");\n        m_out.println(\"* using '\" + m_pass + \"' as the PostgreSQL \"\n                + \"password for OpenNMS\");\n        m_out.println(\"* using '\" + m_database + \"' as the PostgreSQL \"\n                + \"database name for OpenNMS\");\n    }","id":89759,"modified_method":"public void printDiagnostics() {\n        m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsUser()\n                      + \"' as the PostgreSQL \"\n                      + \"user for OpenNMS\");\n        m_out.println(\"* using '\" + m_installerDb.getPassword()\n                      + \"' as the PostgreSQL \"\n                      + \"password for OpenNMS\");\n        m_out.println(\"* using '\" + m_installerDb.getDatabaseName()\n                      + \"' as the PostgreSQL database name for OpenNMS\");\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void loadProperties() throws Exception {\n        m_properties = new Properties();\n        m_properties.load(Installer.class.getResourceAsStream(\"installer.properties\"));\n\n        /*\n         * Do this if we want to merge our properties with the system\n         * properties...\n         */\n        Properties sys = System.getProperties();\n        m_properties.putAll(sys);\n\n        m_opennms_home = fetchProperty(\"install.dir\");\n        m_database = fetchProperty(\"install.database.name\");\n        m_user = fetchProperty(\"install.database.user\");\n        m_pass = fetchProperty(\"install.database.password\");\n        m_pg_driver = fetchProperty(\"install.database.driver\");\n        m_pg_url = fetchProperty(\"install.database.url\");\n        m_pg_bindir = fetchProperty(\"install.database.bindir\");\n        m_sql_dir = fetchProperty(\"install.etc.dir\");\n        m_install_servletdir = fetchProperty(\"install.servlet.dir\");\n\n        String soext = fetchProperty(\"build.soext\");\n        String pg_iplike_dir = fetchProperty(\"install.postgresql.dir\");\n\n        m_pg_iplike = pg_iplike_dir + File.separator + \"iplike.\" + soext;\n        m_create_sql = m_sql_dir + File.separator + \"create.sql\";\n    }","id":89760,"modified_method":"public void loadProperties() throws Exception {\n        m_properties = new Properties();\n        m_properties.load(Installer.class.getResourceAsStream(\"installer.properties\"));\n\n        /*\n         * Do this if we want to merge our properties with the system\n         * properties...\n         */\n        Properties sys = System.getProperties();\n        m_properties.putAll(sys);\n\n        m_opennms_home = fetchProperty(\"install.dir\");\n        m_installerDb.setDatabaseName(fetchProperty(\"install.database.name\"));\n        m_installerDb.setPostgresOpennmsUser(fetchProperty(\"install.database.user\"));\n        m_installerDb.setPassword(fetchProperty(\"install.database.password\"));\n        m_pg_driver = fetchProperty(\"install.database.driver\");\n        m_pg_url = fetchProperty(\"install.database.url\");\n        m_installerDb.setProgresBinaryDirectory(fetchProperty(\"install.database.bindir\"));\n        String etcDirectory = fetchProperty(\"install.etc.dir\");\n        m_install_servletdir = fetchProperty(\"install.servlet.dir\");\n\n        String soext = fetchProperty(\"build.soext\");\n        String pg_iplike_dir = fetchProperty(\"install.postgresql.dir\");\n\n        m_installerDb.setPgIpLikeLocation(pg_iplike_dir + File.separator + \"iplike.\" + soext);\n\n        m_installerDb.setStoredProcedureDirectory(etcDirectory);\n        m_installerDb.setCreateSqlLocation(etcDirectory + File.separator + \"create.sql\");\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Installer() throws SQLException {\n        // The DEFAULT value for these columns will take care of these primary keys\n        m_columnReplacements.put(\"snmpinterface.id\", new DoNotAddColumn());\n        m_columnReplacements.put(\"ipinterface.id\", new DoNotAddColumn());\n        m_columnReplacements.put(\"ifservices.id\", new DoNotAddColumn());\n        m_columnReplacements.put(\"assets.id\", new DoNotAddColumn());\n\n        // Triggers will take care of these surrogate foreign keys\n        m_columnReplacements.put(\"ipinterface.snmpinterfaceid\",\n                                 new DoNotAddColumn());\n        m_columnReplacements.put(\"ifservices.ipinterfaceid\",\n                                 new DoNotAddColumn());\n        m_columnReplacements.put(\"outages.ifserviceid\", new DoNotAddColumn());\n        \n        m_columnReplacements.put(\"events.eventsource\",\n                                 new EventSourceReplacement());\n        \n        m_columnReplacements.put(\"outages.outageid\",\n                                 new AutoInteger(1));\n        \n        m_columnReplacements.put(\"snmpinterface.nodeid\",\n                                 new RowHasBogusData(\"snmpInterface\",\n                                                     \"nodeId\"));\n        \n        m_columnReplacements.put(\"snmpinterface.snmpifindex\",\n                                 new RowHasBogusData(\"snmpInterface\",\n                                                     \"snmpIfIndex\"));\n\n        m_columnReplacements.put(\"ipinterface.nodeid\",\n                                 new RowHasBogusData(\"ipInterface\", \"nodeId\"));\n\n        m_columnReplacements.put(\"ipinterface.ipaddr\",\n                                 new RowHasBogusData(\"ipInterface\", \"ipAddr\"));\n\n        m_columnReplacements.put(\"ifservices.nodeid\",\n                                 new RowHasBogusData(\"ifservices\", \"nodeId\"));\n\n        m_columnReplacements.put(\"ifservices.ipaddr\",\n                                 new RowHasBogusData(\"ifservices\", \"ipaddr\"));\n\n        m_columnReplacements.put(\"ifservices.serviceid\",\n                                 new RowHasBogusData(\"ifservices\",\n                                                     \"serviceId\"));\n\n        m_columnReplacements.put(\"outages.nodeid\",\n                                 new RowHasBogusData(\"outages\", \"nodeId\"));\n        \n        m_columnReplacements.put(\"outages.serviceid\",\n                                 new RowHasBogusData(\"outages\", \"serviceId\"));\n        \n        /*\n         * This is totally bogus.  outages.svcregainedeventid is a foreign\n         * key that points at events.eventid, and a fixed replacement of zero\n         * will break, because there should never be an event with an ID of\n         * zero.  I don't think it ever got executed before due to the\n         * null replacement only being performed if a column was marked as\n         * NOT NULL.\n         */\n        /*\n        m_columnReplacements.put(\"outages.svcregainedeventid\",\n                                 new FixedIntegerReplacement(0));\n                                 */\n        \n        // Disabled for the same reason as above\n        /*\n        m_columnReplacements.put(\"notifications.eventid\",\n                                 new FixedIntegerReplacement(0));\n                                 */\n        \n        m_columnReplacements.put(\"usersnotified.id\",\n                                 new NextValReplacement(\"userNotifNxtId\"));\n        \n    }","id":89761,"modified_method":"public Installer() {\n        setOutputStream(System.out);\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyFilesAndDirectories() throws FileNotFoundException {\n        if (m_update_database) {\n            verifyFileExists(true, m_sql_dir, \"SQL directory\",\n                             \"install.etc.dir property\");\n\n            verifyFileExists(false, m_create_sql, \"create.sql\",\n                             \"install.etc.dir property\");\n        }\n\n        if (m_update_iplike) {\n            verifyFileExists(false, m_pg_iplike, \"iplike module\",\n                             \"install.postgresql.dir property\");\n        }\n\n        if (m_tomcat_conf != null) {\n            verifyFileExists(\n                             false,\n                             m_tomcat_conf,\n                             \"Tomcat startup configuration file tomcat4.conf\",\n                             \"-T option\");\n        }\n\n        if (m_install_webapp) {\n            verifyFileExists(true, m_webappdir, \"Tomcat context directory\",\n                             \"-w option\");\n\n            verifyFileExists(true, m_install_servletdir,\n                             \"OpenNMS servlet directory\",\n                             \"install.servlet.dir property\");\n        }\n    }","id":89762,"modified_method":"public void verifyFilesAndDirectories() throws FileNotFoundException {\n        if (m_update_database) {\n            verifyFileExists(true, m_installerDb.getStoredProcedureDirectory(), \"SQL directory\",\n                             \"install.etc.dir property\");\n\n            verifyFileExists(false, m_installerDb.getCreateSqlLocation(),\n                             \"create.sql\",\n                             \"install.etc.dir property\");\n        }\n\n        if (m_update_iplike) {\n            verifyFileExists(false, m_installerDb.getPgIpLikeLocation(),\n                             \"iplike module\",\n                             \"install.postgresql.dir property\");\n        }\n\n        if (m_tomcat_conf != null) {\n            verifyFileExists(\n                             false,\n                             m_tomcat_conf,\n                             \"Tomcat startup configuration file tomcat4.conf\",\n                             \"-T option\");\n        }\n\n        if (m_install_webapp) {\n            verifyFileExists(true, m_webappdir, \"Tomcat context directory\",\n                             \"-w option\");\n\n            verifyFileExists(true, m_install_servletdir,\n                             \"OpenNMS servlet directory\",\n                             \"install.servlet.dir property\");\n        }\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void removeFile(String destination, String description,\n            boolean recursive) throws IOException, InterruptedException,\n            Exception {\n        String[] cmd;\n        ProcessExec e = new ProcessExec(m_out, m_out);\n\n        if (recursive) {\n            cmd = new String[3];\n            cmd[0] = \"rm\";\n            cmd[1] = \"-r\";\n            cmd[2] = destination;\n        } else {\n            cmd = new String[2];\n            cmd[0] = \"rm\";\n            cmd[1] = destination;\n        }\n        if (e.exec(cmd) != 0) {\n            throw new Exception(\"Non-zero exit value returned while \"\n                    + \"removing \" + description + \", \" + destination\n                    + \", using \\\"\" + join(\" \", cmd) + \"\\\"\");\n        }\n\n        if (new File(destination).exists()) {\n            throw new Exception(\"Could not delete existing \" + description\n                    + \": \" + destination);\n        }\n    }","id":89763,"modified_method":"public void removeFile(String destination, String description,\n            boolean recursive) throws IOException, InterruptedException,\n            Exception {\n        String[] cmd;\n        ProcessExec e = new ProcessExec(m_out, m_out);\n\n        if (recursive) {\n            cmd = new String[3];\n            cmd[0] = \"rm\";\n            cmd[1] = \"-r\";\n            cmd[2] = destination;\n        } else {\n            cmd = new String[2];\n            cmd[0] = \"rm\";\n            cmd[1] = destination;\n        }\n        if (e.exec(cmd) != 0) {\n            throw new Exception(\"Non-zero exit value returned while \"\n                    + \"removing \" + description + \", \" + destination\n                    + \", using \\\"\" + StringUtils.arrayToDelimitedString(cmd, \" \") + \"\\\"\");\n        }\n\n        if (new File(destination).exists()) {\n            throw new Exception(\"Could not delete existing \" + description\n                    + \": \" + destination);\n        }\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            throw new Exception(\"Nothing to do.\\n\" + m_required_options\n                    + \"\\nUse '-h' for help.\");\n        }\n\n        // Don't bother checking the Java version. Leave it up to runjava.\n        // checkJava();\n        // XXX Check Tomcat version?\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            databaseConnect(\"template1\");\n            databaseCheckVersion();\n            databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!databaseUserExists()) {\n                databaseAddUser();\n            }\n            if (!databaseDBExists()) {\n                databaseAddDB();\n            }\n        }\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            databaseDisconnect();\n\n            databaseConnect(m_database);\n        }\n\n        if (m_fix_constraint) {\n            fixConstraint();\n        }\n\n        if (m_update_database) {\n            checkOldTables();\n            if (!m_skip_constraints) {\n                checkConstraints();\n                checkIndexUniqueness();\n            }\n            createSequences();\n\n            // XXX should we be using createFunctions and createLanguages\n            // instead?\n            updatePlPgsql();\n\n            // XXX should we be using createFunctions instead?\n            addStoredProcedures();\n\n            createTables();\n            //createIndexes();\n            // createFunctions(m_cfunctions); // Unused, not in create.sql\n            // createLanguages(); // Unused, not in create.sql\n            // createFunctions(m_functions); // Unused, not in create.sql\n\n            fixData();\n        }\n\n        if (m_do_inserts) {\n            insertData();\n        }\n\n        if (m_update_unicode) {\n            checkUnicode();\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            updateIplike();\n        }\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts) {\n            databaseDisconnect();\n        }\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        System.out.println();\n        System.out.println(\"Installer completed successfully!\");\n    }","id":89764,"modified_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            throw new Exception(\"Nothing to do.\\n\" + m_required_options\n                    + \"\\nUse '-h' for help.\");\n        }\n        \n        DataSource adminDataSource =\n            new SimpleDataSource(m_pg_driver, m_pg_url + \"template1\",\n                                    m_pg_user, m_pg_pass);\n        m_installerDb.setAdminDataSource(adminDataSource);\n        DataSource opennmsDataSource =\n            new SimpleDataSource(m_pg_driver, m_pg_url + m_installerDb.getDatabaseName(),\n                                    m_pg_user, m_pg_pass);\n        m_installerDb.setDataSource(opennmsDataSource);\n\n        m_installerDb.addColumnReplacements();\n\n        // XXX Check Tomcat version?\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            m_installerDb.databaseCheckVersion();\n            m_installerDb.databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.createTables();\n            //createIndexes();\n            // createFunctions(m_cfunctions); // Unused, not in create.sql\n            // createLanguages(); // Unused, not in create.sql\n            // createFunctions(m_functions); // Unused, not in create.sql\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_installerDb.checkUnicode();\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts) {\n            m_installerDb.closeConnection();\n            m_installerDb.closeAdminConnection();\n        }\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void parseArguments(String[] argv) throws Exception {\n        LinkedList<String> args = new LinkedList<String>();\n\n        for (int i = 0; i < argv.length; i++) {\n            StringBuffer b = new StringBuffer(argv[i]);\n            boolean is_arg = false;\n\n            while (b.length() > 0 && b.charAt(0) == '-') {\n                is_arg = true;\n                b.deleteCharAt(0);\n            }\n\n            if (is_arg) {\n                while (b.length() > 0) {\n                    char c = b.charAt(0);\n                    b.deleteCharAt(0);\n\n                    switch (c) {\n                    case 'h':\n                        printHelp();\n                        break;\n\n                    case 'c':\n                        m_force = true;\n                        break;\n\n                    case 'C':\n                        i++;\n                        m_fix_constraint = true;\n                        m_fix_constraint_name = getNextArg(argv, i, 'C');\n                        break;\n\n                    case 'd':\n                        m_update_database = true;\n                        break;\n\n                    case 'i':\n                        m_do_inserts = true;\n                        break;\n\n                    case 'n':\n                        m_skip_constraints = true;\n\n                    case 'N':\n                        m_ignore_notnull = true;\n                        break;\n\n                    case 'p':\n                        i++;\n                        m_pg_pass = getNextArg(argv, i, 'p');\n                        break;\n\n                    case 'R':\n                        m_no_revert = true;\n                        break;\n\n                    case 's':\n                        m_update_iplike = true;\n                        break;\n\n                    case 'T':\n                        i++;\n                        m_tomcat_conf = getNextArg(argv, i, 'T');\n                        break;\n\n                    case 'u':\n                        i++;\n                        m_pg_user = getNextArg(argv, i, 'u');\n                        break;\n\n                    case 'U':\n                        m_update_unicode = true;\n                        break;\n\n                    case 'w':\n                        i++;\n                        m_webappdir = getNextArg(argv, i, 'w');\n                        break;\n\n                    case 'x':\n                        m_debug = true;\n                        break;\n\n                    case 'X':\n                        m_fix_constraint_remove_rows = true;\n                        break;\n\n                    case 'y':\n                        m_install_webapp = true;\n                        break;\n\n                    default:\n                        throw new Exception(\"unknown option '\" + c + \"'\"\n                                + \", use '-h' option for usage\");\n                    }\n                }\n            } else {\n                args.add(argv[i]);\n            }\n        }\n\n        if (args.size() != 0) {\n            throw new Exception(\"too many command-line arguments specified\");\n        }\n    }","id":89765,"modified_method":"public void parseArguments(String[] argv) throws Exception {\n        LinkedList<String> args = new LinkedList<String>();\n\n        for (int i = 0; i < argv.length; i++) {\n            StringBuffer b = new StringBuffer(argv[i]);\n            boolean is_arg = false;\n\n            while (b.length() > 0 && b.charAt(0) == '-') {\n                is_arg = true;\n                b.deleteCharAt(0);\n            }\n\n            if (is_arg) {\n                while (b.length() > 0) {\n                    char c = b.charAt(0);\n                    b.deleteCharAt(0);\n\n                    switch (c) {\n                    case 'h':\n                        printHelp();\n                        break;\n\n                    case 'c':\n                        m_installerDb.setForce(true);\n                        break;\n\n                    case 'C':\n                        i++;\n                        m_fix_constraint = true;\n                        m_fix_constraint_name = getNextArg(argv, i, 'C');\n                        break;\n\n                    case 'd':\n                        m_update_database = true;\n                        break;\n\n                    case 'i':\n                        m_do_inserts = true;\n                        break;\n\n                    case 'n':\n                        m_skip_constraints = true;\n\n                    case 'N':\n                        m_installerDb.setIgnoreNotNull(true);\n                        break;\n\n                    case 'p':\n                        i++;\n                        m_pg_pass = getNextArg(argv, i, 'p');\n                        break;\n\n                    case 'R':\n                        m_installerDb.setNoRevert(true);\n                        break;\n\n                    case 's':\n                        m_update_iplike = true;\n                        break;\n\n                    case 'T':\n                        i++;\n                        m_tomcat_conf = getNextArg(argv, i, 'T');\n                        break;\n\n                    case 'u':\n                        i++;\n                        m_installerDb.setPostgresAdminUser(getNextArg(argv, i, 'u'));\n                        break;\n\n                    case 'U':\n                        m_update_unicode = true;\n                        break;\n\n                    case 'w':\n                        i++;\n                        m_webappdir = getNextArg(argv, i, 'w');\n                        break;\n\n                    case 'x':\n                        m_installerDb.setDebug(true);\n                        break;\n\n                    case 'X':\n                        m_fix_constraint_remove_rows = true;\n                        break;\n\n                    case 'y':\n                        m_install_webapp = true;\n                        break;\n\n                    default:\n                        throw new Exception(\"unknown option '\" + c + \"'\"\n                                + \", use '-h' option for usage\");\n                    }\n                }\n            } else {\n                args.add(argv[i]);\n            }\n        }\n\n        if (args.size() != 0) {\n            throw new Exception(\"too many command-line arguments specified\");\n        }\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void pingLocalhost() throws IOException {\n        String host = \"127.0.0.1\";\n\n        IcmpSocket m_socket = null;\n\n        try {\n                m_socket = new IcmpSocket();\n        } catch (UnsatisfiedLinkError e) {\n                m_out.println(\"UnsatisfiedLinkError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.  Try setting the property \"\n                              + \"'opennms.library.jicmp' to point at the \"\n                              + \"full path name of the libjicmp.so shared \"\n                              + \"library \"\n                              + \"(e.g. 'java -Dopennms.library.jicmp=/some/path/libjicmp.so ...')\");\n                throw e;\n        } catch (NoClassDefFoundError e) {\n                m_out.println(\"NoClassDefFoundError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.\");\n                throw e;\n        } catch (IOException e) {\n                m_out.println(\"IOException while creating an \"\n                              + \"IcmpSocket.\");\n                throw e;\n        }\n\n        java.net.InetAddress addr = null;\n        try {\n            addr = java.net.InetAddress.getByName(host);\n        } catch (java.net.UnknownHostException e) {\n            m_out.println(\"UnknownHostException when looking up \"\n                           + host + \".\");\n            throw e;\n\n        }\n\n        m_out.println(\"PING \" + host + \" (\" + addr.getHostAddress()\n                      + \"): 56 data bytes\");\n\n        short m_icmpId = 2;\n\n        IcmpSocket.Stuff s = new IcmpSocket.Stuff(m_socket, m_icmpId);\n        Thread t = new Thread(s);\n        t.start();\n\n        int count = 3;\n        for (long attempt = 0; attempt < count; attempt++) {\n            // build a packet\n            org.opennms.netmgt.ping.Packet pingPkt =\n                new org.opennms.netmgt.ping.Packet(attempt);\n            pingPkt.setIdentity(m_icmpId);\n            pingPkt.computeChecksum();\n        \n            // convert it to a datagram to be sent\n            byte[] buf = pingPkt.toBytes();\n            DatagramPacket sendPkt =\n                new DatagramPacket(buf, buf.length, addr, 0);\n            buf = null;\n            pingPkt = null;\n\n            try {\n                m_socket.send(sendPkt);\n            } catch (IOException e) {\n                m_out.println(\"IOException received when sending packet.\");\n                throw e;\n            }\n            try {\n                Thread.currentThread().sleep(1000);\n            } catch (InterruptedException e) {\n                // do nothing\n            }\n        }\n\n    }","id":89766,"modified_method":"public void pingLocalhost() throws IOException {\n        String host = \"127.0.0.1\";\n\n        IcmpSocket m_socket = null;\n\n        try {\n                m_socket = new IcmpSocket();\n        } catch (UnsatisfiedLinkError e) {\n                m_out.println(\"UnsatisfiedLinkError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.  Try setting the property \"\n                              + \"'opennms.library.jicmp' to point at the \"\n                              + \"full path name of the libjicmp.so shared \"\n                              + \"library \"\n                              + \"(e.g. 'java -Dopennms.library.jicmp=/some/path/libjicmp.so ...')\");\n                throw e;\n        } catch (NoClassDefFoundError e) {\n                m_out.println(\"NoClassDefFoundError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.\");\n                throw e;\n        } catch (IOException e) {\n                m_out.println(\"IOException while creating an \"\n                              + \"IcmpSocket.\");\n                throw e;\n        }\n\n        java.net.InetAddress addr = null;\n        try {\n            addr = java.net.InetAddress.getByName(host);\n        } catch (java.net.UnknownHostException e) {\n            m_out.println(\"UnknownHostException when looking up \"\n                           + host + \".\");\n            throw e;\n\n        }\n\n        m_out.println(\"PING \" + host + \" (\" + addr.getHostAddress()\n                      + \"): 56 data bytes\");\n\n        short m_icmpId = 2;\n\n        IcmpSocket.Stuff s = new IcmpSocket.Stuff(m_socket, m_icmpId);\n        Thread t = new Thread(s);\n        t.start();\n\n        int count = 3;\n        for (long attempt = 0; attempt < count; attempt++) {\n            // build a packet\n            org.opennms.netmgt.ping.Packet pingPkt =\n                new org.opennms.netmgt.ping.Packet(attempt);\n            pingPkt.setIdentity(m_icmpId);\n            pingPkt.computeChecksum();\n        \n            // convert it to a datagram to be sent\n            byte[] buf = pingPkt.toBytes();\n            DatagramPacket sendPkt =\n                new DatagramPacket(buf, buf.length, addr, 0);\n            buf = null;\n            pingPkt = null;\n\n            try {\n                m_socket.send(sendPkt);\n            } catch (IOException e) {\n                m_out.println(\"IOException received when sending packet.\");\n                throw e;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // do nothing\n            }\n        }\n\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setUp() throws IOException, SQLException {\n        m_anticipator = new FileAnticipator();\n        File dist = m_anticipator.tempDir(\"dist\");\n        File dist_webapps = m_anticipator.tempDir(dist, \"webapps\");\n        File opennms_webapp = m_anticipator.tempDir(dist_webapps, \"opennms\");\n        File meta_inf = m_anticipator.tempDir(opennms_webapp, \"META-INF\");\n        m_anticipator.tempFile(meta_inf, \"context.xml\");\n\n        File web_inf = m_anticipator.tempDir(opennms_webapp, \"WEB-INF\");\n        File lib = m_anticipator.tempDir(web_inf, \"lib\");\n        m_anticipator.tempFile(lib, \"log4j.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.tempFile(lib, \"opennms_core.jar\");\n        m_anticipator.tempFile(lib, \"opennms_services.jar\");\n        m_anticipator.tempFile(lib, \"opennms_web.jar\");\n\n        m_tomcat = m_anticipator.tempDir(\"tomcat\");\n        m_tomcat_webapps = m_anticipator.tempDir(m_tomcat, \"webapps\");\n        m_tomcat_conf_dir = m_anticipator.tempDir(m_tomcat, \"conf\");\n        File tomcat_server = m_anticipator.tempDir(m_tomcat, \"server\");\n        File tomcat_lib = m_anticipator.tempDir(tomcat_server, \"lib\");\n\n        m_anticipator.expecting(m_tomcat_webapps, \"opennms.xml\");\n        m_anticipator.expecting(tomcat_lib, \"log4j.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_core.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_services.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_web.jar\");\n\n        m_installer = new Installer();\n        m_installer.m_out = new PrintStream(new ByteArrayOutputStream());\n        // m_installer.m_out = System.out;\n        m_installer.m_install_servletdir = opennms_webapp.getAbsolutePath();\n        m_installer.m_webappdir = m_tomcat_webapps.getAbsolutePath();\n    }","id":89767,"modified_method":"public void setUp() throws IOException, SQLException {\n        m_anticipator = new FileAnticipator();\n        File dist = m_anticipator.tempDir(\"dist\");\n        File dist_webapps = m_anticipator.tempDir(dist, \"webapps\");\n        File opennms_webapp = m_anticipator.tempDir(dist_webapps, \"opennms\");\n        File meta_inf = m_anticipator.tempDir(opennms_webapp, \"META-INF\");\n        m_anticipator.tempFile(meta_inf, \"context.xml\");\n\n        File web_inf = m_anticipator.tempDir(opennms_webapp, \"WEB-INF\");\n        File lib = m_anticipator.tempDir(web_inf, \"lib\");\n        m_anticipator.tempFile(lib, \"log4j.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.tempFile(lib, \"opennms_core.jar\");\n        m_anticipator.tempFile(lib, \"opennms_services.jar\");\n        m_anticipator.tempFile(lib, \"opennms_web.jar\");\n\n        m_tomcat = m_anticipator.tempDir(\"tomcat\");\n        m_tomcat_webapps = m_anticipator.tempDir(m_tomcat, \"webapps\");\n        m_tomcat_conf_dir = m_anticipator.tempDir(m_tomcat, \"conf\");\n        File tomcat_server = m_anticipator.tempDir(m_tomcat, \"server\");\n        File tomcat_lib = m_anticipator.tempDir(tomcat_server, \"lib\");\n\n        m_anticipator.expecting(m_tomcat_webapps, \"opennms.xml\");\n        m_anticipator.expecting(tomcat_lib, \"log4j.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_core.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_services.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_web.jar\");\n\n        m_installer = new Installer();\n        m_installer.setOutputStream(new PrintStream(new ByteArrayOutputStream()));\n        m_installer.m_install_servletdir = opennms_webapp.getAbsolutePath();\n        m_installer.m_webappdir = m_tomcat_webapps.getAbsolutePath();\n    }","commit_id":"1cdd3b088b1960b9c889f94e2c56348593dbbc4c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Installer() throws SQLException {\n        // The DEFAULT value for these columns will take care of these primary keys\n        m_columnReplacements.put(\"snmpinterface.id\", new DoNotAddColumn());\n        m_columnReplacements.put(\"ipinterface.id\", new DoNotAddColumn());\n        m_columnReplacements.put(\"ifservices.id\", new DoNotAddColumn());\n        m_columnReplacements.put(\"assets.id\", new DoNotAddColumn());\n\n        // Triggers will take care of these surrogate foreign keys\n        m_columnReplacements.put(\"ipinterface.snmpinterfaceid\",\n                                 new DoNotAddColumn());\n        m_columnReplacements.put(\"ifservices.ipinterfaceid\",\n                                 new DoNotAddColumn());\n        m_columnReplacements.put(\"outages.ifserviceid\", new DoNotAddColumn());\n        \n        m_columnReplacements.put(\"events.eventsource\",\n                                 new EventSourceReplacement());\n        \n        m_columnReplacements.put(\"outages.outageid\",\n                                 new AutoInteger(1));\n        \n        m_columnReplacements.put(\"snmpinterface.nodeid\",\n                                 new RowHasBogusData(\"snmpInterface\",\n                                                     \"nodeId\"));\n        \n        m_columnReplacements.put(\"snmpinterface.snmpifindex\",\n                                 new RowHasBogusData(\"snmpInterface\",\n                                                     \"snmpIfIndex\"));\n\n        m_columnReplacements.put(\"ipinterface.nodeid\",\n                                 new RowHasBogusData(\"ipInterface\", \"nodeId\"));\n\n        m_columnReplacements.put(\"ipinterface.ipaddr\",\n                                 new RowHasBogusData(\"ipInterface\", \"ipAddr\"));\n\n        m_columnReplacements.put(\"ifservices.nodeid\",\n                                 new RowHasBogusData(\"ifservices\", \"nodeId\"));\n\n        m_columnReplacements.put(\"ifservices.ipaddr\",\n                                 new RowHasBogusData(\"ifservices\", \"ipaddr\"));\n\n        m_columnReplacements.put(\"ifservices.serviceid\",\n                                 new RowHasBogusData(\"ifservices\",\n                                                     \"serviceId\"));\n\n        m_columnReplacements.put(\"outages.nodeid\",\n                                 new RowHasBogusData(\"outages\", \"nodeId\"));\n        \n        m_columnReplacements.put(\"outages.serviceid\",\n                                 new RowHasBogusData(\"outages\", \"serviceId\"));\n        \n        /*\n         * This is totally bogus.  outages.svcregainedeventid is a foreign\n         * key that points at events.eventid, and a fixed replacement of zero\n         * will break, because there should never be an event with an ID of\n         * zero.  I don't think it ever got executed before due to the\n         * null replacement only being performed if a column was marked as\n         * NOT NULL.\n         */\n        /*\n        m_columnReplacements.put(\"outages.svcregainedeventid\",\n                                 new FixedIntegerReplacement(0));\n                                 */\n        \n        // Disabled for the same reason as above\n        /*\n        m_columnReplacements.put(\"notifications.eventid\",\n                                 new FixedIntegerReplacement(0));\n                                 */\n        \n        m_columnReplacements.put(\"usersnotified.id\",\n                                 new NextValReplacement(\"userNotifNxtId\"));\n        \n    }","id":89768,"modified_method":"public Installer() {\n        setOutputStream(System.out);\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void verifyFilesAndDirectories() throws FileNotFoundException {\n        if (m_update_database) {\n            verifyFileExists(true, m_sql_dir, \"SQL directory\",\n                             \"install.etc.dir property\");\n\n            verifyFileExists(false, m_create_sql, \"create.sql\",\n                             \"install.etc.dir property\");\n        }\n\n        if (m_update_iplike) {\n            verifyFileExists(false, m_pg_iplike, \"iplike module\",\n                             \"install.postgresql.dir property\");\n        }\n\n        if (m_tomcat_conf != null) {\n            verifyFileExists(\n                             false,\n                             m_tomcat_conf,\n                             \"Tomcat startup configuration file tomcat4.conf\",\n                             \"-T option\");\n        }\n\n        if (m_install_webapp) {\n            verifyFileExists(true, m_webappdir, \"Tomcat context directory\",\n                             \"-w option\");\n\n            verifyFileExists(true, m_install_servletdir,\n                             \"OpenNMS servlet directory\",\n                             \"install.servlet.dir property\");\n        }\n    }","id":89769,"modified_method":"public void verifyFilesAndDirectories() throws FileNotFoundException {\n        if (m_update_database) {\n            verifyFileExists(true, m_installerDb.getStoredProcedureDirectory(), \"SQL directory\",\n                             \"install.etc.dir property\");\n\n            verifyFileExists(false, m_installerDb.getCreateSqlLocation(),\n                             \"create.sql\",\n                             \"install.etc.dir property\");\n        }\n\n        if (m_update_iplike) {\n            verifyFileExists(false, m_installerDb.getPgIpLikeLocation(),\n                             \"iplike module\",\n                             \"install.postgresql.dir property\");\n        }\n\n        if (m_tomcat_conf != null) {\n            verifyFileExists(\n                             false,\n                             m_tomcat_conf,\n                             \"Tomcat startup configuration file tomcat4.conf\",\n                             \"-T option\");\n        }\n\n        if (m_install_webapp) {\n            verifyFileExists(true, m_webappdir, \"Tomcat context directory\",\n                             \"-w option\");\n\n            verifyFileExists(true, m_install_servletdir,\n                             \"OpenNMS servlet directory\",\n                             \"install.servlet.dir property\");\n        }\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void removeFile(String destination, String description,\n            boolean recursive) throws IOException, InterruptedException,\n            Exception {\n        String[] cmd;\n        ProcessExec e = new ProcessExec(m_out, m_out);\n\n        if (recursive) {\n            cmd = new String[3];\n            cmd[0] = \"rm\";\n            cmd[1] = \"-r\";\n            cmd[2] = destination;\n        } else {\n            cmd = new String[2];\n            cmd[0] = \"rm\";\n            cmd[1] = destination;\n        }\n        if (e.exec(cmd) != 0) {\n            throw new Exception(\"Non-zero exit value returned while \"\n                    + \"removing \" + description + \", \" + destination\n                    + \", using \\\"\" + join(\" \", cmd) + \"\\\"\");\n        }\n\n        if (new File(destination).exists()) {\n            throw new Exception(\"Could not delete existing \" + description\n                    + \": \" + destination);\n        }\n    }","id":89770,"modified_method":"public void removeFile(String destination, String description,\n            boolean recursive) throws IOException, InterruptedException,\n            Exception {\n        String[] cmd;\n        ProcessExec e = new ProcessExec(m_out, m_out);\n\n        if (recursive) {\n            cmd = new String[3];\n            cmd[0] = \"rm\";\n            cmd[1] = \"-r\";\n            cmd[2] = destination;\n        } else {\n            cmd = new String[2];\n            cmd[0] = \"rm\";\n            cmd[1] = destination;\n        }\n        if (e.exec(cmd) != 0) {\n            throw new Exception(\"Non-zero exit value returned while \"\n                    + \"removing \" + description + \", \" + destination\n                    + \", using \\\"\" + StringUtils.arrayToDelimitedString(cmd, \" \") + \"\\\"\");\n        }\n\n        if (new File(destination).exists()) {\n            throw new Exception(\"Could not delete existing \" + description\n                    + \": \" + destination);\n        }\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void loadProperties() throws Exception {\n        m_properties = new Properties();\n        m_properties.load(Installer.class.getResourceAsStream(\"installer.properties\"));\n\n        /*\n         * Do this if we want to merge our properties with the system\n         * properties...\n         */\n        Properties sys = System.getProperties();\n        m_properties.putAll(sys);\n\n        m_opennms_home = fetchProperty(\"install.dir\");\n        m_database = fetchProperty(\"install.database.name\");\n        m_user = fetchProperty(\"install.database.user\");\n        m_pass = fetchProperty(\"install.database.password\");\n        m_pg_driver = fetchProperty(\"install.database.driver\");\n        m_pg_url = fetchProperty(\"install.database.url\");\n        m_pg_bindir = fetchProperty(\"install.database.bindir\");\n        m_sql_dir = fetchProperty(\"install.etc.dir\");\n        m_install_servletdir = fetchProperty(\"install.servlet.dir\");\n\n        String soext = fetchProperty(\"build.soext\");\n        String pg_iplike_dir = fetchProperty(\"install.postgresql.dir\");\n\n        m_pg_iplike = pg_iplike_dir + File.separator + \"iplike.\" + soext;\n        m_create_sql = m_sql_dir + File.separator + \"create.sql\";\n    }","id":89771,"modified_method":"public void loadProperties() throws Exception {\n        m_properties = new Properties();\n        m_properties.load(Installer.class.getResourceAsStream(\"installer.properties\"));\n\n        /*\n         * Do this if we want to merge our properties with the system\n         * properties...\n         */\n        Properties sys = System.getProperties();\n        m_properties.putAll(sys);\n\n        m_opennms_home = fetchProperty(\"install.dir\");\n        m_installerDb.setDatabaseName(fetchProperty(\"install.database.name\"));\n        m_installerDb.setPostgresOpennmsUser(fetchProperty(\"install.database.user\"));\n        m_installerDb.setPassword(fetchProperty(\"install.database.password\"));\n        m_pg_driver = fetchProperty(\"install.database.driver\");\n        m_pg_url = fetchProperty(\"install.database.url\");\n        m_installerDb.setProgresBinaryDirectory(fetchProperty(\"install.database.bindir\"));\n        String etcDirectory = fetchProperty(\"install.etc.dir\");\n        m_install_servletdir = fetchProperty(\"install.servlet.dir\");\n\n        String soext = fetchProperty(\"build.soext\");\n        String pg_iplike_dir = fetchProperty(\"install.postgresql.dir\");\n\n        m_installerDb.setPgIpLikeLocation(pg_iplike_dir + File.separator + \"iplike.\" + soext);\n\n        m_installerDb.setStoredProcedureDirectory(etcDirectory);\n        m_installerDb.setCreateSqlLocation(etcDirectory + File.separator + \"create.sql\");\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void printDiagnostics() {\n        m_out.println(\"* using '\" + m_user + \"' as the PostgreSQL \"\n                + \"user for OpenNMS\");\n        m_out.println(\"* using '\" + m_pass + \"' as the PostgreSQL \"\n                + \"password for OpenNMS\");\n        m_out.println(\"* using '\" + m_database + \"' as the PostgreSQL \"\n                + \"database name for OpenNMS\");\n    }","id":89772,"modified_method":"public void printDiagnostics() {\n        m_out.println(\"* using '\" + m_installerDb.getPostgresOpennmsUser()\n                      + \"' as the PostgreSQL \"\n                      + \"user for OpenNMS\");\n        m_out.println(\"* using '\" + m_installerDb.getPassword()\n                      + \"' as the PostgreSQL \"\n                      + \"password for OpenNMS\");\n        m_out.println(\"* using '\" + m_installerDb.getDatabaseName()\n                      + \"' as the PostgreSQL database name for OpenNMS\");\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void pingLocalhost() throws IOException {\n        String host = \"127.0.0.1\";\n\n        IcmpSocket m_socket = null;\n\n        try {\n                m_socket = new IcmpSocket();\n        } catch (UnsatisfiedLinkError e) {\n                m_out.println(\"UnsatisfiedLinkError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.  Try setting the property \"\n                              + \"'opennms.library.jicmp' to point at the \"\n                              + \"full path name of the libjicmp.so shared \"\n                              + \"library \"\n                              + \"(e.g. 'java -Dopennms.library.jicmp=/some/path/libjicmp.so ...')\");\n                throw e;\n        } catch (NoClassDefFoundError e) {\n                m_out.println(\"NoClassDefFoundError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.\");\n                throw e;\n        } catch (IOException e) {\n                m_out.println(\"IOException while creating an \"\n                              + \"IcmpSocket.\");\n                throw e;\n        }\n\n        java.net.InetAddress addr = null;\n        try {\n            addr = java.net.InetAddress.getByName(host);\n        } catch (java.net.UnknownHostException e) {\n            m_out.println(\"UnknownHostException when looking up \"\n                           + host + \".\");\n            throw e;\n\n        }\n\n        m_out.println(\"PING \" + host + \" (\" + addr.getHostAddress()\n                      + \"): 56 data bytes\");\n\n        short m_icmpId = 2;\n\n        IcmpSocket.Stuff s = new IcmpSocket.Stuff(m_socket, m_icmpId);\n        Thread t = new Thread(s);\n        t.start();\n\n        int count = 3;\n        for (long attempt = 0; attempt < count; attempt++) {\n            // build a packet\n            org.opennms.netmgt.ping.Packet pingPkt =\n                new org.opennms.netmgt.ping.Packet(attempt);\n            pingPkt.setIdentity(m_icmpId);\n            pingPkt.computeChecksum();\n        \n            // convert it to a datagram to be sent\n            byte[] buf = pingPkt.toBytes();\n            DatagramPacket sendPkt =\n                new DatagramPacket(buf, buf.length, addr, 0);\n            buf = null;\n            pingPkt = null;\n\n            try {\n                m_socket.send(sendPkt);\n            } catch (IOException e) {\n                m_out.println(\"IOException received when sending packet.\");\n                throw e;\n            }\n            try {\n                Thread.currentThread().sleep(1000);\n            } catch (InterruptedException e) {\n                // do nothing\n            }\n        }\n\n    }","id":89773,"modified_method":"public void pingLocalhost() throws IOException {\n        String host = \"127.0.0.1\";\n\n        IcmpSocket m_socket = null;\n\n        try {\n                m_socket = new IcmpSocket();\n        } catch (UnsatisfiedLinkError e) {\n                m_out.println(\"UnsatisfiedLinkError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.  Try setting the property \"\n                              + \"'opennms.library.jicmp' to point at the \"\n                              + \"full path name of the libjicmp.so shared \"\n                              + \"library \"\n                              + \"(e.g. 'java -Dopennms.library.jicmp=/some/path/libjicmp.so ...')\");\n                throw e;\n        } catch (NoClassDefFoundError e) {\n                m_out.println(\"NoClassDefFoundError while creating an \"\n                              + \"IcmpSocket.  Most likely failed to load \"\n                              + \"libjicmp.so.\");\n                throw e;\n        } catch (IOException e) {\n                m_out.println(\"IOException while creating an \"\n                              + \"IcmpSocket.\");\n                throw e;\n        }\n\n        java.net.InetAddress addr = null;\n        try {\n            addr = java.net.InetAddress.getByName(host);\n        } catch (java.net.UnknownHostException e) {\n            m_out.println(\"UnknownHostException when looking up \"\n                           + host + \".\");\n            throw e;\n\n        }\n\n        m_out.println(\"PING \" + host + \" (\" + addr.getHostAddress()\n                      + \"): 56 data bytes\");\n\n        short m_icmpId = 2;\n\n        IcmpSocket.Stuff s = new IcmpSocket.Stuff(m_socket, m_icmpId);\n        Thread t = new Thread(s);\n        t.start();\n\n        int count = 3;\n        for (long attempt = 0; attempt < count; attempt++) {\n            // build a packet\n            org.opennms.netmgt.ping.Packet pingPkt =\n                new org.opennms.netmgt.ping.Packet(attempt);\n            pingPkt.setIdentity(m_icmpId);\n            pingPkt.computeChecksum();\n        \n            // convert it to a datagram to be sent\n            byte[] buf = pingPkt.toBytes();\n            DatagramPacket sendPkt =\n                new DatagramPacket(buf, buf.length, addr, 0);\n            buf = null;\n            pingPkt = null;\n\n            try {\n                m_socket.send(sendPkt);\n            } catch (IOException e) {\n                m_out.println(\"IOException received when sending packet.\");\n                throw e;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // do nothing\n            }\n        }\n\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            throw new Exception(\"Nothing to do.\\n\" + m_required_options\n                    + \"\\nUse '-h' for help.\");\n        }\n\n        // Don't bother checking the Java version. Leave it up to runjava.\n        // checkJava();\n        // XXX Check Tomcat version?\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            databaseConnect(\"template1\");\n            databaseCheckVersion();\n            databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!databaseUserExists()) {\n                databaseAddUser();\n            }\n            if (!databaseDBExists()) {\n                databaseAddDB();\n            }\n        }\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            databaseDisconnect();\n\n            databaseConnect(m_database);\n        }\n\n        if (m_fix_constraint) {\n            fixConstraint();\n        }\n\n        if (m_update_database) {\n            checkOldTables();\n            if (!m_skip_constraints) {\n                checkConstraints();\n                checkIndexUniqueness();\n            }\n            createSequences();\n\n            // XXX should we be using createFunctions and createLanguages\n            // instead?\n            updatePlPgsql();\n\n            // XXX should we be using createFunctions instead?\n            addStoredProcedures();\n\n            createTables();\n            //createIndexes();\n            // createFunctions(m_cfunctions); // Unused, not in create.sql\n            // createLanguages(); // Unused, not in create.sql\n            // createFunctions(m_functions); // Unused, not in create.sql\n\n            fixData();\n        }\n\n        if (m_do_inserts) {\n            insertData();\n        }\n\n        if (m_update_unicode) {\n            checkUnicode();\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            updateIplike();\n        }\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts) {\n            databaseDisconnect();\n        }\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        System.out.println();\n        System.out.println(\"Installer completed successfully!\");\n    }","id":89774,"modified_method":"public void install(String[] argv) throws Exception {\n        printHeader();\n        loadProperties();\n        parseArguments(argv);\n\n        if (!m_update_database && !m_do_inserts && !m_update_iplike\n                && !m_update_unicode && m_tomcat_conf == null\n                && !m_install_webapp && !m_fix_constraint) {\n            throw new Exception(\"Nothing to do.\\n\" + m_required_options\n                    + \"\\nUse '-h' for help.\");\n        }\n        \n        DataSource adminDataSource =\n            new SimpleDataSource(m_pg_driver, m_pg_url + \"template1\",\n                                    m_pg_user, m_pg_pass);\n        m_installerDb.setAdminDataSource(adminDataSource);\n        DataSource opennmsDataSource =\n            new SimpleDataSource(m_pg_driver, m_pg_url + m_installerDb.getDatabaseName(),\n                                    m_pg_user, m_pg_pass);\n        m_installerDb.setDataSource(opennmsDataSource);\n\n        m_installerDb.addColumnReplacements();\n\n        // XXX Check Tomcat version?\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts || m_fix_constraint) {\n            m_installerDb.databaseCheckVersion();\n            m_installerDb.databaseCheckLanguage();\n        }\n\n        printDiagnostics();\n\n        verifyFilesAndDirectories();\n\n        if (m_install_webapp) {\n            checkWebappOldOpennmsDir();\n            checkServerXmlOldOpennmsContext();\n        }\n\n        if (m_update_database || m_fix_constraint) {\n            m_installerDb.readTables();\n        }\n\n        if (m_update_database) {\n            // XXX Check and optionally modify pg_hba.conf\n\n            if (!m_installerDb.databaseUserExists()) {\n                m_installerDb.databaseAddUser();\n            }\n            if (!m_installerDb.databaseDBExists()) {\n                m_installerDb.databaseAddDB();\n            }\n        }\n\n        if (m_fix_constraint) {\n            m_installerDb.fixConstraint(m_fix_constraint_name,\n                                        m_fix_constraint_remove_rows);\n        }\n\n        if (m_update_database) {\n            m_installerDb.checkOldTables();\n            if (!m_skip_constraints) {\n                m_installerDb.checkConstraints();\n                m_installerDb.checkIndexUniqueness();\n            }\n            m_installerDb.createSequences();\n\n            // should we be using createFunctions and createLanguages instead?\n            m_installerDb.updatePlPgsql();\n\n            // should we be using createFunctions instead?\n            m_installerDb.addStoredProcedures();\n\n            m_installerDb.createTables();\n            //createIndexes();\n            // createFunctions(m_cfunctions); // Unused, not in create.sql\n            // createLanguages(); // Unused, not in create.sql\n            // createFunctions(m_functions); // Unused, not in create.sql\n\n            m_installerDb.fixData();\n        }\n\n        if (m_do_inserts) {\n            m_installerDb.insertData();\n        }\n\n        if (m_update_unicode) {\n            m_installerDb.checkUnicode();\n        }\n\n        if (m_install_webapp) {\n            installWebApp();\n        }\n\n        if (m_tomcat_conf != null) {\n            updateTomcatConf();\n        }\n\n        if (m_update_iplike) {\n            m_installerDb.updateIplike();\n        }\n\n        if (m_update_database || m_update_iplike || m_update_unicode\n                || m_do_inserts) {\n            m_installerDb.closeConnection();\n            m_installerDb.closeAdminConnection();\n        }\n\n        if (m_update_database) {\n            createConfiguredFile();\n        }\n\n        m_out.println();\n        m_out.println(\"Installer completed successfully!\");\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void parseArguments(String[] argv) throws Exception {\n        LinkedList<String> args = new LinkedList<String>();\n\n        for (int i = 0; i < argv.length; i++) {\n            StringBuffer b = new StringBuffer(argv[i]);\n            boolean is_arg = false;\n\n            while (b.length() > 0 && b.charAt(0) == '-') {\n                is_arg = true;\n                b.deleteCharAt(0);\n            }\n\n            if (is_arg) {\n                while (b.length() > 0) {\n                    char c = b.charAt(0);\n                    b.deleteCharAt(0);\n\n                    switch (c) {\n                    case 'h':\n                        printHelp();\n                        break;\n\n                    case 'c':\n                        m_force = true;\n                        break;\n\n                    case 'C':\n                        i++;\n                        m_fix_constraint = true;\n                        m_fix_constraint_name = getNextArg(argv, i, 'C');\n                        break;\n\n                    case 'd':\n                        m_update_database = true;\n                        break;\n\n                    case 'i':\n                        m_do_inserts = true;\n                        break;\n\n                    case 'n':\n                        m_skip_constraints = true;\n\n                    case 'N':\n                        m_ignore_notnull = true;\n                        break;\n\n                    case 'p':\n                        i++;\n                        m_pg_pass = getNextArg(argv, i, 'p');\n                        break;\n\n                    case 'R':\n                        m_no_revert = true;\n                        break;\n\n                    case 's':\n                        m_update_iplike = true;\n                        break;\n\n                    case 'T':\n                        i++;\n                        m_tomcat_conf = getNextArg(argv, i, 'T');\n                        break;\n\n                    case 'u':\n                        i++;\n                        m_pg_user = getNextArg(argv, i, 'u');\n                        break;\n\n                    case 'U':\n                        m_update_unicode = true;\n                        break;\n\n                    case 'w':\n                        i++;\n                        m_webappdir = getNextArg(argv, i, 'w');\n                        break;\n\n                    case 'x':\n                        m_debug = true;\n                        break;\n\n                    case 'X':\n                        m_fix_constraint_remove_rows = true;\n                        break;\n\n                    case 'y':\n                        m_install_webapp = true;\n                        break;\n\n                    default:\n                        throw new Exception(\"unknown option '\" + c + \"'\"\n                                + \", use '-h' option for usage\");\n                    }\n                }\n            } else {\n                args.add(argv[i]);\n            }\n        }\n\n        if (args.size() != 0) {\n            throw new Exception(\"too many command-line arguments specified\");\n        }\n    }","id":89775,"modified_method":"public void parseArguments(String[] argv) throws Exception {\n        LinkedList<String> args = new LinkedList<String>();\n\n        for (int i = 0; i < argv.length; i++) {\n            StringBuffer b = new StringBuffer(argv[i]);\n            boolean is_arg = false;\n\n            while (b.length() > 0 && b.charAt(0) == '-') {\n                is_arg = true;\n                b.deleteCharAt(0);\n            }\n\n            if (is_arg) {\n                while (b.length() > 0) {\n                    char c = b.charAt(0);\n                    b.deleteCharAt(0);\n\n                    switch (c) {\n                    case 'h':\n                        printHelp();\n                        break;\n\n                    case 'c':\n                        m_installerDb.setForce(true);\n                        break;\n\n                    case 'C':\n                        i++;\n                        m_fix_constraint = true;\n                        m_fix_constraint_name = getNextArg(argv, i, 'C');\n                        break;\n\n                    case 'd':\n                        m_update_database = true;\n                        break;\n\n                    case 'i':\n                        m_do_inserts = true;\n                        break;\n\n                    case 'n':\n                        m_skip_constraints = true;\n\n                    case 'N':\n                        m_installerDb.setIgnoreNotNull(true);\n                        break;\n\n                    case 'p':\n                        i++;\n                        m_pg_pass = getNextArg(argv, i, 'p');\n                        break;\n\n                    case 'R':\n                        m_installerDb.setNoRevert(true);\n                        break;\n\n                    case 's':\n                        m_update_iplike = true;\n                        break;\n\n                    case 'T':\n                        i++;\n                        m_tomcat_conf = getNextArg(argv, i, 'T');\n                        break;\n\n                    case 'u':\n                        i++;\n                        m_installerDb.setPostgresAdminUser(getNextArg(argv, i, 'u'));\n                        break;\n\n                    case 'U':\n                        m_update_unicode = true;\n                        break;\n\n                    case 'w':\n                        i++;\n                        m_webappdir = getNextArg(argv, i, 'w');\n                        break;\n\n                    case 'x':\n                        m_installerDb.setDebug(true);\n                        break;\n\n                    case 'X':\n                        m_fix_constraint_remove_rows = true;\n                        break;\n\n                    case 'y':\n                        m_install_webapp = true;\n                        break;\n\n                    default:\n                        throw new Exception(\"unknown option '\" + c + \"'\"\n                                + \", use '-h' option for usage\");\n                    }\n                }\n            } else {\n                args.add(argv[i]);\n            }\n        }\n\n        if (args.size() != 0) {\n            throw new Exception(\"too many command-line arguments specified\");\n        }\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setUp() throws IOException, SQLException {\n        m_anticipator = new FileAnticipator();\n        File dist = m_anticipator.tempDir(\"dist\");\n        File dist_webapps = m_anticipator.tempDir(dist, \"webapps\");\n        File opennms_webapp = m_anticipator.tempDir(dist_webapps, \"opennms\");\n        File meta_inf = m_anticipator.tempDir(opennms_webapp, \"META-INF\");\n        m_anticipator.tempFile(meta_inf, \"context.xml\");\n\n        File web_inf = m_anticipator.tempDir(opennms_webapp, \"WEB-INF\");\n        File lib = m_anticipator.tempDir(web_inf, \"lib\");\n        m_anticipator.tempFile(lib, \"log4j.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.tempFile(lib, \"opennms_core.jar\");\n        m_anticipator.tempFile(lib, \"opennms_services.jar\");\n        m_anticipator.tempFile(lib, \"opennms_web.jar\");\n\n        m_tomcat = m_anticipator.tempDir(\"tomcat\");\n        m_tomcat_webapps = m_anticipator.tempDir(m_tomcat, \"webapps\");\n        m_tomcat_conf_dir = m_anticipator.tempDir(m_tomcat, \"conf\");\n        File tomcat_server = m_anticipator.tempDir(m_tomcat, \"server\");\n        File tomcat_lib = m_anticipator.tempDir(tomcat_server, \"lib\");\n\n        m_anticipator.expecting(m_tomcat_webapps, \"opennms.xml\");\n        m_anticipator.expecting(tomcat_lib, \"log4j.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_core.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_services.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_web.jar\");\n\n        m_installer = new Installer();\n        m_installer.m_out = new PrintStream(new ByteArrayOutputStream());\n        // m_installer.m_out = System.out;\n        m_installer.m_install_servletdir = opennms_webapp.getAbsolutePath();\n        m_installer.m_webappdir = m_tomcat_webapps.getAbsolutePath();\n    }","id":89776,"modified_method":"public void setUp() throws IOException, SQLException {\n        m_anticipator = new FileAnticipator();\n        File dist = m_anticipator.tempDir(\"dist\");\n        File dist_webapps = m_anticipator.tempDir(dist, \"webapps\");\n        File opennms_webapp = m_anticipator.tempDir(dist_webapps, \"opennms\");\n        File meta_inf = m_anticipator.tempDir(opennms_webapp, \"META-INF\");\n        m_anticipator.tempFile(meta_inf, \"context.xml\");\n\n        File web_inf = m_anticipator.tempDir(opennms_webapp, \"WEB-INF\");\n        File lib = m_anticipator.tempDir(web_inf, \"lib\");\n        m_anticipator.tempFile(lib, \"log4j.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.tempFile(lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.tempFile(lib, \"opennms_core.jar\");\n        m_anticipator.tempFile(lib, \"opennms_services.jar\");\n        m_anticipator.tempFile(lib, \"opennms_web.jar\");\n\n        m_tomcat = m_anticipator.tempDir(\"tomcat\");\n        m_tomcat_webapps = m_anticipator.tempDir(m_tomcat, \"webapps\");\n        m_tomcat_conf_dir = m_anticipator.tempDir(m_tomcat, \"conf\");\n        File tomcat_server = m_anticipator.tempDir(m_tomcat, \"server\");\n        File tomcat_lib = m_anticipator.tempDir(tomcat_server, \"lib\");\n\n        m_anticipator.expecting(m_tomcat_webapps, \"opennms.xml\");\n        m_anticipator.expecting(tomcat_lib, \"log4j.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9.jar\");\n        m_anticipator.expecting(tomcat_lib, \"castor-0.9.3.9-xml.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_core.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_services.jar\");\n        m_anticipator.expecting(tomcat_lib, \"opennms_web.jar\");\n\n        m_installer = new Installer();\n        m_installer.setOutputStream(new PrintStream(new ByteArrayOutputStream()));\n        m_installer.m_install_servletdir = opennms_webapp.getAbsolutePath();\n        m_installer.m_webappdir = m_tomcat_webapps.getAbsolutePath();\n    }","commit_id":"0be746673f9b7680e8161b2b6d1017e7b1801d84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Domain getDomain(LdapUser user) {\n\tString csDomainName = null;\n\tif (StringUtils.isNotBlank(domainName)) {\n\t    csDomainName = domainName;\n\t} else {\n\t    if (StringUtils.isNotBlank(groupName)) {\n\t\tcsDomainName = groupName;\n\t    } else if (StringUtils.isNotBlank(user.getDomain())) {\n\t\tcsDomainName = user.getDomain();\n\t    }\n\t    //removing all the special characters and trimming it length 190 to make the domain valid.\n\t    csDomainName = StringUtils.substring(csDomainName.replaceAll(\"\\\\W\",\"\"),0,190);\n\t}\n\tDomain domain;\n\tif (StringUtils.isNotBlank(csDomainName)) {\n\t    domain = _domainService.getDomainByName(csDomainName, Domain.ROOT_DOMAIN);\n\n\t    if (domain == null) {\n\t\tdomain = _domainService.createDomain(csDomainName, Domain.ROOT_DOMAIN, csDomainName, UUID.randomUUID().toString());\n\t    }\n\t} else {\n\t    domain = _domainService.getDomain(Domain.ROOT_DOMAIN);\n\t}\n\n\treturn domain;\n    }","id":89777,"modified_method":"private Domain getDomain(LdapUser user) {\n        Domain domain;\n        if (_domain != null) {\n            //this means either domain id or groupname is passed and this will be same for all the users in this call. hence returning it.\n            domain = _domain;\n        } else {\n            if (domainId != null) {\n                // a domain Id is passed. use it for this user and all the users in the same api call (by setting _domain)\n                domain = _domain = _domainService.getDomain(domainId);\n            } else {\n                // a group name is passed. use it for this user and all the users in the same api call(by setting _domain)\n                domain = _domain = getDomainForName(groupName);\n                if (domain == null) {\n                    //use the domain from the LDAP for this user\n                    domain = getDomainForName(user.getDomain());\n                }\n            }\n            if (domain == null) {\n                // could not get a domain using domainId / LDAP group / OU of LDAP user. using ROOT domain for this user\n                domain = _domainService.getDomain(Domain.ROOT_DOMAIN);\n            }\n        }\n        return domain;\n    }","commit_id":"917ea33ba93325dabdac55df156159334285ab01","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException,\n\tNetworkRuleConflictException {\n\tList<LdapUserResponse> ldapResponses = null;\n\tfinal ListResponse<LdapUserResponse> response = new ListResponse<LdapUserResponse>();\n\ttry {\n\tList<LdapUser> users;\n\tif(StringUtils.isNotBlank(groupName)) {\n\t    users = _ldapManager.getUsersInGroup(groupName);\n\t} else {\n\t\tusers = _ldapManager.getUsers();\n\t}\n\t    for (LdapUser user : users) {\n\t    Domain domain = getDomain(user);\n\t\t    _accountService.createUserAccount(user.getUsername(), generatePassword(), user.getFirstname(), user.getLastname(), user.getEmail(), timezone, user.getUsername(),\n\t\t\t\t\t\t  accountType, domain.getId(), domain.getNetworkDomain(), details, UUID.randomUUID().toString(), UUID.randomUUID().toString());\n\t    }\n\t    ldapResponses = createLdapUserResponse(users);\n\t} catch (final NoLdapUserMatchingQueryException ex) {\n\t    ldapResponses = new ArrayList<LdapUserResponse>();\n\t} finally {\n\t    response.setResponses(ldapResponses);\n\t    response.setResponseName(getCommandName());\n\t    setResponseObject(response);\n\t}\n    }","id":89778,"modified_method":"@Override\n    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException,\n            NetworkRuleConflictException {\n\n        List<LdapUser> users;\n        try {\n            if (StringUtils.isNotBlank(groupName)) {\n                users = _ldapManager.getUsersInGroup(groupName);\n            } else {\n                users = _ldapManager.getUsers();\n            }\n        } catch (NoLdapUserMatchingQueryException ex) {\n            users = new ArrayList<LdapUser>();\n            s_logger.info(\"No Ldap user matching query. \"+\" ::: \"+ex.getMessage());\n        }\n\n        List<LdapUser> addedUsers = new ArrayList<LdapUser>();\n        for (LdapUser user : users) {\n            Domain domain = getDomain(user);\n            try {\n                _accountService.createUserAccount(user.getUsername(), generatePassword(), user.getFirstname(), user.getLastname(), user.getEmail(), timezone, user.getUsername(),\n                        accountType, domain.getId(), domain.getNetworkDomain(), details, UUID.randomUUID().toString(), UUID.randomUUID().toString());\n                addedUsers.add(user);\n            } catch (InvalidParameterValueException ex) {\n                s_logger.error(\"Failed to create user with username: \" + user.getUsername() +\" ::: \"+ex.getMessage());\n            }\n        }\n        ListResponse<LdapUserResponse> response = new ListResponse<LdapUserResponse>();\n        response.setResponses(createLdapUserResponse(addedUsers));\n        response.setResponseName(getCommandName());\n        setResponseObject(response);\n    }","commit_id":"917ea33ba93325dabdac55df156159334285ab01","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected String getDomainInternal() {\n        return context.getDomain();\n    }","id":89779,"modified_method":"@Override\n    protected String getDomainInternal() {\n        return (context != null) ? context.getDomain() : null;\n    }","commit_id":"005b44a7c483f18e4d88b87c66810c4f0f9f63cc","url":"https://github.com/apache/tomcat"},{"original_method":"public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {\n        this.server=server;\n        if(factory != null)\n            factory.setServer(server);\n        return ObjectName.getInstance(getDomain());\n    }","id":89780,"modified_method":"public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {\n        this.server=server;\n        if(factory != null)\n            factory.setServer(server);\n        if (name != null) {//we only create a name if it is empty\n            return name;\n        }\n        //if the objectName is not a pattern then at least one key property MUST exist\n        String objectName = getDomain() + \" : service=JChannelFactory\";\n        return ObjectName.getInstance(objectName);\n    }","commit_id":"2e2f37b124d297191c9695bddfe94e01f9b89b9d","url":"https://github.com/belaban/JGroups"},{"original_method":"public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {\n        this.server=server;\n        if(factory != null)\n            factory.setServer(server);\n        return ObjectName.getInstance(getDomain());\n    }","id":89781,"modified_method":"public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {\n        this.server=server;\n        if(factory != null)\n            factory.setServer(server);\n        if (name != null) {//we only create a name if it is empty\n            return name;\n        }\n        //if the objectName is not a pattern then at least one key property MUST exist\n        String objectName = getDomain() + \" : service=JChannelFactory\";\n        return ObjectName.getInstance(objectName);\n    }","commit_id":"e38a7f618f0336b724cfd3f23fe55fdafca0f427","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n    public void testGetWarmers() throws Exception {\n        createIndex(\"test\");\n        ensureSearchable(\"test\");\n        assertAcked(client().admin().indices().preparePutWarmer(\"warmer1\").setSearchRequest(client().prepareSearch(\"test\")).get());\n        ensureSearchable(\"test\");\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(\"_warmers\")\n                .execute().actionGet();\n        ImmutableOpenMap<String, ImmutableList<Entry>> warmersMap = getIndexResponse.warmers();\n        assertThat(warmersMap, notNullValue());\n        assertThat(warmersMap.size(), equalTo(1));\n        ImmutableList<Entry> warmersList = warmersMap.get(\"test\");\n        assertThat(warmersList, notNullValue());\n        assertThat(warmersList.size(), equalTo(1));\n        Entry warmer = warmersList.get(0);\n        assertThat(warmer, notNullValue());\n        assertThat(warmer.name(), equalTo(\"warmer1\"));\n    }","id":89782,"modified_method":"@Test\n    public void testGetWarmers() throws Exception {\n        createIndex(\"test\");\n        ensureSearchable(\"test\");\n        assertAcked(client().admin().indices().preparePutWarmer(\"warmer1\").setSearchRequest(client().prepareSearch(\"test\")).get());\n        ensureSearchable(\"test\");\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(Feature.WARMERS)\n                .execute().actionGet();\n        ImmutableOpenMap<String, ImmutableList<Entry>> warmersMap = getIndexResponse.warmers();\n        assertThat(warmersMap, notNullValue());\n        assertThat(warmersMap.size(), equalTo(1));\n        ImmutableList<Entry> warmersList = warmersMap.get(\"test\");\n        assertThat(warmersList, notNullValue());\n        assertThat(warmersList.size(), equalTo(1));\n        Entry warmer = warmersList.get(0);\n        assertThat(warmer, notNullValue());\n        assertThat(warmer.name(), equalTo(\"warmer1\"));\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testGetAliases() throws Exception {\n        CreateIndexResponse createIndexResponse = prepareCreate(\"test\").addAlias(new Alias(\"testAlias\")).execute().actionGet();\n        assertAcked(createIndexResponse);\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(\"_aliases\")\n                .execute().actionGet();\n        ImmutableOpenMap<String, ImmutableList<AliasMetaData>> aliasesMap = getIndexResponse.aliases();\n        assertThat(aliasesMap, notNullValue());\n        assertThat(aliasesMap.size(), equalTo(1));\n        ImmutableList<AliasMetaData> aliasesList = aliasesMap.get(\"test\");\n        assertThat(aliasesList, notNullValue());\n        assertThat(aliasesList.size(), equalTo(1));\n        AliasMetaData alias = aliasesList.get(0);\n        assertThat(alias, notNullValue());\n        assertThat(alias.alias(), equalTo(\"testAlias\"));\n    }","id":89783,"modified_method":"@Test\n    public void testGetAliases() throws Exception {\n        CreateIndexResponse createIndexResponse = prepareCreate(\"test\").addAlias(new Alias(\"testAlias\")).execute().actionGet();\n        assertAcked(createIndexResponse);\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(Feature.ALIASES)\n                .execute().actionGet();\n        ImmutableOpenMap<String, ImmutableList<AliasMetaData>> aliasesMap = getIndexResponse.aliases();\n        assertThat(aliasesMap, notNullValue());\n        assertThat(aliasesMap.size(), equalTo(1));\n        ImmutableList<AliasMetaData> aliasesList = aliasesMap.get(\"test\");\n        assertThat(aliasesList, notNullValue());\n        assertThat(aliasesList.size(), equalTo(1));\n        AliasMetaData alias = aliasesList.get(0);\n        assertThat(alias, notNullValue());\n        assertThat(alias.alias(), equalTo(\"testAlias\"));\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testGetSettings() throws Exception {\n        CreateIndexResponse createIndexResponse = prepareCreate(\"test\").setSettings(ImmutableSettings.builder().put(\"number_of_shards\", 1)).execute().actionGet();\n        assertAcked(createIndexResponse);\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(\"_settings\")\n                .execute().actionGet();\n        ImmutableOpenMap<String, Settings> settingsMap = getIndexResponse.settings();\n        assertThat(settingsMap, notNullValue());\n        assertThat(settingsMap.size(), equalTo(1));\n        Settings settings = settingsMap.get(\"test\");\n        assertThat(settings, notNullValue());\n        assertThat(settings.get(\"index.number_of_shards\"), equalTo(\"1\"));\n    }","id":89784,"modified_method":"@Test\n    public void testGetSettings() throws Exception {\n        CreateIndexResponse createIndexResponse = prepareCreate(\"test\").setSettings(ImmutableSettings.builder().put(\"number_of_shards\", 1)).execute().actionGet();\n        assertAcked(createIndexResponse);\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(Feature.SETTINGS)\n                .execute().actionGet();\n        ImmutableOpenMap<String, Settings> settingsMap = getIndexResponse.settings();\n        assertThat(settingsMap, notNullValue());\n        assertThat(settingsMap.size(), equalTo(1));\n        Settings settings = settingsMap.get(\"test\");\n        assertThat(settings, notNullValue());\n        assertThat(settings.get(\"index.number_of_shards\"), equalTo(\"1\"));\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testGetMappings() throws Exception {\n        CreateIndexResponse createIndexResponse = prepareCreate(\"test\").addMapping(\"type1\", \"{\\\"type1\\\":{}}\").execute().actionGet();\n        assertAcked(createIndexResponse);\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(\"_mappings\")\n                .execute().actionGet();\n        ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.mappings();\n        assertThat(mappings, notNullValue());\n        assertThat(mappings.size(), equalTo(1));\n        ImmutableOpenMap<String, MappingMetaData> indexMappings = mappings.get(\"test\");\n        assertThat(indexMappings, notNullValue());\n        assertThat(indexMappings.size(), anyOf(equalTo(1), equalTo(2)));\n        if (indexMappings.size() == 2) {\n            MappingMetaData mapping = indexMappings.get(\"_default_\");\n            assertThat(mapping, notNullValue());\n        }\n        MappingMetaData mapping = indexMappings.get(\"type1\");\n        assertThat(mapping, notNullValue());\n        assertThat(mapping.type(), equalTo(\"type1\"));\n    }","id":89785,"modified_method":"@Test\n    public void testGetMappings() throws Exception {\n        CreateIndexResponse createIndexResponse = prepareCreate(\"test\").addMapping(\"type1\", \"{\\\"type1\\\":{}}\").execute().actionGet();\n        assertAcked(createIndexResponse);\n        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().addIndices(\"test\").addFeatures(Feature.MAPPINGS)\n                .execute().actionGet();\n        ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings = getIndexResponse.mappings();\n        assertThat(mappings, notNullValue());\n        assertThat(mappings.size(), equalTo(1));\n        ImmutableOpenMap<String, MappingMetaData> indexMappings = mappings.get(\"test\");\n        assertThat(indexMappings, notNullValue());\n        assertThat(indexMappings.size(), anyOf(equalTo(1), equalTo(2)));\n        if (indexMappings.size() == 2) {\n            MappingMetaData mapping = indexMappings.get(\"_default_\");\n            assertThat(mapping, notNullValue());\n        }\n        MappingMetaData mapping = indexMappings.get(\"type1\");\n        assertThat(mapping, notNullValue());\n        assertThat(mapping.type(), equalTo(\"type1\"));\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        features = in.readStringArray();\n    }","id":89786,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        if (in.getVersion().before(Version.V_1_4_1)) {\n            Feature.convertToFeatures(in.readStringArray());\n        } else {\n            int size = in.readVInt();\n            features = new Feature[size];\n            for (int i = 0; i < size; i++) {\n                features[i] = Feature.fromId(in.readByte());\n            }\n        }\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeStringArray(features);\n    }","id":89787,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        if (out.getVersion().before(Version.V_1_4_1)) {\n            String[] featureNames = new String[features.length];\n            for (int i = 0; i< features.length; i++) {\n                featureNames[i] = features[i].preferredName();\n            }\n            out.writeStringArray(featureNames);\n        } else {\n            out.writeVInt(features.length);\n            for (Feature feature : features) {\n                out.writeByte(feature.id);\n            }\n        }\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String[] features() {\n        return features;\n    }","id":89788,"modified_method":"public Feature[] features() {\n        return features;\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetIndexRequestBuilder setFeatures(String... features) {\n        request.features(features);\n        return this;\n    }","id":89789,"modified_method":"public GetIndexRequestBuilder setFeatures(Feature... features) {\n        request.features(features);\n        return this;\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GetIndexRequestBuilder addFeatures(String... features) {\n        request.features(ObjectArrays.concat(request.features(), features, String.class));\n        return this;\n    }","id":89790,"modified_method":"public GetIndexRequestBuilder addFeatures(Feature... features) {\n        request.addFeatures(features);\n        return this;\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"GetIndexResponse(String[] indices, ImmutableOpenMap<String, ImmutableList<IndexWarmersMetaData.Entry>> warmers,\n            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings,\n            ImmutableOpenMap<String, ImmutableList<AliasMetaData>> aliases, ImmutableOpenMap<String, Settings> settings) {\n        this.indices = indices;\n        this.warmers = warmers;\n        this.mappings = mappings;\n        this.aliases = aliases;\n        this.settings = settings;\n    }","id":89791,"modified_method":"GetIndexResponse(String[] indices, ImmutableOpenMap<String, ImmutableList<IndexWarmersMetaData.Entry>> warmers,\n            ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings,\n            ImmutableOpenMap<String, ImmutableList<AliasMetaData>> aliases, ImmutableOpenMap<String, Settings> settings) {\n        this.indices = indices;\n        if (warmers != null) {\n            this.warmers = warmers;\n        }\n        if (mappings != null) {\n            this.mappings = mappings;\n        }\n        if (aliases != null) {\n            this.aliases = aliases;\n        }\n        if (settings != null) {\n            this.settings = settings;\n        }\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleMapping() {\n        GetIndexResponse response = client().admin().indices().prepareGetIndex().addIndices(\"idx\").setFeatures(\"_mapping\").get();\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertMappings(response, \"idx\");\n        assertEmptyAliases(response);\n        assertEmptySettings(response);\n        assertEmptyWarmers(response);\n    }","id":89792,"modified_method":"@Test\n    public void testSimpleMapping() {\n        GetIndexResponse response = runWithRandomFeatureMethod(client().admin().indices().prepareGetIndex().addIndices(\"idx\"),\n                Feature.MAPPINGS);\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertMappings(response, \"idx\");\n        assertEmptyAliases(response);\n        assertEmptySettings(response);\n        assertEmptyWarmers(response);\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleWarmer() {\n        GetIndexResponse response = client().admin().indices().prepareGetIndex().addIndices(\"idx\").setFeatures(\"_warmer\").get();\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertWarmers(response, \"idx\");\n        assertEmptyAliases(response);\n        assertEmptyMappings(response);\n        assertEmptySettings(response);\n    }","id":89793,"modified_method":"@Test\n    public void testSimpleWarmer() {\n        GetIndexResponse response = runWithRandomFeatureMethod(client().admin().indices().prepareGetIndex().addIndices(\"idx\"),\n                Feature.WARMERS);\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertWarmers(response, \"idx\");\n        assertEmptyAliases(response);\n        assertEmptyMappings(response);\n        assertEmptySettings(response);\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleAlias() {\n        GetIndexResponse response = client().admin().indices().prepareGetIndex().addIndices(\"idx\").setFeatures(\"_alias\").get();\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertAliases(response, \"idx\");\n        assertEmptyMappings(response);\n        assertEmptySettings(response);\n        assertEmptyWarmers(response);\n    }","id":89794,"modified_method":"@Test\n    public void testSimpleAlias() {\n        GetIndexResponse response = runWithRandomFeatureMethod(client().admin().indices().prepareGetIndex().addIndices(\"idx\"),\n                Feature.ALIASES);\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertAliases(response, \"idx\");\n        assertEmptyMappings(response);\n        assertEmptySettings(response);\n        assertEmptyWarmers(response);\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testEmptyMixedFeatures() {\n        int numFeatures = randomIntBetween(1, allFeatures.length);\n        List<String> features = new ArrayList<String>(numFeatures);\n        for (int i = 0; i < numFeatures; i++) {\n            features.add(randomFrom(allFeatures));\n        }\n        GetIndexResponse response = client().admin().indices().prepareGetIndex().addIndices(\"empty_idx\")\n                .setFeatures(features.toArray(new String[features.size()])).get();\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"empty_idx\"));\n        assertEmptyAliases(response);\n        if (features.contains(\"_mapping\") || features.contains(\"_mappings\")) {\n            assertEmptyOrOnlyDefaultMappings(response, \"empty_idx\");\n        } else {\n            assertEmptyMappings(response);\n        }\n        if (features.contains(\"_settings\")) {\n            assertNonEmptySettings(response, \"empty_idx\");\n        } else {\n            assertEmptySettings(response);\n        }\n        assertEmptyWarmers(response);\n    }","id":89795,"modified_method":"@Test\n    public void testEmptyMixedFeatures() {\n        int numFeatures = randomIntBetween(1, Feature.values().length);\n        List<Feature> features = new ArrayList<Feature>(numFeatures);\n        for (int i = 0; i < numFeatures; i++) {\n            features.add(randomFrom(Feature.values()));\n        }\n        GetIndexResponse response = runWithRandomFeatureMethod(client().admin().indices().prepareGetIndex().addIndices(\"empty_idx\"),\n                features.toArray(new Feature[features.size()]));\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"empty_idx\"));\n        assertEmptyAliases(response);\n        if (features.contains(Feature.MAPPINGS)) {\n            assertEmptyOrOnlyDefaultMappings(response, \"empty_idx\");\n        } else {\n            assertEmptyMappings(response);\n        }\n        if (features.contains(Feature.SETTINGS)) {\n            assertNonEmptySettings(response, \"empty_idx\");\n        } else {\n            assertEmptySettings(response);\n        }\n        assertEmptyWarmers(response);\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleSettings() {\n        GetIndexResponse response = client().admin().indices().prepareGetIndex().addIndices(\"idx\").setFeatures(\"_settings\").get();\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertSettings(response, \"idx\");\n        assertEmptyAliases(response);\n        assertEmptyMappings(response);\n        assertEmptyWarmers(response);\n    }","id":89796,"modified_method":"@Test\n    public void testSimpleSettings() {\n        GetIndexResponse response = runWithRandomFeatureMethod(client().admin().indices().prepareGetIndex().addIndices(\"idx\"),\n                Feature.SETTINGS);\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        assertSettings(response, \"idx\");\n        assertEmptyAliases(response);\n        assertEmptyMappings(response);\n        assertEmptyWarmers(response);\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleMixedFeatures() {\n        int numFeatures = randomIntBetween(1, allFeatures.length);\n        List<String> features = new ArrayList<String>(numFeatures);\n        for (int i = 0; i < numFeatures; i++) {\n            features.add(randomFrom(allFeatures));\n        }\n        GetIndexResponse response = client().admin().indices().prepareGetIndex().addIndices(\"idx\")\n                .setFeatures(features.toArray(new String[features.size()])).get();\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        if (features.contains(\"_alias\") || features.contains(\"_aliases\")) {\n            assertAliases(response, \"idx\");\n        } else {\n            assertEmptyAliases(response);\n        }\n        if (features.contains(\"_mapping\") || features.contains(\"_mappings\")) {\n            assertMappings(response, \"idx\");\n        } else {\n            assertEmptyMappings(response);\n        }\n        if (features.contains(\"_settings\")) {\n            assertSettings(response, \"idx\");\n        } else {\n            assertEmptySettings(response);\n        }\n        if (features.contains(\"_warmer\") || features.contains(\"_warmers\")) {\n            assertWarmers(response, \"idx\");\n        } else {\n            assertEmptyWarmers(response);\n        }\n    }","id":89797,"modified_method":"@Test\n    public void testSimpleMixedFeatures() {\n        int numFeatures = randomIntBetween(1, Feature.values().length);\n        List<Feature> features = new ArrayList<Feature>(numFeatures);\n        for (int i = 0; i < numFeatures; i++) {\n            features.add(randomFrom(Feature.values()));\n        }\n        GetIndexResponse response = runWithRandomFeatureMethod(client().admin().indices().prepareGetIndex().addIndices(\"idx\"),\n                features.toArray(new Feature[features.size()]));\n        String[] indices = response.indices();\n        assertThat(indices, notNullValue());\n        assertThat(indices.length, equalTo(1));\n        assertThat(indices[0], equalTo(\"idx\"));\n        if (features.contains(Feature.ALIASES)) {\n            assertAliases(response, \"idx\");\n        } else {\n            assertEmptyAliases(response);\n        }\n        if (features.contains(Feature.MAPPINGS)) {\n            assertMappings(response, \"idx\");\n        } else {\n            assertEmptyMappings(response);\n        }\n        if (features.contains(Feature.SETTINGS)) {\n            assertSettings(response, \"idx\");\n        } else {\n            assertEmptySettings(response);\n        }\n        if (features.contains(Feature.WARMERS)) {\n            assertWarmers(response, \"idx\");\n        } else {\n            assertEmptyWarmers(response);\n        }\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel, final Client client) {\n        String[] indices = Strings.splitStringByCommaToArray(request.param(\"index\"));\n        String[] features = request.paramAsStringArray(\"type\", null);\n        // Work out if the indices is a list of features\n        if (features == null && indices.length > 0 && indices[0] != null && indices[0].startsWith(\"_\") && !\"_all\".equals(indices[0])) {\n            features = indices;\n            indices = new String[] {\"_all\"};\n        }\n        final GetIndexRequest getIndexRequest = new GetIndexRequest();\n        getIndexRequest.indices(indices);\n        if (features != null) {\n            getIndexRequest.features(features);\n        }\n        getIndexRequest.indicesOptions(IndicesOptions.fromRequest(request, getIndexRequest.indicesOptions()));\n        getIndexRequest.local(request.paramAsBoolean(\"local\", getIndexRequest.local()));\n        client.admin().indices().getIndex(getIndexRequest, new RestBuilderListener<GetIndexResponse>(channel) {\n\n            @Override\n            public RestResponse buildResponse(GetIndexResponse response, XContentBuilder builder) throws Exception {\n\n                String[] features = getIndexRequest.features();\n                String[] indices = response.indices();\n\n                builder.startObject();\n                for (String index : indices) {\n                    builder.startObject(index);\n                    for (String feature : features) {\n                        switch (feature) {\n                        case \"_alias\":\n                        case \"_aliases\":\n                            writeAliases(response.aliases().get(index), builder, request);\n                            break;\n                        case \"_mapping\":\n                        case \"_mappings\":\n                            writeMappings(response.mappings().get(index), builder, request);\n                            break;\n                        case \"_settings\":\n                            writeSettings(response.settings().get(index), builder, request);\n                            break;\n                        case \"_warmer\":\n                        case \"_warmers\":\n                            writeWarmers(response.warmers().get(index), builder, request);\n                            break;\n                        default:\n                            throw new ElasticsearchIllegalStateException(\"feature [\" + feature + \"] is not valid\");\n                        }\n                    }\n                    builder.endObject();\n\n                }\n                builder.endObject();\n\n                return new BytesRestResponse(OK, builder);\n            }\n\n            private void writeAliases(ImmutableList<AliasMetaData> aliases, XContentBuilder builder, Params params) throws IOException {\n                if (aliases != null) {\n                    builder.startObject(Fields.ALIASES);\n                    for (AliasMetaData alias : aliases) {\n                        AliasMetaData.Builder.toXContent(alias, builder, params);\n                    }\n                    builder.endObject();\n                }\n            }\n\n            private void writeMappings(ImmutableOpenMap<String, MappingMetaData> mappings, XContentBuilder builder, Params params) throws IOException {\n                if (mappings != null) {\n                    builder.startObject(Fields.MAPPINGS);\n                    for (ObjectObjectCursor<String, MappingMetaData> typeEntry : mappings) {\n                        builder.field(typeEntry.key);\n                        builder.map(typeEntry.value.sourceAsMap());\n                    }\n                    builder.endObject();\n                }\n            }\n\n            private void writeSettings(Settings settings, XContentBuilder builder, Params params) throws IOException {\n                builder.startObject(Fields.SETTINGS);\n                settings.toXContent(builder, params);\n                builder.endObject();\n            }\n\n            private void writeWarmers(ImmutableList<IndexWarmersMetaData.Entry> warmers, XContentBuilder builder, Params params) throws IOException {\n                if (warmers != null) {\n                    builder.startObject(Fields.WARMERS);\n                    for (IndexWarmersMetaData.Entry warmer : warmers) {\n                        IndexWarmersMetaData.FACTORY.toXContent(warmer, builder, params);\n                    }\n                    builder.endObject();\n                }\n            }\n        });\n    }","id":89798,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel, final Client client) {\n        String[] indices = Strings.splitStringByCommaToArray(request.param(\"index\"));\n        String[] featureParams = request.paramAsStringArray(\"type\", null);\n        // Work out if the indices is a list of features\n        if (featureParams == null && indices.length > 0 && indices[0] != null && indices[0].startsWith(\"_\") && !\"_all\".equals(indices[0])) {\n            featureParams = indices;\n            indices = new String[] {\"_all\"};\n        }\n        final GetIndexRequest getIndexRequest = new GetIndexRequest();\n        getIndexRequest.indices(indices);\n        if (featureParams != null) {\n            Feature[] features = Feature.convertToFeatures(featureParams);\n            getIndexRequest.features(features);\n        }\n        getIndexRequest.indicesOptions(IndicesOptions.fromRequest(request, getIndexRequest.indicesOptions()));\n        getIndexRequest.local(request.paramAsBoolean(\"local\", getIndexRequest.local()));\n        client.admin().indices().getIndex(getIndexRequest, new RestBuilderListener<GetIndexResponse>(channel) {\n\n            @Override\n            public RestResponse buildResponse(GetIndexResponse response, XContentBuilder builder) throws Exception {\n\n                Feature[] features = getIndexRequest.featuresAsEnums();\n                String[] indices = response.indices();\n\n                builder.startObject();\n                for (String index : indices) {\n                    builder.startObject(index);\n                    for (Feature feature : features) {\n                        switch (feature) {\n                        case ALIASES:\n                            writeAliases(response.aliases().get(index), builder, request);\n                            break;\n                        case MAPPINGS:\n                            writeMappings(response.mappings().get(index), builder, request);\n                            break;\n                        case SETTINGS:\n                            writeSettings(response.settings().get(index), builder, request);\n                            break;\n                        case WARMERS:\n                            writeWarmers(response.warmers().get(index), builder, request);\n                            break;\n                        default:\n                            throw new ElasticsearchIllegalStateException(\"feature [\" + feature + \"] is not valid\");\n                        }\n                    }\n                    builder.endObject();\n\n                }\n                builder.endObject();\n\n                return new BytesRestResponse(OK, builder);\n            }\n\n            private void writeAliases(ImmutableList<AliasMetaData> aliases, XContentBuilder builder, Params params) throws IOException {\n                if (aliases != null) {\n                    builder.startObject(Fields.ALIASES);\n                    for (AliasMetaData alias : aliases) {\n                        AliasMetaData.Builder.toXContent(alias, builder, params);\n                    }\n                    builder.endObject();\n                }\n            }\n\n            private void writeMappings(ImmutableOpenMap<String, MappingMetaData> mappings, XContentBuilder builder, Params params) throws IOException {\n                if (mappings != null) {\n                    builder.startObject(Fields.MAPPINGS);\n                    for (ObjectObjectCursor<String, MappingMetaData> typeEntry : mappings) {\n                        builder.field(typeEntry.key);\n                        builder.map(typeEntry.value.sourceAsMap());\n                    }\n                    builder.endObject();\n                }\n            }\n\n            private void writeSettings(Settings settings, XContentBuilder builder, Params params) throws IOException {\n                builder.startObject(Fields.SETTINGS);\n                settings.toXContent(builder, params);\n                builder.endObject();\n            }\n\n            private void writeWarmers(ImmutableList<IndexWarmersMetaData.Entry> warmers, XContentBuilder builder, Params params) throws IOException {\n                if (warmers != null) {\n                    builder.startObject(Fields.WARMERS);\n                    for (IndexWarmersMetaData.Entry warmer : warmers) {\n                        IndexWarmersMetaData.FACTORY.toXContent(warmer, builder, params);\n                    }\n                    builder.endObject();\n                }\n            }\n        });\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doMasterOperation(final GetIndexRequest request, String[] concreteIndices, final ClusterState state,\n                                     final ActionListener<GetIndexResponse> listener) throws ElasticsearchException {\n        ImmutableOpenMap<String, ImmutableList<Entry>> warmersResult = ImmutableOpenMap.of();\n        ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsResult = ImmutableOpenMap.of();\n        ImmutableOpenMap<String, ImmutableList<AliasMetaData>> aliasesResult = ImmutableOpenMap.of();\n        ImmutableOpenMap<String, Settings> settings = ImmutableOpenMap.of();\n        String[] features = request.features();\n        boolean doneAliases = false;\n        boolean doneMappings = false;\n        boolean doneSettings = false;\n        boolean doneWarmers = false;\n        for (String feature : features) {\n            switch (feature) {\n                case \"_warmer\":\n                case \"_warmers\":\n                    if (!doneWarmers) {\n                        warmersResult = state.metaData().findWarmers(concreteIndices, request.types(), Strings.EMPTY_ARRAY);\n                        doneWarmers = true;\n                    }\n                    break;\n                case \"_mapping\":\n                case \"_mappings\":\n                    if (!doneMappings) {\n                        mappingsResult = state.metaData().findMappings(concreteIndices, request.types());\n                        doneMappings = true;\n                    }\n                    break;\n                case \"_alias\":\n                case \"_aliases\":\n                    if (!doneAliases) {\n                        aliasesResult = state.metaData().findAliases(Strings.EMPTY_ARRAY, concreteIndices);\n                        doneAliases = true;\n                    }\n                    break;\n                case \"_settings\":\n                    if (!doneSettings) {\n                        ImmutableOpenMap.Builder<String, Settings> settingsMapBuilder = ImmutableOpenMap.builder();\n                        for (String index : concreteIndices) {\n                            settingsMapBuilder.put(index, state.metaData().index(index).getSettings());\n                        }\n                        settings = settingsMapBuilder.build();\n                        doneSettings = true;\n                    }\n                    break;\n\n                default:\n                    throw new ElasticsearchIllegalStateException(\"feature [\" + feature + \"] is not valid\");\n            }\n        }\n        listener.onResponse(new GetIndexResponse(concreteIndices, warmersResult, mappingsResult, aliasesResult, settings));\n    }","id":89799,"modified_method":"@Override\n    protected void doMasterOperation(final GetIndexRequest request, String[] concreteIndices, final ClusterState state,\n                                     final ActionListener<GetIndexResponse> listener) throws ElasticsearchException {\n        ImmutableOpenMap<String, ImmutableList<Entry>> warmersResult = ImmutableOpenMap.of();\n        ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsResult = ImmutableOpenMap.of();\n        ImmutableOpenMap<String, ImmutableList<AliasMetaData>> aliasesResult = ImmutableOpenMap.of();\n        ImmutableOpenMap<String, Settings> settings = ImmutableOpenMap.of();\n        Feature[] features = request.featuresAsEnums();\n        boolean doneAliases = false;\n        boolean doneMappings = false;\n        boolean doneSettings = false;\n        boolean doneWarmers = false;\n        for (Feature feature : features) {\n            switch (feature) {\n            case WARMERS:\n                    if (!doneWarmers) {\n                        warmersResult = state.metaData().findWarmers(concreteIndices, request.types(), Strings.EMPTY_ARRAY);\n                        doneWarmers = true;\n                    }\n                    break;\n            case MAPPINGS:\n                    if (!doneMappings) {\n                        mappingsResult = state.metaData().findMappings(concreteIndices, request.types());\n                        doneMappings = true;\n                    }\n                    break;\n            case ALIASES:\n                    if (!doneAliases) {\n                        aliasesResult = state.metaData().findAliases(Strings.EMPTY_ARRAY, concreteIndices);\n                        doneAliases = true;\n                    }\n                    break;\n            case SETTINGS:\n                    if (!doneSettings) {\n                        ImmutableOpenMap.Builder<String, Settings> settingsMapBuilder = ImmutableOpenMap.builder();\n                        for (String index : concreteIndices) {\n                            settingsMapBuilder.put(index, state.metaData().index(index).getSettings());\n                        }\n                        settings = settingsMapBuilder.build();\n                        doneSettings = true;\n                    }\n                    break;\n\n                default:\n                    throw new ElasticsearchIllegalStateException(\"feature [\" + feature + \"] is not valid\");\n            }\n        }\n        listener.onResponse(new GetIndexResponse(concreteIndices, warmersResult, mappingsResult, aliasesResult, settings));\n    }","commit_id":"353574d6af98685e9ced83e54b72b4cace55fb0f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n\n        final ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n        final String path = operation.require(CommonAttributes.PATH).asString();\n        final Boolean enabled = operation.hasDefined(CommonAttributes.SCAN_ENABLED)\n            ? operation.get(CommonAttributes.SCAN_ENABLED).asBoolean()\n            : null;\n        final Integer interval = operation.hasDefined(CommonAttributes.SCAN_INTERVAL)\n            ? operation.get(CommonAttributes.SCAN_INTERVAL).asInt()\n            : null;\n        final String relativeTo = operation.hasDefined(CommonAttributes.RELATIVE_TO)\n            ? operation.get(CommonAttributes.RELATIVE_TO).asString()\n            : null;\n        final Boolean autoDeployZip =  operation.hasDefined(CommonAttributes.AUTO_DEPLOY_ZIPPED)\n                    ? operation.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).asBoolean()\n                    : null;\n        final Boolean autoDeployExp =  operation.hasDefined(CommonAttributes.AUTO_DEPLOY_EXPLODED)\n                    ? operation.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).asBoolean()\n                    : null;\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(opAddr);\n\n        final ModelNode subModel = context.getSubModel();\n        subModel.get(CommonAttributes.PATH).set(path);\n        if (enabled != null) subModel.get(CommonAttributes.SCAN_ENABLED).set(enabled);\n        if (interval != null) subModel.get(CommonAttributes.SCAN_INTERVAL).set(interval);\n        if (autoDeployZip != null) subModel.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).set(autoDeployZip);\n        if (autoDeployExp != null) subModel.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).set(autoDeployExp);\n        if(relativeTo != null) subModel.get(CommonAttributes.RELATIVE_TO).set(relativeTo);\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                @Override\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceTarget serviceTarget = context.getServiceTarget();\n                    DeploymentScannerService.addService(serviceTarget, name, relativeTo, path, interval, TimeUnit.MILLISECONDS,\n                                                        autoDeployZip, autoDeployExp, enabled);\n                    resultHandler.handleResultComplete();\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensatingOperation);\n    }","id":89800,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n\n        final ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n        final String path = operation.require(CommonAttributes.PATH).asString();\n        final Boolean enabled = operation.hasDefined(CommonAttributes.SCAN_ENABLED)\n            ? operation.get(CommonAttributes.SCAN_ENABLED).asBoolean()\n            : null;\n        final Integer interval = operation.hasDefined(CommonAttributes.SCAN_INTERVAL)\n            ? operation.get(CommonAttributes.SCAN_INTERVAL).asInt()\n            : null;\n        final String relativeTo = operation.hasDefined(CommonAttributes.RELATIVE_TO)\n            ? operation.get(CommonAttributes.RELATIVE_TO).asString()\n            : null;\n        final Boolean autoDeployZip =  operation.hasDefined(CommonAttributes.AUTO_DEPLOY_ZIPPED)\n                    ? operation.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).asBoolean()\n                    : null;\n        final Boolean autoDeployExp =  operation.hasDefined(CommonAttributes.AUTO_DEPLOY_EXPLODED)\n                    ? operation.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).asBoolean()\n                    : null;\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(opAddr);\n\n        final ModelNode subModel = context.getSubModel();\n        subModel.get(CommonAttributes.NAME).set(name);\n        subModel.get(CommonAttributes.PATH).set(path);\n        if (enabled != null) subModel.get(CommonAttributes.SCAN_ENABLED).set(enabled);\n        if (interval != null) subModel.get(CommonAttributes.SCAN_INTERVAL).set(interval);\n        if (autoDeployZip != null) subModel.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).set(autoDeployZip);\n        if (autoDeployExp != null) subModel.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).set(autoDeployExp);\n        if(relativeTo != null) subModel.get(CommonAttributes.RELATIVE_TO).set(relativeTo);\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                @Override\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceTarget serviceTarget = context.getServiceTarget();\n                    DeploymentScannerService.addService(serviceTarget, name, relativeTo, path, interval, TimeUnit.MILLISECONDS,\n                                                        autoDeployZip, autoDeployExp, enabled);\n                    resultHandler.handleResultComplete();\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensatingOperation);\n    }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        log.debug(\"Initializing Deployment Scanner Extension\");\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(CommonAttributes.DEPLOYMENT_SCANNER);\n        subsystem.registerXMLElementWriter(parser);\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(DeploymentSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, SubsystemAdd.INSTANCE, DeploymentSubsystemProviders.SUBSYSTEM_ADD, false);\n        // Register operation handlers\n        final ModelNodeRegistration scanners = registration.registerSubModel(scannersPath, DeploymentSubsystemProviders.SCANNER);\n        scanners.registerOperationHandler(ADD, DeploymentScannerAdd.INSTANCE, DeploymentSubsystemProviders.SCANNER_ADD, false);\n        scanners.registerOperationHandler(REMOVE, DeploymentScannerRemove.INSTANCE, DeploymentSubsystemProviders.SCANNER_REMOVE, false);\n        scanners.registerOperationHandler(\"enable\", DeploymentScannerEnable.INSTANCE, DeploymentSubsystemProviders.SCANNER_ENABLE, false);\n        scanners.registerOperationHandler(\"disable\", DeploymentScannerDisable.INSTANCE, DeploymentSubsystemProviders.SCANNER_DISABLE, false);\n    }","id":89801,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        log.debug(\"Initializing Deployment Scanner Extension\");\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(CommonAttributes.DEPLOYMENT_SCANNER);\n        subsystem.registerXMLElementWriter(parser);\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(SUBSYSTEM);\n        registration.registerOperationHandler(DeploymentScannerSubsystemAdd.OPERATION_NAME, DeploymentScannerSubsystemAdd.INSTANCE,\n                DeploymentScannerSubsystemAdd.INSTANCE, false);\n        registration.registerOperationHandler(DeploymentScannerSubsystemRemove.OPERATION_NAME, DeploymentScannerSubsystemRemove.INSTANCE,\n                DeploymentScannerSubsystemRemove.INSTANCE, false);\n        // Register operation handlers\n        final ModelNodeRegistration scanners = registration.registerSubModel(scannersPath, SCANNER);\n        scanners.registerOperationHandler(DeploymentScannerAdd.OPERATION_NAME, DeploymentScannerAdd.INSTANCE, DeploymentScannerAdd.INSTANCE, false);\n        scanners.registerOperationHandler(DeploymentScannerRemove.OPERATION_NAME, DeploymentScannerRemove.INSTANCE, DeploymentScannerRemove.INSTANCE, false);\n        scanners.registerReadWriteAttribute(Attribute.PATH.getLocalName(), null, WritePathAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        scanners.registerReadWriteAttribute(Attribute.RELATIVE_TO.getLocalName(), null, WriteRelativeToAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        scanners.registerReadWriteAttribute(Attribute.SCAN_ENABLED.getLocalName(), null, WriteEnabledAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        scanners.registerReadWriteAttribute(Attribute.SCAN_INTERVAL.getLocalName(), null, WriteScanIntervalAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        scanners.registerReadWriteAttribute(Attribute.AUTO_DEPLOY_ZIPPED.getLocalName(), null, WriteAutoDeployZipAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n        scanners.registerReadWriteAttribute(Attribute.AUTO_DEPLOY_EXPLODED.getLocalName(), null, WriteAutoDeployExplodedAttributeHandler.INSTANCE, Storage.CONFIGURATION);\n    }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void parseScanner(XMLExtendedStreamReader reader, final ModelNode address, List<ModelNode> list) throws XMLStreamException {\n            // Handle attributes\n            Boolean enabled = null;\n            Integer interval = null;\n            String path = null;\n            String name = DEFAULT_SCANNER_NAME;\n            String relativeTo = null;\n            Boolean autoDeployZipped = null;\n            Boolean autoDeployExploded = null;\n            final int attrCount = reader.getAttributeCount();\n            for (int i = 0; i < attrCount; i++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case PATH: {\n                        path = value;\n                        break;\n                    }\n                    case NAME: {\n                        name = value;\n                        break;\n                    }\n                    case RELATIVE_TO: {\n                        relativeTo = value;\n                        break;\n                    }\n                    case SCAN_INTERVAL: {\n                        interval = Integer.parseInt(value);\n                        break;\n                    }\n                    case SCAN_ENABLED: {\n                        enabled = Boolean.parseBoolean(value);\n                        break;\n                    }\n                    case AUTO_DEPLOY_ZIPPED: {\n                        autoDeployZipped = Boolean.parseBoolean(value);\n                        break;\n                    }\n                    case AUTO_DEPLOY_EXPLODED: {\n                        autoDeployExploded = Boolean.parseBoolean(value);\n                        break;\n                    }\n                    default:\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n            if (name == null) {\n                ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n            }\n            if (path == null) {\n                ParseUtils.missingRequired(reader, Collections.singleton(\"path\"));\n            }\n            requireNoContent(reader);\n\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            operation.get(OP_ADDR).set(address).add(\"scanner\", name);\n            operation.get(CommonAttributes.PATH).set(path);\n            if (interval != null) operation.get(CommonAttributes.SCAN_INTERVAL).set(interval.intValue());\n            if (autoDeployZipped != null) operation.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).set(autoDeployZipped.booleanValue());\n            if (autoDeployExploded != null) operation.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).set(autoDeployExploded.booleanValue());\n            if (enabled != null) operation.get(CommonAttributes.SCAN_ENABLED).set(enabled.booleanValue());\n            if(relativeTo != null) operation.get(CommonAttributes.RELATIVE_TO).set(relativeTo);\n            list.add(operation);\n        }","id":89802,"modified_method":"void parseScanner(XMLExtendedStreamReader reader, final ModelNode address, List<ModelNode> list) throws XMLStreamException {\n            // Handle attributes\n            Boolean enabled = null;\n            Integer interval = null;\n            String path = null;\n            String name = DEFAULT_SCANNER_NAME;\n            String relativeTo = null;\n            Boolean autoDeployZipped = null;\n            Boolean autoDeployExploded = null;\n            final int attrCount = reader.getAttributeCount();\n            for (int i = 0; i < attrCount; i++) {\n                requireNoNamespaceAttribute(reader, i);\n                final String value = reader.getAttributeValue(i);\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case PATH: {\n                        path = value;\n                        break;\n                    }\n                    case NAME: {\n                        name = value;\n                        break;\n                    }\n                    case RELATIVE_TO: {\n                        relativeTo = value;\n                        break;\n                    }\n                    case SCAN_INTERVAL: {\n                        interval = Integer.parseInt(value);\n                        break;\n                    }\n                    case SCAN_ENABLED: {\n                        enabled = Boolean.parseBoolean(value);\n                        break;\n                    }\n                    case AUTO_DEPLOY_ZIPPED: {\n                        autoDeployZipped = Boolean.parseBoolean(value);\n                        break;\n                    }\n                    case AUTO_DEPLOY_EXPLODED: {\n                        autoDeployExploded = Boolean.parseBoolean(value);\n                        break;\n                    }\n                    default:\n                        throw ParseUtils.unexpectedAttribute(reader, i);\n                }\n            }\n            if (name == null) {\n                ParseUtils.missingRequired(reader, Collections.singleton(CommonAttributes.NAME));\n            }\n            if (path == null) {\n                ParseUtils.missingRequired(reader, Collections.singleton(CommonAttributes.PATH));\n            }\n            requireNoContent(reader);\n\n            final ModelNode operation = new ModelNode();\n            operation.get(OP).set(ADD);\n            operation.get(OP_ADDR).set(address).add(CommonAttributes.SCANNER, name);\n            operation.get(CommonAttributes.PATH).set(path);\n            if (interval != null) operation.get(CommonAttributes.SCAN_INTERVAL).set(interval.intValue());\n            if (autoDeployZipped != null) operation.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).set(autoDeployZipped.booleanValue());\n            if (autoDeployExploded != null) operation.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).set(autoDeployExploded.booleanValue());\n            if (enabled != null) operation.get(CommonAttributes.SCAN_ENABLED).set(enabled.booleanValue());\n            if(relativeTo != null) operation.get(CommonAttributes.RELATIVE_TO).set(relativeTo);\n            list.add(operation);\n        }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n\n        final PathAddress address = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode subModel = new ModelNode();\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(ADD);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n        compensatingOperation.get(CommonAttributes.PATH).set(subModel.get(CommonAttributes.PATH));\n        compensatingOperation.get(CommonAttributes.SCAN_ENABLED).set(subModel.get(CommonAttributes.SCAN_ENABLED));\n        compensatingOperation.get(CommonAttributes.SCAN_INTERVAL).set(subModel.get(CommonAttributes.SCAN_INTERVAL));\n        compensatingOperation.get(CommonAttributes.RELATIVE_TO).set(subModel.get(CommonAttributes.RELATIVE_TO));\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceController<?> controller = context.getServiceRegistry()\n                            .getService(DeploymentScannerService.getServiceName(name));\n                    if (controller != null) {\n                        controller.addListener(new ResultHandler.ServiceRemoveListener(resultHandler));\n                    } else {\n                        resultHandler.handleResultComplete();\n                    }\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensatingOperation);\n    }","id":89803,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) {\n\n        final PathAddress address = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode subModel = new ModelNode();\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(ADD);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n        compensatingOperation.get(CommonAttributes.PATH).set(subModel.get(CommonAttributes.PATH));\n        if (subModel.hasDefined(CommonAttributes.SCAN_ENABLED))\n            compensatingOperation.get(CommonAttributes.SCAN_ENABLED).set(subModel.get(CommonAttributes.SCAN_ENABLED));\n        if (subModel.hasDefined(CommonAttributes.SCAN_INTERVAL))\n            compensatingOperation.get(CommonAttributes.SCAN_INTERVAL).set(subModel.get(CommonAttributes.SCAN_INTERVAL));\n        if (subModel.hasDefined(CommonAttributes.RELATIVE_TO))\n            compensatingOperation.get(CommonAttributes.RELATIVE_TO).set(subModel.get(CommonAttributes.RELATIVE_TO));\n        if (subModel.hasDefined(CommonAttributes.AUTO_DEPLOY_ZIPPED))\n            compensatingOperation.get(CommonAttributes.AUTO_DEPLOY_ZIPPED).set(subModel.get(CommonAttributes.AUTO_DEPLOY_ZIPPED));\n        if (subModel.hasDefined(CommonAttributes.AUTO_DEPLOY_EXPLODED))\n            compensatingOperation.get(CommonAttributes.AUTO_DEPLOY_EXPLODED).set(subModel.get(CommonAttributes.AUTO_DEPLOY_EXPLODED));\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceController<?> controller = context.getServiceRegistry()\n                            .getService(DeploymentScannerService.getServiceName(name));\n                    if (controller != null) {\n                        controller.addListener(new ResultHandler.ServiceRemoveListener(resultHandler));\n                    } else {\n                        resultHandler.handleResultComplete();\n                    }\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensatingOperation);\n    }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(OperationContext context, ModelNode operation, ResultHandler resultHandler) {\n\n        // Initialize the scanner\n        context.getSubModel().get(CommonAttributes.DEPLOYMENT_SCANNER).setEmptyObject();\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(operation.get(OP_ADDR));\n\n        resultHandler.handleResultComplete();\n\n        context.getSubModel().setEmptyObject();\n\n        return new BasicOperationResult(compensatingOperation);\n    }","id":89804,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public OperationResult execute(OperationContext context, ModelNode operation, ResultHandler resultHandler) {\n\n        // Initialize the scanner\n        context.getSubModel().get(CommonAttributes.SCANNER).setEmptyObject();\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(operation.get(OP_ADDR));\n\n        resultHandler.handleResultComplete();\n\n        return new BasicOperationResult(compensatingOperation);\n    }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Locale getLocale(final ModelNode operation) {\n        if (!operation.has(LOCALE)) {\n            return null;\n        }\n        return new Locale(operation.get(LOCALE).asString());\n    }","id":89805,"modified_method":"private static Locale getLocale(final ModelNode operation) {\n        if (!operation.hasDefined(LOCALE)) {\n            return null;\n        }\n        return new Locale(operation.get(LOCALE).asString());\n    }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            String childName = operation.require(CHILD_TYPE).asString();\n\n            ModelNode subModel = context.getSubModel().clone();\n            if (!subModel.isDefined()) {\n                final ModelNode result = new ModelNode();\n                result.setEmptyList();\n                resultHandler.handleResultFragment(new String[0], result);\n                resultHandler.handleResultComplete();\n            } else {\n                final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final Set<String> childNames = context.getRegistry().getChildNames(address);\n                if (!childNames.contains(childName)) {\n                    throw new OperationFailedException(new ModelNode().set(\"No known child called \" + childName)); //TODO i18n\n                } else {\n                    final AtomicBoolean ok = new AtomicBoolean(true);\n                    final ModelNode result = new ModelNode();\n                    subModel = subModel.get(childName);\n                    if (!subModel.isDefined()) {\n                        result.setEmptyList();\n                    } else {\n\n                        for (final String key : subModel.keys()) {\n                            if (!ok.get()) {\n                                break;\n                            }\n                            final PathAddress childAddress = address.append(PathElement.pathElement(childName, key));\n\n                            final ModelNode readOp = operation.clone();\n                            readOp.get(OP_ADDR).set(childAddress.toModelNode());\n\n                            if(operation.has(INCLUDE_RUNTIME))\n                                readOp.get(INCLUDE_RUNTIME).set(operation.get(INCLUDE_RUNTIME).asBoolean());\n\n                            final ModelNode readResult = readModel(context, readOp, new ResultHandler() {\n                                public void handleResultFragment(String[] location, ModelNode result) {\n                                    // TODO\n                                }\n                                public void handleResultComplete() {\n                                    // TODO\n                                }\n                                public void handleFailed(ModelNode failureDescription) {\n                                    ok.set(false);\n                                    resultHandler.handleFailed(failureDescription);\n                                }\n                                public void handleCancellation() {\n                                    ok.set(false);\n                                    resultHandler.handleCancellation();\n                                }\n                            }, childAddress);\n                            result.add(key, readResult);\n                        }\n                    }\n\n                    if (ok.get()) {\n                        resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n                        resultHandler.handleResultComplete();\n                    }\n                }\n            }\n\n            return new BasicOperationResult();\n        }","id":89806,"modified_method":"@Override\n        public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler) throws OperationFailedException {\n\n            String childName = operation.require(CHILD_TYPE).asString();\n\n            ModelNode subModel = context.getSubModel().clone();\n            if (!subModel.isDefined()) {\n                final ModelNode result = new ModelNode();\n                result.setEmptyList();\n                resultHandler.handleResultFragment(new String[0], result);\n                resultHandler.handleResultComplete();\n            } else {\n                final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n                final Set<String> childNames = context.getRegistry().getChildNames(address);\n                if (!childNames.contains(childName)) {\n                    throw new OperationFailedException(new ModelNode().set(\"No known child called \" + childName)); //TODO i18n\n                } else {\n                    final AtomicBoolean ok = new AtomicBoolean(true);\n                    final ModelNode result = new ModelNode();\n                    subModel = subModel.get(childName);\n                    if (!subModel.isDefined()) {\n                        result.setEmptyList();\n                    } else {\n\n                        for (final String key : subModel.keys()) {\n                            if (!ok.get()) {\n                                break;\n                            }\n                            final PathAddress childAddress = address.append(PathElement.pathElement(childName, key));\n\n                            final ModelNode readOp = operation.clone();\n                            readOp.get(OP_ADDR).set(childAddress.toModelNode());\n\n                            if(operation.hasDefined(INCLUDE_RUNTIME))\n                                readOp.get(INCLUDE_RUNTIME).set(operation.get(INCLUDE_RUNTIME).asBoolean());\n\n                            final ModelNode readResult = readModel(context, readOp, new ResultHandler() {\n                                public void handleResultFragment(String[] location, ModelNode result) {\n                                    // TODO\n                                }\n                                public void handleResultComplete() {\n                                    // TODO\n                                }\n                                public void handleFailed(ModelNode failureDescription) {\n                                    ok.set(false);\n                                    resultHandler.handleFailed(failureDescription);\n                                }\n                                public void handleCancellation() {\n                                    ok.set(false);\n                                    resultHandler.handleCancellation();\n                                }\n                            }, childAddress);\n                            result.add(key, readResult);\n                        }\n                    }\n\n                    if (ok.get()) {\n                        resultHandler.handleResultFragment(Util.NO_LOCATION, result);\n                        resultHandler.handleResultComplete();\n                    }\n                }\n            }\n\n            return new BasicOperationResult();\n        }","commit_id":"69d33bfdd7e59efa09769a9b1a600ae946422cc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc */\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final Resource resource = context.createResource(PathAddress.EMPTY_ADDRESS);\n        populateModel(context, operation, resource);\n        final ModelNode model = resource.getModel();\n\n        if (requiresRuntime(context)) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                    final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n                    final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    performRuntime(context, operation, model, verificationHandler, controllers);\n\n                    if(requiresRuntimeVerification()) {\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        @Override\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            rollbackRuntime(context, operation, model, controllers);\n                        }\n                    });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","id":89807,"modified_method":"/** {@inheritDoc */\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final Resource resource = createResource(context);\n        populateModel(context, operation, resource);\n        final ModelNode model = resource.getModel();\n\n        if (requiresRuntime(context)) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                    final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n                    final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    performRuntime(context, operation, model, verificationHandler, controllers);\n\n                    if(requiresRuntimeVerification()) {\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        @Override\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            rollbackRuntime(context, operation, model, controllers);\n                        }\n                    });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceController<Void> addService(final ServiceTarget target, final ServiceVerificationHandler verificationHandler) {\n        FrameworkBootstrapService service = new FrameworkBootstrapService();\n        ServiceBuilder<Void> builder = target.addService(FRAMEWORK_BOOTSTRAP, service);\n        builder.addDependency(ServerEnvironmentService.SERVICE_NAME, ServerEnvironment.class, service.injectedServerEnvironment);\n        builder.addDependency(SubsystemState.SERVICE_NAME, SubsystemState.class, service.injectedSubsystemState);\n        builder.addDependency(JBOSS_BINDING_NAME.append(\"osgi-http\"), SocketBinding.class, service.httpServerPortBinding);\n        builder.addListener(verificationHandler);\n        return builder.install();\n    }","id":89808,"modified_method":"public static ServiceController<Void> addService(final ServiceTarget target, OSGiRuntimeResource resource, final ServiceVerificationHandler verificationHandler) {\n        FrameworkBootstrapService service = new FrameworkBootstrapService(resource);\n        ServiceBuilder<Void> builder = target.addService(FRAMEWORK_BOOTSTRAP, service);\n        builder.addDependency(ServerEnvironmentService.SERVICE_NAME, ServerEnvironment.class, service.injectedServerEnvironment);\n        builder.addDependency(SubsystemState.SERVICE_NAME, SubsystemState.class, service.injectedSubsystemState);\n        builder.addDependency(JBOSS_BINDING_NAME.append(\"osgi-http\"), SocketBinding.class, service.httpServerPortBinding);\n        builder.addListener(verificationHandler);\n        return builder.install();\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void stop(StopContext context) {\n            ServiceController<?> controller = context.getController();\n            LOGGER.tracef(\"Stopping: %s in mode %s\", controller.getName(), controller.getMode());\n            injectedBundleContext.getValue().removeServiceListener(jndiServiceListener);\n        }","id":89809,"modified_method":"@Override\n        public void stop(StopContext context) {\n            ServiceController<?> controller = context.getController();\n            LOGGER.tracef(\"Stopping: %s in mode %s\", controller.getName(), controller.getMode());\n            injectedBundleContext.getValue().removeServiceListener(jndiServiceListener);\n            resource.getInjectedBundleContext().uninject();\n        }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void start(StartContext context) throws StartException {\n        ServiceController<?> controller = context.getController();\n        LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            SubsystemState subsystemState = injectedSubsystemState.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Register the URLStreamHandlerFactory\n            Module coreFrameworkModule = ((ModuleClassLoader) FrameworkBuilder.class.getClassLoader()).getModule();\n            Module.registerURLStreamHandlerFactoryModule(coreFrameworkModule);\n            Module.registerContentHandlerFactoryModule(coreFrameworkModule);\n\n            ServiceTarget serviceTarget = context.getChildTarget();\n            AutoInstallIntegration.addService(serviceTarget);\n            FrameworkModuleIntegration.addService(serviceTarget, props);\n            JAXPServiceProvider.addService(serviceTarget);\n            ModuleLoaderIntegration.addService(serviceTarget);\n            ModuleIdentityArtifactProvider.addService(serviceTarget);\n            RepositoryProvider.addService(serviceTarget);\n            ResolverService.addService(serviceTarget);\n            SystemServicesIntegration.addService(serviceTarget);\n\n            // Configure the {@link Framework} builder\n            Activation activation = subsystemState.getActivationPolicy();\n            Mode initialMode = (activation == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n            FrameworkBuilder builder = new FrameworkBuilder(props, initialMode);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(serviceTarget);\n\n            // Create the {@link Framework} services\n            builder.createFrameworkServices(true);\n\n        } catch (Throwable th) {\n            throw MESSAGES.startFailedToCreateFrameworkServices(th);\n        }\n    }","id":89810,"modified_method":"public synchronized void start(StartContext context) throws StartException {\n        ServiceController<?> controller = context.getController();\n        LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            SubsystemState subsystemState = injectedSubsystemState.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Register the URLStreamHandlerFactory\n            Module coreFrameworkModule = ((ModuleClassLoader) FrameworkBuilder.class.getClassLoader()).getModule();\n            Module.registerURLStreamHandlerFactoryModule(coreFrameworkModule);\n            Module.registerContentHandlerFactoryModule(coreFrameworkModule);\n\n            ServiceTarget serviceTarget = context.getChildTarget();\n            AutoInstallIntegration.addService(serviceTarget);\n            FrameworkModuleIntegration.addService(serviceTarget, props);\n            JAXPServiceProvider.addService(serviceTarget);\n            ModuleLoaderIntegration.addService(serviceTarget);\n            ModuleIdentityArtifactProvider.addService(serviceTarget);\n            RepositoryProvider.addService(serviceTarget);\n            ResolverService.addService(serviceTarget);\n            SystemServicesIntegration.addService(serviceTarget, resource);\n\n            // Configure the {@link Framework} builder\n            Activation activation = subsystemState.getActivationPolicy();\n            Mode initialMode = (activation == Activation.EAGER ? Mode.ACTIVE : Mode.ON_DEMAND);\n            FrameworkBuilder builder = new FrameworkBuilder(props, initialMode);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(serviceTarget);\n\n            // Create the {@link Framework} services\n            builder.createFrameworkServices(true);\n\n        } catch (Throwable th) {\n            throw MESSAGES.startFailedToCreateFrameworkServices(th);\n        }\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceController<?> addService(final ServiceTarget target) {\n            SystemServicesIntegration service = new SystemServicesIntegration();\n            ServiceBuilder<SystemServicesProvider> builder = target.addService(IntegrationServices.SYSTEM_SERVICES_PROVIDER, service);\n            builder.addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer);\n            builder.addDependency(Services.SYSTEM_CONTEXT, BundleContext.class, service.injectedBundleContext);\n            builder.addDependency(Services.FRAMEWORK_CREATE);\n            builder.setInitialMode(Mode.ON_DEMAND);\n            return builder.install();\n        }","id":89811,"modified_method":"public static ServiceController<?> addService(final ServiceTarget target, OSGiRuntimeResource resource) {\n            SystemServicesIntegration service = new SystemServicesIntegration(resource);\n            ServiceBuilder<SystemServicesProvider> builder = target.addService(IntegrationServices.SYSTEM_SERVICES_PROVIDER, service);\n            builder.addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.injectedMBeanServer);\n            builder.addDependency(Services.SYSTEM_CONTEXT, BundleContext.class, service.injectedBundleContext);\n            builder.addDependency(Services.FRAMEWORK_CREATE);\n            builder.setInitialMode(Mode.ON_DEMAND);\n            return builder.install();\n        }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void start(StartContext context) throws StartException {\n            ServiceController<?> controller = context.getController();\n            LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n            serviceContainer = context.getController().getServiceContainer();\n            final BundleContext syscontext = injectedBundleContext.getValue();\n\n            // Register the JNDI service listener\n            jndiServiceListener = new JNDIServiceListener(syscontext);\n            try {\n                String filter = \"(\" + Constants.OBJECTCLASS + \"=\" + ObjectFactory.class.getName() + \")\";\n                syscontext.addServiceListener(jndiServiceListener, filter);\n            } catch (InvalidSyntaxException e) {\n                // ignore\n            }\n\n            // Register the socket-binding services\n            String bindingNames = syscontext.getProperty(MAPPED_OSGI_SOCKET_BINDINGS);\n            if (bindingNames != null) {\n                final Set<ServiceName> socketBindingNames = new HashSet<ServiceName>();\n                for (String suffix : bindingNames.split(\",\")) {\n                    socketBindingNames.add(JBOSS_BINDING_NAME.append(suffix));\n                }\n                ServiceTarget serviceTarget = context.getChildTarget();\n                ServiceName serviceName = IntegrationServices.SYSTEM_SERVICES_PROVIDER.append(\"BINDINGS\");\n                ServiceBuilder<Void> builder = serviceTarget.addService(serviceName, new AbstractService<Void>() {\n                    public void start(StartContext context) throws StartException {\n                        for (ServiceName serviceName : socketBindingNames) {\n                            SocketBinding binding = (SocketBinding) serviceContainer.getRequiredService(serviceName).getValue();\n                            Dictionary<String, String> props = new Hashtable<String, String>();\n                            props.put(\"socketBinding\", serviceName.getSimpleName());\n                            InetSocketAddress value = binding.getSocketAddress();\n                            syscontext.registerService(InetSocketAddress.class.getName(), value, props);\n                        }\n                    }\n                });\n                ServiceName[] serviceNameArray = socketBindingNames.toArray(new ServiceName[socketBindingNames.size()]);\n                builder.addDependencies(serviceNameArray);\n                builder.install();\n            }\n        }","id":89812,"modified_method":"@Override\n        public void start(StartContext context) throws StartException {\n            ServiceController<?> controller = context.getController();\n            LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n            serviceContainer = context.getController().getServiceContainer();\n            final BundleContext syscontext = injectedBundleContext.getValue();\n\n            // Inject the system bundle context into the runtime resource\n            resource.getInjectedBundleContext().inject(syscontext);\n\n            // Register the JNDI service listener\n            jndiServiceListener = new JNDIServiceListener(syscontext);\n            try {\n                String filter = \"(\" + Constants.OBJECTCLASS + \"=\" + ObjectFactory.class.getName() + \")\";\n                syscontext.addServiceListener(jndiServiceListener, filter);\n            } catch (InvalidSyntaxException e) {\n                // ignore\n            }\n\n            // Register the socket-binding services\n            String bindingNames = syscontext.getProperty(MAPPED_OSGI_SOCKET_BINDINGS);\n            if (bindingNames != null) {\n                final Set<ServiceName> socketBindingNames = new HashSet<ServiceName>();\n                for (String suffix : bindingNames.split(\",\")) {\n                    socketBindingNames.add(JBOSS_BINDING_NAME.append(suffix));\n                }\n                ServiceTarget serviceTarget = context.getChildTarget();\n                ServiceName serviceName = IntegrationServices.SYSTEM_SERVICES_PROVIDER.append(\"BINDINGS\");\n                ServiceBuilder<Void> builder = serviceTarget.addService(serviceName, new AbstractService<Void>() {\n                    public void start(StartContext context) throws StartException {\n                        for (ServiceName serviceName : socketBindingNames) {\n                            SocketBinding binding = (SocketBinding) serviceContainer.getRequiredService(serviceName).getValue();\n                            Dictionary<String, String> props = new Hashtable<String, String>();\n                            props.put(\"socketBinding\", serviceName.getSimpleName());\n                            InetSocketAddress value = binding.getSocketAddress();\n                            syscontext.registerService(InetSocketAddress.class.getName(), value, props);\n                        }\n                    }\n                });\n                ServiceName[] serviceNameArray = socketBindingNames.toArray(new ServiceName[socketBindingNames.size()]);\n                builder.addDependencies(serviceNameArray);\n                builder.install();\n            }\n        }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(OSGiSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiSubsystemAdd.INSTANCE, OSGiSubsystemAdd.DESCRIPTION, false);\n        registration.registerReadWriteAttribute(ModelConstants.ACTIVATION, null, ActivationAttributeHandler.INSTANCE, EnumSet.of(AttributeAccess.Flag.STORAGE_CONFIGURATION, AttributeAccess.Flag.RESTART_JVM));\n        if (registerRuntimeOnly) {\n            registration.registerReadWriteAttribute(ModelConstants.STARTLEVEL, StartLevelHandler.READ_HANDLER, StartLevelHandler.WRITE_HANDLER, Storage.RUNTIME);\n            registration.registerOperationHandler(ModelConstants.ACTIVATE, ActivateOperationHandler.INSTANCE, ActivateOperationHandler.INSTANCE, EnumSet.of(OperationEntry.Flag.RESTART_NONE));\n        }\n        registration.registerOperationHandler(ModelDescriptionConstants.DESCRIBE, OSGiSubsystemDescribeHandler.INSTANCE, OSGiSubsystemAdd.DESCRIPTION, false, OperationEntry.EntryType.PRIVATE);\n        registration.registerOperationHandler(ModelDescriptionConstants.REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, OSGiSubsystemProviders.SUBSYSTEM_REMOVE, false);\n\n        // Framework Properties\n        ManagementResourceRegistration properties = registration.registerSubModel(PathElement.pathElement(ModelConstants.PROPERTY), OSGiSubsystemProviders.PROPERTY_DESCRIPTION);\n        properties.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiFrameworkPropertyAdd.INSTANCE, OSGiFrameworkPropertyAdd.DESCRIPTION, false);\n        properties.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiFrameworkPropertyRemove.INSTANCE, OSGiFrameworkPropertyRemove.DESCRIPTION, false);\n        properties.registerReadWriteAttribute(ModelConstants.VALUE, null, OSGiFrameworkPropertyWrite.INSTANCE, Storage.CONFIGURATION);\n\n        // Framework Capabilities\n        ManagementResourceRegistration capabilities = registration.registerSubModel(PathElement.pathElement(ModelConstants.CAPABILITY), OSGiSubsystemProviders.CAPABILITY_DESCRIPTION);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiCapabilityAdd.INSTANCE, OSGiCapabilityAdd.DESCRIPTION, false);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiCapabilityRemove.INSTANCE, OSGiCapabilityRemove.DESCRIPTION, false);\n        capabilities.registerReadOnlyAttribute(ModelConstants.STARTLEVEL, null, Storage.RUNTIME);\n\n        if (registerRuntimeOnly) {\n            // Bundles present at runtime, this info is not available for controllers\n            ManagementResourceRegistration bundles = registration.registerSubModel(PathElement.pathElement(ModelConstants.BUNDLE), OSGiSubsystemProviders.BUNDLE_DESCRIPTION);\n            BundleRuntimeHandler.INSTANCE.register(bundles);\n        }\n\n        subsystem.registerXMLElementWriter(OSGiSubsystemWriter.INSTANCE);\n    }","id":89813,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(OSGiDescriptionProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiSubsystemAdd.INSTANCE, OSGiDescriptionProviders.SUBSYSTEM_ADD, false);\n        registration.registerReadWriteAttribute(ModelConstants.ACTIVATION, null, ActivationAttributeHandler.INSTANCE, EnumSet.of(AttributeAccess.Flag.STORAGE_CONFIGURATION, AttributeAccess.Flag.RESTART_JVM));\n        registration.registerOperationHandler(ModelDescriptionConstants.DESCRIBE, OSGiSubsystemDescribeHandler.INSTANCE, OSGiDescriptionProviders.SUBSYSTEM_ADD, false, OperationEntry.EntryType.PRIVATE);\n        registration.registerOperationHandler(ModelDescriptionConstants.REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, OSGiDescriptionProviders.SUBSYSTEM_REMOVE, false);\n\n        // Framework Properties\n        ManagementResourceRegistration properties = registration.registerSubModel(PathElement.pathElement(ModelConstants.PROPERTY), OSGiDescriptionProviders.PROPERTY_DESCRIPTION);\n        properties.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiFrameworkPropertyAdd.INSTANCE, OSGiFrameworkPropertyAdd.DESCRIPTION, false);\n        properties.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiFrameworkPropertyRemove.INSTANCE, OSGiFrameworkPropertyRemove.DESCRIPTION, false);\n        properties.registerReadWriteAttribute(ModelConstants.VALUE, null, OSGiFrameworkPropertyWrite.INSTANCE, Storage.CONFIGURATION);\n\n        // Framework Capabilities\n        ManagementResourceRegistration capabilities = registration.registerSubModel(PathElement.pathElement(ModelConstants.CAPABILITY), OSGiDescriptionProviders.CAPABILITY_DESCRIPTION);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiCapabilityAdd.INSTANCE, OSGiCapabilityAdd.DESCRIPTION, false);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiCapabilityRemove.INSTANCE, OSGiCapabilityRemove.DESCRIPTION, false);\n        capabilities.registerReadOnlyAttribute(ModelConstants.STARTLEVEL, null, Storage.RUNTIME);\n\n        // Runtime attributes/operations\n        if (registerRuntimeOnly) {\n            registration.registerOperationHandler(ModelConstants.ACTIVATE, ActivateOperationHandler.INSTANCE, OSGiDescriptionProviders.ACTIVATE_OPERATION, EnumSet.of(OperationEntry.Flag.RESTART_NONE));\n            registration.registerReadWriteAttribute(ModelConstants.STARTLEVEL, StartLevelHandler.READ_HANDLER, StartLevelHandler.WRITE_HANDLER, Storage.RUNTIME);\n            BundleResourceHandler.INSTANCE.register(registration.registerSubModel(PathElement.pathElement(ModelConstants.BUNDLE), OSGiDescriptionProviders.BUNDLE_DESCRIPTION));\n        }\n\n        subsystem.registerXMLElementWriter(OSGiSubsystemWriter.INSTANCE);\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final Activation activationMode = getActivationMode(operation);\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, activationMode);\n\n        context.addStep(new OperationStepHandler() {\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(BundleInstallIntegration.addService(serviceTarget));\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, verificationHandler));\n                newControllers.add(PersistentBundlesIntegration.addService(serviceTarget, deploymentTracker));\n                context.completeStep();\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_OSGI_XSERVICE_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_BUNDLE_CONTEXT_BINDING, new BundleContextBindingProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_OSGI_DEPLOYMENT, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_OSGI_MODULE, new ModuleRegisterProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activationMode));\n\n        // This step injects the System Bundle Service into our custom resource\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                ServiceBuilder<Void> builder = context.getServiceTarget().addService(Services.JBOSGI_BASE_NAME.append(\"OSGiSubsystem\").append(\"initialize\"),\n                        new AbstractService<Void>() {\n                            @SuppressWarnings(\"unchecked\")\n                            @Override\n                            public void start(StartContext context) throws StartException {\n                                try {\n                                    ServiceContainer ctr = context.getController().getServiceContainer();\n                                    ServiceController<Bundle> sc = (ServiceController<Bundle>) ctr.getRequiredService(Services.SYSTEM_BUNDLE);\n                                    resource.setBundleContextServiceController(sc);\n                                } finally {\n                                    context.getController().setMode(Mode.REMOVE);\n                                }\n                            }\n                        });\n                builder.addDependency(Services.SYSTEM_BUNDLE);\n                builder.setInitialMode(Mode.PASSIVE);\n                builder.install();\n                context.completeStep();\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","id":89814,"modified_method":"protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final Activation activationMode = getActivationMode(operation);\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, activationMode);\n\n        context.addStep(new OperationStepHandler() {\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(BundleInstallIntegration.addService(serviceTarget));\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, verificationHandler));\n                newControllers.add(PersistentBundlesIntegration.addService(serviceTarget, deploymentTracker));\n                context.completeStep();\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_OSGI_XSERVICE_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_BUNDLE_CONTEXT_BINDING, new BundleContextBindingProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_OSGI_DEPLOYMENT, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_OSGI_MODULE, new ModuleRegisterProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activationMode));\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testClientDeploymentAsArchive() throws Exception {\n\n        deployer.deploy(DEPLOYMENT_NAME);\n        try {\n            Long bundleId = getBundleId(DEPLOYMENT_NAME, null);\n            Assert.assertNotNull(\"Bundle found\", bundleId);\n            Assert.assertEquals(\"INSTALLED\", getBundleState(bundleId));\n\n            Assert.assertTrue(\"Bundle started\", bundleStart(bundleId));\n            Assert.assertEquals(\"ACTIVE\", getBundleState(bundleId));\n\n            Map<String, Object> info = getBundleInfo(bundleId);\n            Assert.assertEquals(6, info.size());\n            Assert.assertEquals(bundleId + \"L\", info.get(\"id\"));\n            Assert.assertEquals(\"1\", info.get(\"startlevel\"));\n            Assert.assertEquals(\"ACTIVE\", info.get(\"state\"));\n            Assert.assertEquals(DEPLOYMENT_NAME, info.get(\"symbolic-name\"));\n            Assert.assertEquals(\"bundle\", info.get(\"type\"));\n            Assert.assertEquals(\"0.0.0\", info.get(\"version\"));\n\n            Assert.assertTrue(\"Bundle stopped\", bundleStop(bundleId));\n            Assert.assertEquals(\"RESOLVED\", getBundleState(bundleId));\n\n            Assert.assertTrue(\"Bundle started\", bundleStart(DEPLOYMENT_NAME));\n            Assert.assertEquals(\"ACTIVE\", getBundleState(DEPLOYMENT_NAME));\n\n            Assert.assertTrue(\"Bundle stopped\", bundleStop(DEPLOYMENT_NAME));\n            Assert.assertEquals(\"RESOLVED\", getBundleState(DEPLOYMENT_NAME));\n        } finally {\n            deployer.undeploy(DEPLOYMENT_NAME);\n            Assert.assertNull(\"UNINSTALLED\", getBundleState(DEPLOYMENT_NAME));\n        }\n    }","id":89815,"modified_method":"@Test\n    public void testClientDeploymentAsArchive() throws Exception {\n\n        deployer.deploy(DEPLOYMENT_NAME);\n        try {\n            Long bundleId = getBundleId(SYMBOLIC_NAME, null);\n            Assert.assertNotNull(\"Bundle found\", bundleId);\n            Assert.assertEquals(\"INSTALLED\", getBundleState(bundleId));\n\n            Assert.assertTrue(\"Bundle started\", bundleStart(bundleId));\n            Assert.assertEquals(\"ACTIVE\", getBundleState(bundleId));\n\n            Map<String, Object> info = getBundleInfo(bundleId);\n            Assert.assertEquals(7, info.size());\n            Assert.assertEquals(bundleId + \"L\", info.get(ModelConstants.ID));\n            Assert.assertEquals(\"1\", info.get(ModelConstants.STARTLEVEL));\n            Assert.assertEquals(\"ACTIVE\", info.get(ModelConstants.STATE));\n            Assert.assertEquals(SYMBOLIC_NAME, info.get(ModelConstants.SYMBOLIC_NAME));\n            Assert.assertEquals(DEPLOYMENT_NAME, info.get(ModelConstants.LOCATION));\n            Assert.assertEquals(\"bundle\", info.get(ModelConstants.TYPE));\n            Assert.assertEquals(\"0.0.0\", info.get(ModelConstants.VERSION));\n\n            Assert.assertTrue(\"Bundle stopped\", bundleStop(bundleId));\n            Assert.assertEquals(\"RESOLVED\", getBundleState(bundleId));\n\n            Assert.assertTrue(\"Bundle started\", bundleStart(DEPLOYMENT_NAME));\n            Assert.assertEquals(\"ACTIVE\", getBundleState(DEPLOYMENT_NAME));\n\n            Assert.assertTrue(\"Bundle stopped\", bundleStop(DEPLOYMENT_NAME));\n            Assert.assertEquals(\"RESOLVED\", getBundleState(DEPLOYMENT_NAME));\n        } finally {\n            deployer.undeploy(DEPLOYMENT_NAME);\n        }\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment(name = DEPLOYMENT_NAME, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, DEPLOYMENT_NAME);\n        archive.addClasses(SimpleActivator.class, SimpleService.class);\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(SimpleActivator.class);\n                builder.addImportPackages(BundleActivator.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":89816,"modified_method":"@Deployment(name = DEPLOYMENT_NAME, managed = false, testable = false)\n    public static JavaArchive getTestArchive() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, DEPLOYMENT_NAME);\n        archive.addClasses(SimpleActivator.class, SimpleService.class);\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(SYMBOLIC_NAME);\n                builder.addBundleManifestVersion(2);\n                builder.addBundleActivator(SimpleActivator.class);\n                builder.addImportPackages(BundleActivator.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"63c2a2f8f7f6af37a25a85b055520c08ac153b41","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseAndMarshalModel() throws Exception {\n        //Parse the subsystem xml and install into the first controller\n        String subsystemXml = readResource(\"securitysubsystemv12.xml\");\n\n        KernelServices servicesA = super.installInController(AdditionalInitialization.MANAGEMENT, subsystemXml);\n        //Get the model and the persisted xml from the first controller\n        ModelNode modelA = servicesA.readWholeModel();\n        String marshalled = servicesA.getPersistedSubsystemXml();\n        servicesA.shutdown();\n\n        System.out.println(marshalled);\n\n        //Install the persisted xml from the first controller into a second controller\n        KernelServices servicesB = super.installInController(AdditionalInitialization.MANAGEMENT, marshalled);\n        ModelNode modelB = servicesB.readWholeModel();\n\n        //Make sure the models from the two controllers are identical\n        super.compare(modelA, modelB);\n\n        assertRemoveSubsystemResources(servicesB);\n    }","id":89817,"modified_method":"@Test\n    public void testParseAndMarshalModel() throws Exception {\n        standardSubsystemTest(null);\n    }","commit_id":"5c457bf7b86e815d1b57de89cda0b18a152f0b45","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void registerAttributes(final ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerReadWriteAttribute(CACHE_TYPE, null, new SecurityDomainReloadWriteHandler(CACHE_TYPE));\n    }","id":89818,"modified_method":"public void registerAttributes(final ManagementResourceRegistration resourceRegistration) {\n        resourceRegistration.registerReadWriteAttribute(CACHE_TYPE, null, new SecurityDomainReloadWriteHandler(CACHE_TYPE));\n        resourceRegistration.registerReadWriteAttribute(MODULE_OPTIONS, null, new SecurityDomainReloadWriteHandler(MODULE_OPTIONS));\n    }","commit_id":"5c457bf7b86e815d1b57de89cda0b18a152f0b45","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerOperations(ManagementResourceRegistration resourceRegistration) {\n        super.registerOperations(resourceRegistration);\n\n        if (registerRuntimeOnly) {\n            EnumSet<Flag> runtimeOnly = EnumSet.of(Flag.RUNTIME_ONLY);\n            resourceRegistration.registerOperationHandler(Constants.LIST_CACHED_PRINCIPALS,\n                    ListCachePrincipals.INSTANCE, SecuritySubsystemDescriptions.LIST_CACHED_PRINCIPALS, runtimeOnly);\n            resourceRegistration.registerOperationHandler(Constants.FLUSH_CACHE, FlushOperation.INSTANCE,\n                    SecuritySubsystemDescriptions.FLUSH_CACHE, runtimeOnly);\n        }\n    }","id":89819,"modified_method":"@Override\n    public void registerOperations(ManagementResourceRegistration resourceRegistration) {\n        super.registerOperations(resourceRegistration);\n\n        if (registerRuntimeOnly) {\n            resourceRegistration.registerOperationHandler(ListCachePrincipals.DEFINITION, ListCachePrincipals.INSTANCE);\n            resourceRegistration.registerOperationHandler(FlushOperation.DEFINITION,FlushOperation.INSTANCE);\n        }\n    }","commit_id":"5c457bf7b86e815d1b57de89cda0b18a152f0b45","url":"https://github.com/wildfly/wildfly"},{"original_method":"public URI postForLocation(String url, Object request, String... urlVariables)\n\t\t\tthrows RestClientException {\n\n\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\tHttpHeaders headers =\n\t\t\t\texecute(url, HttpMethod.POST, new PostPutCallback(request), this.headersExtractor, urlVariables);\n\t\treturn headers.getLocation();\n\t}","id":89820,"modified_method":"public URI postForLocation(String url, Object request, String... urlVariables) throws RestClientException {\n\t\tif (request != null) {\n\t\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\t}\n\t\tHttpHeaders headers =\n\t\t\t\texecute(url, HttpMethod.POST, new PostPutCallback(request), this.headersExtractor, urlVariables);\n\t\treturn headers.getLocation();\n\t}","commit_id":"4c0edc2b9ddbc8c65cf2aab7cc05b71593b6daf4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public URI postForLocation(String url, Object request, Map<String, String> urlVariables)\n\t\t\tthrows RestClientException {\n\n\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\tHttpHeaders headers =\n\t\t\t\texecute(url, HttpMethod.POST, new PostPutCallback(request), this.headersExtractor, urlVariables);\n\t\treturn headers.getLocation();\n\t}","id":89821,"modified_method":"public URI postForLocation(String url, Object request, Map<String, String> urlVariables)\n\t\t\tthrows RestClientException {\n\t\tif (request != null) {\n\t\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\t}\n\t\tHttpHeaders headers =\n\t\t\t\texecute(url, HttpMethod.POST, new PostPutCallback(request), this.headersExtractor, urlVariables);\n\t\treturn headers.getLocation();\n\t}","commit_id":"4c0edc2b9ddbc8c65cf2aab7cc05b71593b6daf4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void put(String url, Object request, String... urlVariables) throws RestClientException {\n\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\texecute(url, HttpMethod.PUT, new PostPutCallback(request), null, urlVariables);\n\t}","id":89822,"modified_method":"public void put(String url, Object request, String... urlVariables) throws RestClientException {\n\t\tif (request != null) {\n\t\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\t}\n\t\texecute(url, HttpMethod.PUT, new PostPutCallback(request), null, urlVariables);\n\t}","commit_id":"4c0edc2b9ddbc8c65cf2aab7cc05b71593b6daf4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void put(String url, Object request, Map<String, String> urlVariables) throws RestClientException {\n\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\texecute(url, HttpMethod.PUT, new PostPutCallback(request), null, urlVariables);\n\t}","id":89823,"modified_method":"public void put(String url, Object request, Map<String, String> urlVariables) throws RestClientException {\n\t\tif (request != null) {\n\t\t\tcheckForSupportedMessageConverter(request.getClass());\n\t\t}\n\t\texecute(url, HttpMethod.PUT, new PostPutCallback(request), null, urlVariables);\n\t}","commit_id":"4c0edc2b9ddbc8c65cf2aab7cc05b71593b6daf4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic void doWithRequest(ClientHttpRequest httpRequest) throws IOException {\n\t\t\tHttpMessageConverter entityConverter = getSupportedMessageConverters(this.request.getClass()).get(0);\n\t\t\tentityConverter.write(this.request, httpRequest);\n\t\t}","id":89824,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic void doWithRequest(ClientHttpRequest httpRequest) throws IOException {\n\t\t\tif (request != null) {\n\t\t\t\tHttpMessageConverter entityConverter = getSupportedMessageConverters(this.request.getClass()).get(0);\n\t\t\t\tentityConverter.write(this.request, httpRequest);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpRequest.getHeaders().setContentLength(0L);\n\t\t\t}\n\t\t}","commit_id":"4c0edc2b9ddbc8c65cf2aab7cc05b71593b6daf4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create a new instance of the {@link RestTemplate} using default settings.\n\t * @see #initDefaultStrategies()\n\t */\n\tpublic RestTemplate() {\n\t}","id":89825,"modified_method":"/**\n\t * Create a new instance of the {@link RestTemplate} using default settings.\n\t */\n\tpublic RestTemplate() {\n\t}","commit_id":"4c0edc2b9ddbc8c65cf2aab7cc05b71593b6daf4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private static boolean isSuperMethod(PsiClass aClass,\n                                       HierarchicalMethodSignature hierarchicalMethodSignature,\n                                       HierarchicalMethodSignature superSignatureHierarchical) {\n    PsiMethod superMethod = superSignatureHierarchical.getMethod();\n    PsiClass superClass = superMethod.getContainingClass();\n    PsiClass containingClass = hierarchicalMethodSignature.getMethod().getContainingClass();\n    return !superMethod.isConstructor()\n           && !aClass.equals(superClass)\n           && PsiUtil.isAccessible(superMethod, aClass, aClass)\n           && MethodSignatureUtil.isSubsignature(superSignatureHierarchical, hierarchicalMethodSignature)\n           && superClass != null\n           && (containingClass != null && containingClass.isInterface() == superClass.isInterface() || superClass.isInterface() || \"java.lang.Object\".equals(superClass.getQualifiedName()))\n      ;\n  }","id":89826,"modified_method":"private static boolean isSuperMethod(PsiClass aClass,\n                                       HierarchicalMethodSignature hierarchicalMethodSignature,\n                                       HierarchicalMethodSignature superSignatureHierarchical) {\n    PsiMethod superMethod = superSignatureHierarchical.getMethod();\n    PsiClass superClass = superMethod.getContainingClass();\n    PsiClass containingClass = hierarchicalMethodSignature.getMethod().getContainingClass();\n    if (!superMethod.isConstructor()) {\n      if (!aClass.equals(superClass)) {\n        if (PsiUtil.isAccessible(superMethod, aClass, aClass)) {\n          if (MethodSignatureUtil.isSubsignature(superSignatureHierarchical, hierarchicalMethodSignature)) {\n            if (superClass != null) {\n              if (superClass.isInterface() ||\n                  \"java.lang.Object\".equals(superClass.getQualifiedName())) {\n                return true;\n              }\n\n              if (containingClass != null) {\n                if (!containingClass.isInterface()) {\n                  return true;\n                }\n\n                if (!aClass.isInterface() && !InheritanceUtil.isInheritorOrSelf(superClass, containingClass, true)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"114127cf507a8f5e12e0e93476bf90ecd996ad90","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"rawtypes\")\n    @Test\n    public void testMapToInterface2() {\n        Map m = new HashMap<>();\n\n        TestInterface ti = converter.convert(m).to(TestInterface.class);\n        assertNull(ti.getFoo());\n        assertEquals(0, ti.getbar());\n    }","id":89827,"modified_method":"@SuppressWarnings(\"rawtypes\")\n    @Test\n    public void testMapToInterface2() {\n        Map m = new HashMap<>();\n\n        TestInterface ti = converter.convert(m).to(TestInterface.class);\n        assertNull(ti.getFoo());\n        assertEquals(0, ti.getBar());\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"int getbar();","id":89828,"modified_method":"int getBar();","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Test\n    public void testMapToInterface1() {\n        Map m = new HashMap<>();\n        m.put(\"foo\", 12345);\n        m.put(\"bar\", \"999\");\n        m.put(\"alt\", \"someval\");\n\n        TestInterface ti = converter.convert(m).to(TestInterface.class);\n        assertEquals(\"12345\", ti.getFoo());\n        assertEquals(999, ti.getbar());\n    }","id":89829,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Test\n    public void testMapToInterface1() {\n        Map m = new HashMap<>();\n        m.put(\"foo\", 12345);\n        m.put(\"bar\", \"999\");\n        m.put(\"alt\", \"someval\");\n\n        TestInterface ti = converter.convert(m).to(TestInterface.class);\n        assertEquals(\"12345\", ti.getFoo());\n        assertEquals(999, ti.getBar());\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testInterfaceToMap() {\n        Object obj = new Object();\n        TestInterface impl = new TestInterface() {\n            @Override\n            public String getFoo() {\n                return \"Chocolate!\";\n            }\n\n            @Override\n            public int getbar() {\n                return 76543;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public long getL() {\n                return 1L;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public boolean isSomething() {\n                return true;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public Object getBlah() {\n                return obj;\n            }\n\n            @SuppressWarnings(\"unused\")\n            private byte getByte() {\n                return (byte) 12;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public String getAlt(int arg) {\n                return \"some value\";\n            }\n        };\n\n        @SuppressWarnings(\"rawtypes\")\n        Map m = converter.convert(impl).to(Map.class);\n        assertEquals(5, m.size());\n        assertEquals(\"Chocolate!\", m.get(\"foo\"));\n        assertEquals(76543, (int) m.get(\"bar\"));\n        assertEquals(1L, (long) m.get(\"l\"));\n        assertTrue((boolean) m.get(\"something\"));\n        assertSame(obj, m.get(\"blah\"));\n    }","id":89830,"modified_method":"@Test\n    public void testInterfaceToMap() {\n        Object obj = new Object();\n        TestInterface impl = new TestInterface() {\n            @Override\n            public String getFoo() {\n                return \"Chocolate!\";\n            }\n\n            @Override\n            public int getBar() {\n                return 76543;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public long getL() {\n                return 1L;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public boolean isSomething() {\n                return true;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public Object getBlah() {\n                return obj;\n            }\n\n            @SuppressWarnings(\"unused\")\n            private byte getByte() {\n                return (byte) 12;\n            }\n\n            @SuppressWarnings(\"unused\")\n            public String getAlt(int arg) {\n                return \"some value\";\n            }\n        };\n\n        @SuppressWarnings(\"rawtypes\")\n        Map m = converter.convert(impl).to(Map.class);\n        assertEquals(5, m.size());\n        assertEquals(\"Chocolate!\", m.get(\"foo\"));\n        assertEquals(76543, (int) m.get(\"bar\"));\n        assertEquals(1L, (long) m.get(\"l\"));\n        assertTrue((boolean) m.get(\"something\"));\n        assertSame(obj, m.get(\"blah\"));\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"private boolean isMapType(Class<?> targetCls) {\n        // All interface types that are not Collections are treated as maps\n        if (targetCls.isInterface())\n            return true;\n        else\n            return Dictionary.class.isAssignableFrom(targetCls);\n    }","id":89831,"modified_method":"private boolean isMapType(Class<?> targetCls) {\n        // All interface types that are not Collections are treated as maps\n        if (targetCls.isInterface())\n            return true;\n        else if (isWriteableJavaBean(targetCls))\n            return true;\n        else\n            return Dictionary.class.isAssignableFrom(targetCls);\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    private static void handleMethod(Object obj, Method md, Set<String> invokedMethods, Map res) {\n        String mn = md.getName();\n        if (invokedMethods.contains(mn))\n            return; // method with this name already invoked\n\n        String propName = getAccessorPropertyName(md);\n\n        try {\n            res.put(propName.toString(), md.invoke(obj));\n            invokedMethods.add(mn);\n        } catch (Exception e) {\n        }\n    }","id":89832,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    private static void handleMethod(Object obj, Method md, Set<String> invokedMethods, Map res) {\n        String mn = md.getName();\n        if (invokedMethods.contains(mn))\n            return; // method with this name already invoked\n\n        String propName = getAccessorPropertyName(md);\n        if (propName == null)\n            return;\n\n        try {\n            res.put(propName.toString(), md.invoke(obj));\n            invokedMethods.add(mn);\n        } catch (Exception e) {\n        }\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"private static String getAccessorPropertyName(Method md) {\n        if (md.getReturnType().equals(Void.class))\n            return null; // not an accessor\n\n        if (md.getParameterTypes().length > 0)\n            return null; // not an accessor\n\n        if (Object.class.equals(md.getDeclaringClass()))\n            return null; // do not use any methods on the Object class as a accessor\n\n        String mn = md.getName();\n        int prefix;\n        if (mn.startsWith(\"get\"))\n            prefix = 3;\n        else if (mn.startsWith(\"is\"))\n            prefix = 2;\n        else\n            return null; // not an accessor prefix\n\n        if (mn.length() <= prefix)\n            return null; // just 'get' or 'is': not an accessor\n        String propStr = mn.substring(prefix);\n        StringBuilder propName = new StringBuilder(propStr.length());\n        propName.append(Character.toLowerCase(propStr.charAt(0)));\n        if (propStr.length() > 1)\n            propName.append(propStr.substring(1));\n\n        return propName.toString();\n    }","id":89833,"modified_method":"private static String getAccessorPropertyName(Method md) {\n        if (md.getReturnType().equals(Void.class))\n            return null; // not an accessor\n\n        if (md.getParameterTypes().length > 0)\n            return null; // not an accessor\n\n        if (Object.class.equals(md.getDeclaringClass()))\n            return null; // do not use any methods on the Object class as a accessor\n\n        String mn = md.getName();\n        int prefix;\n        if (mn.startsWith(\"get\"))\n            prefix = 3;\n        else if (mn.startsWith(\"is\"))\n            prefix = 2;\n        else\n            return null; // not an accessor prefix\n\n        if (mn.length() <= prefix)\n            return null; // just 'get' or 'is': not an accessor\n        String propStr = mn.substring(prefix);\n        StringBuilder propName = new StringBuilder(propStr.length());\n        char firstChar = propStr.charAt(0);\n        if (!Character.isUpperCase(firstChar))\n            return null; // no acccessor as no camel casing\n        propName.append(Character.toLowerCase(firstChar));\n        if (propStr.length() > 1)\n            propName.append(propStr.substring(1));\n\n        return propName.toString();\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private Object convertToMapType(Class<?> targetCls, Type[] typeArguments) {\n        if (Map.class.isAssignableFrom(targetCls))\n            return convertToMap(targetCls, typeArguments);\n        else if (Dictionary.class.isAssignableFrom(targetCls))\n            return new Hashtable(convertToMap(Map.class, typeArguments));\n        return createProxy(targetCls);\n    }","id":89834,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private Object convertToMapType(Class<?> targetCls, Type[] typeArguments) {\n        if (Map.class.isAssignableFrom(targetCls))\n            return convertToMap(targetCls, typeArguments);\n        else if (Dictionary.class.isAssignableFrom(targetCls))\n            return new Hashtable(convertToMap(Map.class, typeArguments));\n        else if (targetCls.isInterface())\n            return createProxy(targetCls);\n        return createJavaBean(targetCls);\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public Object to(Type type) {\n        Class<?> cls = null;\n        Type[] typeArguments = null;\n        if (type instanceof Class) {\n            cls = (Class<?>) type;\n        } else if (type instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) type;\n            Type rt = pt.getRawType();\n            typeArguments = pt.getActualTypeArguments();\n            if (rt instanceof Class)\n                cls = (Class<?>) rt;\n        }\n        if (cls == null)\n            return null;\n\n        Class<?> targetCls = cls;\n\n        if (object == null)\n            return handleNull(cls);\n\n        targetCls = primitiveToBoxed(targetCls);\n\n        if (!Map.class.isAssignableFrom(targetCls) &&\n                !Collections.class.isAssignableFrom(targetCls)) {\n            // For maps and collections we always want copies returned\n            if (targetCls.isAssignableFrom(object.getClass()))\n                return object;\n        }\n\n        Object res = trySpecialCases(targetCls);\n        if (res != null)\n            return res;\n\n        if (targetCls.isArray()) {\n            return convertToArray(targetCls);\n        } else if (Collection.class.isAssignableFrom(targetCls)) {\n            return convertToCollection(targetCls, typeArguments);\n        } else if (isMapType(targetCls)) {\n            return convertToMapType(targetCls, typeArguments);\n        }\n\n        // At this point we know that the target is a 'singular' type: not a map, collection or array\n        if (object instanceof Collection) {\n            return convertCollectionToSingleValue(cls);\n        } else if (object instanceof Object[]) {\n            return convertArrayToSingleValue(cls);\n        }\n\n        Object res2 = tryStandardMethods(targetCls);\n        if (res2 != null) {\n            return res2;\n        } else {\n            return null;\n        }\n    }","id":89835,"modified_method":"@Override\n    public Object to(Type type) {\n        Class<?> cls = null;\n        Type[] typeArguments = null;\n        if (type instanceof Class) {\n            cls = (Class<?>) type;\n        } else if (type instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) type;\n            Type rt = pt.getRawType();\n            typeArguments = pt.getActualTypeArguments();\n            if (rt instanceof Class)\n                cls = (Class<?>) rt;\n        }\n        if (cls == null)\n            return null;\n\n        if (object == null)\n            return handleNull(cls);\n\n        Class<?> targetCls = primitiveToBoxed(cls);\n\n        if (!Map.class.isAssignableFrom(targetCls) &&\n                !Collections.class.isAssignableFrom(targetCls)) {\n            // For maps and collections we always want copies returned\n            if (targetCls.isAssignableFrom(object.getClass()))\n                return object;\n        }\n\n        Object res = trySpecialCases(targetCls);\n        if (res != null)\n            return res;\n\n        if (targetCls.isArray()) {\n            return convertToArray(targetCls);\n        } else if (Collection.class.isAssignableFrom(targetCls)) {\n            return convertToCollection(targetCls, typeArguments);\n        } else if (isMapType(targetCls)) {\n            return convertToMapType(targetCls, typeArguments);\n        }\n\n        // At this point we know that the target is a 'singular' type: not a map, collection or array\n        if (object instanceof Collection) {\n            return convertCollectionToSingleValue(cls);\n        } else if (object instanceof Object[]) {\n            return convertArrayToSingleValue(cls);\n        }\n\n        Object res2 = tryStandardMethods(targetCls);\n        if (res2 != null) {\n            return res2;\n        } else {\n            return null;\n        }\n    }","commit_id":"0274b940bb0c9801531b66d18ce8b92295dad389","url":"https://github.com/apache/felix"},{"original_method":"public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {\n\t\treturn !metadata.isInterface() && // not an interface or an annotation\n\t\t\t\t(metadata.isAnnotated(Component.class.getName()) ||\n\t\t\t\tmetadata.hasAnnotatedMethods(Bean.class.getName()));\n\t}","id":89836,"modified_method":"public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) {\n\t\tif(metadata.isInterface()) {\n\t\t\treturn false; // do not consider an interface or an annotation\n\t\t}\n\t\treturn metadata.isAnnotated(Import.class.getName()) ||\n\t\t\t\tmetadata.isAnnotated(Component.class.getName()) ||\n\t\t\t\tmetadata.hasAnnotatedMethods(Bean.class.getName());\n\t}","commit_id":"71f6da673abec4c805eb8232a2c8e07837b7f0a7","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean isAssignable(ClassNode node, ClassNode testNode) {\n        if (testNode.isInterface()) {\n            if (node.implementsInterface(testNode)) return true;\n        } else {\n            if (node.isDerivedFrom(testNode)) return true;\n        }\n        return false;\n    }","id":89837,"modified_method":"private boolean isAssignable(ClassNode node, ClassNode testNode) {\n        if (testNode.isInterface()) {\n        \tif(node.isInterface()) {\n        \t\tif (node.isDerivedFrom(testNode)) return true;\n        \t} else {\n        \t\tif (node.implementsInterface(testNode)) return true;\n        \t}\n        } else {\n            if (node.isDerivedFrom(testNode)) return true;\n        }\n        return false;\n    }","commit_id":"cac249ea52aefad322dad086aa8705bd054785b0","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Get the access token\n     */\n    protected AccessTokenValidation getAccessTokenValidation() {\n        AccessTokenValidation accessTokenV = null;\n        if (dataProvider == null && tokenHandlers.isEmpty()) {\n            throw new InternalServerErrorException();\n        }\n        \n        // Get the scheme and its data, Bearer only is supported by default\n        // WWW-Authenticate with the list of supported schemes will be sent back \n        // if the scheme is not accepted\n        String[] authParts = AuthorizationUtils.getAuthorizationParts(mc, supportedSchemes);\n        String authScheme = authParts[0];\n        String authSchemeData = authParts[1];\n        \n        // Get the registered handler capable of processing the token\n        AccessTokenValidator handler = findTokenValidator(authScheme);\n        if (handler != null) {\n            try {\n                // Convert the HTTP Authorization scheme data into a token\n                accessTokenV = handler.validateAccessToken(mc, authScheme, authSchemeData);\n            } catch (OAuthServiceException ex) {\n                AuthorizationUtils.throwAuthorizationFailure(\n                    Collections.singleton(authScheme), realm);\n            }\n        }\n        // Default processing if no registered providers available\n        ServerAccessToken localAccessToken = null;\n        if (accessTokenV == null && dataProvider != null && authScheme.equals(DEFAULT_AUTH_SCHEME)) {\n            try {\n                localAccessToken = dataProvider.getAccessToken(authSchemeData);\n            } catch (OAuthServiceException ex) {\n                // to be handled next\n            }\n            if (localAccessToken == null) {\n                AuthorizationUtils.throwAuthorizationFailure(\n                    Collections.singleton(authScheme), realm);\n            }\n            accessTokenV = new AccessTokenValidation(localAccessToken);\n        }\n        if (accessTokenV == null) {\n            AuthorizationUtils.throwAuthorizationFailure(supportedSchemes, realm);\n        }\n        // Check if token is still valid\n        if (OAuthUtils.isExpired(accessTokenV.getTokenIssuedAt(), accessTokenV.getTokenLifetime())) {\n            if (localAccessToken != null) {\n                dataProvider.removeAccessToken(localAccessToken);\n            }\n            AuthorizationUtils.throwAuthorizationFailure(supportedSchemes, realm);\n        }\n        \n        // Check audiences\n        if (!validateAudience(accessTokenV.getAudience())) {\n            AuthorizationUtils.throwAuthorizationFailure(supportedSchemes, realm);\n        }\n        \n        return accessTokenV;\n    }","id":89838,"modified_method":"/**\n     * Get the access token\n     */\n    protected AccessTokenValidation getAccessTokenValidation() {\n        AccessTokenValidation accessTokenV = null;\n        if (dataProvider == null && tokenHandlers.isEmpty()) {\n            throw new InternalServerErrorException();\n        }\n        \n        // Get the scheme and its data, Bearer only is supported by default\n        // WWW-Authenticate with the list of supported schemes will be sent back \n        // if the scheme is not accepted\n        String[] authParts = getAuthorizationParts();\n        String authScheme = authParts[0];\n        String authSchemeData = authParts[1];\n        \n        // Get the registered handler capable of processing the token\n        AccessTokenValidator handler = findTokenValidator(authScheme);\n        if (handler != null) {\n            try {\n                // Convert the HTTP Authorization scheme data into a token\n                accessTokenV = handler.validateAccessToken(getMessageContext(), authScheme, authSchemeData);\n            } catch (OAuthServiceException ex) {\n                AuthorizationUtils.throwAuthorizationFailure(\n                    Collections.singleton(authScheme), realm);\n            }\n        }\n        // Default processing if no registered providers available\n        ServerAccessToken localAccessToken = null;\n        if (accessTokenV == null && dataProvider != null && authScheme.equals(DEFAULT_AUTH_SCHEME)) {\n            try {\n                localAccessToken = dataProvider.getAccessToken(authSchemeData);\n            } catch (OAuthServiceException ex) {\n                // to be handled next\n            }\n            if (localAccessToken == null) {\n                AuthorizationUtils.throwAuthorizationFailure(\n                    Collections.singleton(authScheme), realm);\n            }\n            accessTokenV = new AccessTokenValidation(localAccessToken);\n        }\n        if (accessTokenV == null) {\n            AuthorizationUtils.throwAuthorizationFailure(supportedSchemes, realm);\n        }\n        // Check if token is still valid\n        if (OAuthUtils.isExpired(accessTokenV.getTokenIssuedAt(), accessTokenV.getTokenLifetime())) {\n            if (localAccessToken != null) {\n                dataProvider.removeAccessToken(localAccessToken);\n            }\n            AuthorizationUtils.throwAuthorizationFailure(supportedSchemes, realm);\n        }\n        \n        // Check audiences\n        if (!validateAudience(accessTokenV.getAudience())) {\n            AuthorizationUtils.throwAuthorizationFailure(supportedSchemes, realm);\n        }\n        \n        return accessTokenV;\n    }","commit_id":"2cf133d0cb05680ee3b21e3d6905faca8e2189a5","url":"https://github.com/apache/cxf"},{"original_method":"public MessageContext getMessageContext() {\n        return mc;\n    }","id":89839,"modified_method":"public MessageContext getMessageContext() {\n        return mc != null ? mc : new MessageContextImpl(PhaseInterceptorChain.getCurrentMessage());\n    }","commit_id":"2cf133d0cb05680ee3b21e3d6905faca8e2189a5","url":"https://github.com/apache/cxf"},{"original_method":"public void filter(ContainerRequestContext context) {\n        Message m = JAXRSUtils.getCurrentMessage();\n        if (isCorsRequest(m)) {\n            return;\n        }\n        \n        // Get the access token\n        AccessTokenValidation accessTokenV = getAccessTokenValidation(); \n        \n        // Find the scopes which match the current request\n        \n        List<OAuthPermission> permissions = accessTokenV.getTokenScopes();\n        List<OAuthPermission> matchingPermissions = new ArrayList<OAuthPermission>();\n        \n        HttpServletRequest req = getMessageContext().getHttpServletRequest();\n        for (OAuthPermission perm : permissions) {\n            boolean uriOK = checkRequestURI(req, perm.getUris());\n            boolean verbOK = checkHttpVerb(req, perm.getHttpVerbs());\n            if (uriOK && verbOK) {\n                matchingPermissions.add(perm);\n            }\n        }\n        \n        if (permissions.size() > 0 && matchingPermissions.isEmpty()) {\n            String message = \"Client has no valid permissions\";\n            LOG.warning(message);\n            throw new WebApplicationException(403);\n        }\n      \n        // Create the security context and make it available on the message\n        SecurityContext sc = createSecurityContext(req, accessTokenV);\n        m.put(SecurityContext.class, sc);\n        \n        // Also set the OAuthContext\n        OAuthContext oauthContext = new OAuthContext(accessTokenV.getTokenSubject(),\n                                                     accessTokenV.getClientSubject(),\n                                                     matchingPermissions,\n                                                     accessTokenV.getTokenGrantType());\n        \n        oauthContext.setClientId(accessTokenV.getClientId());\n        oauthContext.setTokenKey(accessTokenV.getTokenKey());\n        oauthContext.setTokenAudience(accessTokenV.getAudience());\n        \n        m.setContent(OAuthContext.class, oauthContext);\n    }","id":89840,"modified_method":"public void filter(ContainerRequestContext context) {\n        validateRequest(JAXRSUtils.getCurrentMessage());\n    }","commit_id":"2cf133d0cb05680ee3b21e3d6905faca8e2189a5","url":"https://github.com/apache/cxf"},{"original_method":"protected JweDecryptor getInitializedDecryptor() {\n        if (decryptor != null) {\n            return decryptor;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        if (m == null) {\n            throw new SecurityException();\n        }\n        String propLoc = (String)m.getContextualProperty(RSSEC_ENCRYPTION_IN_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        try {\n            Bus bus = m.getExchange().getBus();\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            PrivateKey pk = null;\n            KeyStore keyStore = (KeyStore)m.getExchange().get(props.get(CryptoUtils.RSSEC_KEY_STORE_FILE));\n            if (keyStore == null) {\n                keyStore = CryptoUtils.loadKeyStore(props, bus);\n                m.getExchange().put((String)props.get(CryptoUtils.RSSEC_KEY_STORE_FILE), keyStore);\n            }\n            PrivateKeyPasswordProvider cb = \n                (PrivateKeyPasswordProvider)m.getContextualProperty(CryptoUtils.RSSEC_KEY_PSWD_PROVIDER);\n            pk = CryptoUtils.loadPrivateKey(keyStore, props, bus, cb);\n            \n            return new WrappedKeyJweDecryptor(pk, cryptoProperties);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":89841,"modified_method":"protected JweDecryptor getInitializedDecryptor() {\n        if (decryptor != null) {\n            return decryptor;    \n        } \n        try {\n            PrivateKey pk = CryptoUtils.loadPrivateKey(JAXRSUtils.getCurrentMessage(), \n                                                       RSSEC_ENCRYPTION_IN_PROPS, \n                                                       CryptoUtils.RSSEC_DECRYPT_KEY_PSWD_PROVIDER);\n            return new WrappedKeyJweDecryptor(pk, cryptoProperties);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"protected JwsSignatureVerifier getInitializedSigVerifier() {\n        if (sigVerifier != null) {\n            return sigVerifier;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        if (m == null) {\n            throw new SecurityException();\n        }\n        String propLoc = (String)m.getContextualProperty(RSSEC_SIGNATURE_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            PublicKey pk = null;\n            KeyStore keyStore = (KeyStore)m.getExchange().get(props.get(CryptoUtils.RSSEC_KEY_STORE_FILE));\n            if (keyStore == null) {\n                keyStore = CryptoUtils.loadKeyStore(props, bus);\n                m.getExchange().put((String)props.get(CryptoUtils.RSSEC_KEY_STORE_FILE), keyStore);\n            }\n            pk = CryptoUtils.loadPublicKey(keyStore, props);\n            return new PublicKeyJwsSignatureVerifier(pk);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":89842,"modified_method":"protected JwsSignatureVerifier getInitializedSigVerifier() {\n        if (sigVerifier != null) {\n            return sigVerifier;    \n        } \n        try {\n            PublicKey pk = CryptoUtils.loadPublicKey(JAXRSUtils.getCurrentMessage(), \n                                                     RSSEC_SIGNATURE_PROPS);\n            return new PublicKeyJwsSignatureVerifier(pk);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"protected JwsSignatureProvider getInitializedSigProvider() {\n        if (sigProvider != null) {\n            return sigProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        if (m == null) {\n            throw new SecurityException();\n        }\n        String propLoc = (String)m.getContextualProperty(RSSEC_SIGNATURE_OUT_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        try {\n            Bus bus = m.getExchange().getBus();\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            PrivateKey pk = null;\n            KeyStore keyStore = (KeyStore)m.getExchange().get(props.get(CryptoUtils.RSSEC_KEY_STORE_FILE));\n            if (keyStore == null) {\n                keyStore = CryptoUtils.loadKeyStore(props, bus);\n                m.getExchange().put((String)props.get(CryptoUtils.RSSEC_KEY_STORE_FILE), keyStore);\n            }\n            PrivateKeyPasswordProvider cb = \n                (PrivateKeyPasswordProvider)m.getContextualProperty(CryptoUtils.RSSEC_KEY_PSWD_PROVIDER);\n            pk = CryptoUtils.loadPrivateKey(keyStore, props, bus, cb);\n            PrivateKeyJwsSignatureProvider provider = new PrivateKeyJwsSignatureProvider(pk);\n            provider.setDefaultJwtAlgorithm(props.getProperty(JSON_WEB_SIGNATURE_ALGO_PROP));\n            return provider;\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":89843,"modified_method":"protected JwsSignatureProvider getInitializedSigProvider() {\n        if (sigProvider != null) {\n            return sigProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = (String)m.getContextualProperty(RSSEC_SIGNATURE_OUT_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        try {\n            Properties props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n            PrivateKey pk = CryptoUtils.loadPrivateKey(m, props, CryptoUtils.RSSEC_SIG_KEY_PSWD_PROVIDER);\n            PrivateKeyJwsSignatureProvider provider = new PrivateKeyJwsSignatureProvider(pk);\n            provider.setDefaultJwtAlgorithm(props.getProperty(JSON_WEB_SIGNATURE_ALGO_PROP));\n            return provider;\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static PrivateKey loadPrivateKey(Properties props, Bus bus, PrivateKeyPasswordProvider provider) {\n        try {\n            KeyStore keyStore = loadKeyStore(props, bus);\n            return loadPrivateKey(keyStore, props, bus, provider);\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }    \n    }","id":89844,"modified_method":"public static PrivateKey loadPrivateKey(Properties props, Bus bus, PrivateKeyPasswordProvider provider) {\n        KeyStore keyStore = loadKeyStore(props, bus);\n        return loadPrivateKey(keyStore, props, bus, provider);\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static KeyStore loadKeyStore(Properties props, Bus bus) throws Exception {\n        String keyStoreType = props.getProperty(RSSEC_KEY_STORE_TYPE);\n        String keyStoreLoc = props.getProperty(RSSEC_KEY_STORE_FILE);\n        String keyStorePswd = props.getProperty(RSSEC_KEY_STORE_PSWD);\n        InputStream is = ResourceUtils.getResourceStream(keyStoreLoc, bus);\n        return loadKeyStore(is, keyStorePswd.toCharArray(), keyStoreType);\n    }","id":89845,"modified_method":"public static KeyStore loadKeyStore(Properties props, Bus bus) {\n        String keyStoreType = props.getProperty(RSSEC_KEY_STORE_TYPE);\n        String keyStoreLoc = props.getProperty(RSSEC_KEY_STORE_FILE);\n        String keyStorePswd = props.getProperty(RSSEC_KEY_STORE_PSWD);\n        try {\n            InputStream is = ResourceUtils.getResourceStream(keyStoreLoc, bus);\n            return loadKeyStore(is, keyStorePswd.toCharArray(), keyStoreType);\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static PublicKey loadPublicKey(InputStream storeLocation, char[] storePassword, String alias,\n                                          String storeType) {\n        try {\n            return loadCertificate(storeLocation, storePassword, alias, storeType).getPublicKey();\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }\n    }","id":89846,"modified_method":"public static PublicKey loadPublicKey(InputStream storeLocation, char[] storePassword, String alias,\n                                          String storeType) {\n        return loadCertificate(storeLocation, storePassword, alias, storeType).getPublicKey();\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static KeyStore loadKeyStore(InputStream storeLocation, char[] storePassword, String type) \n        throws Exception {\n        KeyStore ks = KeyStore.getInstance(type == null ? KeyStore.getDefaultType() : type);\n        ks.load(storeLocation, storePassword);\n        return ks;\n    }","id":89847,"modified_method":"public static KeyStore loadKeyStore(InputStream storeLocation, char[] storePassword, String type) {\n        try {\n            KeyStore ks = KeyStore.getInstance(type == null ? KeyStore.getDefaultType() : type);\n            ks.load(storeLocation, storePassword);\n            return ks;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static PrivateKey loadPrivateKey(KeyStore keyStore, \n                                            Properties props, \n                                            Bus bus, \n                                            PrivateKeyPasswordProvider provider) {\n        try {\n            String keyPswd = props.getProperty(RSSEC_KEY_PSWD);\n            String alias = props.getProperty(RSSEC_KEY_STORE_ALIAS);\n            char[] keyPswdChars = provider != null ? provider.getPassword(props) \n                : keyPswd != null ? keyPswd.toCharArray() : null;    \n            return loadPrivateKey(keyStore, keyPswdChars, alias);\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }    \n    }","id":89848,"modified_method":"public static PrivateKey loadPrivateKey(KeyStore keyStore, \n                                            Properties props, \n                                            Bus bus, \n                                            PrivateKeyPasswordProvider provider) {\n        \n        String keyPswd = props.getProperty(RSSEC_KEY_PSWD);\n        String alias = props.getProperty(RSSEC_KEY_STORE_ALIAS);\n        char[] keyPswdChars = provider != null ? provider.getPassword(props) \n            : keyPswd != null ? keyPswd.toCharArray() : null;    \n        return loadPrivateKey(keyStore, keyPswdChars, alias);\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static PublicKey loadPublicKey(KeyStore keyStore, Properties props) {\n        try {\n            return loadCertificate(keyStore, props).getPublicKey();\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }\n    }","id":89849,"modified_method":"public static PublicKey loadPublicKey(Message m, Properties props) {\n        KeyStore keyStore = CryptoUtils.loadPersistKeyStore(m, props);\n        return CryptoUtils.loadPublicKey(keyStore, props.getProperty(RSSEC_KEY_STORE_ALIAS));\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static Certificate loadCertificate(InputStream storeLocation, char[] storePassword, String alias,\n                                              String storeType) {\n        try {\n            KeyStore keyStore = loadKeyStore(storeLocation, storePassword, storeType);\n            return loadCertificate(keyStore, alias);\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }\n    }","id":89850,"modified_method":"public static Certificate loadCertificate(InputStream storeLocation, char[] storePassword, String alias,\n                                              String storeType) {\n        KeyStore keyStore = loadKeyStore(storeLocation, storePassword, storeType);\n        return loadCertificate(keyStore, alias);\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static PublicKey loadPublicKey(KeyStore keyStore, String alias) {\n        try {\n            return loadCertificate(keyStore, alias).getPublicKey();\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }\n    }","id":89851,"modified_method":"public static PublicKey loadPublicKey(KeyStore keyStore, String alias) {\n        return loadCertificate(keyStore, alias).getPublicKey();\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static PrivateKey loadPrivateKey(InputStream storeLocation, \n                                            char[] storePassword, \n                                            char[] keyPassword, \n                                            String alias,\n                                            String storeType) {\n        try {\n            KeyStore keyStore = loadKeyStore(storeLocation, storePassword, storeType);\n            KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)\n                keyStore.getEntry(alias, new KeyStore.PasswordProtection(keyPassword));\n            return pkEntry.getPrivateKey();\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }\n    }","id":89852,"modified_method":"public static PrivateKey loadPrivateKey(InputStream storeLocation, \n                                            char[] storePassword, \n                                            char[] keyPassword, \n                                            String alias,\n                                            String storeType) {\n        KeyStore keyStore = loadKeyStore(storeLocation, storePassword, storeType);\n        return loadPrivateKey(keyStore, keyPassword, alias);\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public static Certificate loadCertificate(KeyStore keyStore, Properties props) {\n        try {\n            return loadCertificate(keyStore, props.getProperty(RSSEC_KEY_STORE_ALIAS));\n        } catch (Exception ex) { \n            throw new SecurityException(ex);\n        }\n    }","id":89853,"modified_method":"public static KeyStore loadPersistKeyStore(Message m, Properties props) {\n        KeyStore keyStore = (KeyStore)m.getExchange().get(props.get(CryptoUtils.RSSEC_KEY_STORE_FILE));\n        if (keyStore == null) {\n            keyStore = CryptoUtils.loadKeyStore(props, m.getExchange().getBus());\n            m.getExchange().put((String)props.get(CryptoUtils.RSSEC_KEY_STORE_FILE), keyStore);\n        }\n        return keyStore;\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testJweJwsRsa() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/jwejws\";\n        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = JAXRSJweJwsTest.class.getResource(\"client.xml\");\n        Bus springBus = bf.createBus(busFile.toString());\n        bean.setBus(springBus);\n        bean.setServiceClass(BookStore.class);\n        bean.setAddress(address);\n        List<Object> providers = new LinkedList<Object>();\n        providers.add(new JweWriterInterceptor());\n        providers.add(new JweClientResponseFilter());\n        providers.add(new JwsWriterInterceptor());\n        providers.add(new JwsClientResponseFilter());\n        bean.setProviders(providers);\n        bean.getProperties(true).put(\"rs.security.encryption.out.properties\", SERVER_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.signature.out.properties\", CLIENT_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.encryption.in.properties\", CLIENT_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.signature.in.properties\", SERVER_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.crypto.key.password.provider\", \n                                     new PrivateKeyPasswordProviderImpl());\n        BookStore bs = bean.create(BookStore.class);\n        String text = bs.echoText(\"book\");\n        assertEquals(\"book\", text);\n    }","id":89854,"modified_method":"@Test\n    public void testJweJwsRsa() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/jwejws\";\n        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();\n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = JAXRSJweJwsTest.class.getResource(\"client.xml\");\n        Bus springBus = bf.createBus(busFile.toString());\n        bean.setBus(springBus);\n        bean.setServiceClass(BookStore.class);\n        bean.setAddress(address);\n        List<Object> providers = new LinkedList<Object>();\n        providers.add(new JweWriterInterceptor());\n        providers.add(new JweClientResponseFilter());\n        providers.add(new JwsWriterInterceptor());\n        providers.add(new JwsClientResponseFilter());\n        bean.setProviders(providers);\n        bean.getProperties(true).put(\"rs.security.encryption.out.properties\", SERVER_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.signature.out.properties\", CLIENT_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.encryption.in.properties\", CLIENT_JWEJWS_PROPERTIES);\n        bean.getProperties(true).put(\"rs.security.signature.in.properties\", SERVER_JWEJWS_PROPERTIES);\n        PrivateKeyPasswordProvider provider = new PrivateKeyPasswordProviderImpl();\n        bean.getProperties(true).put(\"rs.security.signature.key.password.provider\", provider);\n        bean.getProperties(true).put(\"rs.security.decryption.key.password.provider\", provider);\n        BookStore bs = bean.create(BookStore.class);\n        String text = bs.echoText(\"book\");\n        assertEquals(\"book\", text);\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"protected JweEncryptor getInitializedEncryptor() {\n        if (encryptor != null) {\n            return encryptor;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        if (m == null) {\n            throw new SecurityException();\n        }\n        String propLoc = (String)m.getContextualProperty(JSON_WEB_ENCRYPTION_OUT_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            PublicKey pk = null;\n            KeyStore keyStore = (KeyStore)m.getExchange().get(props.get(CryptoUtils.RSSEC_KEY_STORE_FILE));\n            if (keyStore == null) {\n                keyStore = CryptoUtils.loadKeyStore(props, bus);\n                m.getExchange().put((String)props.get(CryptoUtils.RSSEC_KEY_STORE_FILE), keyStore);\n            }\n            pk = CryptoUtils.loadPublicKey(keyStore, props);\n            return new WrappedKeyJweEncryptor(new JweHeaders(Algorithm.RSA_OAEP.getJwtName(),\n                                                             props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP)), \n                                              pk);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":89855,"modified_method":"protected JweEncryptor getInitializedEncryptor() {\n        if (encryptor != null) {\n            return encryptor;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = (String)m.getContextualProperty(JSON_WEB_ENCRYPTION_OUT_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            PublicKey pk = CryptoUtils.loadPublicKey(m, props);\n            JweHeaders headers = new JweHeaders(Algorithm.RSA_OAEP.getJwtName(),\n                                                props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP));\n            String compression = props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP);\n            if (compression != null) {\n                headers.setZipAlgorithm(compression);\n            }\n            \n            return new WrappedKeyJweEncryptor(headers, pk);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"335148d95dc0263ae191960554330d09a8baa982","url":"https://github.com/apache/cxf"},{"original_method":"public String outboundFilter(String s, StringBuffer expectedPong) {\n        \n        String field[]=s.split(\" \",3);\n        String command;\n        final String[] allowedCommands =\n        {\n                \"NOTICE\",\n                \"MODE\",\n                \"JOIN\",\n                \"NICK\",\n                \"WHO\",\n                \"WHOIS\",\n                \"LIST\",\n                \"NAMES\",\n                \"NICK\",\n                // \"QUIT\", // replace with a filtered QUIT to hide client quit messages\n                \"SILENCE\",\n                \"MAP\", // seems safe enough, the ircd should protect themselves though\n                \"PART\",\n                \"OPER\",\n                // \"PONG\", // replaced with a filtered PING/PONG since some clients send the server IP (thanks aardvax!) \n                // \"PING\", \n                \"KICK\",\n                \"HELPME\",\n                \"RULES\",\n                \"TOPIC\"\n        };\n\n        if(field[0].length()==0)\n\t    return null; // W T F?\n\t\n        \n        if(field[0].charAt(0)==':')\n            return null; // wtf\n        \n        command = field[0].toUpperCase();\n\n\tif (\"PING\".equals(command)) {\n            // Most clients just send a PING and are happy with any old PONG.  Others,\n            // like BitchX, actually expect certain behavior.  It sends two different pings:\n            // \"PING :irc.freshcoffee.i2p\" and \"PING 1234567890 127.0.0.1\" (where the IP is the proxy)\n            // the PONG to the former seems to be \"PONG 127.0.0.1\", while the PONG to the later is\n            // \":irc.freshcoffee.i2p PONG irc.freshcoffe.i2p :1234567890\".\n            // We don't want to send them our proxy's IP address, so we need to rewrite the PING\n            // sent to the server, but when we get a PONG back, use what we expected, rather than\n            // what they sent.\n            //\n            // Yuck.\n\n            String rv = null;\n            expectedPong.setLength(0);\n            if (field.length == 1) { // PING\n                rv = \"PING\";\n                expectedPong.append(\"PONG 127.0.0.1\");\n            } else if (field.length == 2) { // PING nonce\n                rv = \"PING \" + field[1];\n                expectedPong.append(\"PONG \").append(field[1]);\n            } else if (field.length == 3) { // PING nonce serverLocation\n                rv = \"PING \" + field[1];\n                expectedPong.append(\"PONG \").append(field[1]);\n            } else {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"IRC client sent a PING we don't understand, filtering it (\\\"\" + s + \"\\\")\");\n                rv = null;\n            }\n            \n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"sending ping \" + rv + \", waiting for \" + expectedPong + \" orig was [\" + s  + \"]\");\n            \n            return rv;\n        }\n\tif (\"PONG\".equals(command))\n            return \"PONG 127.0.0.1\"; // no way to know what the ircd to i2ptunnel server con is, so localhost works\n\n        // Allow all allowedCommands\n        for(int i=0;i<allowedCommands.length;i++)\n        {\n            if(allowedCommands[i].equals(command))\n                return s;\n        }\n        \n        // Allow PRIVMSG, but block CTCP (except ACTION).\n        if(\"PRIVMSG\".equals(command))\n        {\n            String msg;\n            msg = field[2];\n        \n            byte[] bytes = msg.getBytes();\n            if(bytes[1]==0x01)\n            {\n                    // CTCP\n                msg=msg.substring(2);\n                if(msg.startsWith(\"ACTION \")) {\n                    // /me says hello\n                    return s;\n                }\n                return null; // Block all other ctcp\n            }\n            return s;\n        }\n        \n        if(\"USER\".equals(command)) {\n            int idx = field[2].lastIndexOf(\":\");\n            if(idx<0)\n                return \"USER user hostname localhost :realname\";\n            String realname = field[2].substring(idx+1);\n            String ret = \"USER \"+field[1]+\" hostname localhost :\"+realname;\n            return ret;\n        } else if (\"QUIT\".equals(command)) {\n            return \"QUIT :leaving\";\n        }\n        \n        // Block the rest\n        return null;\n    }","id":89856,"modified_method":"public String outboundFilter(String s, StringBuffer expectedPong) {\n        \n        String field[]=s.split(\" \",3);\n        String command;\n        final String[] allowedCommands =\n        {\n                // \"NOTICE\", // can contain CTCP\n                \"MODE\",\n                \"JOIN\",\n                \"NICK\",\n                \"WHO\",\n                \"WHOIS\",\n                \"LIST\",\n                \"NAMES\",\n                \"NICK\",\n                // \"QUIT\", // replace with a filtered QUIT to hide client quit messages\n                \"SILENCE\",\n                \"MAP\", // seems safe enough, the ircd should protect themselves though\n                \"PART\",\n                \"OPER\",\n                // \"PONG\", // replaced with a filtered PING/PONG since some clients send the server IP (thanks aardvax!) \n                // \"PING\", \n                \"KICK\",\n                \"HELPME\",\n                \"RULES\",\n                \"TOPIC\"\n        };\n\n        if(field[0].length()==0)\n\t    return null; // W T F?\n\t\n        \n        if(field[0].charAt(0)==':')\n            return null; // wtf\n        \n        command = field[0].toUpperCase();\n\n\tif (\"PING\".equalsIgnoreCase(command)) {\n            // Most clients just send a PING and are happy with any old PONG.  Others,\n            // like BitchX, actually expect certain behavior.  It sends two different pings:\n            // \"PING :irc.freshcoffee.i2p\" and \"PING 1234567890 127.0.0.1\" (where the IP is the proxy)\n            // the PONG to the former seems to be \"PONG 127.0.0.1\", while the PONG to the later is\n            // \":irc.freshcoffee.i2p PONG irc.freshcoffe.i2p :1234567890\".\n            // We don't want to send them our proxy's IP address, so we need to rewrite the PING\n            // sent to the server, but when we get a PONG back, use what we expected, rather than\n            // what they sent.\n            //\n            // Yuck.\n\n            String rv = null;\n            expectedPong.setLength(0);\n            if (field.length == 1) { // PING\n                rv = \"PING\";\n                expectedPong.append(\"PONG 127.0.0.1\");\n            } else if (field.length == 2) { // PING nonce\n                rv = \"PING \" + field[1];\n                expectedPong.append(\"PONG \").append(field[1]);\n            } else if (field.length == 3) { // PING nonce serverLocation\n                rv = \"PING \" + field[1];\n                expectedPong.append(\"PONG \").append(field[1]);\n            } else {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"IRC client sent a PING we don't understand, filtering it (\\\"\" + s + \"\\\")\");\n                rv = null;\n            }\n            \n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"sending ping \" + rv + \", waiting for \" + expectedPong + \" orig was [\" + s  + \"]\");\n            \n            return rv;\n        }\n\tif (\"PONG\".equalsIgnoreCase(command))\n            return \"PONG 127.0.0.1\"; // no way to know what the ircd to i2ptunnel server con is, so localhost works\n\n        // Allow all allowedCommands\n        for(int i=0;i<allowedCommands.length;i++)\n        {\n            if(allowedCommands[i].equalsIgnoreCase(command))\n                return s;\n        }\n        \n        // Allow PRIVMSG, but block CTCP (except ACTION).\n        if(\"PRIVMSG\".equalsIgnoreCase(command) || \"NOTICE\".equalsIgnoreCase(command))\n        {\n            String msg;\n            msg = field[2];\n        \n            if(msg.indexOf(0x01) >= 0) // CTCP marker ^A can be anywhere, not just immediately after the ':'\n            {\n                    // CTCP\n                msg=msg.substring(2);\n                if(msg.startsWith(\"ACTION \")) {\n                    // /me says hello\n                    return s;\n                }\n                return null; // Block all other ctcp\n            }\n            return s;\n        }\n        \n        if(\"USER\".equalsIgnoreCase(command)) {\n            int idx = field[2].lastIndexOf(\":\");\n            if(idx<0)\n                return \"USER user hostname localhost :realname\";\n            String realname = field[2].substring(idx+1);\n            String ret = \"USER \"+field[1]+\" hostname localhost :\"+realname;\n            return ret;\n        } else if (\"QUIT\".equalsIgnoreCase(command)) {\n            return \"QUIT :leaving\";\n        }\n        \n        // Block the rest\n        return null;\n    }","commit_id":"819a72d4f6b9cd1068db3be3758e6855c49f16db","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/*************************************************************************\n     *\n     */\n    \n    public String inboundFilter(String s, StringBuffer expectedPong) {\n        \n        String field[]=s.split(\" \",4);\n        String command;\n        int idx=0;\n        final String[] allowedCommands =\n        {\n                \"NOTICE\",\n                //\"PING\",\n                //\"PONG\",\n                \"MODE\",\n                \"JOIN\",\n                \"NICK\",\n                \"QUIT\",\n                \"PART\",\n                \"WALLOPS\",\n                \"ERROR\",\n                \"KICK\",\n                \"H\", // \"hide operator status\" (after kicking an op)\n                \"TOPIC\"\n        };\n        \n        if(field[0].charAt(0)==':')\n            idx++;\n\n        try { command = field[idx++]; }\n         catch (IndexOutOfBoundsException ioobe) // wtf, server sent borked command?\n        {\n           _log.warn(\"Dropping defective message: index out of bounds while extracting command.\");\n           return null;\n        }\n\n        idx++; //skip victim\n\n        // Allow numerical responses\n        try {\n            new Integer(command);\n            return s;\n        } catch(NumberFormatException nfe){}\n\n        \n\tif (\"PING\".equals(command))\n            return \"PING 127.0.0.1\"; // no way to know what the ircd to i2ptunnel server con is, so localhost works\n\tif (\"PONG\".equals(command)) {\n            // Turn the received \":irc.freshcoffee.i2p PONG irc.freshcoffee.i2p :127.0.0.1\"\n            // into \":127.0.0.1 PONG 127.0.0.1 \" so that the caller can append the client's extra parameter\n            // though, does 127.0.0.1 work for irc clients connecting remotely?  and for all of them?  sure would\n            // be great if irc clients actually followed the RFCs here, but i guess thats too much to ask.\n            // If we haven't PINGed them, or the PING we sent isn't something we know how to filter, this \n            // is blank.\n            String pong = expectedPong.length() > 0 ? expectedPong.toString() : null;\n            expectedPong.setLength(0);\n            return pong;\n        }\n        \n        // Allow all allowedCommands\n        for(int i=0;i<allowedCommands.length;i++) {\n            if(allowedCommands[i].equals(command))\n                return s;\n        }\n        \n        // Allow PRIVMSG, but block CTCP.\n        if(\"PRIVMSG\".equals(command))\n        {\n            String msg;\n            msg = field[idx++];\n        \n            byte[] bytes = msg.getBytes();\n            if(bytes[1]==0x01)\n            {\n                // CTCP\n                msg=msg.substring(2);\n                if(msg.startsWith(\"ACTION \")) {\n                    // /me says hello\n                    return s;\n                }\n                return null; // Block all other ctcp\n            }\n            return s;\n        }\n        \n        // Block the rest\n        return null;\n    }","id":89857,"modified_method":"/*************************************************************************\n     *\n     */\n    \n    public String inboundFilter(String s, StringBuffer expectedPong) {\n        \n        String field[]=s.split(\" \",4);\n        String command;\n        int idx=0;\n        final String[] allowedCommands =\n        {\n                // \"NOTICE\", // can contain CTCP\n                //\"PING\",\n                //\"PONG\",\n                \"MODE\",\n                \"JOIN\",\n                \"NICK\",\n                \"QUIT\",\n                \"PART\",\n                \"WALLOPS\",\n                \"ERROR\",\n                \"KICK\",\n                \"H\", // \"hide operator status\" (after kicking an op)\n                \"TOPIC\"\n        };\n        \n        if(field[0].charAt(0)==':')\n            idx++;\n\n        try { command = field[idx++]; }\n         catch (IndexOutOfBoundsException ioobe) // wtf, server sent borked command?\n        {\n           _log.warn(\"Dropping defective message: index out of bounds while extracting command.\");\n           return null;\n        }\n\n        idx++; //skip victim\n\n        // Allow numerical responses\n        try {\n            new Integer(command);\n            return s;\n        } catch(NumberFormatException nfe){}\n\n        \n\tif (\"PING\".equalsIgnoreCase(command))\n            return \"PING 127.0.0.1\"; // no way to know what the ircd to i2ptunnel server con is, so localhost works\n\tif (\"PONG\".equalsIgnoreCase(command)) {\n            // Turn the received \":irc.freshcoffee.i2p PONG irc.freshcoffee.i2p :127.0.0.1\"\n            // into \":127.0.0.1 PONG 127.0.0.1 \" so that the caller can append the client's extra parameter\n            // though, does 127.0.0.1 work for irc clients connecting remotely?  and for all of them?  sure would\n            // be great if irc clients actually followed the RFCs here, but i guess thats too much to ask.\n            // If we haven't PINGed them, or the PING we sent isn't something we know how to filter, this \n            // is blank.\n            String pong = expectedPong.length() > 0 ? expectedPong.toString() : null;\n            expectedPong.setLength(0);\n            return pong;\n        }\n        \n        // Allow all allowedCommands\n        for(int i=0;i<allowedCommands.length;i++) {\n            if(allowedCommands[i].equalsIgnoreCase(command))\n                return s;\n        }\n        \n        // Allow PRIVMSG, but block CTCP.\n        if(\"PRIVMSG\".equalsIgnoreCase(command) || \"NOTICE\".equalsIgnoreCase(command))\n        {\n            String msg;\n            msg = field[idx++];\n        \n            if(msg.indexOf(0x01) >= 0) // CTCP marker ^A can be anywhere, not just immediately after the ':'\n            {\n                // CTCP\n                msg=msg.substring(2);\n                if(msg.startsWith(\"ACTION \")) {\n                    // /me says hello\n                    return s;\n                }\n                return null; // Block all other ctcp\n            }\n            return s;\n        }\n        \n        // Block the rest\n        return null;\n    }","commit_id":"819a72d4f6b9cd1068db3be3758e6855c49f16db","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            final String name = call.getMethodAsString();\n            if (name==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                final Expression objectExpression = call.getObjectExpression();\n                final ClassNode receiver = getType(objectExpression, classNode);\n                MethodNode mn = findMethod(call, receiver, name, args);\n                if (mn==null) {\n                    if (objectExpression instanceof VariableExpression) {\n                        VariableExpression variableExpression = (VariableExpression) objectExpression;\n                        if (!temporaryIfBranchTypeInformation.isEmpty()) {\n                            final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                            List<ClassNode> potentialReceiverType = tempo.get(findTargetVariable(variableExpression));\n                            if (potentialReceiverType!=null) {\n                                for (ClassNode potentialReceiver : potentialReceiverType) {\n                                    mn = findMethod(call, potentialReceiver, name, args);\n                                    if (mn!=null) break;\n                                }\n                            }\n                        }\n                    }\n                    if (mn==null) {\n                        addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                        return;\n                    }\n                }\n                storeType(call, mn.getReturnType());\n            }\n        }","id":89858,"modified_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            final String name = call.getMethodAsString();\n            if (name==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                final Expression objectExpression = call.getObjectExpression();\n                final ClassNode receiver = getType(objectExpression, classNode);\n                MethodNode mn = findMethod(call, receiver, name, args);\n                if (mn==null && !temporaryIfBranchTypeInformation.isEmpty()) {\n                    Object key = objectExpression.getText();\n                    final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                    if (objectExpression instanceof VariableExpression) {\n                        VariableExpression variableExpression = (VariableExpression) objectExpression;\n                        key = findTargetVariable(variableExpression);\n                    }\n                    List<ClassNode> potentialReceiverType = tempo.get(key);\n                    if (potentialReceiverType != null) {\n                        for (ClassNode potentialReceiver : potentialReceiverType) {\n                            mn = findMethod(call, potentialReceiver, name, args);\n                            if (mn != null) break;\n                        }\n                    }\n                    if (mn==null) {\n                        addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                        return;\n                    }\n                }\n                storeType(call, mn.getReturnType());\n            }\n        }","commit_id":"eb787b863272deeec44b59e56c8666cbb3b335e5","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                    VariableExpression target = findTargetVariable((VariableExpression) left);\n                    List<ClassNode> potentialTypes = tempo.get(target);\n                    if (potentialTypes==null) {\n                        potentialTypes = new LinkedList<ClassNode>();\n                        tempo.put(target, potentialTypes);\n                    }\n                    potentialTypes.add(rightExpression.getType());\n                }\n            }\n        }","id":89859,"modified_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = left.getText();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    key = findTargetVariable((VariableExpression) left);\n                }\n                List<ClassNode> potentialTypes = tempo.get(key);\n                if (potentialTypes==null) {\n                    potentialTypes = new LinkedList<ClassNode>();\n                    tempo.put(key, potentialTypes);\n                }\n                potentialTypes.add(rightExpression.getType());\n            }\n        }","commit_id":"eb787b863272deeec44b59e56c8666cbb3b335e5","url":"https://github.com/apache/groovy"},{"original_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n            this.temporaryIfBranchTypeInformation  = new Stack<Map<Expression, List<ClassNode>>>();\n            pushTemporaryTypeInfo();\n        }","id":89860,"modified_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n            this.temporaryIfBranchTypeInformation  = new Stack<Map<Object, List<ClassNode>>>();\n            pushTemporaryTypeInfo();\n        }","commit_id":"eb787b863272deeec44b59e56c8666cbb3b335e5","url":"https://github.com/apache/groovy"},{"original_method":"private void pushTemporaryTypeInfo() {\n            Map<Expression, List<ClassNode>> potentialTypes = new HashMap<Expression, List<ClassNode>>();\n            temporaryIfBranchTypeInformation.push(potentialTypes);\n        }","id":89861,"modified_method":"private void pushTemporaryTypeInfo() {\n            Map<Object, List<ClassNode>> potentialTypes = new HashMap<Object, List<ClassNode>>();\n            temporaryIfBranchTypeInformation.push(potentialTypes);\n        }","commit_id":"eb787b863272deeec44b59e56c8666cbb3b335e5","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n            ClassNode leftRedirect = left.redirect();\n            ClassNode rightRedirect = right.redirect();\n\n            if (op==ASSIGN) {\n                return leftRedirect.isArray() && !rightRedirect.isArray()?leftRedirect:rightRedirect;\n            } else if (isBoolIntrinsicOp(op)) {\n                return boolean_TYPE;\n            } else if (isArrayOp(op)) {\n                ClassNode arrayType = getType(expr.getLeftExpression(), classNode);\n                return arrayType.getComponentType();\n            } else if (op==FIND_REGEX) {\n                // this case always succeeds the result is a Matcher\n                return Matcher_TYPE;\n            }\n            // the left operand is determining the result of the operation\n            // for primitives and their wrapper we use a fixed table here\n            else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n                if (isOperationInGroup(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                    if (isBigDecCategory(leftRedirect) && isBigDecCategory(rightRedirect))    return BigDecimal_TYPE;\n                    if (isDoubleCategory(leftRedirect) && isDoubleCategory(rightRedirect))    return double_TYPE;\n                } else if (isPowerOperator(op)) {\n                    return Number_TYPE;\n                } else if (isBitOperator(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                }\n            }\n\n\n            // try to find a method for the operation\n            String operationName = getOperationName(op);\n            MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n            if (method!=null) {\n                if (isCompareToBoolean(op)) return boolean_TYPE;\n                if (op==COMPARE_TO)         return int_TYPE;\n                return method.getReturnType();\n            }\n            //TODO: other cases\n            return null;\n        }","id":89862,"modified_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n            ClassNode leftRedirect = left.redirect();\n            ClassNode rightRedirect = right.redirect();\n\n            if (op==ASSIGN) {\n                return leftRedirect.isArray() && !rightRedirect.isArray()?leftRedirect:rightRedirect;\n            } else if (isBoolIntrinsicOp(op)) {\n                return boolean_TYPE;\n            } else if (isArrayOp(op)) {\n                ClassNode arrayType = getType(expr.getLeftExpression(), classNode);\n                final ClassNode componentType = arrayType.getComponentType();\n                return componentType==null?ClassHelper.OBJECT_TYPE:componentType;\n            } else if (op==FIND_REGEX) {\n                // this case always succeeds the result is a Matcher\n                return Matcher_TYPE;\n            }\n            // the left operand is determining the result of the operation\n            // for primitives and their wrapper we use a fixed table here\n            else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n                if (isOperationInGroup(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                    if (isBigDecCategory(leftRedirect) && isBigDecCategory(rightRedirect))    return BigDecimal_TYPE;\n                    if (isDoubleCategory(leftRedirect) && isDoubleCategory(rightRedirect))    return double_TYPE;\n                } else if (isPowerOperator(op)) {\n                    return Number_TYPE;\n                } else if (isBitOperator(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                }\n            }\n\n\n            // try to find a method for the operation\n            String operationName = getOperationName(op);\n            MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n            if (method!=null) {\n                if (isCompareToBoolean(op)) return boolean_TYPE;\n                if (op==COMPARE_TO)         return int_TYPE;\n                return method.getReturnType();\n            }\n            //TODO: other cases\n            return null;\n        }","commit_id":"eb787b863272deeec44b59e56c8666cbb3b335e5","url":"https://github.com/apache/groovy"},{"original_method":"private static VariableExpression findTargetVariable(VariableExpression ve) {\n            VariableExpression result = ve;\n            final Variable accessedVariable = result.getAccessedVariable();\n            while (accessedVariable !=null && accessedVariable!=result && accessedVariable instanceof VariableExpression) {\n                result = (VariableExpression) result.getAccessedVariable();\n            }\n            return result;\n        }","id":89863,"modified_method":"private static Variable findTargetVariable(VariableExpression ve) {\n            final Variable accessedVariable = ve.getAccessedVariable();\n            if (accessedVariable !=ve) {\n                if (accessedVariable instanceof VariableExpression) return findTargetVariable((VariableExpression) accessedVariable);\n            }\n            return accessedVariable;\n        }","commit_id":"eb787b863272deeec44b59e56c8666cbb3b335e5","url":"https://github.com/apache/groovy"},{"original_method":"private static VariableExpression findTargetVariable(VariableExpression ve) {\n            VariableExpression result = ve;\n            final Variable accessedVariable = result.getAccessedVariable();\n            while (accessedVariable !=null && accessedVariable!=result && accessedVariable instanceof VariableExpression) {\n                result = (VariableExpression) result.getAccessedVariable();\n            }\n            return result;\n        }","id":89864,"modified_method":"private static Variable findTargetVariable(VariableExpression ve) {\n            final Variable accessedVariable = ve.getAccessedVariable();\n            if (accessedVariable !=ve) {\n                if (accessedVariable instanceof VariableExpression) return findTargetVariable((VariableExpression) accessedVariable);\n            }\n            return accessedVariable;\n        }","commit_id":"bea5359820dda3b4c9784ca17db57fa4e237c2ee","url":"https://github.com/apache/groovy"},{"original_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n            this.temporaryIfBranchTypeInformation  = new Stack<Map<Expression, List<ClassNode>>>();\n            pushTemporaryTypeInfo();\n        }","id":89865,"modified_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n            this.temporaryIfBranchTypeInformation  = new Stack<Map<Object, List<ClassNode>>>();\n            pushTemporaryTypeInfo();\n        }","commit_id":"bea5359820dda3b4c9784ca17db57fa4e237c2ee","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            final String name = call.getMethodAsString();\n            if (name==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                final Expression objectExpression = call.getObjectExpression();\n                final ClassNode receiver = getType(objectExpression, classNode);\n                MethodNode mn = findMethod(call, receiver, name, args);\n                if (mn==null) {\n                    if (objectExpression instanceof VariableExpression) {\n                        VariableExpression variableExpression = (VariableExpression) objectExpression;\n                        if (!temporaryIfBranchTypeInformation.isEmpty()) {\n                            final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                            List<ClassNode> potentialReceiverType = tempo.get(findTargetVariable(variableExpression));\n                            if (potentialReceiverType!=null) {\n                                for (ClassNode potentialReceiver : potentialReceiverType) {\n                                    mn = findMethod(call, potentialReceiver, name, args);\n                                    if (mn!=null) break;\n                                }\n                            }\n                        }\n                    }\n                    if (mn==null) {\n                        addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                        return;\n                    }\n                }\n                storeType(call, mn.getReturnType());\n            }\n        }","id":89866,"modified_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            final String name = call.getMethodAsString();\n            if (name==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                final Expression objectExpression = call.getObjectExpression();\n                final ClassNode receiver = getType(objectExpression, classNode);\n                MethodNode mn = findMethod(call, receiver, name, args);\n                if (mn==null && !temporaryIfBranchTypeInformation.isEmpty()) {\n                    Object key = objectExpression.getText();\n                    final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                    if (objectExpression instanceof VariableExpression) {\n                        VariableExpression variableExpression = (VariableExpression) objectExpression;\n                        key = findTargetVariable(variableExpression);\n                    }\n                    List<ClassNode> potentialReceiverType = tempo.get(key);\n                    if (potentialReceiverType != null) {\n                        for (ClassNode potentialReceiver : potentialReceiverType) {\n                            mn = findMethod(call, potentialReceiver, name, args);\n                            if (mn != null) break;\n                        }\n                    }\n                    if (mn==null) {\n                        addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                        return;\n                    }\n                }\n                storeType(call, mn.getReturnType());\n            }\n        }","commit_id":"bea5359820dda3b4c9784ca17db57fa4e237c2ee","url":"https://github.com/apache/groovy"},{"original_method":"private void pushTemporaryTypeInfo() {\n            Map<Expression, List<ClassNode>> potentialTypes = new HashMap<Expression, List<ClassNode>>();\n            temporaryIfBranchTypeInformation.push(potentialTypes);\n        }","id":89867,"modified_method":"private void pushTemporaryTypeInfo() {\n            Map<Object, List<ClassNode>> potentialTypes = new HashMap<Object, List<ClassNode>>();\n            temporaryIfBranchTypeInformation.push(potentialTypes);\n        }","commit_id":"bea5359820dda3b4c9784ca17db57fa4e237c2ee","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n            ClassNode leftRedirect = left.redirect();\n            ClassNode rightRedirect = right.redirect();\n\n            if (op==ASSIGN) {\n                return leftRedirect.isArray() && !rightRedirect.isArray()?leftRedirect:rightRedirect;\n            } else if (isBoolIntrinsicOp(op)) {\n                return boolean_TYPE;\n            } else if (isArrayOp(op)) {\n                ClassNode arrayType = getType(expr.getLeftExpression(), classNode);\n                return arrayType.getComponentType();\n            } else if (op==FIND_REGEX) {\n                // this case always succeeds the result is a Matcher\n                return Matcher_TYPE;\n            }\n            // the left operand is determining the result of the operation\n            // for primitives and their wrapper we use a fixed table here\n            else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n                if (isOperationInGroup(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                    if (isBigDecCategory(leftRedirect) && isBigDecCategory(rightRedirect))    return BigDecimal_TYPE;\n                    if (isDoubleCategory(leftRedirect) && isDoubleCategory(rightRedirect))    return double_TYPE;\n                } else if (isPowerOperator(op)) {\n                    return Number_TYPE;\n                } else if (isBitOperator(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                }\n            }\n\n\n            // try to find a method for the operation\n            String operationName = getOperationName(op);\n            MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n            if (method!=null) {\n                if (isCompareToBoolean(op)) return boolean_TYPE;\n                if (op==COMPARE_TO)         return int_TYPE;\n                return method.getReturnType();\n            }\n            //TODO: other cases\n            return null;\n        }","id":89868,"modified_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n            ClassNode leftRedirect = left.redirect();\n            ClassNode rightRedirect = right.redirect();\n\n            if (op==ASSIGN) {\n                return leftRedirect.isArray() && !rightRedirect.isArray()?leftRedirect:rightRedirect;\n            } else if (isBoolIntrinsicOp(op)) {\n                return boolean_TYPE;\n            } else if (isArrayOp(op)) {\n                ClassNode arrayType = getType(expr.getLeftExpression(), classNode);\n                final ClassNode componentType = arrayType.getComponentType();\n                return componentType==null?ClassHelper.OBJECT_TYPE:componentType;\n            } else if (op==FIND_REGEX) {\n                // this case always succeeds the result is a Matcher\n                return Matcher_TYPE;\n            }\n            // the left operand is determining the result of the operation\n            // for primitives and their wrapper we use a fixed table here\n            else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n                if (isOperationInGroup(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                    if (isBigDecCategory(leftRedirect) && isBigDecCategory(rightRedirect))    return BigDecimal_TYPE;\n                    if (isDoubleCategory(leftRedirect) && isDoubleCategory(rightRedirect))    return double_TYPE;\n                } else if (isPowerOperator(op)) {\n                    return Number_TYPE;\n                } else if (isBitOperator(op)) {\n                    if (isIntCategory(leftRedirect)    && isIntCategory(rightRedirect))       return int_TYPE;\n                    if (isLongCategory(leftRedirect)   && isLongCategory(rightRedirect))      return Long_TYPE;\n                    if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect))    return BigInteger_TYPE;\n                }\n            }\n\n\n            // try to find a method for the operation\n            String operationName = getOperationName(op);\n            MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n            if (method!=null) {\n                if (isCompareToBoolean(op)) return boolean_TYPE;\n                if (op==COMPARE_TO)         return int_TYPE;\n                return method.getReturnType();\n            }\n            //TODO: other cases\n            return null;\n        }","commit_id":"bea5359820dda3b4c9784ca17db57fa4e237c2ee","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                    VariableExpression target = findTargetVariable((VariableExpression) left);\n                    List<ClassNode> potentialTypes = tempo.get(target);\n                    if (potentialTypes==null) {\n                        potentialTypes = new LinkedList<ClassNode>();\n                        tempo.put(target, potentialTypes);\n                    }\n                    potentialTypes.add(rightExpression.getType());\n                }\n            }\n        }","id":89869,"modified_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                Object key = left.getText();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    key = findTargetVariable((VariableExpression) left);\n                }\n                List<ClassNode> potentialTypes = tempo.get(key);\n                if (potentialTypes==null) {\n                    potentialTypes = new LinkedList<ClassNode>();\n                    tempo.put(key, potentialTypes);\n                }\n                potentialTypes.add(rightExpression.getType());\n            }\n        }","commit_id":"bea5359820dda3b4c9784ca17db57fa4e237c2ee","url":"https://github.com/apache/groovy"},{"original_method":"private static boolean isOutlying(OsmPrimitive osm, Area area) {\n        if (osm instanceof Node) {\n            return !osm.isNewOrUndeleted() && !area.contains(((Node) osm).getCoor());\n        } else if (osm instanceof Way) {\n            for (Node n : ((Way) osm).getNodes()) {\n                if (isOutlying(n, area)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return false;\n    }","id":89870,"modified_method":"private static boolean isOutlying(OsmPrimitive osm, Area area) {\n        if (osm instanceof Node && !osm.isNewOrUndeleted()) {\n            LatLon coor = ((Node) osm).getCoor();\n            return coor != null && !area.contains(coor);\n        } else if (osm instanceof Way) {\n            for (Node n : ((Way) osm).getNodes()) {\n                if (isOutlying(n, area)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return false;\n    }","commit_id":"be0282dce51e6468735aeb39e71df163f88ad30a","url":"https://github.com/openstreetmap/josm"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    if (headerValuePart.getParent() instanceof Clause) {\n      return getPackageReferences(headerValuePart);\n    }\n    return PsiReference.EMPTY_ARRAY;\n  }","id":89871,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    return headerValuePart.getParent() instanceof Clause ? getPackageReferences(headerValuePart) : PsiReference.EMPTY_ARRAY;\n  }","commit_id":"619d609e24099a460482cb3ecd2a3a73b5a90389","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Returns all manifest holders which provide the given package via export-package.\n   *\n   * @param packageSpec the package specification (may include version ranges)\n   * @return set of matching manifest holders.\n   */\n  @NotNull\n  public Set<ManifestHolder> whoProvides(@NotNull final String packageSpec) {\n    Set<ManifestHolder> result = new HashSet<ManifestHolder>();\n    for (ManifestHolder manifestHolder : myManifestHolders) {\n      BundleManifest bundleManifest;\n      try {\n        bundleManifest = manifestHolder.getBundleManifest();\n      }\n      catch (ManifestHolderDisposedException ignore) {\n        // ok this thing is gone\n        continue;\n      }\n      if (bundleManifest != null) {\n        if (bundleManifest.exportsPackage(packageSpec)) {\n          result.add(manifestHolder);\n        }\n      }\n    }\n    return result;\n  }","id":89872,"modified_method":"/**\n   * Returns all manifest holders which provide the given package via export-package.\n   *\n   * @param packageSpec the package specification (may include version ranges)\n   * @return set of matching manifest holders.\n   */\n  @NotNull\n  public Set<ManifestHolder> whoProvides(@NotNull final String packageSpec) {\n    Set<ManifestHolder> result = new HashSet<ManifestHolder>();\n    for (ManifestHolder manifestHolder : myManifestHolders) {\n      BundleManifest bundleManifest;\n      try {\n        bundleManifest = manifestHolder.getBundleManifest();\n      }\n      catch (ManifestHolderDisposedException ignore) {\n        // ok this thing is gone\n        continue;\n      }\n      if (bundleManifest != null) {\n        if (bundleManifest.isPackageExported(packageSpec)) {\n          result.add(manifestHolder);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"619d609e24099a460482cb3ecd2a3a73b5a90389","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public boolean exportsPackage(@NotNull String packageSpec) {\n    Header header = myManifestFile.getHeader(EXPORT_PACKAGE);\n    if (header == null) {\n      return false;\n    }\n\n    List<BundleCapability> capabilities = ContainerUtil.newArrayList();\n    String bsn = getBundleSymbolicName();\n    String bv = getBundleVersion().toString();\n    for (HeaderValue headerValue : header.getHeaderValues()) {\n      List<BundleCapability> caps = FelixManifestParser.parseExportHeader(headerValue.getUnwrappedText(), bsn, bv);\n      if (caps == null) return false;  // parse error\n      capabilities.addAll(caps);\n    }\n\n    List<BundleRequirement> requirements = FelixManifestParser.parseImportHeader(packageSpec);\n    if (requirements == null) return false;  // parse error\n\n    return satisfies(capabilities, requirements);\n  }","id":89873,"modified_method":"@Override\n  public boolean isPackageExported(@NotNull String packageSpec) {\n    Header header = myManifestFile.getHeader(EXPORT_PACKAGE);\n    if (header == null) {\n      return false;\n    }\n\n    List<BundleCapability> capabilities = ContainerUtil.newArrayList();\n    String bsn = getBundleSymbolicName();\n    String bv = getBundleVersion().toString();\n    for (HeaderValue headerValue : header.getHeaderValues()) {\n      List<BundleCapability> caps = FelixManifestParser.parseExportHeader(headerValue.getUnwrappedText(), bsn, bv);\n      if (caps == null) return false;  // parse error\n      capabilities.addAll(caps);\n    }\n\n    List<BundleRequirement> requirements = FelixManifestParser.parseImportHeader(packageSpec);\n    if (requirements == null) return false;  // parse error\n\n    return satisfies(capabilities, requirements);\n  }","commit_id":"619d609e24099a460482cb3ecd2a3a73b5a90389","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testExportsPackage() {\n    BundleManifest bundleManifest = getManifest(Manifest1);\n\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bar\"));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.bam\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"naff.blah\"), is(false));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=1.0.0\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=2.0.0\"), is(false));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=\\\"[1.0.0, 2.0.0)\\\"\"), is(true));\n    assertThat(bundleManifest.exportsPackage(\"foo.bar.baz;version=\\\"[1.1.0, 2.0.0)\\\"\"), is(false));\n  }","id":89874,"modified_method":"public void testExportsPackage() {\n    BundleManifest bundleManifest = getManifest(Manifest1);\n\n    assertThat(bundleManifest.getBundleSymbolicName(), equalTo(\"foo.bar\"));\n    assertThat(bundleManifest.isPackageExported(\"foo.bar.baz\"), is(true));\n    assertThat(bundleManifest.isPackageExported(\"foo.bar.bam\"), is(true));\n    assertThat(bundleManifest.isPackageExported(\"naff.blah\"), is(false));\n    assertThat(bundleManifest.isPackageExported(\"foo.bar.baz;version=1.0.0\"), is(true));\n    assertThat(bundleManifest.isPackageExported(\"foo.bar.baz;version=2.0.0\"), is(false));\n    assertThat(bundleManifest.isPackageExported(\"foo.bar.baz;version=\\\"[1.0.0, 2.0.0)\\\"\"), is(true));\n    assertThat(bundleManifest.isPackageExported(\"foo.bar.baz;version=\\\"[1.1.0, 2.0.0)\\\"\"), is(false));\n  }","commit_id":"619d609e24099a460482cb3ecd2a3a73b5a90389","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public Object getConvertedValue(@NotNull Header header) {\n    List<HeaderValue> headerValues = header.getHeaderValues();\n    if (!headerValues.isEmpty()) {\n      List<String> packages = ContainerUtil.newArrayListWithCapacity(headerValues.size());\n      for (HeaderValue headerValue : headerValues) {\n        HeaderValuePart valuePart = ((Clause)headerValue).getValue();\n        if (valuePart != null) {\n          String packageName = valuePart.getText().replaceAll(\"\\\\s+\", \"\");\n          packages.add(packageName);\n        }\n      }\n      return packages;\n    }\n\n    return null;\n  }","id":89875,"modified_method":"@Nullable\n  @Override\n  public Object getConvertedValue(@NotNull Header header) {\n    List<HeaderValue> headerValues = header.getHeaderValues();\n    if (!headerValues.isEmpty()) {\n      List<String> packages = ContainerUtil.newArrayListWithCapacity(headerValues.size());\n      for (HeaderValue headerValue : headerValues) {\n        HeaderValuePart valuePart = ((Clause)headerValue).getValue();\n        if (valuePart != null) {\n          packages.add(valuePart.getText().replaceAll(\"\\\\s+\", \"\"));\n        }\n      }\n      return packages;\n    }\n\n    return null;\n  }","commit_id":"b4d2c8e4cb32ac5681540a609226bdaa4f97a122","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected static PsiReference[] getPackageReferences(PsiElement psiElement) {\n    String packageName = psiElement.getText();\n    if (StringUtil.isEmptyOrSpaces(packageName) ) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    int offset = 0;\n    if (packageName.charAt(0) == '!') {\n      packageName = packageName.substring(1);\n      offset = 1;\n    }\n\n    int size = packageName.length() - 1;\n    if (packageName.charAt(size) == '?') {\n      packageName = packageName.substring(0, size);\n    }\n\n    PackageReferenceSet referenceSet = new ManifestPackageReferenceSet(packageName, psiElement, offset);\n    return referenceSet.getReferences().toArray(new PsiPackageReference[referenceSet.getReferences().size()]);\n  }","id":89876,"modified_method":"protected static PsiReference[] getPackageReferences(PsiElement psiElement) {\n    String packageName = psiElement.getText();\n    if (StringUtil.isEmptyOrSpaces(packageName) ) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    int offset = 0;\n    if (packageName.charAt(0) == '!') {\n      packageName = packageName.substring(1);\n      offset = 1;\n    }\n\n    int size = packageName.length() - 1;\n    if (packageName.charAt(size) == '?') {\n      packageName = packageName.substring(0, size);\n    }\n\n    PackageReferenceSet refSet = new PackageReferenceSet(packageName, psiElement, offset) {\n      @Override\n      public Collection<PsiPackage> resolvePackageName(@Nullable PsiPackage context, String packageName) {\n        if (context == null) return Collections.emptyList();\n        String unwrappedPackageName = packageName.replaceAll(\"\\\\s+\", \"\");\n        return ContainerUtil.filter(context.getSubPackages(), pkg -> unwrappedPackageName.equals(pkg.getName()));\n      }\n    };\n    return refSet.getReferences().toArray(new PsiPackageReference[0]);\n  }","commit_id":"b4d2c8e4cb32ac5681540a609226bdaa4f97a122","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    if (headerValuePart.getParent() instanceof Clause) {\n      return getPackageReferences(headerValuePart);\n    }\n\n    return PsiReference.EMPTY_ARRAY;\n  }","id":89877,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    return headerValuePart.getParent() instanceof Clause ? getPackageReferences(headerValuePart) : PsiReference.EMPTY_ARRAY;\n  }","commit_id":"b4d2c8e4cb32ac5681540a609226bdaa4f97a122","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    PsiElement parent = headerValuePart.getParent();\n    if (parent instanceof Clause) {\n      PsiElement element = headerValuePart.getOriginalElement();\n      if (isPackageRef(element.getPrevSibling())) {\n        return getPackageReferences(headerValuePart);\n      }\n    }\n    else if (parent instanceof Attribute) {\n      Attribute attribute = (Attribute)parent;\n      if (Constants.USES_DIRECTIVE.equals(attribute.getName())) {\n        List<PsiReference> references = ContainerUtil.newSmartList();\n        for (ASTNode astNode : headerValuePart.getNode().getChildren(TOKEN_FILTER)) {\n          if (astNode instanceof ManifestToken) {\n            ManifestToken manifestToken = (ManifestToken)astNode;\n            ContainerUtil.addAll(references, getPackageReferences(manifestToken));\n          }\n        }\n        return ContainerUtilRt.toArray(references, new PsiReference[references.size()]);\n      }\n    }\n\n    return PsiReference.EMPTY_ARRAY;\n  }","id":89878,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    PsiElement parent = headerValuePart.getParent();\n    if (parent instanceof Clause) {\n      PsiElement element = headerValuePart.getOriginalElement().getPrevSibling();\n      if (!(element instanceof ManifestToken) ||\n          ((ManifestToken)element).getTokenType() != ManifestTokenType.SEMICOLON) {\n        return getPackageReferences(headerValuePart);\n      }\n    }\n    else if (parent instanceof Attribute) {\n      Attribute attribute = (Attribute)parent;\n      if (Constants.USES_DIRECTIVE.equals(attribute.getName())) {\n        List<PsiReference> references = ContainerUtil.newSmartList();\n        for (ASTNode astNode : headerValuePart.getNode().getChildren(TOKEN_FILTER)) {\n          if (astNode instanceof ManifestToken) {\n            ManifestToken manifestToken = (ManifestToken)astNode;\n            ContainerUtil.addAll(references, getPackageReferences(manifestToken));\n          }\n        }\n        return ContainerUtilRt.toArray(references, new PsiReference[references.size()]);\n      }\n    }\n\n    return PsiReference.EMPTY_ARRAY;\n  }","commit_id":"b4d2c8e4cb32ac5681540a609226bdaa4f97a122","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    return headerValuePart.getParent() instanceof Clause ? getPackageReferences(headerValuePart) : PsiReference.EMPTY_ARRAY;\n  }","id":89879,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    if (headerValuePart.getParent() instanceof Clause) {\n      return getPackageReferences(headerValuePart);\n    }\n\n    return PsiReference.EMPTY_ARRAY;\n  }","commit_id":"8e5d72b92ad392bcc6f5eb3dde901b8d8b9b1e14","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected static PsiReference[] getPackageReferences(final PsiElement psiElement) {\n    String packageName = psiElement.getText();\n    if (StringUtil.isEmptyOrSpaces(packageName) ) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    int offset = 0;\n    if (packageName.charAt(0) == '!') {\n      packageName = packageName.substring(1);\n      offset++;\n    }\n\n    int size = packageName.length() - 1;\n    if (packageName.charAt(size) == '?') {\n      packageName = packageName.substring(0, size);\n    }\n    PackageReferenceSet referenceSet = new ManifestPackageReferenceSet(packageName, psiElement, offset);\n    return referenceSet.getReferences().toArray(new PsiPackageReference[referenceSet.getReferences().size()]);\n  }","id":89880,"modified_method":"protected static PsiReference[] getPackageReferences(PsiElement psiElement) {\n    String packageName = psiElement.getText();\n    if (StringUtil.isEmptyOrSpaces(packageName) ) {\n      return PsiReference.EMPTY_ARRAY;\n    }\n\n    int offset = 0;\n    if (packageName.charAt(0) == '!') {\n      packageName = packageName.substring(1);\n      offset = 1;\n    }\n\n    int size = packageName.length() - 1;\n    if (packageName.charAt(size) == '?') {\n      packageName = packageName.substring(0, size);\n    }\n\n    PackageReferenceSet referenceSet = new ManifestPackageReferenceSet(packageName, psiElement, offset);\n    return referenceSet.getReferences().toArray(new PsiPackageReference[referenceSet.getReferences().size()]);\n  }","commit_id":"8e5d72b92ad392bcc6f5eb3dde901b8d8b9b1e14","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    if (headerValuePart.getParent() instanceof Clause) {\n      final PsiElement element = headerValuePart.getOriginalElement();\n      if (isPackageRef(element.getPrevSibling())) {\n        return getPackageReferences(headerValuePart);\n      }\n    }\n    else if (headerValuePart.getParent() instanceof Attribute) {\n      Attribute attribute = (Attribute)headerValuePart.getParent();\n      if (USES_DIRECTIVE.equals(attribute.getName()) && !USES_DIRECTIVE.equals(headerValuePart.getUnwrappedText())) {\n        List<PsiReference> references = ContainerUtil.newArrayList();\n        for (ASTNode astNode : headerValuePart.getNode().getChildren(TokenSet.create(ManifestTokenType.HEADER_VALUE_PART))) {\n          if (astNode instanceof ManifestToken) {\n            ManifestToken manifestToken = (ManifestToken)astNode;\n            ContainerUtil.addAll(references, getPackageReferences(manifestToken));\n          }\n        }\n        return ContainerUtilRt.toArray(references, new PsiReference[references.size()]);\n      }\n    }\n    return PsiReference.EMPTY_ARRAY;\n  }","id":89881,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferences(@NotNull HeaderValuePart headerValuePart) {\n    PsiElement parent = headerValuePart.getParent();\n    if (parent instanceof Clause) {\n      PsiElement element = headerValuePart.getOriginalElement();\n      if (isPackageRef(element.getPrevSibling())) {\n        return getPackageReferences(headerValuePart);\n      }\n    }\n    else if (parent instanceof Attribute) {\n      Attribute attribute = (Attribute)parent;\n      if (Constants.USES_DIRECTIVE.equals(attribute.getName())) {\n        List<PsiReference> references = ContainerUtil.newSmartList();\n        for (ASTNode astNode : headerValuePart.getNode().getChildren(TOKEN_FILTER)) {\n          if (astNode instanceof ManifestToken) {\n            ManifestToken manifestToken = (ManifestToken)astNode;\n            ContainerUtil.addAll(references, getPackageReferences(manifestToken));\n          }\n        }\n        return ContainerUtilRt.toArray(references, new PsiReference[references.size()]);\n      }\n    }\n\n    return PsiReference.EMPTY_ARRAY;\n  }","commit_id":"8e5d72b92ad392bcc6f5eb3dde901b8d8b9b1e14","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean isPackageRef(final PsiElement element) {\n    final boolean result;\n    if (element instanceof ManifestToken) {\n      ManifestToken manifestToken = (ManifestToken)element;\n      result = manifestToken.getTokenType() != ManifestTokenType.SEMICOLON;\n    }\n    else {\n      result = true;\n    }\n\n    return result;\n  }","id":89882,"modified_method":"private static boolean isPackageRef(PsiElement element) {\n    if (element instanceof ManifestToken) {\n      ManifestToken manifestToken = (ManifestToken)element;\n      return manifestToken.getTokenType() != ManifestTokenType.SEMICOLON;\n    }\n    else {\n      return true;\n    }\n  }","commit_id":"8e5d72b92ad392bcc6f5eb3dde901b8d8b9b1e14","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public OsgiManifestCompletionContributor() {\n    extend(\n      CompletionType.BASIC,\n      header(Constants.EXPORT_PACKAGE),\n      new HeaderParametersProvider(Constants.VERSION_ATTRIBUTE, Constants.USES_DIRECTIVE+':'));\n\n    extend(\n      CompletionType.BASIC,\n      header(Constants.IMPORT_PACKAGE),\n      new HeaderParametersProvider(Constants.VERSION_ATTRIBUTE, Constants.RESOLUTION_DIRECTIVE+':'));\n\n    extend(\n      CompletionType.BASIC,\n      directive(Constants.RESOLUTION_DIRECTIVE),\n      new SimpleProvider(\"mandatory\", \"optional\"));\n  }","id":89883,"modified_method":"public OsgiManifestCompletionContributor() {\n    extend(\n      CompletionType.BASIC,\n      header(Constants.EXPORT_PACKAGE),\n      new HeaderParametersProvider(Constants.VERSION_ATTRIBUTE, Constants.USES_DIRECTIVE + ':'));\n\n    extend(\n      CompletionType.BASIC,\n      header(Constants.IMPORT_PACKAGE),\n      new HeaderParametersProvider(Constants.VERSION_ATTRIBUTE, Constants.RESOLUTION_DIRECTIVE + ':'));\n\n    extend(\n      CompletionType.BASIC,\n      directive(Constants.RESOLUTION_DIRECTIVE),\n      new SimpleProvider(Constants.RESOLUTION_MANDATORY, Constants.RESOLUTION_OPTIONAL));\n  }","commit_id":"8e5d72b92ad392bcc6f5eb3dde901b8d8b9b1e14","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void setMacros(Iterable<String> macros) {\n        this.macros = macros;\n    }","id":89884,"modified_method":"public void setMacros(Map<String, String> macros) {\n        this.macros = macros;\n    }","commit_id":"d6e940ee7711aff0cdc0c39752870cbd0a0bdf8b","url":"https://github.com/gradle/gradle"},{"original_method":"public Iterable<String> getMacros() {\n        return macros;\n    }","id":89885,"modified_method":"public Map<String, String> getMacros() {\n        return macros;\n    }","commit_id":"d6e940ee7711aff0cdc0c39752870cbd0a0bdf8b","url":"https://github.com/gradle/gradle"},{"original_method":"public void collectArguments(T spec, ArgCollector collector) {\n        for (String macro : spec.getMacros()) {\n            collector.args(\"-D\" + macro);\n        }\n        collector.args(spec.getArgs());\n        collector.args(\"-c\");\n        if (spec.isPositionIndependentCode()) {\n            if (!OperatingSystem.current().isWindows()) {\n                collector.args(\"-fPIC\");\n            }\n        }\n    }","id":89886,"modified_method":"public void collectArguments(T spec, ArgCollector collector) {\n        for (String macroArg : new MacroArgsConverter().transform(spec.getMacros())) {\n            collector.args(\"-D\", macroArg);\n        }\n\n        collector.args(spec.getArgs());\n        collector.args(\"-c\");\n        if (spec.isPositionIndependentCode()) {\n            if (!OperatingSystem.current().isWindows()) {\n                collector.args(\"-fPIC\");\n            }\n        }\n    }","commit_id":"d6e940ee7711aff0cdc0c39752870cbd0a0bdf8b","url":"https://github.com/gradle/gradle"},{"original_method":"public void collectArguments(T spec, ArgCollector collector) {\n        collector.args(\"/nologo\");\n        for (String macro : spec.getMacros()) {\n            collector.args(\"/D\" + macro);\n        }\n        collector.args(spec.getArgs());\n        collector.args(\"/c\");\n        if (spec.isPositionIndependentCode()) {\n            collector.args(\"/LD\"); // TODO:DAZ Not sure if this has any effect at compile time\n        }\n        for (File file : spec.getIncludeRoots()) {\n            collector.args(\"/I\", file.getAbsolutePath());\n        }\n        for (File file : spec.getSource()) {\n            collector.args(file);\n        }\n    }","id":89887,"modified_method":"public void collectArguments(T spec, ArgCollector collector) {\n        collector.args(\"/nologo\");\n\n        for (String macroArg : new MacroArgsConverter().transform(spec.getMacros())) {\n            collector.args(\"/D\" + macroArg);\n        }\n        collector.args(spec.getArgs());\n        collector.args(\"/c\");\n        if (spec.isPositionIndependentCode()) {\n            collector.args(\"/LD\"); // TODO:DAZ Not sure if this has any effect at compile time\n        }\n        for (File file : spec.getIncludeRoots()) {\n            collector.args(\"/I\", file.getAbsolutePath());\n        }\n        for (File file : spec.getSource()) {\n            collector.args(file);\n        }\n    }","commit_id":"d6e940ee7711aff0cdc0c39752870cbd0a0bdf8b","url":"https://github.com/gradle/gradle"},{"original_method":"public static <T> List<T> findAll(Collection<? extends T> collection, Condition<T> condition) {\n    final ArrayList<T> result = new ArrayList<T>();\n    for (final T t : collection) {\n      if (condition.value(t)) {\n        result.add(t);\n      }\n    }\n    return result;\n  }","id":89888,"modified_method":"public static <T> List<T> findAll(Collection<? extends T> collection, Condition<? super T> condition) {\n    final ArrayList<T> result = new ArrayList<T>();\n    for (final T t : collection) {\n      if (condition.value(t)) {\n        result.add(t);\n      }\n    }\n    return result;\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T, Original> DataAccessor<T> createConvertor(final DataAccessor<Original> original,\n                                                              final Convertor<Original, T> convertor) {\n    return new DataAccessor<T>(){\n      public T getImpl(DataContext dataContext) throws NoDataException {\n        return convertor.convert(original.getNotNull(dataContext));\n      }\n    };\n  }","id":89889,"modified_method":"public static <T, Original> DataAccessor<T> createConvertor(final DataAccessor<Original> original,\n                                                              final Function<Original, T> convertor) {\n    return new DataAccessor<T>(){\n      public T getImpl(DataContext dataContext) throws NoDataException {\n        return convertor.fun(original.getNotNull(dataContext));\n      }\n    };\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T, Original> DataAccessor/*<T[]>*/ createArrayConvertor(final DataAccessor/*<Original[]>*/ original, final Convertor<Original, T> convertor, final Class<T> aClass) {\n    return new DataAccessor/*<T[]>*/() {\n      public Object /*T[]*/ getImpl(DataContext dataContext) throws NoDataException {\n        ArrayList<T> converted = CollectUtil.SKIP_NULLS.toList((Object[])original.getNotNull(dataContext), convertor);\n        return converted.toArray((Object[]/*T[]*/)Array.newInstance(aClass, converted.size()));\n      }\n    };\n  }","id":89890,"modified_method":"public static <T, Original> DataAccessor<T[]> createArrayConvertor(final DataAccessor<Original[]> original, final Function<Original, T> convertor, final Class<T> aClass) {\n    return new DataAccessor<T[]>() {\n      public T[] getImpl(DataContext dataContext) throws NoDataException {\n        List<T> converted = skipNulls(map(original.getNotNull(dataContext), convertor));\n        return converted.toArray((T[])Array.newInstance(aClass, converted.size()));\n      }\n    };\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String expandSilentMarcos(String str, boolean firstQueueExpand, DataContext dataContext) throws Macro.ExecutionCancelledException {\n    return expandMacroSet(str, firstQueueExpand, dataContext,\n                          ConvertingIterator.create(getMacros(), new Convertor<Macro, Macro>() {\n                            public Macro convert(Macro macro) {\n                              if (macro instanceof PromptMacro)\n                                return new Macro.Silent(macro, \"\");\n                              return macro;\n                            }\n                          }));\n  }","id":89891,"modified_method":"public String expandSilentMarcos(String str, boolean firstQueueExpand, DataContext dataContext) throws Macro.ExecutionCancelledException {\n    return expandMacroSet(str, firstQueueExpand, dataContext,\n                          ConvertingIterator.create(getMacros().iterator(), new Convertor<Macro, Macro>() {\n                            public Macro convert(Macro macro) {\n                              if (macro instanceof PromptMacro)\n                                return new Macro.Silent(macro, \"\");\n                              return macro;\n                            }\n                          }));\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Iterator<Macro> getMacros() {\n    return myMacrosMap.values().iterator();\n  }","id":89892,"modified_method":"public Collection<Macro> getMacros() {\n    return myMacrosMap.values();\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void cacheMacrosPreview(DataContext dataContext) {\n    dataContext = getCorrectContext(dataContext);\n    Iterator<Macro> macros = getMacros();\n    while (macros.hasNext()) {\n      Macro macro = macros.next();\n      macro.cachePreview(dataContext);\n    }\n  }","id":89893,"modified_method":"public void cacheMacrosPreview(DataContext dataContext) {\n    dataContext = getCorrectContext(dataContext);\n    for (Macro macro : getMacros()) {\n      macro.cachePreview(dataContext);\n    }\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Expands all macros that are found in the <code>str<\/code>.\n   */\n  public String expandMacrosInString(String str, boolean firstQueueExpand, DataContext dataContext) throws Macro.ExecutionCancelledException {\n    return expandMacroSet(str, firstQueueExpand, dataContext, getMacros());\n  }","id":89894,"modified_method":"/**\n   * Expands all macros that are found in the <code>str<\/code>.\n   */\n  public String expandMacrosInString(String str, boolean firstQueueExpand, DataContext dataContext) throws Macro.ExecutionCancelledException {\n    return expandMacroSet(str, firstQueueExpand, dataContext, getMacros().iterator());\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void init() {\n    super.init();\n\n    ArrayList<Macro> macros = CollectUtil.COLLECT.toList(MacroManager.getInstance().getMacros());\n    Collections.sort(macros, new Comparator() {\n      public int compare(Object o1, Object o2) {\n        String name1 = ((Macro)o1).getName();\n        String name2 = ((Macro)o2).getName();\n        if (!StringUtil.startsWithChar(name1, '/')) {\n          name1 = ZERO + name1;\n        }\n        if (!StringUtil.startsWithChar(name2, '/')) {\n          name2 = ZERO + name2;\n        }\n        return name1.compareToIgnoreCase(name2);\n      }\n      private final String ZERO = new String(new char[] {0});\n    });\n    for (Iterator<Macro> iterator = macros.iterator(); iterator.hasNext();) {\n      Macro macro = iterator.next();\n      myMacrosModel.addElement(new MacroWrapper(macro));\n    }\n\n    addListeners();\n    if (myMacrosModel.size() > 0){\n      myMacrosList.setSelectedIndex(0);\n    }\n    else{\n      setOKActionEnabled(false);\n    }\n  }","id":89895,"modified_method":"protected void init() {\n    super.init();\n\n    java.util.List<Macro> macros = new ArrayList<Macro>(MacroManager.getInstance().getMacros());\n    Collections.sort(macros, new Comparator<Macro>() {\n      public int compare(Macro macro1, Macro macro2) {\n        String name1 = macro1.getName();\n        String name2 = macro2.getName();\n        if (!StringUtil.startsWithChar(name1, '/')) {\n          name1 = ZERO + name1;\n        }\n        if (!StringUtil.startsWithChar(name2, '/')) {\n          name2 = ZERO + name2;\n        }\n        return name1.compareToIgnoreCase(name2);\n      }\n      private final String ZERO = new String(new char[] {0});\n    });\n    for (Macro macro : macros) {\n      myMacrosModel.addElement(new MacroWrapper(macro));\n    }\n\n    addListeners();\n    if (myMacrosModel.size() > 0){\n      myMacrosList.setSelectedIndex(0);\n    }\n    else{\n      setOKActionEnabled(false);\n    }\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return {@link VirtualFile}s on local file system (returns jars as files).\n   */\n  public List<VirtualFile> getVirtualFiles() {\n    return CollectUtil.SKIP_NULLS.toList(getPathList().iterator(), PATH_TO_LOCAL_VFILE);\n  }","id":89896,"modified_method":"/**\n   * @return {@link VirtualFile}s on local file system (returns jars as files).\n   */\n  public List<VirtualFile> getVirtualFiles() {\n    return skipNulls(map(getPathList(), PATH_TO_LOCAL_VFILE));\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addAllFiles(List<File> classpathList) {\n    for (Iterator<File> iterator = classpathList.iterator(); iterator.hasNext();) {\n      File file = iterator.next();\n      add(PathUtil.getCanonicalPath(file.getAbsolutePath()).replace('/', File.separatorChar));\n    }\n  }","id":89897,"modified_method":"public void addAllFiles(List<File> classpathList) {\n    for (File file : classpathList) {\n      add(PathUtil.getCanonicalPath(file.getAbsolutePath()).replace('/', File.separatorChar));\n    }\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Iterator<String> chooseFirstTimeItems(String path) {\n    if (path == null) {\n      return ADD_NOTHING;\n    }\n    final StringTokenizer tokenizer = new StringTokenizer(path, File.pathSeparator);\n    // in JDK 1.5 StringTokenizer implements Enumeration<Object> rather then Enumeration<String>, need to convert\n    final Enumeration<String> en = new Enumeration<String>() {\n      public boolean hasMoreElements() {\n        return tokenizer.hasMoreElements();\n      }\n\n      public String nextElement() {\n        return (String)tokenizer.nextElement();\n      }\n    };\n    return FilteringIterator.create(ContainerUtil.iterate(en), new Condition<String>() {\n      public boolean value(String element) {\n        element = element.trim();\n        if (element.length() == 0) {\n          return false;\n        }\n        return !myPathSet.contains(element);\n      }\n    });\n  }","id":89898,"modified_method":"private Iterator<String> chooseFirstTimeItems(String path) {\n    if (path == null) {\n      return ADD_NOTHING;\n    }\n    final StringTokenizer tokenizer = new StringTokenizer(path, File.pathSeparator);\n    // in JDK 1.5 StringTokenizer implements Enumeration<Object> rather then Enumeration<String>, need to convert\n    final Enumeration<String> en = new Enumeration<String>() {\n      public boolean hasMoreElements() {\n        return tokenizer.hasMoreElements();\n      }\n\n      public String nextElement() {\n        return (String)tokenizer.nextElement();\n      }\n    };\n    return FilteringIterator.create(iterate(en), new Condition<String>() {\n      public boolean value(String element) {\n        element = element.trim();\n        return element.length() != 0 && !myPathSet.contains(element);\n      }\n    });\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPathsString() {\n    final StringBuffer buffer = new StringBuffer();\n    String separator = \"\";\n    final List<String> classPath = getPathList();\n    for (Iterator iterator = classPath.iterator(); iterator.hasNext();) {\n      String path = (String) iterator.next();\n      buffer.append(separator);\n      buffer.append(path);\n      separator = File.pathSeparator;\n    }\n    return buffer.toString();\n  }","id":89899,"modified_method":"public String getPathsString() {\n    final StringBuffer buffer = new StringBuffer();\n    String separator = \"\";\n    final List<String> classPath = getPathList();\n    for (final String path : classPath) {\n      buffer.append(separator);\n      buffer.append(path);\n      separator = File.pathSeparator;\n    }\n    return buffer.toString();\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return The same as {@link #getVirtualFiles()} but returns jars as {@link JarFileSystem} roots.\n   */\n  public List<VirtualFile> getRootDirs() {\n    return CollectUtil.SKIP_NULLS.toList(getPathList().iterator(), PATH_TO_DIR);\n  }","id":89900,"modified_method":"/**\n   * @return The same as {@link #getVirtualFiles()} but returns jars as {@link JarFileSystem} roots.\n   */\n  public List<VirtualFile> getRootDirs() {\n    return skipNulls(map(getPathList(), PATH_TO_DIR));\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void add(VirtualFile file) {\n    add(LOCAL_PATH.convert(file));\n  }","id":89901,"modified_method":"public void add(VirtualFile file) {\n    add(LOCAL_PATH.fun(file));\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addAll(List<String> allClasspath) {\n    for (Iterator<String> iterator = allClasspath.iterator(); iterator.hasNext();) {\n      String path = iterator.next();\n      add(path);\n    }\n  }","id":89902,"modified_method":"public void addAll(List<String> allClasspath) {\n    for (String path : allClasspath) {\n      add(path);\n    }\n  }","commit_id":"02eaabd03c4866affc86c4bcfc45df5cf2478bfd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void generateHealthReport(JspWriter out, NameNode nn,\n        HttpServletRequest request) throws IOException {\n      FSNamesystem fsn = nn.getNamesystem();\n      final DatanodeManager dm = fsn.getBlockManager().getDatanodeManager();\n      final List<DatanodeDescriptor> live = new ArrayList<DatanodeDescriptor>();\n      final List<DatanodeDescriptor> dead = new ArrayList<DatanodeDescriptor>();\n      dm.fetchDatanodes(live, dead, true);\n\n      int liveDecommissioned = 0;\n      for (DatanodeDescriptor d : live) {\n        liveDecommissioned += d.isDecommissioned() ? 1 : 0;\n      }\n\n      int deadDecommissioned = 0;\n      for (DatanodeDescriptor d : dead) {\n        deadDecommissioned += d.isDecommissioned() ? 1 : 0;\n      }\n      \n      final List<DatanodeDescriptor> decommissioning = dm.getDecommissioningNodes();\n\n      sorterField = request.getParameter(\"sorter/field\");\n      sorterOrder = request.getParameter(\"sorter/order\");\n      if (sorterField == null)\n        sorterField = \"name\";\n      if (sorterOrder == null)\n        sorterOrder = \"ASC\";\n\n      // Find out common suffix. Should this be before or after the sort?\n      String port_suffix = null;\n      if (live.size() > 0) {\n        String name = live.get(0).getName();\n        int idx = name.indexOf(':');\n        if (idx > 0) {\n          port_suffix = name.substring(idx);\n        }\n\n        for (int i = 1; port_suffix != null && i < live.size(); i++) {\n          if (live.get(i).getName().endsWith(port_suffix) == false) {\n            port_suffix = null;\n            break;\n          }\n        }\n      }\n\n      counterReset();\n      long[] fsnStats = fsn.getStats();\n      long total = fsnStats[0];\n      long remaining = fsnStats[2];\n      long used = fsnStats[1];\n      long nonDFS = total - remaining - used;\n      nonDFS = nonDFS < 0 ? 0 : nonDFS;\n      float percentUsed = DFSUtil.getPercentUsed(used, total);\n      float percentRemaining = DFSUtil.getPercentRemaining(remaining, total);\n      float median = 0;\n      float max = 0;\n      float min = 0;\n      float dev = 0;\n      \n      if (live.size() > 0) {\n        float totalDfsUsed = 0;\n        float[] usages = new float[live.size()];\n        int i = 0;\n        for (DatanodeDescriptor dn : live) {\n          usages[i++] = dn.getDfsUsedPercent();\n          totalDfsUsed += dn.getDfsUsedPercent();\n        }\n        totalDfsUsed /= live.size();\n        Arrays.sort(usages);\n        median = usages[usages.length/2];\n        max = usages[usages.length - 1];\n        min = usages[0];\n        \n        for (i = 0; i < usages.length; i++) {\n          dev += (usages[i] - totalDfsUsed) * (usages[i] - totalDfsUsed);\n        }\n        dev = (float) Math.sqrt(dev/usages.length);\n      }\n\n      long bpUsed = fsnStats[6];\n      float percentBpUsed = DFSUtil.getPercentUsed(bpUsed, total);\n      \n      out.print(\"<div id=\\\"dfstable\\\"> <table>\\n\" + rowTxt() + colTxt()\n          + \"Configured Capacity\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(total) + rowTxt() + colTxt() + \"DFS Used\"\n          + colTxt() + \":\" + colTxt() + StringUtils.byteDesc(used) + rowTxt()\n          + colTxt() + \"Non DFS Used\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(nonDFS) + rowTxt() + colTxt()\n          + \"DFS Remaining\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(remaining) + rowTxt() + colTxt() + \"DFS Used%\"\n          + colTxt() + \":\" + colTxt()\n          + StringUtils.limitDecimalTo2(percentUsed) + \" %\" + rowTxt()\n          + colTxt() + \"DFS Remaining%\" + colTxt() + \":\" + colTxt()\n          + StringUtils.limitDecimalTo2(percentRemaining) + \" %\"\n          + rowTxt() + colTxt() + \"Block Pool Used\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(bpUsed) + rowTxt()\n          + colTxt() + \"Block Pool Used%\"+ colTxt() + \":\" + colTxt()\n          + StringUtils.limitDecimalTo2(percentBpUsed) + \" %\" \n          + rowTxt() + colTxt() + \"DataNodes usages\" + colTxt() + \":\" + colTxt()\n          + \"Min %\" + colTxt() + \"Median %\" + colTxt() + \"Max %\" + colTxt()\n          + \"stdev %\" + rowTxt() + colTxt() + colTxt() + colTxt()\n          + StringUtils.limitDecimalTo2(min) + \" %\"\n          + colTxt() + StringUtils.limitDecimalTo2(median) + \" %\"\n          + colTxt() + StringUtils.limitDecimalTo2(max) + \" %\"\n          + colTxt() + StringUtils.limitDecimalTo2(dev) + \" %\"\n          + rowTxt() + colTxt()\n          + \"<a href=\\\"dfsnodelist.jsp?whatNodes=LIVE\\\">Live Nodes<\/a> \"\n          + colTxt() + \":\" + colTxt() + live.size()\n          + \" (Decommissioned: \" + liveDecommissioned + \")\"\n          + rowTxt() + colTxt()\n          + \"<a href=\\\"dfsnodelist.jsp?whatNodes=DEAD\\\">Dead Nodes<\/a> \"\n          + colTxt() + \":\" + colTxt() + dead.size() \n          + \" (Decommissioned: \" + deadDecommissioned + \")\"\n          + rowTxt() + colTxt()\n          + \"<a href=\\\"dfsnodelist.jsp?whatNodes=DECOMMISSIONING\\\">\"\n          + \"Decommissioning Nodes<\/a> \"\n          + colTxt() + \":\" + colTxt() + decommissioning.size() \n          + rowTxt() + colTxt(\"Excludes missing blocks.\")\n          + \"Number of Under-Replicated Blocks\" + colTxt() + \":\" + colTxt()\n          + fsn.getBlockManager().getUnderReplicatedNotMissingBlocks()\n          + \"<\/table><\/div><br>\\n\");\n\n      if (live.isEmpty() && dead.isEmpty()) {\n        out.print(\"There are no datanodes in the cluster\");\n      }\n    }","id":89903,"modified_method":"void generateHealthReport(JspWriter out, NameNode nn,\n        HttpServletRequest request) throws IOException {\n      FSNamesystem fsn = nn.getNamesystem();\n      final DatanodeManager dm = fsn.getBlockManager().getDatanodeManager();\n      final List<DatanodeDescriptor> live = new ArrayList<DatanodeDescriptor>();\n      final List<DatanodeDescriptor> dead = new ArrayList<DatanodeDescriptor>();\n      dm.fetchDatanodes(live, dead, true);\n\n      int liveDecommissioned = 0;\n      for (DatanodeDescriptor d : live) {\n        liveDecommissioned += d.isDecommissioned() ? 1 : 0;\n      }\n\n      int deadDecommissioned = 0;\n      for (DatanodeDescriptor d : dead) {\n        deadDecommissioned += d.isDecommissioned() ? 1 : 0;\n      }\n      \n      final List<DatanodeDescriptor> decommissioning = dm.getDecommissioningNodes();\n\n      sorterField = request.getParameter(\"sorter/field\");\n      sorterOrder = request.getParameter(\"sorter/order\");\n      if (sorterField == null)\n        sorterField = \"name\";\n      if (sorterOrder == null)\n        sorterOrder = \"ASC\";\n\n      // Find out common suffix. Should this be before or after the sort?\n      String port_suffix = null;\n      if (live.size() > 0) {\n        String name = live.get(0).getName();\n        int idx = name.indexOf(':');\n        if (idx > 0) {\n          port_suffix = name.substring(idx);\n        }\n\n        for (int i = 1; port_suffix != null && i < live.size(); i++) {\n          if (live.get(i).getName().endsWith(port_suffix) == false) {\n            port_suffix = null;\n            break;\n          }\n        }\n      }\n\n      counterReset();\n      long[] fsnStats = fsn.getStats();\n      long total = fsnStats[0];\n      long remaining = fsnStats[2];\n      long used = fsnStats[1];\n      long nonDFS = total - remaining - used;\n      nonDFS = nonDFS < 0 ? 0 : nonDFS;\n      float percentUsed = DFSUtil.getPercentUsed(used, total);\n      float percentRemaining = DFSUtil.getPercentRemaining(remaining, total);\n      float median = 0;\n      float max = 0;\n      float min = 0;\n      float dev = 0;\n      \n      if (live.size() > 0) {\n        float totalDfsUsed = 0;\n        float[] usages = new float[live.size()];\n        int i = 0;\n        for (DatanodeDescriptor dn : live) {\n          usages[i++] = dn.getDfsUsedPercent();\n          totalDfsUsed += dn.getDfsUsedPercent();\n        }\n        totalDfsUsed /= live.size();\n        Arrays.sort(usages);\n        median = usages[usages.length/2];\n        max = usages[usages.length - 1];\n        min = usages[0];\n        \n        for (i = 0; i < usages.length; i++) {\n          dev += (usages[i] - totalDfsUsed) * (usages[i] - totalDfsUsed);\n        }\n        dev = (float) Math.sqrt(dev/usages.length);\n      }\n\n      long bpUsed = fsnStats[6];\n      float percentBpUsed = DFSUtil.getPercentUsed(bpUsed, total);\n\n      // don't show under-replicated/missing blocks or corrupt files for SBN\n      // since the standby namenode doesn't compute replication queues \n      String underReplicatedBlocks = \"\";\n      if (nn.getServiceState() == HAServiceState.ACTIVE) {\n    \t  underReplicatedBlocks = new String(rowTxt() \n              + colTxt(\"Excludes missing blocks.\")\n              + \"Number of Under-Replicated Blocks\" + colTxt() + \":\" + colTxt()\n              + fsn.getBlockManager().getUnderReplicatedNotMissingBlocks()); \n      }\n      out.print(\"<div id=\\\"dfstable\\\"> <table>\\n\" + rowTxt() + colTxt()\n          + \"Configured Capacity\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(total) + rowTxt() + colTxt() + \"DFS Used\"\n          + colTxt() + \":\" + colTxt() + StringUtils.byteDesc(used) + rowTxt()\n          + colTxt() + \"Non DFS Used\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(nonDFS) + rowTxt() + colTxt()\n          + \"DFS Remaining\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(remaining) + rowTxt() + colTxt() + \"DFS Used%\"\n          + colTxt() + \":\" + colTxt()\n          + StringUtils.limitDecimalTo2(percentUsed) + \" %\" + rowTxt()\n          + colTxt() + \"DFS Remaining%\" + colTxt() + \":\" + colTxt()\n          + StringUtils.limitDecimalTo2(percentRemaining) + \" %\"\n          + rowTxt() + colTxt() + \"Block Pool Used\" + colTxt() + \":\" + colTxt()\n          + StringUtils.byteDesc(bpUsed) + rowTxt()\n          + colTxt() + \"Block Pool Used%\"+ colTxt() + \":\" + colTxt()\n          + StringUtils.limitDecimalTo2(percentBpUsed) + \" %\" \n          + rowTxt() + colTxt() + \"DataNodes usages\" + colTxt() + \":\" + colTxt()\n          + \"Min %\" + colTxt() + \"Median %\" + colTxt() + \"Max %\" + colTxt()\n          + \"stdev %\" + rowTxt() + colTxt() + colTxt() + colTxt()\n          + StringUtils.limitDecimalTo2(min) + \" %\"\n          + colTxt() + StringUtils.limitDecimalTo2(median) + \" %\"\n          + colTxt() + StringUtils.limitDecimalTo2(max) + \" %\"\n          + colTxt() + StringUtils.limitDecimalTo2(dev) + \" %\"\n          + rowTxt() + colTxt()\n          + \"<a href=\\\"dfsnodelist.jsp?whatNodes=LIVE\\\">Live Nodes<\/a> \"\n          + colTxt() + \":\" + colTxt() + live.size()\n          + \" (Decommissioned: \" + liveDecommissioned + \")\"\n          + rowTxt() + colTxt()\n          + \"<a href=\\\"dfsnodelist.jsp?whatNodes=DEAD\\\">Dead Nodes<\/a> \"\n          + colTxt() + \":\" + colTxt() + dead.size() \n          + \" (Decommissioned: \" + deadDecommissioned + \")\"\n          + rowTxt() + colTxt()\n          + \"<a href=\\\"dfsnodelist.jsp?whatNodes=DECOMMISSIONING\\\">\"\n          + \"Decommissioning Nodes<\/a> \"\n          + colTxt() + \":\" + colTxt() + decommissioning.size()\n          + underReplicatedBlocks\n          + \"<\/table><\/div><br>\\n\");\n\n      if (live.isEmpty() && dead.isEmpty()) {\n        out.print(\"There are no datanodes in the cluster\");\n      }\n    }","commit_id":"acacde55e6a4488cd749eba630ff2e68c4dc5c63","url":"https://github.com/apache/hadoop"},{"original_method":"private void checkCompleteNodesWithoutCoordinates() {\n        for (Node node:dataSet.getNodes()) {\n            if (!node.isIncomplete() && (node.getCoor() == null || node.getEastNorth() == null)) {\n                writer.println(String.format(\"%s is not incomplete but has null coordinates\", node));\n            }\n        }\n    }","id":89904,"modified_method":"private void checkCompleteNodesWithoutCoordinates() {\n        for (Node node:dataSet.getNodes()) {\n            if (!node.isIncomplete() && (node.getCoor() == null || node.getEastNorth() == null)) {\n                printError(\"COMPLETE WITHOUT COORDINATES\", \"%s is not incomplete but has null coordinates\", node);\n            }\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void checkReferredPrimitive(OsmPrimitive primitive, OsmPrimitive parent) {\n        if (dataSet.getPrimitiveById(primitive) == null) {\n            writer.println(String.format(\"%s is referenced by %s but not found in dataset\", primitive, parent));\n        }\n        if (dataSet.getPrimitiveById(primitive) != primitive) {\n            writer.println(String.format(\"%s is different instance that referred by %s\", primitive, parent));\n        }\n        if (primitive.isDeleted()) {\n            writer.println(String.format(\"%s refers to deleted primitive %s\", parent, primitive));\n        }\n    }","id":89905,"modified_method":"private void checkReferredPrimitive(OsmPrimitive primitive, OsmPrimitive parent) {\n        if (dataSet.getPrimitiveById(primitive) == null) {\n            printError(\"REFERENCED BUT NOT IN DATA\", \"%s is referenced by %s but not found in dataset\", primitive, parent);\n        }\n        if (dataSet.getPrimitiveById(primitive) != primitive) {\n            printError(\"DIFFERENT INSTANCE\", \"%s is different instance that referred by %s\", primitive, parent);\n        }\n        if (primitive.isDeleted()) {\n            printError(\"DELETED REFERENCED\", \"%s refers to deleted primitive %s\", parent, primitive);\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void searchWays() {\n        for (Way w:dataSet.getWays()) {\n            if (!w.isIncomplete() && !w.isDeleted() && !dataSet.searchWays(w.getBBox()).contains(w)) {\n                writer.println(String.format(\"%s not found using Dataset.searchWays()\", w));\n            }\n        }\n    }","id":89906,"modified_method":"private void searchWays() {\n        for (Way w:dataSet.getWays()) {\n            if (!w.isIncomplete() && !w.isDeleted() && !dataSet.searchWays(w.getBBox()).contains(w)) {\n                printError(\"SEARCH WAYS\", \"%s not found using Dataset.searchWays()\", w);\n            }\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void checkReferrers() {\n        for (Way way:dataSet.getWays()) {\n            if (!way.isDeleted()) {\n                for (Node n:way.getNodes()) {\n                    if (!n.getReferrers().contains(way)) {\n                        writer.println(String.format(\"%s is part of %s but is not in referrers\", n, way));\n                    }\n                }\n            }\n        }\n\n        for (Relation relation:dataSet.getRelations()) {\n            if (!relation.isDeleted()) {\n                for (RelationMember m:relation.getMembers()) {\n                    if (!m.getMember().getReferrers().contains(relation)) {\n                        writer.println(String.format(\"%s is part of %s but is not in referrers\", m.getMember(), relation));\n                    }\n                }\n            }\n        }\n    }","id":89907,"modified_method":"private void checkReferrers() {\n        for (Way way:dataSet.getWays()) {\n            if (!way.isDeleted()) {\n                for (Node n:way.getNodes()) {\n                    if (!n.getReferrers().contains(way)) {\n                        printError(\"WAY NOT IN REFERRERS\", \"%s is part of %s but is not in referrers\", n, way);\n                    }\n                }\n            }\n        }\n\n        for (Relation relation:dataSet.getRelations()) {\n            if (!relation.isDeleted()) {\n                for (RelationMember m:relation.getMembers()) {\n                    if (!m.getMember().getReferrers().contains(relation)) {\n                        printError(\"RELATION NOT IN REFERRERS\", \"%s is part of %s but is not in referrers\", m.getMember(), relation);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void checkCompleteWaysWithIncompleteNodes() {\n        for (Way way:dataSet.getWays()) {\n            if (way.isUsable()) {\n                for (Node node:way.getNodes()) {\n                    if (node.isIncomplete()) {\n                        writer.println(String.format(\"%s is usable but contains incomplete node '%s'\", way, node));\n                    }\n                }\n            }\n        }\n    }","id":89908,"modified_method":"private void checkCompleteWaysWithIncompleteNodes() {\n        for (Way way:dataSet.getWays()) {\n            if (way.isUsable()) {\n                for (Node node:way.getNodes()) {\n                    if (node.isIncomplete()) {\n                        printError(\"USABLE HAS INCOMPLETE\", \"%s is usable but contains incomplete node '%s'\", way, node);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void checkZeroNodesWays() {\n        for (Way way:dataSet.getWays()) {\n            if (way.isUsable() && way.getNodesCount() == 0) {\n                writer.println(String.format(\"Way %s has zero nodes\", way));\n            } else if (way.isUsable() && way.getNodesCount() == 1) {\n                writer.println(String.format(\"Way %s has only one node\", way));\n            }\n        }\n    }","id":89909,"modified_method":"private void checkZeroNodesWays() {\n        for (Way way:dataSet.getWays()) {\n            if (way.isUsable() && way.getNodesCount() == 0) {\n                printError(\"WARN - ZERO NODES\", \"Way %s has zero nodes\", way);\n            } else if (way.isUsable() && way.getNodesCount() == 1) {\n                printError(\"WARN - NO NODES\", \"Way %s has only one node\", way);\n            }\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void searchNodes() {\n        for (Node n:dataSet.getNodes()) {\n            if (!n.isIncomplete() && !n.isDeleted()) {\n                LatLon c = n.getCoor();\n                BBox box = new BBox(new LatLon(c.lat() - 0.0001, c.lon() - 0.0001), new LatLon(c.lat() + 0.0001, c.lon() + 0.0001));\n                if (!dataSet.searchNodes(box).contains(n)) {\n                    writer.println(String.format(\"%s not found using Dataset.searchNodes()\", n));\n                }\n            }\n        }\n    }","id":89910,"modified_method":"private void searchNodes() {\n        for (Node n:dataSet.getNodes()) {\n            if (!n.isIncomplete() && !n.isDeleted()) {\n                LatLon c = n.getCoor();\n                BBox box = new BBox(new LatLon(c.lat() - 0.0001, c.lon() - 0.0001), new LatLon(c.lat() + 0.0001, c.lon() + 0.0001));\n                if (!dataSet.searchNodes(box).contains(n)) {\n                    printError(\"SEARCH NODES\", \"%s not found using Dataset.searchNodes()\", n);\n                }\n            }\n        }\n    }","commit_id":"ff3b32f4a5370a43e38232154f1887f73fc110d6","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n   * Evaluates the expression.\r\n   * @param ctx query context\r\n   * @param seq sequence to be checked\r\n   * @return resulting item\r\n   * @throws QueryException query exception\r\n   */\r\n  Iter iter(final QueryContext ctx, final Iter seq) throws QueryException {\r\n    if(var.type != null && !var.type.instance(seq)) return null;\r\n    if(var.name == null) return ctx.iter(expr);\r\n\r\n    final int s = ctx.vars.size();\r\n    ctx.vars.add(var.bind(seq.finish(), ctx).copy());\r\n    final Iter ir = ctx.iter(expr);\r\n    ctx.vars.reset(s);\r\n    return ir;\r\n  }","id":89911,"modified_method":"/**\r\n   * Evaluates the expression.\r\n   * @param ctx query context\r\n   * @param seq sequence to be checked\r\n   * @return resulting item\r\n   * @throws QueryException query exception\r\n   */\r\n  Iter iter(final QueryContext ctx, final Iter seq) throws QueryException {\r\n    if(var.type != null && !var.type.instance(seq)) return null;\r\n    if(var.name == null) return ctx.iter(expr);\r\n\r\n    final int s = ctx.vars.size();\r\n    ctx.vars.add(var.bind(seq.finish(), ctx).copy());\r\n    final Item im = ctx.iter(expr).finish();\r\n    ctx.vars.reset(s);\r\n    return im.iter();\r\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Compiles the expression.\r\n   * @param ctx query context\r\n   * @param it item to be bound\r\n   * @return resulting item\r\n   * @throws QueryException query exception\r\n   */\r\n  public Case comp(final QueryContext ctx, final Item it)\r\n      throws QueryException {\r\n    if(var.name == null) {\r\n      super.comp(ctx);\r\n    } else {\r\n      final int s = ctx.vars.size();\r\n      ctx.vars.add(var.bind(it, ctx).copy());\r\n      super.comp(ctx);\r\n      ctx.vars.reset(s);\r\n    }\r\n    return this;\r\n  }","id":89912,"modified_method":"/**\r\n   * Compiles the expression.\r\n   * @param ctx query context\r\n   * @param it item to be bound\r\n   * @return resulting item\r\n   * @throws QueryException query exception\r\n   */\r\n  public Case comp(final QueryContext ctx, final Item it)\r\n      throws QueryException {\r\n    if(var.name == null) {\r\n      super.comp(ctx);\r\n    } else {\r\n      final int s = ctx.vars.size();\r\n      ctx.vars.add(it == null ? var : var.bind(it, ctx).copy());\r\n      super.comp(ctx);\r\n      ctx.vars.reset(s);\r\n    }\r\n    return this;\r\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Case comp(final QueryContext ctx) throws QueryException {\r\n    if(var.name == null) {\r\n      super.comp(ctx);\r\n    } else {\r\n      final int s = ctx.vars.size();\r\n      ctx.vars.add(var);\r\n      super.comp(ctx);\r\n      ctx.vars.reset(s);\r\n    }\r\n    return this;\r\n  }","id":89913,"modified_method":"@Override\r\n  public Case comp(final QueryContext ctx) throws QueryException {\r\n    return comp(ctx, null);\r\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public final String toString() {\n    return path;\n  }","id":89914,"modified_method":"@Override\n  public String toString() {\n    return path;\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    final Iter t = SeqIter.get(expr[0].iter(ctx));\n    final Item i = t.next();\n\n    // check target constraints\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(t.size() != 1) Err.or(UPWRTRGTYP, this);\n\n    CFrag ex = null;\n    if(i.type == Type.ELM) {\n      ex = new CElem(expr[1], new Expr[0], new Atts());\n    } else if(i.type == Type.ATT) {\n      ex = new CAttr(expr[1], new Expr[0], false);\n    } else if(i.type == Type.PI) {\n      ex = new CPI(expr[1], Seq.EMPTY);\n    } else {\n      Err.or(UPWRTRGTYP, this);\n    }\n    ctx.updates.add(new RenamePrimitive((Nod) i, ex.atomic(ctx).qname().ln()));\n    return Iter.EMPTY;\n  }","id":89915,"modified_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    final Iter t = SeqIter.get(expr[0].iter(ctx));\n    final Item i = t.next();\n\n    // check target constraints\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(t.size() != 1) Err.or(UPWRTRGTYP, this);\n\n    CFrag ex = null;\n    if(i.type == Type.ELM) {\n      ex = new CElem(expr[1], new Expr[0], new Atts());\n    } else if(i.type == Type.ATT) {\n      ex = new CAttr(expr[1], new Expr[0], false);\n    } else if(i.type == Type.PI) {\n      ex = new CPI(expr[1], Seq.EMPTY);\n    } else {\n      Err.or(UPWRTRGTYP, this);\n    }\n    ctx.updates.add(new RenamePrimitive((Nod) i, ex.atomic(ctx).nname()));\n    return Iter.EMPTY;\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public String toString() {\n    return RENAME + \"...\";\n  }","id":89916,"modified_method":"@Override\n  public String toString() {\n    return RENAME + ' ' + NODE + ' ' + expr[0] + ' ' + AS + ' ' + expr[1];\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    final int c = ctx.vars.size();\n    for(final Let fo : copies) {\n      // [LK] copied node is a DOC node ? ... attributes ?\n      final Data m = UpdateFunctions.buildDB(fo.expr.iter(ctx), null);\n      ctx.vars.add(fo.var.bind(new DBNode(m, 1), ctx).copy());\n    }\n    \n    final PendingUpdates upd = ctx.updates;\n    ctx.updates = new PendingUpdates();\n    expr[0].iter(ctx);\n    ctx.updates.apply();\n    ctx.updates = upd;\n\n    final Iter ir = expr[1].iter(ctx);\n    ctx.vars.reset(c);\n    return ir;\n  }","id":89917,"modified_method":"@Override\n  public Iter iter(final QueryContext ctx) throws QueryException {\n    final int c = ctx.vars.size();\n    for(final Let fo : copies) {\n      // [LK] copied node is a DOC node ? ... attributes ?\n      final Data m = UpdateFunctions.buildDB(fo.expr.iter(ctx), null);\n      ctx.vars.add(fo.var.bind(new DBNode(m, 1), ctx).copy());\n    }\n    \n    final PendingUpdates upd = ctx.updates;\n    ctx.updates = new PendingUpdates();\n    expr[0].iter(ctx);\n    ctx.updates.apply();\n    ctx.updates = upd;\n\n    final Item im = expr[1].iter(ctx).finish();\n    ctx.vars.reset(c);\n    return im.iter();\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public boolean uses(final Use u, final QueryContext ctx) {\n    return u != Use.UPD && super.uses(u, ctx);\n  }","id":89918,"modified_method":"@Override\n  public boolean uses(final Use u, final QueryContext ctx) {\n    return u == Use.VAR || u != Use.UPD && super.uses(u, ctx);\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Expr comp(final QueryContext ctx) throws QueryException {\r\n    ts = checkUp(ts, ctx).comp(ctx);\r\n\r\n    for(int c = 0; c < cs.length; c++) cs[c] = cs[c].comp(ctx);\r\n\r\n    boolean em = true;\r\n    final Expr[] tmp = new Expr[cs.length];\r\n    for(int i = 0; i < cs.length; i++) {\r\n      tmp[i] = cs[i].expr;\r\n      em &= tmp[i].e();\r\n    }\r\n    if(em) {\r\n      ctx.compInfo(OPTTRUE);\r\n      return Seq.EMPTY;\r\n    }\r\n    List.updating(ctx, tmp);\r\n\r\n    // pre-evaluate type switch\r\n    if(ts.i()) {\r\n      for(int c = 0; c < cs.length; c++) {\r\n        if(cs[c].var.type != null) {\r\n          if(cs[c].var.type.instance(ts.iter(ctx))) {\r\n            ctx.compInfo(OPTPRE, this);\r\n            return cs[c].comp(ctx, (Item) ts).expr;\r\n          }\r\n          cs = Array.delete(cs, c);\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  }","id":89919,"modified_method":"@Override\r\n  public Expr comp(final QueryContext ctx) throws QueryException {\r\n    ts = checkUp(ts, ctx).comp(ctx);\r\n    for(final Case c : cs) c.comp(ctx);\r\n\r\n    boolean em = true;\r\n    for(final Case c : cs) em &= c.e();\r\n    if(em) {\r\n      ctx.compInfo(OPTTRUE);\r\n      return Seq.EMPTY;\r\n    }\r\n\r\n    final Expr[] tmp = new Expr[cs.length];\r\n    for(int i = 0; i < cs.length; i++) tmp[i] = cs[i].expr;\r\n    List.updating(ctx, tmp);\r\n\r\n    // pre-evaluate type switch\r\n    if(ts.i()) {\r\n      for(int c = 0; c < cs.length; c++) {\r\n        if(cs[c].var.type != null) {\r\n          if(cs[c].var.type.instance(ts.iter(ctx))) {\r\n            ctx.compInfo(OPTPRE, this);\r\n            return cs[c].comp(ctx, (Item) ts).expr;\r\n          }\r\n          cs = Array.delete(cs, c);\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Initializes the code.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  void init(final String[] args) throws Exception {\n    final Args arg = new Args(args);\n    boolean o = true;\n    while(arg.more() && o) {\n      if(arg.dash()) {\n        final char c = arg.next();\n        if(c == 'r') {\n          reporting = true;\n          currTime = true;\n        } else if(c == 'p') {\n          path = arg.string() + \"/\";\n        } else if(c == 'v') {\n          verbose = true;\n        } else {\n          o = false;\n        }\n      } else {\n        single = arg.string();\n        maxout *= 10;\n      }\n    }\n\n    if(!o) {\n      Main.outln(NL + Main.name(this) + \" Test Suite [pat]\" + NL +\n          \" [pat] perform only tests with the specified pattern\" + NL +\n          \" -h show this help\" + NL +\n          \" -p change path\" + NL +\n          \" -r create report\" + NL +\n          \" -v verbose output\");\n      return;\n    }\n\n    queries = path + \"Queries/XQuery/\";\n    expected = path + \"ExpectedTestResults/\";\n    results = path + \"ReportingResults/Results/\";\n    report = path + \"ReportingResults/\";\n    sources = path + \"TestSources/\";\n\n    final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    final String dat = sdf.format(Calendar.getInstance().getTime());\n\n    final Performance perf = new Performance();\n    context.prop.set(Prop.XQFORMAT, false);\n    context.prop.set(Prop.MAINMEM, false);\n    context.prop.set(Prop.TABLEMEM, false);\n    context.prop.set(Prop.CHOP, false);\n\n    new CreateDB(path + input).execute(context);\n    data = context.data();\n\n    final Nodes root = new Nodes(0, data);\n    Main.outln(NL + Main.name(this) + \" Test Suite \" +\n        text(\"/*:test-suite/@version\", root));\n\n    Main.outln(NL + \"Caching Sources...\");\n    for(final int s : nodes(\"//*:source\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      srcs.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Modules...\");\n    for(final int s : nodes(\"//*:module\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      mods.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Collections...\");\n    for(final int c : nodes(\"//*:collection\", root).nodes) {\n      final Nodes nodes = new Nodes(c, data);\n      final String cname = text(\"@ID\", nodes);\n\n      final TokenList dl = new TokenList();\n      final Nodes doc = nodes(\"*:input-document\", nodes);\n      for(int d = 0; d < doc.size(); d++) {\n        dl.add(token(sources + string(data.atom(doc.nodes[d])) + \".xml\"));\n      }\n      colls.put(cname, dl.finish());\n    }\n    init(root);\n\n    if(reporting) {\n      Main.outln(\"Delete old results...\");\n      delete(new File[] { new File(results) });\n    }\n\n    Main.out(\"Parsing Queries\");\n    if(verbose) Main.outln();\n    final Nodes nodes = nodes(\"//*:test-case\", root);\n    //final Nodes nodes = nodes(\n    //  \"//*:test-group[starts-with(@name, 'Minimal')]//*:test-case\", root);\n    int total = nodes.size();\n    for(int t = 0; t < total; t++) {\n      if(!parse(new Nodes(nodes.nodes[t], data))) break;\n      if(!verbose && t % 1000 == 0) Main.out(\".\");\n    }\n    Main.outln();\n    total = ok + ok2 + err + err2;\n\n    final String time = perf.getTimer();\n    Main.outln(\"Writing log file...\" + NL);\n    BufferedWriter bw = new BufferedWriter(\n        new OutputStreamWriter(new FileOutputStream(path + pathlog), UTF8));\n    bw.write(\"TEST RESULTS ==================================================\");\n    bw.write(NL + NL + \"Total #Queries: \" + total + NL);\n    bw.write(\"Correct / Empty Results: \" + ok + \" / \" + ok2 + NL);\n    bw.write(\"Conformance (w/Empty Results): \");\n    bw.write(pc(ok, total) + \" / \" + pc(ok + ok2, total) + NL);\n    bw.write(\"Wrong Results / Errors: \" + err + \" / \" + err2 + NL);\n    bw.write(\"WRONG =========================================================\");\n    bw.write(NL + NL + logErr + NL);\n    bw.write(\"WRONG (ERRORS) ================================================\");\n    bw.write(NL + NL + logErr2 + NL);\n    bw.write(\"CORRECT? (EMPTY) ==============================================\");\n    bw.write(NL + NL + logOK2 + NL);\n    bw.write(\"CORRECT =======================================================\");\n    bw.write(NL + NL + logOK + NL);\n    bw.write(\"===============================================================\");\n    bw.close();\n\n    bw = new BufferedWriter(new FileWriter(pathhis, true));\n    bw.write(dat + \"\\t\" + ok + \"\\t\" + ok2 + \"\\t\" + err + \"\\t\" + err2 + NL);\n    bw.close();\n\n    if(reporting) {\n      bw = new BufferedWriter(new OutputStreamWriter(\n          new FileOutputStream(report + NAME + \".xml\"), UTF8));\n      write(bw, report + NAME + \"Pre.xml\");\n      bw.write(logReport.toString());\n      write(bw, report + NAME + \"Pos.xml\");\n      bw.close();\n    }\n\n    Main.outln(\"Total #Queries: \" + total);\n    Main.outln(\"Correct / Empty results: \" + ok + \" / \" + ok2);\n    Main.out(\"Conformance (w/empty results): \");\n    Main.outln(pc(ok, total) + \" / \" + pc(ok + ok2, total));\n    Main.outln(\"Total Time: \" + time);\n\n    context.close();\n  }","id":89920,"modified_method":"/**\n   * Initializes the code.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  void init(final String[] args) throws Exception {\n    final Args arg = new Args(args);\n    boolean o = true;\n    while(arg.more() && o) {\n      if(arg.dash()) {\n        final char c = arg.next();\n        if(c == 'r') {\n          reporting = true;\n          currTime = true;\n        } else if(c == 'd') {\n          debug = true;\n        } else if(c == 'p') {\n          path = arg.string() + \"/\";\n        } else if(c == 'v') {\n          verbose = true;\n        } else {\n          o = false;\n        }\n      } else {\n        single = arg.string();\n        maxout *= 10;\n      }\n    }\n\n    if(!o) {\n      Main.outln(NL + Main.name(this) + \" Test Suite [pat]\" + NL +\n          \" [pat] perform only tests with the specified pattern\" + NL +\n          \" -d show debugging info\" + NL +\n          \" -h show this help\" + NL +\n          \" -p change path\" + NL +\n          \" -r create report\" + NL +\n          \" -v verbose output\");\n      return;\n    }\n\n    queries = path + \"Queries/XQuery/\";\n    expected = path + \"ExpectedTestResults/\";\n    results = path + \"ReportingResults/Results/\";\n    report = path + \"ReportingResults/\";\n    sources = path + \"TestSources/\";\n\n    final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    final String dat = sdf.format(Calendar.getInstance().getTime());\n\n    final Performance perf = new Performance();\n    context.prop.set(Prop.XQFORMAT, false);\n    context.prop.set(Prop.MAINMEM, false);\n    context.prop.set(Prop.TABLEMEM, false);\n    context.prop.set(Prop.CHOP, false);\n\n    new CreateDB(path + input).execute(context);\n    data = context.data();\n\n    final Nodes root = new Nodes(0, data);\n    Main.outln(NL + Main.name(this) + \" Test Suite \" +\n        text(\"/*:test-suite/@version\", root));\n\n    Main.outln(NL + \"Caching Sources...\");\n    for(final int s : nodes(\"//*:source\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      srcs.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Modules...\");\n    for(final int s : nodes(\"//*:module\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      mods.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Collections...\");\n    for(final int c : nodes(\"//*:collection\", root).nodes) {\n      final Nodes nodes = new Nodes(c, data);\n      final String cname = text(\"@ID\", nodes);\n\n      final TokenList dl = new TokenList();\n      final Nodes doc = nodes(\"*:input-document\", nodes);\n      for(int d = 0; d < doc.size(); d++) {\n        dl.add(token(sources + string(data.atom(doc.nodes[d])) + \".xml\"));\n      }\n      colls.put(cname, dl.finish());\n    }\n    init(root);\n\n    if(reporting) {\n      Main.outln(\"Delete old results...\");\n      delete(new File[] { new File(results) });\n    }\n\n    Main.out(\"Parsing Queries\");\n    if(verbose) Main.outln();\n    final Nodes nodes = nodes(\"//*:test-case\", root);\n    //final Nodes nodes = nodes(\n    //  \"//*:test-group[starts-with(@name, 'Minimal')]//*:test-case\", root);\n    int total = nodes.size();\n    for(int t = 0; t < total; t++) {\n      if(!parse(new Nodes(nodes.nodes[t], data))) break;\n      if(!verbose && t % 1000 == 0) Main.out(\".\");\n    }\n    Main.outln();\n    total = ok + ok2 + err + err2;\n\n    final String time = perf.getTimer();\n    Main.outln(\"Writing log file...\" + NL);\n    BufferedWriter bw = new BufferedWriter(\n        new OutputStreamWriter(new FileOutputStream(path + pathlog), UTF8));\n    bw.write(\"TEST RESULTS ==================================================\");\n    bw.write(NL + NL + \"Total #Queries: \" + total + NL);\n    bw.write(\"Correct / Empty Results: \" + ok + \" / \" + ok2 + NL);\n    bw.write(\"Conformance (w/Empty Results): \");\n    bw.write(pc(ok, total) + \" / \" + pc(ok + ok2, total) + NL);\n    bw.write(\"Wrong Results / Errors: \" + err + \" / \" + err2 + NL);\n    bw.write(\"WRONG =========================================================\");\n    bw.write(NL + NL + logErr + NL);\n    bw.write(\"WRONG (ERRORS) ================================================\");\n    bw.write(NL + NL + logErr2 + NL);\n    bw.write(\"CORRECT? (EMPTY) ==============================================\");\n    bw.write(NL + NL + logOK2 + NL);\n    bw.write(\"CORRECT =======================================================\");\n    bw.write(NL + NL + logOK + NL);\n    bw.write(\"===============================================================\");\n    bw.close();\n\n    bw = new BufferedWriter(new FileWriter(pathhis, true));\n    bw.write(dat + \"\\t\" + ok + \"\\t\" + ok2 + \"\\t\" + err + \"\\t\" + err2 + NL);\n    bw.close();\n\n    if(reporting) {\n      bw = new BufferedWriter(new OutputStreamWriter(\n          new FileOutputStream(report + NAME + \".xml\"), UTF8));\n      write(bw, report + NAME + \"Pre.xml\");\n      bw.write(logReport.toString());\n      write(bw, report + NAME + \"Pos.xml\");\n      bw.close();\n    }\n\n    Main.outln(\"Total #Queries: \" + total);\n    Main.outln(\"Correct / Empty results: \" + ok + \" / \" + ok2);\n    Main.out(\"Conformance (w/empty results): \");\n    Main.outln(pc(ok, total) + \" / \" + pc(ok + ok2, total));\n    Main.outln(\"Total Time: \" + time);\n\n    context.close();\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses the specified test case.\n   * @param root root node\n   * @throws Exception exception\n   * @return true if the query, specified by {@link #single}, was evaluated.\n   */\n  private boolean parse(final Nodes root) throws Exception {\n    final String pth = text(\"@FilePath\", root);\n    final String outname = text(\"@name\", root);\n    if(single != null && !outname.startsWith(single)) return true;\n\n    if(verbose) Main.outln(\"- \" + outname);\n\n    boolean inspect = false;\n    boolean correct = true;\n\n    final Nodes nodes = states(root);\n    for(int n = 0; n < nodes.size(); n++) {\n      final Nodes state = new Nodes(nodes.nodes[n], nodes.data);\n      \n      final String inname = text(\"*:query/@name\", state);\n      Prop.xquery = IO.get(queries + pth + inname + \".xq\");\n      final String in = read(Prop.xquery);\n      String error = null;\n      SeqIter iter = null;\n      boolean doc = true;\n\n      final TokenBuilder files = new TokenBuilder();\n      final CachedOutput out = new CachedOutput();\n\n      final Nodes cont = nodes(\"*:contextItem\", state);\n      Nodes curr = null;\n      if(cont.size() != 0) {\n        final Data d = Open.check(context,\n            srcs.get(string(data.atom(cont.nodes[0]))));\n        curr = new Nodes(d.doc(), d, true);\n      }\n\n      final QueryProcessor xq = new QueryProcessor(in, curr, context);\n      final QueryContext qctx = xq.ctx;\n\n      try {\n        files.add(file(nodes(\"*:input-file\", state),\n            nodes(\"*:input-file/@variable\", state), qctx, n == 0));\n        files.add(file(nodes(\"*:input-URI\", state),\n            nodes(\"*:input-URI/@variable\", state), qctx, n == 0));\n        files.add(file(nodes(\"*:defaultCollection\", state),\n            null, qctx, n == 0));\n\n        var(nodes(\"*:input-query/@name\", state),\n            nodes(\"*:input-query/@variable\", state), pth, qctx);\n\n        parse(qctx, state);\n\n        for(final int p : nodes(\"*:module\", root).nodes) {\n          final String ns = text(\"@namespace\", new Nodes(p, data));\n          final String f = mods.get(string(data.atom(p))) + \".xq\";\n          xq.module(ns, f);\n        }\n\n        // evaluate and serialize query\n        final XMLSerializer xml = new XMLSerializer(out, false,\n            context.prop.is(Prop.XQFORMAT));\n        iter = SeqIter.get(xq.iter());\n        Item it;\n        while((it = iter.next()) != null) {\n          doc &= it.type == Type.DOC;\n          it.serialize(xml);\n        }\n        xml.close();\n\n      } catch(final QueryException ex) {\n        error = ex.getMessage();\n        if(error.startsWith(\"Stopped at\")) {\n          error = error.substring(error.indexOf('\\n') + 1);\n        }\n\n        if(error.startsWith(\"[\")) {\n          final int i = error.indexOf(\"]\");\n          error = error.substring(1).substring(0, i - 1) +\n            error.substring(i + 1);\n        }\n      } catch(final Exception ex) {\n        final ByteArrayOutputStream bw = new ByteArrayOutputStream();\n        ex.printStackTrace(new PrintStream(bw));\n        error = bw.toString();\n      } catch(final Error ex) {\n        final ByteArrayOutputStream bw = new ByteArrayOutputStream();\n        ex.printStackTrace(new PrintStream(bw));\n        error = bw.toString();\n      }\n\n      final Nodes outFiles = nodes(\"*:output-file/text()\", state);\n      final Nodes cmpFiles = nodes(\"*:output-file/@compare\", state);\n      boolean xml = false;\n      boolean frag = false;\n\n      final StringList result = new StringList();\n      for(int o = 0; o < outFiles.size(); o++) {\n        final String resFile = string(data.atom(outFiles.nodes[o]));\n        final IO exp = IO.get(expected + pth + resFile);\n        result.add(read(exp));\n        final byte[] type = data.atom(cmpFiles.nodes[o]);\n        xml |= eq(type, XML);\n        frag |= eq(type, FRAGMENT);\n      }\n      String expError = text(\"*:expected-error/text()\", state);\n\n      final StringBuilder log = new StringBuilder(pth + inname + \".xq\");\n      if(files.size() != 0) {\n        log.append(\" [\");\n        log.append(files);\n        log.append(\"]\");\n      }\n      log.append(NL);\n\n      /** Remove comments. */\n      log.append(norm(in));\n      log.append(NL);\n      final String logStr = log.toString();\n      // skip queries with variable results\n      final boolean print = currTime || !logStr.contains(\"current-\");\n\n      boolean correctError = false;\n      if(error != null && (outFiles.size() == 0 || expError.length() != 0)) {\n        expError = error(pth + outname, expError);\n        final String code = error.substring(0, Math.min(8, error.length()));\n        for(final String er : SLASH.split(expError)) {\n          if(code.equals(er)) {\n            correctError = true;\n            break;\n          }\n        }\n      }\n\n      if(correctError) {\n        if(print) {\n          logOK.append(logStr);\n          logOK.append(\"[Right] \");\n          logOK.append(norm(error));\n          logOK.append(NL);\n          logOK.append(NL);\n          addLog(pth, outname + \".log\", error);\n        }\n        ok++;\n      } else if(error == null) {\n        int s = -1;\n        final int rs = result.size();\n        while(++s < rs) {\n          inspect |= s < cmpFiles.nodes.length &&\n            eq(data.atom(cmpFiles.nodes[s]), INSPECT);\n\n          if(result.get(s).equals(out.toString())) break;\n\n          if(xml || frag) {\n            iter.reset();\n\n            String rin = result.get(s).trim();\n            if(!doc || frag) {\n              if(rin.startsWith(\"<?xml\")) rin = rin.replaceAll(\"^<.*?>\", \"\");\n              rin = \"<X>\" + rin + \"<\/X>\";\n            }\n\n            final Data rdata = CreateDB.xml(IO.get(rin), context.prop);\n            final SeqIter si = new SeqIter();\n            int pre = doc ? 0 : 2;\n            final int size = rdata.meta.size;\n            while(pre < size) {\n              final int k = rdata.kind(pre);\n              if(k != Data.TEXT || !ws(rdata.atom(pre))) {\n                si.add(new DBNode(rdata, pre));\n              }\n              pre += rdata.size(pre, k);\n            }\n            final boolean eq = FNSeq.deep(iter, si);\n            rdata.close();\n            if(eq) break;\n          }\n        }\n        if((rs > 0 || expError.length() != 0) && s == rs && !inspect) {\n          if(print) {\n            if(outFiles.size() == 0) result.add(error(pth + outname, expError));\n            logErr.append(logStr);\n            logErr.append(\"[\" + testid + \" ] \");\n            logErr.append(norm(result.get(0)));\n            logErr.append(NL);\n            logErr.append(\"[Wrong] \");\n            logErr.append(norm(out.toString()));\n            logErr.append(NL);\n            logErr.append(NL);\n            addLog(pth, outname + (xml ? \".xml\" : \".txt\"), out.toString());\n          }\n          correct = false;\n          err++;\n        } else {\n          if(print) {\n            logOK.append(logStr);\n            logOK.append(\"[Right] \");\n            logOK.append(norm(out.toString()));\n            logOK.append(NL);\n            logOK.append(NL);\n            addLog(pth, outname + (xml ? \".xml\" : \".txt\"), out.toString());\n          }\n          ok++;\n        }\n      } else {\n        if(outFiles.size() == 0 || expError.length() != 0) {\n          if(print) {\n            logOK2.append(logStr);\n            logOK2.append(\"[\" + testid + \" ] \");\n            logOK2.append(norm(expError));\n            logOK2.append(NL);\n            logOK2.append(\"[Rght?] \");\n            logOK2.append(norm(error));\n            logOK2.append(NL);\n            logOK2.append(NL);\n            addLog(pth, outname + \".log\", error);\n          }\n          ok2++;\n        } else {\n          if(print) {\n            logErr2.append(logStr);\n            logErr2.append(\"[\" + testid + \" ] \");\n            logErr2.append(norm(result.get(0)));\n            logErr2.append(NL);\n            logErr2.append(\"[Wrong] \");\n            logErr2.append(norm(error));\n            logErr2.append(NL);\n            logErr2.append(NL);\n            addLog(pth, outname + \".log\", error);\n          }\n          correct = false;\n          err2++;\n        }\n      }\n      if(curr != null) Close.close(context, curr.data);\n      xq.close();\n    }\n\n    if(reporting) {\n      logReport.append(\"    <test-case name=\\\"\");\n      logReport.append(outname);\n      logReport.append(\"\\\" result='\");\n      logReport.append(correct ? \"pass\" : \"fail\");\n      if(inspect) logReport.append(\"' todo='inspect\");\n      logReport.append(\"'/>\");\n      logReport.append(NL);\n    }\n    return single == null || !outname.equals(single);\n  }","id":89921,"modified_method":"/**\n   * Parses the specified test case.\n   * @param root root node\n   * @throws Exception exception\n   * @return true if the query, specified by {@link #single}, was evaluated.\n   */\n  private boolean parse(final Nodes root) throws Exception {\n    final String pth = text(\"@FilePath\", root);\n    final String outname = text(\"@name\", root);\n    if(single != null && !outname.startsWith(single)) return true;\n\n    if(verbose) Main.outln(\"- \" + outname);\n\n    boolean inspect = false;\n    boolean correct = true;\n\n    final Nodes nodes = states(root);\n    for(int n = 0; n < nodes.size(); n++) {\n      final Nodes state = new Nodes(nodes.nodes[n], nodes.data);\n      \n      final String inname = text(\"*:query/@name\", state);\n      Prop.xquery = IO.get(queries + pth + inname + \".xq\");\n      final String in = read(Prop.xquery);\n      String error = null;\n      SeqIter iter = null;\n      boolean doc = true;\n\n      final TokenBuilder files = new TokenBuilder();\n      final CachedOutput out = new CachedOutput();\n\n      final Nodes cont = nodes(\"*:contextItem\", state);\n      Nodes curr = null;\n      if(cont.size() != 0) {\n        final Data d = Open.check(context,\n            srcs.get(string(data.atom(cont.nodes[0]))));\n        curr = new Nodes(d.doc(), d, true);\n      }\n\n      final QueryProcessor xq = new QueryProcessor(in, curr, context);\n      final QueryContext qctx = xq.ctx;\n\n      try {\n        files.add(file(nodes(\"*:input-file\", state),\n            nodes(\"*:input-file/@variable\", state), qctx, n == 0));\n        files.add(file(nodes(\"*:input-URI\", state),\n            nodes(\"*:input-URI/@variable\", state), qctx, n == 0));\n        files.add(file(nodes(\"*:defaultCollection\", state),\n            null, qctx, n == 0));\n\n        var(nodes(\"*:input-query/@name\", state),\n            nodes(\"*:input-query/@variable\", state), pth, qctx);\n\n        parse(qctx, state);\n\n        for(final int p : nodes(\"*:module\", root).nodes) {\n          final String ns = text(\"@namespace\", new Nodes(p, data));\n          final String f = mods.get(string(data.atom(p))) + \".xq\";\n          xq.module(ns, f);\n        }\n\n        // evaluate and serialize query\n        final XMLSerializer xml = new XMLSerializer(out, false,\n            context.prop.is(Prop.XQFORMAT));\n        iter = SeqIter.get(xq.iter());\n        Item it;\n        while((it = iter.next()) != null) {\n          doc &= it.type == Type.DOC;\n          it.serialize(xml);\n        }\n        xml.close();\n\n      } catch(final QueryException ex) {\n        error = ex.getMessage();\n        if(error.startsWith(\"Stopped at\")) {\n          error = error.substring(error.indexOf('\\n') + 1);\n        }\n\n        if(error.startsWith(\"[\")) {\n          final int i = error.indexOf(\"]\");\n          error = error.substring(1).substring(0, i - 1) +\n            error.substring(i + 1);\n        }\n      } catch(final Exception ex) {\n        final ByteArrayOutputStream bw = new ByteArrayOutputStream();\n        ex.printStackTrace(new PrintStream(bw));\n        error = bw.toString();\n      } catch(final Error ex) {\n        final ByteArrayOutputStream bw = new ByteArrayOutputStream();\n        ex.printStackTrace(new PrintStream(bw));\n        error = bw.toString();\n      }\n\n      final Nodes outFiles = nodes(\"*:output-file/text()\", state);\n      final Nodes cmpFiles = nodes(\"*:output-file/@compare\", state);\n      boolean xml = false;\n      boolean frag = false;\n\n      final StringList result = new StringList();\n      for(int o = 0; o < outFiles.size(); o++) {\n        final String resFile = string(data.atom(outFiles.nodes[o]));\n        final IO exp = IO.get(expected + pth + resFile);\n        result.add(read(exp));\n        final byte[] type = data.atom(cmpFiles.nodes[o]);\n        xml |= eq(type, XML);\n        frag |= eq(type, FRAGMENT);\n      }\n      String expError = text(\"*:expected-error/text()\", state);\n\n      final StringBuilder log = new StringBuilder(pth + inname + \".xq\");\n      if(files.size() != 0) {\n        log.append(\" [\");\n        log.append(files);\n        log.append(\"]\");\n      }\n      log.append(NL);\n\n      /** Remove comments. */\n      log.append(norm(in));\n      log.append(NL);\n      final String logStr = log.toString();\n      // skip queries with variable results\n      final boolean print = currTime || !logStr.contains(\"current-\");\n\n      boolean correctError = false;\n      if(error != null && (outFiles.size() == 0 || expError.length() != 0)) {\n        expError = error(pth + outname, expError);\n        final String code = error.substring(0, Math.min(8, error.length()));\n        for(final String er : SLASH.split(expError)) {\n          if(code.equals(er)) {\n            correctError = true;\n            break;\n          }\n        }\n      }\n\n      if(correctError) {\n        if(print) {\n          logOK.append(logStr);\n          logOK.append(\"[Right] \");\n          logOK.append(norm(error));\n          logOK.append(NL);\n          logOK.append(NL);\n          addLog(pth, outname + \".log\", error);\n        }\n        ok++;\n      } else if(error == null) {\n        int s = -1;\n        final int rs = result.size();\n        while(++s < rs) {\n          inspect |= s < cmpFiles.nodes.length &&\n            eq(data.atom(cmpFiles.nodes[s]), INSPECT);\n\n          if(result.get(s).equals(out.toString())) break;\n\n          if(xml || frag) {\n            iter.reset();\n\n            String ri = result.get(s).trim();\n            if(!doc) {\n              if(ri.startsWith(\"<?xml\")) ri = ri.replaceAll(\"^<.*?>\\\\s*\", \"\");\n              ri = \"<X>\" + ri + \"<\/X>\";\n            }\n\n            final Data rdata = CreateDB.xml(IO.get(ri), context.prop);\n            final SeqIter si = new SeqIter();\n            for(int pre = doc ? 0 : 2; pre < rdata.meta.size;) {\n              si.add(new DBNode(rdata, pre));\n              pre += rdata.size(pre, rdata.kind(pre));\n            }\n            \n            final boolean eq = FNSeq.deep(iter, si);\n            if(!eq && debug) {\n              iter.reset();\n              si.reset();\n              final XMLSerializer ser = new XMLSerializer(\n                  new PrintOutput(System.out));\n              Item it;\n              Main.outln(NL + \"=== \" + testid + \" ===\");\n              while((it = si.next()) != null) it.serialize(ser);\n              Main.outln(NL + \"=== \" + NAME + \" ===\");\n              while((it = iter.next()) != null) it.serialize(ser);\n              Main.outln();\n            }\n\n            rdata.close();\n            if(eq) break;\n          }\n        }\n        if((rs > 0 || expError.length() != 0) && s == rs && !inspect) {\n          if(print) {\n            if(outFiles.size() == 0) result.add(error(pth + outname, expError));\n            logErr.append(logStr);\n            logErr.append(\"[\" + testid + \" ] \");\n            logErr.append(norm(result.get(0)));\n            logErr.append(NL);\n            logErr.append(\"[Wrong] \");\n            logErr.append(norm(out.toString()));\n            logErr.append(NL);\n            logErr.append(NL);\n            addLog(pth, outname + (xml ? \".xml\" : \".txt\"), out.toString());\n          }\n          correct = false;\n          err++;\n        } else {\n          if(print) {\n            logOK.append(logStr);\n            logOK.append(\"[Right] \");\n            logOK.append(norm(out.toString()));\n            logOK.append(NL);\n            logOK.append(NL);\n            addLog(pth, outname + (xml ? \".xml\" : \".txt\"), out.toString());\n          }\n          ok++;\n        }\n      } else {\n        if(outFiles.size() == 0 || expError.length() != 0) {\n          if(print) {\n            logOK2.append(logStr);\n            logOK2.append(\"[\" + testid + \" ] \");\n            logOK2.append(norm(expError));\n            logOK2.append(NL);\n            logOK2.append(\"[Rght?] \");\n            logOK2.append(norm(error));\n            logOK2.append(NL);\n            logOK2.append(NL);\n            addLog(pth, outname + \".log\", error);\n          }\n          ok2++;\n        } else {\n          if(print) {\n            logErr2.append(logStr);\n            logErr2.append(\"[\" + testid + \" ] \");\n            logErr2.append(norm(result.get(0)));\n            logErr2.append(NL);\n            logErr2.append(\"[Wrong] \");\n            logErr2.append(norm(error));\n            logErr2.append(NL);\n            logErr2.append(NL);\n            addLog(pth, outname + \".log\", error);\n          }\n          correct = false;\n          err2++;\n        }\n      }\n      if(curr != null) Close.close(context, curr.data);\n      xq.close();\n    }\n\n    if(reporting) {\n      logReport.append(\"    <test-case name=\\\"\");\n      logReport.append(outname);\n      logReport.append(\"\\\" result='\");\n      logReport.append(correct ? \"pass\" : \"fail\");\n      if(inspect) logReport.append(\"' todo='inspect\");\n      logReport.append(\"'/>\");\n      logReport.append(NL);\n    }\n    return single == null || !outname.equals(single);\n  }","commit_id":"fd995bf213a6b08de52e344a31a402cadee0f83d","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Iter iter(final QueryContext ctx) throws QueryException {\r\n    final SeqIter seq = new SeqIter();\r\n    final Iter[] iter = new Iter[fl.length];\r\n    for(int f = 0; f < fl.length; f++) iter[f] = ctx.iter(fl[f]);\r\n    iter(ctx, seq, iter, 0);\r\n    if(group != null) {\r\n      group.sq = seq;\r\n      return group.iter(ctx);\r\n//      final Item m =  group.iter(ctx).finish();\r\n//      order.sq = (SeqIter) m.iter();\r\n    } else {\r\n      order.sq = seq;  \r\n    }\r\n    \r\n    \r\n    return order.iter(ctx);\r\n  }","id":89922,"modified_method":"@Override\r\n  public Iter iter(final QueryContext ctx) throws QueryException {\r\n    final SeqIter seq = new SeqIter();\r\n    final Iter[] iter = new Iter[fl.length];\r\n    for(int f = 0; f < fl.length; f++) iter[f] = ctx.iter(fl[f]);\r\n    iter(ctx, seq, iter, 0);\r\n    if(group != null) { // perform grouping\r\n      group.sq = seq;\r\n      final Item m =  group.iter(ctx).finish();\r\n      if(order != null)\r\n        order.sq = (m.iter().size() > 1) ? (SeqIter) m.iter() : new SeqIter(m);\r\n      else\r\n        return m.iter();\r\n    } else {\r\n      order.sq = seq;  \r\n    }\r\n    return order.iter(ctx);\r\n  }","commit_id":"67cb4ed2ab4b6cce2cff77e42d69735aab7abcae","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Iter iter(final QueryContext ctx) {\n    return new Iter() {\n      final int e = sq.size();\n      int[] group;\n      Iter ir;\n      int p = -1;\n      \n      @Override\n      public Item next() throws QueryException {\n        if(group == null) {\n          // enumerate sort array and sort entries\n          group = new int[e];\n          for(int i = 0; i < e; i++) group[i] = i;\n          group(group, e);\n          for(final Grp g : grp) g.finish();\n        }\n        final int s = groups.size();\n        final Integer[] hashes = groups.keySet().toArray(new Integer[s]);\n        while(true) {\n          if(ir != null) {\n            final Item i = ir.next();\n            if(i != null) return i;\n            ir = null;\n          } else {\n            if(++p == hashes.length) return null;\n            final int witness = groups.get(hashes[p])[0]; \n            ir = sq.item[witness].iter();\n          }\n        }\n      }\n      @Override\n      public String toString() {\n        return Group.this.toString();\n      }\n    };\n  }","id":89923,"modified_method":"@Override\n  public Iter iter(final QueryContext ctx) {\n    return new Iter() {\n      Iter ir;\n      int p = -1;\n      \n      @Override\n      public Item next() throws QueryException {\n        if(groups == null) {\n          // enumerate sort array and sort entries\n//          for(int i = 0; i < e; i++) group[i] = i;\n          group();\n          for(final Grp g : grp) g.finish();\n        }\n        final int s = groups.size();\n        final Integer[] hashes = groups.keySet().toArray(new Integer[s]);\n        while(true) {\n          if(ir != null) {\n            final Item i = ir.next();\n            if(i != null) return i;\n            ir = null;\n          } else {\n            if(++p == hashes.length) return null;\n            final int witness = groups.get(hashes[p])[0]; \n            ir = sq.item[witness].iter();\n          }\n        }\n      }\n      @Override\n      public String toString() {\n        return Group.this.toString();\n      }\n    };\n  }","commit_id":"67cb4ed2ab4b6cce2cff77e42d69735aab7abcae","url":"https://github.com/BaseXdb/basex"},{"original_method":"public boolean isUserAllowedToPublishAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n\t  // First check to see if the user in *this* course has access to *this* assessment\n\t  checkAssessmentInSite(assessmentId, published);\n\n\t  if (getPublishAnyAssessment()) {\n\t\t  return true;\n\t  }\n\t  else if (getPublishOwnAssessment()) {\n\t\t  final String loggedInUser = AgentFacade.getAgentString();\n\t\t  return StringUtils.equals(loggedInUser, assessmentOwnerId);\n\t  }\n\t  return false;\n  }","id":89924,"modified_method":"public boolean isUserAllowedToPublishAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n    if (!isAssessmentInSite(assessmentId, published)) {\n      return false;\n    }\n\n    if (getPublishAnyAssessment()) {\n      return true;\n    }\n    else if (getPublishOwnAssessment()) {\n      final String loggedInUser = AgentFacade.getAgentString();\n      return StringUtils.equals(loggedInUser, assessmentOwnerId);\n    }\n    return false;\n  }","commit_id":"3cdf240a911bde645c11a56d53e6361bb5e47a90","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean isUserAllowedToDeleteAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n\t  // First check to see if the user in *this* course has access to *this* assessment\n\t  checkAssessmentInSite(assessmentId, published);\n\t  \n\t  // Second check on the realm permissions\n\t  if (getDeleteAnyAssessment()) {\n\t\t  return true;\n\t  }\n\t  else if (getDeleteOwnAssessment()) {\n\t\t  final String loggedInUser = AgentFacade.getAgentString();\n\t\t  return StringUtils.equals(loggedInUser, assessmentOwnerId);\n\t  }\n\t  return false;\n  }","id":89925,"modified_method":"public boolean isUserAllowedToDeleteAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n    if (!isAssessmentInSite(assessmentId, published)) {\n      return false;\n    }\n\n    // Second check on the realm permissions\n    if (getDeleteAnyAssessment()) {\n      return true;\n    }\n    else if (getDeleteOwnAssessment()) {\n      final String loggedInUser = AgentFacade.getAgentString();\n      return StringUtils.equals(loggedInUser, assessmentOwnerId);\n    }\n    return false;\n  }","commit_id":"3cdf240a911bde645c11a56d53e6361bb5e47a90","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void checkAssessmentInSite(final String assessmentId, final boolean published) {\n      if (!isAssessmentInSite(assessmentId, AgentFacade.getCurrentSiteId(), published)) {\n          throw new IllegalArgumentException(\"Assessment \" + assessmentId + \" (published=\" + published + \") does not belong to site \" + AgentFacade.getCurrentSiteId());\n      }\n  }","id":89926,"modified_method":"public static boolean isAssessmentInSite(final String assessmentId, final boolean published) {\n    return isAssessmentInSite(assessmentId, AgentFacade.getCurrentSiteId(), published);\n  }","commit_id":"3cdf240a911bde645c11a56d53e6361bb5e47a90","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean isUserAllowedToEditAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n\t  // First check to see if the user in *this* course has access to *this* assessment\n\t  checkAssessmentInSite(assessmentId, published);\n\t  \n\t  // Second check on the realm permissions\n\t  if (getEditAnyAssessment()) {\n\t\t  return true;\n\t  }\n\t  else if (getEditOwnAssessment()) {\n\t\t  final String loggedInUser = AgentFacade.getAgentString();\n\t\t  return StringUtils.equals(loggedInUser, assessmentOwnerId);\n\t  }\n\t  return false;\n  }","id":89927,"modified_method":"public boolean isUserAllowedToEditAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n    if (!isAssessmentInSite(assessmentId, published)) {\n      return false;\n    }\n\n    // Second check on the realm permissions\n    if (getEditAnyAssessment()) {\n      return true;\n    }\n    else if (getEditOwnAssessment()) {\n      final String loggedInUser = AgentFacade.getAgentString();\n      return StringUtils.equals(loggedInUser, assessmentOwnerId);\n    }\n    return false;\n  }","commit_id":"3cdf240a911bde645c11a56d53e6361bb5e47a90","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean isUserAllowedToTakeAssessment(final String assessmentId) {\n\t  // First check to see if the user in *this* course has access to *this* assessment\n\t  checkAssessmentInSite(assessmentId, true);\n\t  \n\t  // Second check on the realm permissions\n\t  return getTakeAssessment();\n  }","id":89928,"modified_method":"public boolean isUserAllowedToTakeAssessment(final String assessmentId) {\n    if (!isAssessmentInSite(assessmentId, true)) { \n      return false;\n    }\n\n    // Second check on the realm permissions\n    return getTakeAssessment();\n  }","commit_id":"3cdf240a911bde645c11a56d53e6361bb5e47a90","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean isUserAllowedToGradeAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n\t  // First check to see if the user in *this* course has access to *this* assessment\n\t  checkAssessmentInSite(assessmentId, published);\n\t  \n\t  // Second check on the realm permissions\n\t  if (getGradeAnyAssessment()) {\n\t\t  return true;\n\t  }\n\t  else if (getGradeOwnAssessment()) {\n\t\t  final String loggedInUser = AgentFacade.getAgentString();\n\t\t  return StringUtils.equals(loggedInUser, assessmentOwnerId);\n\t  }\n\t  return false;\n  }","id":89929,"modified_method":"public boolean isUserAllowedToGradeAssessment(final String assessmentId, final String assessmentOwnerId, final boolean published) {\n    if (!isAssessmentInSite(assessmentId, published)) {\n      return false;\n    }\n\n    // Second check on the realm permissions\n    if (getGradeAnyAssessment()) {\n      return true;\n    }\n    else if (getGradeOwnAssessment()) {\n      final String loggedInUser = AgentFacade.getAgentString();\n      return StringUtils.equals(loggedInUser, assessmentOwnerId);\n    }\n    return false;\n  }","commit_id":"3cdf240a911bde645c11a56d53e6361bb5e47a90","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Schedules a package action of the given type for the given server with the\n     * packages given as a list.\n     * @param scheduler The user scheduling the action.\n     * @param srvr The server that this action is for.\n     * @param pkgs A list of maps containing keys 'name_id' and 'evr_id'\n     *             with Long values.\n     * @param type The type of the package action.  One of the static types found in\n     *             ActionFactory\n     * @param earliestAction The earliest time that this action could happen.\n     * @return The action that has been scheduled.\n     */\n    public static Action schedulePackageAction(User scheduler,\n            Server srvr, List pkgs, ActionType type, Date earliestAction) {\n\n        String name = \"\";\n        if (type.equals(ActionFactory.TYPE_PACKAGES_REMOVE) ||\n            type.equals(ActionFactory.TYPE_SOLARISPKGS_REMOVE)) {\n            name = \"Package Removal\";\n        }\n        else if (type.equals(ActionFactory.TYPE_PACKAGES_UPDATE) ||\n                 type.equals(ActionFactory.TYPE_SOLARISPKGS_INSTALL)) {\n            name = \"Package Install\";\n        }\n        else if (type.equals(ActionFactory.TYPE_PACKAGES_REFRESH_LIST)) {\n            name = \"Package List Refresh\";\n        }\n        else if (type.equals(ActionFactory.TYPE_PACKAGES_DELTA)) {\n            name = \"Package Synchronization\";\n        }\n\n        Action action = scheduleAction(scheduler, srvr, type, name, earliestAction);\n        ActionFactory.save(action);\n        \n        if (pkgs != null) {\n          // for each item in the set create a package action detail\n          // I'm using datasource to insert the records instead of \n          // hibernate. It seems terribly inefficient to lookup a\n          // packagename and packageevr object to insert the ids into the\n          // correct table if I already have the ids.\n          WriteMode m = ModeFactory.getWriteMode(\"Action_queries\", \"schedule_action\"); \n          for (Iterator itr = pkgs.iterator(); itr.hasNext();) {\n              Map rse = (Map) itr.next();\n              Map params = new HashMap();\n              Long nameId = (Long) rse.get(\"name_id\");\n              Long evrId = (Long) rse.get(\"evr_id\");\n              Long archId = (Long) rse.get(\"arch_id\");\n              if (nameId == null || evrId == null) {\n                  throw new IllegalArgumentException(\"name_id or \" +\n                        \"evr_id are not in the Map passed into \" +\n                        \"this method.  Please populate the Map \" +\n                        \"with the name_id and evr_id items\");\n              }\n              params.put(\"action_id\", action.getId());\n              params.put(\"name_id\", nameId);\n              params.put(\"evr_id\", evrId);\n              params.put(\"arch_id\", archId);\n              m.executeUpdate(params);\n          }\n        }\n        \n        return action;\n    }","id":89930,"modified_method":"/**\n     * Schedules a package action of the given type for the given server with the\n     * packages given as a list.\n     * @param scheduler The user scheduling the action.\n     * @param srvr The server that this action is for.\n     * @param pkgs A list of maps containing keys 'name_id', 'evr_id' and \n     *             optional 'arch_id' with Long values.\n     * @param type The type of the package action.  One of the static types found in\n     *             ActionFactory\n     * @param earliestAction The earliest time that this action could happen.\n     * @return The action that has been scheduled.\n     */\n    public static Action schedulePackageAction(User scheduler,\n            Server srvr, List pkgs, ActionType type, Date earliestAction) {\n\n        String name = \"\";\n        if (type.equals(ActionFactory.TYPE_PACKAGES_REMOVE) ||\n            type.equals(ActionFactory.TYPE_SOLARISPKGS_REMOVE)) {\n            name = \"Package Removal\";\n        }\n        else if (type.equals(ActionFactory.TYPE_PACKAGES_UPDATE) ||\n                 type.equals(ActionFactory.TYPE_SOLARISPKGS_INSTALL)) {\n            name = \"Package Install\";\n        }\n        else if (type.equals(ActionFactory.TYPE_PACKAGES_REFRESH_LIST)) {\n            name = \"Package List Refresh\";\n        }\n        else if (type.equals(ActionFactory.TYPE_PACKAGES_DELTA)) {\n            name = \"Package Synchronization\";\n        }\n\n        Action action = scheduleAction(scheduler, srvr, type, name, earliestAction);\n        ActionFactory.save(action);\n        \n        if (pkgs != null) {\n          // for each item in the set create a package action detail\n          // I'm using datasource to insert the records instead of \n          // hibernate. It seems terribly inefficient to lookup a\n          // packagename and packageevr object to insert the ids into the\n          // correct table if I already have the ids.\n          for (Iterator itr = pkgs.iterator(); itr.hasNext();) {\n              Map rse = (Map) itr.next();\n              Map params = new HashMap();\n              Long nameId = (Long) rse.get(\"name_id\");\n              Long evrId = (Long) rse.get(\"evr_id\");\n              Long archId = (Long) rse.get(\"arch_id\");\n              if (nameId == null || evrId == null) {\n                  throw new IllegalArgumentException(\"name_id or \" +\n                        \"evr_id are not in the Map passed into \" +\n                        \"this method.  Please populate the Map \" +\n                        \"with the name_id and evr_id items\");\n              }\n              params.put(\"action_id\", action.getId());\n              params.put(\"name_id\", nameId);\n              params.put(\"evr_id\", evrId);\n\n              WriteMode m = null;\n              if (archId == null) {\n                  m = ModeFactory.getWriteMode(\"Action_queries\", \n                          \"schedule_action_no_arch\");\n              } \n              else {\n                  params.put(\"arch_id\", archId);\n                  m = ModeFactory.getWriteMode(\"Action_queries\", \"schedule_action\"); \n              }\n              m.executeUpdate(params);\n          }\n        }\n        \n        return action;\n    }","commit_id":"5402b0772ef4352c92df399839376902195b7db3","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Creates a new operation, defaulting the status to \"in progress\" and the progress\n     * of the operation to 0.\n     *\n     * @param user        user under which to associate the operation; cannot be\n     *                    <code>null<\/code>\n     * @param description high level description of what the operation is doing;\n     *                    cannot be <code>null<\/code>\n     */\n    public static void createOperation(User user, String description) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        if (description == null) {\n            throw new IllegalArgumentException(\"description cannot be null\");\n        }\n        \n        WriteMode m = ModeFactory.getWriteMode(\"ssm_queries\", \"create_operation\");\n\n        Map<String, Object> params = new HashMap<String, Object>(3);\n        params.put(\"user_id\", user.getId());\n        params.put(\"description\", description);\n        params.put(\"status\", SsmOperationStatus.IN_PROGRESS.getText());\n\n        m.executeUpdate(params);\n    }","id":89931,"modified_method":"/**\n     * Creates a new operation, defaulting the status to \"in progress\" and the progress\n     * of the operation to 0.\n     * <p/>\n     * For efficiency, this call assumes the following:\n     * <ul>\n     * <li>The set of servers that are taking place in the operation are already in the\n     * database as an RhnSet (the name of set is passed into this call).<\/li>\n     * <li>The server ID is stored in the first element (i.e. \"element\" in the set table).\n     * <\/ul>\n     * <p/>\n     * This should be a safe assumption since, at very least, if all servers are taking\n     * place in the operation they are already in the SSM RhnSet. If only a subset\n     * is needed, a nested select can be used to drop them into a new set, preventing\n     * the need to have another insert per server for this call.\n     *\n     * @param user        user under which to associate the operation; cannot be\n     *                    <code>null<\/code>\n     * @param description high level description of what the operation is doing;\n     *                    cannot be <code>null<\/code>\n     * @param rhnSetLabel references a RhnSet with the server IDs to associate with the\n     *                    new operation\n     * @return the id of the created operation\n     */\n    public static long createOperation(User user, String description,\n                                       String rhnSetLabel) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        if (description == null) {\n            throw new IllegalArgumentException(\"description cannot be null\");\n        }\n\n        SelectMode selectMode;\n        WriteMode writeMode;\n        Map<String, Object> params = new HashMap<String, Object>();\n\n        // Select the operation ID manually from the sequence so we can add the mappings\n        // from the operation to the servers\n        selectMode = ModeFactory.getMode(\"ssm_operation_queries\", \"get_seq_nextval\");\n        DataResult nextValResult = selectMode.execute(params);\n        Map<String, Object> nextValMap = (Map<String, Object>) nextValResult.get(0);\n        long operationId = (Long) nextValMap.get(\"nextval\");\n\n        // Add the operation data\n        writeMode = ModeFactory.getWriteMode(\"ssm_operation_queries\", \"create_operation\");\n\n        params.clear();\n        params.put(\"op_id\", operationId);\n        params.put(\"user_id\", user.getId());\n        params.put(\"description\", description);\n        params.put(\"status\", SsmOperationStatus.IN_PROGRESS.getText());\n\n        writeMode.executeUpdate(params);\n\n        // Add the server/operation mappings\n        writeMode =\n            ModeFactory.getWriteMode(\"ssm_operation_queries\", \"map_servers_to_operation\");\n\n        params.clear();\n        params.put(\"op_id\", operationId);\n        params.put(\"set_label\", rhnSetLabel);\n\n        writeMode.executeUpdate(params);\n\n        return operationId;\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Indicates the operation has completed, updating its status and progress completed\n     * values to indicate this.\n     * \n     * @param user        verifies that the user isn't trying to load someone else's\n     *                    operation; cannot be <code>null<\/code>\n     * @param operationId database ID of the operation to update\n     */\n    public static void completeOperation(User user, long operationId) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n        \n        WriteMode m = ModeFactory.getWriteMode(\"ssm_queries\", \"update_status_and_progress\");\n\n        Map<String, Object> params = new HashMap<String, Object>(3);\n        params.put(\"user_id\", user.getId());\n        params.put(\"op_id\", operationId);\n        params.put(\"status\", SsmOperationStatus.COMPLETED.getText());\n        params.put(\"progress\", 100);\n\n        m.executeUpdate(params);\n    }","id":89932,"modified_method":"/**\n     * Indicates the operation has completed, updating its status and progress completed\n     * values to indicate this.\n     *\n     * @param user        verifies that the user isn't trying to load someone else's\n     *                    operation; cannot be <code>null<\/code>\n     * @param operationId database ID of the operation to update\n     */\n    public static void completeOperation(User user, long operationId) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        WriteMode m =\n            ModeFactory.getWriteMode(\"ssm_operation_queries\", \"update_status_and_progress\");\n\n        Map<String, Object> params = new HashMap<String, Object>(3);\n        params.put(\"user_id\", user.getId());\n        params.put(\"op_id\", operationId);\n        params.put(\"status\", SsmOperationStatus.COMPLETED.getText());\n        params.put(\"progress\", 100);\n\n        m.executeUpdate(params);\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Returns a list of all operations for the given user that are currently executing.\n     *\n     * @param user operations returned only for this user; cannot be <code>null<\/code>\n     * @return list of maps containing the data describing each matching operation\n     */\n    public static DataResult inProgressOperations(User user) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"ssm_queries\", \"find_operations_with_status\");\n\n        Map<String, Object> params = new HashMap<String, Object>(2);\n        params.put(\"user_id\", user.getId());\n        params.put(\"status\", SsmOperationStatus.IN_PROGRESS.getText());\n\n        DataResult result = m.execute(params);\n        return result;\n    }","id":89933,"modified_method":"/**\n     * Returns a list of all operations for the given user that are currently executing.\n     *\n     * @param user operations returned only for this user; cannot be <code>null<\/code>\n     * @return list of maps containing the data describing each matching operation\n     */\n    public static DataResult inProgressOperations(User user) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        SelectMode m =\n            ModeFactory.getMode(\"ssm_operation_queries\", \"find_operations_with_status\");\n\n        Map<String, Object> params = new HashMap<String, Object>(2);\n        params.put(\"user_id\", user.getId());\n        params.put(\"status\", SsmOperationStatus.IN_PROGRESS.getText());\n\n        DataResult result = m.execute(params);\n        return result;\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Returns the details of the given operation.\n     *\n     * @param user        verifies that the user isn't trying to load someone else's\n     *                    operation; cannot be <code>null<\/code>\n     * @param operationId database ID of the operation to load\n     * @return list of size 1 if the operation was found, containing a map of database\n     *         column to value for the given operation; list of size 0 if no matches\n     *         were found in the database\n     */\n    public static DataResult findOperationById(User user, long operationId) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n        \n        SelectMode m = ModeFactory.getMode(\"ssm_queries\", \"find_operation_by_id\");\n\n        Map<String, Object> params = new HashMap<String, Object>(2);\n        params.put(\"user_id\", user.getId());\n        params.put(\"op_id\", operationId);\n\n        DataResult result = m.execute(params);\n        return result;\n    }","id":89934,"modified_method":"/**\n     * Returns the details of the given operation.\n     *\n     * @param user        verifies that the user isn't trying to load someone else's\n     *                    operation; cannot be <code>null<\/code>\n     * @param operationId database ID of the operation to load\n     * @return list of size 1 if the operation was found, containing a map of database\n     *         column to value for the given operation; list of size 0 if no matches\n     *         were found in the database\n     */\n    public static DataResult findOperationById(User user, long operationId) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"ssm_operation_queries\", \"find_operation_by_id\");\n\n        Map<String, Object> params = new HashMap<String, Object>(2);\n        params.put(\"user_id\", user.getId());\n        params.put(\"op_id\", operationId);\n\n        DataResult result = m.execute(params);\n        return result;\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Returns a list of all operations for the given user, regardless of their status.\n     *\n     * @param user operations returned only for this user; cannot be <code>null<\/code>\n     * @return list of maps containing the data describing each operation\n     */\n    public static DataResult allOperations(User user) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"ssm_queries\", \"find_all_operations\");\n\n        Map<String, Object> params = new HashMap<String, Object>(1);\n        params.put(\"user_id\", user.getId());\n\n        DataResult result = m.execute(params);\n        return result;\n    }","id":89935,"modified_method":"/**\n     * Returns a list of all operations for the given user, regardless of their status.\n     *\n     * @param user operations returned only for this user; cannot be <code>null<\/code>\n     * @return list of maps containing the data describing each operation\n     */\n    public static DataResult allOperations(User user) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"user cannot be null\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"ssm_operation_queries\", \"find_all_operations\");\n\n        Map<String, Object> params = new HashMap<String, Object>(1);\n        params.put(\"user_id\", user.getId());\n\n        DataResult result = m.execute(params);\n        return result;\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testCreateCompleteAndInProgressOperations() {\n        // Test\n        SsmOperationManager.createOperation(ssmUser, \"Test operation 1\");\n        SsmOperationManager.createOperation(ssmUser, \"Test operation 2\");\n\n        DataResult result = SsmOperationManager.allOperations(ssmUser);\n        assertNotNull(result);\n        assertEquals(2, result.size());\n\n        Map<String, Object> operationData = (Map<String, Object>) result.get(0);\n        long operationId = (Long) operationData.get(\"id\");\n\n        SsmOperationManager.completeOperation(ssmUser, operationId);\n\n        // Verify\n\n        //   Verify counts for all and in progress operations\n        DataResult all = SsmOperationManager.allOperations(ssmUser);\n        DataResult inProgress = SsmOperationManager.inProgressOperations(ssmUser);\n\n        assertEquals(2, all.size());\n        assertEquals(1, inProgress.size());\n\n        //   Verify the completed operation has its progress set to 100\n        for (int ii = 0; ii < all.size(); ii++) {\n            Map<String, Object> operation = (Map<String, Object>) all.get(ii);\n\n            if (operation.get(\"status\").equals(SsmOperationStatus.COMPLETED.getText())) {\n                assertEquals(100L, operation.get(\"progress\"));\n            }\n        }\n    }","id":89936,"modified_method":"public void testCreateCompleteAndInProgressOperations() throws Exception {\n        // Test\n        long completeMeId =\n            SsmOperationManager.createOperation(ssmUser, \"Test operation 1\", setLabel);\n        SsmOperationManager.createOperation(ssmUser, \"Test operation 2\", setLabel);\n\n        SsmOperationManager.completeOperation(ssmUser, completeMeId);\n\n        // Verify\n\n        //   Verify counts for all and in progress operations\n        DataResult all = SsmOperationManager.allOperations(ssmUser);\n        DataResult inProgress = SsmOperationManager.inProgressOperations(ssmUser);\n\n        assertEquals(2, all.size());\n        assertEquals(1, inProgress.size());\n\n        //   Verify the completed operation has its progress set to 100\n        for (int ii = 0; ii < all.size(); ii++) {\n            Map<String, Object> operation = (Map<String, Object>) all.get(ii);\n\n            if (operation.get(\"id\").equals(completeMeId)) {\n                assertEquals(SsmOperationStatus.COMPLETED.getText(),\n                    operation.get(\"status\"));\n                assertEquals(100L, operation.get(\"progress\"));\n            }\n        }\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testCreateAndFindOperation() {\n        // Test\n        SsmOperationManager.createOperation(ssmUser, \"Test operation 1\");\n        \n        DataResult result = SsmOperationManager.allOperations(ssmUser);\n        assertNotNull(result);\n        assertEquals(1, result.size());\n\n        Map<String, Object> operationData = (Map<String, Object>) result.get(0);\n        long operationId = (Long) operationData.get(\"id\");\n        \n        DataResult operation = SsmOperationManager.findOperationById(ssmUser, operationId);\n        \n        // Verify\n        assertNotNull(operation);\n        assertEquals(1, operation.size());\n        \n        operationData = (Map<String, Object>) operation.get(0);\n        \n        assertEquals(\"Test operation 1\", operationData.get(\"description\"));\n        assertEquals(0L, operationData.get(\"progress\"));\n        assertEquals(SsmOperationStatus.IN_PROGRESS.getText(), operationData.get(\"status\"));\n        assertNotNull(operationData.get(\"started\"));\n        assertNotNull(operationData.get(\"modified\"));\n    }","id":89937,"modified_method":"public void testCreateAndFindOperation() throws Exception {\n        // Test\n        long operationId =\n            SsmOperationManager.createOperation(ssmUser, \"Test operation 1\", setLabel);\n        \n        DataResult operation = SsmOperationManager.findOperationById(ssmUser, operationId);\n        \n        // Verify\n        assertNotNull(operation);\n        assertEquals(1, operation.size());\n        \n        Map<String, Object> operationData = (Map<String, Object>) operation.get(0);\n        \n        assertEquals(\"Test operation 1\", operationData.get(\"description\"));\n        assertEquals(0L, operationData.get(\"progress\"));\n        assertEquals(SsmOperationStatus.IN_PROGRESS.getText(), operationData.get(\"status\"));\n        assertNotNull(operationData.get(\"started\"));\n        assertNotNull(operationData.get(\"modified\"));\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected void setUp() throws Exception {\n        ssmUser = UserTestUtils.findNewUser(\"ssmuser\", \"ssmorg\");\n    }","id":89938,"modified_method":"protected void setUp() throws Exception {\n        ssmUser = UserTestUtils.findNewUser(\"ssmuser\", \"ssmorg\");\n        setLabel = populateRhnSet();\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testCreateAndAllOperations() {\n        // Test\n        SsmOperationManager.createOperation(ssmUser, \"Test operation\");\n\n        DataResult result = SsmOperationManager.allOperations(ssmUser);\n\n        // Verify\n        assertNotNull(result);\n        assertEquals(1, result.size());\n    }","id":89939,"modified_method":"public void testCreateAndAllOperations() throws Exception {\n        // Test\n        SsmOperationManager.createOperation(ssmUser, \"Test operation\", setLabel);\n\n        DataResult result = SsmOperationManager.allOperations(ssmUser);\n\n        // Verify\n        assertNotNull(result);\n        assertEquals(1, result.size());\n    }","commit_id":"933261af3565d2896d46074d0c60fe5b50856b90","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Clear out and re-generate the entries in rhnServerNeededPackageCache and\n     * rhnServerNeededErrataCache tables by channel.  Usefull if the set of \n     * errata or packages gets changed with a Channel\n     * \n     * @param cid - channel to update caches for.\n     */\n    public static void updateErrataAndPackageCacheForChannel(Long cid) {\n        // Clear em out\n        WriteMode m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"delete_errata_cache_by_channel\");\n        Map params = new HashMap();\n        params.put(\"channel_id\", cid);\n        int count = m.executeUpdate(params);\n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"errata_cache deleted: \" + count);\n\n        m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"delete_package_cache_by_channel\");\n        params = new HashMap();\n        params.put(\"channel_id\", cid);\n        count = m.executeUpdate(params); \n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"package_cache deleted: \" + count);\n\n        // Insert into rhnServerNeededPackageCache\n        m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"insert_package_cache_by_channel\");\n        params = new HashMap();\n        params.put(\"channel_id\", cid);\n        count = m.executeUpdate(params); \n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"package_cache inserted: \" + count);\n        \n        // Insert into rhnServerNeededErrataCache\n        m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"insert_errata_cache_by_channel\");\n        params = new HashMap();\n        params.put(\"channel_id\", cid);\n        count = m.executeUpdate(params); \n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"errata_cache inserted: \" + count);\n    }","id":89940,"modified_method":"/**\n     * Clear out and re-generate the entries in rhnServerNeededPackageCache and\n     * rhnServerNeededErrataCache tables by channel.  Usefull if the set of \n     * errata or packages gets changed with a Channel\n     * \n     * @param cid - channel to update caches for.\n     */\n    public static void updateErrataAndPackageCacheForChannel(Long cid) {\n        // Clear em out\n\n\n        WriteMode m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"delete_package_cache_by_channel\");\n        Map params = new HashMap();\n        params.put(\"channel_id\", cid);\n        int count = m.executeUpdate(params); \n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"package_cache deleted: \" + count);\n\n        // Insert into rhnServerNeededPackageCache\n        m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"insert_package_cache_by_channel\");\n        params = new HashMap();\n        params.put(\"channel_id\", cid);\n        count = m.executeUpdate(params); \n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"package_cache inserted: \" + count);\n        \n        m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"delete_errata_cache_by_channel\");\n        params = new HashMap();\n        params.put(\"channel_id\", cid);\n        count = m.executeUpdate(params);\n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"errata_cache deleted: \" + count);\n        \n        \n        // Insert into rhnServerNeededErrataCache\n        m = ModeFactory.getWriteMode(\n                \"ErrataCache_queries\", \"insert_errata_cache_by_channel\");\n        params = new HashMap();\n        params.put(\"channel_id\", cid);\n        count = m.executeUpdate(params); \n        log.debug(\"updateErrataAndPackageCacheForChannel : \" +\n                \"errata_cache inserted: \" + count);\n    }","commit_id":"583825a58387f7b38f7828508c60766cbfe1bef4","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Takes an unpublished errata and returns a published errata into the \n     * channels we pass in. NOTE:  This method will commit the transaction in order\n     * to allow the async call to update the errata cache to be able to have the\n     * proper data \n     * \n     * @param unpublished The errata to publish\n     * @param channelIds The Long channelIds we want to publish this Errata to.\n     * @param user who is publishing errata\n     * @return Returns a published errata.\n     */\n    public static Errata publish(Errata unpublished, Set channelIds, User user) {\n        //pass on to the factory\n        Errata retval = ErrataFactory.publish(unpublished);\n        log.debug(\"publish - errata published\");\n        \n        retval = addChannelsToErrata(retval, channelIds, user);\n        \n        ErrataCacheManager.updateErrataCacheForChannelsAsync(\n                    retval.getChannels(), user.getOrg());\n        log.debug(\"publish - updateErrataCacheForChannelsAsync called\");\n        return retval;\n    }","id":89941,"modified_method":"/**\n     * Takes an unpublished errata and returns a published errata into the \n     * channels we pass in. NOTE:  This method does NOT update the errata cache for\n     * the channels.  THat is done when packages are pushed as part of the errata \n     * publication process (which is not done here)\n     * \n     * @param unpublished The errata to publish\n     * @param channelIds The Long channelIds we want to publish this Errata to.\n     * @param user who is publishing errata\n     * @return Returns a published errata.\n     */\n    public static Errata publish(Errata unpublished, Set channelIds, User user) {\n        //pass on to the factory\n        Errata retval = ErrataFactory.publish(unpublished);\n        log.debug(\"publish - errata published\");\n        \n        retval = addChannelsToErrata(retval, channelIds, user);\n        log.debug(\"publish - updateErrataCacheForChannelsAsync called\");\n        return retval;\n    }","commit_id":"583825a58387f7b38f7828508c60766cbfe1bef4","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public static String writeGpxFile(File fout, GPXFile file, Context ctx) {\r\n\t\ttry {\r\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(GPX_TIME_FORMAT);\r\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n\t\t\tFileOutputStream output = new FileOutputStream(fout);\r\n\t\t\tXmlSerializer serializer = Xml.newSerializer();\r\n\t\t\tserializer.setOutput(output, \"UTF-8\"); //$NON-NLS-1$\r\n\t\t\tserializer.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); //$NON-NLS-1$\r\n\t\t\tserializer.startDocument(\"UTF-8\", true); //$NON-NLS-1$\r\n\t\t\tserializer.startTag(null, \"gpx\"); //$NON-NLS-1$\r\n\t\t\tserializer.attribute(null, \"version\", \"1.1\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\tserializer.attribute(null, \"creator\", Version.APP_NAME_VERSION); //$NON-NLS-1$\r\n\t\t\tserializer.attribute(\"xmlns\", \"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\r\n\t\t\tserializer.attribute(\"xsi\", \"schemaLocation\", \"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\r\n\t\t\tserializer.attribute(null, \"xmlns\", \"http://www.topografix.com/GPX/1/1\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n\t\t\tfor (Track track : file.tracks) {\r\n\t\t\t\tserializer.startTag(null, \"trk\"); //$NON-NLS-1$\r\n\t\t\t\tfor (TrkSegment segment : track.segments) {\r\n\t\t\t\t\tserializer.startTag(null, \"trkseg\"); //$NON-NLS-1$\r\n\t\t\t\t\tfor (TrkPt p : segment.points) {\r\n\t\t\t\t\t\tserializer.startTag(null, \"trkpt\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.attribute(null, \"lat\", latLonFormat.format(p.lat)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tserializer.attribute(null, \"lon\", latLonFormat.format(p.lon)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tserializer.startTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.text(format.format(new Date(p.time)));\r\n\t\t\t\t\t\tserializer.endTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.startTag(null, \"ele\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.text(p.ele + \"\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.endTag(null, \"ele\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tif (p.speed > 0) {\r\n\t\t\t\t\t\t\tserializer.startTag(null, \"speed\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t\tserializer.text(p.speed + \"\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t\tserializer.endTag(null, \"speed\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tserializer.endTag(null, \"trkpt\"); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tserializer.endTag(null, \"trkseg\"); //$NON-NLS-1$\r\n\t\t\t\t}\r\n\t\t\t\tserializer.endTag(null, \"trk\"); //$NON-NLS-1$\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (WptPt l : file.points) {\r\n\t\t\t\tserializer.startTag(null, \"wpt\"); //$NON-NLS-1$\r\n\t\t\t\tserializer.attribute(null, \"lat\", latLonFormat.format(l.lat)); //$NON-NLS-1$ \r\n\t\t\t\tserializer.attribute(null, \"lon\", latLonFormat.format(l.lon)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\tserializer.startTag(null, \"name\"); //$NON-NLS-1$\r\n\t\t\t\tserializer.text(l.name);\r\n\t\t\t\tserializer.endTag(null, \"name\"); //$NON-NLS-1$\r\n\t\t\t\tif (l.time != 0) {\r\n\t\t\t\t\tserializer.startTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t\tserializer.text(format.format(new Date(l.time)));\r\n\t\t\t\t\tserializer.endTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t}\r\n\t\t\t\tserializer.endTag(null, \"wpt\"); //$NON-NLS-1$\r\n\t\t\t}\r\n\r\n\t\t\tserializer.endTag(null, \"gpx\"); //$NON-NLS-1$\r\n\t\t\tserializer.flush();\r\n\t\t\tserializer.endDocument();\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\tlog.error(\"Error saving gpx\", e); //$NON-NLS-1$\r\n\t\t\treturn ctx.getString(R.string.error_occurred_saving_gpx);\r\n\t\t} catch (IOException e) {\r\n\t\t\tlog.error(\"Error saving gpx\", e); //$NON-NLS-1$\r\n\t\t\treturn ctx.getString(R.string.error_occurred_saving_gpx);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","id":89942,"modified_method":"public static String writeGpxFile(File fout, GPXFile file, Context ctx) {\r\n\t\ttry {\r\n\t\t\tSimpleDateFormat format = new SimpleDateFormat(GPX_TIME_FORMAT);\r\n\t\t\tformat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n\t\t\tFileOutputStream output = new FileOutputStream(fout);\r\n\t\t\tXmlSerializer serializer = Xml.newSerializer();\r\n\t\t\tserializer.setOutput(output, \"UTF-8\"); //$NON-NLS-1$\r\n\t\t\tserializer.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); //$NON-NLS-1$\r\n\t\t\tserializer.startDocument(\"UTF-8\", true); //$NON-NLS-1$\r\n\t\t\tserializer.startTag(null, \"gpx\"); //$NON-NLS-1$\r\n\t\t\tserializer.attribute(null, \"version\", \"1.1\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\tserializer.attribute(null, \"creator\", Version.APP_NAME_VERSION); //$NON-NLS-1$\r\n\t\t\tserializer.attribute(null, \"xmlns:xsi\", \"http://www.w3.org/2001/XMLSchema-instance\");\r\n\t\t\tserializer.attribute(null, \"xsi:schemaLocation\", \"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\");\r\n\t\t\t\r\n\r\n\t\t\tfor (Track track : file.tracks) {\r\n\t\t\t\tserializer.startTag(null, \"trk\"); //$NON-NLS-1$\r\n\t\t\t\tfor (TrkSegment segment : track.segments) {\r\n\t\t\t\t\tserializer.startTag(null, \"trkseg\"); //$NON-NLS-1$\r\n\t\t\t\t\tfor (TrkPt p : segment.points) {\r\n\t\t\t\t\t\tserializer.startTag(null, \"trkpt\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.attribute(null, \"lat\", latLonFormat.format(p.lat)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tserializer.attribute(null, \"lon\", latLonFormat.format(p.lon)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tserializer.startTag(null, \"ele\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.text(p.ele + \"\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.endTag(null, \"ele\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.startTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tserializer.text(format.format(new Date(p.time)));\r\n\t\t\t\t\t\tserializer.endTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tif (p.speed > 0) {\r\n\t\t\t\t\t\t\tserializer.startTag(null, \"extensions\");\r\n\t\t\t\t\t\t\tserializer.startTag(null, \"speed\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t\tserializer.text(p.speed + \"\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t\tserializer.endTag(null, \"speed\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t\tserializer.endTag(null, \"extensions\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tserializer.endTag(null, \"trkpt\"); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tserializer.endTag(null, \"trkseg\"); //$NON-NLS-1$\r\n\t\t\t\t}\r\n\t\t\t\tserializer.endTag(null, \"trk\"); //$NON-NLS-1$\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (WptPt l : file.points) {\r\n\t\t\t\tserializer.startTag(null, \"wpt\"); //$NON-NLS-1$\r\n\t\t\t\tserializer.attribute(null, \"lat\", latLonFormat.format(l.lat)); //$NON-NLS-1$ \r\n\t\t\t\tserializer.attribute(null, \"lon\", latLonFormat.format(l.lon)); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\tif (l.time != 0) {\r\n\t\t\t\t\tserializer.startTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t\tserializer.text(format.format(new Date(l.time)));\r\n\t\t\t\t\tserializer.endTag(null, \"time\"); //$NON-NLS-1$\r\n\t\t\t\t}\r\n\t\t\t\tserializer.startTag(null, \"name\"); //$NON-NLS-1$\r\n\t\t\t\tserializer.text(l.name);\r\n\t\t\t\tserializer.endTag(null, \"name\"); //$NON-NLS-1$\r\n\t\t\t\tserializer.endTag(null, \"wpt\"); //$NON-NLS-1$\r\n\t\t\t}\r\n\r\n\t\t\tserializer.endTag(null, \"gpx\"); //$NON-NLS-1$\r\n\t\t\tserializer.flush();\r\n\t\t\tserializer.endDocument();\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\tlog.error(\"Error saving gpx\", e); //$NON-NLS-1$\r\n\t\t\treturn ctx.getString(R.string.error_occurred_saving_gpx);\r\n\t\t} catch (IOException e) {\r\n\t\t\tlog.error(\"Error saving gpx\", e); //$NON-NLS-1$\r\n\t\t\treturn ctx.getString(R.string.error_occurred_saving_gpx);\r\n\t\t}\r\n\t\treturn null;\r\n\t}","commit_id":"dabe59eb7e0a1cd9f622466ad84ac605dbd64f4e","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping embedded kafka server...\");\n    kafkaServer.stopAndWait();\n  }","id":89943,"modified_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping embedded kafka server...\");\n    if (kafkaServer != null) {\n      kafkaServer.stopAndWait();\n    }\n  }","commit_id":"10766aa7e8055513d033a23f6665f311fd94ce9a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void init(String[] args) {\n    if (args.length != 1) {\n      String name = KafkaServerMain.class.getSimpleName();\n      throw new IllegalArgumentException(String.format(\"Usage: %s <brokerId>\", name));\n    }\n\n    int brokerId = Integer.parseInt(args[0]);\n\n    CConfiguration cConf = CConfiguration.create();\n    String zkConnectStr = String.format(\"%s/%s\", cConf.get(Constants.CFG_ZOOKEEPER_ENSEMBLE), ZOOKEEPER_NAMESPACE);\n    int port = cConf.getInt(KAFKA_PORT_CONFIG, -1);\n    int numPartitions = cConf.getInt(KAFKA_NUM_PARTITIONS_CONFIG, 1);\n    String logDir = cConf.get(KAFKA_LOG_DIR_CONFIG);\n\n    kafkaProperties = generateKafkaConfig(brokerId, zkConnectStr, port, numPartitions, logDir);\n  }","id":89944,"modified_method":"@Override\n  public void init(String[] args) {\n    LOG.info(String.format(\"Got args - %s\", Arrays.toString(args)));\n\n    if (args.length != 1) {\n      String name = KafkaServerMain.class.getSimpleName();\n      throw new IllegalArgumentException(String.format(\"Usage: %s <brokerId>\", name));\n    }\n\n    int brokerId = Integer.parseInt(args[0]);\n\n    CConfiguration cConf = CConfiguration.create();\n    String zkConnectStr = String.format(\"%s/%s\", cConf.get(Constants.CFG_ZOOKEEPER_ENSEMBLE), ZOOKEEPER_NAMESPACE);\n    int port = cConf.getInt(KAFKA_PORT_CONFIG, -1);\n    int numPartitions = cConf.getInt(KAFKA_NUM_PARTITIONS_CONFIG, 1);\n    String logDir = cConf.get(KAFKA_LOG_DIR_CONFIG);\n\n    kafkaProperties = generateKafkaConfig(brokerId, zkConnectStr, port, numPartitions, logDir);\n  }","commit_id":"10766aa7e8055513d033a23f6665f311fd94ce9a","url":"https://github.com/caskdata/cdap"},{"original_method":"public static Iterable<File> getClassPathJarsFiles(String hiveClassPath) {\n    if (hiveClassPath == null) {\n      return null;\n    }\n    return Iterables.transform(Splitter.on(':').split(hiveClassPath), STRING_FILE_FUNCTION);\n  }","id":89945,"modified_method":"/**\n   * Get all the files contained in a class path.\n   */\n  public static Iterable<File> getClassPathJarsFiles(String hiveClassPath) {\n    if (hiveClassPath == null) {\n      return null;\n    }\n    return Iterables.transform(Splitter.on(':').split(hiveClassPath), STRING_FILE_FUNCTION);\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Check that Hive is in the class path - with a right version.\n   *\n   * @param hiveClassLoader class loader to use to load hive classes.\n   *                        If null, the class loader of this class is used.\n   */\n  public static HiveSuport checkHiveSupport(ClassLoader hiveClassLoader) {\n    try {\n      ClassLoader usingCL = hiveClassLoader;\n      if (usingCL == null) {\n        usingCL = ExploreServiceUtils.class.getClassLoader();\n      }\n\n      // In Hive 12, CLIService.getOperationStatus returns OperationState.\n      // In Hive 13, CLIService.getOperationStatus returns OperationStatus.\n      Class cliServiceClass = usingCL.loadClass(\"org.apache.hive.service.cli.CLIService\");\n      Class operationHandleCl = usingCL.loadClass(\"org.apache.hive.service.cli.OperationHandle\");\n      Method getOperationMethod = cliServiceClass.getDeclaredMethod(\"getOperationStatus\", operationHandleCl);\n\n      // Rowset is an interface in Hive 13, but a class in Hive 12\n      Class rowSetClass = usingCL.loadClass(\"org.apache.hive.service.cli.RowSet\");\n\n      if (rowSetClass.isInterface()\n        && getOperationMethod.getReturnType() == usingCL.loadClass(\"org.apache.hive.service.cli.OperationStatus\")) {\n        return HiveSuport.HIVE_13;\n      } else if (!rowSetClass.isInterface()\n        && getOperationMethod.getReturnType() == usingCL.loadClass(\"org.apache.hive.service.cli.OperationState\")) {\n        return HiveSuport.HIVE_12;\n      }\n      throw new RuntimeException(\"Hive distribution not supported.\");\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Throwable e) {\n      throw new RuntimeException(\"Hive jars not present in classpath\", e);\n    }\n  }","id":89946,"modified_method":"/**\n   * Check that Hive is in the class path - with a right version.\n   *\n   * @param hiveClassLoader class loader to use to load hive classes.\n   *                        If null, the class loader of this class is used.\n   */\n  public static HiveSupport checkHiveSupport(ClassLoader hiveClassLoader) {\n    try {\n      ClassLoader usingCL = hiveClassLoader;\n      if (usingCL == null) {\n        usingCL = ExploreServiceUtils.class.getClassLoader();\n      }\n\n      // In Hive 12, CLIService.getOperationStatus returns OperationState.\n      // In Hive 13, CLIService.getOperationStatus returns OperationStatus.\n      Class cliServiceClass = usingCL.loadClass(\"org.apache.hive.service.cli.CLIService\");\n      Class operationHandleCl = usingCL.loadClass(\"org.apache.hive.service.cli.OperationHandle\");\n      Method getStatusMethod = cliServiceClass.getDeclaredMethod(\"getOperationStatus\", operationHandleCl);\n\n      // Rowset is an interface in Hive 13, but a class in Hive 12\n      Class rowSetClass = usingCL.loadClass(\"org.apache.hive.service.cli.RowSet\");\n\n      if (rowSetClass.isInterface()\n        && getStatusMethod.getReturnType() == usingCL.loadClass(\"org.apache.hive.service.cli.OperationStatus\")) {\n        return HiveSupport.HIVE_13;\n      } else if (!rowSetClass.isInterface()\n        && getStatusMethod.getReturnType() == usingCL.loadClass(\"org.apache.hive.service.cli.OperationState\")) {\n        return HiveSupport.HIVE_12;\n      }\n      throw new RuntimeException(\"Hive distribution not supported. Set the configuration reactor.explore.enabled \" +\n                                 \"to false to start up Reactor without Explore.\");\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Throwable e) {\n      throw new RuntimeException(\"Hive jars not present in classpath. Set the configuration reactor.explore.enabled \" +\n                                 \"to false to start up Reactor without Explore.\", e);\n    }\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"public static Class getHiveService() {\n    HiveSuport hiveVersion = checkHiveSupport(null);\n    Class hiveServiceCl = hiveVersion.getHiveExploreServiceClass();\n    return hiveServiceCl;\n  }","id":89947,"modified_method":"public static Class getHiveService() {\n    HiveSupport hiveVersion = checkHiveSupport(null);\n    Class hiveServiceCl = hiveVersion.getHiveExploreServiceClass();\n    return hiveServiceCl;\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Trace the jar dependencies needed by the Explore container, using\n   * a class loader will be built with the class path given in parameter.\n   *\n   * @param hiveClassPathStr Class path to use to build the custom class loader.\n   * @return an ordered set of jar files.\n   */\n  public static Set<File> traceExploreDependencies(String hiveClassPathStr) throws IOException {\n    if (exploreDependencies != null) {\n      return exploreDependencies;\n    }\n\n    ClassLoader classLoader = buildClassLoader(hiveClassPathStr);\n    return traceExploreDependencies(classLoader);\n  }","id":89948,"modified_method":"/**\n   * Trace the jar dependencies needed by the Explore container. Uses a separate class loader to load Hive classes,\n   * built using the explore classpath passed as a system property to reactor-master.\n   *\n   * @return an ordered set of jar files.\n   */\n  public static Set<File> traceExploreDependencies() throws IOException {\n    if (exploreDependencies != null) {\n      return exploreDependencies;\n    }\n\n    ClassLoader classLoader = getExploreClassLoader();\n    return traceExploreDependencies(classLoader);\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"private TwillPreparer getPreparer() {\n    TwillPreparer preparer = twillRunnerService.prepare(twillApplication)\n      .addLogHandler(new PrinterLogHandler(new PrintWriter(System.out)));\n    preparer = prepareHiveContainer(preparer);\n    return prepare(preparer);\n  }","id":89949,"modified_method":"private TwillPreparer getPreparer() {\n    TwillPreparer preparer = twillRunnerService.prepare(twillApplication)\n      .addLogHandler(new PrinterLogHandler(new PrintWriter(System.out)));\n    preparer = prepareExploreContainer(preparer);\n    return prepare(preparer);\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping {}\", serviceName);\n    stopFlag = true;\n\n    dsService.stopAndWait();\n    if (isLeader.get() && twillController != null) {\n      twillController.stopAndWait();\n    }\n\n    leaderElection.stopAndWait();\n    Services.chainStop(metricsCollectionService, kafkaClientService, zkClientService);\n  }","id":89950,"modified_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping {}\", serviceName);\n    stopFlag = true;\n\n    dsService.stopAndWait();\n    if (isLeader.get() && twillController != null) {\n      twillController.stopAndWait();\n    }\n\n    if (leaderElection != null) {\n      leaderElection.stopAndWait();\n    }\n    Services.chainStop(metricsCollectionService, kafkaClientService, zkClientService);\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void init(String[] args) {\n    isHiveEnabled = cConf.getBoolean(Constants.Explore.CFG_EXPLORE_ENABLED);\n    serviceName = Constants.Service.REACTOR_SERVICES;\n    cConf.set(Constants.Dataset.Manager.ADDRESS, getLocalHost().getCanonicalHostName());\n\n    baseInjector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new LoggingModules().getDistributedModules(),\n      new IOModule(),\n      new AuthModule(),\n      new KafkaClientModule(),\n      new TwillModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new DataSetServiceModules().getDistributedModule(),\n      new DataFabricModules().getDistributedModules(),\n      new MetricsClientRuntimeModule().getDistributedModules(),\n      new ServiceStoreModules().getDistributedModule()\n    );\n\n    // Initialize ZK client\n    zkClientService = baseInjector.getInstance(ZKClientService.class);\n    kafkaClientService = baseInjector.getInstance(KafkaClientService.class);\n    metricsCollectionService = baseInjector.getInstance(MetricsCollectionService.class);\n    dsService = baseInjector.getInstance(DatasetService.class);\n    serviceStore = baseInjector.getInstance(ServiceStore.class);\n    systemServiceInstanceMap = getConfigKeys();\n\n    locationFactory = baseInjector.getInstance(LocationFactory.class);\n    secureStoreUpdater = new HBaseSecureStoreUpdater(hConf, locationFactory);\n  }","id":89951,"modified_method":"@Override\n  public void init(String[] args) {\n    isExploreEnabled = cConf.getBoolean(Constants.Explore.CFG_EXPLORE_ENABLED);\n    serviceName = Constants.Service.REACTOR_SERVICES;\n    cConf.set(Constants.Dataset.Manager.ADDRESS, getLocalHost().getCanonicalHostName());\n\n    baseInjector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new LoggingModules().getDistributedModules(),\n      new IOModule(),\n      new AuthModule(),\n      new KafkaClientModule(),\n      new TwillModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new DataSetServiceModules().getDistributedModule(),\n      new DataFabricModules().getDistributedModules(),\n      new MetricsClientRuntimeModule().getDistributedModules(),\n      new ServiceStoreModules().getDistributedModule()\n    );\n\n    // Initialize ZK client\n    zkClientService = baseInjector.getInstance(ZKClientService.class);\n    kafkaClientService = baseInjector.getInstance(KafkaClientService.class);\n    metricsCollectionService = baseInjector.getInstance(MetricsCollectionService.class);\n    dsService = baseInjector.getInstance(DatasetService.class);\n    serviceStore = baseInjector.getInstance(ServiceStore.class);\n    systemServiceInstanceMap = getConfigKeys();\n\n    locationFactory = baseInjector.getInstance(LocationFactory.class);\n    secureStoreUpdater = new HBaseSecureStoreUpdater(hConf, locationFactory);\n\n    checkExploreRequirements();\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"private TwillApplication createTwillApplication(final Map<String, Integer> instanceCountMap) {\n    try {\n      return new ReactorTwillApplication(cConf, getSavedCConf(), getSavedHConf(), isHiveEnabled, instanceCountMap);\n    } catch (Exception e) {\n      throw  Throwables.propagate(e);\n    }\n  }","id":89952,"modified_method":"private TwillApplication createTwillApplication(final Map<String, Integer> instanceCountMap) {\n    try {\n      return new ReactorTwillApplication(cConf, getSavedCConf(), getSavedHConf(), isExploreEnabled, instanceCountMap);\n    } catch (Exception e) {\n      throw  Throwables.propagate(e);\n    }\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"private TwillPreparer prepareHiveContainer(TwillPreparer preparer) {\n    if (!isHiveEnabled) {\n      return preparer;\n    }\n\n    // HIVE_CLASSPATH will be defined in startup scripts if Hive is installed.\n    String hiveClassPathStr = System.getProperty(Constants.Explore.HIVE_CLASSPATH);\n    LOG.debug(\"Hive classpath = {}\", hiveClassPathStr);\n    if (hiveClassPathStr == null) {\n      throw new RuntimeException(\"System property \" + Constants.Explore.HIVE_CLASSPATH + \" is not set.\");\n    }\n\n    // Here we need to get a different class loader that contains all the hive jars,\n    // because Hive ships a lot of dependencies that conflicts with ours.\n    ClassLoader hiveCL = ExploreServiceUtils.buildClassLoader(hiveClassPathStr);\n\n    // This checking will throw an exception if Hive is not present or if its version is unsupported\n    ExploreServiceUtils.checkHiveSupport(hiveCL);\n\n    return addHiveDependenciesToPreparer(preparer, hiveCL);\n  }","id":89953,"modified_method":"/**\n   * Prepare the specs of the twill application for the Explore twill runnable.\n   * Add jars needed by the Explore module in the classpath of the containers, and\n   * add conf files (hive_site.xml, etc) as resources available for the Explore twill\n   * runnable.\n   */\n  private TwillPreparer prepareExploreContainer(TwillPreparer preparer) {\n    if (!isExploreEnabled) {\n      return preparer;\n    }\n\n    try {\n      // Put jars needed by Hive in the containers classpath. Those jars are localized in the Explore\n      // container by ReactorTwillApplication, so they are available for ExploreServiceTwillRunnable\n      Set<File> jars = ExploreServiceUtils.traceExploreDependencies();\n      for (File jarFile : jars) {\n        LOG.trace(\"Adding jar file to classpath: {}\", jarFile.getName());\n        preparer = preparer.withClassPaths(jarFile.getName());\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Unable to trace Explore dependencies\", e);\n    }\n\n    // HIVE_CONF_FILES will be defined in startup scripts if Hive is installed.\n    String hiveConfFiles = System.getProperty(Constants.Explore.HIVE_CONF_FILES);\n    LOG.debug(\"Hive conf files = {}\", hiveConfFiles);\n    if (hiveConfFiles == null) {\n      throw new RuntimeException(\"System property \" + Constants.Explore.HIVE_CONF_FILES + \" is not set.\");\n    }\n\n    // Add all the conf files needed by hive as resources available to containers\n    Iterable<File> hiveConfFilesFiles = ExploreServiceUtils.getClassPathJarsFiles(hiveConfFiles);\n    for (File file : hiveConfFilesFiles) {\n      if (file.getName().matches(\".*\\\\.xml\")) {\n        preparer = preparer.withResources(file.toURI());\n      }\n    }\n\n    return preparer;\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"private TwillSpecification.Builder.RunnableSetter addExploreService(TwillSpecification.Builder.MoreRunnable builder) {\n\n    ResourceSpecification resourceSpec = ResourceSpecification.Builder.with()\n      .setVirtualCores(cConf.getInt(Constants.Explore.CONTAINER_VIRTUAL_CORES, 1))\n      .setMemory(cConf.getInt(Constants.Explore.CONTAINER_MEMORY_MB, 512), ResourceSpecification.SizeUnit.MEGA)\n      .setInstances(cConf.getInt(Constants.Explore.CONTAINER_INSTANCES, 1))\n      .build();\n\n    TwillSpecification.Builder.MoreFile twillSpecs =\n      builder.add(new ExploreServiceTwillRunnable(\"explore.executor\", \"cConf.xml\", \"hConf.xml\"), resourceSpec)\n        .withLocalFiles()\n        .add(\"cConf.xml\", cConfFile.toURI())\n        .add(\"hConf.xml\", hConfFile.toURI());\n\n    // HIVE_CLASSPATH will be defined in startup scripts if Hive is installed.\n    String hiveClassPathStr = System.getProperty(Constants.Explore.HIVE_CLASSPATH);\n    if (hiveClassPathStr == null) {\n      throw new RuntimeException(\"System property \" + Constants.Explore.HIVE_CLASSPATH + \" is not set.\");\n    }\n\n    try {\n      // Ship jars needed by Hive to the container\n      Set<File> jars = ExploreServiceUtils.traceExploreDependencies(hiveClassPathStr);\n      for (File jarFile : jars) {\n        twillSpecs = twillSpecs.add(jarFile.getName(), jarFile);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Unable to trace Explore dependencies\", e);\n    }\n\n    return twillSpecs.apply();\n  }","id":89954,"modified_method":"private TwillSpecification.Builder.RunnableSetter addExploreService(TwillSpecification.Builder.MoreRunnable builder) {\n\n    ResourceSpecification resourceSpec = ResourceSpecification.Builder.with()\n      .setVirtualCores(cConf.getInt(Constants.Explore.CONTAINER_VIRTUAL_CORES, 1))\n      .setMemory(cConf.getInt(Constants.Explore.CONTAINER_MEMORY_MB, 512), ResourceSpecification.SizeUnit.MEGA)\n      .setInstances(cConf.getInt(Constants.Explore.CONTAINER_INSTANCES, 1))\n      .build();\n\n    TwillSpecification.Builder.MoreFile twillSpecs =\n      builder.add(new ExploreServiceTwillRunnable(\"explore.executor\", \"cConf.xml\", \"hConf.xml\"), resourceSpec)\n        .withLocalFiles()\n        .add(\"cConf.xml\", cConfFile.toURI())\n        .add(\"hConf.xml\", hConfFile.toURI());\n\n    try {\n      // Ship jars needed by Hive to the container\n      Set<File> jars = ExploreServiceUtils.traceExploreDependencies();\n      for (File jarFile : jars) {\n        twillSpecs = twillSpecs.add(jarFile.getName(), jarFile);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Unable to trace Explore dependencies\", e);\n    }\n\n    return twillSpecs.apply();\n  }","commit_id":"65199449fdb6cd3adf735477b93988d404220809","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping {}\", serviceName);\n    stopFlag = true;\n\n    dsService.stopAndWait();\n    if (isLeader.get() && twillController != null) {\n      twillController.stopAndWait();\n    }\n\n    if (leaderElection != null) {\n      leaderElection.stopAndWait();\n    }\n    Futures.getUnchecked(Services.chainStop(serviceStore, metricsCollectionService, kafkaClientService,\n                                            zkClientService));\n\n    try {\n      exploreClient.close();\n    } catch (IOException e) {\n      LOG.error(\"Could not close Explore client\", e);\n      throw Throwables.propagate(e);\n    }\n  }","id":89955,"modified_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping {}\", serviceName);\n    stopFlag = true;\n\n    if (dsService != null) {\n      dsService.stopAndWait();\n    }\n\n    if (isLeader.get() && twillController != null) {\n      twillController.stopAndWait();\n    }\n\n    if (leaderElection != null) {\n      leaderElection.stopAndWait();\n    }\n    Futures.getUnchecked(Services.chainStop(serviceStore, metricsCollectionService, kafkaClientService,\n                                            zkClientService));\n\n    try {\n      exploreClient.close();\n    } catch (IOException e) {\n      LOG.error(\"Could not close Explore client\", e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"53a39ad91c6c0ecf56f676898906b6b534bf11a7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void init(String[] args) {\n    exploreEnabled = cConf.getBoolean(Constants.Explore.EXPLORE_ENABLED);\n    serviceName = Constants.Service.MASTER_SERVICES;\n    cConf.set(Constants.Dataset.Manager.ADDRESS, getLocalHost().getCanonicalHostName());\n\n    try {\n      SecurityUtil.loginForMasterService(cConf);\n    } catch (Exception e) {\n      LOG.error(\"Failed to login as CDAP user\", e);\n      throw Throwables.propagate(e);\n    }\n\n    baseInjector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new LoggingModules().getDistributedModules(),\n      new IOModule(),\n      new AuthModule(),\n      new KafkaClientModule(),\n      new TwillModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new DataSetServiceModules().getDistributedModule(),\n      new DataFabricModules().getDistributedModules(),\n      new DataSetsModules().getDistributedModule(),\n      new MetricsClientRuntimeModule().getDistributedModules(),\n      new ServiceStoreModules().getDistributedModule(),\n      new ExploreClientModule(),\n      new NotificationFeedServiceRuntimeModule().getDistributedModules(),\n      new NotificationServiceRuntimeModule().getDistributedModules(),\n      new StreamAdminModules().getDistributedModules()\n    );\n\n    // Initialize ZK client\n    zkClientService = baseInjector.getInstance(ZKClientService.class);\n    kafkaClientService = baseInjector.getInstance(KafkaClientService.class);\n    metricsCollectionService = baseInjector.getInstance(MetricsCollectionService.class);\n    dsService = baseInjector.getInstance(DatasetService.class);\n    serviceStore = baseInjector.getInstance(ServiceStore.class);\n    exploreClient = baseInjector.getInstance(ExploreClient.class);\n    secureStoreUpdater = baseInjector.getInstance(TokenSecureStoreUpdater.class);\n\n    checkTransactionRequirements();\n    checkExploreRequirements();\n  }","id":89956,"modified_method":"@Override\n  public void init(String[] args) {\n    CConfigurationUtil.checkCConfValidity(cConf);\n    exploreEnabled = cConf.getBoolean(Constants.Explore.EXPLORE_ENABLED);\n    serviceName = Constants.Service.MASTER_SERVICES;\n    cConf.set(Constants.Dataset.Manager.ADDRESS, getLocalHost().getCanonicalHostName());\n\n    try {\n      SecurityUtil.loginForMasterService(cConf);\n    } catch (Exception e) {\n      LOG.error(\"Failed to login as CDAP user\", e);\n      throw Throwables.propagate(e);\n    }\n\n    baseInjector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new LoggingModules().getDistributedModules(),\n      new IOModule(),\n      new AuthModule(),\n      new KafkaClientModule(),\n      new TwillModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new DataSetServiceModules().getDistributedModule(),\n      new DataFabricModules().getDistributedModules(),\n      new DataSetsModules().getDistributedModule(),\n      new MetricsClientRuntimeModule().getDistributedModules(),\n      new ServiceStoreModules().getDistributedModule(),\n      new ExploreClientModule(),\n      new NotificationFeedServiceRuntimeModule().getDistributedModules(),\n      new NotificationServiceRuntimeModule().getDistributedModules(),\n      new StreamAdminModules().getDistributedModules()\n    );\n\n    // Initialize ZK client\n    zkClientService = baseInjector.getInstance(ZKClientService.class);\n    kafkaClientService = baseInjector.getInstance(KafkaClientService.class);\n    metricsCollectionService = baseInjector.getInstance(MetricsCollectionService.class);\n    dsService = baseInjector.getInstance(DatasetService.class);\n    serviceStore = baseInjector.getInstance(ServiceStore.class);\n    exploreClient = baseInjector.getInstance(ExploreClient.class);\n    secureStoreUpdater = baseInjector.getInstance(TokenSecureStoreUpdater.class);\n\n    checkTransactionRequirements();\n    checkExploreRequirements();\n  }","commit_id":"53a39ad91c6c0ecf56f676898906b6b534bf11a7","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Start the service.\n   */\n  public void startUp() throws Exception {\n    // Start all the services.\n    txService.startAndWait();\n    metricsCollectionService.startAndWait();\n    datasetService.startAndWait();\n    serviceStore.startAndWait();\n    streamService.startAndWait();\n\n    // It is recommended to initialize log appender after datasetService is started,\n    // since log appender instantiates a dataset.\n    logAppenderInitializer.initialize();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric\");\n    }\n\n    metricsQueryService.startAndWait();\n    router.startAndWait();\n    if (webCloudAppService != null) {\n      webCloudAppService.startAndWait();\n    }\n\n    if (securityEnabled) {\n      externalAuthenticationServer.startAndWait();\n    }\n\n    if (exploreExecutorService != null) {\n      exploreExecutorService.startAndWait();\n    }\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    String protocol = sslEnabled ? \"https\" : \"http\";\n    int dashboardPort = sslEnabled ?\n      configuration.getInt(Constants.Dashboard.SSL_BIND_PORT) :\n      configuration.getInt(Constants.Dashboard.BIND_PORT);\n    System.out.println(\"Standalone CDAP started successfully.\");\n    System.out.printf(\"Connect to the Console at %s://%s:%d\\n\", protocol, hostname, dashboardPort);\n  }","id":89957,"modified_method":"/**\n   * Start the service.\n   */\n  public void startUp() throws Exception {\n    CConfigurationUtil.checkCConfValidity(configuration);\n    // Start all the services.\n    txService.startAndWait();\n    metricsCollectionService.startAndWait();\n    datasetService.startAndWait();\n    serviceStore.startAndWait();\n    streamService.startAndWait();\n\n    // It is recommended to initialize log appender after datasetService is started,\n    // since log appender instantiates a dataset.\n    logAppenderInitializer.initialize();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric\");\n    }\n\n    metricsQueryService.startAndWait();\n    router.startAndWait();\n    if (webCloudAppService != null) {\n      webCloudAppService.startAndWait();\n    }\n\n    if (securityEnabled) {\n      externalAuthenticationServer.startAndWait();\n    }\n\n    if (exploreExecutorService != null) {\n      exploreExecutorService.startAndWait();\n    }\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    String protocol = sslEnabled ? \"https\" : \"http\";\n    int dashboardPort = sslEnabled ?\n      configuration.getInt(Constants.Dashboard.SSL_BIND_PORT) :\n      configuration.getInt(Constants.Dashboard.BIND_PORT);\n    System.out.println(\"Standalone CDAP started successfully.\");\n    System.out.printf(\"Connect to the Console at %s://%s:%d\\n\", protocol, hostname, dashboardPort);\n  }","commit_id":"53a39ad91c6c0ecf56f676898906b6b534bf11a7","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Creates the menu responsible for desktop sharing when a single desktop\n     * sharing contact is available.\n     *\n     * @return the created popup menu\n     */\n    private JPopupMenu createResizeVideoMenu()\n    {\n        final JPopupMenu popupMenu = new JPopupMenu(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.CHANGE_VIDEO_QUALITY\"));\n\n        popupMenu.setInvoker(this);\n        popupMenu.setFocusable(true);\n\n        JMenuItem lowQuality = new JMenuItem(\n            GuiActivator.getResources()\n                .getI18NString(\"service.gui.LOW_QUALITY\")\n                + \" (\"\n                + (int) QualityPreset.LO_QUALITY.getResolution().getHeight()\n                + \"p)\",\n            GuiActivator.getResources()\n                .getImage(\"service.gui.icons.LO_VIDEO_ICON\"));\n\n        JMenuItem normalQuality = new JMenuItem(GuiActivator.getResources()\n                .getI18NString(\"service.gui.SD_QUALITY\")\n                + \" (\"\n                + (int) QualityPreset.SD_QUALITY.getResolution().getHeight()\n                + \"p)\",\n            GuiActivator.getResources()\n                .getImage(\"service.gui.icons.SD_VIDEO_ICON\"));\n\n        JMenuItem hdQuality = new JMenuItem(GuiActivator.getResources()\n                .getI18NString(\"service.gui.HD_QUALITY\")\n                + \" (\"\n                + (int) QualityPreset.HD_QUALITY.getResolution().getHeight()\n                + \"p)\",\n            GuiActivator.getResources()\n                .getImage(\"service.gui.icons.HD_VIDEO_ICON\"));\n\n        JLabel titleLabel = new JLabel(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.CHANGE_VIDEO_QUALITY\"));\n\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n        popupMenu.add(titleLabel);\n        popupMenu.addSeparator();\n        popupMenu.add(hdQuality);\n        popupMenu.add(normalQuality);\n        popupMenu.add(lowQuality);\n\n        lowQuality.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                popupMenu.setVisible(false);\n\n                setIconImageID(ImageLoader.LO_VIDEO_BUTTON);\n\n                CallManager.setVideoQualityPreset(\n                        call.getCallPeers().next(),\n                        QualityPreset.LO_QUALITY);\n            }\n        });\n\n        normalQuality.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                popupMenu.setVisible(false);\n\n                setIconImageID(ImageLoader.SD_VIDEO_BUTTON);\n\n                CallManager.setVideoQualityPreset(\n                        call.getCallPeers().next(), QualityPreset.SD_QUALITY);\n            }\n        });\n\n        hdQuality.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                popupMenu.setVisible(false);\n\n                setIconImageID(ImageLoader.HD_VIDEO_BUTTON);\n\n                CallManager.setVideoQualityPreset(\n                        call.getCallPeers().next(), QualityPreset.HD_QUALITY);\n            }\n        });\n\n        return popupMenu;\n    }","id":89958,"modified_method":"/**\n     * Creates the menu responsible for desktop sharing when a single desktop\n     * sharing contact is available.\n     *\n     * @return the created popup menu\n     */\n    private JPopupMenu createResizeVideoMenu()\n    {\n        final JPopupMenu popupMenu = new JPopupMenu(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.CHANGE_VIDEO_QUALITY\"));\n\n        popupMenu.setInvoker(this);\n        popupMenu.setFocusable(true);\n\n        Dimension loDimension = QualityPreset.LO_QUALITY.getResolution();\n        Dimension sdDimension = QualityPreset.SD_QUALITY.getResolution();\n        Dimension hdDimension = QualityPreset.HD_QUALITY.getResolution();\n\n        JMenuItem lowQuality = new JMenuItem(\n            GuiActivator.getResources()\n                .getI18NString(\"service.gui.LOW_QUALITY\")\n                + getFormattedDimension(loDimension),\n            GuiActivator.getResources()\n                .getImage(\"service.gui.icons.LO_VIDEO_ICON\"));\n\n        JMenuItem normalQuality = new JMenuItem(GuiActivator.getResources()\n                .getI18NString(\"service.gui.SD_QUALITY\")\n                + getFormattedDimension(sdDimension),\n            GuiActivator.getResources()\n                .getImage(\"service.gui.icons.SD_VIDEO_ICON\"));\n\n        JMenuItem hdQuality = new JMenuItem(GuiActivator.getResources()\n                .getI18NString(\"service.gui.HD_QUALITY\")\n                + getFormattedDimension(hdDimension),\n            GuiActivator.getResources()\n                .getImage(\"service.gui.icons.HD_VIDEO_ICON\"));\n\n        JLabel titleLabel = new JLabel(\n            GuiActivator.getResources().getI18NString(\n                \"service.gui.CHANGE_VIDEO_QUALITY\"));\n\n        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));\n        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n        popupMenu.add(titleLabel);\n        popupMenu.addSeparator();\n        popupMenu.add(hdQuality);\n        popupMenu.add(normalQuality);\n        popupMenu.add(lowQuality);\n\n        lowQuality.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                popupMenu.setVisible(false);\n\n                setIconImageID(ImageLoader.LO_VIDEO_BUTTON);\n\n                CallManager.setVideoQualityPreset(\n                        call.getCallPeers().next(),\n                        QualityPreset.LO_QUALITY);\n            }\n        });\n\n        normalQuality.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                popupMenu.setVisible(false);\n\n                setIconImageID(ImageLoader.SD_VIDEO_BUTTON);\n\n                CallManager.setVideoQualityPreset(\n                        call.getCallPeers().next(), QualityPreset.SD_QUALITY);\n            }\n        });\n\n        hdQuality.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                popupMenu.setVisible(false);\n\n                setIconImageID(ImageLoader.HD_VIDEO_BUTTON);\n\n                CallManager.setVideoQualityPreset(\n                        call.getCallPeers().next(), QualityPreset.HD_QUALITY);\n            }\n        });\n\n        return popupMenu;\n    }","commit_id":"912204639150d59d91ab0066ff275d8ea5f01e1c","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Nonnull\n    private Privilege[] getPrivileges(String absPath, PermissionProvider provider) throws RepositoryException {\n        // TODO\n        String oakPath = getOakPath(absPath);\n        Tree tree = getTree(oakPath);\n        Set<String> pNames = provider.getPrivilegeNames(tree);\n        if (pNames.isEmpty()) {\n            return new Privilege[0];\n        } else {\n            Set<Privilege> privileges = new HashSet<Privilege>(pNames.size());\n            for (String name : pNames) {\n                privileges.add(privilegeManager.getPrivilege(namePathMapper.getJcrName(name)));\n            }\n            return privileges.toArray(new Privilege[privileges.size()]);\n        }\n    }","id":89959,"modified_method":"@Nonnull\n    private Privilege[] getPrivileges(String absPath, PermissionProvider provider) throws RepositoryException {\n        // TODO\n        String oakPath = getOakPath(absPath);\n        Tree tree = getTree(oakPath);\n        Set<String> pNames = provider.getPrivileges(tree);\n        if (pNames.isEmpty()) {\n            return new Privilege[0];\n        } else {\n            Set<Privilege> privileges = new HashSet<Privilege>(pNames.size());\n            for (String name : pNames) {\n                privileges.add(privilegeManager.getPrivilege(namePathMapper.getJcrName(name)));\n            }\n            return privileges.toArray(new Privilege[privileges.size()]);\n        }\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void addEntry(@Nonnull Principal principal, @Nonnull Tree entryTree) {\n            NodeUtil node = new NodeUtil(entryTree);\n            Entry entry = new Entry(node);\n            if (entry.permissions != Permissions.NO_PERMISSION) {\n                Key key = new Key(node);\n                if (principal instanceof Group) {\n                    groupEntries.put(key, entry);\n                } else {\n                    userEntries.put(key, entry);\n                }\n            }\n        }","id":89960,"modified_method":"private void addEntry(@Nonnull Principal principal, @Nonnull Tree entryTree) {\n            Entry entry = new Entry(entryTree);\n            if (entry.privilegeBits.isEmpty()) {\n                Key key = new Key(entryTree);\n                if (principal instanceof Group) {\n                    groupEntries.put(key, entry);\n                } else {\n                    userEntries.put(key, entry);\n                }\n            }\n        }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public CompiledPermissionImpl(@Nonnull ReadOnlyTree permissionsTree,\n                                  @Nonnull Set<Principal> principals) {\n        this.principals = checkNotNull(principals);\n\n        EntriesBuilder builder = new EntriesBuilder();\n        for (Principal principal : principals) {\n            Tree t = permissionsTree.getChild(Text.escapeIllegalJcrChars(principal.getName()));\n            if (t != null) {\n                builder.addEntry(principal, t);\n            }\n        }\n        userEntries = builder.userEntries.build();\n        groupEntries = builder.groupEntries.build();\n    }","id":89961,"modified_method":"public CompiledPermissionImpl(@Nonnull Set<Principal> principals,\n                                  @Nonnull PrivilegeDefinitionStore privilegeStore,\n                                  @Nonnull ReadOnlyTree permissionsTree) {\n        this.principals = checkNotNull(principals);\n        this.privilegeStore = privilegeStore;\n\n        EntriesBuilder builder = new EntriesBuilder();\n        for (Principal principal : principals) {\n            Tree t = permissionsTree.getChild(Text.escapeIllegalJcrChars(principal.getName()));\n            if (t != null) {\n                builder.addEntry(principal, t);\n            }\n        }\n        userEntries = builder.userEntries.build();\n        groupEntries = builder.groupEntries.build();\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public Set<String> getPrivilegeNames(@Nullable Tree tree) {\n        return Collections.singleton(PrivilegeConstants.JCR_ALL);\n    }","id":89962,"modified_method":"@Nonnull\n    @Override\n    public Set<String> getPrivileges(@Nullable Tree tree) {\n        return Collections.singleton(PrivilegeConstants.JCR_ALL);\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    private String getVersionablePath(@Nonnull Tree versionStoreTree, @Nullable PropertyState property) {\n        String versionablePath = null;\n        Tree t = versionStoreTree;\n        while (!JcrConstants.JCR_SYSTEM.equals(t.getName())) {\n            if (JcrConstants.NT_VERSIONHISTORY.equals(TreeUtil.getPrimaryTypeName(t))) {\n                PropertyState prop = t.getProperty(workspaceName);\n                if (prop != null) {\n                    versionablePath = prop.getValue(Type.PATH);\n                    if (t != versionStoreTree) {\n                        String rel = PathUtils.relativize(t.getPath(), versionStoreTree.getPath());\n                        String propName = (property == null) ? \"\" : property.getName();\n                        versionablePath = PathUtils.concat(versionablePath, rel, propName);\n                    }\n                }\n                break;\n            }// FIXME: handle activities and configurations\n            t = t.getParent();\n        }\n\n        if (versionablePath == null || versionablePath.length() == 0) {\n            log.warn(\"Unable to determine path of the versionable node.\");\n        }\n        return Strings.emptyToNull(versionablePath);\n    }","id":89963,"modified_method":"@CheckForNull\n    private String getVersionablePath(@Nonnull Tree versionStoreTree, @Nullable PropertyState property) {\n        String relPath = \"\";\n        String propName = (property == null) ? \"\" : property.getName();\n        String versionablePath = null;\n        Tree t = versionStoreTree;\n        while (t != null && !JcrConstants.JCR_VERSIONSTORAGE.equals(t.getName())) {\n            String name = t.getName();\n            String ntName = TreeUtil.getPrimaryTypeName(t);\n            if (VersionConstants.JCR_FROZENNODE.equals(name) && t != versionStoreTree) {\n                relPath = PathUtils.relativize(t.getPath(), versionStoreTree.getPath());\n            } else if (JcrConstants.NT_VERSIONHISTORY.equals(ntName)) {\n                PropertyState prop = t.getProperty(workspaceName);\n                if (prop != null) {\n                    versionablePath = PathUtils.concat(prop.getValue(Type.PATH), relPath, propName);\n                }\n                break;\n            }\n            t = t.getParent();\n        }\n\n        if (versionablePath == null || versionablePath.length() == 0) {\n            log.warn(\"Unable to determine path of the version controlled node.\");\n        }\n        return Strings.emptyToNull(versionablePath);\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public PermissionProviderImpl(@Nonnull Root root, @Nonnull Set<Principal> principals,\n                                  @Nonnull SecurityProvider securityProvider) {\n        this.root = new ReadOnlyRoot(root);\n        this.acContext = securityProvider.getAccessControlConfiguration().getContext();\n        if (principals.contains(SystemPrincipal.INSTANCE) || isAdmin(principals)) {\n            compiledPermissions = AllPermissions.getInstance();\n        } else {\n            String relativePath = PERMISSIONS_STORE_PATH + '/' + workspaceName;\n            ReadOnlyTree rootTree = ReadOnlyTree.createFromRoot(root);\n            ReadOnlyTree permissionsTree = getPermissionsRoot(rootTree, relativePath);\n            if (permissionsTree == null) {\n                compiledPermissions = NoPermissions.getInstance();\n            } else {\n                compiledPermissions = new CompiledPermissionImpl(permissionsTree, principals);\n            }\n        }\n    }","id":89964,"modified_method":"public PermissionProviderImpl(@Nonnull Root root, @Nonnull Set<Principal> principals,\n                                  @Nonnull SecurityProvider securityProvider) {\n        this.root = new ReadOnlyRoot(root);\n        this.acContext = securityProvider.getAccessControlConfiguration().getContext();\n        if (principals.contains(SystemPrincipal.INSTANCE) || isAdmin(principals)) {\n            compiledPermissions = AllPermissions.getInstance();\n        } else {\n            String relativePath = PERMISSIONS_STORE_PATH + '/' + workspaceName;\n            ReadOnlyTree rootTree = this.root.getTree(\"/\");\n            ReadOnlyTree permissionsTree = getPermissionsRoot(rootTree, relativePath);\n            if (permissionsTree == null) {\n                compiledPermissions = NoPermissions.getInstance();\n            } else {\n                PrivilegeDefinitionStore privilegeStore = new PrivilegeDefinitionStore(this.root);\n                compiledPermissions = new CompiledPermissionImpl(principals, privilegeStore, permissionsTree);\n            }\n        }\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public Set<String> getPrivilegeNames(@Nullable Tree tree) {\n        // TODO\n        return Collections.emptySet();\n    }","id":89965,"modified_method":"@Nonnull\n    @Override\n    public Set<String> getPrivileges(@Nullable Tree tree) {\n        return compiledPermissions.getPrivileges(tree);\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean hasPrivileges(@Nullable Tree tree, String... privilegeNames) {\n        // TODO\n        return false;\n    }","id":89966,"modified_method":"@Override\n    public boolean hasPrivileges(@Nullable Tree tree, String... privilegeNames) {\n        return compiledPermissions.hasPrivileges(tree, privilegeNames);\n    }","commit_id":"737313a3428833a97c415c6c33d5117d0f73420f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void copyStagedChanges(MongoNode srcNode, MongoNode destNode) {\n\n        // Copy staged changes at the top level.\n        copyAddedNodes(srcNode, destNode);\n        copyRemovedNodes(srcNode, destNode);\n        copyAddedProperties(srcNode, destNode);\n        copyRemovedProperties(srcNode, destNode);\n\n        // Recursively add staged changes of the descendants.\n        List<String> srcChildren = srcNode.getChildren();\n        if (srcChildren == null || srcChildren.isEmpty()) {\n            return;\n        }\n\n        for (String childName : srcChildren) {\n            String oldChildPath = PathUtils.concat(srcNode.getPath(), childName);\n            MongoNode oldChild = getStoredNode(oldChildPath);\n\n            String newChildPath = PathUtils.concat(destNode.getPath(), childName);\n            MongoNode newChild = getStagedNode(newChildPath);\n            copyStagedChanges(oldChild, newChild);\n        }\n    }","id":89967,"modified_method":"private void copyStagedChanges(MongoNode srcNode, MongoNode destNode, boolean move) {\n        copyAddedNodes(srcNode, destNode, move);\n        copyRemovedNodes(srcNode, destNode);\n        copyAddedProperties(srcNode, destNode);\n        copyRemovedProperties(srcNode, destNode);\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void visit(CopyNodeInstruction instruction) {\n        String srcPath = instruction.getSourcePath();\n        checkAbsolutePath(srcPath);\n\n        String destPath = instruction.getDestPath();\n        if (!PathUtils.isAbsolute(destPath)) {\n            destPath = PathUtils.concat(instruction.getPath(), destPath);\n            checkAbsolutePath(destPath);\n        }\n\n        String srcParentPath = PathUtils.getParentPath(srcPath);\n        String srcNodeName = PathUtils.getName(srcPath);\n\n        String destParentPath = PathUtils.getParentPath(destPath);\n        String destNodeName = PathUtils.getName(destPath);\n\n        MongoNode srcParent = getStoredNode(srcParentPath, false);\n        if (!srcParent.childExists(srcNodeName)) {\n            throw new NotFoundException(srcPath);\n        }\n        MongoNode destParent = getStoredNode(destParentPath);\n        if (destParent.childExists(destNodeName)) {\n            throw new RuntimeException(\"Node already exists at copy destination path: \" + destPath);\n        }\n\n        // First, copy the existing nodes.\n        FetchNodesActionNew action = new FetchNodesActionNew(nodeStore,\n                srcPath, FetchNodesActionNew.LIMITLESS_DEPTH, baseRevisionId);\n        action.setBranchId(branchId);\n        Map<String, MongoNode> nodesToCopy = action.execute();\n        for (MongoNode nodeMongo : nodesToCopy.values()) {\n            String oldPath = nodeMongo.getPath();\n            String oldPathRel = PathUtils.relativize(srcPath, oldPath);\n            String newPath = PathUtils.concat(destPath, oldPathRel);\n\n            nodeMongo.setPath(newPath);\n            nodeMongo.removeField(\"_id\");\n            pathNodeMap.put(newPath, nodeMongo);\n        }\n\n        // Then, copy any staged changes.\n        MongoNode srcNode = getStoredNode(srcPath, false);\n        MongoNode destNode = getStagedNode(destPath);\n        copyStagedChanges(srcNode, destNode);\n\n        // Finally, add to destParent.\n        destParent.addChild(destNodeName);\n    }","id":89968,"modified_method":"@Override\n    public void visit(CopyNodeInstruction instruction) {\n        String srcPath = instruction.getSourcePath();\n        checkAbsolutePath(srcPath);\n\n        String destPath = instruction.getDestPath();\n        if (!PathUtils.isAbsolute(destPath)) {\n            destPath = PathUtils.concat(instruction.getPath(), destPath);\n            checkAbsolutePath(destPath);\n        }\n\n        String srcParentPath = PathUtils.getParentPath(srcPath);\n        String srcNodeName = PathUtils.getName(srcPath);\n\n        String destParentPath = PathUtils.getParentPath(destPath);\n        String destNodeName = PathUtils.getName(destPath);\n\n        MongoNode srcParent = getStoredNode(srcParentPath, false);\n        if (!srcParent.childExists(srcNodeName)) {\n            throw new NotFoundException(srcPath);\n        }\n        MongoNode destParent = getStoredNode(destParentPath);\n        if (destParent.childExists(destNodeName)) {\n            throw new RuntimeException(\"Node already exists at copy destination path: \" + destPath);\n        }\n\n        // First, copy existing nodes.\n        Map<String, MongoNode> nodesToCopy = fetchNodes(srcPath);\n        for (MongoNode srcNode : nodesToCopy.values()) {\n            String srcNodePath = srcNode.getPath();\n            MongoNode stagedSrcNode = pathNodeMap.get(srcNodePath);\n            if (stagedSrcNode != null && stagedSrcNode.isDeleted()) {\n                // Skip nodes that are staged to be deleted.\n                continue;\n            }\n            String destNodePath = PathUtils.concat(destPath, PathUtils.relativize(srcPath, srcNodePath));\n            MongoNode destNode = srcNode.copy();\n            destNode.setPath(destNodePath);\n            destNode.removeField(\"_id\");\n            if (stagedSrcNode != null) {\n                copyStagedChanges(stagedSrcNode, destNode, false);\n            }\n            pathNodeMap.put(destNodePath, destNode);\n        }\n\n        // Then, copy any staged changes.\n        MongoNode srcNode = getStagedNode(srcPath);\n        MongoNode destNode = getStagedNode(destPath);\n        copyStagedChanges(srcNode, destNode, false);\n\n        // Finally, add to destParent.\n        destParent.addChild(destNodeName);\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void visit(RemoveNodeInstruction instruction) {\n        String nodePath = instruction.getPath();\n        checkAbsolutePath(nodePath);\n\n        String parentPath = PathUtils.getParentPath(nodePath);\n        String nodeName = PathUtils.getName(nodePath);\n        MongoNode parent = getStoredNode(parentPath);\n        if (!parent.childExists(nodeName)) {\n            throw new RuntimeException(\"Node \" + nodeName\n                    + \" does not exists at parent path: \" + parentPath);\n        }\n        parent.removeChild(nodeName);\n    }","id":89969,"modified_method":"@Override\n    public void visit(RemoveNodeInstruction instruction) {\n        String nodePath = instruction.getPath();\n        checkAbsolutePath(nodePath);\n\n        String parentPath = PathUtils.getParentPath(nodePath);\n        String nodeName = PathUtils.getName(nodePath);\n        MongoNode parent = getStoredNode(parentPath);\n        if (!parent.childExists(nodeName)) {\n            throw new RuntimeException(\"Node \" + nodeName\n                    + \" does not exists at parent path: \" + parentPath);\n        }\n        parent.removeChild(nodeName);\n        markAsDeleted(nodePath);\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void visit(MoveNodeInstruction instruction) {\n        String srcPath = instruction.getSourcePath();\n        String destPath = instruction.getDestPath();\n        if (PathUtils.isAncestor(srcPath, destPath)) {\n            throw new RuntimeException(\"Target path cannot be descendant of source path: \"\n                    + destPath);\n        }\n\n        String srcParentPath = PathUtils.getParentPath(srcPath);\n        String srcNodeName = PathUtils.getName(srcPath);\n\n        String destParentPath = PathUtils.getParentPath(destPath);\n        String destNodeName = PathUtils.getName(destPath);\n\n        MongoNode srcParent = getStoredNode(srcParentPath);\n        if (!srcParent.childExists(srcNodeName)) {\n            throw new NotFoundException(srcPath);\n        }\n\n        MongoNode destParent = getStoredNode(destParentPath);\n        if (destParent.childExists(destNodeName)) {\n            throw new RuntimeException(\"Node already exists at move destination path: \" + destPath);\n        }\n\n        // First, copy the existing nodes.\n        FetchNodesActionNew action = new FetchNodesActionNew(nodeStore,\n                srcPath, FetchNodesActionNew.LIMITLESS_DEPTH, baseRevisionId);\n        action.setBranchId(branchId);\n        Map<String, MongoNode> nodesToCopy = action.execute();\n        for (MongoNode nodeMongo : nodesToCopy.values()) {\n            String oldPath = nodeMongo.getPath();\n            String oldPathRel = PathUtils.relativize(srcPath, oldPath);\n            String newPath = PathUtils.concat(destPath, oldPathRel);\n\n            nodeMongo.setPath(newPath);\n            nodeMongo.removeField(\"_id\");\n            pathNodeMap.put(newPath, nodeMongo);\n        }\n\n        // Then, copy any staged changes.\n        MongoNode srcNode = getStoredNode(srcPath, false);\n        MongoNode destNode = getStagedNode(destPath);\n        copyStagedChanges(srcNode, destNode);\n\n        // Finally, add to destParent and remove from srcParent.\n        destParent.addChild(destNodeName);\n        srcParent.removeChild(srcNodeName);\n    }","id":89970,"modified_method":"@Override\n    public void visit(MoveNodeInstruction instruction) {\n        String srcPath = instruction.getSourcePath();\n        String destPath = instruction.getDestPath();\n        if (PathUtils.isAncestor(srcPath, destPath)) {\n            throw new RuntimeException(\"Target path cannot be descendant of source path: \"\n                    + destPath);\n        }\n\n        String srcParentPath = PathUtils.getParentPath(srcPath);\n        String srcNodeName = PathUtils.getName(srcPath);\n\n        String destParentPath = PathUtils.getParentPath(destPath);\n        String destNodeName = PathUtils.getName(destPath);\n\n        MongoNode srcParent = getStoredNode(srcParentPath);\n        if (!srcParent.childExists(srcNodeName)) {\n            throw new NotFoundException(srcPath);\n        }\n\n        MongoNode destParent = getStoredNode(destParentPath);\n        if (destParent.childExists(destNodeName)) {\n            throw new RuntimeException(\"Node already exists at move destination path: \" + destPath);\n        }\n\n        // First, copy existing nodes.\n        Map<String, MongoNode> nodesToCopy = fetchNodes(srcPath);\n        for (MongoNode srcNode : nodesToCopy.values()) {\n            String srcNodePath = srcNode.getPath();\n            MongoNode stagedSrcNode = pathNodeMap.get(srcNodePath);\n            if (stagedSrcNode != null && stagedSrcNode.isDeleted()) {\n                // Skip nodes that are staged to be deleted.\n                continue;\n            }\n            String destNodePath = PathUtils.concat(destPath, PathUtils.relativize(srcPath, srcNodePath));\n            MongoNode destNode = srcNode.copy();\n            destNode.setPath(destNodePath);\n            destNode.removeField(\"_id\");\n            if (stagedSrcNode != null) {\n                copyStagedChanges(stagedSrcNode, destNode, true);\n            }\n            pathNodeMap.put(destNodePath, destNode);\n        }\n\n        // Then, copy any staged changes.\n        MongoNode srcNode = getStagedNode(srcPath);\n        MongoNode destNode = getStagedNode(destPath);\n        copyStagedChanges(srcNode, destNode, true);\n\n        // Finally, add to destParent and remove from srcParent.\n        destParent.addChild(destNodeName);\n        srcParent.removeChild(srcNodeName);\n\n        if (!srcParent.hasPendingChanges()) {\n            pathNodeMap.remove(srcPath);\n            pathNodeMap.remove(srcParentPath);\n        } else {\n            markAsDeleted(srcPath);\n        }\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void copyAddedNodes(MongoNode srcNode, MongoNode destNode) {\n        List<String> addedChildren = srcNode.getAddedChildren();\n        if (addedChildren == null || addedChildren.isEmpty()) {\n            return;\n        }\n\n        for (String childName : addedChildren) {\n            getStagedNode(PathUtils.concat(destNode.getPath(), childName));\n            destNode.addChild(childName);\n        }\n    }","id":89971,"modified_method":"private void copyAddedNodes(MongoNode srcNode, MongoNode destNode, boolean move) {\n        List<String> addedChildren = srcNode.getAddedChildren();\n        if (addedChildren == null || addedChildren.isEmpty()) {\n            return;\n        }\n\n        for (String childName : addedChildren) {\n            getStagedNode(PathUtils.concat(destNode.getPath(), childName));\n            destNode.addChild(childName);\n            if (move) {\n                pathNodeMap.remove(PathUtils.concat(srcNode.getPath(), childName));\n            }\n        }\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void removeChild(String childName) {\n        if (removedChildren == null) {\n            removedChildren = new LinkedList<String>();\n        }\n        removedChildren.add(childName);\n    }","id":89972,"modified_method":"public void removeChild(String childName) {\n        if (addedChildren != null && addedChildren.contains(childName)) {\n            addedChildren.remove(childName);\n            return;\n        }\n\n        if (removedChildren == null) {\n            removedChildren = new LinkedList<String>();\n        }\n\n        if (!removedChildren.contains(childName)) {\n            removedChildren.add(childName);\n        }\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void addChild(String childName) {\n        if (addedChildren == null) {\n            addedChildren = new LinkedList<String>();\n        }\n        addedChildren.add(childName);\n    }","id":89973,"modified_method":"public void addChild(String childName) {\n        if (removedChildren != null && removedChildren.contains(childName)) {\n            removedChildren.remove(childName);\n            return;\n        }\n\n        if (addedChildren == null) {\n            addedChildren = new LinkedList<String>();\n        }\n\n        if (!addedChildren.contains(childName)) {\n            addedChildren.add(childName);\n        }\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Returns the node from the cache or null if the node is not in the cache.\n     *\n     * @param path Path\n     * @param branchId Branch id\n     * @param revisionId Revision id\n     * @return\n     */\n    public MongoNode getFromCache(String path, String branchId, long revisionId) {\n        String key = path + \"*\" + branchId + \"*\" + revisionId;\n        MongoNode node = nodeCache.get(key);\n        if (node == null) {\n            return null;\n        }\n        LOG.debug(\"Returning node from cache: {}\", key);\n        return node;\n    }","id":89974,"modified_method":"/**\n     * Returns the node from the cache or null if the node is not in the cache.\n     *\n     * @param path Path\n     * @param branchId Branch id\n     * @param revisionId Revision id\n     * @return\n     */\n    public MongoNode getFromCache(String path, String branchId, long revisionId) {\n        String key = path + \"*\" + branchId + \"*\" + revisionId;\n        MongoNode node = nodeCache.get(key);\n        if (node == null) {\n            return null;\n        }\n        LOG.debug(\"Returning node from cache: {}\", key);\n        return node.copy();\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Boolean execute() throws Exception {\n        // To check a path really exists, all the paths from root need to be checked.\n        Set<String> paths = new HashSet<String>();\n        char[] path = this.path.toCharArray();\n        StringBuilder current = new StringBuilder();\n        for (int i = 0; i < path.length; i++) {\n            if (i == 0) {\n                paths.add(\"/\");\n            } else if (path[i] == '/') {\n                paths.add(current.toString());\n            }\n            current.append(path[i]);\n        }\n        paths.add(current.toString());\n\n        if (revisionId == null) {\n            revisionId = new GetHeadRevisionCommand(nodeStore).execute();\n        }\n\n        FetchNodesActionNew action = new FetchNodesActionNew(nodeStore, paths, revisionId);\n        action.setBranchId(branchId);\n        //action.setValidCommits(validCommits);\n\n        Map<String, MongoNode> pathAndNodeMap = action.execute();\n        String currentPath = this.path;\n        while (!PathUtils.denotesRoot(currentPath)) {\n            String childName = PathUtils.getName(currentPath);\n            String parentPath = PathUtils.getParentPath(currentPath);\n            MongoNode parentNode = pathAndNodeMap.get(parentPath);\n            if (parentNode == null || !parentNode.childExists(childName)) {\n                node = null;\n                return false;\n            }\n            currentPath = PathUtils.getParentPath(currentPath);\n        }\n        node = pathAndNodeMap.get(this.path);\n        return true;\n    }","id":89975,"modified_method":"@Override\n    public Boolean execute() throws Exception {\n        if (revisionId == null) {\n            revisionId = new GetHeadRevisionCommand(nodeStore).execute();\n        }\n\n        FetchNodesActionNew action = new FetchNodesActionNew(nodeStore, path, 0, revisionId);\n        action.setBranchId(branchId);\n\n        Map<String, MongoNode> pathAndNodeMap = action.execute();\n        node = pathAndNodeMap.get(this.path);\n        return node != null && !node.isDeleted();\n    }","commit_id":"d1629190fe5594d46898631893c6270013148792","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nullable\n  public static Language reallyEvaluateLanguageInRange(final int start, final int end, final PsiFile file) {\n    Language lang = null;\n    int curOffset = start;\n    do {\n      PsiElement elt = getElementAtOffset(file, curOffset);\n\n      if (!(elt instanceof PsiWhiteSpace)) {\n        final Language language = findLanguageFromElement(elt);\n        if (lang == null) {\n          lang = language;\n        }\n        else if (lang != language) {\n          return null;\n        }\n      }\n      int endOffset = elt.getTextRange().getEndOffset();\n      curOffset = endOffset <= curOffset ? curOffset + 1 : endOffset;\n    }\n    while (curOffset < end);\n    return narrowLanguage(lang, file.getLanguage());\n  }","id":89976,"modified_method":"@Nullable\n  public static Language reallyEvaluateLanguageInRange(final int start, final int end, final PsiFile file) {\n    Language lang = null;\n    int curOffset = start;\n    do {\n      PsiElement elt = getElementAtOffset(file, curOffset);\n\n      if (!(elt instanceof PsiWhiteSpace)) {\n        final Language language = findLanguageFromElement(elt);\n        if (lang == null) {\n          lang = language;\n        }\n        else if (lang != language) {\n          return null;\n        }\n      }\n      TextRange range = elt.getTextRange();\n      if (range == null) {\n        LOG.error(\"Null range for element \" + elt + \" of \" + elt.getClass() + \" in file \" + file + \" at offset \" + curOffset);\n        return file.getLanguage();\n      }\n      int endOffset = range.getEndOffset();\n      curOffset = endOffset <= curOffset ? curOffset + 1 : endOffset;\n    }\n    while (curOffset < end);\n    return narrowLanguage(lang, file.getLanguage());\n  }","commit_id":"0a02886fa950a5c4c2d68affbf7e5e3575f46b4d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doComment() {\n    myLine1 = myDocument.getLineNumber(myStartOffset);\n    myLine2 = myDocument.getLineNumber(myEndOffset);\n\n    if (myLine2 > myLine1 && myDocument.getLineStartOffset(myLine2) == myEndOffset) {\n      myLine2--;\n    }\n\n    myStartOffsets = new int[myLine2 - myLine1 + 1];\n    myEndOffsets = new int[myLine2 - myLine1 + 1];\n    myCommenters = new Commenter[myLine2 - myLine1 + 1];\n    boolean allLineCommented = true;\n    CharSequence chars = myDocument.getCharsSequence();\n\n    boolean singleline = myLine1 == myLine2;\n    int offset = myDocument.getLineStartOffset(myLine1);\n    offset = CharArrayUtil.shiftForward(myDocument.getCharsSequence(), offset, \" \\t\");\n    final Language languageSuitableForCompleteFragment = PsiUtilBase.evaluateLanguageInRange(offset, CharArrayUtil.shiftBackward(\n      myDocument.getCharsSequence(), myDocument.getLineEndOffset(myLine2), \" \\t\\n\"), myFile);\n\n    Commenter blockSuitableCommenter = languageSuitableForCompleteFragment == null ? LanguageCommenters.INSTANCE.forLanguage(myFile.getLanguage()) : null;\n\n    if (blockSuitableCommenter == null && myFile.getFileType() instanceof AbstractFileType) {\n      blockSuitableCommenter = new Commenter() {\n        final SyntaxTable mySyntaxTable = ((AbstractFileType)myFile.getFileType()).getSyntaxTable();\n        @Nullable\n        public String getLineCommentPrefix() {\n          return mySyntaxTable.getLineComment();\n        }\n\n        @Nullable\n        public String getBlockCommentPrefix() {\n          return mySyntaxTable.getStartComment();\n        }\n\n        @Nullable\n        public String getBlockCommentSuffix() {\n          return mySyntaxTable.getEndComment();\n        }\n      };\n    }\n\n    for (int line = myLine1; line <= myLine2; line++) {\n      final Commenter commenter = blockSuitableCommenter != null ? blockSuitableCommenter : findCommenter(line);\n      if (commenter == null) return;\n\n      if (commenter.getLineCommentPrefix() == null &&\n          (commenter.getBlockCommentPrefix() == null || commenter.getBlockCommentSuffix() == null)) {\n        return;\n      }\n      myCommenters[line - myLine1] = commenter;\n      if (!isLineCommented(line, chars, commenter) && (singleline || !isLineEmpty(line))) {\n        allLineCommented = false;\n        break;\n      }\n    }\n\n    if (!allLineCommented) {\n      if (CodeStyleSettingsManager.getSettings(myProject).LINE_COMMENT_AT_FIRST_COLUMN) {\n        doDefaultCommenting(blockSuitableCommenter);\n      }\n      else {\n        doIndentCommenting(blockSuitableCommenter);\n      }\n    }\n    else {\n      for (int line = myLine2; line >= myLine1; line--) {\n        int offset1 = myStartOffsets[line - myLine1];\n        int offset2 = myEndOffsets[line - myLine1];\n        if (offset1 == offset2) continue;\n        Commenter commenter = myCommenters[line - myLine1];\n        String prefix = commenter.getBlockCommentPrefix();\n        if (prefix == null || !myDocument.getText().substring(offset1, myDocument.getTextLength()).startsWith(prefix)) {\n          prefix = commenter.getLineCommentPrefix();\n        }\n\n        String suffix = commenter.getBlockCommentSuffix();\n        if (suffix == null && prefix != null) suffix = \"\";\n\n        if (prefix != null && suffix != null) {\n          final int suffixLen = suffix.length();\n          final int prefixLen = prefix.length();\n          if (offset2 >= 0) {\n            if (!CharArrayUtil.regionMatches(chars, offset1 + prefixLen, prefix)) {\n              myDocument.deleteString(offset2 - suffixLen, offset2);\n            }\n          }\n          if (offset1 >= 0) {\n            for (int i = offset2 - suffixLen - 1; i > offset1 + prefixLen; --i) {\n              if (CharArrayUtil.regionMatches(chars, i, suffix)) {\n                myDocument.deleteString(i, i + suffixLen);\n              }\n              else if (CharArrayUtil.regionMatches(chars, i, prefix)) {\n                myDocument.deleteString(i, i + prefixLen);\n              }\n            }\n            myDocument.deleteString(offset1, offset1 + prefixLen);\n          }\n        }\n      }\n    }\n  }","id":89977,"modified_method":"private void doComment() {\n    myLine1 = myDocument.getLineNumber(myStartOffset);\n    myLine2 = myDocument.getLineNumber(myEndOffset);\n\n    if (myLine2 > myLine1 && myDocument.getLineStartOffset(myLine2) == myEndOffset) {\n      myLine2--;\n    }\n\n    myStartOffsets = new int[myLine2 - myLine1 + 1];\n    myEndOffsets = new int[myLine2 - myLine1 + 1];\n    myCommenters = new Commenter[myLine2 - myLine1 + 1];\n    boolean allLineCommented = true;\n    CharSequence chars = myDocument.getCharsSequence();\n\n    boolean singleline = myLine1 == myLine2;\n    int offset = myDocument.getLineStartOffset(myLine1);\n    offset = CharArrayUtil.shiftForward(myDocument.getCharsSequence(), offset, \" \\t\");\n    final Language languageSuitableForCompleteFragment = PsiUtilBase.reallyEvaluateLanguageInRange(offset, CharArrayUtil.shiftBackward(\n      myDocument.getCharsSequence(), myDocument.getLineEndOffset(myLine2), \" \\t\\n\"), myFile);\n\n    Commenter blockSuitableCommenter = languageSuitableForCompleteFragment == null ? LanguageCommenters.INSTANCE.forLanguage(myFile.getLanguage()) : null;\n\n    if (blockSuitableCommenter == null && myFile.getFileType() instanceof AbstractFileType) {\n      blockSuitableCommenter = new Commenter() {\n        final SyntaxTable mySyntaxTable = ((AbstractFileType)myFile.getFileType()).getSyntaxTable();\n        @Nullable\n        public String getLineCommentPrefix() {\n          return mySyntaxTable.getLineComment();\n        }\n\n        @Nullable\n        public String getBlockCommentPrefix() {\n          return mySyntaxTable.getStartComment();\n        }\n\n        @Nullable\n        public String getBlockCommentSuffix() {\n          return mySyntaxTable.getEndComment();\n        }\n      };\n    }\n\n    for (int line = myLine1; line <= myLine2; line++) {\n      final Commenter commenter = blockSuitableCommenter != null ? blockSuitableCommenter : findCommenter(line);\n      if (commenter == null) return;\n\n      if (commenter.getLineCommentPrefix() == null &&\n          (commenter.getBlockCommentPrefix() == null || commenter.getBlockCommentSuffix() == null)) {\n        return;\n      }\n      myCommenters[line - myLine1] = commenter;\n      if (!isLineCommented(line, chars, commenter) && (singleline || !isLineEmpty(line))) {\n        allLineCommented = false;\n        break;\n      }\n    }\n\n    if (!allLineCommented) {\n      if (CodeStyleSettingsManager.getSettings(myProject).LINE_COMMENT_AT_FIRST_COLUMN) {\n        doDefaultCommenting(blockSuitableCommenter);\n      }\n      else {\n        doIndentCommenting(blockSuitableCommenter);\n      }\n    }\n    else {\n      for (int line = myLine2; line >= myLine1; line--) {\n        int offset1 = myStartOffsets[line - myLine1];\n        int offset2 = myEndOffsets[line - myLine1];\n        if (offset1 == offset2) continue;\n        Commenter commenter = myCommenters[line - myLine1];\n        String prefix = commenter.getBlockCommentPrefix();\n        if (prefix == null || !myDocument.getText().substring(offset1, myDocument.getTextLength()).startsWith(prefix)) {\n          prefix = commenter.getLineCommentPrefix();\n        }\n\n        String suffix = commenter.getBlockCommentSuffix();\n        if (suffix == null && prefix != null) suffix = \"\";\n\n        if (prefix != null && suffix != null) {\n          final int suffixLen = suffix.length();\n          final int prefixLen = prefix.length();\n          if (offset2 >= 0) {\n            if (!CharArrayUtil.regionMatches(chars, offset1 + prefixLen, prefix)) {\n              myDocument.deleteString(offset2 - suffixLen, offset2);\n            }\n          }\n          if (offset1 >= 0) {\n            for (int i = offset2 - suffixLen - 1; i > offset1 + prefixLen; --i) {\n              if (CharArrayUtil.regionMatches(chars, i, suffix)) {\n                myDocument.deleteString(i, i + suffixLen);\n              }\n              else if (CharArrayUtil.regionMatches(chars, i, prefix)) {\n                myDocument.deleteString(i, i + prefixLen);\n              }\n            }\n            myDocument.deleteString(offset1, offset1 + prefixLen);\n          }\n        }\n      }\n    }\n  }","commit_id":"930b5d4eba386a7742e6b85550de7e2a31b97390","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Language evaluateLanguageInRange(final int start, final int end, final PsiFile file) {\n    Language lang = null;\n    int curOffset = start;\n    do {\n      PsiElement elt = getElementAtOffset(file, curOffset);\n      if (elt == null) break;\n      if (!(elt instanceof PsiWhiteSpace)) {\n        final Language language = findLanguageFromElement(elt, file);\n        if (lang == null) {\n          lang = language;\n        } else if (lang != language) {\n          return null;\n        }\n      }\n      int endOffset = elt.getTextRange().getEndOffset();\n      if (endOffset == curOffset) {\n        endOffset++;\n      }\n      curOffset = endOffset;\n    }\n    while(curOffset < end);\n    return narrowLanguage(lang, file.getLanguage());\n  }","id":89978,"modified_method":"@Nullable\n  public static Language evaluateLanguageInRange(final int start, final int end, final PsiFile file) {\n    PsiElement elt = getElementAtOffset(file, start);\n\n    if (elt != null) {\n      elt = elt.getParent();\n      TextRange selectionRange = new TextRange(start, end);\n      TextRange range = elt.getTextRange();\n\n      while(!range.contains(selectionRange)) {\n        elt = elt.getParent();\n        if (elt == null) break;\n        range = elt.getTextRange();\n      }\n      \n      if (range.contains(selectionRange) && elt != null) {\n        return elt.getLanguage();\n      }\n    }\n\n    return reallyEvaluateLanguageInRange(start, end, file);\n  }","commit_id":"930b5d4eba386a7742e6b85550de7e2a31b97390","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement getPrevSibling() {\n    PsiElement prev = null;\n    final PsiElement parent = getParent();\n    if (parent != null) {\n      final PsiElement[] thisLevelElements = parent.getChildren();\n      for (PsiElement element : thisLevelElements) {\n        if (element == this) {\n          break;\n        }\n        prev = element;\n      }\n    }\n    return prev;\n  }","id":89979,"modified_method":"@Nullable\n  public PsiElement getPrevSibling() {\n    PsiElement prev = null;\n    final PsiElement parent = getAntParent();\n    if (parent != null) {\n      final PsiElement[] thisLevelElements = parent.getChildren();\n      for (PsiElement element : thisLevelElements) {\n        if (element == this) {\n          break;\n        }\n        prev = element;\n      }\n    }\n    return prev;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiReference[] getReferences() {\n    return new PsiReference[]{new PsiReference() {\n\n      public PsiElement getElement() {\n        return AntElementImpl.this;\n      }\n\n      public TextRange getRangeInElement() {\n        return getTextRange();\n      }\n\n      @Nullable\n      public PsiElement resolve() {\n        return null;\n      }\n\n      public String getCanonicalText() {\n        return getText();\n      }\n\n      public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n        return null;\n      }\n\n      public PsiElement bindToElement(PsiElement element) throws IncorrectOperationException {\n        return null;\n      }\n\n      public boolean isReferenceTo(PsiElement element) {\n        return false;\n      }\n\n      public Object[] getVariants() {\n        return new Object[0];\n      }\n\n      public boolean isSoft() {\n        return false;\n      }\n    }};\n  }","id":89980,"modified_method":"@NotNull\n  public PsiReference[] getReferences() {\n    if(myReferences != null) return myReferences;\n\n    final GenericReferenceProvider[] providers = AntReferenceProvidersRegistry.getProvidersByElement(this);\n    final List<PsiReference> result = new ArrayList<PsiReference>();\n    for (final GenericReferenceProvider provider : providers) {\n      result.addAll(Arrays.asList(provider.getReferencesByElement(this)));\n    }\n    return myReferences = result.toArray(new PsiReference[result.size()]);\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Language getLanguage() {\n    return AntSupport.getLanguage();\n  }","id":89981,"modified_method":"@NotNull\n  public AntLanguage getLanguage() {\n    return AntSupport.getLanguage();\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement findElementAt(int offset) {\n    final TextRange textRange = getTextRange();\n    if (textRange.getStartOffset() <= offset && textRange.getEndOffset() >= offset) {\n      final PsiElement[] children = getChildren();\n      for (PsiElement child : children) {\n        final PsiElement psiElement = child.findElementAt(offset);\n        if (psiElement != null) {\n          return psiElement;\n        }\n      }\n      return this;\n    }\n    return null;\n  }","id":89982,"modified_method":"public PsiElement findElementAt(int offset) {\n    final int offsetInFile = offset + getTextRange().getStartOffset();\n    for (final AntElement element : getChildren()) {\n      final TextRange textRange = element.getTextRange();\n      if(textRange.contains(offsetInFile))\n        return element.findElementAt(offsetInFile - textRange.getStartOffset());\n    }\n    return getTextRange().contains(offsetInFile) ? this : null;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntElementImpl(final PsiElement parent, final PsiElement sourceElement) {\n    super(sourceElement);\n    myParent = parent;\n  }","id":89983,"modified_method":"public AntElementImpl(final AntElement parent, final XmlElement sourceElement) {\n    super(sourceElement);\n    myParent = parent;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement getFirstChild() {\n    final PsiElement[] children = getChildren();\n    return (children.length == 0) ? null : children[0];\n  }","id":89984,"modified_method":"@Nullable\n  public AntElement getFirstChild() {\n    final AntElement[] children = getChildren();\n    return (children.length == 0) ? null : children[0];\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiElement[] getChildren() {\n    if (myChildren == null) {\n      myChildren = EMPTY_CHILDREN;\n      ArrayList<AntElement> children = null;\n      final XmlTag tag = getSourceTag();\n      final XmlTag[] tags = tag.getSubTags();\n      for (XmlTag subtag : tags) {\n        AntElement child = parseSubTag(subtag);\n        if (child != null) {\n          if (children == null) {\n            children = new ArrayList<AntElement>();\n          }\n          children.add(child);\n        }\n      }\n      if (children != null) {\n        myChildren = children.toArray(new AntElement[children.size()]);\n      }\n    }\n    return myChildren;\n  }","id":89985,"modified_method":"@NotNull\n  public AntElement[] getChildren(){\n    if(myChildren != null) return myChildren;\n    return myChildren = getChildrenInner();\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement getNextSibling() {\n    final PsiElement parent = getParent();\n    if (parent != null) {\n      final PsiElement[] thisLevelElements = parent.getChildren();\n      PsiElement thisElement = null;\n      for (PsiElement element : thisLevelElements) {\n        if (thisElement != null) {\n          return element;\n        }\n        if (element == this) {\n          thisElement = element;\n        }\n      }\n    }\n    return null;\n  }","id":89986,"modified_method":"@Nullable\n  public PsiElement getNextSibling() {\n    final PsiElement parent = getAntParent();\n    if (parent != null) {\n      final PsiElement[] thisLevelElements = parent.getChildren();\n      PsiElement thisElement = null;\n      for (PsiElement element : thisLevelElements) {\n        if (thisElement != null) {\n          return element;\n        }\n        if (element == this) {\n          thisElement = element;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public XmlTag getSourceTag() {\n    return (XmlTag)getSourceElement();\n  }","id":89987,"modified_method":"@NotNull\n  public XmlElement getSourceElement() {\n    return (XmlElement)super.getSourceElement();\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiFile createFile(FileViewProvider viewProvider) {\n    return new AntFile(viewProvider);\n  }","id":89988,"modified_method":"public PsiFile createFile(FileViewProvider viewProvider) {\n    return new AntFileImpl(viewProvider);\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getName() {\n    parseTag();\n    return myName;\n  }","id":89989,"modified_method":"@Nullable\n  public String getName() {\n    return getSourceElement().getAttributeValue(\"name\");\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public AntTarget getDefaultTarget() {\n    if (myDefaultTarget == null) {\n      parseTag();\n      final String defaultTarget = myDefaultTargetName;\n      if (defaultTarget == null || defaultTarget.length() > 0) {\n        return null;\n      }\n      for (AntTarget target : getAllTargets()) {\n        if (defaultTarget.equals(target.getName())) {\n          myDefaultTarget = target;\n          break;\n        }\n      }\n    }\n    return myDefaultTarget;\n  }","id":89990,"modified_method":"@Nullable\n  public AntTarget getDefaultTarget() {\n    final PsiReference[] references = getReferences();\n    for (PsiReference ref : references) {\n      final GenericReference reference = (GenericReference)ref;\n      if (reference.getType().isAssignableTo(ReferenceType.ANT_TARGET)) {\n        return (AntTarget)reference.resolve();\n      }\n    }\n    return null;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AntTarget[] getAllTargets() {\n    if (myTargets == null) {\n      myTargets = EMPTY_TARGETS;\n      final PsiElement[] children = getChildren();\n      if (children.length > 0) {\n        ArrayList<AntTarget> targets = null;\n        for (PsiElement child : children) {\n          if (child instanceof AntTarget) {\n            if (targets == null) {\n              targets = new ArrayList<AntTarget>();\n            }\n            targets.add((AntTarget)child);\n          }\n        }\n        if (targets != null) {\n          myTargets = targets.toArray(new AntTarget[ targets.size()]);\n        }\n      }\n    }\n    return myTargets;\n  }","id":89991,"modified_method":"@NotNull\n  public AntTarget[] getTargets() {\n    if (myTargets != null) return myTargets;\n    final List<AntTarget> targets = new ArrayList<AntTarget>();\n    for (final AntElement child : getChildren()) {\n      if (child instanceof AntTarget)\n        targets.add((AntTarget)child);\n    }\n    return myTargets = targets.toArray(new AntTarget[targets.size()]);\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getDescription() {\n    parseTag();\n    return myDescription;\n  }","id":89992,"modified_method":"@Nullable\n  public String getDescription() {\n    final XmlTag tag = getSourceElement().findFirstSubTag(\"description\");\n    return tag != null ? tag.getValue().getTrimmedText() : null;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls\n  public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntProject: \");\n      builder.append(getName());\n      if (myDescription != null) {\n        builder.append(\" [\");\n        builder.append(myDescription);\n        builder.append(\"]\");\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":89993,"modified_method":"@NonNls\n  public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntProject: \");\n      builder.append(getName());\n      if (getDescription() != null) {\n        builder.append(\" [\");\n        builder.append(getDescription());\n        builder.append(\"]\");\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public AntTarget getTarget(final String name) {\n    AntTarget[] targets = getAllTargets();\n    for (AntTarget target : targets) {\n      if (name.compareToIgnoreCase(target.getName()) == 0) {\n        return target;\n      }\n    }\n    return null;\n  }","id":89994,"modified_method":"@Nullable\n  public AntTarget getTarget(final String name) {\n    AntTarget[] targets = getTargets();\n    for (AntTarget target : targets) {\n      if (name.equals(target.getName())) {\n        return target;\n      }\n    }\n    return null;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getBaseDir() {\n    parseTag();\n    return myBaseDir;\n  }","id":89995,"modified_method":"@Nullable\n  public String getBaseDir() {\n    return getSourceElement().getAttributeValue(\"basedir\");\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"HardCodedStringLiteral\")\n  private void parseTag() {\n    if (myName == null) {\n      final XmlTag tag = getSourceTag();\n      final String name = tag.getName();\n      if (\"property\".compareToIgnoreCase(name) == 0) {\n        myName = tag.getAttributeValue(\"name\");\n        myValue = tag.getAttributeValue(\"value\");\n        myLocation = tag.getAttributeValue(\"location\");\n        myRefId = tag.getAttributeValue(\"refid\");\n        myFile = tag.getAttributeValue(\"file\");\n      }\n    }\n  }","id":89996,"modified_method":"@SuppressWarnings(\"HardCodedStringLiteral\")\n  private void parseTag() {\n    if (myName == null) {\n      final XmlTag tag = (XmlTag)getSourceElement();\n      final String name = tag.getName();\n      if (\"property\".compareToIgnoreCase(name) == 0) {\n        myName = tag.getAttributeValue(\"name\");\n        myValue = tag.getAttributeValue(\"value\");\n        myLocation = tag.getAttributeValue(\"location\");\n        myRefId = tag.getAttributeValue(\"refid\");\n        myFile = tag.getAttributeValue(\"file\");\n      }\n    }\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Properties getProperties() {\n    parseTag();\n    Properties result = new Properties();\n    if (myValue != null) {\n      result.setProperty(myName, myValue);\n    }\n    else if (myLocation != null) {\n      result.setProperty(myName, myLocation);\n    }\n    else if (myRefId != null) {\n      result.setProperty(myName, myRefId);\n    }\n    else if (myFile != null) {\n      try {\n        FileInputStream fis = null;\n        try {\n          fis = new FileInputStream(new File(((AntProject)getParent()).getBaseDir(), myFile));\n          result.load(fis);\n        }\n        finally {\n          if (fis != null) {\n            fis.close();\n          }\n        }\n      }\n      catch (IOException e) {\n        result = new Properties();\n      }\n    }\n    return result;\n  }","id":89997,"modified_method":"@NotNull\n  public Properties getProperties() {\n    parseTag();\n    Properties result = new Properties();\n    if (myValue != null) {\n      result.setProperty(myName, myValue);\n    }\n    else if (myLocation != null) {\n      result.setProperty(myName, myLocation);\n    }\n    else if (myRefId != null) {\n      result.setProperty(myName, myRefId);\n    }\n    else if (myFile != null) {\n      try {\n        FileInputStream fis = null;\n        try {\n          fis = new FileInputStream(new File(((AntProject)getAntParent()).getBaseDir(), myFile));\n          result.load(fis);\n        }\n        finally {\n          if (fis != null) {\n            fis.close();\n          }\n        }\n      }\n      catch (IOException e) {\n        result = new Properties();\n      }\n    }\n    return result;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Language getLanguage() {\n    if (ourAntLanguage == null) {\n      ourAntLanguage = getFileType().getLanguage();\n    }\n    return ourAntLanguage;\n  }","id":89998,"modified_method":"public static AntLanguage getLanguage() {\n    if (ourAntLanguage == null) {\n      if (ourAntFileType == null) {\n        ourAntFileType = new AntFileType();\n      }\n      ourAntLanguage = (AntLanguage)ourAntFileType.getLanguage();\n    }\n    return ourAntLanguage;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AntTarget[] getDependsTargets() {\n    if (myDependsTargets == null) {\n      myDependsTargets = AntProjectImpl.EMPTY_TARGETS;\n      final String depends = myDepends;\n      if (depends != null && depends.length() > 0) {\n        AntProject project = (AntProject)getParent();\n        final String[] names = depends.split(\",\");\n        ArrayList<AntTarget> targets = null;\n        for (String name : names) {\n          final AntTarget antTarget = project.getTarget(name);\n          if (antTarget != null) {\n            if (targets == null) {\n              targets = new ArrayList<AntTarget>();\n            }\n            targets.add(antTarget);\n          }\n        }\n        if (targets != null) {\n          myDependsTargets = targets.toArray(new AntTarget[targets.size()]);\n        }\n      }\n    }\n    return myDependsTargets;\n  }","id":89999,"modified_method":"@NotNull\n  public AntTarget[] getDependsTargets() {\n    if (myDependsTargets == null) {\n      final String depends = getSourceElement().getAttributeValue(\"depends\");\n      if (depends == null || depends.length() == 0) {\n        myDependsTargets = AntProjectImpl.EMPTY_TARGETS;\n      }\n      else {\n        AntProject project = (AntProject)getAntParent();\n        final List<AntTarget> targets = new ArrayList<AntTarget>();\n        for (String name : depends.split(\",\")) {\n          final AntTarget antTarget = project.getTarget(name);\n          if (antTarget != null) {\n            targets.add(antTarget);\n          }\n        }\n        myDependsTargets = targets.toArray(new AntTarget[targets.size()]);\n      }\n    }\n    return myDependsTargets;\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"}]