[{"original_method":"@Override\n    protected void renderBreadcrumbs(Element parent) {\n        Element div = append(parent, \"div\");\n        div.setAttribute(\"class\", \"breadcrumbs\");\n        appendLink(div, \"index.html\", \"all\");\n        appendText(div, \" > \");\n        appendLink(div, String.format(\"%s.html\", getResults().getPackageResults().getName()), getResults().getPackageResults().getName());\n        appendText(div, String.format(\" > %s\", getResults().getSimpleName()));\n    }","id":0,"modified_method":"@Override\n    protected void renderBreadcrumbs(SimpleHtmlWriter htmlWriter) throws IOException {\n        htmlWriter.startElement(\"div\").attribute(\"class\", \"breadcrumbs\")\n            .startElement(\"a\").attribute(\"href\", \"index.html\").characters(\"all\").endElement()\n            .characters(\" > \")\n            .startElement(\"a\").attribute(\"href\", String.format(\"%s.html\", getResults().getPackageResults().getName())).characters(getResults().getPackageResults().getName()).endElement()\n            .characters(String.format(\" > %s\", getResults().getSimpleName()))\n        .endElement();\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override protected void registerTabs() {\n        addFailuresTab();\n        addTab(\"Tests\", new Action<Element>() {\n            public void execute(Element element) {\n                renderTests(element);\n            }\n        });\n        final String stdOut = getOutputString(TestOutputEvent.Destination.StdOut);\n        if (stdOut.length() > 0) {\n            addTab(\"Standard output\", new Action<Element>() {\n                public void execute(Element element) {\n                    renderStd(element, stdOut);\n                }\n            });\n        }\n        final String stdErr = getOutputString(TestOutputEvent.Destination.StdErr);\n        if (stdErr.length() > 0) {\n            addTab(\"Standard error\", new Action<Element>() {\n                public void execute(Element element) {\n                    renderStd(element, stdErr);\n                }\n            });\n        }\n    }","id":1,"modified_method":"@Override\n    protected void registerTabs() {\n        addFailuresTab();\n        addTab(\"Tests\", new ErroringAction<SimpleHtmlWriter>() {\n            public void doExecute(SimpleHtmlWriter writer) throws IOException {\n                renderTests(writer);\n            }\n        });\n        if (resultsProvider.hasOutput(className, TestOutputEvent.Destination.StdOut)) {\n            addTab(\"Standard output\", new ErroringAction<SimpleHtmlWriter>() {\n                @Override\n                protected void doExecute(SimpleHtmlWriter htmlWriter) throws IOException {\n                    htmlWriter.startElement(\"span\").attribute(\"class\", \"code\")\n                        .startElement(\"pre\")\n                        .characters(\"\");\n                    resultsProvider.writeOutputs(className, TestOutputEvent.Destination.StdOut, htmlWriter);\n                        htmlWriter.endElement()\n                    .endElement();\n                }\n            });\n        }\n        if (resultsProvider.hasOutput(className, TestOutputEvent.Destination.StdErr)) {\n            addTab(\"Standard error\", new ErroringAction<SimpleHtmlWriter>() {\n                @Override\n                protected void doExecute(SimpleHtmlWriter element) throws Exception {\n                    element.startElement(\"span\").attribute(\"class\", \"code\")\n                    .startElement(\"pre\")\n                        .characters(\"\");\n                    resultsProvider.writeOutputs(className, TestOutputEvent.Destination.StdErr, element);\n                    element.endElement()\n                    .endElement();\n                }\n            });\n        }\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> TextReportRenderer<T> renderer(final DomReportRenderer<T> renderer) {\n        return renderer(new TextReportRenderer<T>() {\n            @Override\n            protected void writeTo(T model, Writer writer) throws Exception {\n                if (documentBuilder == null) {\n                    documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                }\n                Document document = documentBuilder.newDocument();\n\n                Element html = document.createElement(\"html\");\n                document.appendChild(html);\n                renderer.render(model, html);\n\n                if (transformer == null) {\n                    TransformerFactory factory = TransformerFactory.newInstance();\n                    transformer = factory.newTransformer();\n                    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n                    transformer.setOutputProperty(OutputKeys.METHOD, \"html\");\n                    transformer.setOutputProperty(OutputKeys.MEDIA_TYPE, \"text/html\");\n                }\n\n                writer.write(\"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\");\n                writer.write(SystemProperties.getLineSeparator());\n                transformer.transform(new DOMSource(document), new StreamResult(writer));\n            }\n        });\n    }","id":2,"modified_method":"public <T> TextReportRenderer<T> renderer(final AbstractHtmlReportRenderer<T> renderer) {\n        return renderer(new TextReportRenderer<T>() {\n            @Override\n            protected void writeTo(T model, Writer writer) throws Exception {\n                SimpleHtmlWriter htmlWriter = new SimpleHtmlWriter(writer, \"\");\n                htmlWriter.startElement(\"html\");\n                renderer.render(model, htmlWriter);\n                htmlWriter.endElement();\n            }\n        });\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override protected void registerTabs() {\n        addFailuresTab();\n        if (!getResults().getPackages().isEmpty()) {\n            addTab(\"Packages\", new Action<Element>() {\n                public void execute(Element element) {\n                    renderPackages(element);\n                }\n            });\n        }\n        addTab(\"Classes\", new Action<Element>() {\n            public void execute(Element element) {\n                renderClasses(element);\n            }\n        });\n    }","id":3,"modified_method":"@Override\n    protected void registerTabs() {\n        addFailuresTab();\n        if (!getResults().getPackages().isEmpty()) {\n            addTab(\"Packages\", new ErroringAction<SimpleHtmlWriter>() {\n                @Override\n                protected void doExecute(SimpleHtmlWriter writer) throws IOException {\n                    renderPackages(writer);\n                }\n            });\n        }\n        addTab(\"Classes\", new ErroringAction<SimpleHtmlWriter>() {\n            public void doExecute(SimpleHtmlWriter htmlWriter) throws IOException {\n                renderClasses(htmlWriter);\n            }\n        });\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"private void renderPackages(Element parent) {\n        Element table = append(parent, \"table\");\n        Element thead = append(table, \"thead\");\n        Element tr = append(thead, \"tr\");\n        appendWithText(tr, \"th\", \"Package\");\n        appendWithText(tr, \"th\", \"Tests\");\n        appendWithText(tr, \"th\", \"Failures\");\n        appendWithText(tr, \"th\", \"Duration\");\n        appendWithText(tr, \"th\", \"Success rate\");\n        for (PackageTestResults testPackage : getResults().getPackages()) {\n            tr = append(table, \"tr\");\n            Element td = append(tr, \"td\");\n            td.setAttribute(\"class\", testPackage.getStatusClass());\n            appendLink(td, String.format(\"%s.html\", testPackage.getName()), testPackage.getName());\n            appendWithText(tr, \"td\", testPackage.getTestCount());\n            appendWithText(tr, \"td\", testPackage.getFailureCount());\n            appendWithText(tr, \"td\", testPackage.getFormattedDuration());\n            td = appendWithText(tr, \"td\", testPackage.getFormattedSuccessRate());\n            td.setAttribute(\"class\", testPackage.getStatusClass());\n        }\n    }","id":4,"modified_method":"@Override\n    protected void renderBreadcrumbs(SimpleHtmlWriter htmlWriter) {\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override protected void registerTabs() {\n        addFailuresTab();\n        addTab(\"Classes\", new Action<Element>() {\n            public void execute(Element element) {\n                renderClasses(element);\n            }\n        });\n    }","id":5,"modified_method":"@Override\n    protected void registerTabs() {\n        addFailuresTab();\n        addTab(\"Classes\", new ErroringAction<SimpleHtmlWriter>() {\n            public void doExecute(SimpleHtmlWriter htmlWriter) throws IOException {\n                renderClasses(htmlWriter);\n            }\n        });\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override protected void renderBreadcrumbs(Element parent) {\n        Element div = append(parent, \"div\");\n        div.setAttribute(\"class\", \"breadcrumbs\");\n        appendLink(div, \"index.html\", \"all\");\n        appendText(div, String.format(\" > %s\", getResults().getName()));\n    }","id":6,"modified_method":"@Override\n    protected void renderBreadcrumbs(SimpleHtmlWriter htmlWriter) throws IOException {\n        htmlWriter.startElement(\"div\").attribute(\"class\", \"breadcrumbs\");\n        htmlWriter.startElement(\"a\").attribute(\"href\", \"index.html\").characters(\"all\").endElement();\n        htmlWriter.characters(String.format(\" > %s\", getResults().getName()));\n        htmlWriter.endElement();\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"protected void addTab(String title, final Action<Element> contentRenderer) {\n        tabsRenderer.add(title, new DomReportRenderer<T>() {\n            @Override\n            public void render(T model, Element parent) {\n                contentRenderer.execute(parent);\n            }\n        });\n    }","id":7,"modified_method":"protected void addTab(String title, final Action<SimpleHtmlWriter> contentRenderer) {\n        tabsRenderer.add(title, new AbstractHtmlReportRenderer<T>() {\n            @Override\n            public void render(T model, SimpleHtmlWriter writer) {\n                contentRenderer.execute(writer);\n            }\n        });\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"protected abstract void renderBreadcrumbs(Element parent);","id":8,"modified_method":"protected abstract void renderBreadcrumbs(SimpleHtmlWriter htmlWriter) throws IOException;","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected DomReportRenderer<T> getContentRenderer() {\n        return new DomReportRenderer<T>() {\n            @Override\n            public void render(T model, Element content) {\n                PageRenderer.this.results = model;\n                tabsRenderer.clear();\n                registerTabs();\n                renderTabs(content);\n            }\n        };\n    }","id":9,"modified_method":"@Override\n    protected AbstractHtmlReportRenderer<T> getContentRenderer() {\n        return new AbstractHtmlReportRenderer<T>() {\n            @Override\n            public void render(T model, SimpleHtmlWriter htmlWriter) throws IOException {\n                PageRenderer.this.results = model;\n                tabsRenderer.clear();\n                registerTabs();\n                renderTabs(htmlWriter);\n            }\n        };\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected DomReportRenderer<T> getHeaderRenderer() {\n        return new DomReportRenderer<T>() {\n            @Override\n            public void render(T model, Element content) {\n                PageRenderer.this.results = model;\n                renderBreadcrumbs(content);\n\n                // summary\n                Element summary = appendWithId(content, \"div\", \"summary\");\n                Element row = appendTableAndRow(summary);\n                Element group = appendCell(row);\n                group.setAttribute(\"class\", \"summaryGroup\");\n                Element summaryRow = appendTableAndRow(group);\n\n                Element tests = appendCell(summaryRow);\n                tests.setAttribute(\"id\", \"tests\");\n                tests.setAttribute(\"class\", \"infoBox\");\n                Element div = appendWithText(tests, \"div\", results.getTestCount());\n                div.setAttribute(\"class\", \"counter\");\n                appendWithText(tests, \"p\", \"tests\");\n\n                Element failures = appendCell(summaryRow);\n                failures.setAttribute(\"id\", \"failures\");\n                failures.setAttribute(\"class\", \"infoBox\");\n                div = appendWithText(failures, \"div\", results.getFailureCount());\n                div.setAttribute(\"class\", \"counter\");\n                appendWithText(failures, \"p\", \"failures\");\n\n                Element duration = appendCell(summaryRow);\n                duration.setAttribute(\"id\", \"duration\");\n                duration.setAttribute(\"class\", \"infoBox\");\n                div = appendWithText(duration, \"div\", results.getFormattedDuration());\n                div.setAttribute(\"class\", \"counter\");\n                appendWithText(duration, \"p\", \"duration\");\n\n                Element successRate = appendCell(row);\n                successRate.setAttribute(\"id\", \"successRate\");\n                successRate.setAttribute(\"class\", String.format(\"infoBox %s\", results.getStatusClass()));\n                div = appendWithText(successRate, \"div\", results.getFormattedSuccessRate());\n                div.setAttribute(\"class\", \"percent\");\n                appendWithText(successRate, \"p\", \"successful\");\n            }\n        };\n    }","id":10,"modified_method":"@Override\n    protected AbstractHtmlReportRenderer<T> getHeaderRenderer() {\n        return new AbstractHtmlReportRenderer<T>() {\n            @Override\n            public void render(T model, SimpleHtmlWriter htmlWriter) throws IOException {\n                PageRenderer.this.results = model;\n                renderBreadcrumbs(htmlWriter);\n\n                // summary\n                htmlWriter.startElement(\"div\").attribute(\"id\", \"summary\");\n                htmlWriter.startElement(\"table\");\n                htmlWriter.startElement(\"tr\");\n                htmlWriter.startElement(\"td\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"summaryGroup\");\n                htmlWriter.startElement(\"table\");\n                htmlWriter.startElement(\"tr\");\n                htmlWriter.startElement(\"td\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"infoBox\").attribute(\"id\", \"tests\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"counter\").characters(Integer.toString(results.getTestCount())).endElement();\n                htmlWriter.startElement(\"p\").characters(\"tests\").endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.startElement(\"td\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"infoBox\").attribute(\"id\", \"failures\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"counter\").characters(Integer.toString(results.getFailureCount())).endElement();\n                htmlWriter.startElement(\"p\").characters(\"failures\").endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.startElement(\"td\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"infoBox\").attribute(\"id\", \"duration\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"counter\").characters(results.getFormattedDuration()).endElement();\n                htmlWriter.startElement(\"p\").characters(\"duration\").endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.startElement(\"td\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", String.format(\"infoBox %s\", results.getStatusClass())).attribute(\"id\", \"successRate\");\n                htmlWriter.startElement(\"div\").attribute(\"class\", \"percent\").characters(results.getFormattedSuccessRate()).endElement();\n                htmlWriter.startElement(\"p\").characters(\"successful\").endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n                htmlWriter.endElement();\n            }\n        };\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"protected void addFailuresTab() {\n        if (!results.getFailures().isEmpty()) {\n            addTab(\"Failed tests\", new Action<Element>() {\n                public void execute(Element element) {\n                    renderFailures(element);\n                }\n            });\n        }\n    }","id":11,"modified_method":"protected void addFailuresTab() {\n        if (!results.getFailures().isEmpty()) {\n            addTab(\"Failed tests\", new ErroringAction<SimpleHtmlWriter>() {\n                public void doExecute(SimpleHtmlWriter element) throws IOException {\n                    renderFailures(element);\n                }\n            });\n        }\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected DomReportRenderer<BuildProfile> getContentRenderer() {\n            return new TextDomReportRenderer<BuildProfile>(new HTMLProfileReport());\n        }","id":12,"modified_method":"@Override\n        protected AbstractHtmlReportRenderer<BuildProfile> getContentRenderer() {\n            return new AbstractHtmlReportRenderer<BuildProfile>() {\n                @Override\n                public void render(BuildProfile model, SimpleHtmlWriter htmlWriter) throws IOException {\n                    htmlWriter.startElement(\"div\").attribute(\"id\", \"tabs\")\n                        .startElement(\"ul\").attribute(\"class\", \"tabLinks\")\n                            .startElement(\"li\").startElement(\"a\").attribute(\"href\", \"#tab0\").characters(\"Summary\").endElement().endElement()\n                            .startElement(\"li\").startElement(\"a\").attribute(\"href\", \"#tab1\").characters(\"Configuration\").endElement().endElement()\n                            .startElement(\"li\").startElement(\"a\").attribute(\"href\", \"#tab2\").characters(\"Dependency Resolution\").endElement().endElement()\n                            .startElement(\"li\").startElement(\"a\").attribute(\"href\", \"#tab3\").characters(\"Task Execution\").endElement().endElement()\n                        .endElement();\n                        htmlWriter.startElement(\"div\").attribute(\"class\", \"tab\").attribute(\"id\", \"tab0\");\n                            htmlWriter.startElement(\"h2\").characters(\"Summary\").endElement();\n                            htmlWriter.startElement(\"table\");\n                                htmlWriter.startElement(\"thead\");\n                                    htmlWriter.startElement(\"tr\");\n                                        htmlWriter.startElement(\"th\").characters(\"Description\").endElement();\n                                        htmlWriter.startElement(\"th\").attribute(\"class\", \"numeric\").characters(\"Duration\").endElement();\n                                    htmlWriter.endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"Total Build Time\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getElapsedTotal())).endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"Startup\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getElapsedStartup())).endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"Settings and BuildSrc\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getElapsedSettings())).endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"Loading Projects\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getElapsedProjectsLoading())).endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"Configuring Projects\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getElapsedAfterProjectsEvaluated())).endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"Task Execution\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getElapsedTotalExecutionTime())).endElement();\n                                htmlWriter.endElement();\n                            htmlWriter.endElement();\n                        htmlWriter.endElement();\n                        htmlWriter.startElement(\"div\").attribute(\"class\", \"tab\").attribute(\"id\", \"tab1\");\n                            htmlWriter.startElement(\"h2\").characters(\"Configuration\").endElement();\n                            htmlWriter.startElement(\"table\");\n                                htmlWriter.startElement(\"thead\");\n                                    htmlWriter.startElement(\"tr\");\n                                        htmlWriter.startElement(\"th\").characters(\"Project\").endElement();\n                                        htmlWriter.startElement(\"th\").attribute(\"class\", \"numeric\").characters(\"Duration\").endElement();\n                                    htmlWriter.endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"All projects\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getProjectConfiguration().getElapsedTime())).endElement();\n                                htmlWriter.endElement();\n                                final List<Operation> operations = model.getProjectConfiguration().getOperations();\n                                //sort in reverse order\n                                Collections.sort(operations, new Comparator<Operation>() {\n                                        public int compare(Operation o1, Operation o2) {\n                                        return Long.valueOf(o2.getElapsedTime()).compareTo(Long.valueOf(o1.getElapsedTime()));\n                                    }\n                                    });\n                                for (Operation operation : operations) {\n                                    EvalutationOperation evalOperation = (EvalutationOperation)operation;\n                                    htmlWriter.startElement(\"tr\");\n                                        htmlWriter.startElement(\"td\").characters(evalOperation.getPath()).endElement();\n                                        htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(evalOperation.getElapsedTime())).endElement();\n                                    htmlWriter.endElement();\n                                }\n                            htmlWriter.endElement()\n                        .endElement();\n                        htmlWriter.startElement(\"div\").attribute(\"class\", \"tab\").attribute(\"id\", \"tab2\");\n                            htmlWriter.startElement(\"h2\").characters(\"Dependency Resolution\").endElement()\n                                .startElement(\"table\")\n                                    .startElement(\"thead\");\n                                    htmlWriter.startElement(\"tr\");\n                                        htmlWriter.startElement(\"th\").characters(\"Dependencies\").endElement();\n                                        htmlWriter.startElement(\"th\").attribute(\"class\", \"numeric\").characters(\"Duration\").endElement();\n                                    htmlWriter.endElement();\n                                htmlWriter.endElement();\n                                htmlWriter.startElement(\"tr\");\n                                    htmlWriter.startElement(\"td\").characters(\"All dependencies\").endElement();\n                                    htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getDependencySets().getElapsedTime())).endElement();\n                                htmlWriter.endElement();\n\n                                final List<DependencyResolveProfile> dependencyResolveProfiles = model.getDependencySets().getOperations();\n                                Collections.sort(dependencyResolveProfiles, new Comparator<DependencyResolveProfile>() {\n                                        public int compare(DependencyResolveProfile p1, DependencyResolveProfile p2) {\n                                        return Long.valueOf(p2.getElapsedTime()).compareTo(Long.valueOf(p1.getElapsedTime()));\n                                    }\n                                    });\n                                for (DependencyResolveProfile profile : dependencyResolveProfiles) {\n                                    htmlWriter.startElement(\"tr\");\n                                        htmlWriter.startElement(\"td\").characters(profile.getPath()).endElement();\n                                        htmlWriter.startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(profile.getElapsedTime())).endElement();\n                                    htmlWriter.endElement();\n                                }\n                            htmlWriter.endElement()\n                        .endElement();\n                        htmlWriter.startElement(\"div\").attribute(\"class\", \"tab\").attribute(\"id\", \"tab3\");\n                            htmlWriter.startElement(\"h2\").characters(\"Task Execution\").endElement()\n                            .startElement(\"table\")\n                                .startElement(\"thead\")\n                                    .startElement(\"tr\")\n                                        .startElement(\"th\").characters(\"Task\").endElement()\n                                        .startElement(\"th\").attribute(\"class\", \"numeric\").characters(\"Duration\").endElement()\n                                        .startElement(\"th\").characters(\"Result\").endElement()\n                                    .endElement()\n                                .endElement();\n                                htmlWriter.startElement(\"tr\")\n                                    .startElement(\"td\").characters(\"All dependencies\").endElement()\n                                    .startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(model.getDependencySets().getElapsedTime())).endElement()\n                                .endElement();\n                                final List<ProjectProfile> projects = model.getProjects();\n                                Collections.sort(projects, new Comparator<ProjectProfile>() {\n                                        public int compare(ProjectProfile p1, ProjectProfile p2) {\n                                        return Long.valueOf(p2.getTasks().getElapsedTime()).compareTo(p1.getTasks().getElapsedTime());\n                                    }\n                                });\n                                for (ProjectProfile project : projects) {\n                                   htmlWriter.startElement(\"tr\")\n                                        .startElement(\"td\").characters(project.getPath()).endElement()\n                                        .startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(project.getTasks().getElapsedTime())).endElement()\n                                        .startElement(\"td\").characters(\"(total)\").endElement()\n                                    .endElement();\n                                    final List<TaskExecution> taskExecutions  = project.getTasks().getOperations();\n                                    Collections.sort(taskExecutions, new Comparator<TaskExecution>() {\n                                               public int compare(TaskExecution p1, TaskExecution p2) {\n                                            return Long.valueOf(p2.getElapsedTime()).compareTo(Long.valueOf(p1.getElapsedTime()));\n                                        }\n                                           });\n                                    for (TaskExecution taskExecution : taskExecutions) {\n                                        htmlWriter.startElement(\"tr\")\n                                            .startElement(\"td\").attribute(\"class\", \"identPath\").characters(taskExecution.getPath()).endElement()\n                                            .startElement(\"td\").attribute(\"class\", \"numeric\").characters(DURATION_FORMAT.format(taskExecution.getElapsedTime())).endElement()\n                                            .startElement(\"td\").characters(taskExecution.getState().getSkipped() ? taskExecution.getState().getSkipMessage() : (taskExecution.getState().getDidWork()) ? \"\" : \"Did No Work\").endElement()\n                                        .endElement();\n                                    }\n                                }\n                            htmlWriter.endElement()\n                        .endElement()\n                    .endElement();\n                }\n            };\n        }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected DomReportRenderer<BuildProfile> getHeaderRenderer() {\n            return new DomReportRenderer<BuildProfile>() {\n                @Override\n                public void render(BuildProfile model, Element parent) {\n                    Element header = appendWithId(parent, \"div\", \"header\");\n                    appendWithText(header, \"p\", String.format(\"Profiled with tasks: %s\", model.getTaskDescription()));\n                    appendWithText(header, \"p\", String.format(\"Run on: %s\", DATE_FORMAT.format(model.getBuildStarted())));\n                }\n            };\n        }","id":13,"modified_method":"@Override\n        protected AbstractHtmlReportRenderer<BuildProfile> getHeaderRenderer() {\n            return new AbstractHtmlReportRenderer<BuildProfile>() {\n                @Override\n                public void render(BuildProfile model, SimpleHtmlWriter htmlWriter) throws IOException {\n                    htmlWriter.startElement(\"div\").attribute(\"id\", \"header\")\n                        .startElement(\"p\").characters(String.format(\"Profiled with tasks: %s\", model.getTaskDescription())).endElement()\n                        .startElement(\"p\").characters(String.format(\"Run on: %s\", DATE_FORMAT.format(model.getBuildStarted()))).endElement()\n                    .endElement();\n                }\n            };\n        }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"public ProjectProfile(Project project) {\n        this.project = project;\n    }","id":14,"modified_method":"public ProjectProfile(Project project) {\n        this.project = project;\n        this.evaluation = new EvalutationOperation(project);\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"public SimpleXmlWriter(OutputStream output, String indent) throws IOException {\n        this.indent = indent;\n        this.output = new OutputStreamWriter(output, \"UTF-8\");\n        writeXmlDeclaration(\"UTF-8\", \"1.1\");\n    }","id":15,"modified_method":"public SimpleXmlWriter(OutputStream output, String indent) throws IOException {\n        super(output, indent);\n        writeXmlDeclaration(\"UTF-8\", \"1.1\");\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"protected abstract DomReportRenderer<T> getContentRenderer();","id":16,"modified_method":"protected abstract AbstractHtmlReportRenderer<T> getContentRenderer();","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"protected abstract DomReportRenderer<T> getHeaderRenderer();","id":17,"modified_method":"protected abstract AbstractHtmlReportRenderer<T> getHeaderRenderer();","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"private TabDefinition(String title, DomReportRenderer<T> renderer) {\n            this.title = title;\n            this.renderer = renderer;\n        }","id":18,"modified_method":"private TabDefinition(String title, AbstractHtmlReportRenderer<T> renderer) {\n            this.title = title;\n            this.renderer = renderer;\n        }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"public void add(String title, DomReportRenderer<T> contentRenderer) {\n        tabs.add(new TabDefinition(title, contentRenderer));\n    }","id":19,"modified_method":"public void add(String title, AbstractHtmlReportRenderer<T> contentRenderer) {\n        tabs.add(new TabDefinition(title, contentRenderer));\n    }","commit_id":"4f33342c635fdf70aa36fec8351f8d78cde3de14","url":"https://github.com/gradle/gradle"},{"original_method":"protected MavenExecutionRequest createMavenExecutionRequest( File pom )\n        throws Exception\n    {        \n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( pom )\n            .setProjectPresent( true )\n            .setPluginGroups( Arrays.asList( new String[] { \"org.apache.maven.plugins\" } ) )\n            .setLocalRepository( getLocalRepository() )\n            .setRemoteRepositories( getRemoteRepositories() )\n            .setPluginArtifactRepositories( getPluginArtifactRepositories() )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) )\n            .setProperties( new Properties() );\n\n        return request;\n    }","id":20,"modified_method":"protected MavenExecutionRequest createMavenExecutionRequest( File pom )\n        throws Exception\n    {        \n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( pom )\n            .setProjectPresent( true )\n            .setShowErrors( true )\n            .setPluginGroups( Arrays.asList( new String[] { \"org.apache.maven.plugins\" } ) )\n            .setLocalRepository( getLocalRepository() )\n            .setRemoteRepositories( getRemoteRepositories() )\n            .setPluginArtifactRepositories( getPluginArtifactRepositories() )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) )\n            .setProperties( new Properties() );\n\n        return request;\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testExecutionUsingABaseDirectory()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project0\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( targetDirectory )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[]{\"package\"} ) );\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","id":21,"modified_method":"public void testExecutionUsingABaseDirectory()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project0\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n\n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( targetDirectory )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[]{\"package\"} ) );\n        */\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testEmbedderWillStillStartupWhenTheSettingsConfigurationIsCrap()\n        throws Exception\n    {\n        // START SNIPPET: simple-embedder-example\n\n        File projectDirectory = getTestFile( \"src/examples/simple-project\" );\n\n        File user = new File( projectDirectory, \"invalid-settings.xml\" );\n\n        Configuration configuration = new SimpleConfiguration()\n            .setUserSettingsFile( user );\n\n        ConfigurationValidationResult validationResult = MavenEmbedder.validateConfiguration( configuration );\n\n        assertFalse( validationResult.isValid() );\n\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        //assertNotNull( embedder.getLocalRepository().getBasedir() );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( projectDirectory )\n            .setGoals( Arrays.asList( new String[]{\"validate\"} ) );\n\n        MavenExecutionResult result = embedder.execute( request );\n        \n        for ( Exception e : result.getExceptions() )\n        {\n            e.printStackTrace();\n        }\n        \n        assertFalse( result.hasExceptions() );\n\n        assertNotNull( result.getProject() );\n\n        MavenProject project = result.getProject();\n\n        String environment = project.getProperties().getProperty( \"environment\" );\n\n        assertEquals( \"development\", environment );\n\n        // END SNIPPET: simple-embedder-example\n    }","id":22,"modified_method":"public void testEmbedderWillStillStartupWhenTheSettingsConfigurationIsCrap()\n        throws Exception\n    {\n        // START SNIPPET: simple-embedder-example\n\n        File projectDirectory = getTestFile( \"src/examples/simple-project\" );\n\n        File user = new File( projectDirectory, \"invalid-settings.xml\" );\n\n        Configuration configuration = new SimpleConfiguration()\n            .setUserSettingsFile( user );\n\n        ConfigurationValidationResult validationResult = MavenEmbedder.validateConfiguration( configuration );\n\n        assertFalse( validationResult.isValid() );\n\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        //assertNotNull( embedder.getLocalRepository().getBasedir() );\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( projectDirectory, \"pom.xml\" ) );        \n        \n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( projectDirectory )\n            .setGoals( Arrays.asList( new String[]{\"validate\"} ) );\n        */\n\n        MavenExecutionResult result = embedder.execute( request );\n        \n        for ( Exception e : result.getExceptions() )\n        {\n            e.printStackTrace();\n        }\n        \n        assertFalse( result.hasExceptions() );\n\n        assertNotNull( result.getProject() );\n\n        MavenProject project = result.getProject();\n\n        String environment = project.getProperties().getProperty( \"environment\" );\n\n        assertEquals( \"development\", environment );\n\n        // END SNIPPET: simple-embedder-example\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testExecutionUsingABaseDirectory()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project0\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( targetDirectory )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[]{\"package\"} ) );\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","id":23,"modified_method":"public void testExecutionUsingABaseDirectory()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project0\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n\n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( targetDirectory )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[]{\"package\"} ) );\n        */\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testExecutionUsingAProfileWhichSetsAProperty()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project2\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        // Check with profile not active\n\n        MavenExecutionRequest requestWithoutProfile = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) );\n\n        MavenExecutionResult r0 = mavenEmbedder.execute( requestWithoutProfile );\n\n        assertNoExceptions( r0 );\n\n        MavenProject p0 = r0.getProject();\n\n        assertNull( p0.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"name\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"occupation\" ) );\n\n        // Check with profile activated\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) )\n            .addActiveProfile( \"embedderProfile\" );\n\n        MavenExecutionResult r1 = mavenEmbedder.execute( request );\n\n        MavenProject p1 = r1.getProject();\n\n        System.out.println( p1 );\n        System.out.println( p1.getProperties() );\n        \n        assertEquals( \"true\", p1.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertEquals( \"jason\", p1.getProperties().getProperty( \"name\" ) );\n\n        assertEquals( \"somnambulance\", p1.getProperties().getProperty( \"occupation\" ) );\n    }","id":24,"modified_method":"public void testExecutionUsingAProfileWhichSetsAProperty()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project2\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        // Check with profile not active\n\n        MavenExecutionRequest requestWithoutProfile = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n\n        /*\n        MavenExecutionRequest requestWithoutProfile = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) );\n        */\n\n        MavenExecutionResult r0 = mavenEmbedder.execute( requestWithoutProfile );\n\n        assertNoExceptions( r0 );\n\n        MavenProject p0 = r0.getProject();\n\n        assertNull( p0.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"name\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"occupation\" ) );\n\n        // Check with profile activated\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n        request.addActiveProfile( \"embedderProfile\" );\n        \n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) )\n            .addActiveProfile( \"embedderProfile\" );\n        */\n\n        MavenExecutionResult r1 = mavenEmbedder.execute( request );\n\n        MavenProject p1 = r1.getProject();\n\n        System.out.println( p1 );\n        System.out.println( p1.getProperties() );\n        \n        assertEquals( \"true\", p1.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertEquals( \"jason\", p1.getProperties().getProperty( \"name\" ) );\n\n        assertEquals( \"somnambulance\", p1.getProperties().getProperty( \"occupation\" ) );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testWithOptionalDependencies()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/projects/optional-dep\" );\n\n        File targetDirectory = new File( basedir, \"target/projects/option-dep\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( targetDirectory )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"install\" } ) );\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n        \n        if (result.hasExceptions() )\n        {\n            result.getExceptions().get( 0 ).printStackTrace();\n            fail( \"Project didn't execute correctly.\");\n        }\n    }","id":25,"modified_method":"public void testWithOptionalDependencies()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/projects/optional-dep\" );\n\n        File targetDirectory = new File( basedir, \"target/projects/option-dep\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n        \n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( targetDirectory )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"install\" } ) );\n        */\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n        \n        if (result.hasExceptions() )\n        {\n            result.getExceptions().get( 0 ).printStackTrace();\n            fail( \"Project didn't execute correctly.\");\n        }\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Test that two executions of the embedder don't share data that has changed, see MNG-3013\n     *\n     * @throws Exception\n     */\n    public void testTwoExecutionsDoNotCacheChangedData()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project-caching\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        File pom = new File( targetDirectory, \"pom.xml\" );\n\n        Model model = mavenEmbedder.readModel( pom );\n\n        Plugin plugin = new Plugin();\n        plugin.setArtifactId( \"maven-surefire-plugin\" );\n        plugin.setVersion( \"2.4.2\" );\n        model.setBuild( new Build() );\n        model.getBuild().addPlugin( plugin );\n\n        Writer writer = WriterFactory.newXmlWriter( pom );\n        mavenEmbedder.writeModel( writer, model );\n        writer.close();\n\n        /* execute maven */\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setPom( pom ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        MavenProject project = result.getProject();\n\n        Artifact p = project.getPluginArtifactMap().get( plugin.getKey() );\n        assertEquals( \"2.4.2\", p.getVersion() );\n\n        /* Add the surefire plugin 2.3 to the pom */\n        plugin.setVersion( \"2.4.3\" );\n        writer = WriterFactory.newXmlWriter( pom );\n        mavenEmbedder.writeModel( writer, model );\n        writer.close();\n\n        /* execute Maven */\n        request = new DefaultMavenExecutionRequest().setPom( pom ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n        result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        project = result.getProject();\n\n        p = project.getPluginArtifactMap().get( plugin.getKey() );\n        assertEquals( \"2.4.3\", p.getVersion() );\n    }","id":26,"modified_method":"/**\n     * Test that two executions of the embedder don't share data that has changed, see MNG-3013\n     *\n     * @throws Exception\n     */\n    public void testTwoExecutionsDoNotCacheChangedData()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project-caching\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        File pom = new File( targetDirectory, \"pom.xml\" );\n\n        Model model = mavenEmbedder.readModel( pom );\n\n        Plugin plugin = new Plugin();\n        plugin.setArtifactId( \"maven-surefire-plugin\" );\n        plugin.setVersion( \"2.4.2\" );\n        model.setBuild( new Build() );\n        model.getBuild().addPlugin( plugin );\n\n        Writer writer = WriterFactory.newXmlWriter( pom );\n        mavenEmbedder.writeModel( writer, model );\n        writer.close();\n\n        MavenExecutionRequest request = createMavenExecutionRequest( pom );\n        \n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest().setPom( pom ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n        */\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        MavenProject project = result.getProject();\n\n        Artifact p = project.getPluginArtifactMap().get( plugin.getKey() );\n        assertEquals( \"2.4.2\", p.getVersion() );\n\n        /* Add the surefire plugin 2.3 to the pom */\n        plugin.setVersion( \"2.4.3\" );\n        writer = WriterFactory.newXmlWriter( pom );\n        mavenEmbedder.writeModel( writer, model );\n        writer.close();\n\n        request = createMavenExecutionRequest( pom );\n        \n        /*\n        request = new DefaultMavenExecutionRequest().setPom( pom ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n        */\n            \n        result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n\n        project = result.getProject();\n\n        p = project.getPluginArtifactMap().get( plugin.getKey() );\n        assertEquals( \"2.4.3\", p.getVersion() );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testExecutionUsingAPomFile()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project1\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n        \n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","id":27,"modified_method":"public void testExecutionUsingAPomFile()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project1\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n\n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n        */\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n        \n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"private static boolean postCredentials(String user, String password) {\n    String url = stepicUrl + \"accounts/login/\";\n    final HttpPost request = new HttpPost(url);\n    List <NameValuePair> nvps = new ArrayList <NameValuePair>();\n    nvps.add(new BasicNameValuePair(\"csrfmiddlewaretoken\", ourCSRFToken));\n    nvps.add(new BasicNameValuePair(\"login\", user));\n    nvps.add(new BasicNameValuePair(\"next\", \"/\"));\n    nvps.add(new BasicNameValuePair(\"password\", password));\n    nvps.add(new BasicNameValuePair(\"remember\", \"on\"));\n\n    try {\n      request.setEntity(new UrlEncodedFormEntity(nvps, HTTP.UTF_8));\n    }\n    catch (UnsupportedEncodingException e) {\n      LOG.error(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n\n    setHeaders(request, \"application/x-www-form-urlencoded\");\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String s = EntityUtils.toString(response.getEntity());\n      saveCSRFToken();\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 302) {\n        LOG.error(\"Failed to login \" + EntityUtils.toString(response.getEntity()));\n        ourClient = null;\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.warn(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n    return true;\n  }","id":28,"modified_method":"private static boolean postCredentials(String user, String password) {\n    String url = stepicUrl + \"accounts/login/\";\n    final HttpPost request = new HttpPost(url);\n    List <NameValuePair> nvps = new ArrayList <NameValuePair>();\n    nvps.add(new BasicNameValuePair(\"csrfmiddlewaretoken\", ourCSRFToken));\n    nvps.add(new BasicNameValuePair(\"login\", user));\n    nvps.add(new BasicNameValuePair(\"next\", \"/\"));\n    nvps.add(new BasicNameValuePair(\"password\", password));\n    nvps.add(new BasicNameValuePair(\"remember\", \"on\"));\n\n    try {\n      request.setEntity(new UrlEncodedFormEntity(nvps, HTTP.UTF_8));\n    }\n    catch (UnsupportedEncodingException e) {\n      LOG.error(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n\n    setHeaders(request, \"application/x-www-form-urlencoded\");\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      saveCSRFToken();\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 302) {\n        final HttpEntity responseEntity = response.getEntity();\n        final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n        LOG.error(\"Failed to login \" + responseString);\n        ourClient = null;\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.warn(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n    return true;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int postLesson(Project project, @NotNull final Lesson lesson, ProgressIndicator indicator) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"lessons\");\n    if (ourClient == null) {\n      showLoginDialog();\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new LessonWrapper(lesson));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n        return 0;\n      }\n      final Lesson postedLesson = new Gson().fromJson(responseString, Course.class).getLessons().get(0);\n      for (Task task : lesson.getTaskList()) {\n        indicator.checkCanceled();\n        postTask(project, task, postedLesson.id);\n      }\n      return postedLesson.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","id":29,"modified_method":"public static int postLesson(Project project, @NotNull final Lesson lesson, ProgressIndicator indicator) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"lessons\");\n    if (ourClient == null) {\n      showLoginDialog();\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new LessonWrapper(lesson));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n        return 0;\n      }\n      final Lesson postedLesson = new Gson().fromJson(responseString, Course.class).getLessons().get(0);\n      for (Task task : lesson.getTaskList()) {\n        indicator.checkCanceled();\n        postTask(project, task, postedLesson.id);\n      }\n      return postedLesson.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int postModule(int courseId, int position, @NotNull final String title) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"sections\");\n    setHeaders(request, \"application/json\");\n    final Section section = new Section();\n    section.course = courseId;\n    section.title = title;\n    section.position = position;\n    final SectionWrapper sectionContainer = new SectionWrapper();\n    sectionContainer.section = section;\n    String requestBody = new Gson().toJson(sectionContainer);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n      final Section postedSection = new Gson().fromJson(responseString, SectionContainer.class).sections.get(0);\n      return postedSection.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","id":30,"modified_method":"private static int postModule(int courseId, int position, @NotNull final String title) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"sections\");\n    setHeaders(request, \"application/json\");\n    final Section section = new Section();\n    section.course = courseId;\n    section.title = title;\n    section.position = position;\n    final SectionWrapper sectionContainer = new SectionWrapper();\n    sectionContainer.section = section;\n    String requestBody = new Gson().toJson(sectionContainer);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n      final Section postedSection = new Gson().fromJson(responseString, SectionContainer.class).sections.get(0);\n      return postedSection.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void postAttempt(@NotNull final Task task, boolean passed, @Nullable String login, @Nullable String password) {\n    if (task.getStepicId() <= 0) {\n      return;\n    }\n    if (ourClient == null) {\n      if (StringUtil.isEmptyOrSpaces(login) || StringUtil.isEmptyOrSpaces(password)) {\n        return;\n      }\n      else {\n        final boolean success = login(login, password);\n        if (!success) return;\n      }\n    }\n\n    final HttpPost attemptRequest = new HttpPost(stepicApiUrl + \"attempts\");\n    setHeaders(attemptRequest, \"application/json\");\n    String attemptRequestBody = new Gson().toJson(new AttemptWrapper(task.getStepicId()));\n    attemptRequest.setEntity(new StringEntity(attemptRequestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse attemptResponse = ourClient.execute(attemptRequest);\n      final String attemptResponseString = EntityUtils.toString(attemptResponse.getEntity());\n      final StatusLine statusLine = attemptResponse.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to make attempt \" + attemptResponseString);\n      }\n      final AttemptWrapper.Attempt attempt = new Gson().fromJson(attemptResponseString, AttemptContainer.class).attempts.get(0);\n\n      final Map<String, TaskFile> taskFiles = task.getTaskFiles();\n      final ArrayList<SolutionFile> files = new ArrayList<SolutionFile>();\n      for (TaskFile fileEntry : taskFiles.values()) {\n        files.add(new SolutionFile(fileEntry.name, fileEntry.text));\n      }\n      postSubmission(passed, attempt, files);\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","id":31,"modified_method":"public static void postAttempt(@NotNull final Task task, boolean passed, @Nullable String login, @Nullable String password) {\n    if (task.getStepicId() <= 0) {\n      return;\n    }\n    if (ourClient == null) {\n      if (StringUtil.isEmptyOrSpaces(login) || StringUtil.isEmptyOrSpaces(password)) {\n        return;\n      }\n      else {\n        final boolean success = login(login, password);\n        if (!success) return;\n      }\n    }\n\n    final HttpPost attemptRequest = new HttpPost(stepicApiUrl + \"attempts\");\n    setHeaders(attemptRequest, \"application/json\");\n    String attemptRequestBody = new Gson().toJson(new AttemptWrapper(task.getStepicId()));\n    attemptRequest.setEntity(new StringEntity(attemptRequestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse attemptResponse = ourClient.execute(attemptRequest);\n      final HttpEntity responseEntity = attemptResponse.getEntity();\n      final String attemptResponseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine statusLine = attemptResponse.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to make attempt \" + attemptResponseString);\n      }\n      final AttemptWrapper.Attempt attempt = new Gson().fromJson(attemptResponseString, AttemptContainer.class).attempts.get(0);\n\n      final Map<String, TaskFile> taskFiles = task.getTaskFiles();\n      final ArrayList<SolutionFile> files = new ArrayList<SolutionFile>();\n      for (TaskFile fileEntry : taskFiles.values()) {\n        files.add(new SolutionFile(fileEntry.name, fileEntry.text));\n      }\n      postSubmission(passed, attempt, files);\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void postSubmission(boolean passed, AttemptWrapper.Attempt attempt, ArrayList<SolutionFile> files) throws IOException {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"submissions\");\n    setHeaders(request, \"application/json\");\n\n    String requestBody = new Gson().toJson(new SubmissionWrapper(attempt.id, passed ? \"1\" : \"0\", files));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final String responseString = EntityUtils.toString(response.getEntity());\n    final StatusLine line = response.getStatusLine();\n    if (line.getStatusCode() != 201) {\n      LOG.error(\"Failed to make submission \" + responseString);\n    }\n  }","id":32,"modified_method":"private static void postSubmission(boolean passed, AttemptWrapper.Attempt attempt, ArrayList<SolutionFile> files) throws IOException {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"submissions\");\n    setHeaders(request, \"application/json\");\n\n    String requestBody = new Gson().toJson(new SubmissionWrapper(attempt.id, passed ? \"1\" : \"0\", files));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final HttpEntity responseEntity = response.getEntity();\n    final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n    final StatusLine line = response.getStatusLine();\n    if (line.getStatusCode() != 201) {\n      LOG.error(\"Failed to make submission \" + responseString);\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void postCourse(final Project project, @NotNull Course course, boolean relogin, @NotNull final ProgressIndicator indicator) {\n    indicator.setText(\"Uploading course to \" + stepicUrl);\n    final HttpPost request = new HttpPost(stepicApiUrl + \"courses\");\n    if (ourClient == null || !relogin) {\n      if (!login()) return;\n    }\n    final AuthorWrapper user = getCurrentUser();\n    if (user != null) {\n      course.setAuthors(user.users);\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new CourseWrapper(course));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        if (!relogin) {\n          login();\n          postCourse(project, course, true, indicator);\n        }\n        LOG.error(\"Failed to push \" + responseString);\n        return;\n      }\n      final CourseInfo postedCourse = new Gson().fromJson(responseString, CoursesContainer.class).courses.get(0);\n\n      final int sectionId = postModule(postedCourse.id, 1, String.valueOf(postedCourse.getName()));\n      int position = 1;\n      for (Lesson lesson : course.getLessons()) {\n        indicator.checkCanceled();\n        final int lessonId = postLesson(project, lesson, indicator);\n        postUnit(lessonId, position, sectionId);\n        position += 1;\n      }\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          postAdditionalFiles(project, postedCourse.id, indicator);\n        }\n      });\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","id":33,"modified_method":"private static void postCourse(final Project project, @NotNull Course course, boolean relogin, @NotNull final ProgressIndicator indicator) {\n    indicator.setText(\"Uploading course to \" + stepicUrl);\n    final HttpPost request = new HttpPost(stepicApiUrl + \"courses\");\n    if (ourClient == null || !relogin) {\n      if (!login()) return;\n    }\n    final AuthorWrapper user = getCurrentUser();\n    if (user != null) {\n      course.setAuthors(user.users);\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new CourseWrapper(course));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        if (!relogin) {\n          login();\n          postCourse(project, course, true, indicator);\n        }\n        LOG.error(\"Failed to push \" + responseString);\n        return;\n      }\n      final CourseInfo postedCourse = new Gson().fromJson(responseString, CoursesContainer.class).courses.get(0);\n\n      final int sectionId = postModule(postedCourse.id, 1, String.valueOf(postedCourse.getName()));\n      int position = 1;\n      for (Lesson lesson : course.getLessons()) {\n        indicator.checkCanceled();\n        final int lessonId = postLesson(project, lesson, indicator);\n        postUnit(lessonId, position, sectionId);\n        position += 1;\n      }\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          postAdditionalFiles(project, postedCourse.id, indicator);\n        }\n      });\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static <T> T getFromStepic(String link, final Class<T> container) throws IOException {\n    final HttpGet request = new HttpGet(stepicApiUrl + link);\n    if (ourClient == null) {\n      initializeClient();\n    }\n    setHeaders(request, \"application/json\");\n\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final StatusLine statusLine = response.getStatusLine();\n    final String responseString = EntityUtils.toString(response.getEntity());\n    if (statusLine.getStatusCode() != 200) {\n      throw new IOException(\"Stepic returned non 200 status code \" + responseString);\n    }\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    return gson.fromJson(responseString, container);\n  }","id":34,"modified_method":"private static <T> T getFromStepic(String link, final Class<T> container) throws IOException {\n    final HttpGet request = new HttpGet(stepicApiUrl + link);\n    if (ourClient == null) {\n      initializeClient();\n    }\n    setHeaders(request, \"application/json\");\n\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final StatusLine statusLine = response.getStatusLine();\n    final HttpEntity responseEntity = response.getEntity();\n    final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n    if (statusLine.getStatusCode() != 200) {\n      throw new IOException(\"Stepic returned non 200 status code \" + responseString);\n    }\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    return gson.fromJson(responseString, container);\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void postUnit(int lessonId, int position, int sectionId) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"units\");\n    setHeaders(request, \"application/json\");\n    final UnitWrapper unitWrapper = new UnitWrapper();\n    unitWrapper.unit = new Unit();\n    unitWrapper.unit.lesson = lessonId;\n    unitWrapper.unit.position = position;\n    unitWrapper.unit.section = sectionId;\n\n    String requestBody = new Gson().toJson(unitWrapper);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","id":35,"modified_method":"private static void postUnit(int lessonId, int position, int sectionId) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"units\");\n    setHeaders(request, \"application/json\");\n    final UnitWrapper unitWrapper = new UnitWrapper();\n    unitWrapper.unit = new Unit();\n    unitWrapper.unit.lesson = lessonId;\n    unitWrapper.unit.position = position;\n    unitWrapper.unit.section = sectionId;\n\n    String requestBody = new Gson().toJson(unitWrapper);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void postTask(final Project project, @NotNull final Task task, final int lessonId) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"step-sources\");\n    setHeaders(request, \"application/json\");\n    final Gson gson = new GsonBuilder().setPrettyPrinting().excludeFieldsWithoutExposeAnnotation().create();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        final String requestBody = gson.toJson(new StepSourceWrapper(project, task, lessonId));\n        request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n        try {\n          final CloseableHttpResponse response = ourClient.execute(request);\n          final StatusLine line = response.getStatusLine();\n          if (line.getStatusCode() != 201) {\n            LOG.error(\"Failed to push \" + EntityUtils.toString(response.getEntity()));\n          }\n        }\n        catch (IOException e) {\n          LOG.error(e.getMessage());\n        }\n      }\n    });\n  }","id":36,"modified_method":"public static void postTask(final Project project, @NotNull final Task task, final int lessonId) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"step-sources\");\n    setHeaders(request, \"application/json\");\n    final Gson gson = new GsonBuilder().setPrettyPrinting().excludeFieldsWithoutExposeAnnotation().create();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        final String requestBody = gson.toJson(new StepSourceWrapper(project, task, lessonId));\n        request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n        try {\n          final CloseableHttpResponse response = ourClient.execute(request);\n          final StatusLine line = response.getStatusLine();\n          if (line.getStatusCode() != 201) {\n            final HttpEntity responseEntity = response.getEntity();\n            final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n            LOG.error(\"Failed to push \" + responseString);\n          }\n        }\n        catch (IOException e) {\n          LOG.error(e.getMessage());\n        }\n      }\n    });\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean createUser(@NotNull final String user, @NotNull final String password) {\n    final HttpPost userRequest = new HttpPost(stepicApiUrl + \"users\");\n    initializeClient();\n    setHeaders(userRequest, \"application/json\");\n    String requestBody = new Gson().toJson(new UserWrapper(user, password));\n    userRequest.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(userRequest);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine statusLine = response.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to create user \" + responseString);\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return true;\n  }","id":37,"modified_method":"public static boolean createUser(@NotNull final String user, @NotNull final String password) {\n    final HttpPost userRequest = new HttpPost(stepicApiUrl + \"users\");\n    initializeClient();\n    setHeaders(userRequest, \"application/json\");\n    String requestBody = new Gson().toJson(new UserWrapper(user, password));\n    userRequest.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(userRequest);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine statusLine = response.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to create user \" + responseString);\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return true;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        staticId = handlerContext.getId(attributes);\n        prefixedId = handlerContext.getIdPrefix() + staticId;\n        effectiveId = handlerContext.getEffectiveId(attributes);\n\n        xformsControl = handlerContext.isTemplate()\n                ? null : (XFormsSingleNodeControl) containingDocument.getObjectByEffectiveId(effectiveId);\n\n        // Give the handler a chance to do some prep work\n        prepareHandler(uri, localname, qName, attributes, staticId, effectiveId, xformsControl);\n\n        if (isMustOutputControl(xformsControl)) {\n\n            final ContentHandler contentHandler = handlerContext.getController().getOutput();\n            final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n            if (handlerContext.isNewXHTMLLayout()) {\n                // Open control <span>\n                spanQName = XMLUtils.buildQName(xhtmlPrefix, \"span\");\n\n                final AttributesImpl containerAttributes = getContainerAttributes(uri, localname, attributes);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName, containerAttributes);\n            }\n\n            // Get local order for control\n            final String localOrder = attributes.getValue(XFormsConstants.XXFORMS_ORDER_QNAME.getNamespaceURI(),\n                    XFormsConstants.XXFORMS_ORDER_QNAME.getName());\n\n            // Use local or default config\n            final String[] config = (localOrder != null) ? StringUtils.split(localOrder) : handlerContext.getDocumentOrder();\n\n            // Output named anchor if the control has a help or alert. This is so that a separate help and error\n            // sections can link back to the control.\n            if (handlerContext.isNoScript()) {\n                if (xformsControl != null\n                        && (XFormsControl.hasHelp(containingDocument, prefixedId)\n                            || XFormsControl.hasAlert(containingDocument, prefixedId))) {\n                    final String aQName = XMLUtils.buildQName(xhtmlPrefix, \"a\");\n                    reusableAttributes.clear();\n                    reusableAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, xformsControl.getEffectiveId());\n                    contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"a\", aQName, reusableAttributes);\n                    contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"a\", aQName);\n                }\n            }\n\n            final boolean isTemplate = handlerContext.isTemplate();\n\n            // Process everything up to and including the control\n            for (int i = 0; i < config.length; i++) {\n                final String current = config[i];\n\n                if (\"control\".equals(current)) {\n                    // Handle control\n                    handleControlStart(uri, localname, qName, attributes, staticId, effectiveId, xformsControl);\n                    // Do the rest in end() below if needed\n                    if (i < config.length - 1) {\n                        // There remains stuff to process\n                        final int endConfigLength = config.length - i;\n                        endConfig = new String[endConfigLength];\n                        System.arraycopy(config, i, endConfig, 0, endConfigLength);\n                        this.attributes = new AttributesImpl(attributes);\n                    }\n                    break;\n                } else if (\"label\".equals(current)) {\n                    // xforms:label\n                    if (hasLocalLabel())\n                        handleLabel(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                } else if (\"alert\".equals(current)) {\n                    // xforms:alert\n                    if (hasLocalAlert())\n                        handleAlert(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                } else if (\"hint\".equals(current)) {\n                    // xforms:hint\n                    if (hasLocalHint())\n                        handleHint(staticId, effectiveId, xformsControl, isTemplate);\n                } else {\n                    // xforms:help\n                    if (hasLocalHelp())\n                        handleHelp(staticId, effectiveId, xformsControl, isTemplate);\n                }\n            }\n        }\n    }","id":38,"modified_method":"@Override\n    public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        staticId = handlerContext.getId(attributes);\n        prefixedId = handlerContext.getIdPrefix() + staticId;\n        effectiveId = handlerContext.getEffectiveId(attributes);\n\n        xformsControl = handlerContext.isTemplate()\n                ? null : (XFormsSingleNodeControl) containingDocument.getObjectByEffectiveId(effectiveId);\n\n        // Give the handler a chance to do some prep work\n        prepareHandler(uri, localname, qName, attributes, staticId, effectiveId, xformsControl);\n\n        if (isMustOutputControl(xformsControl)) {\n\n            final ContentHandler contentHandler = handlerContext.getController().getOutput();\n            final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n            if (handlerContext.isNewXHTMLLayout() && isMustOutputContainerElement()) {\n                // Open control element, usually <span>\n                containingElementQName = XMLUtils.buildQName(xhtmlPrefix, getContainingElementName());\n\n                final AttributesImpl containerAttributes = getContainerAttributes(uri, localname, attributes);\n                contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, getContainingElementName(), containingElementQName, containerAttributes);\n            }\n\n            // Get local order for control\n            final String localOrder = attributes.getValue(XFormsConstants.XXFORMS_ORDER_QNAME.getNamespaceURI(),\n                    XFormsConstants.XXFORMS_ORDER_QNAME.getName());\n\n            // Use local or default config\n            final String[] config = (localOrder != null) ? StringUtils.split(localOrder) : handlerContext.getDocumentOrder();\n\n            // Output named anchor if the control has a help or alert. This is so that a separate help and error\n            // sections can link back to the control.\n            if (handlerContext.isNoScript()) {\n                if (xformsControl != null\n                        && (XFormsControl.hasHelp(containingDocument, prefixedId)\n                            || XFormsControl.hasAlert(containingDocument, prefixedId))) {\n                    final String aQName = XMLUtils.buildQName(xhtmlPrefix, \"a\");\n                    reusableAttributes.clear();\n                    reusableAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, xformsControl.getEffectiveId());\n                    contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, \"a\", aQName, reusableAttributes);\n                    contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"a\", aQName);\n                }\n            }\n\n            final boolean isTemplate = handlerContext.isTemplate();\n\n            // Process everything up to and including the control\n            for (int i = 0; i < config.length; i++) {\n                final String current = config[i];\n\n                if (\"control\".equals(current)) {\n                    // Handle control\n                    handleControlStart(uri, localname, qName, attributes, staticId, effectiveId, xformsControl);\n                    // Do the rest in end() below if needed\n                    if (i < config.length - 1) {\n                        // There remains stuff to process\n                        final int endConfigLength = config.length - i;\n                        endConfig = new String[endConfigLength];\n                        System.arraycopy(config, i, endConfig, 0, endConfigLength);\n                        this.attributes = new AttributesImpl(attributes);\n                    }\n                    break;\n                } else if (\"label\".equals(current)) {\n                    // xforms:label\n                    if (hasLocalLabel())\n                        handleLabel(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                } else if (\"alert\".equals(current)) {\n                    // xforms:alert\n                    if (hasLocalAlert())\n                        handleAlert(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                } else if (\"hint\".equals(current)) {\n                    // xforms:hint\n                    if (hasLocalHint())\n                        handleHint(staticId, effectiveId, xformsControl, isTemplate);\n                } else {\n                    // xforms:help\n                    if (hasLocalHelp())\n                        handleHelp(staticId, effectiveId, xformsControl, isTemplate);\n                }\n            }\n        }\n    }","commit_id":"214ea9b24a23d2a644c45a083705d8c249f422a5","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    public void end(String uri, String localname, String qName) throws SAXException {\n        if (isMustOutputControl(xformsControl)) {\n            // Process everything after the control has been shown\n            if (endConfig != null) {\n                final boolean isTemplate = handlerContext.isTemplate();\n\n                for (final String current: endConfig) {\n                    if (\"control\".equals(current)) {\n                        // Handle control\n                        handleControlEnd(uri, localname, qName, attributes, staticId, effectiveId, xformsControl);\n                    } else if (\"label\".equals(current)) {\n                        // xforms:label\n                        if (hasLocalLabel())\n                            handleLabel(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                    } else if (\"alert\".equals(current)) {\n                        // xforms:alert\n                        if (hasLocalAlert())\n                            handleAlert(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                    } else if (\"hint\".equals(current)) {\n                        // xforms:hint\n                        if (hasLocalHint())\n                            handleHint(staticId, effectiveId, xformsControl, isTemplate);\n                    } else {\n                        // xforms:help\n                        if (hasLocalHelp())\n                            handleHelp(staticId, effectiveId, xformsControl, isTemplate);\n                    }\n                }\n            }\n\n            if (handlerContext.isNewXHTMLLayout()) {\n                // Close control <span>\n                final ContentHandler contentHandler = handlerContext.getController().getOutput();\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, \"span\", spanQName);\n            }\n        }\n    }","id":39,"modified_method":"@Override\n    public void end(String uri, String localname, String qName) throws SAXException {\n        if (isMustOutputControl(xformsControl)) {\n            // Process everything after the control has been shown\n            if (endConfig != null) {\n                final boolean isTemplate = handlerContext.isTemplate();\n\n                for (final String current: endConfig) {\n                    if (\"control\".equals(current)) {\n                        // Handle control\n                        handleControlEnd(uri, localname, qName, attributes, staticId, effectiveId, xformsControl);\n                    } else if (\"label\".equals(current)) {\n                        // xforms:label\n                        if (hasLocalLabel())\n                            handleLabel(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                    } else if (\"alert\".equals(current)) {\n                        // xforms:alert\n                        if (hasLocalAlert())\n                            handleAlert(staticId, effectiveId, attributes, xformsControl, isTemplate);\n                    } else if (\"hint\".equals(current)) {\n                        // xforms:hint\n                        if (hasLocalHint())\n                            handleHint(staticId, effectiveId, xformsControl, isTemplate);\n                    } else {\n                        // xforms:help\n                        if (hasLocalHelp())\n                            handleHelp(staticId, effectiveId, xformsControl, isTemplate);\n                    }\n                }\n            }\n\n            if (handlerContext.isNewXHTMLLayout() && isMustOutputContainerElement()) {\n                // Close control element, usually <span>\n                final ContentHandler contentHandler = handlerContext.getController().getOutput();\n                contentHandler.endElement(XMLConstants.XHTML_NAMESPACE_URI, getContainingElementName(), containingElementQName);\n            }\n        }\n    }","commit_id":"214ea9b24a23d2a644c45a083705d8c249f422a5","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final XFormsStaticState staticState = containingDocument.getStaticState();\n\n        // Register control handlers on controller\n        {\n            final ElementHandlerController controller = handlerContext.getController();\n\n            // xforms:input\n            controller.registerHandler(XFormsInputHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"input\");\n\n            // xforms:output\n            controller.registerHandler(XFormsOutputTextHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    return XFormsConstants.XXFORMS_TEXT_APPEARANCE_QNAME.equals(controller.getAttributeQNameValue(attributes.getValue(\"appearance\")));\n                }\n            });\n            controller.registerHandler(XFormsOutputDownloadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    return XFormsConstants.XXFORMS_DOWNLOAD_APPEARANCE_QNAME.equals(getAppearance(attributes));\n                }\n            });\n            controller.registerHandler(XFormsOutputImageHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    final String mediatypeValue = attributes.getValue(\"mediatype\");\n                    return mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n                }\n            });\n            controller.registerHandler(XFormsOutputHTMLHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    final String mediatypeValue = attributes.getValue(\"mediatype\");\n                    return mediatypeValue != null && mediatypeValue.equals(\"text/html\");\n                }\n            });\n            controller.registerHandler(XFormsOutputDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\");\n\n            // xforms:trigger\n            final ElementHandlerController.Matcher triggerSubmitMinimalMatcher = controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    final QName appearance = getAppearance(attributes);\n                    return appearance != null && !handlerContext.isNoScript() // is noscript mode, use the full appearance\n                            && (XFormsConstants.XFORMS_MINIMAL_APPEARANCE_QNAME.equals(appearance)    // minimal appearance\n                                || XFormsConstants.XXFORMS_LINK_APPEARANCE_QNAME.equals(appearance)); // legacy appearance\n                }\n            };\n            controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\", triggerSubmitMinimalMatcher);\n            controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\");\n\n            // xforms:submit\n            controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\", triggerSubmitMinimalMatcher);\n            controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\");\n\n            // Other controls\n            controller.registerHandler(XFormsSecretHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"secret\");\n            controller.registerHandler(XFormsTextareaHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"textarea\");\n            controller.registerHandler(XFormsUploadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"upload\");\n            controller.registerHandler(XFormsRangeHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"range\");\n            \n            controller.registerHandler(XFormsSelectHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\");\n            controller.registerHandler(XFormsSelect1Handler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\");\n\n            controller.registerHandler(XFormsGroupHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\");\n            controller.registerHandler(XFormsSwitchHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\");\n            controller.registerHandler(XFormsCaseHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"case\");\n            controller.registerHandler(XFormsRepeatHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"repeat\");\n\n            controller.registerHandler(XXFormsDialogHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n\n            // Add handlers for LHHA elements\n            if (true) {// TODO: check w/ XFStaticState if there are any standalone LHHA elements\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"label\");\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"help\");\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"hint\");\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"alert\");\n            }\n\n            // Add handlers for custom components\n            final Map<QName, Element> componentBindings = staticState.getXblBindings().getComponentBindings();\n            if (componentBindings != null) {\n                for (final QName currentQName: componentBindings.keySet()) {\n                    controller.registerHandler(XXFormsComponentHandler.class.getName(), currentQName.getNamespaceURI(), currentQName.getName());\n                }\n            }\n        }\n\n        // Add class for YUI skin\n        // TODO: should be configurable somehow\n        attributes = XMLUtils.appendToClassAttribute(attributes, \"yui-skin-sam\");\n\n        // Start xhtml:body\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        contentHandler.startElement(uri, localname, qName, attributes);\n        helper = new ContentHandlerHelper(contentHandler);\n\n        final XFormsControls xformsControls = containingDocument.getControls();\n        final String htmlPrefix = XMLUtils.prefixFromQName(qName);\n\n        // Get formatting prefix and declare it if needed\n        // TODO: would be nice to do this here, but then we need to make sure this prefix is available to other handlers\n//        formattingPrefix = handlerContext.findFormattingPrefixDeclare();\n\n        final String xformsSubmissionPath;\n        {\n            final String requestPath = handlerContext.getExternalContext().getRequest().getRequestPath();\n            final boolean isForwarded = OrbeonXFormsFilter.OPS_RENDERER_PATH.equals(requestPath);\n            if (isForwarded) {\n                // This is the case where the request was forwarded to us (separate deployment)\n                xformsSubmissionPath = \"/xforms-server-submit\";// TODO: read property!\n            } else {\n                // Submission posts to URL of the current page and xforms-xml-submission.xpl intercepts that\n                xformsSubmissionPath = requestPath;\n            }\n        }\n\n        // Noscript panel is included before the xhtml:form element, in case the form is hidden through CSS\n        if (!handlerContext.isNoScript()) {\n            // TODO: must send startPrefixMapping()/endPrefixMapping()?\n            helper.element(\"\", XMLConstants.XINCLUDE_URI, \"include\", new String[] { \"href\", \"oxf:/config/noscript-panel.xml\" });\n        }\n\n        // Create xhtml:form element\n        final boolean hasUpload = staticState.hasControlByName(\"upload\");\n        helper.startElement(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"form\", new String[] {\n                // Add id so that things work in portals    \n                \"id\", XFormsUtils.namespaceId(containingDocument, \"xforms-form\"),\n                // Regular classes\n                \"class\", \"xforms-form\" + (handlerContext.isNoScript() ? \" xforms-noscript\" : \" xforms-initially-hidden\"),\n                // Submission parameters\n                \"action\", xformsSubmissionPath, \"method\", \"POST\",\n                // In noscript mode, don't add event handler\n                \"onsubmit\", handlerContext.isNoScript() ? null : \"return false\",\n                hasUpload ? \"enctype\" : null, hasUpload ? \"multipart/form-data\" : null});\n\n        {\n            // Output encoded static and dynamic state\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[] {\n                    \"type\", \"hidden\", \"name\", \"$static-state\", \"value\", handlerContext.getEncodedClientState().getStaticState()\n            });\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$dynamic-state\", \"value\", handlerContext.getEncodedClientState().getDynamicState()\n            });\n        }\n\n        if (!handlerContext.isNoScript()) {\n            // Other fields used by JavaScript\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$server-events\", \"value\", \"\"\n            });\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$client-state\", \"value\", \"\"\n            });\n\n            // Store information about nested repeats hierarchy\n            {\n                helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                        \"type\", \"hidden\", \"name\", \"$repeat-tree\", \"value\", staticState.getRepeatHierarchyString()\n                });\n            }\n\n            // Store information about the initial index of each repeat\n            {\n                final StringBuffer repeatIndexesStringBuffer = new StringBuffer();\n                final Map<String, Integer> repeatIdToIndex = xformsControls.getCurrentControlTree().getMinimalRepeatIdToIndex(staticState);\n                if (repeatIdToIndex.size() != 0) {\n                    for (final Map.Entry<String, Integer> currentEntry: repeatIdToIndex.entrySet()) {\n                        final String repeatId = currentEntry.getKey();\n                        final Integer index = currentEntry.getValue();\n\n                        if (repeatIndexesStringBuffer.length() > 0)\n                            repeatIndexesStringBuffer.append(',');\n\n                        repeatIndexesStringBuffer.append(repeatId);\n                        repeatIndexesStringBuffer.append(' ');\n                        repeatIndexesStringBuffer.append(index);\n                    }\n                }\n\n                helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                        \"type\", \"hidden\", \"name\", \"$repeat-indexes\", \"value\", repeatIndexesStringBuffer.toString()\n                });\n            }\n\n            // Ajax loading indicator\n            if (XFormsProperties.isAjaxShowLoadingIcon(containingDocument)) {\n\n                helper.startElement(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"span\", new String[]{ \"class\", \"xforms-loading-loading\" });\n                helper.text(\"Loading...\"); // text is hardcoded, but you can rewrite it in the theme if needed\n                helper.endElement();\n\n                helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"span\", new String[]{ \"class\", \"xforms-loading-none\" });\n            }\n\n            // Ajax error panel\n            if (XFormsProperties.isAjaxShowErrors(containingDocument)) {\n                // XInclude dialog so users can configure it\n                // TODO: must send startPrefixMapping()/endPrefixMapping()?\n                helper.element(\"\", XMLConstants.XINCLUDE_URI, \"include\", new String[] { \"href\", \"oxf:/config/error-dialog.xml\" });\n            }\n\n            // Help panel\n            // TODO: must send startPrefixMapping()/endPrefixMapping()?\n            helper.element(\"\", XMLConstants.XINCLUDE_URI, \"include\", new String[] { \"href\", \"oxf:/config/help-panel.xml\" });\n\n            // Templates\n            {\n                final String spanQName = XMLUtils.buildQName(htmlPrefix, \"span\");\n                final String TEMPLATE_ID = \"$xforms-effective-id$\";\n\n                // HACK: We would be ok with just one template, but IE 6 doesn't allow setting the input/@type attribute properly\n\n                // xforms:select[@appearance = 'full'], xforms:input[@type = 'xs:boolean']\n                XFormsSelect1Handler.outputItemFullTemplate(pipelineContext, handlerContext, contentHandler, htmlPrefix, spanQName,\n                        containingDocument, reusableAttributes, attributes,\n                        \"xforms-select-full-template\", TEMPLATE_ID, TEMPLATE_ID, true, \"checkbox\");\n\n                // xforms:select1[@appearance = 'full']\n                XFormsSelect1Handler.outputItemFullTemplate(pipelineContext, handlerContext, contentHandler, htmlPrefix, spanQName,\n                        containingDocument, reusableAttributes, attributes,\n                        \"xforms-select1-full-template\", TEMPLATE_ID, TEMPLATE_ID, true, \"radio\");\n            }\n\n        } else {\n            // Noscript mode\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$noscript\", \"value\", \"true\"\n            });\n        }\n    }","id":40,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final XFormsStaticState staticState = containingDocument.getStaticState();\n\n        // Register control handlers on controller\n        {\n            final ElementHandlerController controller = handlerContext.getController();\n\n            // xforms:input\n            controller.registerHandler(XFormsInputHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"input\");\n\n            // xforms:output\n            controller.registerHandler(XFormsOutputTextHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    return XFormsConstants.XXFORMS_TEXT_APPEARANCE_QNAME.equals(controller.getAttributeQNameValue(attributes.getValue(\"appearance\")));\n                }\n            });\n            controller.registerHandler(XFormsOutputDownloadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    return XFormsConstants.XXFORMS_DOWNLOAD_APPEARANCE_QNAME.equals(getAppearance(attributes));\n                }\n            });\n            controller.registerHandler(XFormsOutputImageHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    final String mediatypeValue = attributes.getValue(\"mediatype\");\n                    return mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n                }\n            });\n            controller.registerHandler(XFormsOutputHTMLHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    final String mediatypeValue = attributes.getValue(\"mediatype\");\n                    return mediatypeValue != null && mediatypeValue.equals(\"text/html\");\n                }\n            });\n            controller.registerHandler(XFormsOutputDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\");\n\n            // xforms:trigger\n            final ElementHandlerController.Matcher triggerSubmitMinimalMatcher = controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    final QName appearance = getAppearance(attributes);\n                    return appearance != null && !handlerContext.isNoScript() // is noscript mode, use the full appearance\n                            && (XFormsConstants.XFORMS_MINIMAL_APPEARANCE_QNAME.equals(appearance)    // minimal appearance\n                                || XFormsConstants.XXFORMS_LINK_APPEARANCE_QNAME.equals(appearance)); // legacy appearance\n                }\n            };\n            controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\", triggerSubmitMinimalMatcher);\n            controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\");\n\n            // xforms:submit\n            controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\", triggerSubmitMinimalMatcher);\n            controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\");\n\n            // xforms:group\n            controller.registerHandler(XFormsGroupInternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n                }\n            });\n            controller.registerHandler(XFormsGroupFieldsetHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n                public boolean match(Attributes attributes) {\n                    return XFormsConstants.XXFORMS_FIELDSET_APPEARANCE_QNAME.equals(getAppearance(attributes));\n                }\n            });\n            controller.registerHandler(XFormsGroupDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\");\n\n            // Other controls\n            controller.registerHandler(XFormsSecretHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"secret\");\n            controller.registerHandler(XFormsTextareaHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"textarea\");\n            controller.registerHandler(XFormsUploadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"upload\");\n            controller.registerHandler(XFormsRangeHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"range\");\n            \n            controller.registerHandler(XFormsSelectHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\");\n            controller.registerHandler(XFormsSelect1Handler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\");\n\n            controller.registerHandler(XFormsSwitchHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\");\n            controller.registerHandler(XFormsCaseHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"case\");\n            controller.registerHandler(XFormsRepeatHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"repeat\");\n\n            controller.registerHandler(XXFormsDialogHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n\n            // Add handlers for LHHA elements\n//            if (true) {// TODO: check w/ XFStaticState if there are any standalone LHHA elements\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"label\");\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"help\");\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"hint\");\n                controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"alert\");\n//            }\n\n            // Add handlers for custom components\n            final Map<QName, Element> componentBindings = staticState.getXblBindings().getComponentBindings();\n            if (componentBindings != null) {\n                for (final QName currentQName: componentBindings.keySet()) {\n                    controller.registerHandler(XXFormsComponentHandler.class.getName(), currentQName.getNamespaceURI(), currentQName.getName());\n                }\n            }\n        }\n\n        // Add class for YUI skin\n        // TODO: should be configurable somehow\n        attributes = XMLUtils.appendToClassAttribute(attributes, \"yui-skin-sam\");\n\n        // Start xhtml:body\n        final ContentHandler contentHandler = handlerContext.getController().getOutput();\n        contentHandler.startElement(uri, localname, qName, attributes);\n        helper = new ContentHandlerHelper(contentHandler);\n\n        final XFormsControls xformsControls = containingDocument.getControls();\n        final String htmlPrefix = XMLUtils.prefixFromQName(qName);\n\n        // Get formatting prefix and declare it if needed\n        // TODO: would be nice to do this here, but then we need to make sure this prefix is available to other handlers\n//        formattingPrefix = handlerContext.findFormattingPrefixDeclare();\n\n        final String xformsSubmissionPath;\n        {\n            final String requestPath = handlerContext.getExternalContext().getRequest().getRequestPath();\n            final boolean isForwarded = OrbeonXFormsFilter.OPS_RENDERER_PATH.equals(requestPath);\n            if (isForwarded) {\n                // This is the case where the request was forwarded to us (separate deployment)\n                xformsSubmissionPath = \"/xforms-server-submit\";// TODO: read property!\n            } else {\n                // Submission posts to URL of the current page and xforms-xml-submission.xpl intercepts that\n                xformsSubmissionPath = requestPath;\n            }\n        }\n\n        // Noscript panel is included before the xhtml:form element, in case the form is hidden through CSS\n        if (!handlerContext.isNoScript()) {\n            // TODO: must send startPrefixMapping()/endPrefixMapping()?\n            helper.element(\"\", XMLConstants.XINCLUDE_URI, \"include\", new String[] { \"href\", \"oxf:/config/noscript-panel.xml\" });\n        }\n\n        // Create xhtml:form element\n        final boolean hasUpload = staticState.hasControlByName(\"upload\");\n        helper.startElement(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"form\", new String[] {\n                // Add id so that things work in portals    \n                \"id\", XFormsUtils.namespaceId(containingDocument, \"xforms-form\"),\n                // Regular classes\n                \"class\", \"xforms-form\" + (handlerContext.isNoScript() ? \" xforms-noscript\" : \" xforms-initially-hidden\"),\n                // Submission parameters\n                \"action\", xformsSubmissionPath, \"method\", \"POST\",\n                // In noscript mode, don't add event handler\n                \"onsubmit\", handlerContext.isNoScript() ? null : \"return false\",\n                hasUpload ? \"enctype\" : null, hasUpload ? \"multipart/form-data\" : null});\n\n        {\n            // Output encoded static and dynamic state\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[] {\n                    \"type\", \"hidden\", \"name\", \"$static-state\", \"value\", handlerContext.getEncodedClientState().getStaticState()\n            });\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$dynamic-state\", \"value\", handlerContext.getEncodedClientState().getDynamicState()\n            });\n        }\n\n        if (!handlerContext.isNoScript()) {\n            // Other fields used by JavaScript\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$server-events\", \"value\", \"\"\n            });\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$client-state\", \"value\", \"\"\n            });\n\n            // Store information about nested repeats hierarchy\n            {\n                helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                        \"type\", \"hidden\", \"name\", \"$repeat-tree\", \"value\", staticState.getRepeatHierarchyString()\n                });\n            }\n\n            // Store information about the initial index of each repeat\n            {\n                final StringBuffer repeatIndexesStringBuffer = new StringBuffer();\n                final Map<String, Integer> repeatIdToIndex = xformsControls.getCurrentControlTree().getMinimalRepeatIdToIndex(staticState);\n                if (repeatIdToIndex.size() != 0) {\n                    for (final Map.Entry<String, Integer> currentEntry: repeatIdToIndex.entrySet()) {\n                        final String repeatId = currentEntry.getKey();\n                        final Integer index = currentEntry.getValue();\n\n                        if (repeatIndexesStringBuffer.length() > 0)\n                            repeatIndexesStringBuffer.append(',');\n\n                        repeatIndexesStringBuffer.append(repeatId);\n                        repeatIndexesStringBuffer.append(' ');\n                        repeatIndexesStringBuffer.append(index);\n                    }\n                }\n\n                helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                        \"type\", \"hidden\", \"name\", \"$repeat-indexes\", \"value\", repeatIndexesStringBuffer.toString()\n                });\n            }\n\n            // Ajax loading indicator\n            if (XFormsProperties.isAjaxShowLoadingIcon(containingDocument)) {\n\n                helper.startElement(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"span\", new String[]{ \"class\", \"xforms-loading-loading\" });\n                helper.text(\"Loading...\"); // text is hardcoded, but you can rewrite it in the theme if needed\n                helper.endElement();\n\n                helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"span\", new String[]{ \"class\", \"xforms-loading-none\" });\n            }\n\n            // Ajax error panel\n            if (XFormsProperties.isAjaxShowErrors(containingDocument)) {\n                // XInclude dialog so users can configure it\n                // TODO: must send startPrefixMapping()/endPrefixMapping()?\n                helper.element(\"\", XMLConstants.XINCLUDE_URI, \"include\", new String[] { \"href\", \"oxf:/config/error-dialog.xml\" });\n            }\n\n            // Help panel\n            // TODO: must send startPrefixMapping()/endPrefixMapping()?\n            helper.element(\"\", XMLConstants.XINCLUDE_URI, \"include\", new String[] { \"href\", \"oxf:/config/help-panel.xml\" });\n\n            // Templates\n            {\n                final String spanQName = XMLUtils.buildQName(htmlPrefix, \"span\");\n                final String TEMPLATE_ID = \"$xforms-effective-id$\";\n\n                // HACK: We would be ok with just one template, but IE 6 doesn't allow setting the input/@type attribute properly\n\n                // xforms:select[@appearance = 'full'], xforms:input[@type = 'xs:boolean']\n                XFormsSelect1Handler.outputItemFullTemplate(pipelineContext, handlerContext, contentHandler, htmlPrefix, spanQName,\n                        containingDocument, reusableAttributes, attributes,\n                        \"xforms-select-full-template\", TEMPLATE_ID, TEMPLATE_ID, true, \"checkbox\");\n\n                // xforms:select1[@appearance = 'full']\n                XFormsSelect1Handler.outputItemFullTemplate(pipelineContext, handlerContext, contentHandler, htmlPrefix, spanQName,\n                        containingDocument, reusableAttributes, attributes,\n                        \"xforms-select1-full-template\", TEMPLATE_ID, TEMPLATE_ID, true, \"radio\");\n            }\n\n        } else {\n            // Noscript mode\n            helper.element(htmlPrefix, XMLConstants.XHTML_NAMESPACE_URI, \"input\", new String[]{\n                    \"type\", \"hidden\", \"name\", \"$noscript\", \"value\", \"true\"\n            });\n        }\n    }","commit_id":"214ea9b24a23d2a644c45a083705d8c249f422a5","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        namespaceSupport.startElement();\n\n        if (XMLConstants.XHTML_NAMESPACE_URI.equals(uri))\n            xhtmlElementLocalnames.add(localname);\n\n        // Check for XForms or extension namespaces\n        final boolean isXForms = XFormsConstants.XFORMS_NAMESPACE_URI.equals(uri);\n        final boolean isXXForms = XFormsConstants.XXFORMS_NAMESPACE_URI.equals(uri);\n        final boolean isEXForms = XFormsConstants.EXFORMS_NAMESPACE_URI.equals(uri);\n        final boolean isXFormsOrExtension = isXForms || isXXForms || isEXForms;\n\n        final boolean isXBL = XFormsConstants.XBL_NAMESPACE_URI.equals(uri);\n\n        final int idIndex = attributes.getIndex(\"id\");\n\n        // Entering model or controls\n        if (!inXForms && isXFormsOrExtension) {\n            inXForms = true;\n            xformsLevel = level;\n        }\n\n        if (inPreserve) {\n            // Within preserved content\n\n\n            if (inLHHA) {\n                // Gather id and namespace information about content of LHHA\n                if (isXForms) {\n                    // Must be xforms:output\n                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                } else if (hostLanguageAVTs && hasAVT(attributes)) {\n                    // Must be an AVT on an host language element\n                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                }\n            } else if (inXBL && level - 1 == preserveLevel && isXBL && \"binding\".equals(localname)) {\n                // Gather binding information in xbl:xbl/xbl:binding\n                final String elementAttribute = attributes.getValue(\"element\");\n                if (elementAttribute != null) {\n                    storeXBLBinding(elementAttribute);\n                }\n                // Gather id and namespace information\n                attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n            }\n            // Output element\n            startElement(true, uri, localname, qName, attributes);\n        } else if (isXFormsOrExtension) {\n            // This is an XForms element\n\n            // TODO: can we restrain gathering ids / namespaces to only certain elements (all controls + elements with XPath expressions + models + instances)?\n\n            // Create a new id and update the attributes if needed\n            attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n\n            // Handle full update annotation\n            if (isXXForms && localname.equals(\"dynamic\")) {\n                // Remember this subtree has a full update\n                addMark(reusableStringArray[0], templateSAXStore.getElementMark());\n                // Add a class to help the client\n                attributes = XMLUtils.appendToClassAttribute(attributes, \"xforms-update-full\");\n            } else if (templateSAXStore != null && Version.isPE()) {\n                // Remember mark if xxforms:update=\"full\"\n                final String xxformsUpdate = attributes.getValue(XFormsConstants.XXFORMS_UPDATE_QNAME.getNamespaceURI(), XFormsConstants.XXFORMS_UPDATE_QNAME.getName());\n                if (XFormsConstants.XFORMS_FULL_UPDATE.equals(xxformsUpdate)) {\n                    // Remember this subtree has a full update\n                    addMark(reusableStringArray[0], templateSAXStore.getElementMark());\n                    // Add a class to help the client\n                    attributes = XMLUtils.appendToClassAttribute(attributes, \"xforms-update-full\");\n                }\n            }\n\n            // Rewrite elements / add appearances\n            if (inTitle && \"output\".equals(localname)) {\n                // Special case of xforms:output within title, which produces an xxforms:text control\n                attributes = XMLUtils.addOrReplaceAttribute(attributes, \"\", \"\", \"for\", htmlTitleElementId);\n                startPrefixMapping(true, \"xxforms\", XFormsConstants.XXFORMS_NAMESPACE_URI);\n                startElement(true, XFormsConstants.XXFORMS_NAMESPACE_URI, \"text\", \"xxforms:text\", attributes);\n            } else if (\"group\".equals(localname) && isClosestXHTMLAncestorTableContainer()) {\n                // Closest xhtml:* ancestor is xhtml:table|xhtml:tbody|xhtml:thead|xhtml:tfoot|xhtml:tr\n                attributes = XMLUtils.addOrReplaceAttribute(attributes, \"\", \"\", XFormsConstants.APPEARANCE_QNAME.getName(), XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName());\n                startElement(true, uri, localname, qName, attributes);\n            } else {\n                // Leave element untouched (except for the id attribute)\n                startElement(true, uri, localname, qName, attributes);\n            }\n        } else if (!isXBL && metadata.isXBLBindingCheckAutomaticBindings(uri, localname)) {\n            // Element with a binding\n\n            // Create a new id and update the attributes if needed\n            attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n\n            // Leave element untouched (except for the id attribute)\n            startElement(true, uri, localname, qName, attributes);\n\n            // Don't handle the content\n            inPreserve = true;\n            preserveLevel = level;\n\n        } else if (isXBL) {\n            // This must be xbl:xbl (otherwise we will have isPreserve == true) or xbl:template\n            assert localname.equals(\"xbl\") || localname.equals(\"template\") || localname.equals(\"handler\");\n            // NOTE: Still process attributes, because the annotator is used to process top-level <xbl:handler> as well.\n            attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n            startElement(true, uri, localname, qName, attributes);\n        } else {\n            // Non-XForms element without an XBL binding\n\n            String htmlElementId = null;\n\n            if (level == 1) {\n                if (\"head\".equals(localname)) {\n                    // Entering head\n                    inHead = true;\n                }\n            } else if (level == 2) {\n                if (inHead && \"title\".equals(localname)) {\n                    // Entering title\n                    inTitle = true;\n                    // Make sure there will be an id on the title element (ideally, we would do this only if there is a nested xforms:output)\n                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                    htmlElementId = reusableStringArray[0];\n                    htmlTitleElementId = htmlElementId;\n                }\n            }\n\n            // NOTE: @id attributes on XHTML elements are rewritten with their effective id during XHTML output by\n            // XHTMLElementHandler.\n            if (\"true\".equals(attributes.getValue(XFormsConstants.XXFORMS_NAMESPACE_URI, \"control\"))) {\n                // Non-XForms element which we want to turn into a control (specifically, into a group)\n\n                // Create a new xforms:group control which specifies the element name to use. Namespace mappings for the\n                // given QName must be in scope as that QName is the original element name.\n                final AttributesImpl newAttributes = new AttributesImpl(getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex));\n                newAttributes.addAttribute(XFormsConstants.XXFORMS_NAMESPACE_URI, \"element\", \"xxforms:element\", ContentHandlerHelper.CDATA, qName);\n\n                startPrefixMapping(true, \"xxforms\", XFormsConstants.XXFORMS_NAMESPACE_URI);\n                startElement(true, XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", \"xforms:group\", newAttributes);\n            } else if (hostLanguageAVTs) {\n                // This is a non-XForms element and we allow AVTs\n                final int attributesCount = attributes.getLength();\n                if (attributesCount > 0) {\n                    boolean elementOutput = false;\n                    for (int i = 0; i < attributesCount; i++) {\n                        final String currentAttributeURI = attributes.getURI(i);\n                        if (\"\".equals(currentAttributeURI) || XMLConstants.XML_URI.equals(currentAttributeURI)) {\n                            // For now we only support AVTs on attributes in no namespace or in the XML namespace (for xml:lang)\n                            final String attributeValue = attributes.getValue(i);\n                            if (XFormsUtils.maybeAVT(attributeValue)) {\n                                // This is an AVT\n                                final String attributeName = attributes.getQName(i);// use qualified name for xml:lang\n\n                                // Create a new id and update the attributes if needed\n                                if (htmlElementId == null) {\n                                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                                    htmlElementId = reusableStringArray[0];\n\n                                    // TODO: Clear all attributes having AVTs or XPath expressions will end up in repeat templates.\n                                }\n\n                                if (!elementOutput) {\n                                    // Output the element with the new or updated id attribute\n                                    startElement(true, uri, localname, qName, attributes);\n                                    elementOutput = true;\n                                }\n\n                                // Create a new xxforms:attribute control\n                                reusableAttributes.clear();\n\n                                final AttributesImpl newAttributes = (AttributesImpl) getAttributesGatherNamespaces(qName, reusableAttributes, reusableStringArray, -1);\n\n                                newAttributes.addAttribute(\"\", \"for\", \"for\", ContentHandlerHelper.CDATA, htmlElementId);\n                                newAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, attributeName);\n                                newAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, attributeValue);\n\n                                newAttributes.addAttribute(\"\", \"for-name\", \"for-name\", ContentHandlerHelper.CDATA, localname);\n\n                                // These extra attributes can be used alongside src/href attributes\n                                if (\"src\".equals(attributeName) || \"href\".equals(attributeName)) {\n                                    final String urlType = attributes.getValue(XMLConstants.OPS_FORMATTING_URI, \"url-type\");\n                                    final String portletMode = attributes.getValue(XMLConstants.OPS_FORMATTING_URI, \"portlet-mode\");\n                                    final String windowState = attributes.getValue(XMLConstants.OPS_FORMATTING_URI, \"window-state\");\n\n                                    if (urlType != null)\n                                        newAttributes.addAttribute(\"\", \"url-type\", \"url-type\", ContentHandlerHelper.CDATA, urlType);\n                                    if (portletMode != null)\n                                        newAttributes.addAttribute(\"\", \"portlet-mode\", \"portlet-mode\", ContentHandlerHelper.CDATA, \"portlet-mode\");\n                                    if (windowState != null)\n                                        newAttributes.addAttribute(\"\", \"window-state\", \"window-state\", ContentHandlerHelper.CDATA, \"window-state\");\n                                }\n\n                                startPrefixMapping(true, \"xxforms\", XFormsConstants.XXFORMS_NAMESPACE_URI);\n                                startElement(true, XFormsConstants.XXFORMS_NAMESPACE_URI, \"attribute\", \"xxforms:attribute\", newAttributes);\n                                endElement(true, XFormsConstants.XXFORMS_NAMESPACE_URI, \"attribute\", \"xxforms:attribute\");\n                                endPrefixMapping(true, \"xxforms\");\n                            }\n                        }\n                    }\n\n                    // Output the element as is if no AVT was found\n                    if (!elementOutput)\n                        startElement(true, uri, localname, qName, attributes);\n                } else {\n                    startElement(true, uri, localname, qName, attributes);\n                }\n\n            } else {\n                // No AVT handling, just output the element\n                startElement(true, uri, localname, qName, attributes);\n            }\n        }\n\n        // Check for preserved content\n        if (!inPreserve) {\n            if (inXForms) {\n                // Preserve as is the content of labels, etc., instances, and schemas\n                // Within other XForms: check for labels, xforms:instance, and xs:schema\n                if (isXForms) {\n                    inLHHA = XFormsConstants.LABEL_HINT_HELP_ALERT_ELEMENT.contains(localname); // labels, etc. may contain XHTML\n                    if (inLHHA || \"instance\".equals(localname)) {                                  // xforms:instance\n                        inPreserve = true;\n                        preserveLevel = level;\n                    }\n                } else if (\"schema\".equals(localname) && XMLConstants.XSD_URI.equals(uri)) {       // xs:schema\n                    inPreserve = true;\n                    preserveLevel = level;\n\n                }\n            } else {\n                // At the top-level: check for labels and xbl:xbl\n                final boolean isXBLXBL = isXBL && \"xbl\".equals(localname);\n                if (isXForms) {\n                    inLHHA = XFormsConstants.LABEL_HINT_HELP_ALERT_ELEMENT.contains(localname); // labels, etc. may contain XHTML\n                    if (inLHHA) {\n                        inPreserve = true;\n                        preserveLevel = level;\n                    }\n                } else if (isXBLXBL) {// xbl:xbl\n                    inPreserve = true;\n                    preserveLevel = level;\n                    inXBL = true;\n                }\n            }\n        }\n\n        level++;\n    }","id":41,"modified_method":"@Override\n    public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        namespaceSupport.startElement();\n\n        if (XMLConstants.XHTML_NAMESPACE_URI.equals(uri))\n            xhtmlElementLocalnames.add(localname);\n\n        // Check for XForms or extension namespaces\n        final boolean isXForms = XFormsConstants.XFORMS_NAMESPACE_URI.equals(uri);\n        final boolean isXXForms = XFormsConstants.XXFORMS_NAMESPACE_URI.equals(uri);\n        final boolean isEXForms = XFormsConstants.EXFORMS_NAMESPACE_URI.equals(uri);\n        final boolean isXFormsOrExtension = isXForms || isXXForms || isEXForms;\n\n        final boolean isXBL = XFormsConstants.XBL_NAMESPACE_URI.equals(uri);\n\n        final int idIndex = attributes.getIndex(\"id\");\n\n        // Entering model or controls\n        if (!inXForms && isXFormsOrExtension) {\n            inXForms = true;\n            xformsLevel = level;\n        }\n\n        if (inPreserve) {\n            // Within preserved content\n\n\n            if (inLHHA) {\n                // Gather id and namespace information about content of LHHA\n                if (isXForms) {\n                    // Must be xforms:output\n                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                } else if (hostLanguageAVTs && hasAVT(attributes)) {\n                    // Must be an AVT on an host language element\n                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                }\n            } else if (inXBL && level - 1 == preserveLevel && isXBL && \"binding\".equals(localname)) {\n                // Gather binding information in xbl:xbl/xbl:binding\n                final String elementAttribute = attributes.getValue(\"element\");\n                if (elementAttribute != null) {\n                    storeXBLBinding(elementAttribute);\n                }\n                // Gather id and namespace information\n                attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n            }\n            // Output element\n            startElement(true, uri, localname, qName, attributes);\n        } else if (isXFormsOrExtension) {\n            // This is an XForms element\n\n            // TODO: can we restrain gathering ids / namespaces to only certain elements (all controls + elements with XPath expressions + models + instances)?\n\n            // Create a new id and update the attributes if needed\n            attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n\n            // Handle full update annotation\n            if (isXXForms && localname.equals(\"dynamic\")) {\n                // Remember this subtree has a full update\n                addMark(reusableStringArray[0], templateSAXStore.getElementMark());\n                // Add a class to help the client\n                attributes = XMLUtils.appendToClassAttribute(attributes, \"xforms-update-full\");\n            } else if (templateSAXStore != null && Version.isPE()) {\n                // Remember mark if xxforms:update=\"full\"\n                final String xxformsUpdate = attributes.getValue(XFormsConstants.XXFORMS_UPDATE_QNAME.getNamespaceURI(), XFormsConstants.XXFORMS_UPDATE_QNAME.getName());\n                if (XFormsConstants.XFORMS_FULL_UPDATE.equals(xxformsUpdate)) {\n                    // Remember this subtree has a full update\n                    addMark(reusableStringArray[0], templateSAXStore.getElementMark());\n                    // Add a class to help the client\n                    attributes = XMLUtils.appendToClassAttribute(attributes, \"xforms-update-full\");\n                }\n            }\n\n            // Rewrite elements / add appearances\n            if (inTitle && \"output\".equals(localname)) {\n                // Special case of xforms:output within title, which produces an xxforms:text control\n                attributes = XMLUtils.addOrReplaceAttribute(attributes, \"\", \"\", \"for\", htmlTitleElementId);\n                startPrefixMapping(true, \"xxforms\", XFormsConstants.XXFORMS_NAMESPACE_URI);\n                startElement(true, XFormsConstants.XXFORMS_NAMESPACE_URI, \"text\", \"xxforms:text\", attributes);\n            } else if ((\"group\".equals(localname) || \"switch\".equals(localname)) && isClosestXHTMLAncestorTableContainer()) {\n                // Closest xhtml:* ancestor is xhtml:table|xhtml:tbody|xhtml:thead|xhtml:tfoot|xhtml:tr\n                attributes = XMLUtils.addOrReplaceAttribute(attributes, \"\", \"\", XFormsConstants.APPEARANCE_QNAME.getName(), XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName());\n                startElement(true, uri, localname, qName, attributes);\n            } else {\n                // Leave element untouched (except for the id attribute)\n                startElement(true, uri, localname, qName, attributes);\n            }\n        } else if (!isXBL && metadata.isXBLBindingCheckAutomaticBindings(uri, localname)) {\n            // Element with a binding\n\n            // Create a new id and update the attributes if needed\n            attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n\n            // Leave element untouched (except for the id attribute)\n            startElement(true, uri, localname, qName, attributes);\n\n            // Don't handle the content\n            inPreserve = true;\n            preserveLevel = level;\n\n        } else if (isXBL) {\n            // This must be xbl:xbl (otherwise we will have isPreserve == true) or xbl:template\n            assert localname.equals(\"xbl\") || localname.equals(\"template\") || localname.equals(\"handler\");\n            // NOTE: Still process attributes, because the annotator is used to process top-level <xbl:handler> as well.\n            attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n            startElement(true, uri, localname, qName, attributes);\n        } else {\n            // Non-XForms element without an XBL binding\n\n            String htmlElementId = null;\n\n            if (level == 1) {\n                if (\"head\".equals(localname)) {\n                    // Entering head\n                    inHead = true;\n                }\n            } else if (level == 2) {\n                if (inHead && \"title\".equals(localname)) {\n                    // Entering title\n                    inTitle = true;\n                    // Make sure there will be an id on the title element (ideally, we would do this only if there is a nested xforms:output)\n                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                    htmlElementId = reusableStringArray[0];\n                    htmlTitleElementId = htmlElementId;\n                }\n            }\n\n            // NOTE: @id attributes on XHTML elements are rewritten with their effective id during XHTML output by\n            // XHTMLElementHandler.\n            if (\"true\".equals(attributes.getValue(XFormsConstants.XXFORMS_NAMESPACE_URI, \"control\"))) {\n                // Non-XForms element which we want to turn into a control (specifically, into a group)\n\n                // Create a new xforms:group control which specifies the element name to use. Namespace mappings for the\n                // given QName must be in scope as that QName is the original element name.\n                final AttributesImpl newAttributes = new AttributesImpl(getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex));\n                newAttributes.addAttribute(XFormsConstants.XXFORMS_NAMESPACE_URI, \"element\", \"xxforms:element\", ContentHandlerHelper.CDATA, qName);\n\n                startPrefixMapping(true, \"xxforms\", XFormsConstants.XXFORMS_NAMESPACE_URI);\n                startElement(true, XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", \"xforms:group\", newAttributes);\n            } else if (hostLanguageAVTs) {\n                // This is a non-XForms element and we allow AVTs\n                final int attributesCount = attributes.getLength();\n                if (attributesCount > 0) {\n                    boolean elementOutput = false;\n                    for (int i = 0; i < attributesCount; i++) {\n                        final String currentAttributeURI = attributes.getURI(i);\n                        if (\"\".equals(currentAttributeURI) || XMLConstants.XML_URI.equals(currentAttributeURI)) {\n                            // For now we only support AVTs on attributes in no namespace or in the XML namespace (for xml:lang)\n                            final String attributeValue = attributes.getValue(i);\n                            if (XFormsUtils.maybeAVT(attributeValue)) {\n                                // This is an AVT\n                                final String attributeName = attributes.getQName(i);// use qualified name for xml:lang\n\n                                // Create a new id and update the attributes if needed\n                                if (htmlElementId == null) {\n                                    attributes = getAttributesGatherNamespaces(qName, attributes, reusableStringArray, idIndex);\n                                    htmlElementId = reusableStringArray[0];\n\n                                    // TODO: Clear all attributes having AVTs or XPath expressions will end up in repeat templates.\n                                }\n\n                                if (!elementOutput) {\n                                    // Output the element with the new or updated id attribute\n                                    startElement(true, uri, localname, qName, attributes);\n                                    elementOutput = true;\n                                }\n\n                                // Create a new xxforms:attribute control\n                                reusableAttributes.clear();\n\n                                final AttributesImpl newAttributes = (AttributesImpl) getAttributesGatherNamespaces(qName, reusableAttributes, reusableStringArray, -1);\n\n                                newAttributes.addAttribute(\"\", \"for\", \"for\", ContentHandlerHelper.CDATA, htmlElementId);\n                                newAttributes.addAttribute(\"\", \"name\", \"name\", ContentHandlerHelper.CDATA, attributeName);\n                                newAttributes.addAttribute(\"\", \"value\", \"value\", ContentHandlerHelper.CDATA, attributeValue);\n\n                                newAttributes.addAttribute(\"\", \"for-name\", \"for-name\", ContentHandlerHelper.CDATA, localname);\n\n                                // These extra attributes can be used alongside src/href attributes\n                                if (\"src\".equals(attributeName) || \"href\".equals(attributeName)) {\n                                    final String urlType = attributes.getValue(XMLConstants.OPS_FORMATTING_URI, \"url-type\");\n                                    final String portletMode = attributes.getValue(XMLConstants.OPS_FORMATTING_URI, \"portlet-mode\");\n                                    final String windowState = attributes.getValue(XMLConstants.OPS_FORMATTING_URI, \"window-state\");\n\n                                    if (urlType != null)\n                                        newAttributes.addAttribute(\"\", \"url-type\", \"url-type\", ContentHandlerHelper.CDATA, urlType);\n                                    if (portletMode != null)\n                                        newAttributes.addAttribute(\"\", \"portlet-mode\", \"portlet-mode\", ContentHandlerHelper.CDATA, \"portlet-mode\");\n                                    if (windowState != null)\n                                        newAttributes.addAttribute(\"\", \"window-state\", \"window-state\", ContentHandlerHelper.CDATA, \"window-state\");\n                                }\n\n                                startPrefixMapping(true, \"xxforms\", XFormsConstants.XXFORMS_NAMESPACE_URI);\n                                startElement(true, XFormsConstants.XXFORMS_NAMESPACE_URI, \"attribute\", \"xxforms:attribute\", newAttributes);\n                                endElement(true, XFormsConstants.XXFORMS_NAMESPACE_URI, \"attribute\", \"xxforms:attribute\");\n                                endPrefixMapping(true, \"xxforms\");\n                            }\n                        }\n                    }\n\n                    // Output the element as is if no AVT was found\n                    if (!elementOutput)\n                        startElement(true, uri, localname, qName, attributes);\n                } else {\n                    startElement(true, uri, localname, qName, attributes);\n                }\n\n            } else {\n                // No AVT handling, just output the element\n                startElement(true, uri, localname, qName, attributes);\n            }\n        }\n\n        // Check for preserved content\n        if (!inPreserve) {\n            if (inXForms) {\n                // Preserve as is the content of labels, etc., instances, and schemas\n                // Within other XForms: check for labels, xforms:instance, and xs:schema\n                if (isXForms) {\n                    inLHHA = XFormsConstants.LABEL_HINT_HELP_ALERT_ELEMENT.contains(localname); // labels, etc. may contain XHTML\n                    if (inLHHA || \"instance\".equals(localname)) {                                  // xforms:instance\n                        inPreserve = true;\n                        preserveLevel = level;\n                    }\n                } else if (\"schema\".equals(localname) && XMLConstants.XSD_URI.equals(uri)) {       // xs:schema\n                    inPreserve = true;\n                    preserveLevel = level;\n\n                }\n            } else {\n                // At the top-level: check for labels and xbl:xbl\n                final boolean isXBLXBL = isXBL && \"xbl\".equals(localname);\n                if (isXForms) {\n                    inLHHA = XFormsConstants.LABEL_HINT_HELP_ALERT_ELEMENT.contains(localname); // labels, etc. may contain XHTML\n                    if (inLHHA) {\n                        inPreserve = true;\n                        preserveLevel = level;\n                    }\n                } else if (isXBLXBL) {// xbl:xbl\n                    inPreserve = true;\n                    preserveLevel = level;\n                    inXBL = true;\n                }\n            }\n        }\n\n        level++;\n    }","commit_id":"909c284f60efabdf7aed4fd1f432f8cd684d988b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    protected void handleLabel() throws SAXException {\n        // TODO: check why we output our own label here\n\n        final XFormsGroupControl groupControl = (XFormsGroupControl) getControl();\n        final String effectiveId = getEffectiveId();\n\n        reusableAttributes.clear();\n        reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, getLabelClasses(groupControl));\n        outputLabelFor(handlerContext, reusableAttributes, effectiveId, effectiveId, LHHAC.LABEL, handlerContext.getLabelElementName(),\n                getLabelValue(groupControl), groupControl != null && groupControl.isHTMLLabel(), !handlerContext.isSpanHTMLLayout());\n    }","id":42,"modified_method":"@Override\n    protected void handleLabel() throws SAXException {\n        // TODO: check why we output our own label here\n\n        final XFormsSingleNodeControl groupControl = (XFormsSingleNodeControl) getControl();\n        final String effectiveId = getEffectiveId();\n\n        reusableAttributes.clear();\n        reusableAttributes.addAttribute(\"\", \"class\", \"class\", ContentHandlerHelper.CDATA, getLabelClasses(groupControl));\n        outputLabelFor(handlerContext, reusableAttributes, effectiveId, effectiveId, LHHAC.LABEL, handlerContext.getLabelElementName(),\n                getLabelValue(groupControl), groupControl != null && groupControl.isHTMLLabel(), !handlerContext.isSpanHTMLLayout());\n    }","commit_id":"909c284f60efabdf7aed4fd1f432f8cd684d988b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void registerHandlers(final ElementHandlerController controller, final XFormsContainingDocument containingDocument) {\n\n        // xforms:input\n        controller.registerHandler(XFormsInputHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"input\");\n\n        // xforms:output\n        controller.registerHandler(XFormsOutputTextHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_TEXT_APPEARANCE_QNAME.equals(controller.getAttributeQNameValue(attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName())));\n            }\n        });\n        controller.registerHandler(XFormsOutputDownloadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_DOWNLOAD_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsOutputImageHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n            }\n        });\n        controller.registerHandler(XFormsOutputHTMLHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.equals(\"text/html\");\n            }\n        });\n        controller.registerHandler(XFormsOutputDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\");\n\n        // xforms:trigger\n        final ElementHandlerController.Matcher triggerSubmitMinimalMatcher = controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final QName appearance = getAppearance(attributes);\n                return appearance != null && !containingDocument.getStaticState().isNoscript() // is noscript mode, use the full appearance\n                        && (XFormsConstants.XFORMS_MINIMAL_APPEARANCE_QNAME.equals(appearance)    // minimal appearance\n                            || XFormsConstants.XXFORMS_LINK_APPEARANCE_QNAME.equals(appearance)); // legacy appearance\n            }\n        };\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\");\n\n        // xforms:submit\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\");\n\n        // xforms:group\n        controller.registerHandler(XFormsGroupInternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupFieldsetHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_FIELDSET_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupSeparatorHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                // XFormsAnnotatorContentHandler adds this appearance if needed\n\n                // NOTE: we just check on the attribute value instead of resolving the QName, so that XFormsAnnotatorContentHandler\n                // doesn't have to declare the xxforms:* prefix.\n                final String appearanceAttributeValue = attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName());\n                return XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName().equals(appearanceAttributeValue);\n            }\n        });\n        controller.registerHandler(XFormsGroupDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\");\n\n        // xforms:switch\n        controller.registerHandler(XFormsSwitchHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\");\n        controller.registerHandler(XFormsCaseHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"case\");\n\n        // xforms:repeat\n        controller.registerHandler(XFormsRepeatHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"repeat\");\n\n        // xforms:secret\n        controller.registerHandler(XFormsSecretHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"secret\");\n\n        // xforms:upload\n        controller.registerHandler(XFormsUploadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"upload\");\n\n        // xforms:range\n        controller.registerHandler(XFormsRangeHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"range\");\n\n        // Other controls\n        controller.registerHandler(XFormsTextareaHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"textarea\");\n        if (!containingDocument.getStaticState().isNoscript())\n            controller.registerHandler(XXFormsDialogHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n        else\n            controller.registerHandler(NullHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n\n        // xforms:select and xforms:select1\n        controller.registerHandler(XFormsSelect1InternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsSelect1InternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsSelectHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\");\n        controller.registerHandler(XFormsSelect1Handler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\");\n\n        // Add handlers for LHHA elements\n        // TODO: check w/ XFStaticState if there are any standalone LHHA elements\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"label\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"help\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"hint\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"alert\");\n\n        // Add handlers for custom components\n        final Seq<QName> componentBindings = containingDocument.getStaticOps().getBindingQNames();\n        for (final scala.collection.Iterator<QName> i = componentBindings.iterator(); i.hasNext();) {\n            final QName currentQName = i.next();\n            controller.registerHandler(XXFormsComponentHandler.class.getName(), currentQName.getNamespaceURI(), currentQName.getName());\n        }\n\n        // xxf:dynamic\n        controller.registerHandler(XXFormsDynamicHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dynamic\");\n    }","id":43,"modified_method":"public static void registerHandlers(final ElementHandlerController controller, final XFormsContainingDocument containingDocument) {\n\n        // xforms:input\n        controller.registerHandler(XFormsInputHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"input\");\n\n        // xforms:output\n        controller.registerHandler(XFormsOutputTextHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_TEXT_APPEARANCE_QNAME.equals(controller.getAttributeQNameValue(attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName())));\n            }\n        });\n        controller.registerHandler(XFormsOutputDownloadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_DOWNLOAD_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsOutputImageHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n            }\n        });\n        controller.registerHandler(XFormsOutputHTMLHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.equals(\"text/html\");\n            }\n        });\n        controller.registerHandler(XFormsOutputDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\");\n\n        // xforms:trigger\n        final ElementHandlerController.Matcher triggerSubmitMinimalMatcher = controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final QName appearance = getAppearance(attributes);\n                return appearance != null && !containingDocument.getStaticState().isNoscript() // is noscript mode, use the full appearance\n                        && (XFormsConstants.XFORMS_MINIMAL_APPEARANCE_QNAME.equals(appearance)    // minimal appearance\n                            || XFormsConstants.XXFORMS_LINK_APPEARANCE_QNAME.equals(appearance)); // legacy appearance\n            }\n        };\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\");\n\n        // xforms:submit\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\");\n\n        // xforms:group\n        controller.registerHandler(XFormsGroupInternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupFieldsetHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_FIELDSET_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupSeparatorHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                // XFormsAnnotatorContentHandler adds this appearance if needed\n\n                // NOTE: we just check on the attribute value instead of resolving the QName, so that XFormsAnnotatorContentHandler\n                // doesn't have to declare the xxforms:* prefix.\n                final String appearanceAttributeValue = attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName());\n                return XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName().equals(appearanceAttributeValue);\n            }\n        });\n        controller.registerHandler(XFormsGroupDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\");\n\n        // xforms:switch\n        // NOTE: We use the same handlers for switch as we do for group\n        controller.registerHandler(XFormsGroupSeparatorHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                // XFormsAnnotatorContentHandler adds this appearance if needed\n\n                // NOTE: we just check on the attribute value instead of resolving the QName, so that XFormsAnnotatorContentHandler\n                // doesn't have to declare the xxforms:* prefix.\n                final String appearanceAttributeValue = attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName());\n                return XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName().equals(appearanceAttributeValue);\n            }\n        });\n        controller.registerHandler(XFormsGroupDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\");\n        controller.registerHandler(XFormsCaseHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"case\");\n\n        // xforms:repeat\n        controller.registerHandler(XFormsRepeatHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"repeat\");\n\n        // xforms:secret\n        controller.registerHandler(XFormsSecretHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"secret\");\n\n        // xforms:upload\n        controller.registerHandler(XFormsUploadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"upload\");\n\n        // xforms:range\n        controller.registerHandler(XFormsRangeHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"range\");\n\n        // Other controls\n        controller.registerHandler(XFormsTextareaHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"textarea\");\n        if (!containingDocument.getStaticState().isNoscript())\n            controller.registerHandler(XXFormsDialogHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n        else\n            controller.registerHandler(NullHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n\n        // xforms:select and xforms:select1\n        controller.registerHandler(XFormsSelect1InternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsSelect1InternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsSelectHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\");\n        controller.registerHandler(XFormsSelect1Handler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\");\n\n        // Add handlers for LHHA elements\n        // TODO: check w/ XFStaticState if there are any standalone LHHA elements\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"label\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"help\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"hint\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"alert\");\n\n        // Add handlers for custom components\n        final Seq<QName> componentBindings = containingDocument.getStaticOps().getBindingQNames();\n        for (final scala.collection.Iterator<QName> i = componentBindings.iterator(); i.hasNext();) {\n            final QName currentQName = i.next();\n            controller.registerHandler(XXFormsComponentHandler.class.getName(), currentQName.getNamespaceURI(), currentQName.getName());\n        }\n\n        // xxf:dynamic\n        controller.registerHandler(XXFormsDynamicHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dynamic\");\n    }","commit_id":"909c284f60efabdf7aed4fd1f432f8cd684d988b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void populateAttributes(AttributesImpl attributesImpl, String[] attributes) {\n        for (int i = 0; i < attributes.length / 2; i++) {\n            final String attributeName = attributes[i * 2];\n            final String attributeValue = attributes[i * 2 + 1];\n            if (attributeName != null && attributeValue != null)\n                attributesImpl.addAttribute(\"\", attributeName, attributeName, CDATA, attributeValue);\n        }\n    }","id":44,"modified_method":"public static void populateAttributes(AttributesImpl attributesImpl, String[] attributes) {\n        if (attributes != null) {\n            for (int i = 0; i < attributes.length / 2; i++) {\n                final String attributeName = attributes[i * 2];\n                final String attributeValue = attributes[i * 2 + 1];\n                if (attributeName != null && attributeValue != null)\n                    attributesImpl.addAttribute(\"\", attributeName, attributeName, CDATA, attributeValue);\n            }\n        }\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Return the list of items as a JSON tree.\n     *\n     * @param controlValue  current value of the control (to determine selected item) or null (valued used only during initialization)\n     * @param many          whether multiple selection is allowed (to determine selected item)\n     * @return              String representing a JSON tree\n     */\n    public String getJSONTreeInfo(final PropertyContext context, final String controlValue, final boolean many, LocationData locationData) {\n        // Produce a JSON fragment with hierarchical information\n        if (getChildren().size() > 0) {\n            final StringBuilder sb = new StringBuilder(100);\n            sb.append(\"[\");\n            try {\n                visit(null, new ItemsetListener() {\n\n                    public void startLevel(ContentHandler contentHandler, Item item) throws SAXException {}\n                    public void endLevel(ContentHandler contentHandler) throws SAXException {}\n\n                    public void startItem(ContentHandler contentHandler, Item item, boolean first) throws SAXException {\n                        final String value = item.getValue();\n\n                        if (!first)\n                            sb.append(',');\n                        sb.append(\"[\");\n\n                        // Label and value\n                        sb.append('\"');\n                        sb.append(item.getExternalJSLabel());\n                        sb.append(\"\\\",\\\"\");\n                        sb.append(item.getExternalJSValue(context));\n                        sb.append('\\\"');\n\n                        // Attributes if any\n                        final Map<String, String> attributes = item.getAttributes();\n                        if (attributes != null && attributes.size() > 0) {\n                            final int size = attributes.size();\n                            int count = 0;\n                            sb.append(\",{\");// start map attribute name/value\n                            for (final Map.Entry<String, String> entry: attributes.entrySet()) {\n                                sb.append('\"');\n                                sb.append(XFormsUtils.escapeJavaScript(entry.getKey()));\n                                sb.append('\"');\n                                sb.append(':');\n                                sb.append('\"');\n                                sb.append(XFormsUtils.escapeJavaScript(entry.getValue()));\n                                sb.append('\"');\n                                if (++count != size)\n                                    sb.append(',');\n                            }\n                            sb.append('}');\n                        }\n\n                        // NOTE: This is used for tree/menu initialization only\n                        if (controlValue != null) {\n                            // We allow the value to be null when this method is used just to produce the structure of the tree without selection\n                            sb.append(',');\n                            sb.append(Boolean.toString((value != null) && XFormsItemUtils.isSelected(many, controlValue, value)));\n                        }\n                    }\n\n                    public void endItem(ContentHandler contentHandler) throws SAXException {\n                        sb.append(\"]\");\n                    }\n                });\n            } catch (SAXException e) {\n                throw new ValidationException(\"Error while creating itemset tree\", e, locationData);\n            }\n            sb.append(\"]\");\n\n            return sb.toString();\n\n        } else {\n            // Safer to return an empty array rather than en empty string\n            return \"[]\";\n        }\n    }","id":45,"modified_method":"/**\n     * Return the list of items as a JSON tree.\n     *\n     * @param controlValue  current value of the control (to determine selected item) or null (valued used only during initialization)\n     * @param isMultiple    whether multiple selection is allowed (to determine selected item)\n     * @return              String representing a JSON tree\n     */\n    public String getJSONTreeInfo(final PropertyContext context, final String controlValue, final boolean isMultiple, LocationData locationData) {\n        // Produce a JSON fragment with hierarchical information\n        if (getChildren().size() > 0) {\n            final StringBuilder sb = new StringBuilder(100);\n            sb.append(\"[\");\n            try {\n                visit(null, new ItemsetListener() {\n\n                    public void startLevel(ContentHandler contentHandler, Item item) throws SAXException {}\n                    public void endLevel(ContentHandler contentHandler) throws SAXException {}\n\n                    public void startItem(ContentHandler contentHandler, Item item, boolean first) throws SAXException {\n\n                        if (!first)\n                            sb.append(',');\n                        sb.append(\"[\");\n\n                        // Item label and value\n                        sb.append('\"');\n                        sb.append(item.getExternalJSLabel());\n                        sb.append(\"\\\",\\\"\");\n                        sb.append(item.getExternalJSValue(context));\n                        sb.append('\\\"');\n\n                        // Item attributes if any\n                        final Map<String, String> attributes = item.getAttributes();\n                        if (attributes != null && attributes.size() > 0) {\n                            final int size = attributes.size();\n                            int count = 0;\n                            sb.append(\",{\");// start map attribute name/value\n                            for (final Map.Entry<String, String> entry: attributes.entrySet()) {\n                                sb.append('\"');\n                                sb.append(XFormsUtils.escapeJavaScript(entry.getKey()));\n                                sb.append('\"');\n                                sb.append(':');\n                                sb.append('\"');\n                                sb.append(XFormsUtils.escapeJavaScript(entry.getValue()));\n                                sb.append('\"');\n                                if (++count != size)\n                                    sb.append(',');\n                            }\n                            sb.append('}');\n                        }\n\n                        // Handle selection\n                        {\n                            final String itemValue = (item.getValue() != null) ? item.getValue() : \"\";\n                            final boolean itemSelected = (itemValue != null) && XFormsItemUtils.isSelected(isMultiple, controlValue, itemValue);\n\n                            // NOTE: This is useful e.g. for tree/menu initialization\n                            if (itemSelected) {\n                                sb.append(',');\n                                sb.append(Boolean.toString(itemSelected));\n                            }\n                        }\n                    }\n\n                    public void endItem(ContentHandler contentHandler) throws SAXException {\n                        sb.append(\"]\");\n                    }\n                });\n            } catch (SAXException e) {\n                throw new ValidationException(\"Error while creating itemset tree\", e, locationData);\n            }\n            sb.append(\"]\");\n\n            return sb.toString();\n\n        } else {\n            // Safer to return an empty array rather than en empty string\n            return \"[]\";\n        }\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Evaluate the itemset for a given xforms:select or xforms:select1 control.\n     *\n     * @param propertyContext       current context\n     * @param select1Control        control to evaluate\n     * @param setBinding            whether this method must set the evaluation binding (false if it is already set)\n     * @return                      Itemset\n     */\n    public static Itemset evaluateItemset(final PropertyContext propertyContext, final XFormsSelect1Control select1Control, boolean setBinding) {\n\n        final boolean isMultiple = select1Control instanceof XFormsSelectControl;\n        final XBLContainer container = select1Control.getXBLContainer();\n\n        // Optimize static itemsets\n        {\n            final boolean isStaticItemset; {\n            final XFormsStaticState.ItemsInfo itemsInfo = container.getContainingDocument().getStaticState().getItemsInfo(select1Control.getPrefixedId());\n                isStaticItemset = itemsInfo != null && !itemsInfo.hasNonStaticItem();\n            }\n\n            if (isStaticItemset)\n                return evaluateStaticItemsets(container.getContainingDocument(), select1Control.getPrefixedId());\n        }\n\n        final Itemset result = new Itemset();\n\n        // Set binding on this control if required\n        final XFormsContextStack contextStack = container.getContextStack();\n        if (setBinding)\n            contextStack.setBinding(select1Control);\n\n        // TODO: Work on dependencies\n//        final List existingItems = containingDocument.getXFormsControls().getConstantItems(getOriginalId());\n//        final boolean[] mayReuse = new boolean[] { existingItems != null };\n\n        final boolean isEncryptItemValues = select1Control.isEncryptItemValues();\n        Dom4jUtils.visitSubtree(select1Control.getControlElement(), new Dom4jUtils.VisitorListener() {\n\n            private ItemContainer currentContainer = result;\n\n            private String getElementEffectiveId(Element element) {\n                return XFormsUtils.getRelatedEffectiveId(select1Control.getEffectiveId(), element.attributeValue(\"id\"));\n            }\n\n            public void startElement(Element element) {\n                final String localname = element.getName();\n                if (\"item\".equals(localname)) {\n                    // xforms:item\n\n//                    mayReuse[0] = false;\n                    final String label = getLabelValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME));\n                    final String value = getValueValue(element.element(XFormsConstants.XFORMS_VALUE_QNAME));\n\n                    final Map<String, String> attributes = getAttributes(element);\n                    currentContainer.addChildItem(new Item(isMultiple, isEncryptItemValues, attributes, label != null ? label : \"\", value != null ? value : \"\"));\n\n                } else if (\"itemset\".equals(localname)) {\n                    // xforms:itemset\n                    contextStack.pushBinding(propertyContext, element, getElementEffectiveId(element), select1Control.getChildElementScope(element));\n                    {\n                        final XFormsContextStack.BindingContext currentBindingContext = contextStack.getCurrentBindingContext();\n\n                        //if (model == null || model == currentBindingContext.getModel()) { // it is possible to filter on a particular model\n                        final List<org.orbeon.saxon.om.Item> currentNodeSet = currentBindingContext.getNodeset();\n                        if (currentNodeSet != null) {\n\n                            // Node stack tracks the relative position of the current node wrt ancestor nodes\n                            final Stack<NodeInfo> nodeStack = new Stack<NodeInfo>();\n                            int currentLevel = 0;\n\n                            final int iterationCount = currentNodeSet.size();\n                            for (int currentPosition = 1; currentPosition <= iterationCount; currentPosition++) {\n\n                                // Push iteration\n                                contextStack.pushIteration(currentPosition);\n                                {\n                                    final NodeInfo currentNodeInfo = (NodeInfo) currentNodeSet.get(currentPosition - 1);\n\n                                    // Handle children of xforms:itemset\n\n                                    // We support relevance of items as an extension to XForms\n\n                                    // NOTE: If a node is non-relevant, all its descendants will be non-relevant as\n                                    // well. If a node is non-relevant, it should be as if it had not even been part of\n                                    // the nodeset.\n                                    final boolean isRelevant = InstanceData.getInheritedRelevant(currentNodeInfo);\n                                    if (isRelevant) {\n                                        final String label = getLabelValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME));\n                                        final Element valueCopyElement;\n                                        {\n                                            final Element valueElement = element.element(XFormsConstants.XFORMS_VALUE_QNAME);\n                                            valueCopyElement = (valueElement != null)\n                                                    ? valueElement : element.element(XFormsConstants.XFORMS_COPY_QNAME);\n                                        }\n                                        if (valueCopyElement == null)\n                                            throw new ValidationException(\"xforms:itemset element must contain one xforms:value or one xforms:copy element.\", select1Control.getLocationData());\n\n                                        // Update stack and containers\n                                        if (nodeStack.size() != 0) {\n                                            final int newLevel = getNodeLevel(currentNodeInfo, nodeStack);\n                                            if (newLevel == currentLevel) {\n                                                //  We are staying at the same level, pop old node\n                                                nodeStack.pop();\n                                            } else if (newLevel < currentLevel) {\n                                                //  We are going down one or more levels\n                                                nodeStack.pop();\n                                                for (int i = newLevel; i < currentLevel; i++) {\n                                                    nodeStack.pop();\n                                                    currentContainer = currentContainer.getParent();\n                                                }\n                                            } else if (newLevel > currentLevel) {\n                                                // Going up one level, set new container as last added child\n                                                final List<Item> children = currentContainer.getChildren();\n                                                currentContainer = children.get(children.size() - 1);\n                                            }\n                                            if (currentContainer == null)\n                                                System.out.println();\n                                            currentLevel = newLevel;\n                                        }\n\n                                        // Handle new item\n                                        if (valueCopyElement.getName().equals(\"value\")) {\n                                            // Handle xforms:value\n                                            // TODO: This could be optimized for xforms:value/@ref|@value as we could get the expression from the cache only once\n                                            final String value = getValueValue(valueCopyElement);\n\n                                            // NOTE: At this point, if the value is null, we should consider the item\n                                            // non-relevant if it is a leaf item. But we don't yet know if this item is\n                                            // a leaf item, so we prune such non-relevant items later.\n\n                                            final Map<String, String> attributes = getAttributes(element);\n                                            currentContainer.addChildItem(new Item(isMultiple, isEncryptItemValues, attributes, label != null ? label : \"\", value));\n                                        } else {\n                                            // TODO: handle xforms:copy\n                                            throw new ValidationException(\"xforms:copy is not yet supported.\", select1Control.getLocationData());\n                                        }\n\n                                        // Always push the last node to the stack\n                                        nodeStack.push(currentNodeInfo);\n\n                                    }\n                                }\n                                contextStack.popBinding();\n                            }\n                        }\n                    }\n                    contextStack.popBinding();\n\n                } else if (\"choices\".equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        final String label = getLabelValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME));\n\n                        final Map<String, String> attributes = getAttributes(element);\n                        final Item newContainer = new Item(isMultiple, isEncryptItemValues, attributes, label, null);\n                        currentContainer.addChildItem(newContainer);\n                        currentContainer = newContainer;\n                    }\n                }\n            }\n\n            private String getValueValue(Element valueElement) {\n                if (valueElement == null)\n                    throw new ValidationException(\"xforms:item or xforms:itemset must contain an xforms:value element.\", select1Control.getLocationData());\n                final XBLBindings.Scope elementScope = select1Control.getChildElementScope(valueElement);\n                final String elementEffectiveId = getElementEffectiveId(valueElement);\n                return XFormsUtils.getChildElementValue(propertyContext, container, elementEffectiveId, elementScope, valueElement, false, null);\n            }\n\n            private String getLabelValue(Element labelElement) {\n                if (labelElement == null)\n                    throw new ValidationException(\"xforms:item or xforms:itemset must contain an xforms:label element.\", select1Control.getLocationData());\n                final XBLBindings.Scope elementScope = select1Control.getChildElementScope(labelElement);\n                final String elementEffectiveId = getElementEffectiveId(labelElement);\n                return XFormsUtils.getChildElementValue(propertyContext, container, elementEffectiveId, elementScope, labelElement, false, null);\n            }\n\n            private Map<String, String> getAttributes(Element itemChoiceItemsetElement) {\n                final String elementEffectiveId = getElementEffectiveId(itemChoiceItemsetElement);\n\n                final Map<String, String> result = new LinkedHashMap<String, String>();\n                for (String attributeName: ATTRIBUTES_TO_PROPAGATE) {\n                    final String attributeValue = itemChoiceItemsetElement.attributeValue(attributeName);\n                    if (attributeValue != null)\n                        addAttributeAVTValue(itemChoiceItemsetElement, attributeName, attributeValue, elementEffectiveId, result);\n                }\n                return result;\n            }\n\n            private void addAttributeAVTValue(Element itemChoiceItemsetElement, String attributeName, String attributeValue, String elementEffectiveId, Map<String, String> result) {\n                if (attributeValue.indexOf('{') == -1) {\n                    // Definitely not an AVT\n                    result.put(attributeName, attributeValue);\n                } else {\n                    // Possible AVT\n                    final XFormsContextStack.BindingContext currentBindingContext = contextStack.getCurrentBindingContext();\n                    final List<org.orbeon.saxon.om.Item> currentNodeset = currentBindingContext.getNodeset();\n                    if (currentNodeset != null && currentNodeset.size() > 0) {\n                        final String tempResult = XPathCache.evaluateAsAvt(propertyContext,\n                                currentNodeset, currentBindingContext.getPosition(),\n                                attributeValue, container.getNamespaceMappings(itemChoiceItemsetElement),\n                                contextStack.getCurrentVariables(), XFormsContainingDocument.getFunctionLibrary(),\n                                contextStack.getFunctionContext(elementEffectiveId), null,\n                                (LocationData) itemChoiceItemsetElement.getData());\n\n                        contextStack.returnFunctionContext();\n\n                        result.put(attributeName, tempResult);\n                    }\n                }\n            }\n\n            public void endElement(Element element) {\n                final String localname = element.getName();\n                if (\"choices\".equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        currentContainer = currentContainer.getParent();\n                    }\n                }\n            }\n\n            public void text(Text text) {\n            }\n\n            /**\n             * Return the node level for the given node. If the stack is emty, the level is 0.\n             *\n             * @param nodeInfo  node to check\n             * @param stack     stack of potential ancestors\n             * @return          node level\n             */\n            private int getNodeLevel(NodeInfo nodeInfo, Stack<NodeInfo> stack) {\n                // Iterate stack from top to bottom\n                Collections.reverse(stack);\n                int level = stack.size();\n                for (Iterator<NodeInfo> i = stack.iterator(); i.hasNext(); level--) {\n                    final NodeInfo currentNode = i.next();\n                    if (isAncestorNode(nodeInfo, currentNode)) {\n                        // Restore order\n                        Collections.reverse(stack);\n                        return level;\n                    }\n                }\n                // Restore order\n                Collections.reverse(stack);\n                return level;\n            }\n\n            /**\n             * Whether the given node has potentialAncestor as ancestor.\n             *\n             * @param node                  node to check\n             * @param potentialAncestor     potential ancestor\n             * @return                      true iif potentialAncestor is an ancestor of node\n             */\n            private boolean isAncestorNode(NodeInfo node, NodeInfo potentialAncestor) {\n                NodeInfo parent = node.getParent();\n                while (parent != null) {\n                    if (parent.isSameNodeInfo(potentialAncestor))\n                        return true;\n                    parent = parent.getParent();\n                }\n\n                return false;\n            }\n        });\n\n        // Prune non-relevant children\n        result.pruneNonRelevantChildren();\n\n        return result;\n    }","id":46,"modified_method":"/**\n     * Evaluate the itemset for a given xforms:select or xforms:select1 control.\n     *\n     * @param propertyContext       current context\n     * @param select1Control        control to evaluate\n     * @param setBinding            whether this method must set the evaluation binding (false if it is already set)\n     * @return                      Itemset\n     */\n    public static Itemset evaluateItemset(final PropertyContext propertyContext, final XFormsSelect1Control select1Control, boolean setBinding) {\n\n        final boolean isMultiple = select1Control instanceof XFormsSelectControl;\n        final XBLContainer container = select1Control.getXBLContainer();\n\n        // Optimize static itemsets\n        {\n            final boolean isStaticItemset; {\n            final XFormsStaticState.ItemsInfo itemsInfo = container.getContainingDocument().getStaticState().getItemsInfo(select1Control.getPrefixedId());\n                isStaticItemset = itemsInfo != null && !itemsInfo.hasNonStaticItem();\n            }\n\n            if (isStaticItemset)\n                return evaluateStaticItemsets(container.getContainingDocument(), select1Control.getPrefixedId());\n        }\n\n        final Itemset result = new Itemset();\n\n        // Set binding on this control if required\n        final XFormsContextStack contextStack = container.getContextStack();\n        if (setBinding)\n            contextStack.setBinding(select1Control);\n\n        // TODO: Work on dependencies\n//        final List existingItems = containingDocument.getXFormsControls().getConstantItems(getOriginalId());\n//        final boolean[] mayReuse = new boolean[] { existingItems != null };\n\n        final boolean isEncryptItemValues = select1Control.isEncryptItemValues();\n        Dom4jUtils.visitSubtree(select1Control.getControlElement(), new Dom4jUtils.VisitorListener() {\n\n            private ItemContainer currentContainer = result;\n\n            private String getElementEffectiveId(Element element) {\n                return XFormsUtils.getRelatedEffectiveId(select1Control.getEffectiveId(), element.attributeValue(\"id\"));\n            }\n\n            public void startElement(Element element) {\n                final String localname = element.getName();\n                if (XFormsConstants.XFORMS_ITEM_QNAME.getName().equals(localname)) {\n                    // xforms:item\n\n//                    mayReuse[0] = false;\n                    final String label = getLabelValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME));\n                    final String value = getValueValue(element.element(XFormsConstants.XFORMS_VALUE_QNAME));\n\n                    final Map<String, String> attributes = getAttributes(element);\n                    currentContainer.addChildItem(new Item(isMultiple, isEncryptItemValues, attributes, label != null ? label : \"\", value != null ? value : \"\"));\n\n                } else if (XFormsConstants.XFORMS_ITEMSET_QNAME.getName().equals(localname)) {\n                    // xforms:itemset\n                    contextStack.pushBinding(propertyContext, element, getElementEffectiveId(element), select1Control.getChildElementScope(element));\n                    {\n                        final XFormsContextStack.BindingContext currentBindingContext = contextStack.getCurrentBindingContext();\n\n                        //if (model == null || model == currentBindingContext.getModel()) { // it is possible to filter on a particular model\n                        final List<org.orbeon.saxon.om.Item> currentNodeSet = currentBindingContext.getNodeset();\n                        if (currentNodeSet != null) {\n\n                            // Node stack tracks the relative position of the current node wrt ancestor nodes\n                            final Stack<NodeInfo> nodeStack = new Stack<NodeInfo>();\n                            int currentLevel = 0;\n\n                            final int iterationCount = currentNodeSet.size();\n                            for (int currentPosition = 1; currentPosition <= iterationCount; currentPosition++) {\n\n                                // Push iteration\n                                contextStack.pushIteration(currentPosition);\n                                {\n                                    final NodeInfo currentNodeInfo = (NodeInfo) currentNodeSet.get(currentPosition - 1);\n\n                                    // Handle children of xforms:itemset\n\n                                    // We support relevance of items as an extension to XForms\n\n                                    // NOTE: If a node is non-relevant, all its descendants will be non-relevant as\n                                    // well. If a node is non-relevant, it should be as if it had not even been part of\n                                    // the nodeset.\n                                    final boolean isRelevant = InstanceData.getInheritedRelevant(currentNodeInfo);\n                                    if (isRelevant) {\n                                        final String label = getLabelValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME));\n                                        final Element valueCopyElement;\n                                        {\n                                            final Element valueElement = element.element(XFormsConstants.XFORMS_VALUE_QNAME);\n                                            valueCopyElement = (valueElement != null)\n                                                    ? valueElement : element.element(XFormsConstants.XFORMS_COPY_QNAME);\n                                        }\n                                        if (valueCopyElement == null)\n                                            throw new ValidationException(\"xforms:itemset element must contain one xforms:value or one xforms:copy element.\", select1Control.getLocationData());\n\n                                        // Update stack and containers\n                                        if (nodeStack.size() != 0) {\n                                            final int newLevel = getNodeLevel(currentNodeInfo, nodeStack);\n                                            if (newLevel == currentLevel) {\n                                                //  We are staying at the same level, pop old node\n                                                nodeStack.pop();\n                                            } else if (newLevel < currentLevel) {\n                                                //  We are going down one or more levels\n                                                nodeStack.pop();\n                                                for (int i = newLevel; i < currentLevel; i++) {\n                                                    nodeStack.pop();\n                                                    currentContainer = currentContainer.getParent();\n                                                }\n                                            } else if (newLevel > currentLevel) {\n                                                // Going up one level, set new container as last added child\n                                                final List<Item> children = currentContainer.getChildren();\n                                                currentContainer = children.get(children.size() - 1);\n                                            }\n                                            if (currentContainer == null)\n                                                System.out.println();\n                                            currentLevel = newLevel;\n                                        }\n\n                                        // Handle new item\n                                        if (valueCopyElement.getName().equals(XFormsConstants.XFORMS_VALUE_QNAME.getName())) {\n                                            // Handle xforms:value\n                                            // TODO: This could be optimized for xforms:value/@ref|@value as we could get the expression from the cache only once\n                                            final String value = getValueValue(valueCopyElement);\n\n                                            // NOTE: At this point, if the value is null, we should consider the item\n                                            // non-relevant if it is a leaf item. But we don't yet know if this item is\n                                            // a leaf item, so we prune such non-relevant items later.\n\n                                            final Map<String, String> attributes = getAttributes(element);\n                                            currentContainer.addChildItem(new Item(isMultiple, isEncryptItemValues, attributes, label != null ? label : \"\", value));\n                                        } else {\n                                            // TODO: handle xforms:copy\n                                            throw new ValidationException(\"xforms:copy is not yet supported.\", select1Control.getLocationData());\n                                        }\n\n                                        // Always push the last node to the stack\n                                        nodeStack.push(currentNodeInfo);\n\n                                    }\n                                }\n                                contextStack.popBinding();\n                            }\n                        }\n                    }\n                    contextStack.popBinding();\n\n                } else if (XFormsConstants.XFORMS_CHOICES_QNAME.getName().equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        final String label = getLabelValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME));\n\n                        final Map<String, String> attributes = getAttributes(element);\n                        final Item newContainer = new Item(isMultiple, isEncryptItemValues, attributes, label, null);\n                        currentContainer.addChildItem(newContainer);\n                        currentContainer = newContainer;\n                    }\n                }\n            }\n\n            private String getValueValue(Element valueElement) {\n                if (valueElement == null)\n                    throw new ValidationException(\"xforms:item or xforms:itemset must contain an xforms:value element.\", select1Control.getLocationData());\n                final XBLBindings.Scope elementScope = select1Control.getChildElementScope(valueElement);\n                final String elementEffectiveId = getElementEffectiveId(valueElement);\n                return XFormsUtils.getChildElementValue(propertyContext, container, elementEffectiveId, elementScope, valueElement, false, null);\n            }\n\n            private String getLabelValue(Element labelElement) {\n                if (labelElement == null)\n                    throw new ValidationException(\"xforms:item or xforms:itemset must contain an xforms:label element.\", select1Control.getLocationData());\n                final XBLBindings.Scope elementScope = select1Control.getChildElementScope(labelElement);\n                final String elementEffectiveId = getElementEffectiveId(labelElement);\n                return XFormsUtils.getChildElementValue(propertyContext, container, elementEffectiveId, elementScope, labelElement, false, null);\n            }\n\n            private Map<String, String> getAttributes(Element itemChoiceItemsetElement) {\n                final String elementEffectiveId = getElementEffectiveId(itemChoiceItemsetElement);\n\n                final Map<String, String> result = new LinkedHashMap<String, String>();\n                for (String attributeName: ATTRIBUTES_TO_PROPAGATE) {\n                    final String attributeValue = itemChoiceItemsetElement.attributeValue(attributeName);\n                    if (attributeValue != null)\n                        addAttributeAVTValue(itemChoiceItemsetElement, attributeName, attributeValue, elementEffectiveId, result);\n                }\n                return result;\n            }\n\n            private void addAttributeAVTValue(Element itemChoiceItemsetElement, String attributeName, String attributeValue, String elementEffectiveId, Map<String, String> result) {\n                if (attributeValue.indexOf('{') == -1) {\n                    // Definitely not an AVT\n                    result.put(attributeName, attributeValue);\n                } else {\n                    // Possible AVT\n                    final XFormsContextStack.BindingContext currentBindingContext = contextStack.getCurrentBindingContext();\n                    final List<org.orbeon.saxon.om.Item> currentNodeset = currentBindingContext.getNodeset();\n                    if (currentNodeset != null && currentNodeset.size() > 0) {\n                        final String tempResult = XPathCache.evaluateAsAvt(propertyContext,\n                                currentNodeset, currentBindingContext.getPosition(),\n                                attributeValue, container.getNamespaceMappings(itemChoiceItemsetElement),\n                                contextStack.getCurrentVariables(), XFormsContainingDocument.getFunctionLibrary(),\n                                contextStack.getFunctionContext(elementEffectiveId), null,\n                                (LocationData) itemChoiceItemsetElement.getData());\n\n                        contextStack.returnFunctionContext();\n\n                        result.put(attributeName, tempResult);\n                    }\n                }\n            }\n\n            public void endElement(Element element) {\n                final String localname = element.getName();\n                if (XFormsConstants.XFORMS_CHOICES_QNAME.getName().equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        currentContainer = currentContainer.getParent();\n                    }\n                }\n            }\n\n            public void text(Text text) {\n            }\n\n            /**\n             * Return the node level for the given node. If the stack is emty, the level is 0.\n             *\n             * @param nodeInfo  node to check\n             * @param stack     stack of potential ancestors\n             * @return          node level\n             */\n            private int getNodeLevel(NodeInfo nodeInfo, Stack<NodeInfo> stack) {\n                // Iterate stack from top to bottom\n                Collections.reverse(stack);\n                int level = stack.size();\n                for (Iterator<NodeInfo> i = stack.iterator(); i.hasNext(); level--) {\n                    final NodeInfo currentNode = i.next();\n                    if (isAncestorNode(nodeInfo, currentNode)) {\n                        // Restore order\n                        Collections.reverse(stack);\n                        return level;\n                    }\n                }\n                // Restore order\n                Collections.reverse(stack);\n                return level;\n            }\n\n            /**\n             * Whether the given node has potentialAncestor as ancestor.\n             *\n             * @param node                  node to check\n             * @param potentialAncestor     potential ancestor\n             * @return                      true iif potentialAncestor is an ancestor of node\n             */\n            private boolean isAncestorNode(NodeInfo node, NodeInfo potentialAncestor) {\n                NodeInfo parent = node.getParent();\n                while (parent != null) {\n                    if (parent.isSameNodeInfo(potentialAncestor))\n                        return true;\n                    parent = parent.getParent();\n                }\n\n                return false;\n            }\n        });\n\n        // Prune non-relevant children\n        result.pruneNonRelevantChildren();\n\n        return result;\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Return whether a select control's value is selected given an item value.\n     *\n     * @param isMultiple    whether multiple selection is allowed\n     * @param controlValue  current value of the control (to determine selected item) or null\n     * @param itemValue     item value to check\n     * @return              true is selected, false otherwise\n     */\n    public static boolean isSelected(boolean isMultiple, String controlValue, String itemValue) {\n        boolean selected = false;\n        if (isMultiple) {\n            if (\"\".equals(controlValue)) {\n                // Special case of empty string: check the item that has empty string if any\n                if (\"\".equals(itemValue)) {\n                    selected = true;\n                }\n            } else {\n                // Case of multiple tokens\n                for (final StringTokenizer st = new StringTokenizer(controlValue); st.hasMoreTokens();) {\n                    final String token = st.nextToken();\n                    if (token.equals(itemValue)) {\n                        selected = true;\n                        break;\n                    }\n                }\n            }\n        } else {\n            selected = controlValue.equals(itemValue);\n        }\n        return selected;\n    }","id":47,"modified_method":"/**\n     * Return whether a select control's value is selected given an item value.\n     *\n     * @param isMultiple    whether multiple selection is allowed\n     * @param controlValue  current value of the control (to determine selected item) or null\n     * @param itemValue     item value to check\n     * @return              true is selected, false otherwise\n     */\n    public static boolean isSelected(boolean isMultiple, String controlValue, String itemValue) {\n        boolean selected = false;\n        if (controlValue != null) {\n            if (isMultiple) {\n                if (\"\".equals(controlValue)) {\n                    // Special case of empty string: check the item that has empty string if any\n                    if (\"\".equals(itemValue)) {\n                        selected = true;\n                    }\n                } else {\n                    // Case of multiple tokens\n                    for (final StringTokenizer st = new StringTokenizer(controlValue); st.hasMoreTokens();) {\n                        final String token = st.nextToken();\n                        if (token.equals(itemValue)) {\n                            selected = true;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                selected = controlValue.equals(itemValue);\n            }\n        }\n        return selected;\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Itemset evaluateStaticItemsets(final XFormsContainingDocument containingDocument, String prefixedId) {\n\n        final boolean isMultiple = XFormsSelect1Control.isMultiple(containingDocument, prefixedId);\n        \n        final Itemset result = new Itemset();\n\n        final Element controlElement = containingDocument.getStaticState().getControlElement(prefixedId);\n        final boolean isEncryptItemValues = XFormsSelect1Control.isEncryptItemValues(containingDocument, controlElement);\n\n        Dom4jUtils.visitSubtree(controlElement, new Dom4jUtils.VisitorListener() {\n\n            private ItemContainer currentContainer = result;\n\n            public void startElement(Element element) {\n                final String localname = element.getName();\n                if (\"item\".equals(localname)) {\n                    // xforms:item\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement == null)\n                        throw new ValidationException(\"xforms:item must contain an xforms:label element.\", (LocationData) controlElement.getData());\n                    final String label = XFormsUtils.getStaticChildElementValue(labelElement, false, null);\n\n                    final Element valueElement = element.element(XFormsConstants.XFORMS_VALUE_QNAME);\n                    if (valueElement == null)\n                        throw new ValidationException(\"xforms:item must contain an xforms:value element.\", (LocationData) controlElement.getData());\n                    final String value = XFormsUtils.getStaticChildElementValue(valueElement, false, null);\n\n                    final Map<String, String> attributes = getAttributes(element);\n                    currentContainer.addChildItem(new Item(isMultiple, isEncryptItemValues, attributes, label != null ? label : \"\", value != null ? value : \"\"));\n\n                } else if (\"itemset\".equals(localname)) {\n                    // xforms:itemset\n\n                    throw new ValidationException(\"xforms:itemset must not appear in static itemset.\", (LocationData) controlElement.getData());\n\n                } else if (\"choices\".equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        final String label = XFormsUtils.getStaticChildElementValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME), false, null);\n\n                        final Map<String, String> attributes = getAttributes(element);\n                        final Item newContainer = new Item(isMultiple, isEncryptItemValues, attributes, label, null);\n                        currentContainer.addChildItem(newContainer);\n                        currentContainer = newContainer;\n                    }\n                }\n            }\n\n            public void endElement(Element element) {\n                final String localname = element.getName();\n                 if (\"choices\".equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        currentContainer = currentContainer.getParent();\n                    }\n                }\n            }\n\n            public void text(Text text) {\n            }\n        });\n        return result;\n    }","id":48,"modified_method":"public static Itemset evaluateStaticItemsets(final XFormsContainingDocument containingDocument, String prefixedId) {\n\n        final boolean isMultiple = XFormsSelect1Control.isMultiple(containingDocument, prefixedId);\n        \n        final Itemset result = new Itemset();\n\n        final Element controlElement = containingDocument.getStaticState().getControlElement(prefixedId);\n        final boolean isEncryptItemValues = XFormsSelect1Control.isEncryptItemValues(containingDocument, controlElement);\n\n        Dom4jUtils.visitSubtree(controlElement, new Dom4jUtils.VisitorListener() {\n\n            private ItemContainer currentContainer = result;\n\n            public void startElement(Element element) {\n                final String localname = element.getName();\n                if (XFormsConstants.XFORMS_ITEM_QNAME.getName().equals(localname)) {\n                    // xforms:item\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement == null)\n                        throw new ValidationException(\"xforms:item must contain an xforms:label element.\", (LocationData) controlElement.getData());\n                    final String label = XFormsUtils.getStaticChildElementValue(labelElement, false, null);\n\n                    final Element valueElement = element.element(XFormsConstants.XFORMS_VALUE_QNAME);\n                    if (valueElement == null)\n                        throw new ValidationException(\"xforms:item must contain an xforms:value element.\", (LocationData) controlElement.getData());\n                    final String value = XFormsUtils.getStaticChildElementValue(valueElement, false, null);\n\n                    final Map<String, String> attributes = getAttributes(element);\n                    currentContainer.addChildItem(new Item(isMultiple, isEncryptItemValues, attributes, label != null ? label : \"\", value != null ? value : \"\"));\n\n                } else if (XFormsConstants.XFORMS_ITEMSET_QNAME.getName().equals(localname)) {\n                    // xforms:itemset\n\n                    throw new ValidationException(\"xforms:itemset must not appear in static itemset.\", (LocationData) controlElement.getData());\n\n                } else if (XFormsConstants.XFORMS_CHOICES_QNAME.getName().equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        final String label = XFormsUtils.getStaticChildElementValue(element.element(XFormsConstants.XFORMS_LABEL_QNAME), false, null);\n\n                        final Map<String, String> attributes = getAttributes(element);\n                        final Item newContainer = new Item(isMultiple, isEncryptItemValues, attributes, label, null);\n                        currentContainer.addChildItem(newContainer);\n                        currentContainer = newContainer;\n                    }\n                }\n            }\n\n            public void endElement(Element element) {\n                final String localname = element.getName();\n                 if (XFormsConstants.XFORMS_CHOICES_QNAME.getName().equals(localname)) {\n                    // xforms:choices\n\n                    final Element labelElement = element.element(XFormsConstants.XFORMS_LABEL_QNAME);\n                    if (labelElement != null) {\n                        currentContainer = currentContainer.getParent();\n                    }\n                }\n            }\n\n            public void text(Text text) {\n            }\n        });\n        return result;\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void registerHandlers(final ElementHandlerController controller, final XFormsStaticState staticState) {\n\n        // xforms:input\n        controller.registerHandler(XFormsInputHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"input\");\n\n        // xforms:output\n        controller.registerHandler(XFormsOutputTextHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_TEXT_APPEARANCE_QNAME.equals(controller.getAttributeQNameValue(attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName())));\n            }\n        });\n        controller.registerHandler(XFormsOutputDownloadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_DOWNLOAD_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsOutputImageHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n            }\n        });\n        controller.registerHandler(XFormsOutputHTMLHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.equals(\"text/html\");\n            }\n        });\n        controller.registerHandler(XFormsOutputDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\");\n\n        // xforms:trigger\n        final ElementHandlerController.Matcher triggerSubmitMinimalMatcher = controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final QName appearance = getAppearance(attributes);\n                return appearance != null && !staticState.isNoScript() // is noscript mode, use the full appearance\n                        && (XFormsConstants.XFORMS_MINIMAL_APPEARANCE_QNAME.equals(appearance)    // minimal appearance\n                            || XFormsConstants.XXFORMS_LINK_APPEARANCE_QNAME.equals(appearance)); // legacy appearance\n            }\n        };\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\");\n\n        // xforms:submit\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\");\n\n        // xforms:group\n        controller.registerHandler(XFormsGroupInternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupFieldsetHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_FIELDSET_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupSeparatorHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                // XFormsAnnotatorContentHandler adds this appearance if needed\n\n                // NOTE: we just check on the attribute value instead of resolving the QName, so that XFormsAnnotatorContentHandler\n                // doesn't have to declare the xxforms:* prefix.\n                final String appearanceAttributeValue = attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName());\n                return XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName().equals(appearanceAttributeValue);\n            }\n        });\n        controller.registerHandler(XFormsGroupDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\");\n\n        // xforms:switch\n        controller.registerHandler(XFormsSwitchHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\");\n        controller.registerHandler(XFormsCaseHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"case\");\n\n        // xforms:repeat\n        controller.registerHandler(XFormsRepeatHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"repeat\");\n\n        // xforms:secret\n        controller.registerHandler(XFormsSecretHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"secret\");\n\n        // xforms:upload\n        controller.registerHandler(XFormsUploadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"upload\");\n\n        // xforms:range\n        controller.registerHandler(XFormsRangeHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"range\");\n\n        // Other controls\n        controller.registerHandler(XFormsTextareaHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"textarea\");\n        controller.registerHandler(XFormsSelectHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\");\n        controller.registerHandler(XFormsSelect1Handler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\");\n        controller.registerHandler(XXFormsDialogHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n\n        // Add handlers for LHHA elements\n        // TODO: check w/ XFStaticState if there are any standalone LHHA elements\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"label\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"help\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"hint\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"alert\");\n\n        // Add handlers for custom components\n        final Map<QName, Element> componentBindings = staticState.getXBLBindings().getComponentBindings();\n        if (componentBindings != null) {\n            for (final QName currentQName: componentBindings.keySet()) {\n                controller.registerHandler(XXFormsComponentHandler.class.getName(), currentQName.getNamespaceURI(), currentQName.getName());\n            }\n        }\n    }","id":49,"modified_method":"public static void registerHandlers(final ElementHandlerController controller, final XFormsStaticState staticState) {\n\n        // xforms:input\n        controller.registerHandler(XFormsInputHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"input\");\n\n        // xforms:output\n        controller.registerHandler(XFormsOutputTextHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_TEXT_APPEARANCE_QNAME.equals(controller.getAttributeQNameValue(attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName())));\n            }\n        });\n        controller.registerHandler(XFormsOutputDownloadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_DOWNLOAD_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsOutputImageHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.startsWith(\"image/\");\n            }\n        });\n        controller.registerHandler(XFormsOutputHTMLHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final String mediatypeValue = attributes.getValue(\"mediatype\");\n                return mediatypeValue != null && mediatypeValue.equals(\"text/html\");\n            }\n        });\n        controller.registerHandler(XFormsOutputDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"output\");\n\n        // xforms:trigger\n        final ElementHandlerController.Matcher triggerSubmitMinimalMatcher = controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                final QName appearance = getAppearance(attributes);\n                return appearance != null && !staticState.isNoScript() // is noscript mode, use the full appearance\n                        && (XFormsConstants.XFORMS_MINIMAL_APPEARANCE_QNAME.equals(appearance)    // minimal appearance\n                            || XFormsConstants.XXFORMS_LINK_APPEARANCE_QNAME.equals(appearance)); // legacy appearance\n            }\n        };\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"trigger\");\n\n        // xforms:submit\n        controller.registerHandler(XFormsTriggerMinimalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\", triggerSubmitMinimalMatcher);\n        controller.registerHandler(XFormsTriggerFullHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"submit\");\n\n        // xforms:group\n        controller.registerHandler(XFormsGroupInternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupFieldsetHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_FIELDSET_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsGroupSeparatorHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                // XFormsAnnotatorContentHandler adds this appearance if needed\n\n                // NOTE: we just check on the attribute value instead of resolving the QName, so that XFormsAnnotatorContentHandler\n                // doesn't have to declare the xxforms:* prefix.\n                final String appearanceAttributeValue = attributes.getValue(XFormsConstants.APPEARANCE_QNAME.getName());\n                return XFormsConstants.XXFORMS_SEPARATOR_APPEARANCE_QNAME.getQualifiedName().equals(appearanceAttributeValue);\n            }\n        });\n        controller.registerHandler(XFormsGroupDefaultHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"group\");\n\n        // xforms:switch\n        controller.registerHandler(XFormsSwitchHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"switch\");\n        controller.registerHandler(XFormsCaseHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"case\");\n\n        // xforms:repeat\n        controller.registerHandler(XFormsRepeatHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"repeat\");\n\n        // xforms:secret\n        controller.registerHandler(XFormsSecretHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"secret\");\n\n        // xforms:upload\n        controller.registerHandler(XFormsUploadHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"upload\");\n\n        // xforms:range\n        controller.registerHandler(XFormsRangeHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"range\");\n\n        // Other controls\n        controller.registerHandler(XFormsTextareaHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"textarea\");\n        controller.registerHandler(XXFormsDialogHandler.class.getName(), XFormsConstants.XXFORMS_NAMESPACE_URI, \"dialog\");\n\n        // xforms:select and xforms:select1\n        controller.registerHandler(XFormsSelect1InternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsSelect1InternalHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\", controller.new Matcher() {\n            public boolean match(Attributes attributes) {\n                return XFormsConstants.XXFORMS_INTERNAL_APPEARANCE_QNAME.equals(getAppearance(attributes));\n            }\n        });\n        controller.registerHandler(XFormsSelectHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select\");\n        controller.registerHandler(XFormsSelect1Handler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"select1\");\n\n        // Add handlers for LHHA elements\n        // TODO: check w/ XFStaticState if there are any standalone LHHA elements\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"label\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"help\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"hint\");\n        controller.registerHandler(XFormsLabelHintHelpAlertHandler.class.getName(), XFormsConstants.XFORMS_NAMESPACE_URI, \"alert\");\n\n        // Add handlers for custom components\n        final Map<QName, Element> componentBindings = staticState.getXBLBindings().getComponentBindings();\n        if (componentBindings != null) {\n            for (final QName currentQName: componentBindings.keySet()) {\n                controller.registerHandler(XXFormsComponentHandler.class.getName(), currentQName.getNamespaceURI(), currentQName.getName());\n            }\n        }\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public SequenceIterator iterate(XPathContext xpathContext) throws XPathException {\n\n        // Get context id\n        final Expression contextIdExpression = (argument == null || argument.length == 0) ? null : argument[0];\n        final String contextId = (contextIdExpression == null) ? null : XFormsUtils.namespaceId(getContainingDocument(xpathContext), contextIdExpression.evaluateAsString(xpathContext));\n\n        // Get context item for id\n        final XFormsContextStack contextStack = getContextStack(xpathContext);\n        final Item contextItem = contextStack.getContextForId(contextId);\n        if (contextItem != null)\n            return new ListIterator(new ArrayList(Collections.singleton(contextItem)));\n        else\n            return EmptyIterator.getInstance();\n    }","id":50,"modified_method":"public SequenceIterator iterate(XPathContext xpathContext) throws XPathException {\n\n        // Get context id\n        final Expression contextIdExpression = (argument == null || argument.length == 0) ? null : argument[0];\n        final String contextId = (contextIdExpression == null) ? null : XFormsUtils.namespaceId(getContainingDocument(xpathContext), contextIdExpression.evaluateAsString(xpathContext));\n\n        // Get context item for id\n        final XFormsContextStack contextStack = getContextStack(xpathContext);\n        final Item contextItem = contextStack.getContextForId(contextId);\n        if (contextItem != null)\n            return SingletonIterator.makeIterator(contextItem);\n        else\n            return EmptyIterator.getInstance();\n    }","commit_id":"592d0e7bc3899a2d2616d0f5150b684fe68086c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private String fixPath( String dir )\n    {\n        File directories = new File( dir );\n        if ( !directories.exists() )\n        {\n            if ( !directories.mkdirs() )\n            {\n                throw new RuntimeException( \"Unable to create directory path[\"\n                    + storeDir + \"] for Neo store.\" );\n            }\n        }\n        String fileSeparator = System.getProperty( \"file.separator\" );\n        if ( \"\\\\\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '/', '\\\\' );\n        }\n        else if ( \"/\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '\\\\', '/' );\n        }\n        String store = dir + fileSeparator + \"neostore.db\";\n        if ( !new File( store).exists() )\n        {\n            NeoStore.createStore( store );\n        }\n        return store;\n    }","id":51,"modified_method":"private String fixPath( String dir )\n    {\n        File directories = new File( dir );\n        if ( !directories.exists() )\n        {\n            if ( !directories.mkdirs() )\n            {\n                throw new RuntimeException( \"Unable to create directory path[\"\n                    + storeDir + \"] for Neo store.\" );\n            }\n        }\n        String fileSeparator = System.getProperty( \"file.separator\" );\n        if ( \"\\\\\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '/', '\\\\' );\n        }\n        else if ( \"/\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '\\\\', '/' );\n        }\n        String store = dir + fileSeparator + \"neostore\";\n        if ( !new File( store).exists() )\n        {\n            NeoStore.createStore( store );\n        }\n        return store;\n    }","commit_id":"b751f703ed006cd3ec94a7af077d5c3849df310b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int createPropertyChain( Map<String,Object> properties )\n    {\n        if ( properties == null )\n        {\n            return Record.NO_NEXT_PROPERTY.intValue();\n        }\n        PropertyStore propStore = getPropertyStore();\n        List<PropertyRecord> propRecords = new ArrayList<PropertyRecord>();\n        PropertyRecord prevRecord = null;\n        for ( Entry<String,Object> entry : properties.entrySet() )\n        {\n            int keyId = indexHolder.getKeyId( entry.getKey() );\n            if ( keyId == -1 )\n            {\n                keyId = createNewPropertyIndex( entry.getKey() );\n            }\n            int propertyId = propStore.nextId();\n            PropertyRecord propertyRecord = new PropertyRecord( propertyId );\n            propertyRecord.setInUse( true );\n            propertyRecord.setCreated();\n            propStore.encodeValue( propertyRecord, entry.getValue() );\n            if ( prevRecord != null )\n            {\n                prevRecord.setPrevProp( propertyId );\n                propertyRecord.setNextProp( prevRecord.getId() );\n            }\n            propRecords.add( propertyRecord );\n            prevRecord = propertyRecord;\n        }\n        // reverse order results in forward update to store\n        for ( int i = propRecords.size() - 1; i >=0; i-- )\n        {\n            propStore.updateRecord( propRecords.get( i ) );\n        }\n        if ( prevRecord != null )\n        {\n            return prevRecord.getId();\n        }\n        return Record.NO_NEXT_PROPERTY.intValue();\n    }","id":52,"modified_method":"private int createPropertyChain( Map<String,Object> properties )\n    {\n        if ( properties == null )\n        {\n            return Record.NO_NEXT_PROPERTY.intValue();\n        }\n        PropertyStore propStore = getPropertyStore();\n        List<PropertyRecord> propRecords = new ArrayList<PropertyRecord>();\n        PropertyRecord prevRecord = null;\n        for ( Entry<String,Object> entry : properties.entrySet() )\n        {\n            int keyId = indexHolder.getKeyId( entry.getKey() );\n            if ( keyId == -1 )\n            {\n                keyId = createNewPropertyIndex( entry.getKey() );\n            }\n            int propertyId = propStore.nextId();\n            PropertyRecord propertyRecord = new PropertyRecord( propertyId );\n            propertyRecord.setInUse( true );\n            propertyRecord.setCreated();\n            propertyRecord.setKeyIndexId( keyId );\n            propStore.encodeValue( propertyRecord, entry.getValue() );\n            if ( prevRecord != null )\n            {\n                prevRecord.setPrevProp( propertyId );\n                propertyRecord.setNextProp( prevRecord.getId() );\n            }\n            propRecords.add( propertyRecord );\n            prevRecord = propertyRecord;\n        }\n        // reverse order results in forward update to store\n        for ( int i = propRecords.size() - 1; i >=0; i-- )\n        {\n            propStore.updateRecord( propRecords.get( i ) );\n        }\n        if ( prevRecord != null )\n        {\n            return prevRecord.getId();\n        }\n        return Record.NO_NEXT_PROPERTY.intValue();\n    }","commit_id":"b751f703ed006cd3ec94a7af077d5c3849df310b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long createRelationship( long node1, long node2, RelationshipType\n        type, Map<String,Object> properties )\n    {\n        int firstNodeId = (int) (node1 & 0xFFFFFFFF );\n        int secondNodeId = (int) (node2 & 0xFFFFFFFF );\n        NodeRecord firstNode = getNodeRecord( node1 );\n        NodeRecord secondNode = getNodeRecord( secondNodeId );\n        int typeId = typeHolder.getTypeId( type.name() );\n        if ( typeId == -1 )\n        {\n            typeId = createNewRelationshipType( type.name() );\n        }\n        int id = getRelationshipStore().nextId(); \n        RelationshipRecord record = new RelationshipRecord( id, firstNodeId,\n            secondNodeId, typeId );\n        record.setInUse( true );\n        record.setCreated();\n        connectRelationship( firstNode, secondNode, record );\n        getNodeStore().updateRecord( firstNode );\n        getNodeStore().updateRecord( secondNode );\n        record.setNextProp( createPropertyChain( properties ) );\n        getRelationshipStore().updateRecord( record );\n        return id & 0xFFFFFFFFL;\n    }","id":53,"modified_method":"public long createRelationship( long node1, long node2, RelationshipType\n        type, Map<String,Object> properties )\n    {\n        int firstNodeId = (int) (node1 & 0xFFFFFFFF );\n        int secondNodeId = (int) (node2 & 0xFFFFFFFF );\n        NodeRecord firstNode = getNodeRecord( node1 );\n        NodeRecord secondNode = getNodeRecord( node2 );\n        int typeId = typeHolder.getTypeId( type.name() );\n        if ( typeId == -1 )\n        {\n            typeId = createNewRelationshipType( type.name() );\n        }\n        int id = getRelationshipStore().nextId(); \n        RelationshipRecord record = new RelationshipRecord( id, firstNodeId,\n            secondNodeId, typeId );\n        record.setInUse( true );\n        record.setCreated();\n        connectRelationship( firstNode, secondNode, record );\n        getNodeStore().updateRecord( firstNode );\n        getNodeStore().updateRecord( secondNode );\n        record.setNextProp( createPropertyChain( properties ) );\n        getRelationshipStore().updateRecord( record );\n        return id & 0xFFFFFFFFL;\n    }","commit_id":"b751f703ed006cd3ec94a7af077d5c3849df310b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                firstNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                secondNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","id":54,"modified_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord( \n                firstNode.getNextRel() );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord(  \n                secondNode.getNextRel() );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","commit_id":"b751f703ed006cd3ec94a7af077d5c3849df310b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                firstNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                secondNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","id":55,"modified_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord( \n                firstNode.getNextRel() );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord(  \n                secondNode.getNextRel() );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","commit_id":"b7961b9b6217a569ce0fc0bfcc3efa96f7d7f8a5","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long createRelationship( long node1, long node2, RelationshipType\n        type, Map<String,Object> properties )\n    {\n        int firstNodeId = (int) (node1 & 0xFFFFFFFF );\n        int secondNodeId = (int) (node2 & 0xFFFFFFFF );\n        NodeRecord firstNode = getNodeRecord( node1 );\n        NodeRecord secondNode = getNodeRecord( secondNodeId );\n        int typeId = typeHolder.getTypeId( type.name() );\n        if ( typeId == -1 )\n        {\n            typeId = createNewRelationshipType( type.name() );\n        }\n        int id = getRelationshipStore().nextId(); \n        RelationshipRecord record = new RelationshipRecord( id, firstNodeId,\n            secondNodeId, typeId );\n        record.setInUse( true );\n        record.setCreated();\n        connectRelationship( firstNode, secondNode, record );\n        getNodeStore().updateRecord( firstNode );\n        getNodeStore().updateRecord( secondNode );\n        record.setNextProp( createPropertyChain( properties ) );\n        getRelationshipStore().updateRecord( record );\n        return id & 0xFFFFFFFFL;\n    }","id":56,"modified_method":"public long createRelationship( long node1, long node2, RelationshipType\n        type, Map<String,Object> properties )\n    {\n        int firstNodeId = (int) (node1 & 0xFFFFFFFF );\n        int secondNodeId = (int) (node2 & 0xFFFFFFFF );\n        NodeRecord firstNode = getNodeRecord( node1 );\n        NodeRecord secondNode = getNodeRecord( node2 );\n        int typeId = typeHolder.getTypeId( type.name() );\n        if ( typeId == -1 )\n        {\n            typeId = createNewRelationshipType( type.name() );\n        }\n        int id = getRelationshipStore().nextId(); \n        RelationshipRecord record = new RelationshipRecord( id, firstNodeId,\n            secondNodeId, typeId );\n        record.setInUse( true );\n        record.setCreated();\n        connectRelationship( firstNode, secondNode, record );\n        getNodeStore().updateRecord( firstNode );\n        getNodeStore().updateRecord( secondNode );\n        record.setNextProp( createPropertyChain( properties ) );\n        getRelationshipStore().updateRecord( record );\n        return id & 0xFFFFFFFFL;\n    }","commit_id":"b7961b9b6217a569ce0fc0bfcc3efa96f7d7f8a5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int createPropertyChain( Map<String,Object> properties )\n    {\n        if ( properties == null )\n        {\n            return Record.NO_NEXT_PROPERTY.intValue();\n        }\n        PropertyStore propStore = getPropertyStore();\n        List<PropertyRecord> propRecords = new ArrayList<PropertyRecord>();\n        PropertyRecord prevRecord = null;\n        for ( Entry<String,Object> entry : properties.entrySet() )\n        {\n            int keyId = indexHolder.getKeyId( entry.getKey() );\n            if ( keyId == -1 )\n            {\n                keyId = createNewPropertyIndex( entry.getKey() );\n            }\n            int propertyId = propStore.nextId();\n            PropertyRecord propertyRecord = new PropertyRecord( propertyId );\n            propertyRecord.setInUse( true );\n            propertyRecord.setCreated();\n            propStore.encodeValue( propertyRecord, entry.getValue() );\n            if ( prevRecord != null )\n            {\n                prevRecord.setPrevProp( propertyId );\n                propertyRecord.setNextProp( prevRecord.getId() );\n            }\n            propRecords.add( propertyRecord );\n            prevRecord = propertyRecord;\n        }\n        // reverse order results in forward update to store\n        for ( int i = propRecords.size() - 1; i >=0; i-- )\n        {\n            propStore.updateRecord( propRecords.get( i ) );\n        }\n        if ( prevRecord != null )\n        {\n            return prevRecord.getId();\n        }\n        return Record.NO_NEXT_PROPERTY.intValue();\n    }","id":57,"modified_method":"private int createPropertyChain( Map<String,Object> properties )\n    {\n        if ( properties == null )\n        {\n            return Record.NO_NEXT_PROPERTY.intValue();\n        }\n        PropertyStore propStore = getPropertyStore();\n        List<PropertyRecord> propRecords = new ArrayList<PropertyRecord>();\n        PropertyRecord prevRecord = null;\n        for ( Entry<String,Object> entry : properties.entrySet() )\n        {\n            int keyId = indexHolder.getKeyId( entry.getKey() );\n            if ( keyId == -1 )\n            {\n                keyId = createNewPropertyIndex( entry.getKey() );\n            }\n            int propertyId = propStore.nextId();\n            PropertyRecord propertyRecord = new PropertyRecord( propertyId );\n            propertyRecord.setInUse( true );\n            propertyRecord.setCreated();\n            propertyRecord.setKeyIndexId( keyId );\n            propStore.encodeValue( propertyRecord, entry.getValue() );\n            if ( prevRecord != null )\n            {\n                prevRecord.setPrevProp( propertyId );\n                propertyRecord.setNextProp( prevRecord.getId() );\n            }\n            propRecords.add( propertyRecord );\n            prevRecord = propertyRecord;\n        }\n        // reverse order results in forward update to store\n        for ( int i = propRecords.size() - 1; i >=0; i-- )\n        {\n            propStore.updateRecord( propRecords.get( i ) );\n        }\n        if ( prevRecord != null )\n        {\n            return prevRecord.getId();\n        }\n        return Record.NO_NEXT_PROPERTY.intValue();\n    }","commit_id":"b7961b9b6217a569ce0fc0bfcc3efa96f7d7f8a5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String fixPath( String dir )\n    {\n        File directories = new File( dir );\n        if ( !directories.exists() )\n        {\n            if ( !directories.mkdirs() )\n            {\n                throw new RuntimeException( \"Unable to create directory path[\"\n                    + storeDir + \"] for Neo store.\" );\n            }\n        }\n        String fileSeparator = System.getProperty( \"file.separator\" );\n        if ( \"\\\\\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '/', '\\\\' );\n        }\n        else if ( \"/\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '\\\\', '/' );\n        }\n        String store = dir + fileSeparator + \"neostore.db\";\n        if ( !new File( store).exists() )\n        {\n            NeoStore.createStore( store );\n        }\n        return store;\n    }","id":58,"modified_method":"private String fixPath( String dir )\n    {\n        File directories = new File( dir );\n        if ( !directories.exists() )\n        {\n            if ( !directories.mkdirs() )\n            {\n                throw new RuntimeException( \"Unable to create directory path[\"\n                    + storeDir + \"] for Neo store.\" );\n            }\n        }\n        String fileSeparator = System.getProperty( \"file.separator\" );\n        if ( \"\\\\\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '/', '\\\\' );\n        }\n        else if ( \"/\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '\\\\', '/' );\n        }\n        String store = dir + fileSeparator + \"neostore\";\n        if ( !new File( store).exists() )\n        {\n            NeoStore.createStore( store );\n        }\n        return store;\n    }","commit_id":"b7961b9b6217a569ce0fc0bfcc3efa96f7d7f8a5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int createPropertyChain( Map<String,Object> properties )\n    {\n        if ( properties == null )\n        {\n            return Record.NO_NEXT_PROPERTY.intValue();\n        }\n        PropertyStore propStore = getPropertyStore();\n        List<PropertyRecord> propRecords = new ArrayList<PropertyRecord>();\n        PropertyRecord prevRecord = null;\n        for ( Entry<String,Object> entry : properties.entrySet() )\n        {\n            int keyId = indexHolder.getKeyId( entry.getKey() );\n            if ( keyId == -1 )\n            {\n                keyId = createNewPropertyIndex( entry.getKey() );\n            }\n            int propertyId = propStore.nextId();\n            PropertyRecord propertyRecord = new PropertyRecord( propertyId );\n            propertyRecord.setInUse( true );\n            propertyRecord.setCreated();\n            propStore.encodeValue( propertyRecord, entry.getValue() );\n            if ( prevRecord != null )\n            {\n                prevRecord.setPrevProp( propertyId );\n                propertyRecord.setNextProp( prevRecord.getId() );\n            }\n            propRecords.add( propertyRecord );\n            prevRecord = propertyRecord;\n        }\n        // reverse order results in forward update to store\n        for ( int i = propRecords.size() - 1; i >=0; i-- )\n        {\n            propStore.updateRecord( propRecords.get( i ) );\n        }\n        if ( prevRecord != null )\n        {\n            return prevRecord.getId();\n        }\n        return Record.NO_NEXT_PROPERTY.intValue();\n    }","id":59,"modified_method":"private int createPropertyChain( Map<String,Object> properties )\n    {\n        if ( properties == null )\n        {\n            return Record.NO_NEXT_PROPERTY.intValue();\n        }\n        PropertyStore propStore = getPropertyStore();\n        List<PropertyRecord> propRecords = new ArrayList<PropertyRecord>();\n        PropertyRecord prevRecord = null;\n        for ( Entry<String,Object> entry : properties.entrySet() )\n        {\n            int keyId = indexHolder.getKeyId( entry.getKey() );\n            if ( keyId == -1 )\n            {\n                keyId = createNewPropertyIndex( entry.getKey() );\n            }\n            int propertyId = propStore.nextId();\n            PropertyRecord propertyRecord = new PropertyRecord( propertyId );\n            propertyRecord.setInUse( true );\n            propertyRecord.setCreated();\n            propertyRecord.setKeyIndexId( keyId );\n            propStore.encodeValue( propertyRecord, entry.getValue() );\n            if ( prevRecord != null )\n            {\n                prevRecord.setPrevProp( propertyId );\n                propertyRecord.setNextProp( prevRecord.getId() );\n            }\n            propRecords.add( propertyRecord );\n            prevRecord = propertyRecord;\n        }\n        // reverse order results in forward update to store\n        for ( int i = propRecords.size() - 1; i >=0; i-- )\n        {\n            propStore.updateRecord( propRecords.get( i ) );\n        }\n        if ( prevRecord != null )\n        {\n            return prevRecord.getId();\n        }\n        return Record.NO_NEXT_PROPERTY.intValue();\n    }","commit_id":"2745fbfa91f80001d361da0c8a6fd30423ab6c20","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String fixPath( String dir )\n    {\n        File directories = new File( dir );\n        if ( !directories.exists() )\n        {\n            if ( !directories.mkdirs() )\n            {\n                throw new RuntimeException( \"Unable to create directory path[\"\n                    + storeDir + \"] for Neo store.\" );\n            }\n        }\n        String fileSeparator = System.getProperty( \"file.separator\" );\n        if ( \"\\\\\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '/', '\\\\' );\n        }\n        else if ( \"/\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '\\\\', '/' );\n        }\n        String store = dir + fileSeparator + \"neostore.db\";\n        if ( !new File( store).exists() )\n        {\n            NeoStore.createStore( store );\n        }\n        return store;\n    }","id":60,"modified_method":"private String fixPath( String dir )\n    {\n        File directories = new File( dir );\n        if ( !directories.exists() )\n        {\n            if ( !directories.mkdirs() )\n            {\n                throw new RuntimeException( \"Unable to create directory path[\"\n                    + storeDir + \"] for Neo store.\" );\n            }\n        }\n        String fileSeparator = System.getProperty( \"file.separator\" );\n        if ( \"\\\\\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '/', '\\\\' );\n        }\n        else if ( \"/\".equals( fileSeparator ) )\n        {\n            dir = dir.replace( '\\\\', '/' );\n        }\n        String store = dir + fileSeparator + \"neostore\";\n        if ( !new File( store).exists() )\n        {\n            NeoStore.createStore( store );\n        }\n        return store;\n    }","commit_id":"2745fbfa91f80001d361da0c8a6fd30423ab6c20","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                firstNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                secondNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","id":61,"modified_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord( \n                firstNode.getNextRel() );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord(  \n                secondNode.getNextRel() );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","commit_id":"2745fbfa91f80001d361da0c8a6fd30423ab6c20","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long createRelationship( long node1, long node2, RelationshipType\n        type, Map<String,Object> properties )\n    {\n        int firstNodeId = (int) (node1 & 0xFFFFFFFF );\n        int secondNodeId = (int) (node2 & 0xFFFFFFFF );\n        NodeRecord firstNode = getNodeRecord( node1 );\n        NodeRecord secondNode = getNodeRecord( secondNodeId );\n        int typeId = typeHolder.getTypeId( type.name() );\n        if ( typeId == -1 )\n        {\n            typeId = createNewRelationshipType( type.name() );\n        }\n        int id = getRelationshipStore().nextId(); \n        RelationshipRecord record = new RelationshipRecord( id, firstNodeId,\n            secondNodeId, typeId );\n        record.setInUse( true );\n        record.setCreated();\n        connectRelationship( firstNode, secondNode, record );\n        getNodeStore().updateRecord( firstNode );\n        getNodeStore().updateRecord( secondNode );\n        record.setNextProp( createPropertyChain( properties ) );\n        getRelationshipStore().updateRecord( record );\n        return id & 0xFFFFFFFFL;\n    }","id":62,"modified_method":"public long createRelationship( long node1, long node2, RelationshipType\n        type, Map<String,Object> properties )\n    {\n        int firstNodeId = (int) (node1 & 0xFFFFFFFF );\n        int secondNodeId = (int) (node2 & 0xFFFFFFFF );\n        NodeRecord firstNode = getNodeRecord( node1 );\n        NodeRecord secondNode = getNodeRecord( node2 );\n        int typeId = typeHolder.getTypeId( type.name() );\n        if ( typeId == -1 )\n        {\n            typeId = createNewRelationshipType( type.name() );\n        }\n        int id = getRelationshipStore().nextId(); \n        RelationshipRecord record = new RelationshipRecord( id, firstNodeId,\n            secondNodeId, typeId );\n        record.setInUse( true );\n        record.setCreated();\n        connectRelationship( firstNode, secondNode, record );\n        getNodeStore().updateRecord( firstNode );\n        getNodeStore().updateRecord( secondNode );\n        record.setNextProp( createPropertyChain( properties ) );\n        getRelationshipStore().updateRecord( record );\n        return id & 0xFFFFFFFFL;\n    }","commit_id":"2745fbfa91f80001d361da0c8a6fd30423ab6c20","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * Main entry point for the import of a file hierarchy.\n   * Instantiates the engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if (!bs.mkdirs() && bs.exists())\n          throw new IOException(BACKINGEXISTS + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      if(Prop.fuse) {\n        atts.add(MOUNTPOINT  , token(mountpoint));\n        atts.add(SIZE        , Token.EMPTY);\n        atts.add(BACKINGSTORE, token(mybackingpath));\n      } else {\n        atts.add(NAME        , NOTMOUNTED);\n        atts.add(SIZE        , Token.EMPTY);\n        atts.add(BACKINGSTORE, token(fsimportpath));\n      }\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() :\n        new File[] { new File(fsimportpath).getCanonicalFile() }) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","id":63,"modified_method":"/**\n   * Main entry point for the import of a file hierarchy.\n   * Instantiates the engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if (!bs.mkdirs() && bs.exists())\n          throw new IOException(BACKINGEXISTS + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      final byte[] mnt = Prop.fuse ? token(mountpoint) : NOTMOUNTED;\n      final byte[] bck = Prop.fuse ? token(mybackingpath) : token(fsimportpath);\n      atts.add(MOUNTPOINT  , mnt);\n      atts.add(SIZE        , Token.EMPTY);\n      atts.add(BACKINGSTORE, bck);\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() :\n        new File[] { new File(fsimportpath).getCanonicalFile() }) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","commit_id":"8af58dd7e555d01091cb3f7a625169ba382627e0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Main entry point for the import of a file hierarchy. Instantiates the\n   * engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if(!bs.mkdirs() && bs.exists()) throw new IOException(BACKINGEXISTS\n          + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      if(Prop.fuse) {\n        atts.add(MOUNTPOINT, token(mountpoint));\n        atts.add(SIZE, Token.EMPTY);\n        atts.add(BACKINGSTORE, token(mybackingpath));\n      } else {\n        atts.add(NAME, NOTMOUNTED);\n        atts.add(SIZE, Token.EMPTY);\n        atts.add(BACKINGSTORE, token(fsimportpath));\n      }\n      if(ADD_TYPE_ATTR) builder.startNS(Token.token(\"xsi\"),\n          Token.token(\"http://www.w3.org/2001/XMLSchema-instance\"));\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() : new File[] { new File(\n          fsimportpath).getCanonicalFile()}) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","id":64,"modified_method":"/**\n   * Main entry point for the import of a file hierarchy. Instantiates the\n   * engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if(!bs.mkdirs() && bs.exists()) throw new IOException(BACKINGEXISTS\n          + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      final byte[] mnt = Prop.fuse ? token(mountpoint) : NOTMOUNTED;\n      final byte[] bck = Prop.fuse ? token(mybackingpath) : token(fsimportpath);\n      atts.add(MOUNTPOINT  , mnt);\n      atts.add(SIZE        , Token.EMPTY);\n      atts.add(BACKINGSTORE, bck);\n\n      if(ADD_TYPE_ATTR) builder.startNS(Token.token(\"xsi\"),\n          Token.token(\"http://www.w3.org/2001/XMLSchema-instance\"));\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() : new File[] { new File(\n          fsimportpath).getCanonicalFile()}) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","commit_id":"8af58dd7e555d01091cb3f7a625169ba382627e0","url":"https://github.com/BaseXdb/basex"},{"original_method":"private synchronized ForeignSource get(File file) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(ForeignSource.class).unmarshal(new StreamSource(file), ForeignSource.class).getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + file.getPath(), e);\n        }\n    }","id":65,"modified_method":"private synchronized ForeignSource get(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(ForeignSource.class);\n            JAXBElement<ForeignSource> fs = um.unmarshal(new StreamSource(inputFile), ForeignSource.class);\n            return fs.getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"291622bb707ffdcbefb83873590ce1447a84e13d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(Requisition.class).unmarshal(new StreamSource(inputFile), Requisition.class).getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","id":66,"modified_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(Requisition.class);\n            JAXBElement<Requisition> req = um.unmarshal(new StreamSource(inputFile), Requisition.class);\n            return req.getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"291622bb707ffdcbefb83873590ce1447a84e13d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Converts the SNMP iformation from the event into a string that can be\n     * stored into the database. The information is formatted in by separating\n     * the of the textual fields with a delimiter character (a comma ',').\n     * <\/P>\n     * \n     * <P>\n     * If the enterprise id text information is not present then the string will\n     * have only two commas. An extra comma is not added to signify the missing\n     * field.\n     * <\/P>\n     * \n     * @see Constants#DB_ATTRIB_DELIM\n     * @see Constants#escape\n     * \n     * @return The smnpblock as a string\n     */\n    public static String format(Snmp info, int maxlen) {\n        if (info == null)\n            return null;\n\n        // id\n        StringBuffer snmpStr = new StringBuffer(info.getId());\n\n        // id text\n        if (info.getIdtext() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Constants.escape(info.getIdtext(), Constants.DB_ATTRIB_DELIM));\n        } else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // version\n        snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getVersion());\n\n        // specific\n        if (info.hasSpecific())\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getSpecific()));\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // generic\n        if (info.hasGeneric())\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getGeneric()));\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // community\n        if (info.getCommunity() != null)\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getCommunity());\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        return Constants.format(snmpStr.toString(), maxlen);\n    }","id":67,"modified_method":"/**\n     * <P>\n     * Converts the SNMP information from the event into a string that can be\n     * stored into the database. The information is formatted in by separating\n     * the of the textual fields with a delimiter character (a comma ',').\n     * <\/P>\n     * \n     * <P>\n     * If the enterprise id text information is not present then the string will\n     * have only two commas. An extra comma is not added to signify the missing\n     * field.\n     * <\/P>\n     * \n     * @see Constants#DB_ATTRIB_DELIM\n     * @see Constants#escape\n     * \n     * @return The smnpblock as a string\n     */\n    public static String format(Snmp info, int maxlen) {\n        if (info == null) {\n            return null;\n        }\n\n        // id\n        StringBuffer snmpStr = new StringBuffer(info.getId());\n\n        // id text\n        if (info.getIdtext() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Constants.escape(info.getIdtext(), Constants.DB_ATTRIB_DELIM));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // version\n        snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getVersion());\n\n        // specific\n        if (info.hasSpecific()) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getSpecific()));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // generic\n        if (info.hasGeneric()) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getGeneric()));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // community\n        if (info.getCommunity() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getCommunity());\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        return Constants.format(snmpStr.toString(), maxlen);\n    }","commit_id":"291622bb707ffdcbefb83873590ce1447a84e13d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized ForeignSource get(File file) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(ForeignSource.class).unmarshal(new StreamSource(file), ForeignSource.class).getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + file.getPath(), e);\n        }\n    }","id":68,"modified_method":"private synchronized ForeignSource get(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(ForeignSource.class);\n            JAXBElement<ForeignSource> fs = um.unmarshal(new StreamSource(inputFile), ForeignSource.class);\n            return fs.getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"0dfbd0198a1c6c4dcc89cebaf4c6d188ff1f9c27","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(Requisition.class).unmarshal(new StreamSource(inputFile), Requisition.class).getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","id":69,"modified_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(Requisition.class);\n            JAXBElement<Requisition> req = um.unmarshal(new StreamSource(inputFile), Requisition.class);\n            return req.getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"0dfbd0198a1c6c4dcc89cebaf4c6d188ff1f9c27","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Converts the SNMP iformation from the event into a string that can be\n     * stored into the database. The information is formatted in by separating\n     * the of the textual fields with a delimiter character (a comma ',').\n     * <\/P>\n     * \n     * <P>\n     * If the enterprise id text information is not present then the string will\n     * have only two commas. An extra comma is not added to signify the missing\n     * field.\n     * <\/P>\n     * \n     * @see Constants#DB_ATTRIB_DELIM\n     * @see Constants#escape\n     * \n     * @return The smnpblock as a string\n     */\n    public static String format(Snmp info, int maxlen) {\n        if (info == null)\n            return null;\n\n        // id\n        StringBuffer snmpStr = new StringBuffer(info.getId());\n\n        // id text\n        if (info.getIdtext() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Constants.escape(info.getIdtext(), Constants.DB_ATTRIB_DELIM));\n        } else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // version\n        snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getVersion());\n\n        // specific\n        if (info.hasSpecific())\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getSpecific()));\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // generic\n        if (info.hasGeneric())\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getGeneric()));\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // community\n        if (info.getCommunity() != null)\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getCommunity());\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        return Constants.format(snmpStr.toString(), maxlen);\n    }","id":70,"modified_method":"/**\n     * <P>\n     * Converts the SNMP information from the event into a string that can be\n     * stored into the database. The information is formatted in by separating\n     * the of the textual fields with a delimiter character (a comma ',').\n     * <\/P>\n     * \n     * <P>\n     * If the enterprise id text information is not present then the string will\n     * have only two commas. An extra comma is not added to signify the missing\n     * field.\n     * <\/P>\n     * \n     * @see Constants#DB_ATTRIB_DELIM\n     * @see Constants#escape\n     * \n     * @return The smnpblock as a string\n     */\n    public static String format(Snmp info, int maxlen) {\n        if (info == null) {\n            return null;\n        }\n\n        // id\n        StringBuffer snmpStr = new StringBuffer(info.getId());\n\n        // id text\n        if (info.getIdtext() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Constants.escape(info.getIdtext(), Constants.DB_ATTRIB_DELIM));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // version\n        snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getVersion());\n\n        // specific\n        if (info.hasSpecific()) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getSpecific()));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // generic\n        if (info.hasGeneric()) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getGeneric()));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // community\n        if (info.getCommunity() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getCommunity());\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        return Constants.format(snmpStr.toString(), maxlen);\n    }","commit_id":"0dfbd0198a1c6c4dcc89cebaf4c6d188ff1f9c27","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized ForeignSource get(File file) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(ForeignSource.class).unmarshal(new StreamSource(file), ForeignSource.class).getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + file.getPath(), e);\n        }\n    }","id":71,"modified_method":"private synchronized ForeignSource get(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(ForeignSource.class);\n            JAXBElement<ForeignSource> fs = um.unmarshal(new StreamSource(inputFile), ForeignSource.class);\n            return fs.getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"2f3066172d17029427faf81bca6b5c598c19c5cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(Requisition.class).unmarshal(new StreamSource(inputFile), Requisition.class).getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","id":72,"modified_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(Requisition.class);\n            JAXBElement<Requisition> req = um.unmarshal(new StreamSource(inputFile), Requisition.class);\n            return req.getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"2f3066172d17029427faf81bca6b5c598c19c5cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Converts the SNMP iformation from the event into a string that can be\n     * stored into the database. The information is formatted in by separating\n     * the of the textual fields with a delimiter character (a comma ',').\n     * <\/P>\n     * \n     * <P>\n     * If the enterprise id text information is not present then the string will\n     * have only two commas. An extra comma is not added to signify the missing\n     * field.\n     * <\/P>\n     * \n     * @see Constants#DB_ATTRIB_DELIM\n     * @see Constants#escape\n     * \n     * @return The smnpblock as a string\n     */\n    public static String format(Snmp info, int maxlen) {\n        if (info == null)\n            return null;\n\n        // id\n        StringBuffer snmpStr = new StringBuffer(info.getId());\n\n        // id text\n        if (info.getIdtext() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Constants.escape(info.getIdtext(), Constants.DB_ATTRIB_DELIM));\n        } else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // version\n        snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getVersion());\n\n        // specific\n        if (info.hasSpecific())\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getSpecific()));\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // generic\n        if (info.hasGeneric())\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getGeneric()));\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        // community\n        if (info.getCommunity() != null)\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getCommunity());\n        else\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n\n        return Constants.format(snmpStr.toString(), maxlen);\n    }","id":73,"modified_method":"/**\n     * <P>\n     * Converts the SNMP information from the event into a string that can be\n     * stored into the database. The information is formatted in by separating\n     * the of the textual fields with a delimiter character (a comma ',').\n     * <\/P>\n     * \n     * <P>\n     * If the enterprise id text information is not present then the string will\n     * have only two commas. An extra comma is not added to signify the missing\n     * field.\n     * <\/P>\n     * \n     * @see Constants#DB_ATTRIB_DELIM\n     * @see Constants#escape\n     * \n     * @return The smnpblock as a string\n     */\n    public static String format(Snmp info, int maxlen) {\n        if (info == null) {\n            return null;\n        }\n\n        // id\n        StringBuffer snmpStr = new StringBuffer(info.getId());\n\n        // id text\n        if (info.getIdtext() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Constants.escape(info.getIdtext(), Constants.DB_ATTRIB_DELIM));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // version\n        snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getVersion());\n\n        // specific\n        if (info.hasSpecific()) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getSpecific()));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // generic\n        if (info.hasGeneric()) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + Integer.toString(info.getGeneric()));\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        // community\n        if (info.getCommunity() != null) {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + info.getCommunity());\n        } else {\n            snmpStr.append(Constants.DB_ATTRIB_DELIM + \"undefined\");\n        }\n\n        return Constants.format(snmpStr.toString(), maxlen);\n    }","commit_id":"2f3066172d17029427faf81bca6b5c598c19c5cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"KernelNodeStoreBranch(KernelNodeStore store, CommitEditor editor) {\n        this.store = store;\n        if (editor == null) {\n            this.editor = store.getEditor();\n        } else {\n            this.editor = new CompositeEditor(store.getEditor(), editor);\n        }\n\n        MicroKernel kernel = store.getKernel();\n        this.branchRevision = kernel.branch(null);\n        this.currentRoot = new KernelNodeState(kernel, \"/\", branchRevision);\n        this.base = currentRoot;\n        this.committed = currentRoot;\n    }","id":74,"modified_method":"KernelNodeStoreBranch(KernelNodeStore store) {\n        this.store = store;\n        MicroKernel kernel = store.getKernel();\n        this.branchRevision = kernel.branch(null);\n        this.currentRoot = new KernelNodeState(kernel, \"/\", branchRevision);\n        this.base = currentRoot;\n        this.committed = currentRoot;\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void beforeCommitHook() throws CommitFailedException {\n        store.setEditor(new CommitEditor() {\n            @Override\n            public NodeState editCommit(\n                    NodeStore store, NodeState before, NodeState after) {\n                NodeBuilder rootBuilder = store.getBuilder(after);\n                NodeBuilder testBuilder = store.getBuilder(after.getChildNode(\"test\"));\n                testBuilder.setNode(\"fromHook\", MemoryNodeState.EMPTY_NODE);\n                rootBuilder.setNode(\"test\", testBuilder.getNodeState());\n                return rootBuilder.getNodeState();\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder = store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        final CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch(EmptyEditor.INSTANCE);\n        branch.setRoot(newRoot);\n        branch.merge();\n\n        NodeState test = store.getRoot().getChildNode(\"test\");\n        assertNotNull(test.getChildNode(\"newNode\"));\n        assertNotNull(test.getChildNode(\"fromHook\"));\n        assertNull(test.getChildNode(\"a\"));\n        assertEquals(fortyTwo, test.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(test, store.getRoot().getChildNode(\"test\"));\n    }","id":75,"modified_method":"@Test\n    public void beforeCommitHook() throws CommitFailedException {\n        store.setEditor(new CommitEditor() {\n            @Override\n            public NodeState editCommit(\n                    NodeStore store, NodeState before, NodeState after) {\n                NodeBuilder rootBuilder = store.getBuilder(after);\n                NodeBuilder testBuilder = store.getBuilder(after.getChildNode(\"test\"));\n                testBuilder.setNode(\"fromHook\", MemoryNodeState.EMPTY_NODE);\n                rootBuilder.setNode(\"test\", testBuilder.getNodeState());\n                return rootBuilder.getNodeState();\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder = store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        final CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch();\n        branch.setRoot(newRoot);\n        branch.merge(EmptyEditor.INSTANCE);\n\n        NodeState test = store.getRoot().getChildNode(\"test\");\n        assertNotNull(test.getChildNode(\"newNode\"));\n        assertNotNull(test.getChildNode(\"fromHook\"));\n        assertNull(test.getChildNode(\"a\"));\n        assertEquals(fortyTwo, test.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(test, store.getRoot().getChildNode(\"test\"));\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void afterCommitHook() throws CommitFailedException {\n        final NodeState[] states = new NodeState[2]; // { before, after }\n        store.setObserver(new Observer() {\n            @Override\n            public void contentChanged(\n                    NodeStore store, NodeState before, NodeState after) {\n                states[0] = before;\n                states[1] = after;\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder= store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch(EmptyEditor.INSTANCE);\n        branch.setRoot(newRoot);\n        branch.merge();\n        store.getRoot(); // triggers the observer\n\n        NodeState before = states[0];\n        NodeState after = states[1];\n        assertNotNull(before);\n        assertNotNull(after);\n\n        assertNull(before.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNotNull(after.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNull(after.getChildNode(\"test\").getChildNode(\"a\"));\n        assertEquals(fortyTwo, after.getChildNode(\"test\").getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(newRoot, after);\n    }","id":76,"modified_method":"@Test\n    public void afterCommitHook() throws CommitFailedException {\n        final NodeState[] states = new NodeState[2]; // { before, after }\n        store.setObserver(new Observer() {\n            @Override\n            public void contentChanged(\n                    NodeStore store, NodeState before, NodeState after) {\n                states[0] = before;\n                states[1] = after;\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder= store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch();\n        branch.setRoot(newRoot);\n        branch.merge(EmptyEditor.INSTANCE);\n        store.getRoot(); // triggers the observer\n\n        NodeState before = states[0];\n        NodeState after = states[1];\n        assertNotNull(before);\n        assertNotNull(after);\n\n        assertNull(before.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNotNull(after.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNull(after.getChildNode(\"test\").getChildNode(\"a\"));\n        assertEquals(fortyTwo, after.getChildNode(\"test\").getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(newRoot, after);\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void branch() throws CommitFailedException {\n        NodeStoreBranch branch = store.branch(EmptyEditor.INSTANCE);\n\n        NodeBuilder rootBuilder = store.getBuilder(branch.getRoot());\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        testBuilder.removeNode(\"x\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        // Assert changes are present in the builder\n        NodeState testState = rootBuilder.getNodeState().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.setRoot(rootBuilder.getNodeState());\n\n        // Assert changes are present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.merge();\n\n        // Assert changes are present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n    }","id":77,"modified_method":"@Test\n    public void branch() throws CommitFailedException {\n        NodeStoreBranch branch = store.branch();\n\n        NodeBuilder rootBuilder = store.getBuilder(branch.getRoot());\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        testBuilder.removeNode(\"x\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        // Assert changes are present in the builder\n        NodeState testState = rootBuilder.getNodeState().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.setRoot(rootBuilder.getNodeState());\n\n        // Assert changes are present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.merge(EmptyEditor.INSTANCE);\n\n        // Assert changes are present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public final void refresh() {\n        branch = store.branch(commitEditor);\n        rootTree = TreeImpl.createRoot(this);\n        permissions = this.accessControlContext.getPermissions();\n    }","id":78,"modified_method":"@Override\n    public final void refresh() {\n        branch = store.branch();\n        rootTree = TreeImpl.createRoot(this);\n        permissions = this.accessControlContext.getPermissions();\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void commit(ConflictHandler conflictHandler) throws CommitFailedException {\n        rebase(conflictHandler);\n        purgePendingChanges();\n        branch.merge();\n        refresh();\n    }","id":79,"modified_method":"@Override\n    public void commit(ConflictHandler conflictHandler) throws CommitFailedException {\n        rebase(conflictHandler);\n        purgePendingChanges();\n        branch.merge(commitEditor);\n        refresh();\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Search for keywords using lucene search. It returns results for pages and attachments. The query can be executed\n     * on multiple wikis if the wikis parameter is specified. Otherwise it's run only on the wiki specified by\n     * defaultWikiName. wikis and defaultWikiName parameters cannot be both null.\n     * \n     * @param query\n     * @param defaultWikiName the name of the wiki to run the query on (can be null)\n     * @param wikis the name of the wikis to run the query on (can be null). This takes precedence if defaultWikiName is\n     *            specified as well.\n     * @param hasProgrammingRights\n     * @param orderField\n     * @param order\n     * @param number the number of results to be returned. If it's -1 then the first 20 results are returned.\n     * @param start 0-based start offset\n     * @param withPrettyNames\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchLucene(String query, String defaultWikiName, String wikis,\n        boolean hasProgrammingRights, String orderField, String order, int number, int start, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (query == null) {\n                return result;\n            }\n\n            /*\n             * One of the two must be non-null. If default wiki name is non-null and wikis is null, then it's a local\n             * search in a specific wiki. If wiki name is null and wikis is non-null it's a global query on different\n             * wikis. If both of them are non-null then the wikis parameter takes the precedence.\n             */\n            if (defaultWikiName == null && wikis == null) {\n                return result;\n            }\n\n            if (!hasProgrammingRights) {\n                query += \" AND NOT space:XWiki AND NOT space:Admin AND NOT space:Panels AND NOT name:WebPreferences\";\n            }\n\n            try {\n                XWikiContext context = Utils.getXWikiContext(componentManager);\n                LucenePlugin lucene = (LucenePlugin) Utils.getXWiki(componentManager).getPlugin(\"lucene\", context);\n\n                /*\n                 * Compute the parameter to be passed to the plugin for ordering: orderField (for ordering on orderField\n                 * in ascending order) or -orderFiled (for descending order)\n                 */\n                String orderParameter = \"\";\n                if (!StringUtils.isBlank(orderField)) {\n                    if (\"desc\".equals(order)) {\n                        orderParameter = String.format(\"-%s\", orderField);\n                    } else {\n                        orderParameter = orderField;\n                    }\n                }\n\n                SearchResults luceneSearchResults =\n                    lucene.getSearchResults(query, orderParameter, (wikis == null) ? defaultWikiName : wikis, \"\",\n                        context);\n\n                /*\n                 * Return only the first 20 results otherwise specified. It also seems that Lucene indexing starts at 1\n                 * (though starting from 0 works as well, and gives the samer results as if starting from 1). To keep\n                 * things consistent we add 1 to the passed start value (which is always 0-based).\n                 */\n                List<com.xpn.xwiki.plugin.lucene.SearchResult> luceneResults =\n                    luceneSearchResults.getResults(start + 1, (number == -1) ? 20 : number);\n\n                /* Build the result. */\n                for (com.xpn.xwiki.plugin.lucene.SearchResult luceneSearchResult : luceneResults) {\n                    String wikiName = luceneSearchResult.getWiki();\n                    String spaceName = luceneSearchResult.getSpace();\n                    String pageName = luceneSearchResult.getName();\n                    String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n\n                    /* Check if the user has the right to see the found document */\n                    if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                        String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n                        Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                        String title = doc.getDisplayTitle();\n\n                        SearchResult searchResult = objectFactory.createSearchResult();\n\n                        searchResult.setPageFullName(pageFullName);\n                        searchResult.setTitle(title);\n                        searchResult.setWiki(wikiName);\n                        searchResult.setSpace(spaceName);\n                        searchResult.setPageName(pageName);\n                        searchResult.setVersion(doc.getVersion());\n\n                        /*\n                         * Check if the result is a page or an attachment, and fill the corresponding fields in the\n                         * result accordingly.\n                         */\n                        if (luceneSearchResult.getType().equals(LucenePlugin.DOCTYPE_WIKIPAGE)) {\n                            searchResult.setType(\"page\");\n                            searchResult.setId(Utils.getPageId(wikiName, spaceName, pageName));\n                        } else {\n                            searchResult.setType(\"file\");\n                            searchResult.setId(String.format(\"%s@%s\", Utils.getPageId(wikiName, pageFullName),\n                                luceneSearchResult.getFilename()));\n                            searchResult.setFilename(luceneSearchResult.getFilename());\n\n                            String attachmentUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(AttachmentResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        URLEncoder.encode(luceneSearchResult.getFilename(), \"UTF-8\")).toString();\n\n                            Link attachmentLink = new Link();\n                            attachmentLink.setHref(attachmentUri);\n                            attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n                            searchResult.getLinks().add(attachmentLink);\n                        }\n\n                        searchResult.setScore(luceneSearchResult.getScore());\n                        searchResult.setAuthor(luceneSearchResult.getAuthor());\n                        Calendar calendar = Calendar.getInstance();\n                        calendar.setTime(doc.getDate());\n                        searchResult.setModified(calendar);\n\n                        if (withPrettyNames) {\n                            searchResult.setAuthorName(Utils.getAuthorName(luceneSearchResult.getAuthor(),\n                                componentManager));\n                        }\n\n                        String language = luceneSearchResult.getLanguage();\n                        if (language.equals(\"default\")) {\n                            language = \"\";\n                        }\n\n                        String pageUri = null;\n                        try {\n                            if (StringUtils.isBlank(language)) {\n                                pageUri =\n                                    UriBuilder\n                                        .fromUri(this.uriInfo.getBaseUri())\n                                        .path(PageResource.class)\n                                        .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                            URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                        .toString();\n                            } else {\n                                searchResult.setLanguage(language);\n                                pageUri =\n                                    UriBuilder\n                                        .fromUri(this.uriInfo.getBaseUri())\n                                        .path(PageTranslationResource.class)\n                                        .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                            URLEncoder.encode(spaceName, \"UTF-8\"),\n                                            URLEncoder.encode(pageName, \"UTF-8\"), language).toString();\n                            }\n                        } catch (UnsupportedEncodingException ex) {\n                            // This should never happen, UTF-8 is always valid.\n                        }\n\n                        Link pageLink = new Link();\n                        pageLink.setHref(pageUri);\n                        pageLink.setRel(Relations.PAGE);\n                        searchResult.getLinks().add(pageLink);\n\n                        result.add(searchResult);\n                    }\n                }\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Error performing lucene search\", e);\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":80,"modified_method":"/**\n     * Search for keywords using lucene search. It returns results for pages and attachments. The query can be executed\n     * on multiple wikis if the wikis parameter is specified. Otherwise it's run only on the wiki specified by\n     * defaultWikiName. wikis and defaultWikiName parameters cannot be both null.\n     * \n     * @param query\n     * @param defaultWikiName the name of the wiki to run the query on (can be null)\n     * @param wikis the name of the wikis to run the query on (can be null). This takes precedence if defaultWikiName is\n     *            specified as well.\n     * @param hasProgrammingRights\n     * @param orderField\n     * @param order\n     * @param number the number of results to be returned. If it's -1 then the first 20 results are returned.\n     * @param start 0-based start offset\n     * @param withPrettyNames\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchLucene(String query, String defaultWikiName, String wikis,\n        boolean hasProgrammingRights, String orderField, String order, int number, int start, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        \n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (query == null) {\n                return result;\n            }\n\n            /*\n             * One of the two must be non-null. If default wiki name is non-null and wikis is null, then it's a local\n             * search in a specific wiki. If wiki name is null and wikis is non-null it's a global query on different\n             * wikis. If both of them are non-null then the wikis parameter takes the precedence.\n             */\n            if (defaultWikiName == null && wikis == null) {\n                return result;\n            }\n\n            if (!hasProgrammingRights) {\n                query += \" AND NOT space:XWiki AND NOT space:Admin AND NOT space:Panels AND NOT name:WebPreferences\";\n            }\n\n            try {\n                XWikiContext context = Utils.getXWikiContext(componentManager);\n                LucenePlugin lucene = (LucenePlugin) Utils.getXWiki(componentManager).getPlugin(\"lucene\", context);\n\n                /*\n                 * Compute the parameter to be passed to the plugin for ordering: orderField (for ordering on orderField\n                 * in ascending order) or -orderFiled (for descending order)\n                 */\n                String orderParameter = \"\";\n                if (!StringUtils.isBlank(orderField)) {\n                    if (\"desc\".equals(order)) {\n                        orderParameter = String.format(\"-%s\", orderField);\n                    } else {\n                        orderParameter = orderField;\n                    }\n                }\n\n                SearchResults luceneSearchResults =\n                    lucene.getSearchResults(query, orderParameter, (wikis == null) ? defaultWikiName : wikis, \"\",\n                        context);\n\n                /*\n                 * Return only the first 20 results otherwise specified. It also seems that Lucene indexing starts at 1\n                 * (though starting from 0 works as well, and gives the samer results as if starting from 1). To keep\n                 * things consistent we add 1 to the passed start value (which is always 0-based).\n                 */\n                List<com.xpn.xwiki.plugin.lucene.SearchResult> luceneResults =\n                    luceneSearchResults.getResults(start + 1, (number == -1) ? 20 : number);\n\n                /* Build the result. */\n                for (com.xpn.xwiki.plugin.lucene.SearchResult luceneSearchResult : luceneResults) {\n                    String wikiName = luceneSearchResult.getWiki();\n                    String spaceName = luceneSearchResult.getSpace();\n                    String pageName = luceneSearchResult.getName();\n                    String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n\n                    /* Check if the user has the right to see the found document */\n                    if (xwikiApi.hasAccessLevel(\"view\", pageId)) {\n                        String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n                        Document doc = xwikiApi.getDocument(pageFullName);\n                        String title = doc.getDisplayTitle();\n\n                        SearchResult searchResult = objectFactory.createSearchResult();\n\n                        searchResult.setPageFullName(pageFullName);\n                        searchResult.setTitle(title);\n                        searchResult.setWiki(wikiName);\n                        searchResult.setSpace(spaceName);\n                        searchResult.setPageName(pageName);\n                        searchResult.setVersion(doc.getVersion());\n\n                        /*\n                         * Check if the result is a page or an attachment, and fill the corresponding fields in the\n                         * result accordingly.\n                         */\n                        if (luceneSearchResult.getType().equals(LucenePlugin.DOCTYPE_WIKIPAGE)) {\n                            searchResult.setType(\"page\");\n                            searchResult.setId(Utils.getPageId(wikiName, spaceName, pageName));\n                        } else {\n                            searchResult.setType(\"file\");\n                            searchResult.setId(String.format(\"%s@%s\", Utils.getPageId(wikiName, pageFullName),\n                                luceneSearchResult.getFilename()));\n                            searchResult.setFilename(luceneSearchResult.getFilename());\n\n                            String attachmentUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(AttachmentResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        URLEncoder.encode(luceneSearchResult.getFilename(), \"UTF-8\")).toString();\n\n                            Link attachmentLink = new Link();\n                            attachmentLink.setHref(attachmentUri);\n                            attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n                            searchResult.getLinks().add(attachmentLink);\n                        }\n\n                        searchResult.setScore(luceneSearchResult.getScore());\n                        searchResult.setAuthor(luceneSearchResult.getAuthor());\n                        Calendar calendar = Calendar.getInstance();\n                        calendar.setTime(doc.getDate());\n                        searchResult.setModified(calendar);\n\n                        if (withPrettyNames) {\n                            searchResult.setAuthorName(Utils.getAuthorName(luceneSearchResult.getAuthor(),\n                                componentManager));\n                        }\n\n                        String language = luceneSearchResult.getLanguage();\n                        if (language.equals(\"default\")) {\n                            language = \"\";\n                        }\n\n                        String pageUri = null;\n                        try {\n                            if (StringUtils.isBlank(language)) {\n                                pageUri =\n                                    UriBuilder\n                                        .fromUri(this.uriInfo.getBaseUri())\n                                        .path(PageResource.class)\n                                        .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                            URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                        .toString();\n                            } else {\n                                searchResult.setLanguage(language);\n                                pageUri =\n                                    UriBuilder\n                                        .fromUri(this.uriInfo.getBaseUri())\n                                        .path(PageTranslationResource.class)\n                                        .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                            URLEncoder.encode(spaceName, \"UTF-8\"),\n                                            URLEncoder.encode(pageName, \"UTF-8\"), language).toString();\n                            }\n                        } catch (UnsupportedEncodingException ex) {\n                            // This should never happen, UTF-8 is always valid.\n                        }\n\n                        Link pageLink = new Link();\n                        pageLink.setHref(pageUri);\n                        pageLink.setRel(Relations.PAGE);\n                        searchResult.getLinks().add(pageLink);\n\n                        result.add(searchResult);\n                    }\n                }\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Error performing lucene search\", e);\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"33349097533fc93369bf6670266a3c96bc1101b9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords the string that will be used in a \"like\" XWQL clause.\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number number of results to be returned.\n     * @param start 0-based start offset.\n     * @param orderField the field to be used to order the results.\n     * @param order \"asc\" or \"desc\"\n     * @param withPrettyNames\n     * @return the results.\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames) throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc where doc.space = :space and ( \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc where ( \");\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        f.format(\"upper(doc.fullName) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"upper(doc.title) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return result;\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\") order by %s\", orderClause);\n            } else {\n                f.format(\n                    \") and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).setOffset(start).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .setOffset(start).execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                /* Check if the user has the right to see the found document */\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n                    }\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":81,"modified_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords the string that will be used in a \"like\" XWQL clause.\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number number of results to be returned.\n     * @param start 0-based start offset.\n     * @param orderField the field to be used to order the results.\n     * @param order \"asc\" or \"desc\"\n     * @param withPrettyNames\n     * @return the results.\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames) throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc where doc.space = :space and ( \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc where ( \");\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        f.format(\"upper(doc.fullName) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"upper(doc.title) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return result;\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\") order by %s\", orderClause);\n            } else {\n                f.format(\n                    \") and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).setOffset(start).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .setOffset(start).execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                /* Check if the user has the right to see the found document */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId)) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n                    }\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"33349097533fc93369bf6670266a3c96bc1101b9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Objects.\n     * \n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number number of results to be returned\n     * @param start 0-based start offset\n     * @param orderField the field to be used to order the results\n     * @param order \"asc\" or \"desc\"\n     * @param withPrettyNames\n     * @return the results\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaceName, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                /* Check if the user has the right to see the found document */\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n                    }\n\n                    String pageUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(PageResource.class)\n                            .build(wikiName, spaceName, pageName).toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(ObjectResource.class)\n                            .build(wikiName, spaceName, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":82,"modified_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Objects.\n     * \n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number number of results to be returned\n     * @param start 0-based start offset\n     * @param orderField the field to be used to order the results\n     * @param order \"asc\" or \"desc\"\n     * @param withPrettyNames\n     * @return the results\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        \n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaceName, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                /* Check if the user has the right to see the found document */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId)) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n                    }\n\n                    String pageUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(PageResource.class)\n                            .build(wikiName, spaceName, pageName).toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(ObjectResource.class)\n                            .build(wikiName, spaceName, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"33349097533fc93369bf6670266a3c96bc1101b9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Execute a database query using a supported query language. Limit search to documents.\n     * \n     * @param query\n     * @param queryLanguage\n     * @param wikiName\n     * @param hasProgrammingRights\n     * @param distinct\n     * @param number number of results to be returned\n     * @param start 0-based start offset\n     * @param withPrettyNames Add the pretty names for users\n     * @param className Add object of type className\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     * @return list of results\n     */\n    protected List<SearchResult> searchDatabaseQuery(String query, String queryLanguage, String wikiName,\n        boolean hasProgrammingRights, boolean distinct, int number, int start, Boolean withPrettyNames, String className)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (query == null || query.trim().startsWith(\"select\")) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n            if (distinct) {\n                f.format(\n                    \"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc %s\",\n                    query);\n            } else {\n                f.format(\"select doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc %s\", query);\n            }\n            String squery = f.toString();\n\n            if (!hasProgrammingRights) {\n                squery\n                    .replace(\"where \",\n                        \"where doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' and \");\n            }\n\n            List<Object> queryResult = null;\n\n            queryResult = queryManager.createQuery(squery, queryLanguage).setLimit(number).setOffset(start).execute();\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                /* Check if the user has the right to see the found document */\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n                    }\n\n                    /*\n                     * In order to add object data to the result, view rights are not enough. Check for edit rights.\n                     * Practical case: XWiki.Admin can be viewed by guest but the information stored in the\n                     * XWiki.XWikiUsers objects (containing the password hash, for example) should not be exposed unless\n                     * the user making the request has actually the right to modify it.\n                     */\n                    if (className != null && !className.equals(\"\")\n                        && Utils.getXWikiApi(componentManager).hasAccessLevel(\"edit\", pageId)) {\n                        BaseObject baseObject = Utils.getBaseObject(doc, className, 0, componentManager);\n                        if (baseObject != null)\n                            searchResult.setObject(DomainObjectFactory.createObject(objectFactory,\n                                uriInfo.getBaseUri(), Utils.getXWikiContext(componentManager), doc, baseObject, false,\n                                Utils.getXWikiApi(componentManager), false));\n                    }\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":83,"modified_method":"/**\n     * Execute a database query using a supported query language. Limit search to documents.\n     * \n     * @param query\n     * @param queryLanguage\n     * @param wikiName\n     * @param hasProgrammingRights\n     * @param distinct\n     * @param number number of results to be returned\n     * @param start 0-based start offset\n     * @param withPrettyNames Add the pretty names for users\n     * @param className Add object of type className\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     * @return list of results\n     */\n    protected List<SearchResult> searchDatabaseQuery(String query, String queryLanguage, String wikiName,\n        boolean hasProgrammingRights, boolean distinct, int number, int start, Boolean withPrettyNames, String className)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (query == null || query.trim().startsWith(\"select\")) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n            if (distinct) {\n                f.format(\n                    \"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc %s\",\n                    query);\n            } else {\n                f.format(\"select doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc %s\", query);\n            }\n            String squery = f.toString();\n\n            if (!hasProgrammingRights) {\n                squery\n                    .replace(\"where \",\n                        \"where doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' and \");\n            }\n\n            List<Object> queryResult = null;\n\n            queryResult = queryManager.createQuery(squery, queryLanguage).setLimit(number).setOffset(start).execute();\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                /* Check if the user has the right to see the found document */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId)) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n                    }\n\n                    /*\n                     * In order to add object data to the result, view rights are not enough. Check for edit rights.\n                     * Practical case: XWiki.Admin can be viewed by guest but the information stored in the\n                     * XWiki.XWikiUsers objects (containing the password hash, for example) should not be exposed unless\n                     * the user making the request has actually the right to modify it.\n                     */\n                    if (className != null && !className.equals(\"\")\n                        && xwikiApi.hasAccessLevel(\"edit\", pageId)) {\n                        BaseObject baseObject = Utils.getBaseObject(doc, className, 0, componentManager);\n                        if (baseObject != null)\n                            searchResult.setObject(DomainObjectFactory.createObject(objectFactory,\n                                uriInfo.getBaseUri(), Utils.getXWikiContext(componentManager), doc, baseObject, false,\n                                xwikiApi, false));\n                    }\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"33349097533fc93369bf6670266a3c96bc1101b9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to spaces.\n     * \n     * @param keywords the string that will be used in a \"like\" XWQL clause\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number number of results to be returned\n     * @param start 0-based start offset\n     * @return the results.\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchSpaces(String keywords, String wikiName, boolean hasProgrammingRights,\n        int number, int start) throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            f.format(\"select distinct doc.space from XWikiDocument as doc where upper(doc.space) like :keywords \");\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by doc.space asc\");\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' order by doc.space asc\");\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n            queryResult =\n                queryManager.createQuery(query, Query.XWQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                    .setOffset(start).execute();\n\n            for (Object object : queryResult) {\n                String spaceName = (String) object;\n                Document spaceDoc = Utils.getXWikiApi(componentManager).getDocument(spaceName + \".WebHome\");\n\n                /* Check if the user has the right to see the found document */\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", spaceDoc.getPrefixedFullName())) {\n                    String title = spaceDoc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"space\");\n                    searchResult.setId(String.format(\"%s:%s\", wikiName, spaceName));\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setTitle(title);\n\n                    /* Add a link to the space information */\n                    Link spaceLink = new Link();\n                    spaceLink.setRel(Relations.SPACE);\n                    String spaceUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(SpaceResource.class).build(wikiName, spaceName)\n                            .toString();\n                    spaceLink.setHref(spaceUri);\n                    searchResult.getLinks().add(spaceLink);\n\n                    /* Add a link to the webhome if it exists */\n                    String webHomePageId = Utils.getPageId(wikiName, spaceName, \"WebHome\");\n                    if (Utils.getXWikiApi(componentManager).exists(webHomePageId)\n                        && Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", webHomePageId)) {\n                        String pageUri =\n                            UriBuilder.fromUri(uriInfo.getBaseUri()).path(PageResource.class)\n                                .build(wikiName, spaceName, \"WebHome\").toString();\n\n                        Link pageLink = new Link();\n                        pageLink.setHref(pageUri);\n                        pageLink.setRel(Relations.HOME);\n                        searchResult.getLinks().add(pageLink);\n                    }\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":84,"modified_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to spaces.\n     * \n     * @param keywords the string that will be used in a \"like\" XWQL clause\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number number of results to be returned\n     * @param start 0-based start offset\n     * @return the results.\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchSpaces(String keywords, String wikiName, boolean hasProgrammingRights,\n        int number, int start) throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            f.format(\"select distinct doc.space from XWikiDocument as doc where upper(doc.space) like :keywords \");\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by doc.space asc\");\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' order by doc.space asc\");\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n            queryResult =\n                queryManager.createQuery(query, Query.XWQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                    .setOffset(start).execute();\n\n            for (Object object : queryResult) {\n                String spaceName = (String) object;\n                Document spaceDoc = xwikiApi.getDocument(String.format(\"%s.WebHome\", spaceName));\n\n                /* Check if the user has the right to see the found document */\n                if (xwikiApi.hasAccessLevel(\"view\", spaceDoc.getPrefixedFullName())) {\n                    String title = spaceDoc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"space\");\n                    searchResult.setId(String.format(\"%s:%s\", wikiName, spaceName));\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setTitle(title);\n\n                    /* Add a link to the space information */\n                    Link spaceLink = new Link();\n                    spaceLink.setRel(Relations.SPACE);\n                    String spaceUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(SpaceResource.class).build(wikiName, spaceName)\n                            .toString();\n                    spaceLink.setHref(spaceUri);\n                    searchResult.getLinks().add(spaceLink);\n\n                    /* Add a link to the webhome if it exists */\n                    String webHomePageId = Utils.getPageId(wikiName, spaceName, \"WebHome\");\n                    if (xwikiApi.exists(webHomePageId) && xwikiApi.hasAccessLevel(\"view\", webHomePageId)) {\n                        String pageUri =\n                            UriBuilder.fromUri(uriInfo.getBaseUri()).path(PageResource.class)\n                                .build(wikiName, spaceName, \"WebHome\").toString();\n\n                        Link pageLink = new Link();\n                        pageLink.setHref(pageUri);\n                        pageLink.setRel(Relations.HOME);\n                        searchResult.getLinks().add(pageLink);\n                    }\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"33349097533fc93369bf6670266a3c96bc1101b9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public boolean login() throws LoginException {\n        if (idp == null) {\n            return false;\n        }\n\n        Credentials credentials = getCredentials();\n        if (credentials == null) {\n            log.info(\"No credentials found for external login module. ignoring.\");\n            return false;\n        }\n\n        try {\n            ExternalUser externalUser = idp.authenticate(credentials);\n            if (externalUser != null) {\n                log.debug(\"Adding Credentials to shared state.\");\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_CREDENTIALS, credentials);\n\n                log.debug(\"Adding login name to shared state.\");\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_LOGIN_NAME, externalUser.getId());\n\n                return true;\n            }\n        } catch (ExternalIdentityException e) {\n            log.error(\"Error while authenticating credentials {} with {}: {}\", new Object[]{\n                    credentials, idp.getName(), e.toString()});\n            return false;\n        }\n        return false;\n    }","id":85,"modified_method":"@Override\n    public boolean login() throws LoginException {\n        if (idp == null) {\n            return false;\n        }\n\n        Credentials credentials = getCredentials();\n        if (credentials == null) {\n            log.info(\"No credentials found for external login module. ignoring.\");\n            return false;\n        }\n\n        try {\n            externalUser = idp.authenticate(credentials);\n            if (externalUser != null) {\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_CREDENTIALS, credentials);\n\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_LOGIN_NAME, externalUser.getId());\n\n                return true;\n            }\n        } catch (ExternalIdentityException e) {\n            log.error(\"Error while authenticating credentials {} with {}: {}\", new Object[]{\n                    credentials, idp.getName(), e.toString()});\n            return false;\n        }\n        return false;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected void clearState() {\n        super.clearState();\n        idp = null;\n        externalUser = null;\n    }","id":86,"modified_method":"@Override\n    protected void clearState() {\n        super.clearState();\n        externalUser = null;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Entry getEntry(LdapConnection connection, LdapProviderConfig.Identity idConfig, String id)\n            throws CursorException, LdapException {\n        String searchFilter = idConfig.getSearchFilter(id);\n\n        // Create the SearchRequest object\n        SearchRequest req = new SearchRequestImpl();\n        req.setScope(SearchScope.SUBTREE);\n        req.addAttributes(\"*\");\n        req.setTimeLimit(config.getSearchTimeout());\n        req.setBase(idConfig.getBaseDN());\n        req.setFilter(searchFilter);\n\n        log.debug(\"Searching entries below {} with {}\", idConfig.getBaseDN(), searchFilter);\n\n        // Process the request\n        SearchCursor searchCursor = connection.search(req);\n        while (searchCursor.next()) {\n            Response response = searchCursor.get();\n\n            // process the SearchResultEntry\n            if (response instanceof SearchResultEntry) {\n                Entry resultEntry = ((SearchResultEntry) response).getEntry();\n                if (searchCursor.next()) {\n                    log.warn(\"search for {} returned more than one entry. discarding additional ones.\", searchFilter);\n                }\n                return resultEntry;\n            }\n        }\n        return null;\n    }","id":87,"modified_method":"private Entry getEntry(LdapConnection connection, LdapProviderConfig.Identity idConfig, String id)\n            throws CursorException, LdapException {\n        String searchFilter = idConfig.getSearchFilter(id);\n\n        // Create the SearchRequest object\n        SearchRequest req = new SearchRequestImpl();\n        req.setScope(SearchScope.SUBTREE);\n        req.addAttributes(\"*\");\n        req.setTimeLimit(config.getSearchTimeout());\n        req.setBase(new Dn(idConfig.getBaseDN()));\n        req.setFilter(searchFilter);\n\n        log.debug(\"Searching entries below {} with {}\", idConfig.getBaseDN(), searchFilter);\n\n        // Process the request\n        SearchCursor searchCursor = connection.search(req);\n        while (searchCursor.next()) {\n            Response response = searchCursor.get();\n\n            // process the SearchResultEntry\n            if (response instanceof SearchResultEntry) {\n                Entry resultEntry = ((SearchResultEntry) response).getEntry();\n                if (searchCursor.next()) {\n                    log.warn(\"search for {} returned more than one entry. discarding additional ones.\", searchFilter);\n                }\n                return resultEntry;\n            }\n        }\n        return null;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Activate\n    private void activate(Map<String, Object> properties) {\n        ConfigurationParameters cfg = ConfigurationParameters.of(properties);\n        config = LdapProviderConfig.of(cfg);\n        log.error(\"***** activate {}: {}\", this, properties);\n    }","id":88,"modified_method":"@Activate\n    private void activate(Map<String, Object> properties) {\n        ConfigurationParameters cfg = ConfigurationParameters.of(properties);\n        config = LdapProviderConfig.of(cfg);\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private LdapConnection connect() throws ExternalIdentityException {\n        try {\n            LdapConnection connection = new LdapNetworkConnection(config.getHost(), config.getPort(), config.isUseSSL());\n            if (config.getBindDN().length() > 0) {\n                connection.bind(config.getBindDN(), config.getBindPassword());\n            } else {\n                connection.bind();\n            }\n            return connection;\n        } catch (LdapException e) {\n            log.error(\"Error while connecting to the ldap server.\", e);\n            throw new ExternalIdentityException(\"Error while connecting and binding to the ldap server\", e);\n        }\n    }","id":89,"modified_method":"private LdapConnection connect() throws ExternalIdentityException {\n        try {\n            LdapConnection connection = new LdapNetworkConnection(config.getHostname(), config.getPort(), config.useSSL());\n            if (config.getBindDN().length() > 0) {\n                connection.bind(config.getBindDN(), config.getBindPassword());\n            } else {\n                connection.bind();\n            }\n            return connection;\n        } catch (LdapException e) {\n            log.error(\"Error while connecting to the ldap server.\", e);\n            throw new ExternalIdentityException(\"Error while connecting and binding to the ldap server\", e);\n        }\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setName(@Nonnull String name) {\n        this.name = name;\n    }","id":90,"modified_method":"/**\n     * Sets the name of this provider.\n     * @param name the name\n     * @return {@code this}\n     * @see #getName()\n     */\n    @Nonnull\n    public LdapProviderConfig setName(@Nonnull String name) {\n        this.name = name;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Identity getUserConfig() {\n        return userConfig;\n    }","id":91,"modified_method":"/**\n     * Returns the user specific configuration.\n     * @return the user config.\n     */\n    @Nonnull\n    public Identity getUserConfig() {\n        return userConfig;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getSearchFilter(String id) {\n            if (filterTemplate == null) {\n                StringBuilder filter = new StringBuilder(\"(&(\")\n                        .append(idAttribute)\n                        .append(\"=%s)\");\n                for (String objectClass: objectClasses) {\n                    filter.append(\"(objectclass=\")\n                            .append(FilterEncoder.encodeFilterValue(objectClass))\n                            .append(')');\n                }\n                if (extraFilter != null && extraFilter.length() > 0) {\n                    filter.append(extraFilter);\n                }\n                filter.append(')');\n                filterTemplate = filter.toString();\n            }\n            return String.format(filterTemplate, FilterEncoder.encodeFilterValue(id));\n        }","id":92,"modified_method":"/**\n         * Returns the LDAP filter that is used when searching this type of identity. The filter is based on the\n         * configuration and has the following format:\n         *\n         * <pre>\n         *     (&(${idAttr}=${id})(objectclass=${objectclass})${extraFilter})\n         * <\/pre>\n         *\n         * Note that the objectclass part is repeated according to the specified objectclasses in {@link #getObjectClasses()}.\n         *\n         * @param id the id value\n         * @return the search filter\n         */\n        @Nonnull\n        public String getSearchFilter(@Nonnull String id) {\n            if (filterTemplate == null) {\n                StringBuilder filter = new StringBuilder(\"(&(\")\n                        .append(idAttribute)\n                        .append(\"=%s)\");\n                for (String objectClass: objectClasses) {\n                    filter.append(\"(objectclass=\")\n                            .append(encodeFilterValue(objectClass))\n                            .append(')');\n                }\n                if (extraFilter != null && extraFilter.length() > 0) {\n                    filter.append(extraFilter);\n                }\n                filter.append(')');\n                filterTemplate = filter.toString();\n            }\n            return String.format(filterTemplate, encodeFilterValue(id));\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getBindPassword() {\n        return bindPassword;\n    }","id":93,"modified_method":"/**\n     * Configures the password that is used to bind to the LDAP server. This value is not used for anonymous binds.\n     * @return the password.\n     */\n    @CheckForNull\n    public String getBindPassword() {\n        return bindPassword;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static LdapProviderConfig of(ConfigurationParameters params) {\n        LdapProviderConfig cfg = new LdapProviderConfig();\n        cfg.name = params.getConfigValue(PARAM_NAME, cfg.name);\n        cfg.host = params.getConfigValue(PARAM_LDAP_HOST, PARAM_LDAP_HOST_DEFAULT);\n        cfg.port = params.getConfigValue(PARAM_LDAP_PORT, PARAM_LDAP_PORT_DEFAULT);\n        cfg.useSSL = params.getConfigValue(PARAM_USE_SSL, PARAM_USE_SSL_DEFAULT);\n        cfg.bindDN = params.getConfigValue(PARAM_BIND_DN, PARAM_BIND_DN_DEFAULT);\n        cfg.bindPassword = params.getConfigValue(PARAM_BIND_PASSWORD, PARAM_BIND_PASSWORD_DEFAULT);\n        cfg.searchTimeout = params.getConfigValue(PARAM_SEARCH_TIMEOUT, PARAM_SEARCH_TIMEOUT_DEFAULT);\n        return cfg;\n    }","id":94,"modified_method":"/**\n     * Creates a new LDAP provider configuration based on the properties store in the given parameters.\n     * @param params the configuration parameters.\n     * @return the config\n     */\n    public static LdapProviderConfig of(ConfigurationParameters params) {\n        LdapProviderConfig cfg = new LdapProviderConfig()\n                .setName(params.getConfigValue(PARAM_NAME, PARAM_NAME_DEFAULT))\n                .setHostname(params.getConfigValue(PARAM_LDAP_HOST, PARAM_LDAP_HOST_DEFAULT))\n                .setPort(params.getConfigValue(PARAM_LDAP_PORT, PARAM_LDAP_PORT_DEFAULT))\n                .setUseSSL(params.getConfigValue(PARAM_USE_SSL, PARAM_USE_SSL_DEFAULT))\n                .setBindDN(params.getConfigValue(PARAM_BIND_DN, PARAM_BIND_DN_DEFAULT))\n                .setBindPassword(params.getConfigValue(PARAM_BIND_PASSWORD, PARAM_BIND_PASSWORD_DEFAULT))\n                .setSearchTimeout(params.getConfigValue(PARAM_SEARCH_TIMEOUT, PARAM_SEARCH_TIMEOUT_DEFAULT))\n                .setGroupMemberAttribute(params.getConfigValue(PARAM_GROUP_MEMBER_ATTRIBUTE, PARAM_GROUP_MEMBER_ATTRIBUTE_DEFAULT));\n\n        cfg.getUserConfig()\n                .setBaseDN(params.getConfigValue(PARAM_USER_BASE_DN, PARAM_USER_BASE_DN))\n                .setIdAttribute(params.getConfigValue(PARAM_USER_ID_ATTRIBUTE, PARAM_USER_ID_ATTRIBUTE_DEFAULT))\n                .setExtraFilter(params.getConfigValue(PARAM_USER_EXTRA_FILTER, PARAM_USER_EXTRA_FILTER_DEFAULT))\n                .setObjectClasses(params.getConfigValue(PARAM_USER_OBJECTCLASS, PARAM_USER_OBJECTCLASS_DEFAULT));\n\n        cfg.getGroupConfig()\n                .setBaseDN(params.getConfigValue(PARAM_GROUP_BASE_DN, PARAM_GROUP_BASE_DN))\n                .setIdAttribute(params.getConfigValue(PARAM_GROUP_NAME_ATTRIBUTE, PARAM_GROUP_NAME_ATTRIBUTE_DEFAULT))\n                .setExtraFilter(params.getConfigValue(PARAM_GROUP_EXTRA_FILTER, PARAM_GROUP_EXTRA_FILTER_DEFAULT))\n                .setObjectClasses(params.getConfigValue(PARAM_GROUP_OBJECTCLASS, PARAM_GROUP_OBJECTCLASS_DEFAULT));\n\n        return cfg;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public int getSearchTimeout() {\n        return searchTimeout;\n    }","id":95,"modified_method":"/**\n     * Configures the timeout in milliseconds that is used for all LDAP searches.\n     * The default is {@value #PARAM_SEARCH_TIMEOUT_DEFAULT}.\n     *\n     * @return the timeout in milliseconds.\n     */\n    public int getSearchTimeout() {\n        return searchTimeout;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public int getPort() {\n        return port;\n    }","id":96,"modified_method":"/**\n     * Configures the port of the LDAP server.\n     * The default is {@value #PARAM_LDAP_PORT_DEFAULT}\n     *\n     * @return the port\n     */\n    public int getPort() {\n        return port;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setBindDN(String bindDN) {\n        this.bindDN = bindDN;\n    }","id":97,"modified_method":"/**\n     * Sets the bind DN.\n     * @param bindDN the DN\n     * @return {@code this}\n     * @see #getBindDN()\n     */\n    @Nonnull\n    public LdapProviderConfig setBindDN(@Nullable String bindDN) {\n        this.bindDN = bindDN;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getGroupMembershipAttribute() {\n        return groupMembershipAttribute;\n    }","id":98,"modified_method":"/**\n     * Configures the attribute that stores the members of a group.\n     * Default is {@value #PARAM_GROUP_MEMBER_ATTRIBUTE_DEFAULT}\n     *\n     * @return the group member attribute\n     */\n    @Nonnull\n    public String getGroupMemberAttribute() {\n        return groupMemberAttribute;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setUseSSL(boolean useSSL) {\n        this.useSSL = useSSL;\n    }","id":99,"modified_method":"/**\n     * Enables SSL connections.\n     * @param useSSL {@code true} to enable SSL\n     * @return {@code this}\n     * @see #useSSL()\n     */\n    @Nonnull\n    public LdapProviderConfig setUseSSL(boolean useSSL) {\n        this.useSSL = useSSL;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setPort(int port) {\n        this.port = port;\n    }","id":100,"modified_method":"/**\n     * Sets the port.\n     * @param port the port\n     * @return {@code this}\n     * @see #getPort()\n     */\n    @Nonnull\n    public LdapProviderConfig setPort(int port) {\n        this.port = port;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Dn getBaseDN() {\n            return baseDN;\n        }","id":101,"modified_method":"/**\n         * Configures the base DN for searches of this kind of identity\n         * @return the base DN\n         */\n        @Nonnull\n        public String getBaseDN() {\n            return baseDN;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    public String getName() {\n        return name;\n    }","id":102,"modified_method":"/**\n     * Returns the name of this provider configuration.\n     * The default is {@value #PARAM_NAME_DEFAULT}\n     *\n     * @return the name.\n     */\n    @Nonnull\n    public String getName() {\n        return name;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setExtraFilter(String extraFilter) {\n            this.extraFilter = extraFilter;\n            filterTemplate = null;\n        }","id":103,"modified_method":"/**\n         * Sets the extra search filter.\n         * @param extraFilter the filter\n         * @return {@code this}\n         * @see #getExtraFilter()\n         */\n        @Nonnull\n        public Identity setExtraFilter(@Nullable String extraFilter) {\n            this.extraFilter = extraFilter;\n            filterTemplate = null;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setGroupMembershipAttribute(String groupMembershipAttribute) {\n        this.groupMembershipAttribute = groupMembershipAttribute;\n    }","id":104,"modified_method":"/**\n     * Sets the group member attribute.\n     * @param groupMemberAttribute the attribute name\n     * @return {@code this}\n     * @see #getGroupMemberAttribute()\n     */\n    @Nonnull\n    public LdapProviderConfig setGroupMemberAttribute(@Nonnull String groupMemberAttribute) {\n        this.groupMemberAttribute = groupMemberAttribute;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Identity getGroupConfig() {\n        return groupConfig;\n    }","id":105,"modified_method":"/**\n     * Returns the group specific configuration.\n     * @return the groups config.\n     */\n    @Nonnull\n    public Identity getGroupConfig() {\n        return groupConfig;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getExtraFilter() {\n            return extraFilter;\n        }","id":106,"modified_method":"/**\n         * Configures the extra LDAP filter that is appended to the internally computed filter when searching for\n         * identities.\n         *\n         * @return the extra filter\n         */\n        @CheckForNull\n        public String getExtraFilter() {\n            return extraFilter;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setBindPassword(String bindPassword) {\n        this.bindPassword = bindPassword;\n    }","id":107,"modified_method":"/**\n     * Sets the bind password\n     * @param bindPassword the password\n     * @return {@code this}\n     * @see #getBindPassword()\n     */\n    @Nonnull\n    public LdapProviderConfig setBindPassword(@Nullable String bindPassword) {\n        this.bindPassword = bindPassword;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getHost() {\n        return host;\n    }","id":108,"modified_method":"/**\n     * Configures the hostname of the LDAP server.\n     * The default is {@value #PARAM_LDAP_HOST_DEFAULT}\n     *\n     * @return the hostname\n     */\n    @Nonnull\n    public String getHostname() {\n        return hostname;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public boolean isUseSSL() {\n        return useSSL;\n    }","id":109,"modified_method":"/**\n     * Configures whether SSL connections should be used.\n     * The default is {@value #PARAM_USE_SSL_DEFAULT}.\n     *\n     * @return {@code true} if SSL should be used.\n     */\n    public boolean useSSL() {\n        return useSSL;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setSearchTimeout(int searchTimeout) {\n        this.searchTimeout = searchTimeout;\n    }","id":110,"modified_method":"/**\n     * Sets the search timeout.\n     * @param searchTimeout the timeout in milliseconds\n     * @return {@code this}\n     * @see #setSearchTimeout(int)\n     */\n    @Nonnull\n    public LdapProviderConfig setSearchTimeout(int searchTimeout) {\n        this.searchTimeout = searchTimeout;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getBindDN() {\n        return bindDN;\n    }","id":111,"modified_method":"/**\n     * Configures the DN that is used to bind to the LDAP server. If this value is {@code null} or an empty string,\n     * anonymous connections are used.\n     * @return the bind DN or {@code null}.\n     */\n    @CheckForNull\n    public String getBindDN() {\n        return bindDN;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setBaseDN(String baseDN) throws LdapInvalidDnException {\n            this.baseDN = new Dn(baseDN);\n        }","id":112,"modified_method":"/**\n         * Sets the base DN for search of this kind of identity.\n         * @param baseDN the DN as string.\n         * @return {@code this}\n         * @see #getBaseDN()\n         */\n        @Nonnull\n        public Identity setBaseDN(@Nonnull String baseDN) {\n            this.baseDN = baseDN;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setIdAttribute(String idAttribute) {\n            this.idAttribute = idAttribute;\n            filterTemplate = null;\n        }","id":113,"modified_method":"/**\n         * Sets the id attribute.\n         * @param idAttribute the id attribute name\n         * @return {@code this}\n         * @see #getIdAttribute()\n         */\n        @Nonnull\n        public Identity setIdAttribute(@Nonnull String idAttribute) {\n            this.idAttribute = idAttribute;\n            filterTemplate = null;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String[] getObjectClasses() {\n            return objectClasses;\n        }","id":114,"modified_method":"/**\n         * Configures the object classes of this kind of identity.\n         * @return an array of object classes\n         * @see #getSearchFilter(String) for more detail about searching and filtering\n         */\n        @Nonnull\n        public String[] getObjectClasses() {\n            return objectClasses;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public String getIdAttribute() {\n            return idAttribute;\n        }","id":115,"modified_method":"/**\n         * Configures the attribute that is used to identify this identity by id. For users this is the attribute that\n         * holds the user id, for groups this is the attribute that holds the group name.\n         *\n         * @return the id attribute name\n         * @see #getSearchFilter(String) for more detail about searching and filtering\n         */\n        @Nonnull\n        public String getIdAttribute() {\n            return idAttribute;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setHost(String host) {\n        this.host = host;\n    }","id":116,"modified_method":"/**\n     * Sets the hostname.\n     * @param hostname the hostname\n     * @return {@code this}\n     * @see #getHostname()\n     */\n    @Nonnull\n    public LdapProviderConfig setHostname(@Nonnull String hostname) {\n        this.hostname = hostname;\n        return this;\n    }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setPathPrefix(String pathPrefix) {\n            this.pathPrefix = pathPrefix;\n        }","id":117,"modified_method":"public Authorizable setPathPrefix(String pathPrefix) {\n            this.pathPrefix = pathPrefix;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setGroupNestingDepth(long groupNestingDepth) {\n            this.groupNestingDepth = groupNestingDepth;\n        }","id":118,"modified_method":"public User setGroupNestingDepth(long groupNestingDepth) {\n            this.groupNestingDepth = groupNestingDepth;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setMembershipExpirationTime(long membershipExpirationTime) {\n            this.membershipExpirationTime = membershipExpirationTime;\n        }","id":119,"modified_method":"public User setMembershipExpirationTime(long membershipExpirationTime) {\n            this.membershipExpirationTime = membershipExpirationTime;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setAutoMembership(Set<String> autoMembership) {\n            this.autoMembership = autoMembership;\n        }","id":120,"modified_method":"public Authorizable setAutoMembership(Set<String> autoMembership) {\n            this.autoMembership = autoMembership;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setExpirationTime(long expirationTime) {\n            this.expirationTime = expirationTime;\n        }","id":121,"modified_method":"public Authorizable setExpirationTime(long expirationTime) {\n            this.expirationTime = expirationTime;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setPropertyMapping(Map<String, String> propertyMapping) {\n            this.propertyMapping = propertyMapping;\n        }","id":122,"modified_method":"public Authorizable setPropertyMapping(Map<String, String> propertyMapping) {\n            this.propertyMapping = propertyMapping;\n            return this;\n        }","commit_id":"5f8b1254cc205dc1861b3dd5b0ca5a1fcb415ef9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(\"_geo_distance\");\n        if (geohashes.size() == 0 && points.size() == 0) {\n            throw new ElasticsearchParseException(\"No points provided for _geo_distance sort.\");\n        }\n\n        builder.startArray(fieldName);\n        for (GeoPoint point : points) {\n            builder.value(point);\n        }\n        for (String geohash : geohashes) {\n            builder.value(geohash);\n        }\n        builder.endArray();\n\n        if (unit != null) {\n            builder.field(\"unit\", unit);\n        }\n        if (geoDistance != null) {\n            builder.field(\"distance_type\", geoDistance.name().toLowerCase(Locale.ROOT));\n        }\n        if (order == SortOrder.DESC) {\n            builder.field(\"reverse\", true);\n        }\n        if (sortMode != null) {\n            builder.field(\"mode\", sortMode);\n        }\n\n        if (nestedPath != null) {\n            builder.field(\"nested_path\", nestedPath);\n        }\n        if (nestedFilter != null) {\n            builder.field(\"nested_filter\", nestedFilter, params);\n        }\n        if (coerce != null) {\n            builder.field(\"coerce\", coerce);\n        }\n        if (ignoreMalformed != null) {\n            builder.field(\"ignore_malformed\", ignoreMalformed);\n        }\n\n        builder.endObject();\n        return builder;\n    }","id":123,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(NAME);\n\n        builder.startArray(fieldName);\n        for (GeoPoint point : points) {\n            builder.value(point);\n        }\n        builder.endArray();\n\n        builder.field(\"unit\", unit);\n        builder.field(\"distance_type\", geoDistance.name().toLowerCase(Locale.ROOT));\n        if (order == SortOrder.DESC) {\n            builder.field(\"reverse\", true);\n        } else {\n            builder.field(\"reverse\", false);\n        }\n\n        if (sortMode != null) {\n            builder.field(\"mode\", sortMode);\n        }\n\n        if (nestedPath != null) {\n            builder.field(\"nested_path\", nestedPath);\n        }\n        if (nestedFilter != null) {\n            builder.field(\"nested_filter\", nestedFilter, params);\n        }\n        builder.field(\"coerce\", coerce);\n        builder.field(\"ignore_malformed\", ignoreMalformed);\n\n        builder.endObject();\n        return builder;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * The geohash of the geo point to create the range distance facets from.\n     */\n    public GeoDistanceSortBuilder geohashes(String... geohashes) {\n        this.geohashes.addAll(Arrays.asList(geohashes));\n        return this;\n    }","id":124,"modified_method":"/**\n     * The geohash of the geo point to create the range distance facets from.\n     * \n     * Deprecated - please use points(GeoPoint... points) instead.\n     */\n    @Deprecated\n    public GeoDistanceSortBuilder geohashes(String... geohashes) {\n        for (String geohash : geohashes) {\n            this.points.add(GeoPoint.fromGeohash(geohash));\n        }\n        return this;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     */\n    public GeoDistanceSortBuilder(String fieldName) {\n        this.fieldName = fieldName;\n    }","id":125,"modified_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     */\n    public GeoDistanceSortBuilder(String fieldName, String ... geohashes) {\n        if (geohashes.length == 0) {\n            throw new IllegalArgumentException(\"Geo distance sorting needs at least one point.\");\n        }\n        for (String geohash : geohashes) {\n            this.points.add(GeoPoint.fromGeohash(geohash));\n        }\n        this.fieldName = fieldName;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Not relevant.\n     */\n    @Override\n    public SortBuilder missing(Object missing) {\n        return this;\n    }","id":126,"modified_method":"/**\n     * Not relevant.\n     *\n     * TODO should this throw an exception rather than silently ignore a parameter that is not used?\n     */\n    @Override\n    public GeoDistanceSortBuilder missing(Object missing) {\n        return this;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     */\n    public GeoDistanceSortBuilder sortMode(String sortMode) {\n        this.sortMode = sortMode;\n        return this;\n    }","id":127,"modified_method":"/**\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     */\n    public GeoDistanceSortBuilder sortMode(String sortMode) {\n        MultiValueMode temp = MultiValueMode.fromString(sortMode);\n        if (temp == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n        this.sortMode = sortMode;\n        return this;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GeoDistanceSortBuilder ignoreMalformed(boolean ignoreMalformed) {\n        this.ignoreMalformed = ignoreMalformed;\n        return this;\n    }","id":128,"modified_method":"public GeoDistanceSortBuilder ignoreMalformed(boolean ignoreMalformed) {\n        if (coerce == false) {\n            this.ignoreMalformed = ignoreMalformed;\n        }\n        return this;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.indexShard().getIndexSettings().getIndexVersionCreated().before(Version.V_2_0_0);\n        boolean coerce = false;\n        boolean ignoreMalformed = false;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Query innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = nestedHelper.getInnerFilter();\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, context.searcher().createNormalizedWeight(innerDocumentsFilter, false));\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSetIterator innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","id":129,"modified_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.indexShard().getIndexSettings().getIndexVersionCreated().before(Version.V_2_0_0);\n        boolean coerce = GeoDistanceSortBuilder.DEFAULT_COERCE;\n        boolean ignoreMalformed = GeoDistanceSortBuilder.DEFAULT_IGNORE_MALFORMED;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                GeoDistanceSortBuilder.parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Query innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = nestedHelper.getInnerFilter();\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, context.searcher().createNormalizedWeight(innerDocumentsFilter, false));\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSetIterator innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingWithMissingGeoPoint() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        // Doc with missing geo point is first, is consistent with 0.20.x\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286d, 10d));\n    }","id":130,"modified_method":"public void testDistanceSortingWithMissingGeoPoint() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        // Doc with missing geo point is first, is consistent with 0.20.x\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286d, 10d));\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingMVFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true).field(\"coerce\", true);\n        }\n        xContentBuilder.field(\"ignore_malformed\", true).endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York\")\n                .startObject(\"locations\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York 2\")\n                .startObject(\"locations\").field(\"lat\", 400.7143528).field(\"lon\", 285.9990269).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .startArray(\"locations\")\n                        // to NY: 1.055 km\n                .startObject().field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                        // to NY: 1.258 km\n                .startObject().field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Greenwich Village\", \"Brooklyn\")\n                .startArray(\"locations\")\n                        // to NY: 2.029 km\n                .startObject().field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                        // to NY: 8.572 km\n                .startObject().field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\",  \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2874d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(5301d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        assertFailures(client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"sum\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":131,"modified_method":"public void testDistanceSortingMVFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true).field(\"coerce\", true);\n        }\n        xContentBuilder.field(\"ignore_malformed\", true).endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York\")\n                .startObject(\"locations\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York 2\")\n                .startObject(\"locations\").field(\"lat\", 400.7143528).field(\"lon\", 285.9990269).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .startArray(\"locations\")\n                        // to NY: 1.055 km\n                .startObject().field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                        // to NY: 1.258 km\n                .startObject().field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Greenwich Village\", \"Brooklyn\")\n                .startArray(\"locations\")\n                        // to NY: 2.029 km\n                .startObject().field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                        // to NY: 8.572 km\n                .startObject().field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\",  \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2874d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(5301d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        assertFailures(client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"sum\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingNestedFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"branches\")\n                .field(\"type\", \"nested\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject()\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").setSettings(settings).addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"companies\", \"company\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 1\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"New York\")\n                        .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 2\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Times Square\")\n                        .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject() // to NY: 5.286 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Tribeca\")\n                        .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject() // to NY: 0.4621 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 3\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Wall Street\")\n                        .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject() // to NY: 1.055 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Soho\")\n                        .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject() // to NY: 1.258 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 4\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Greenwich Village\")\n                        .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject() // to NY: 2.029 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject() // to NY: 8.572 km\n                    .endObject()\n                .endArray()\n                .endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                    SortBuilders.geoDistanceSort(\"branches.location\").setNestedPath(\"branches\")\n                            .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.geoDistanceSort(\"branches.location\").setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                                .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                    .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"sum\").setNestedPath(\"branches\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":132,"modified_method":"public void testDistanceSortingNestedFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"branches\")\n                .field(\"type\", \"nested\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject()\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").setSettings(settings).addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"companies\", \"company\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 1\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"New York\")\n                        .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 2\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Times Square\")\n                        .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject() // to NY: 5.286 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Tribeca\")\n                        .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject() // to NY: 0.4621 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 3\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Wall Street\")\n                        .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject() // to NY: 1.055 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Soho\")\n                        .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject() // to NY: 1.258 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 4\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Greenwich Village\")\n                        .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject() // to NY: 2.029 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject() // to NY: 8.572 km\n                    .endObject()\n                .endArray()\n                .endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                    SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).setNestedPath(\"branches\")\n                            .sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                                .sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                    .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).sortMode(\"sum\").setNestedPath(\"branches\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimpleDistance() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"New York\")\n                .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()),\n        // to NY: 5.286 km\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Times Square\")\n                .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                .endObject()),\n        // to NY: 0.4621 km\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Tribeca\")\n                .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endObject()),\n        // to NY: 1.055 km\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Wall Street\")\n                .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                .endObject()),\n        // to NY: 1.258 km\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Soho\")\n                .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endObject()),\n        // to NY: 2.029 km\n        client().prepareIndex(\"test\", \"type1\", \"6\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Greenwich Village\")\n                .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                .endObject()),\n        // to NY: 8.572 km\n        client().prepareIndex(\"test\", \"type1\", \"7\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Brooklyn\")\n                .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endObject()));\n\n        SearchResponse searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // now with a PLANE type\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").geoDistance(GeoDistance.PLANE).point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // factor type is really too small for this resolution\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\").optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits().length, equalTo(3));\n\n        // SORTING\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"4\", \"5\", \"6\", \"2\", \"7\");\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"7\", \"2\", \"6\", \"5\", \"4\", \"3\", \"1\");\n    }","id":133,"modified_method":"public void testSimpleDistance() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"New York\")\n                .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()),\n        // to NY: 5.286 km\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Times Square\")\n                .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                .endObject()),\n        // to NY: 0.4621 km\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Tribeca\")\n                .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endObject()),\n        // to NY: 1.055 km\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Wall Street\")\n                .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                .endObject()),\n        // to NY: 1.258 km\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Soho\")\n                .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endObject()),\n        // to NY: 2.029 km\n        client().prepareIndex(\"test\", \"type1\", \"6\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Greenwich Village\")\n                .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                .endObject()),\n        // to NY: 8.572 km\n        client().prepareIndex(\"test\", \"type1\", \"7\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Brooklyn\")\n                .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endObject()));\n\n        SearchResponse searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // now with a PLANE type\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").geoDistance(GeoDistance.PLANE).point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // factor type is really too small for this resolution\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\").optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits().length, equalTo(3));\n\n        // SORTING\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\", 40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"4\", \"5\", \"6\", \"2\", \"7\");\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\", 40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"7\", \"2\", \"6\", \"5\", \"4\", \"3\", \"1\");\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected final SearchSourceBuilder createSearchSourceBuilder() throws IOException {\n        SearchSourceBuilder builder = new SearchSourceBuilder();\n        if (randomBoolean()) {\n            builder.from(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.size(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.explain(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.version(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.trackScores(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.minScore(randomFloat() * 1000);\n        }\n        if (randomBoolean()) {\n            builder.timeout(new TimeValue(randomIntBetween(1, 100), randomFrom(TimeUnit.values())));\n        }\n        if (randomBoolean()) {\n            builder.terminateAfter(randomIntBetween(1, 100000));\n        }\n        // if (randomBoolean()) {\n        // builder.defaultRescoreWindowSize(randomIntBetween(1, 100));\n        // }\n        if (randomBoolean()) {\n            int fieldsSize = randomInt(25);\n            List<String> fields = new ArrayList<>(fieldsSize);\n            for (int i = 0; i < fieldsSize; i++) {\n                fields.add(randomAsciiOfLengthBetween(5, 50));\n            }\n            builder.fields(fields);\n        }\n        if (randomBoolean()) {\n            int fieldDataFieldsSize = randomInt(25);\n            for (int i = 0; i < fieldDataFieldsSize; i++) {\n                builder.fieldDataField(randomAsciiOfLengthBetween(5, 50));\n            }\n        }\n        if (randomBoolean()) {\n            int scriptFieldsSize = randomInt(25);\n            for (int i = 0; i < scriptFieldsSize; i++) {\n                if (randomBoolean()) {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"), randomBoolean());\n                } else {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"));\n                }\n            }\n        }\n        if (randomBoolean()) {\n            FetchSourceContext fetchSourceContext;\n            int branch = randomInt(5);\n            String[] includes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < includes.length; i++) {\n                includes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            String[] excludes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < excludes.length; i++) {\n                excludes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            switch (branch) {\n            case 0:\n                fetchSourceContext = new FetchSourceContext(randomBoolean());\n                break;\n            case 1:\n                fetchSourceContext = new FetchSourceContext(includes, excludes);\n                break;\n            case 2:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20));\n                break;\n            case 3:\n                fetchSourceContext = new FetchSourceContext(true, includes, excludes);\n                break;\n            case 4:\n                fetchSourceContext = new FetchSourceContext(includes);\n                break;\n            case 5:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20));\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            builder.fetchSource(fetchSourceContext);\n        }\n        if (randomBoolean()) {\n            int size = randomIntBetween(0, 20);\n            List<String> statsGroups = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                statsGroups.add(randomAsciiOfLengthBetween(5, 20));\n            }\n            builder.stats(statsGroups);\n        }\n        if (randomBoolean()) {\n            int indexBoostSize = randomIntBetween(1, 10);\n            for (int i = 0; i < indexBoostSize; i++) {\n                builder.indexBoost(randomAsciiOfLengthBetween(5, 20), randomFloat() * 10);\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.query(RandomQueryBuilder.createQuery(getRandom()));\n            builder.query(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.postFilter(RandomQueryBuilder.createQuery(getRandom()));\n            builder.postFilter(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            int numSorts = randomIntBetween(1, 5);\n            for (int i = 0; i < numSorts; i++) {\n                int branch = randomInt(5);\n                switch (branch) {\n                case 0:\n                    builder.sort(SortBuilders.fieldSort(randomAsciiOfLengthBetween(5, 20)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 1:\n                    builder.sort(SortBuilders.geoDistanceSort(randomAsciiOfLengthBetween(5, 20))\n                            .geohashes(AbstractQueryTestCase.randomGeohash(1, 12)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 2:\n                    builder.sort(SortBuilders.scoreSort().order(randomFrom(SortOrder.values())));\n                    break;\n                case 3:\n                    builder.sort(SortBuilders.scriptSort(new Script(\"foo\"), \"number\").order(randomFrom(SortOrder.values())));\n                    break;\n                case 4:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20));\n                    break;\n                case 5:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20), randomFrom(SortOrder.values()));\n                    break;\n                }\n            }\n        }\n\n        if (randomBoolean()) {\n            int numSearchFrom = randomIntBetween(1, 5);\n            // We build a json version of the search_from first in order to\n            // ensure that every number type remain the same before/after xcontent (de)serialization.\n            // This is not a problem because the final type of each field value is extracted from associated sort field.\n            // This little trick ensure that equals and hashcode are the same when using the xcontent serialization.\n            XContentBuilder jsonBuilder = XContentFactory.jsonBuilder();\n            jsonBuilder.startObject();\n            jsonBuilder.startArray(\"search_from\");\n            for (int i = 0; i < numSearchFrom; i++) {\n                int branch = randomInt(8);\n                switch (branch) {\n                    case 0:\n                        jsonBuilder.value(randomInt());\n                        break;\n                    case 1:\n                        jsonBuilder.value(randomFloat());\n                        break;\n                    case 2:\n                        jsonBuilder.value(randomLong());\n                        break;\n                    case 3:\n                        jsonBuilder.value(randomDouble());\n                        break;\n                    case 4:\n                        jsonBuilder.value(randomAsciiOfLengthBetween(5, 20));\n                        break;\n                    case 5:\n                        jsonBuilder.value(randomBoolean());\n                        break;\n                    case 6:\n                        jsonBuilder.value(randomByte());\n                        break;\n                    case 7:\n                        jsonBuilder.value(randomShort());\n                        break;\n                    case 8:\n                        jsonBuilder.value(new Text(randomAsciiOfLengthBetween(5, 20)));\n                        break;\n                }\n            }\n            jsonBuilder.endArray();\n            jsonBuilder.endObject();\n            XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(jsonBuilder.bytes());\n            parser.nextToken();\n            parser.nextToken();\n            parser.nextToken();\n            builder.searchAfter(SearchAfterBuilder.PROTOTYPE.fromXContent(parser, null).getSortValues());\n        }\n        if (randomBoolean()) {\n            builder.highlighter(HighlightBuilderTests.randomHighlighterBuilder());\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random suggest builder method\n            builder.suggest(new SuggestBuilder().setText(randomAsciiOfLengthBetween(1, 5)).addSuggestion(\n                    SuggestBuilders.termSuggestion(randomAsciiOfLengthBetween(1, 5))));\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random inner hits builder method\n            InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder();\n            InnerHit innerHit = new InnerHit();\n            innerHit.field(randomAsciiOfLengthBetween(5, 20));\n            innerHitsBuilder.addNestedInnerHits(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20), innerHit);\n            builder.innerHits(innerHitsBuilder);\n        }\n        if (randomBoolean()) {\n            int numRescores = randomIntBetween(1, 5);\n            for (int i = 0; i < numRescores; i++) {\n                builder.addRescorer(QueryRescoreBuilderTests.randomRescoreBuilder());\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random aggregation builder method\n            builder.aggregation(AggregationBuilders.avg(randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (true) {\n            // NORELEASE need a method to randomly build content for ext\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();\n            xContentBuilder.startObject();\n            xContentBuilder.field(\"term_vectors_fetch\", randomAsciiOfLengthBetween(5, 20));\n            xContentBuilder.endObject();\n            builder.ext(xContentBuilder);\n        }\n        return builder;\n    }","id":134,"modified_method":"protected final SearchSourceBuilder createSearchSourceBuilder() throws IOException {\n        SearchSourceBuilder builder = new SearchSourceBuilder();\n        if (randomBoolean()) {\n            builder.from(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.size(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.explain(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.version(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.trackScores(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.minScore(randomFloat() * 1000);\n        }\n        if (randomBoolean()) {\n            builder.timeout(new TimeValue(randomIntBetween(1, 100), randomFrom(TimeUnit.values())));\n        }\n        if (randomBoolean()) {\n            builder.terminateAfter(randomIntBetween(1, 100000));\n        }\n        // if (randomBoolean()) {\n        // builder.defaultRescoreWindowSize(randomIntBetween(1, 100));\n        // }\n        if (randomBoolean()) {\n            int fieldsSize = randomInt(25);\n            List<String> fields = new ArrayList<>(fieldsSize);\n            for (int i = 0; i < fieldsSize; i++) {\n                fields.add(randomAsciiOfLengthBetween(5, 50));\n            }\n            builder.fields(fields);\n        }\n        if (randomBoolean()) {\n            int fieldDataFieldsSize = randomInt(25);\n            for (int i = 0; i < fieldDataFieldsSize; i++) {\n                builder.fieldDataField(randomAsciiOfLengthBetween(5, 50));\n            }\n        }\n        if (randomBoolean()) {\n            int scriptFieldsSize = randomInt(25);\n            for (int i = 0; i < scriptFieldsSize; i++) {\n                if (randomBoolean()) {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"), randomBoolean());\n                } else {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"));\n                }\n            }\n        }\n        if (randomBoolean()) {\n            FetchSourceContext fetchSourceContext;\n            int branch = randomInt(5);\n            String[] includes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < includes.length; i++) {\n                includes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            String[] excludes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < excludes.length; i++) {\n                excludes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            switch (branch) {\n            case 0:\n                fetchSourceContext = new FetchSourceContext(randomBoolean());\n                break;\n            case 1:\n                fetchSourceContext = new FetchSourceContext(includes, excludes);\n                break;\n            case 2:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20));\n                break;\n            case 3:\n                fetchSourceContext = new FetchSourceContext(true, includes, excludes);\n                break;\n            case 4:\n                fetchSourceContext = new FetchSourceContext(includes);\n                break;\n            case 5:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20));\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            builder.fetchSource(fetchSourceContext);\n        }\n        if (randomBoolean()) {\n            int size = randomIntBetween(0, 20);\n            List<String> statsGroups = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                statsGroups.add(randomAsciiOfLengthBetween(5, 20));\n            }\n            builder.stats(statsGroups);\n        }\n        if (randomBoolean()) {\n            int indexBoostSize = randomIntBetween(1, 10);\n            for (int i = 0; i < indexBoostSize; i++) {\n                builder.indexBoost(randomAsciiOfLengthBetween(5, 20), randomFloat() * 10);\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.query(RandomQueryBuilder.createQuery(getRandom()));\n            builder.query(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.postFilter(RandomQueryBuilder.createQuery(getRandom()));\n            builder.postFilter(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            int numSorts = randomIntBetween(1, 5);\n            for (int i = 0; i < numSorts; i++) {\n                int branch = randomInt(5);\n                switch (branch) {\n                case 0:\n                    builder.sort(SortBuilders.fieldSort(randomAsciiOfLengthBetween(5, 20)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 1:\n                    builder.sort(SortBuilders.geoDistanceSort(randomAsciiOfLengthBetween(5, 20),\n                            AbstractQueryTestCase.randomGeohash(1, 12)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 2:\n                    builder.sort(SortBuilders.scoreSort().order(randomFrom(SortOrder.values())));\n                    break;\n                case 3:\n                    builder.sort(SortBuilders.scriptSort(new Script(\"foo\"), \"number\").order(randomFrom(SortOrder.values())));\n                    break;\n                case 4:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20));\n                    break;\n                case 5:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20), randomFrom(SortOrder.values()));\n                    break;\n                }\n            }\n        }\n\n        if (randomBoolean()) {\n            int numSearchFrom = randomIntBetween(1, 5);\n            // We build a json version of the search_from first in order to\n            // ensure that every number type remain the same before/after xcontent (de)serialization.\n            // This is not a problem because the final type of each field value is extracted from associated sort field.\n            // This little trick ensure that equals and hashcode are the same when using the xcontent serialization.\n            XContentBuilder jsonBuilder = XContentFactory.jsonBuilder();\n            jsonBuilder.startObject();\n            jsonBuilder.startArray(\"search_from\");\n            for (int i = 0; i < numSearchFrom; i++) {\n                int branch = randomInt(8);\n                switch (branch) {\n                    case 0:\n                        jsonBuilder.value(randomInt());\n                        break;\n                    case 1:\n                        jsonBuilder.value(randomFloat());\n                        break;\n                    case 2:\n                        jsonBuilder.value(randomLong());\n                        break;\n                    case 3:\n                        jsonBuilder.value(randomDouble());\n                        break;\n                    case 4:\n                        jsonBuilder.value(randomAsciiOfLengthBetween(5, 20));\n                        break;\n                    case 5:\n                        jsonBuilder.value(randomBoolean());\n                        break;\n                    case 6:\n                        jsonBuilder.value(randomByte());\n                        break;\n                    case 7:\n                        jsonBuilder.value(randomShort());\n                        break;\n                    case 8:\n                        jsonBuilder.value(new Text(randomAsciiOfLengthBetween(5, 20)));\n                        break;\n                }\n            }\n            jsonBuilder.endArray();\n            jsonBuilder.endObject();\n            XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(jsonBuilder.bytes());\n            parser.nextToken();\n            parser.nextToken();\n            parser.nextToken();\n            builder.searchAfter(SearchAfterBuilder.PROTOTYPE.fromXContent(parser, null).getSortValues());\n        }\n        if (randomBoolean()) {\n            builder.highlighter(HighlightBuilderTests.randomHighlighterBuilder());\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random suggest builder method\n            builder.suggest(new SuggestBuilder().setText(randomAsciiOfLengthBetween(1, 5)).addSuggestion(\n                    SuggestBuilders.termSuggestion(randomAsciiOfLengthBetween(1, 5))));\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random inner hits builder method\n            InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder();\n            InnerHit innerHit = new InnerHit();\n            innerHit.field(randomAsciiOfLengthBetween(5, 20));\n            innerHitsBuilder.addNestedInnerHits(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20), innerHit);\n            builder.innerHits(innerHitsBuilder);\n        }\n        if (randomBoolean()) {\n            int numRescores = randomIntBetween(1, 5);\n            for (int i = 0; i < numRescores; i++) {\n                builder.addRescorer(QueryRescoreBuilderTests.randomRescoreBuilder());\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random aggregation builder method\n            builder.aggregation(AggregationBuilders.avg(randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (true) {\n            // NORELEASE need a method to randomly build content for ext\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();\n            xContentBuilder.startObject();\n            xContentBuilder.field(\"term_vectors_fetch\", randomAsciiOfLengthBetween(5, 20));\n            xContentBuilder.endObject();\n            builder.ext(xContentBuilder);\n        }\n        return builder;\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.geohashes(hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.points(new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.point(2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").geohashes(\"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","id":135,"modified_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", 2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", \"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testManyToManyGeoPointsWithDifferentFormats() throws ExecutionException, InterruptedException, IOException {\n        /**   q     d1       d2\n         * |4  o|   x    |   x\n         * |    |        |\n         * |3  o|  x     |  x\n         * |    |        |\n         * |2  o| x      | x\n         * |    |        |\n         * |1  o|x       |x\n         * |______________________\n         * 1   2   3   4   5   6\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(2.5, 1), new GeoPoint(2.75, 2), new GeoPoint(3, 3), new GeoPoint(3.25, 4)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(4.5, 1), new GeoPoint(4.75, 2), new GeoPoint(5, 3), new GeoPoint(5.25, 4)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n\n        List<String> qHashes = new ArrayList<>();\n        List<GeoPoint> qPoints = new ArrayList<>();\n        createQPoints(qHashes, qPoints);\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        for (int i = 0; i < 4; i++) {\n            int at = randomInt(3 - i);\n            if (randomBoolean()) {\n                geoDistanceSortBuilder.geohashes(qHashes.get(at));\n            } else {\n                geoDistanceSortBuilder.points(qPoints.get(at));\n            }\n            qHashes.remove(at);\n            qPoints.remove(at);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(4.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(3.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(5.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n    }","id":136,"modified_method":"public void testManyToManyGeoPointsWithDifferentFormats() throws ExecutionException, InterruptedException, IOException {\n        /**   q     d1       d2\n         * |4  o|   x    |   x\n         * |    |        |\n         * |3  o|  x     |  x\n         * |    |        |\n         * |2  o| x      | x\n         * |    |        |\n         * |1  o|x       |x\n         * |______________________\n         * 1   2   3   4   5   6\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(2.5, 1), new GeoPoint(2.75, 2), new GeoPoint(3, 3), new GeoPoint(3.25, 4)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(4.5, 1), new GeoPoint(4.75, 2), new GeoPoint(5, 3), new GeoPoint(5.25, 4)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n\n        List<String> qHashes = new ArrayList<>();\n        List<GeoPoint> qPoints = new ArrayList<>();\n        createQPoints(qHashes, qPoints);\n\n        \n        GeoDistanceSortBuilder geoDistanceSortBuilder = null;\n        for (int i = 0; i < 4; i++) {\n            int at = randomInt(3 - i);\n            if (randomBoolean()) {\n              \tif (geoDistanceSortBuilder == null) {\n              \t  geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", qHashes.get(at));\n              \t} else {\n              \t  geoDistanceSortBuilder.geohashes(qHashes.get(at));\n              \t}\n            } else {\n              if (geoDistanceSortBuilder == null) {\n        \tgeoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", qPoints.get(at));\n              } else {\n                geoDistanceSortBuilder.points(qPoints.get(at));\n              }\n            }\n            qHashes.remove(at);\n            qPoints.remove(at);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(4.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(3.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(5.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testManyToManyGeoPoints() throws ExecutionException, InterruptedException, IOException {\n        /**\n         * | q  |  d1    |   d2\n         * |    |        |\n         * |    |        |\n         * |    |        |\n         * |2  o|  x     |     x\n         * |    |        |\n         * |1  o|      x | x\n         * |___________________________\n         * 1   2   3   4   5   6   7\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(3, 2), new GeoPoint(4, 1)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(5, 1), new GeoPoint(6, 2)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        logger.info(d1Builder.string());\n        logger.info(d2Builder.string());\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n        GeoPoint[] q = new GeoPoint[2];\n        if (randomBoolean()) {\n            q[0] = new GeoPoint(2, 1);\n            q[1] = new GeoPoint(2, 2);\n        } else {\n            q[1] = new GeoPoint(2, 2);\n            q[0] = new GeoPoint(2, 1);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"min\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"max\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n    }","id":137,"modified_method":"public void testManyToManyGeoPoints() throws ExecutionException, InterruptedException, IOException {\n        /**\n         * | q  |  d1    |   d2\n         * |    |        |\n         * |    |        |\n         * |    |        |\n         * |2  o|  x     |     x\n         * |    |        |\n         * |1  o|      x | x\n         * |___________________________\n         * 1   2   3   4   5   6   7\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(3, 2), new GeoPoint(4, 1)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(5, 1), new GeoPoint(6, 2)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        logger.info(d1Builder.string());\n        logger.info(d2Builder.string());\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n        GeoPoint[] q = new GeoPoint[2];\n        if (randomBoolean()) {\n            q[0] = new GeoPoint(2, 1);\n            q[1] = new GeoPoint(2, 2);\n        } else {\n            q[1] = new GeoPoint(2, 2);\n            q[0] = new GeoPoint(2, 1);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"min\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"max\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * A geo distance based sort.\n     *\n     * @param fieldName The geo point like field name.\n     */\n    public static GeoDistanceSortBuilder geoDistanceSort(String fieldName) {\n        return new GeoDistanceSortBuilder(fieldName);\n    }","id":138,"modified_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     */\n    public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, String ... geohashes) {\n        return new GeoDistanceSortBuilder(fieldName, geohashes);\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingNestedFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\").startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject().startObject(\"branches\").field(\"type\", \"nested\")\n                .startObject(\"properties\").startObject(\"name\").field(\"type\", \"string\").endObject().startObject(\"location\")\n                .field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject().endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").setSettings(settings).addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true,\n                client().prepareIndex(\"companies\", \"company\", \"1\")\n                        .setSource(\n                                jsonBuilder().startObject().field(\"name\", \"company 1\").startArray(\"branches\").startObject()\n                                        .field(\"name\", \"New York\").startObject(\"location\").field(\"lat\", 40.7143528)\n                                        .field(\"lon\",\n                                                -74.0059731)\n                                        .endObject().endObject().endArray().endObject()),\n                client().prepareIndex(\"companies\", \"company\", \"2\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"company 2\").startArray(\"branches\").startObject()\n                                .field(\"name\", \"Times Square\").startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722)\n                                .endObject() // to NY: 5.286 km\n                                .endObject().startObject().field(\"name\", \"Tribeca\").startObject(\"location\").field(\"lat\", 40.718266)\n                                .field(\"lon\", -74.007819).endObject() // to NY:\n                                                                      // 0.4621\n                                                                      // km\n                                .endObject().endArray().endObject()),\n                client().prepareIndex(\"companies\", \"company\", \"3\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"company 3\").startArray(\"branches\").startObject()\n                                .field(\"name\", \"Wall Street\").startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305)\n                                .endObject() // to NY: 1.055 km\n                                .endObject().startObject().field(\"name\", \"Soho\").startObject(\"location\").field(\"lat\", 40.7247222)\n                                .field(\"lon\", -74).endObject() // to NY: 1.258\n                                                               // km\n                                .endObject().endArray().endObject()),\n                client().prepareIndex(\"companies\", \"company\", \"4\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"company 4\").startArray(\"branches\").startObject()\n                                .field(\"name\", \"Greenwich Village\").startObject(\"location\").field(\"lat\", 40.731033)\n                                .field(\"lon\", -73.9962255).endObject() // to NY:\n                                                                       // 2.029\n                                                                       // km\n                                .endObject().startObject().field(\"name\", \"Brooklyn\").startObject(\"location\").field(\"lat\", 40.65)\n                                .field(\"lon\", -73.95).endObject() // to NY:\n                                                                  // 8.572 km\n                                .endObject().endArray().endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders\n                .geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client()\n                .prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\")\n                        .point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders\n                .geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client()\n                .prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\")\n                        .point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client()\n                .prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\")\n                        .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\")\n                .setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\").setNestedPath(\"branches\")\n                        .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                        .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(\n                client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                        .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"sum\")\n                                .setNestedPath(\"branches\")),\n                RestStatus.BAD_REQUEST, containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":139,"modified_method":"public void testDistanceSortingNestedFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\").startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject().startObject(\"branches\").field(\"type\", \"nested\")\n                .startObject(\"properties\").startObject(\"name\").field(\"type\", \"string\").endObject().startObject(\"location\")\n                .field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject().endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").setSettings(settings).addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true,\n                client().prepareIndex(\"companies\", \"company\", \"1\")\n                        .setSource(\n                                jsonBuilder().startObject().field(\"name\", \"company 1\").startArray(\"branches\").startObject()\n                                        .field(\"name\", \"New York\").startObject(\"location\").field(\"lat\", 40.7143528)\n                                        .field(\"lon\",\n                                                -74.0059731)\n                                        .endObject().endObject().endArray().endObject()),\n                client().prepareIndex(\"companies\", \"company\", \"2\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"company 2\").startArray(\"branches\").startObject()\n                                .field(\"name\", \"Times Square\").startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722)\n                                .endObject() // to NY: 5.286 km\n                                .endObject().startObject().field(\"name\", \"Tribeca\").startObject(\"location\").field(\"lat\", 40.718266)\n                                .field(\"lon\", -74.007819).endObject() // to NY:\n                                                                      // 0.4621\n                                                                      // km\n                                .endObject().endArray().endObject()),\n                client().prepareIndex(\"companies\", \"company\", \"3\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"company 3\").startArray(\"branches\").startObject()\n                                .field(\"name\", \"Wall Street\").startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305)\n                                .endObject() // to NY: 1.055 km\n                                .endObject().startObject().field(\"name\", \"Soho\").startObject(\"location\").field(\"lat\", 40.7247222)\n                                .field(\"lon\", -74).endObject() // to NY: 1.258\n                                                               // km\n                                .endObject().endArray().endObject()),\n                client().prepareIndex(\"companies\", \"company\", \"4\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"company 4\").startArray(\"branches\").startObject()\n                                .field(\"name\", \"Greenwich Village\").startObject(\"location\").field(\"lat\", 40.731033)\n                                .field(\"lon\", -73.9962255).endObject() // to NY:\n                                                                       // 2.029\n                                                                       // km\n                                .endObject().startObject().field(\"name\", \"Brooklyn\").startObject(\"location\").field(\"lat\", 40.65)\n                                .field(\"lon\", -73.95).endObject() // to NY:\n                                                                  // 8.572 km\n                                .endObject().endArray().endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders\n                .geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client()\n                .prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\",\n                        40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders\n                .geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client()\n                .prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\",\n                        40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client()\n                .prepareSearch(\"companies\").setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\",\n                        40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\")\n                .setQuery(matchAllQuery()).addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731)\n                        .setNestedPath(\"branches\").sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731)\n                        .setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                        .sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        try {\n                client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                        .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).sortMode(\"sum\")\n                                .setNestedPath(\"branches\"));\n                fail(\"Sum should not be allowed as sort mode\");\n        } catch (IllegalArgumentException e) {\n            //expected\n        }\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimpleDistance() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                .startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true,\n                client().prepareIndex(\"test\", \"type1\", \"1\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"New York\").startObject(\"location\").field(\"lat\", 40.7143528)\n                                .field(\"lon\", -74.0059731).endObject().endObject()),\n                // to NY: 5.286 km\n                client().prepareIndex(\"test\", \"type1\", \"2\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Times Square\").startObject(\"location\").field(\"lat\", 40.759011)\n                                .field(\"lon\", -73.9844722).endObject().endObject()),\n                // to NY: 0.4621 km\n                client().prepareIndex(\"test\", \"type1\", \"3\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Tribeca\").startObject(\"location\").field(\"lat\", 40.718266)\n                                .field(\"lon\", -74.007819).endObject().endObject()),\n                // to NY: 1.055 km\n                client().prepareIndex(\"test\", \"type1\", \"4\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Wall Street\").startObject(\"location\").field(\"lat\", 40.7051157)\n                                .field(\"lon\", -74.0088305).endObject().endObject()),\n                // to NY: 1.258 km\n                client().prepareIndex(\"test\", \"type1\", \"5\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Soho\").startObject(\"location\").field(\"lat\", 40.7247222)\n                                .field(\"lon\", -74).endObject().endObject()),\n                // to NY: 2.029 km\n                client().prepareIndex(\"test\", \"type1\", \"6\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Greenwich Village\").startObject(\"location\")\n                                .field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject().endObject()),\n                // to NY: 8.572 km\n                client().prepareIndex(\"test\", \"type1\", \"7\").setSource(jsonBuilder().startObject().field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject().endObject()));\n\n        SearchResponse searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731)).execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\")).execute()\n                .actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // now with a PLANE type\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").geoDistance(GeoDistance.PLANE).point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // factor type is really too small for this resolution\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731)).execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\")).execute()\n                .actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731)).execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\")).execute()\n                .actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\")).execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\").optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).to(\"2.0km\")).execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"2.0km\")).execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits().length, equalTo(3));\n\n        // SORTING\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\").point(40.7143528, -74.0059731).order(SortOrder.ASC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"4\", \"5\", \"6\", \"2\", \"7\");\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\").point(40.7143528, -74.0059731).order(SortOrder.DESC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"7\", \"2\", \"6\", \"5\", \"4\", \"3\", \"1\");\n    }","id":140,"modified_method":"public void testSimpleDistance() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                .startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true,\n                client().prepareIndex(\"test\", \"type1\", \"1\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"New York\").startObject(\"location\").field(\"lat\", 40.7143528)\n                                .field(\"lon\", -74.0059731).endObject().endObject()),\n                // to NY: 5.286 km\n                client().prepareIndex(\"test\", \"type1\", \"2\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Times Square\").startObject(\"location\").field(\"lat\", 40.759011)\n                                .field(\"lon\", -73.9844722).endObject().endObject()),\n                // to NY: 0.4621 km\n                client().prepareIndex(\"test\", \"type1\", \"3\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Tribeca\").startObject(\"location\").field(\"lat\", 40.718266)\n                                .field(\"lon\", -74.007819).endObject().endObject()),\n                // to NY: 1.055 km\n                client().prepareIndex(\"test\", \"type1\", \"4\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Wall Street\").startObject(\"location\").field(\"lat\", 40.7051157)\n                                .field(\"lon\", -74.0088305).endObject().endObject()),\n                // to NY: 1.258 km\n                client().prepareIndex(\"test\", \"type1\", \"5\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Soho\").startObject(\"location\").field(\"lat\", 40.7247222)\n                                .field(\"lon\", -74).endObject().endObject()),\n                // to NY: 2.029 km\n                client().prepareIndex(\"test\", \"type1\", \"6\")\n                        .setSource(jsonBuilder().startObject().field(\"name\", \"Greenwich Village\").startObject(\"location\")\n                                .field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject().endObject()),\n                // to NY: 8.572 km\n                client().prepareIndex(\"test\", \"type1\", \"7\").setSource(jsonBuilder().startObject().field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject().endObject()));\n\n        SearchResponse searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731)).execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\")).execute()\n                .actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // now with a PLANE type\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").geoDistance(GeoDistance.PLANE).point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // factor type is really too small for this resolution\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731)).execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\")).execute()\n                .actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731)).execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\")).execute()\n                .actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\")).execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\").optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).to(\"2.0km\")).execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"2.0km\")).execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits().length, equalTo(3));\n\n        // SORTING\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\", 40.7143528, -74.0059731).order(SortOrder.ASC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"4\", \"5\", \"6\", \"2\", \"7\");\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\", 40.7143528, -74.0059731).order(SortOrder.DESC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"7\", \"2\", \"6\", \"5\", \"4\", \"3\", \"1\");\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingWithMissingGeoPoint() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                .startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Times Square\", \"Tribeca\").startArray(\"locations\")\n                        // to NY: 5.286 km\n                        .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                        .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject().field(\"names\", \"Wall Street\", \"Soho\").endObject())\n                .execute().actionGet();\n\n        refresh();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC)).execute()\n                .actionGet();\n\n        // Doc with missing geo point is first, is consistent with 0.20.x\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286d, 10d));\n    }","id":141,"modified_method":"public void testDistanceSortingWithMissingGeoPoint() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                .startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Times Square\", \"Tribeca\").startArray(\"locations\")\n                        // to NY: 5.286 km\n                        .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                        .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject().field(\"names\", \"Wall Street\", \"Soho\").endObject())\n                .execute().actionGet();\n\n        refresh();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC)).execute()\n                .actionGet();\n\n        // Doc with missing geo point is first, is consistent with 0.20.x\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286d, 10d));\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingMVFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                .startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true).field(\"coerce\", true);\n        }\n        xContentBuilder.field(\"ignore_malformed\", true).endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject().field(\"names\", \"New York\")\n                .startObject(\"locations\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject().endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject().field(\"names\", \"New York 2\")\n                .startObject(\"locations\").field(\"lat\", 400.7143528).field(\"lon\", 285.9990269).endObject().endObject()).execute()\n                .actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Times Square\", \"Tribeca\").startArray(\"locations\")\n                        // to NY: 5.286 km\n                        .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                        .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"4\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Wall Street\", \"Soho\").startArray(\"locations\")\n                        // to NY: 1.055 km\n                        .startObject().field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                        // to NY: 1.258 km\n                        .startObject().field(\"lat\", 40.7247222).field(\"lon\", -74).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"5\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Greenwich Village\", \"Brooklyn\").startArray(\"locations\")\n                        // to NY: 2.029 km\n                        .startObject().field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                        // to NY: 8.572 km\n                        .startObject().field(\"lat\", 40.65).field(\"lon\", -73.95).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2874d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(5301d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        assertFailures(\n                client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                        .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"sum\")),\n                RestStatus.BAD_REQUEST, containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":142,"modified_method":"public void testDistanceSortingMVFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\").startObject(\"properties\")\n                .startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true).field(\"coerce\", true);\n        }\n        xContentBuilder.field(\"ignore_malformed\", true).endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject().field(\"names\", \"New York\")\n                .startObject(\"locations\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject().endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject().field(\"names\", \"New York 2\")\n                .startObject(\"locations\").field(\"lat\", 400.7143528).field(\"lon\", 285.9990269).endObject().endObject()).execute()\n                .actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Times Square\", \"Tribeca\").startArray(\"locations\")\n                        // to NY: 5.286 km\n                        .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                        .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"4\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Wall Street\", \"Soho\").startArray(\"locations\")\n                        // to NY: 1.055 km\n                        .startObject().field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                        // to NY: 1.258 km\n                        .startObject().field(\"lat\", 40.7247222).field(\"lon\", -74).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"5\")\n                .setSource(jsonBuilder().startObject().field(\"names\", \"Greenwich Village\", \"Brooklyn\").startArray(\"locations\")\n                        // to NY: 2.029 km\n                        .startObject().field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                        // to NY: 8.572 km\n                        .startObject().field(\"lat\", 40.65).field(\"lon\", -73.95).endObject().endArray().endObject())\n                .execute().actionGet();\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC)).execute()\n                .actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2874d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(5301d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        try {\n                client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                        .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"sum\"));\n                fail(\"sum should not be supported for sorting by geo distance\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GeoDistanceSortBuilder ignoreMalformed(boolean ignoreMalformed) {\n        this.ignoreMalformed = ignoreMalformed;\n        return this;\n    }","id":143,"modified_method":"public GeoDistanceSortBuilder ignoreMalformed(boolean ignoreMalformed) {\n        if (coerce == false) {\n            this.ignoreMalformed = ignoreMalformed;\n        }\n        return this;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     */\n    public GeoDistanceSortBuilder sortMode(String sortMode) {\n        this.sortMode = sortMode;\n        return this;\n    }","id":144,"modified_method":"/**\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     */\n    public GeoDistanceSortBuilder sortMode(String sortMode) {\n        MultiValueMode temp = MultiValueMode.fromString(sortMode);\n        if (temp == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n        this.sortMode = sortMode;\n        return this;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(\"_geo_distance\");\n        if (geohashes.size() == 0 && points.size() == 0) {\n            throw new ElasticsearchParseException(\"No points provided for _geo_distance sort.\");\n        }\n\n        builder.startArray(fieldName);\n        for (GeoPoint point : points) {\n            builder.value(point);\n        }\n        for (String geohash : geohashes) {\n            builder.value(geohash);\n        }\n        builder.endArray();\n\n        if (unit != null) {\n            builder.field(\"unit\", unit);\n        }\n        if (geoDistance != null) {\n            builder.field(\"distance_type\", geoDistance.name().toLowerCase(Locale.ROOT));\n        }\n        if (order == SortOrder.DESC) {\n            builder.field(\"reverse\", true);\n        }\n        if (sortMode != null) {\n            builder.field(\"mode\", sortMode);\n        }\n\n        if (nestedPath != null) {\n            builder.field(\"nested_path\", nestedPath);\n        }\n        if (nestedFilter != null) {\n            builder.field(\"nested_filter\", nestedFilter, params);\n        }\n        if (coerce != null) {\n            builder.field(\"coerce\", coerce);\n        }\n        if (ignoreMalformed != null) {\n            builder.field(\"ignore_malformed\", ignoreMalformed);\n        }\n\n        builder.endObject();\n        return builder;\n    }","id":145,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(NAME);\n\n        builder.startArray(fieldName);\n        for (GeoPoint point : points) {\n            builder.value(point);\n        }\n        builder.endArray();\n\n        builder.field(\"unit\", unit);\n        builder.field(\"distance_type\", geoDistance.name().toLowerCase(Locale.ROOT));\n        if (order == SortOrder.DESC) {\n            builder.field(\"reverse\", true);\n        } else {\n            builder.field(\"reverse\", false);\n        }\n\n        if (sortMode != null) {\n            builder.field(\"mode\", sortMode);\n        }\n\n        if (nestedPath != null) {\n            builder.field(\"nested_path\", nestedPath);\n        }\n        if (nestedFilter != null) {\n            builder.field(\"nested_filter\", nestedFilter, params);\n        }\n        builder.field(\"coerce\", coerce);\n        builder.field(\"ignore_malformed\", ignoreMalformed);\n\n        builder.endObject();\n        return builder;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * The geohash of the geo point to create the range distance facets from.\n     */\n    public GeoDistanceSortBuilder geohashes(String... geohashes) {\n        this.geohashes.addAll(Arrays.asList(geohashes));\n        return this;\n    }","id":146,"modified_method":"/**\n     * The geohash of the geo point to create the range distance facets from.\n     * \n     * Deprecated - please use points(GeoPoint... points) instead.\n     */\n    @Deprecated\n    public GeoDistanceSortBuilder geohashes(String... geohashes) {\n        for (String geohash : geohashes) {\n            this.points.add(GeoPoint.fromGeohash(geohash));\n        }\n        return this;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     */\n    public GeoDistanceSortBuilder(String fieldName) {\n        this.fieldName = fieldName;\n    }","id":147,"modified_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     */\n    public GeoDistanceSortBuilder(String fieldName, String ... geohashes) {\n        if (geohashes.length == 0) {\n            throw new IllegalArgumentException(\"Geo distance sorting needs at least one point.\");\n        }\n        for (String geohash : geohashes) {\n            this.points.add(GeoPoint.fromGeohash(geohash));\n        }\n        this.fieldName = fieldName;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Not relevant.\n     */\n    @Override\n    public SortBuilder missing(Object missing) {\n        return this;\n    }","id":148,"modified_method":"/**\n     * Not relevant.\n     *\n     * TODO should this throw an exception rather than silently ignore a parameter that is not used?\n     */\n    @Override\n    public GeoDistanceSortBuilder missing(Object missing) {\n        return this;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testManyToManyGeoPoints() throws ExecutionException, InterruptedException, IOException {\n        /**\n         * | q  |  d1    |   d2\n         * |    |        |\n         * |    |        |\n         * |    |        |\n         * |2  o|  x     |     x\n         * |    |        |\n         * |1  o|      x | x\n         * |___________________________\n         * 1   2   3   4   5   6   7\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(3, 2), new GeoPoint(4, 1)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(5, 1), new GeoPoint(6, 2)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        logger.info(d1Builder.string());\n        logger.info(d2Builder.string());\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n        GeoPoint[] q = new GeoPoint[2];\n        if (randomBoolean()) {\n            q[0] = new GeoPoint(2, 1);\n            q[1] = new GeoPoint(2, 2);\n        } else {\n            q[1] = new GeoPoint(2, 2);\n            q[0] = new GeoPoint(2, 1);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"min\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"max\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n    }","id":149,"modified_method":"public void testManyToManyGeoPoints() throws ExecutionException, InterruptedException, IOException {\n        /**\n         * | q  |  d1    |   d2\n         * |    |        |\n         * |    |        |\n         * |    |        |\n         * |2  o|  x     |     x\n         * |    |        |\n         * |1  o|      x | x\n         * |___________________________\n         * 1   2   3   4   5   6   7\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(3, 2), new GeoPoint(4, 1)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(5, 1), new GeoPoint(6, 2)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        logger.info(d1Builder.string());\n        logger.info(d2Builder.string());\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n        GeoPoint[] q = new GeoPoint[2];\n        if (randomBoolean()) {\n            q[0] = new GeoPoint(2, 1);\n            q[1] = new GeoPoint(2, 2);\n        } else {\n            q[1] = new GeoPoint(2, 2);\n            q[0] = new GeoPoint(2, 1);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"min\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"max\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.geohashes(hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.points(new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.point(2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").geohashes(\"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","id":150,"modified_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", 2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", \"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testManyToManyGeoPointsWithDifferentFormats() throws ExecutionException, InterruptedException, IOException {\n        /**   q     d1       d2\n         * |4  o|   x    |   x\n         * |    |        |\n         * |3  o|  x     |  x\n         * |    |        |\n         * |2  o| x      | x\n         * |    |        |\n         * |1  o|x       |x\n         * |______________________\n         * 1   2   3   4   5   6\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(2.5, 1), new GeoPoint(2.75, 2), new GeoPoint(3, 3), new GeoPoint(3.25, 4)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(4.5, 1), new GeoPoint(4.75, 2), new GeoPoint(5, 3), new GeoPoint(5.25, 4)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n\n        List<String> qHashes = new ArrayList<>();\n        List<GeoPoint> qPoints = new ArrayList<>();\n        createQPoints(qHashes, qPoints);\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        for (int i = 0; i < 4; i++) {\n            int at = randomInt(3 - i);\n            if (randomBoolean()) {\n                geoDistanceSortBuilder.geohashes(qHashes.get(at));\n            } else {\n                geoDistanceSortBuilder.points(qPoints.get(at));\n            }\n            qHashes.remove(at);\n            qPoints.remove(at);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(4.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(3.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(5.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n    }","id":151,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public void testManyToManyGeoPointsWithDifferentFormats() throws ExecutionException, InterruptedException, IOException {\n        /**   q     d1       d2\n         * |4  o|   x    |   x\n         * |    |        |\n         * |3  o|  x     |  x\n         * |    |        |\n         * |2  o| x      | x\n         * |    |        |\n         * |1  o|x       |x\n         * |______________________\n         * 1   2   3   4   5   6\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(2.5, 1), new GeoPoint(2.75, 2), new GeoPoint(3, 3), new GeoPoint(3.25, 4)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(4.5, 1), new GeoPoint(4.75, 2), new GeoPoint(5, 3), new GeoPoint(5.25, 4)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n\n        List<String> qHashes = new ArrayList<>();\n        List<GeoPoint> qPoints = new ArrayList<>();\n        createQPoints(qHashes, qPoints);\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = null;\n        for (int i = 0; i < 4; i++) {\n            int at = randomInt(3 - i);\n            if (randomBoolean()) {\n                if (geoDistanceSortBuilder == null) {\n                    geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", qHashes.get(at));\n                } else {\n                    geoDistanceSortBuilder.geohashes(qHashes.get(at));\n                }\n            } else {\n                if (geoDistanceSortBuilder == null) {\n                    geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", qPoints.get(at));\n                } else {\n                    geoDistanceSortBuilder.points(qPoints.get(at));\n                }\n            }\n            qHashes.remove(at);\n            qPoints.remove(at);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(4.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(3.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(5.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.indexShard().getIndexSettings().getIndexVersionCreated().before(Version.V_2_0_0);\n        boolean coerce = false;\n        boolean ignoreMalformed = false;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Query innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = nestedHelper.getInnerFilter();\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, context.searcher().createNormalizedWeight(innerDocumentsFilter, false));\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSetIterator innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","id":152,"modified_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.indexShard().getIndexSettings().getIndexVersionCreated().before(Version.V_2_0_0);\n        boolean coerce = GeoDistanceSortBuilder.DEFAULT_COERCE;\n        boolean ignoreMalformed = GeoDistanceSortBuilder.DEFAULT_IGNORE_MALFORMED;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                GeoDistanceSortBuilder.parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Query innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = nestedHelper.getInnerFilter();\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, context.searcher().createNormalizedWeight(innerDocumentsFilter, false));\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSetIterator innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected final SearchSourceBuilder createSearchSourceBuilder() throws IOException {\n        SearchSourceBuilder builder = new SearchSourceBuilder();\n        if (randomBoolean()) {\n            builder.from(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.size(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.explain(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.version(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.trackScores(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.minScore(randomFloat() * 1000);\n        }\n        if (randomBoolean()) {\n            builder.timeout(new TimeValue(randomIntBetween(1, 100), randomFrom(TimeUnit.values())));\n        }\n        if (randomBoolean()) {\n            builder.terminateAfter(randomIntBetween(1, 100000));\n        }\n        // if (randomBoolean()) {\n        // builder.defaultRescoreWindowSize(randomIntBetween(1, 100));\n        // }\n        if (randomBoolean()) {\n            int fieldsSize = randomInt(25);\n            List<String> fields = new ArrayList<>(fieldsSize);\n            for (int i = 0; i < fieldsSize; i++) {\n                fields.add(randomAsciiOfLengthBetween(5, 50));\n            }\n            builder.fields(fields);\n        }\n        if (randomBoolean()) {\n            int fieldDataFieldsSize = randomInt(25);\n            for (int i = 0; i < fieldDataFieldsSize; i++) {\n                builder.fieldDataField(randomAsciiOfLengthBetween(5, 50));\n            }\n        }\n        if (randomBoolean()) {\n            int scriptFieldsSize = randomInt(25);\n            for (int i = 0; i < scriptFieldsSize; i++) {\n                if (randomBoolean()) {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"), randomBoolean());\n                } else {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"));\n                }\n            }\n        }\n        if (randomBoolean()) {\n            FetchSourceContext fetchSourceContext;\n            int branch = randomInt(5);\n            String[] includes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < includes.length; i++) {\n                includes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            String[] excludes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < excludes.length; i++) {\n                excludes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            switch (branch) {\n            case 0:\n                fetchSourceContext = new FetchSourceContext(randomBoolean());\n                break;\n            case 1:\n                fetchSourceContext = new FetchSourceContext(includes, excludes);\n                break;\n            case 2:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20));\n                break;\n            case 3:\n                fetchSourceContext = new FetchSourceContext(true, includes, excludes);\n                break;\n            case 4:\n                fetchSourceContext = new FetchSourceContext(includes);\n                break;\n            case 5:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20));\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            builder.fetchSource(fetchSourceContext);\n        }\n        if (randomBoolean()) {\n            int size = randomIntBetween(0, 20);\n            List<String> statsGroups = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                statsGroups.add(randomAsciiOfLengthBetween(5, 20));\n            }\n            builder.stats(statsGroups);\n        }\n        if (randomBoolean()) {\n            int indexBoostSize = randomIntBetween(1, 10);\n            for (int i = 0; i < indexBoostSize; i++) {\n                builder.indexBoost(randomAsciiOfLengthBetween(5, 20), randomFloat() * 10);\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.query(RandomQueryBuilder.createQuery(getRandom()));\n            builder.query(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.postFilter(RandomQueryBuilder.createQuery(getRandom()));\n            builder.postFilter(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            int numSorts = randomIntBetween(1, 5);\n            for (int i = 0; i < numSorts; i++) {\n                int branch = randomInt(5);\n                switch (branch) {\n                case 0:\n                    builder.sort(SortBuilders.fieldSort(randomAsciiOfLengthBetween(5, 20)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 1:\n                    builder.sort(SortBuilders.geoDistanceSort(randomAsciiOfLengthBetween(5, 20))\n                            .geohashes(AbstractQueryTestCase.randomGeohash(1, 12)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 2:\n                    builder.sort(SortBuilders.scoreSort().order(randomFrom(SortOrder.values())));\n                    break;\n                case 3:\n                    builder.sort(SortBuilders.scriptSort(new Script(\"foo\"), \"number\").order(randomFrom(SortOrder.values())));\n                    break;\n                case 4:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20));\n                    break;\n                case 5:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20), randomFrom(SortOrder.values()));\n                    break;\n                }\n            }\n        }\n\n        if (randomBoolean()) {\n            int numSearchFrom = randomIntBetween(1, 5);\n            // We build a json version of the search_from first in order to\n            // ensure that every number type remain the same before/after xcontent (de)serialization.\n            // This is not a problem because the final type of each field value is extracted from associated sort field.\n            // This little trick ensure that equals and hashcode are the same when using the xcontent serialization.\n            XContentBuilder jsonBuilder = XContentFactory.jsonBuilder();\n            jsonBuilder.startObject();\n            jsonBuilder.startArray(\"search_from\");\n            for (int i = 0; i < numSearchFrom; i++) {\n                int branch = randomInt(8);\n                switch (branch) {\n                    case 0:\n                        jsonBuilder.value(randomInt());\n                        break;\n                    case 1:\n                        jsonBuilder.value(randomFloat());\n                        break;\n                    case 2:\n                        jsonBuilder.value(randomLong());\n                        break;\n                    case 3:\n                        jsonBuilder.value(randomDouble());\n                        break;\n                    case 4:\n                        jsonBuilder.value(randomAsciiOfLengthBetween(5, 20));\n                        break;\n                    case 5:\n                        jsonBuilder.value(randomBoolean());\n                        break;\n                    case 6:\n                        jsonBuilder.value(randomByte());\n                        break;\n                    case 7:\n                        jsonBuilder.value(randomShort());\n                        break;\n                    case 8:\n                        jsonBuilder.value(new Text(randomAsciiOfLengthBetween(5, 20)));\n                        break;\n                }\n            }\n            jsonBuilder.endArray();\n            jsonBuilder.endObject();\n            XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(jsonBuilder.bytes());\n            parser.nextToken();\n            parser.nextToken();\n            parser.nextToken();\n            builder.searchAfter(SearchAfterBuilder.PROTOTYPE.fromXContent(parser, null).getSortValues());\n        }\n        if (randomBoolean()) {\n            builder.highlighter(HighlightBuilderTests.randomHighlighterBuilder());\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random suggest builder method\n            builder.suggest(new SuggestBuilder().setText(randomAsciiOfLengthBetween(1, 5)).addSuggestion(\n                    SuggestBuilders.termSuggestion(randomAsciiOfLengthBetween(1, 5))));\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random inner hits builder method\n            InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder();\n            InnerHit innerHit = new InnerHit();\n            innerHit.field(randomAsciiOfLengthBetween(5, 20));\n            innerHitsBuilder.addNestedInnerHits(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20), innerHit);\n            builder.innerHits(innerHitsBuilder);\n        }\n        if (randomBoolean()) {\n            int numRescores = randomIntBetween(1, 5);\n            for (int i = 0; i < numRescores; i++) {\n                builder.addRescorer(QueryRescoreBuilderTests.randomRescoreBuilder());\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random aggregation builder method\n            builder.aggregation(AggregationBuilders.avg(randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (true) {\n            // NORELEASE need a method to randomly build content for ext\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();\n            xContentBuilder.startObject();\n            xContentBuilder.field(\"term_vectors_fetch\", randomAsciiOfLengthBetween(5, 20));\n            xContentBuilder.endObject();\n            builder.ext(xContentBuilder);\n        }\n        return builder;\n    }","id":153,"modified_method":"protected final SearchSourceBuilder createSearchSourceBuilder() throws IOException {\n        SearchSourceBuilder builder = new SearchSourceBuilder();\n        if (randomBoolean()) {\n            builder.from(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.size(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.explain(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.version(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.trackScores(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.minScore(randomFloat() * 1000);\n        }\n        if (randomBoolean()) {\n            builder.timeout(new TimeValue(randomIntBetween(1, 100), randomFrom(TimeUnit.values())));\n        }\n        if (randomBoolean()) {\n            builder.terminateAfter(randomIntBetween(1, 100000));\n        }\n        // if (randomBoolean()) {\n        // builder.defaultRescoreWindowSize(randomIntBetween(1, 100));\n        // }\n        if (randomBoolean()) {\n            int fieldsSize = randomInt(25);\n            List<String> fields = new ArrayList<>(fieldsSize);\n            for (int i = 0; i < fieldsSize; i++) {\n                fields.add(randomAsciiOfLengthBetween(5, 50));\n            }\n            builder.fields(fields);\n        }\n        if (randomBoolean()) {\n            int fieldDataFieldsSize = randomInt(25);\n            for (int i = 0; i < fieldDataFieldsSize; i++) {\n                builder.fieldDataField(randomAsciiOfLengthBetween(5, 50));\n            }\n        }\n        if (randomBoolean()) {\n            int scriptFieldsSize = randomInt(25);\n            for (int i = 0; i < scriptFieldsSize; i++) {\n                if (randomBoolean()) {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"), randomBoolean());\n                } else {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"));\n                }\n            }\n        }\n        if (randomBoolean()) {\n            FetchSourceContext fetchSourceContext;\n            int branch = randomInt(5);\n            String[] includes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < includes.length; i++) {\n                includes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            String[] excludes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < excludes.length; i++) {\n                excludes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            switch (branch) {\n            case 0:\n                fetchSourceContext = new FetchSourceContext(randomBoolean());\n                break;\n            case 1:\n                fetchSourceContext = new FetchSourceContext(includes, excludes);\n                break;\n            case 2:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20));\n                break;\n            case 3:\n                fetchSourceContext = new FetchSourceContext(true, includes, excludes);\n                break;\n            case 4:\n                fetchSourceContext = new FetchSourceContext(includes);\n                break;\n            case 5:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20));\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            builder.fetchSource(fetchSourceContext);\n        }\n        if (randomBoolean()) {\n            int size = randomIntBetween(0, 20);\n            List<String> statsGroups = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                statsGroups.add(randomAsciiOfLengthBetween(5, 20));\n            }\n            builder.stats(statsGroups);\n        }\n        if (randomBoolean()) {\n            int indexBoostSize = randomIntBetween(1, 10);\n            for (int i = 0; i < indexBoostSize; i++) {\n                builder.indexBoost(randomAsciiOfLengthBetween(5, 20), randomFloat() * 10);\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.query(RandomQueryBuilder.createQuery(getRandom()));\n            builder.query(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.postFilter(RandomQueryBuilder.createQuery(getRandom()));\n            builder.postFilter(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            int numSorts = randomIntBetween(1, 5);\n            for (int i = 0; i < numSorts; i++) {\n                int branch = randomInt(5);\n                switch (branch) {\n                case 0:\n                    builder.sort(SortBuilders.fieldSort(randomAsciiOfLengthBetween(5, 20)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 1:\n                    builder.sort(SortBuilders.geoDistanceSort(randomAsciiOfLengthBetween(5, 20),\n                            AbstractQueryTestCase.randomGeohash(1, 12)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 2:\n                    builder.sort(SortBuilders.scoreSort().order(randomFrom(SortOrder.values())));\n                    break;\n                case 3:\n                    builder.sort(SortBuilders.scriptSort(new Script(\"foo\"), \"number\").order(randomFrom(SortOrder.values())));\n                    break;\n                case 4:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20));\n                    break;\n                case 5:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20), randomFrom(SortOrder.values()));\n                    break;\n                }\n            }\n        }\n\n        if (randomBoolean()) {\n            int numSearchFrom = randomIntBetween(1, 5);\n            // We build a json version of the search_from first in order to\n            // ensure that every number type remain the same before/after xcontent (de)serialization.\n            // This is not a problem because the final type of each field value is extracted from associated sort field.\n            // This little trick ensure that equals and hashcode are the same when using the xcontent serialization.\n            XContentBuilder jsonBuilder = XContentFactory.jsonBuilder();\n            jsonBuilder.startObject();\n            jsonBuilder.startArray(\"search_from\");\n            for (int i = 0; i < numSearchFrom; i++) {\n                int branch = randomInt(8);\n                switch (branch) {\n                    case 0:\n                        jsonBuilder.value(randomInt());\n                        break;\n                    case 1:\n                        jsonBuilder.value(randomFloat());\n                        break;\n                    case 2:\n                        jsonBuilder.value(randomLong());\n                        break;\n                    case 3:\n                        jsonBuilder.value(randomDouble());\n                        break;\n                    case 4:\n                        jsonBuilder.value(randomAsciiOfLengthBetween(5, 20));\n                        break;\n                    case 5:\n                        jsonBuilder.value(randomBoolean());\n                        break;\n                    case 6:\n                        jsonBuilder.value(randomByte());\n                        break;\n                    case 7:\n                        jsonBuilder.value(randomShort());\n                        break;\n                    case 8:\n                        jsonBuilder.value(new Text(randomAsciiOfLengthBetween(5, 20)));\n                        break;\n                }\n            }\n            jsonBuilder.endArray();\n            jsonBuilder.endObject();\n            XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(jsonBuilder.bytes());\n            parser.nextToken();\n            parser.nextToken();\n            parser.nextToken();\n            builder.searchAfter(SearchAfterBuilder.PROTOTYPE.fromXContent(parser, null).getSortValues());\n        }\n        if (randomBoolean()) {\n            builder.highlighter(HighlightBuilderTests.randomHighlighterBuilder());\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random suggest builder method\n            builder.suggest(new SuggestBuilder().setText(randomAsciiOfLengthBetween(1, 5)).addSuggestion(\n                    SuggestBuilders.termSuggestion(randomAsciiOfLengthBetween(1, 5))));\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random inner hits builder method\n            InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder();\n            InnerHit innerHit = new InnerHit();\n            innerHit.field(randomAsciiOfLengthBetween(5, 20));\n            innerHitsBuilder.addNestedInnerHits(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20), innerHit);\n            builder.innerHits(innerHitsBuilder);\n        }\n        if (randomBoolean()) {\n            int numRescores = randomIntBetween(1, 5);\n            for (int i = 0; i < numRescores; i++) {\n                builder.addRescorer(QueryRescoreBuilderTests.randomRescoreBuilder());\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random aggregation builder method\n            builder.aggregation(AggregationBuilders.avg(randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (true) {\n            // NORELEASE need a method to randomly build content for ext\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();\n            xContentBuilder.startObject();\n            xContentBuilder.field(\"term_vectors_fetch\", randomAsciiOfLengthBetween(5, 20));\n            xContentBuilder.endObject();\n            builder.ext(xContentBuilder);\n        }\n        return builder;\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * A geo distance based sort.\n     *\n     * @param fieldName The geo point like field name.\n     */\n    public static GeoDistanceSortBuilder geoDistanceSort(String fieldName) {\n        return new GeoDistanceSortBuilder(fieldName);\n    }","id":154,"modified_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     */\n    public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, String ... geohashes) {\n        return new GeoDistanceSortBuilder(fieldName, geohashes);\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GeoDistanceSortBuilder ignoreMalformed(boolean ignoreMalformed) {\n        if (coerce == false) {\n            this.ignoreMalformed = ignoreMalformed;\n        }\n        return this;\n    }","id":155,"modified_method":"public GeoDistanceSortBuilder ignoreMalformed(boolean ignoreMalformed) {\n        this.ignoreMalformed = ignoreMalformed;\n        return this;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     */\n    public GeoDistanceSortBuilder sortMode(String sortMode) {\n        MultiValueMode temp = MultiValueMode.fromString(sortMode);\n        if (temp == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n        this.sortMode = sortMode;\n        return this;\n    }","id":156,"modified_method":"/**\n     * Defines which distance to use for sorting in the case a document contains multiple geo points.\n     * Possible values: min and max\n     */\n    public GeoDistanceSortBuilder sortMode(String sortMode) {\n        this.sortMode = sortMode;\n        return this;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * The geohash of the geo point to create the range distance facets from.\n     * \n     * Deprecated - please use points(GeoPoint... points) instead.\n     */\n    @Deprecated\n    public GeoDistanceSortBuilder geohashes(String... geohashes) {\n        for (String geohash : geohashes) {\n            this.points.add(GeoPoint.fromGeohash(geohash));\n        }\n        return this;\n    }","id":157,"modified_method":"/**\n     * The geohash of the geo point to create the range distance facets from.\n     */\n    public GeoDistanceSortBuilder geohashes(String... geohashes) {\n        this.geohashes.addAll(Arrays.asList(geohashes));\n        return this;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Not relevant.\n     *\n     * TODO should this throw an exception rather than silently ignore a parameter that is not used?\n     */\n    @Override\n    public GeoDistanceSortBuilder missing(Object missing) {\n        return this;\n    }","id":158,"modified_method":"/**\n     * Not relevant.\n     */\n    @Override\n    public SortBuilder missing(Object missing) {\n        return this;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     */\n    public GeoDistanceSortBuilder(String fieldName, String ... geohashes) {\n        if (geohashes.length == 0) {\n            throw new IllegalArgumentException(\"Geo distance sorting needs at least one point.\");\n        }\n        for (String geohash : geohashes) {\n            this.points.add(GeoPoint.fromGeohash(geohash));\n        }\n        this.fieldName = fieldName;\n    }","id":159,"modified_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     */\n    public GeoDistanceSortBuilder(String fieldName) {\n        this.fieldName = fieldName;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(NAME);\n\n        builder.startArray(fieldName);\n        for (GeoPoint point : points) {\n            builder.value(point);\n        }\n        builder.endArray();\n\n        builder.field(\"unit\", unit);\n        builder.field(\"distance_type\", geoDistance.name().toLowerCase(Locale.ROOT));\n        if (order == SortOrder.DESC) {\n            builder.field(\"reverse\", true);\n        } else {\n            builder.field(\"reverse\", false);\n        }\n\n        if (sortMode != null) {\n            builder.field(\"mode\", sortMode);\n        }\n\n        if (nestedPath != null) {\n            builder.field(\"nested_path\", nestedPath);\n        }\n        if (nestedFilter != null) {\n            builder.field(\"nested_filter\", nestedFilter, params);\n        }\n        builder.field(\"coerce\", coerce);\n        builder.field(\"ignore_malformed\", ignoreMalformed);\n\n        builder.endObject();\n        return builder;\n    }","id":160,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(\"_geo_distance\");\n        if (geohashes.size() == 0 && points.size() == 0) {\n            throw new ElasticsearchParseException(\"No points provided for _geo_distance sort.\");\n        }\n\n        builder.startArray(fieldName);\n        for (GeoPoint point : points) {\n            builder.value(point);\n        }\n        for (String geohash : geohashes) {\n            builder.value(geohash);\n        }\n        builder.endArray();\n\n        if (unit != null) {\n            builder.field(\"unit\", unit);\n        }\n        if (geoDistance != null) {\n            builder.field(\"distance_type\", geoDistance.name().toLowerCase(Locale.ROOT));\n        }\n        if (order == SortOrder.DESC) {\n            builder.field(\"reverse\", true);\n        }\n        if (sortMode != null) {\n            builder.field(\"mode\", sortMode);\n        }\n\n        if (nestedPath != null) {\n            builder.field(\"nested_path\", nestedPath);\n        }\n        if (nestedFilter != null) {\n            builder.field(\"nested_filter\", nestedFilter, params);\n        }\n        if (coerce != null) {\n            builder.field(\"coerce\", coerce);\n        }\n        if (ignoreMalformed != null) {\n            builder.field(\"ignore_malformed\", ignoreMalformed);\n        }\n\n        builder.endObject();\n        return builder;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.indexShard().getIndexSettings().getIndexVersionCreated().before(Version.V_2_0_0);\n        boolean coerce = GeoDistanceSortBuilder.DEFAULT_COERCE;\n        boolean ignoreMalformed = GeoDistanceSortBuilder.DEFAULT_IGNORE_MALFORMED;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                GeoDistanceSortBuilder.parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Query innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = nestedHelper.getInnerFilter();\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, context.searcher().createNormalizedWeight(innerDocumentsFilter, false));\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSetIterator innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","id":161,"modified_method":"@Override\n    public SortField parse(XContentParser parser, SearchContext context) throws Exception {\n        String fieldName = null;\n        List<GeoPoint> geoPoints = new ArrayList<>();\n        DistanceUnit unit = DistanceUnit.DEFAULT;\n        GeoDistance geoDistance = GeoDistance.DEFAULT;\n        boolean reverse = false;\n        MultiValueMode sortMode = null;\n        NestedInnerQueryParseSupport nestedHelper = null;\n\n        final boolean indexCreatedBeforeV2_0 = context.indexShard().getIndexSettings().getIndexVersionCreated().before(Version.V_2_0_0);\n        boolean coerce = false;\n        boolean ignoreMalformed = false;\n\n        XContentParser.Token token;\n        String currentName = parser.currentName();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentName = parser.currentName();\n            } else if (token == XContentParser.Token.START_ARRAY) {\n                parseGeoPoints(parser, geoPoints);\n\n                fieldName = currentName;\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                // the json in the format of -> field : { lat : 30, lon : 12 }\n                if (\"nested_filter\".equals(currentName) || \"nestedFilter\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.filter();\n                } else {\n                    fieldName = currentName;\n                    GeoPoint point = new GeoPoint();\n                    GeoUtils.parseGeoPoint(parser, point);\n                    geoPoints.add(point);\n                }\n            } else if (token.isValue()) {\n                if (\"reverse\".equals(currentName)) {\n                    reverse = parser.booleanValue();\n                } else if (\"order\".equals(currentName)) {\n                    reverse = \"desc\".equals(parser.text());\n                } else if (currentName.equals(\"unit\")) {\n                    unit = DistanceUnit.fromString(parser.text());\n                } else if (currentName.equals(\"distance_type\") || currentName.equals(\"distanceType\")) {\n                    geoDistance = GeoDistance.fromString(parser.text());\n                } else if (\"coerce\".equals(currentName) || (indexCreatedBeforeV2_0 && \"normalize\".equals(currentName))) {\n                    coerce = parser.booleanValue();\n                    if (coerce == true) {\n                        ignoreMalformed = true;\n                    }\n                } else if (\"ignore_malformed\".equals(currentName) && coerce == false) {\n                    ignoreMalformed = parser.booleanValue();\n                } else if (\"sort_mode\".equals(currentName) || \"sortMode\".equals(currentName) || \"mode\".equals(currentName)) {\n                    sortMode = MultiValueMode.fromString(parser.text());\n                } else if (\"nested_path\".equals(currentName) || \"nestedPath\".equals(currentName)) {\n                    if (nestedHelper == null) {\n                        nestedHelper = new NestedInnerQueryParseSupport(parser, context);\n                    }\n                    nestedHelper.setPath(parser.text());\n                } else {\n                    GeoPoint point = new GeoPoint();\n                    point.resetFromString(parser.text());\n                    geoPoints.add(point);\n                    fieldName = currentName;\n                }\n            }\n        }\n\n        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes\n        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {\n            for (GeoPoint point : geoPoints) {\n                if (point.lat() > 90.0 || point.lat() < -90.0) {\n                    throw new ElasticsearchParseException(\"illegal latitude value [{}] for [GeoDistanceSort]\", point.lat());\n                }\n                if (point.lon() > 180.0 || point.lon() < -180) {\n                    throw new ElasticsearchParseException(\"illegal longitude value [{}] for [GeoDistanceSort]\", point.lon());\n                }\n            }\n        }\n\n        if (coerce) {\n            for (GeoPoint point : geoPoints) {\n                GeoUtils.normalizePoint(point, coerce, coerce);\n            }\n        }\n\n        if (sortMode == null) {\n            sortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN;\n        }\n\n        if (sortMode == MultiValueMode.SUM) {\n            throw new IllegalArgumentException(\"sort_mode [sum] isn't supported for sorting by geo distance\");\n        }\n\n        MappedFieldType fieldType = context.smartNameFieldType(fieldName);\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"failed to find mapper for [\" + fieldName + \"] for geo distance based sort\");\n        }\n        final MultiValueMode finalSortMode = sortMode; // final reference for use in the anonymous class\n        final IndexGeoPointFieldData geoIndexFieldData = context.fieldData().getForField(fieldType);\n        final FixedSourceDistance[] distances = new FixedSourceDistance[geoPoints.size()];\n        for (int i = 0; i< geoPoints.size(); i++) {\n            distances[i] = geoDistance.fixedSourceDistance(geoPoints.get(i).lat(), geoPoints.get(i).lon(), unit);\n        }\n\n        final Nested nested;\n        if (nestedHelper != null && nestedHelper.getPath() != null) {\n            BitSetProducer rootDocumentsFilter = context.bitsetFilterCache().getBitSetProducer(Queries.newNonNestedFilter());\n            Query innerDocumentsFilter;\n            if (nestedHelper.filterFound()) {\n                // TODO: use queries instead\n                innerDocumentsFilter = nestedHelper.getInnerFilter();\n            } else {\n                innerDocumentsFilter = nestedHelper.getNestedObjectMapper().nestedTypeFilter();\n            }\n            nested = new Nested(rootDocumentsFilter, context.searcher().createNormalizedWeight(innerDocumentsFilter, false));\n        } else {\n            nested = null;\n        }\n\n        IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource() {\n\n            @Override\n            public SortField.Type reducedType() {\n                return SortField.Type.DOUBLE;\n            }\n\n            @Override\n            public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n                return new FieldComparator.DoubleComparator(numHits, null, null) {\n                    @Override\n                    protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n                        final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues();\n                        final SortedNumericDoubleValues distanceValues = GeoDistance.distanceValues(geoPointValues, distances);\n                        final NumericDoubleValues selectedValues;\n                        if (nested == null) {\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE);\n                        } else {\n                            final BitSet rootDocs = nested.rootDocs(context);\n                            final DocIdSetIterator innerDocs = nested.innerDocs(context);\n                            selectedValues = finalSortMode.select(distanceValues, Double.MAX_VALUE, rootDocs, innerDocs, context.reader().maxDoc());\n                        }\n                        return selectedValues.getRawDoubleValues();\n                    }\n                };\n            }\n\n        };\n\n        return new SortField(fieldName, geoDistanceComparatorSource, reverse);\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimpleDistance() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"New York\")\n                .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()),\n        // to NY: 5.286 km\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Times Square\")\n                .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                .endObject()),\n        // to NY: 0.4621 km\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Tribeca\")\n                .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endObject()),\n        // to NY: 1.055 km\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Wall Street\")\n                .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                .endObject()),\n        // to NY: 1.258 km\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Soho\")\n                .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endObject()),\n        // to NY: 2.029 km\n        client().prepareIndex(\"test\", \"type1\", \"6\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Greenwich Village\")\n                .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                .endObject()),\n        // to NY: 8.572 km\n        client().prepareIndex(\"test\", \"type1\", \"7\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Brooklyn\")\n                .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endObject()));\n\n        SearchResponse searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // now with a PLANE type\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").geoDistance(GeoDistance.PLANE).point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // factor type is really too small for this resolution\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\").optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits().length, equalTo(3));\n\n        // SORTING\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\", 40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"4\", \"5\", \"6\", \"2\", \"7\");\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\", 40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"7\", \"2\", \"6\", \"5\", \"4\", \"3\", \"1\");\n    }","id":162,"modified_method":"public void testSimpleDistance() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"New York\")\n                .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()),\n        // to NY: 5.286 km\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Times Square\")\n                .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                .endObject()),\n        // to NY: 0.4621 km\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Tribeca\")\n                .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endObject()),\n        // to NY: 1.055 km\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Wall Street\")\n                .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                .endObject()),\n        // to NY: 1.258 km\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Soho\")\n                .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endObject()),\n        // to NY: 2.029 km\n        client().prepareIndex(\"test\", \"type1\", \"6\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Greenwich Village\")\n                .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                .endObject()),\n        // to NY: 8.572 km\n        client().prepareIndex(\"test\", \"type1\", \"7\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"Brooklyn\")\n                .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endObject()));\n\n        SearchResponse searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // now with a PLANE type\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"3km\").geoDistance(GeoDistance.PLANE).point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 5);\n        assertThat(searchResponse.getHits().hits().length, equalTo(5));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\"), equalTo(\"6\")));\n        }\n\n        // factor type is really too small for this resolution\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"2km\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceQuery(\"location\").distance(\"1.242mi\").point(40.7143528, -74.0059731).optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"1\"), equalTo(\"3\"), equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"1.0km\").to(\"2.0km\").optimizeBbox(\"indexed\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 2);\n        assertThat(searchResponse.getHits().hits().length, equalTo(2));\n        for (SearchHit hit : searchResponse.getHits()) {\n            assertThat(hit.id(), anyOf(equalTo(\"4\"), equalTo(\"5\")));\n        }\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).to(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertThat(searchResponse.getHits().hits().length, equalTo(4));\n\n        searchResponse = client().prepareSearch() // from NY\n                .setQuery(geoDistanceRangeQuery(\"location\", 40.7143528, -74.0059731).from(\"2.0km\"))\n                .execute().actionGet();\n        assertHitCount(searchResponse, 3);\n        assertThat(searchResponse.getHits().hits().length, equalTo(3));\n\n        // SORTING\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"4\", \"5\", \"6\", \"2\", \"7\");\n\n        searchResponse = client().prepareSearch().setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"location\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 7);\n        assertOrderedSearchHits(searchResponse, \"7\", \"2\", \"6\", \"5\", \"4\", \"3\", \"1\");\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingWithMissingGeoPoint() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        // Doc with missing geo point is first, is consistent with 0.20.x\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286d, 10d));\n    }","id":163,"modified_method":"public void testDistanceSortingWithMissingGeoPoint() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .endObject()).execute().actionGet();\n\n        refresh();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        // Doc with missing geo point is first, is consistent with 0.20.x\n        assertHitCount(searchResponse, 2);\n        assertOrderedSearchHits(searchResponse, \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286d, 10d));\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingNestedFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"branches\")\n                .field(\"type\", \"nested\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject()\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").setSettings(settings).addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"companies\", \"company\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 1\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"New York\")\n                        .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 2\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Times Square\")\n                        .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject() // to NY: 5.286 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Tribeca\")\n                        .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject() // to NY: 0.4621 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 3\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Wall Street\")\n                        .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject() // to NY: 1.055 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Soho\")\n                        .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject() // to NY: 1.258 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 4\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Greenwich Village\")\n                        .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject() // to NY: 2.029 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject() // to NY: 8.572 km\n                    .endObject()\n                .endArray()\n                .endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                    SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).setNestedPath(\"branches\")\n                            .sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                                .sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                    .addSort(SortBuilders.geoDistanceSort(\"branches.location\", 40.7143528, -74.0059731).sortMode(\"sum\").setNestedPath(\"branches\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":164,"modified_method":"public void testDistanceSortingNestedFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"company\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"branches\")\n                .field(\"type\", \"nested\")\n                .startObject(\"properties\")\n                .startObject(\"name\").field(\"type\", \"string\").endObject()\n                .startObject(\"location\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true);\n        }\n        xContentBuilder.endObject()\n                .endObject()\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n\n        assertAcked(prepareCreate(\"companies\").setSettings(settings).addMapping(\"company\", xContentBuilder));\n        ensureGreen();\n\n        indexRandom(true, client().prepareIndex(\"companies\", \"company\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 1\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"New York\")\n                        .startObject(\"location\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 2\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Times Square\")\n                        .startObject(\"location\").field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject() // to NY: 5.286 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Tribeca\")\n                        .startObject(\"location\").field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject() // to NY: 0.4621 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 3\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Wall Street\")\n                        .startObject(\"location\").field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject() // to NY: 1.055 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Soho\")\n                        .startObject(\"location\").field(\"lat\", 40.7247222).field(\"lon\", -74).endObject() // to NY: 1.258 km\n                    .endObject()\n                .endArray()\n                .endObject()),\n        client().prepareIndex(\"companies\", \"company\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"name\", \"company 4\")\n                .startArray(\"branches\")\n                    .startObject()\n                        .field(\"name\", \"Greenwich Village\")\n                        .startObject(\"location\").field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject() // to NY: 2.029 km\n                    .endObject()\n                    .startObject()\n                        .field(\"name\", \"Brooklyn\")\n                        .startObject(\"location\").field(\"lat\", 40.65).field(\"lon\", -73.95).endObject() // to NY: 8.572 km\n                    .endObject()\n                .endArray()\n                .endObject()));\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\").setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"1\", \"3\", \"2\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                    SortBuilders.geoDistanceSort(\"branches.location\").setNestedPath(\"branches\")\n                            .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 4);\n        assertOrderedSearchHits(searchResponse, \"4\", \"2\", \"3\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                .addSort(\n                        SortBuilders.geoDistanceSort(\"branches.location\").setNestedFilter(termQuery(\"branches.name\", \"brooklyn\"))\n                                .point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC).setNestedPath(\"branches\")\n                )\n                .execute().actionGet();\n        assertHitCount(searchResponse, 4);\n        assertFirstHit(searchResponse, hasId(\"4\"));\n        assertSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), equalTo(Double.MAX_VALUE));\n\n        assertFailures(client().prepareSearch(\"companies\").setQuery(matchAllQuery())\n                    .addSort(SortBuilders.geoDistanceSort(\"branches.location\").point(40.7143528, -74.0059731).sortMode(\"sum\").setNestedPath(\"branches\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testDistanceSortingMVFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true).field(\"coerce\", true);\n        }\n        xContentBuilder.field(\"ignore_malformed\", true).endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York\")\n                .startObject(\"locations\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York 2\")\n                .startObject(\"locations\").field(\"lat\", 400.7143528).field(\"lon\", 285.9990269).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .startArray(\"locations\")\n                        // to NY: 1.055 km\n                .startObject().field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                        // to NY: 1.258 km\n                .startObject().field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Greenwich Village\", \"Brooklyn\")\n                .startArray(\"locations\")\n                        // to NY: 2.029 km\n                .startObject().field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                        // to NY: 8.572 km\n                .startObject().field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\",  \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2874d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(5301d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        assertFailures(client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\", 40.7143528, -74.0059731).sortMode(\"sum\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","id":165,"modified_method":"public void testDistanceSortingMVFields() throws Exception {\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        XContentBuilder xContentBuilder = XContentFactory.jsonBuilder().startObject().startObject(\"type1\")\n                .startObject(\"properties\").startObject(\"locations\").field(\"type\", \"geo_point\");\n        if (version.before(Version.V_2_2_0)) {\n            xContentBuilder.field(\"lat_lon\", true).field(\"coerce\", true);\n        }\n        xContentBuilder.field(\"ignore_malformed\", true).endObject().endObject().endObject().endObject();\n        assertAcked(prepareCreate(\"test\").setSettings(settings).addMapping(\"type1\", xContentBuilder));\n        ensureGreen();\n\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York\")\n                .startObject(\"locations\").field(\"lat\", 40.7143528).field(\"lon\", -74.0059731).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"2\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"New York 2\")\n                .startObject(\"locations\").field(\"lat\", 400.7143528).field(\"lon\", 285.9990269).endObject()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"3\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Times Square\", \"Tribeca\")\n                .startArray(\"locations\")\n                        // to NY: 5.286 km\n                .startObject().field(\"lat\", 40.759011).field(\"lon\", -73.9844722).endObject()\n                        // to NY: 0.4621 km\n                .startObject().field(\"lat\", 40.718266).field(\"lon\", -74.007819).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().prepareIndex(\"test\", \"type1\", \"4\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Wall Street\", \"Soho\")\n                .startArray(\"locations\")\n                        // to NY: 1.055 km\n                .startObject().field(\"lat\", 40.7051157).field(\"lon\", -74.0088305).endObject()\n                        // to NY: 1.258 km\n                .startObject().field(\"lat\", 40.7247222).field(\"lon\", -74).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n\n        client().prepareIndex(\"test\", \"type1\", \"5\").setSource(jsonBuilder().startObject()\n                .field(\"names\", \"Greenwich Village\", \"Brooklyn\")\n                .startArray(\"locations\")\n                        // to NY: 2.029 km\n                .startObject().field(\"lat\", 40.731033).field(\"lon\", -73.9962255).endObject()\n                        // to NY: 8.572 km\n                .startObject().field(\"lat\", 40.65).field(\"lon\", -73.95).endObject()\n                .endArray()\n                .endObject()).execute().actionGet();\n\n        client().admin().indices().prepareRefresh().execute().actionGet();\n\n        // Order: Asc\n        SearchResponse searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"3\", \"4\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n\n        // Order: Asc, Mode: max\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.ASC).sortMode(\"max\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\",  \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n\n        // Order: Desc\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(8572.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(5286.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1258.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        // Order: Desc, Mode: min\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).order(SortOrder.DESC).sortMode(\"min\"))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"4\", \"3\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(2029.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(1055.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(462.1d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.ASC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"1\", \"2\", \"4\", \"3\", \"5\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(2874d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(5301d, 10d));\n\n        searchResponse = client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"avg\").order(SortOrder.DESC))\n                .execute().actionGet();\n\n        assertHitCount(searchResponse, 5);\n        assertOrderedSearchHits(searchResponse, \"5\", \"3\", \"4\", \"2\", \"1\");\n        assertThat(((Number) searchResponse.getHits().getAt(0).sortValues()[0]).doubleValue(), closeTo(5301.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(1).sortValues()[0]).doubleValue(), closeTo(2874.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(2).sortValues()[0]).doubleValue(), closeTo(1157.0d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(3).sortValues()[0]).doubleValue(), closeTo(421.2d, 10d));\n        assertThat(((Number) searchResponse.getHits().getAt(4).sortValues()[0]).doubleValue(), closeTo(0d, 10d));\n\n        assertFailures(client().prepareSearch(\"test\").setQuery(matchAllQuery())\n                .addSort(SortBuilders.geoDistanceSort(\"locations\").point(40.7143528, -74.0059731).sortMode(\"sum\")),\n                RestStatus.BAD_REQUEST,\n                containsString(\"sort_mode [sum] isn't supported for sorting by geo distance\"));\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected final SearchSourceBuilder createSearchSourceBuilder() throws IOException {\n        SearchSourceBuilder builder = new SearchSourceBuilder();\n        if (randomBoolean()) {\n            builder.from(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.size(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.explain(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.version(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.trackScores(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.minScore(randomFloat() * 1000);\n        }\n        if (randomBoolean()) {\n            builder.timeout(new TimeValue(randomIntBetween(1, 100), randomFrom(TimeUnit.values())));\n        }\n        if (randomBoolean()) {\n            builder.terminateAfter(randomIntBetween(1, 100000));\n        }\n        // if (randomBoolean()) {\n        // builder.defaultRescoreWindowSize(randomIntBetween(1, 100));\n        // }\n        if (randomBoolean()) {\n            int fieldsSize = randomInt(25);\n            List<String> fields = new ArrayList<>(fieldsSize);\n            for (int i = 0; i < fieldsSize; i++) {\n                fields.add(randomAsciiOfLengthBetween(5, 50));\n            }\n            builder.fields(fields);\n        }\n        if (randomBoolean()) {\n            int fieldDataFieldsSize = randomInt(25);\n            for (int i = 0; i < fieldDataFieldsSize; i++) {\n                builder.fieldDataField(randomAsciiOfLengthBetween(5, 50));\n            }\n        }\n        if (randomBoolean()) {\n            int scriptFieldsSize = randomInt(25);\n            for (int i = 0; i < scriptFieldsSize; i++) {\n                if (randomBoolean()) {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"), randomBoolean());\n                } else {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"));\n                }\n            }\n        }\n        if (randomBoolean()) {\n            FetchSourceContext fetchSourceContext;\n            int branch = randomInt(5);\n            String[] includes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < includes.length; i++) {\n                includes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            String[] excludes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < excludes.length; i++) {\n                excludes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            switch (branch) {\n            case 0:\n                fetchSourceContext = new FetchSourceContext(randomBoolean());\n                break;\n            case 1:\n                fetchSourceContext = new FetchSourceContext(includes, excludes);\n                break;\n            case 2:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20));\n                break;\n            case 3:\n                fetchSourceContext = new FetchSourceContext(true, includes, excludes);\n                break;\n            case 4:\n                fetchSourceContext = new FetchSourceContext(includes);\n                break;\n            case 5:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20));\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            builder.fetchSource(fetchSourceContext);\n        }\n        if (randomBoolean()) {\n            int size = randomIntBetween(0, 20);\n            List<String> statsGroups = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                statsGroups.add(randomAsciiOfLengthBetween(5, 20));\n            }\n            builder.stats(statsGroups);\n        }\n        if (randomBoolean()) {\n            int indexBoostSize = randomIntBetween(1, 10);\n            for (int i = 0; i < indexBoostSize; i++) {\n                builder.indexBoost(randomAsciiOfLengthBetween(5, 20), randomFloat() * 10);\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.query(RandomQueryBuilder.createQuery(getRandom()));\n            builder.query(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.postFilter(RandomQueryBuilder.createQuery(getRandom()));\n            builder.postFilter(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            int numSorts = randomIntBetween(1, 5);\n            for (int i = 0; i < numSorts; i++) {\n                int branch = randomInt(5);\n                switch (branch) {\n                case 0:\n                    builder.sort(SortBuilders.fieldSort(randomAsciiOfLengthBetween(5, 20)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 1:\n                    builder.sort(SortBuilders.geoDistanceSort(randomAsciiOfLengthBetween(5, 20),\n                            AbstractQueryTestCase.randomGeohash(1, 12)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 2:\n                    builder.sort(SortBuilders.scoreSort().order(randomFrom(SortOrder.values())));\n                    break;\n                case 3:\n                    builder.sort(SortBuilders.scriptSort(new Script(\"foo\"), \"number\").order(randomFrom(SortOrder.values())));\n                    break;\n                case 4:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20));\n                    break;\n                case 5:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20), randomFrom(SortOrder.values()));\n                    break;\n                }\n            }\n        }\n\n        if (randomBoolean()) {\n            int numSearchFrom = randomIntBetween(1, 5);\n            // We build a json version of the search_from first in order to\n            // ensure that every number type remain the same before/after xcontent (de)serialization.\n            // This is not a problem because the final type of each field value is extracted from associated sort field.\n            // This little trick ensure that equals and hashcode are the same when using the xcontent serialization.\n            XContentBuilder jsonBuilder = XContentFactory.jsonBuilder();\n            jsonBuilder.startObject();\n            jsonBuilder.startArray(\"search_from\");\n            for (int i = 0; i < numSearchFrom; i++) {\n                int branch = randomInt(8);\n                switch (branch) {\n                    case 0:\n                        jsonBuilder.value(randomInt());\n                        break;\n                    case 1:\n                        jsonBuilder.value(randomFloat());\n                        break;\n                    case 2:\n                        jsonBuilder.value(randomLong());\n                        break;\n                    case 3:\n                        jsonBuilder.value(randomDouble());\n                        break;\n                    case 4:\n                        jsonBuilder.value(randomAsciiOfLengthBetween(5, 20));\n                        break;\n                    case 5:\n                        jsonBuilder.value(randomBoolean());\n                        break;\n                    case 6:\n                        jsonBuilder.value(randomByte());\n                        break;\n                    case 7:\n                        jsonBuilder.value(randomShort());\n                        break;\n                    case 8:\n                        jsonBuilder.value(new Text(randomAsciiOfLengthBetween(5, 20)));\n                        break;\n                }\n            }\n            jsonBuilder.endArray();\n            jsonBuilder.endObject();\n            XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(jsonBuilder.bytes());\n            parser.nextToken();\n            parser.nextToken();\n            parser.nextToken();\n            builder.searchAfter(SearchAfterBuilder.PROTOTYPE.fromXContent(parser, null).getSortValues());\n        }\n        if (randomBoolean()) {\n            builder.highlighter(HighlightBuilderTests.randomHighlighterBuilder());\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random suggest builder method\n            builder.suggest(new SuggestBuilder().setText(randomAsciiOfLengthBetween(1, 5)).addSuggestion(\n                    SuggestBuilders.termSuggestion(randomAsciiOfLengthBetween(1, 5))));\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random inner hits builder method\n            InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder();\n            InnerHit innerHit = new InnerHit();\n            innerHit.field(randomAsciiOfLengthBetween(5, 20));\n            innerHitsBuilder.addNestedInnerHits(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20), innerHit);\n            builder.innerHits(innerHitsBuilder);\n        }\n        if (randomBoolean()) {\n            int numRescores = randomIntBetween(1, 5);\n            for (int i = 0; i < numRescores; i++) {\n                builder.addRescorer(QueryRescoreBuilderTests.randomRescoreBuilder());\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random aggregation builder method\n            builder.aggregation(AggregationBuilders.avg(randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (true) {\n            // NORELEASE need a method to randomly build content for ext\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();\n            xContentBuilder.startObject();\n            xContentBuilder.field(\"term_vectors_fetch\", randomAsciiOfLengthBetween(5, 20));\n            xContentBuilder.endObject();\n            builder.ext(xContentBuilder);\n        }\n        return builder;\n    }","id":166,"modified_method":"protected final SearchSourceBuilder createSearchSourceBuilder() throws IOException {\n        SearchSourceBuilder builder = new SearchSourceBuilder();\n        if (randomBoolean()) {\n            builder.from(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.size(randomIntBetween(0, 10000));\n        }\n        if (randomBoolean()) {\n            builder.explain(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.version(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.trackScores(randomBoolean());\n        }\n        if (randomBoolean()) {\n            builder.minScore(randomFloat() * 1000);\n        }\n        if (randomBoolean()) {\n            builder.timeout(new TimeValue(randomIntBetween(1, 100), randomFrom(TimeUnit.values())));\n        }\n        if (randomBoolean()) {\n            builder.terminateAfter(randomIntBetween(1, 100000));\n        }\n        // if (randomBoolean()) {\n        // builder.defaultRescoreWindowSize(randomIntBetween(1, 100));\n        // }\n        if (randomBoolean()) {\n            int fieldsSize = randomInt(25);\n            List<String> fields = new ArrayList<>(fieldsSize);\n            for (int i = 0; i < fieldsSize; i++) {\n                fields.add(randomAsciiOfLengthBetween(5, 50));\n            }\n            builder.fields(fields);\n        }\n        if (randomBoolean()) {\n            int fieldDataFieldsSize = randomInt(25);\n            for (int i = 0; i < fieldDataFieldsSize; i++) {\n                builder.fieldDataField(randomAsciiOfLengthBetween(5, 50));\n            }\n        }\n        if (randomBoolean()) {\n            int scriptFieldsSize = randomInt(25);\n            for (int i = 0; i < scriptFieldsSize; i++) {\n                if (randomBoolean()) {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"), randomBoolean());\n                } else {\n                    builder.scriptField(randomAsciiOfLengthBetween(5, 50), new Script(\"foo\"));\n                }\n            }\n        }\n        if (randomBoolean()) {\n            FetchSourceContext fetchSourceContext;\n            int branch = randomInt(5);\n            String[] includes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < includes.length; i++) {\n                includes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            String[] excludes = new String[randomIntBetween(0, 20)];\n            for (int i = 0; i < excludes.length; i++) {\n                excludes[i] = randomAsciiOfLengthBetween(5, 20);\n            }\n            switch (branch) {\n            case 0:\n                fetchSourceContext = new FetchSourceContext(randomBoolean());\n                break;\n            case 1:\n                fetchSourceContext = new FetchSourceContext(includes, excludes);\n                break;\n            case 2:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20));\n                break;\n            case 3:\n                fetchSourceContext = new FetchSourceContext(true, includes, excludes);\n                break;\n            case 4:\n                fetchSourceContext = new FetchSourceContext(includes);\n                break;\n            case 5:\n                fetchSourceContext = new FetchSourceContext(randomAsciiOfLengthBetween(5, 20));\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            builder.fetchSource(fetchSourceContext);\n        }\n        if (randomBoolean()) {\n            int size = randomIntBetween(0, 20);\n            List<String> statsGroups = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                statsGroups.add(randomAsciiOfLengthBetween(5, 20));\n            }\n            builder.stats(statsGroups);\n        }\n        if (randomBoolean()) {\n            int indexBoostSize = randomIntBetween(1, 10);\n            for (int i = 0; i < indexBoostSize; i++) {\n                builder.indexBoost(randomAsciiOfLengthBetween(5, 20), randomFloat() * 10);\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.query(RandomQueryBuilder.createQuery(getRandom()));\n            builder.query(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            // NORELEASE make RandomQueryBuilder work outside of the\n            // AbstractQueryTestCase\n            // builder.postFilter(RandomQueryBuilder.createQuery(getRandom()));\n            builder.postFilter(QueryBuilders.termQuery(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (randomBoolean()) {\n            int numSorts = randomIntBetween(1, 5);\n            for (int i = 0; i < numSorts; i++) {\n                int branch = randomInt(5);\n                switch (branch) {\n                case 0:\n                    builder.sort(SortBuilders.fieldSort(randomAsciiOfLengthBetween(5, 20)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 1:\n                    builder.sort(SortBuilders.geoDistanceSort(randomAsciiOfLengthBetween(5, 20))\n                            .geohashes(AbstractQueryTestCase.randomGeohash(1, 12)).order(randomFrom(SortOrder.values())));\n                    break;\n                case 2:\n                    builder.sort(SortBuilders.scoreSort().order(randomFrom(SortOrder.values())));\n                    break;\n                case 3:\n                    builder.sort(SortBuilders.scriptSort(new Script(\"foo\"), \"number\").order(randomFrom(SortOrder.values())));\n                    break;\n                case 4:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20));\n                    break;\n                case 5:\n                    builder.sort(randomAsciiOfLengthBetween(5, 20), randomFrom(SortOrder.values()));\n                    break;\n                }\n            }\n        }\n\n        if (randomBoolean()) {\n            int numSearchFrom = randomIntBetween(1, 5);\n            // We build a json version of the search_from first in order to\n            // ensure that every number type remain the same before/after xcontent (de)serialization.\n            // This is not a problem because the final type of each field value is extracted from associated sort field.\n            // This little trick ensure that equals and hashcode are the same when using the xcontent serialization.\n            XContentBuilder jsonBuilder = XContentFactory.jsonBuilder();\n            jsonBuilder.startObject();\n            jsonBuilder.startArray(\"search_from\");\n            for (int i = 0; i < numSearchFrom; i++) {\n                int branch = randomInt(8);\n                switch (branch) {\n                    case 0:\n                        jsonBuilder.value(randomInt());\n                        break;\n                    case 1:\n                        jsonBuilder.value(randomFloat());\n                        break;\n                    case 2:\n                        jsonBuilder.value(randomLong());\n                        break;\n                    case 3:\n                        jsonBuilder.value(randomDouble());\n                        break;\n                    case 4:\n                        jsonBuilder.value(randomAsciiOfLengthBetween(5, 20));\n                        break;\n                    case 5:\n                        jsonBuilder.value(randomBoolean());\n                        break;\n                    case 6:\n                        jsonBuilder.value(randomByte());\n                        break;\n                    case 7:\n                        jsonBuilder.value(randomShort());\n                        break;\n                    case 8:\n                        jsonBuilder.value(new Text(randomAsciiOfLengthBetween(5, 20)));\n                        break;\n                }\n            }\n            jsonBuilder.endArray();\n            jsonBuilder.endObject();\n            XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(jsonBuilder.bytes());\n            parser.nextToken();\n            parser.nextToken();\n            parser.nextToken();\n            builder.searchAfter(SearchAfterBuilder.PROTOTYPE.fromXContent(parser, null).getSortValues());\n        }\n        if (randomBoolean()) {\n            builder.highlighter(HighlightBuilderTests.randomHighlighterBuilder());\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random suggest builder method\n            builder.suggest(new SuggestBuilder().setText(randomAsciiOfLengthBetween(1, 5)).addSuggestion(\n                    SuggestBuilders.termSuggestion(randomAsciiOfLengthBetween(1, 5))));\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random inner hits builder method\n            InnerHitsBuilder innerHitsBuilder = new InnerHitsBuilder();\n            InnerHit innerHit = new InnerHit();\n            innerHit.field(randomAsciiOfLengthBetween(5, 20));\n            innerHitsBuilder.addNestedInnerHits(randomAsciiOfLengthBetween(5, 20), randomAsciiOfLengthBetween(5, 20), innerHit);\n            builder.innerHits(innerHitsBuilder);\n        }\n        if (randomBoolean()) {\n            int numRescores = randomIntBetween(1, 5);\n            for (int i = 0; i < numRescores; i++) {\n                builder.addRescorer(QueryRescoreBuilderTests.randomRescoreBuilder());\n            }\n        }\n        if (randomBoolean()) {\n            // NORELEASE need a random aggregation builder method\n            builder.aggregation(AggregationBuilders.avg(randomAsciiOfLengthBetween(5, 20)));\n        }\n        if (true) {\n            // NORELEASE need a method to randomly build content for ext\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();\n            xContentBuilder.startObject();\n            xContentBuilder.field(\"term_vectors_fetch\", randomAsciiOfLengthBetween(5, 20));\n            xContentBuilder.endObject();\n            builder.ext(xContentBuilder);\n        }\n        return builder;\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testManyToManyGeoPointsWithDifferentFormats() throws ExecutionException, InterruptedException, IOException {\n        /**   q     d1       d2\n         * |4  o|   x    |   x\n         * |    |        |\n         * |3  o|  x     |  x\n         * |    |        |\n         * |2  o| x      | x\n         * |    |        |\n         * |1  o|x       |x\n         * |______________________\n         * 1   2   3   4   5   6\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(2.5, 1), new GeoPoint(2.75, 2), new GeoPoint(3, 3), new GeoPoint(3.25, 4)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(4.5, 1), new GeoPoint(4.75, 2), new GeoPoint(5, 3), new GeoPoint(5.25, 4)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n\n        List<String> qHashes = new ArrayList<>();\n        List<GeoPoint> qPoints = new ArrayList<>();\n        createQPoints(qHashes, qPoints);\n\n        \n        GeoDistanceSortBuilder geoDistanceSortBuilder = null;\n        for (int i = 0; i < 4; i++) {\n            int at = randomInt(3 - i);\n            if (randomBoolean()) {\n              \tif (geoDistanceSortBuilder == null) {\n              \t  geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", qHashes.get(at));\n              \t} else {\n              \t  geoDistanceSortBuilder.geohashes(qHashes.get(at));\n              \t}\n            } else {\n              if (geoDistanceSortBuilder == null) {\n        \tgeoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", qPoints.get(at));\n              } else {\n                geoDistanceSortBuilder.points(qPoints.get(at));\n              }\n            }\n            qHashes.remove(at);\n            qPoints.remove(at);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(4.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(3.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(5.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n    }","id":167,"modified_method":"public void testManyToManyGeoPointsWithDifferentFormats() throws ExecutionException, InterruptedException, IOException {\n        /**   q     d1       d2\n         * |4  o|   x    |   x\n         * |    |        |\n         * |3  o|  x     |  x\n         * |    |        |\n         * |2  o| x      | x\n         * |    |        |\n         * |1  o|x       |x\n         * |______________________\n         * 1   2   3   4   5   6\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(2.5, 1), new GeoPoint(2.75, 2), new GeoPoint(3, 3), new GeoPoint(3.25, 4)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(4.5, 1), new GeoPoint(4.75, 2), new GeoPoint(5, 3), new GeoPoint(5.25, 4)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n\n        List<String> qHashes = new ArrayList<>();\n        List<GeoPoint> qPoints = new ArrayList<>();\n        createQPoints(qHashes, qPoints);\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        for (int i = 0; i < 4; i++) {\n            int at = randomInt(3 - i);\n            if (randomBoolean()) {\n                geoDistanceSortBuilder.geohashes(qHashes.get(at));\n            } else {\n                geoDistanceSortBuilder.points(qPoints.get(at));\n            }\n            qHashes.remove(at);\n            qPoints.remove(at);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(4.5, 1, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double) searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(3.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n        assertThat((Double) searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(5.25, 4, 2, 1, DistanceUnit.KILOMETERS), 1.e-4));\n\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", 2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", \"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","id":168,"modified_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.geohashes(hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.points(new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.point(2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").geohashes(\"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testManyToManyGeoPoints() throws ExecutionException, InterruptedException, IOException {\n        /**\n         * | q  |  d1    |   d2\n         * |    |        |\n         * |    |        |\n         * |    |        |\n         * |2  o|  x     |     x\n         * |    |        |\n         * |1  o|      x | x\n         * |___________________________\n         * 1   2   3   4   5   6   7\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(3, 2), new GeoPoint(4, 1)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(5, 1), new GeoPoint(6, 2)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        logger.info(d1Builder.string());\n        logger.info(d2Builder.string());\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n        GeoPoint[] q = new GeoPoint[2];\n        if (randomBoolean()) {\n            q[0] = new GeoPoint(2, 1);\n            q[1] = new GeoPoint(2, 2);\n        } else {\n            q[1] = new GeoPoint(2, 2);\n            q[0] = new GeoPoint(2, 1);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"min\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\", q).sortMode(\"max\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n    }","id":169,"modified_method":"public void testManyToManyGeoPoints() throws ExecutionException, InterruptedException, IOException {\n        /**\n         * | q  |  d1    |   d2\n         * |    |        |\n         * |    |        |\n         * |    |        |\n         * |2  o|  x     |     x\n         * |    |        |\n         * |1  o|      x | x\n         * |___________________________\n         * 1   2   3   4   5   6   7\n         */\n        Version version = VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.CURRENT);\n        Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build();\n        assertAcked(prepareCreate(\"index\").setSettings(settings).addMapping(\"type\", \"location\", \"type=geo_point\"));\n        XContentBuilder d1Builder = jsonBuilder();\n        GeoPoint[] d1Points = {new GeoPoint(3, 2), new GeoPoint(4, 1)};\n        createShuffeldJSONArray(d1Builder, d1Points);\n\n        XContentBuilder d2Builder = jsonBuilder();\n        GeoPoint[] d2Points = {new GeoPoint(5, 1), new GeoPoint(6, 2)};\n        createShuffeldJSONArray(d2Builder, d2Points);\n\n        logger.info(d1Builder.string());\n        logger.info(d2Builder.string());\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(d1Builder),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(d2Builder));\n        ensureYellow();\n        GeoPoint[] q = new GeoPoint[2];\n        if (randomBoolean()) {\n            q[0] = new GeoPoint(2, 1);\n            q[1] = new GeoPoint(2, 2);\n        } else {\n            q[1] = new GeoPoint(2, 2);\n            q[0] = new GeoPoint(2, 1);\n        }\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"min\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 5, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 3, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"max\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d1\", \"d2\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(new GeoDistanceSortBuilder(\"location\").points(q).sortMode(\"max\").order(SortOrder.DESC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        assertOrderedSearchHits(searchResponse, \"d2\", \"d1\");\n        assertThat((Double)searchResponse.getHits().getAt(0).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 1, 6, 2, DistanceUnit.KILOMETERS), 0.01d));\n        assertThat((Double)searchResponse.getHits().getAt(1).getSortValues()[0], closeTo(GeoDistance.PLANE.calculate(2, 2, 4, 1, DistanceUnit.KILOMETERS), 0.01d));\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Constructs a new distance based sort on a geo point like field.\n     *\n     * @param fieldName The geo point like field name.\n     * @param geohashes The points to create the range distance facets from.\n     */\n    public static GeoDistanceSortBuilder geoDistanceSort(String fieldName, String ... geohashes) {\n        return new GeoDistanceSortBuilder(fieldName, geohashes);\n    }","id":170,"modified_method":"/**\n     * A geo distance based sort.\n     *\n     * @param fieldName The geo point like field name.\n     */\n    public static GeoDistanceSortBuilder geoDistanceSort(String fieldName) {\n        return new GeoDistanceSortBuilder(fieldName);\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@TaskAction\n    public void report() {\n        Project project = getProject();\n\n        StyledTextOutput textOutput = getTextOutputFactory().create(ComponentReport.class);\n        ComponentReportRenderer renderer = new ComponentReportRenderer(getFileResolver());\n        renderer.setOutput(textOutput);\n\n        renderer.startProject(project);\n\n        Collection<ComponentSpec> components = new ArrayList<ComponentSpec>();\n        ComponentSpecContainer componentSpecs = project.getExtensions().findByType(ComponentSpecContainer.class);\n        if (componentSpecs != null) {\n            components.addAll(componentSpecs);\n        }\n\n        TestSuiteContainer testSuites = getModelRegistry().find(ModelPath.path(\"testSuites\"), ModelType.of(TestSuiteContainer.class));\n        if (testSuites != null) {\n            components.addAll(testSuites);\n        }\n\n        renderer.renderComponents(components);\n\n        ProjectSourceSet sourceSets = project.getExtensions().findByType(ProjectSourceSet.class);\n        if (sourceSets != null) {\n            renderer.renderSourceSets(sourceSets);\n        }\n        BinaryContainer binaries = project.getExtensions().findByType(BinaryContainer.class);\n        if (binaries != null) {\n            renderer.renderBinaries(binaries);\n        }\n\n        renderer.completeProject(project);\n        renderer.complete();\n    }","id":171,"modified_method":"@TaskAction\n    public void report() {\n        Project project = getProject();\n\n        StyledTextOutput textOutput = getTextOutputFactory().create(ComponentReport.class);\n        ComponentReportRenderer renderer = new ComponentReportRenderer(getFileResolver());\n        renderer.setOutput(textOutput);\n\n        renderer.startProject(project);\n\n        Collection<ComponentSpec> components = new ArrayList<ComponentSpec>();\n        ComponentSpecContainer componentSpecs = getModelRegistry().find(ModelPath.path(\"components\"), ModelType.of(ComponentSpecContainer.class));\n        if (componentSpecs != null) {\n            components.addAll(componentSpecs);\n        }\n\n        TestSuiteContainer testSuites = getModelRegistry().find(ModelPath.path(\"testSuites\"), ModelType.of(TestSuiteContainer.class));\n        if (testSuites != null) {\n            components.addAll(testSuites);\n        }\n\n        renderer.renderComponents(components);\n\n        ProjectSourceSet sourceSets = getModelRegistry().find(ModelPath.path(\"sources\"), ModelType.of(ProjectSourceSet.class));\n        if (sourceSets != null) {\n            renderer.renderSourceSets(sourceSets);\n        }\n        BinaryContainer binaries = getModelRegistry().find(ModelPath.path(\"binaries\"), ModelType.of(BinaryContainer.class));\n        if (binaries != null) {\n            renderer.renderBinaries(binaries);\n        }\n\n        renderer.completeProject(project);\n        renderer.complete();\n    }","commit_id":"e19e071db56fcdf0474d2ac1ff622f6e2b7a76b5","url":"https://github.com/gradle/gradle"},{"original_method":"private int selectIntValue(Node node, String expr, int def) {\n        Integer integerValue = XPathUtils.selectIntegerValue(node, expr);\n        return (integerValue == null) ? def : integerValue.intValue();\n    }","id":172,"modified_method":"private int selectIntValue(Node node, String expr, int def) {\n        Integer integerValue = XPathUtils.selectIntegerValue(node, expr);\n        return (integerValue == null) ? def : integerValue;\n    }","commit_id":"e9c5cf1d3e1250205b8d6f755674d222b16e1521","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private String computeCacheFileName(String type, String path, List nodes) {\n        // Create digest document and digest\n        Document document = new NonLazyUserDataDocument();\n        Element rootElement = document.addElement(\"image\");\n        for (Iterator i = nodes.iterator(); i.hasNext();) {\n            Element element = (Element) i.next();\n            rootElement.add(element.createCopy());\n        }\n        String digest = NumberUtils.toHexString(Dom4jUtils.getDigest(document));\n\n        // Create file name\n        if (\"flat\".equals(type))\n            return computePathNameFlat(path) + \"-\" + digest;\n        else\n            return computePathNameHierarchical(path) + \"-\" + digest;\n    }","id":173,"modified_method":"private String computeCacheFileName(String type, String path, List<Element> nodes) {\n        // Create digest document and digest\n        Document document = new NonLazyUserDataDocument();\n        Element rootElement = document.addElement(\"image\");\n        for (Element element: nodes) {\n            rootElement.add(element.createCopy());\n        }\n        String digest = NumberUtils.toHexString(Dom4jUtils.getDigest(document));\n\n        // Create file name\n        if (\"flat\".equals(type))\n            return computePathNameFlat(path) + \"-\" + digest;\n        else\n            return computePathNameHierarchical(path) + \"-\" + digest;\n    }","commit_id":"e9c5cf1d3e1250205b8d6f755674d222b16e1521","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void processImage(PipelineContext pipelineContext, ImageResponse imageResponse) {\n\n        try {\n            // Read global configuration\n            final Config config = (ImageServer.Config) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_CONFIG), new CacheableInputReader() {\n                public Object read(PipelineContext pipelineContext, ProcessorInput processorInput) {\n\n                    final Document configDocument = readInputAsDOM4J(pipelineContext, processorInput);\n                    final Config result = new Config();\n\n                    String imageDirectoryString = XPathUtils.selectStringValueNormalize(configDocument, \"/config/image-directory\");\n                    imageDirectoryString = imageDirectoryString.replace('\\\\', '/');\n\n                    // Make sure this ends with a '/' so that it is considered a directory\n                    if (!imageDirectoryString.endsWith(\"/\"))\n                        imageDirectoryString = imageDirectoryString + '/';\n\n                    try {\n                        result.imageDirectoryURL = URLFactory.createURL(imageDirectoryString);\n                    } catch (MalformedURLException e) {\n                        throw new OXFException(e);\n                    }\n\n                    final String cacheDirectoryString = XPathUtils.selectStringValueNormalize(configDocument, \"/config/cache/directory\");\n                    result.cacheDir = (cacheDirectoryString == null) ? null : new File(cacheDirectoryString);\n                    if (result.cacheDir != null && !result.cacheDir.isDirectory())\n                        throw new IllegalArgumentException(\"Invalid cache directory: \" + cacheDirectoryString);\n\n                    result.defaultQuality = selectFloatValue(configDocument, \"/config/default-quality\", DEFAULT_QUALITY);\n                    if (result.defaultQuality < 0.0f || result.defaultQuality > 1.0f)\n                        throw new IllegalArgumentException(\"default-quality must be comprised between 0.0 and 1.0\");\n\n                    result.useSandbox = selectBooleanValue(configDocument, \"/config/use-sandbox\", DEFAULT_USE_SANDBOX);\n                    result.cachePathEncoding = XPathUtils.selectStringValueNormalize(configDocument, \"/config/cache/path-encoding\");\n\n                    return result;\n                }\n            });\n\n            // Read image configuration\n            final ImageConfig imageConfig = (ImageServer.ImageConfig) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_IMAGE), new CacheableInputReader() {\n                public Object read(PipelineContext pipelineContext, ProcessorInput processorInput) {\n\n                    final Document imageConfigDocument = readCacheInputAsDOM4J(pipelineContext, INPUT_IMAGE);\n                    final ImageConfig result = new ImageConfig();\n\n                    // Read URL\n                    result.urlString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/url\");\n\n                    // For backward compatibility, try to get path element (which also contained an URL!)\n                    if (result.urlString == null) {\n                        result.urlString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/path\");\n                    }\n\n                    String qualityString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/quality\");\n                    result.quality = (qualityString == null) ? null : new Float(qualityString);\n\n                    String useCacheString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/use-cache\");\n                    result.useCache = (useCacheString == null) ? null : new Boolean(useCacheString);\n\n                    result.transformCount = XPathUtils.selectIntegerValue(imageConfigDocument, \"count(/image/transform)\").intValue();\n                    Object transforms = XPathUtils.selectObjectValue(imageConfigDocument, \"/image/transform\");\n                    if (transforms != null && transforms instanceof Node)\n                        transforms = Collections.singletonList(transforms);\n                    result.transforms = transforms;\n                    result.transformIterator = XPathUtils.selectIterator(imageConfigDocument, \"/image/transform\");\n\n                    return result;\n                }\n            });\n\n            final float quality = (imageConfig.quality == null) ? config.defaultQuality : imageConfig.quality.floatValue();\n            final boolean useCache = config.cacheDir != null && ((imageConfig.useCache == null) ? DEFAULT_USE_CACHE : imageConfig.useCache.booleanValue());\n\n            URLConnection urlConnection = null;\n            InputStream urlConnectionInputStream = null;\n            try {\n                // Make sure the requested resource exists and is valid\n                URL newURL = null;\n                try {\n                    newURL = URLFactory.createURL(config.imageDirectoryURL, imageConfig.urlString);\n                    // Check if new URL is relative to image directory URL\n                    boolean relative = NetUtils.relativeURL(config.imageDirectoryURL, newURL);\n                    if (config.useSandbox && !relative) {\n                        imageResponse.setStatus(ExternalContext.SC_NOT_FOUND);\n                        return;\n                    }\n                    // Try to open the connection\n                    urlConnection = newURL.openConnection();\n                    // Get InputStream and make sure it supprorts marks\n                    urlConnectionInputStream = urlConnection.getInputStream();\n                    if (!urlConnectionInputStream.markSupported())\n                        urlConnectionInputStream = new BufferedInputStream(urlConnectionInputStream);\n                    // Make sure the resource looks like a JPEG file\n                    String contentType = URLConnection.guessContentTypeFromStream(urlConnectionInputStream);\n                    if (!\"image/jpeg\".equals(contentType)) {\n                        imageResponse.setStatus(ExternalContext.SC_NOT_FOUND);\n                        return;\n                    }\n                } catch (IOException e) {\n                    imageResponse.setStatus(ExternalContext.SC_NOT_FOUND);\n                    return;\n                }\n\n                // Get date of last modification of resource\n                long lastModified = NetUtils.getLastModified(urlConnection);\n\n                // Cache handling\n                String cacheFileName = useCache ? computeCacheFileName(config.cachePathEncoding, imageConfig.urlString, (List) imageConfig.transforms) : null;\n                File cacheFile = useCache ? new File(config.cacheDir, cacheFileName) : null;\n                boolean cacheInvalid = !useCache || !cacheFile.exists() || lastModified == 0 || lastModified > cacheFile.lastModified() || cacheFile.length() == 0;\n                boolean mustProcess = cacheInvalid;\n                boolean updateCache = useCache && cacheInvalid;\n\n                // Set Last-Modified, required for caching and conditional get\n                imageResponse.setCaching(lastModified, false, false);\n\n                // Check If-Modified-Since and don't return content if condition is met\n                if ((imageConfig.transformCount == 0 || !mustProcess) && !imageResponse.checkIfModifiedSince(lastModified, false)) {\n                    imageResponse.setStatus(ExternalContext.SC_NOT_MODIFIED);\n                    return;\n                }\n\n                // Set Content-Type\n                imageResponse.startDocument(\"image/jpeg\");\n\n                // Optimize if no transformation is specified\n                if (imageConfig.transformCount == 0) {\n                    NetUtils.copyStream(urlConnectionInputStream, imageResponse.getOutputStream());\n                    return;\n                }\n\n                // Process image if needed\n                if (mustProcess) {\n                    boolean closeOutputStream = false;\n                    OutputStream os = null;\n                    try {\n                        // Try to obtain decoded image from cache first\n                        Long cacheValidity = new Long(lastModified);\n                        String cacheKey = \"[\" + newURL.toExternalForm() + \"][\" + cacheValidity + \"]\";\n                        BufferedImage img1 = null;\n                        // Decode one image at a time to try to minimize the memory impact\n                        // NOTE: This should probably be configurable\n                        synchronized (ImageServer.this) {\n                            img1 = (cache == null) ? null : (BufferedImage) cache.get(cacheKey);\n                            // If this failed (most common case) decode the image\n                            if (img1 == null) {\n                                // Decode image into BufferedImage\n                                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(urlConnectionInputStream);\n                                img1 = decoder.decodeAsBufferedImage();\n\n                                // Store the image into the soft cache\n                                if (cache == null)\n                                    cache = new SoftCacheImpl(0);\n                                cache.put(cacheKey, img1);\n                            } else {\n                                cache.refresh(cacheKey);\n                                //logger.info(\"Found image in cache with key: \" + cacheKey);\n                                logger.info(\"Found decoded image in cache\");\n                            }\n                        }\n\n                        // Filter image\n                        BufferedImage img2 = filter(img1, imageConfig.transformIterator);\n\n                        // Create OutputStream\n                        if (updateCache) {\n                            File outputDir = cacheFile.getParentFile();\n                            if (!outputDir.exists() && !outputDir.mkdirs()) {\n                                logger.info(\"Cannot create cache directory: \" + outputDir.getCanonicalPath());\n                                imageResponse.setStatus(ExternalContext.SC_INTERNAL_SERVER_ERROR);\n                                return;\n                            }\n                            os = new FileOutputStream(cacheFile);\n                            closeOutputStream = true;\n                        } else {\n                            os = imageResponse.getOutputStream();\n                        }\n\n                        // Encode image to OutputStream\n                        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(os);\n                        JPEGEncodeParam params = encoder.getDefaultJPEGEncodeParam(img2);\n                        params.setQuality(quality, false);\n                        encoder.setJPEGEncodeParam(params);\n                        encoder.encode(img2);\n                    } catch (OXFException e) {\n                        logger.error(OXFException.getRootThrowable(e));\n                        imageResponse.setStatus(ExternalContext.SC_INTERNAL_SERVER_ERROR);\n                        return;\n                    } finally {\n                        if (os != null && closeOutputStream) os.close();\n                    }\n                }\n\n                // Send cached image if relevant\n                if (useCache) {\n                    InputStream is = new FileInputStream(cacheFile);\n                    OutputStream os = imageResponse.getOutputStream();\n                    try {\n                        NetUtils.copyStream(is, os);\n                    } finally {\n                        is.close();\n                    }\n                }\n            } finally {\n                // Make sure the connection is closed because when getting the\n                // last modified date, the stream is actually opened. When using\n                // the file: protocol, the file can be locked on disk.\n                if (urlConnection != null && \"file\".equalsIgnoreCase(urlConnection.getURL().getProtocol())) {\n                    if (urlConnectionInputStream != null) urlConnectionInputStream.close();\n                }\n            }\n\n        } catch (OutOfMemoryError e) {\n            logger.info(\"Ran out of memory while processing image\");\n            throw e;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":174,"modified_method":"public void processImage(PipelineContext pipelineContext, ImageResponse imageResponse) {\n\n        try {\n            // Read global configuration\n            final Config config = (ImageServer.Config) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_CONFIG), new CacheableInputReader() {\n                public Object read(PipelineContext pipelineContext, ProcessorInput processorInput) {\n\n                    final Document configDocument = readInputAsDOM4J(pipelineContext, processorInput);\n                    final Config result = new Config();\n\n                    String imageDirectoryString = XPathUtils.selectStringValueNormalize(configDocument, \"/config/image-directory\");\n                    imageDirectoryString = imageDirectoryString.replace('\\\\', '/');\n\n                    // Make sure this ends with a '/' so that it is considered a directory\n                    if (!imageDirectoryString.endsWith(\"/\"))\n                        imageDirectoryString = imageDirectoryString + '/';\n\n                    try {\n                        result.imageDirectoryURL = URLFactory.createURL(imageDirectoryString);\n                    } catch (MalformedURLException e) {\n                        throw new OXFException(e);\n                    }\n\n                    final String cacheDirectoryString = XPathUtils.selectStringValueNormalize(configDocument, \"/config/cache/directory\");\n                    result.cacheDir = (cacheDirectoryString == null) ? null : new File(cacheDirectoryString);\n                    if (result.cacheDir != null && !result.cacheDir.isDirectory())\n                        throw new IllegalArgumentException(\"Invalid cache directory: \" + cacheDirectoryString);\n\n                    result.defaultQuality = selectFloatValue(configDocument, \"/config/default-quality\", DEFAULT_QUALITY);\n                    if (result.defaultQuality < 0.0f || result.defaultQuality > 1.0f)\n                        throw new IllegalArgumentException(\"default-quality must be comprised between 0.0 and 1.0\");\n\n                    result.useSandbox = selectBooleanValue(configDocument, \"/config/use-sandbox\", DEFAULT_USE_SANDBOX);\n                    result.cachePathEncoding = XPathUtils.selectStringValueNormalize(configDocument, \"/config/cache/path-encoding\");\n\n                    return result;\n                }\n            });\n\n            // Read image configuration\n            final ImageConfig imageConfig = (ImageServer.ImageConfig) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_IMAGE), new CacheableInputReader() {\n                public Object read(PipelineContext pipelineContext, ProcessorInput processorInput) {\n\n                    final Document imageConfigDocument = readCacheInputAsDOM4J(pipelineContext, INPUT_IMAGE);\n                    final ImageConfig result = new ImageConfig();\n\n                    // Read URL\n                    result.urlString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/url\");\n\n                    // For backward compatibility, try to get path element (which also contained an URL!)\n                    if (result.urlString == null) {\n                        result.urlString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/path\");\n                    }\n\n                    String qualityString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/quality\");\n                    result.quality = (qualityString == null) ? null : new Float(qualityString);\n\n                    String useCacheString = XPathUtils.selectStringValueNormalize(imageConfigDocument, \"/image/use-cache\");\n                    result.useCache = (useCacheString == null) ? null : Boolean.valueOf(useCacheString);\n\n                    result.transformCount = XPathUtils.selectIntegerValue(imageConfigDocument, \"count(/image/transform)\");\n                    Object transforms = XPathUtils.selectObjectValue(imageConfigDocument, \"/image/transform\");\n                    if (transforms != null && transforms instanceof Node)\n                        transforms = Collections.singletonList(transforms);\n                    result.transforms = transforms;\n                    result.transformIterator = XPathUtils.selectIterator(imageConfigDocument, \"/image/transform\");\n\n                    return result;\n                }\n            });\n\n            final float quality = (imageConfig.quality == null) ? config.defaultQuality : imageConfig.quality;\n            final boolean useCache = config.cacheDir != null && ((imageConfig.useCache == null) ? DEFAULT_USE_CACHE : imageConfig.useCache);\n\n            URLConnection urlConnection = null;\n            InputStream urlConnectionInputStream = null;\n            try {\n                // Make sure the requested resource exists and is valid\n                final URL newURL;\n                try {\n                    newURL = URLFactory.createURL(config.imageDirectoryURL, imageConfig.urlString);\n                    // Check if new URL is relative to image directory URL\n                    boolean relative = NetUtils.relativeURL(config.imageDirectoryURL, newURL);\n                    if (config.useSandbox && !relative) {\n                        imageResponse.setStatus(ExternalContext.SC_NOT_FOUND);\n                        return;\n                    }\n                    // Try to open the connection\n                    urlConnection = newURL.openConnection();\n                    // Get InputStream and make sure it supprorts marks\n                    urlConnectionInputStream = urlConnection.getInputStream();\n                    if (!urlConnectionInputStream.markSupported())\n                        urlConnectionInputStream = new BufferedInputStream(urlConnectionInputStream);\n                    // Make sure the resource looks like a JPEG file\n                    String contentType = URLConnection.guessContentTypeFromStream(urlConnectionInputStream);\n                    if (!\"image/jpeg\".equals(contentType)) {\n                        imageResponse.setStatus(ExternalContext.SC_NOT_FOUND);\n                        return;\n                    }\n                } catch (IOException e) {\n                    imageResponse.setStatus(ExternalContext.SC_NOT_FOUND);\n                    return;\n                }\n\n                // Get date of last modification of resource\n                long lastModified = NetUtils.getLastModified(urlConnection);\n\n                // Cache handling\n                String cacheFileName = useCache ? computeCacheFileName(config.cachePathEncoding, imageConfig.urlString, (List<Element>) imageConfig.transforms) : null;\n                File cacheFile = useCache ? new File(config.cacheDir, cacheFileName) : null;\n                boolean cacheInvalid = !useCache || !cacheFile.exists() || lastModified == 0 || lastModified > cacheFile.lastModified() || cacheFile.length() == 0;\n                boolean mustProcess = cacheInvalid;\n                boolean updateCache = useCache && cacheInvalid;\n\n                // Set Last-Modified, required for caching and conditional get\n                imageResponse.setCaching(lastModified, false, false);\n\n                // Check If-Modified-Since and don't return content if condition is met\n                if ((imageConfig.transformCount == 0 || !mustProcess) && !imageResponse.checkIfModifiedSince(lastModified, false)) {\n                    imageResponse.setStatus(ExternalContext.SC_NOT_MODIFIED);\n                    return;\n                }\n\n                // Set Content-Type\n                imageResponse.startDocument(\"image/jpeg\");\n\n                // Optimize if no transformation is specified\n                if (imageConfig.transformCount == 0) {\n                    NetUtils.copyStream(urlConnectionInputStream, imageResponse.getOutputStream());\n                    return;\n                }\n\n                // Process image if needed\n                if (mustProcess) {\n                    boolean closeOutputStream = false;\n                    OutputStream os = null;\n                    try {\n                        // Try to obtain decoded image from cache first\n                        Long cacheValidity = lastModified;\n                        String cacheKey = \"[\" + newURL.toExternalForm() + \"][\" + cacheValidity + \"]\";\n                        BufferedImage img1;\n                        // Decode one image at a time to try to minimize the memory impact\n                        // NOTE: This should probably be configurable\n                        synchronized (ImageServer.this) {\n                            img1 = (cache == null) ? null : (BufferedImage) cache.get(cacheKey);\n                            // If this failed (most common case) decode the image\n                            if (img1 == null) {\n                                // Decode image into BufferedImage\n                                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(urlConnectionInputStream);\n                                img1 = decoder.decodeAsBufferedImage();\n\n                                // Store the image into the soft cache\n                                if (cache == null)\n                                    cache = new SoftCacheImpl(0);\n                                cache.put(cacheKey, img1);\n                            } else {\n                                cache.refresh(cacheKey);\n                                //logger.info(\"Found image in cache with key: \" + cacheKey);\n                                logger.info(\"Found decoded image in cache\");\n                            }\n                        }\n\n                        // Filter image\n                        BufferedImage img2 = filter(img1, imageConfig.transformIterator);\n\n                        // Create OutputStream\n                        if (updateCache) {\n                            File outputDir = cacheFile.getParentFile();\n                            if (!outputDir.exists() && !outputDir.mkdirs()) {\n                                logger.info(\"Cannot create cache directory: \" + outputDir.getCanonicalPath());\n                                imageResponse.setStatus(ExternalContext.SC_INTERNAL_SERVER_ERROR);\n                                return;\n                            }\n                            os = new FileOutputStream(cacheFile);\n                            closeOutputStream = true;\n                        } else {\n                            os = imageResponse.getOutputStream();\n                        }\n\n                        // Encode image to OutputStream\n                        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(os);\n                        JPEGEncodeParam params = encoder.getDefaultJPEGEncodeParam(img2);\n                        params.setQuality(quality, false);\n                        encoder.setJPEGEncodeParam(params);\n                        encoder.encode(img2);\n                    } catch (OXFException e) {\n                        logger.error(OXFException.getRootThrowable(e));\n                        imageResponse.setStatus(ExternalContext.SC_INTERNAL_SERVER_ERROR);\n                        return;\n                    } finally {\n                        if (os != null && closeOutputStream) os.close();\n                    }\n                }\n\n                // Send cached image if relevant\n                if (useCache) {\n                    InputStream is = new FileInputStream(cacheFile);\n                    OutputStream os = imageResponse.getOutputStream();\n                    try {\n                        NetUtils.copyStream(is, os);\n                    } finally {\n                        is.close();\n                    }\n                }\n            } finally {\n                // Make sure the connection is closed because when getting the\n                // last modified date, the stream is actually opened. When using\n                // the file: protocol, the file can be locked on disk.\n                if (urlConnection != null && \"file\".equalsIgnoreCase(urlConnection.getURL().getProtocol())) {\n                    if (urlConnectionInputStream != null) urlConnectionInputStream.close();\n                }\n            }\n\n        } catch (OutOfMemoryError e) {\n            logger.info(\"Ran out of memory while processing image\");\n            throw e;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"e9c5cf1d3e1250205b8d6f755674d222b16e1521","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private synchronized BufferedImage filter(BufferedImage img, Iterator transformIterator) {\n        // Copy the image to RGB if necessary (is there another way? Otherwise some images fail)\n        BufferedImage srcImage = img;\n        if (img.getType() != BufferedImage.TYPE_INT_RGB) {\n            srcImage = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_RGB);\n            Graphics2D graphics = srcImage.createGraphics();\n            graphics.drawImage(img, null, 0, 0);\n            graphics.dispose();\n        }\n\n        ImageProducer producer = srcImage.getSource();\n        int currentWidth = img.getWidth(null);\n        int currentHeight = img.getHeight(null);\n\n        // There may be one drawing operation\n        List drawConfiguration = new ArrayList();\n\n        // Iterate through all transforms\n        while (transformIterator.hasNext()) {\n            Node node = (Node) transformIterator.next();\n            String transformType = XPathUtils.selectStringValueNormalize(node, \"@type\");\n            if (\"scale\".equals(transformType)) {\n                // Scale image\n                String qualityString = XPathUtils.selectStringValueNormalize(node, \"quality\");\n                boolean lowQuality = \"low\".equals(qualityString);\n                boolean scaleUp = selectBooleanValue(node, \"scale-up\", DEFAULT_SCALE_UP);\n                String widthString = XPathUtils.selectStringValueNormalize(node, \"width\");\n                int width;\n                int height;\n                if (widthString == null) {\n                    // There must be a maximum, use it to compute width and height\n                    String maxSizeString = XPathUtils.selectStringValueNormalize(node, \"max-size\");\n                    String maxWidthString = XPathUtils.selectStringValueNormalize(node, \"max-width\");\n                    String maxHeightString = XPathUtils.selectStringValueNormalize(node, \"max-height\");\n                    if (maxSizeString != null) {\n                        int maxSize = Integer.parseInt(maxSizeString);\n                        double scale = (currentWidth > currentHeight)\n                                ? ((double) maxSize / (double) currentWidth)\n                                : ((double) maxSize / (double) currentHeight);\n                        width = (int) (scale * currentWidth);\n                        height = (int) (scale * currentHeight);\n                    } else if (maxWidthString != null) {\n                        int maxWidth = Integer.parseInt(maxWidthString);\n                        double scale = (double) maxWidth / (double) currentWidth;\n                        width = (int) (scale * currentWidth);\n                        height = (int) (scale * currentHeight);\n                    } else {\n                        int maxHeight = Integer.parseInt(maxHeightString);\n                        double scale = (double) maxHeight / (double) currentHeight;\n                        width = (int) (scale * currentWidth);\n                        height = (int) (scale * currentHeight);\n                    }\n                } else {\n                    // Width and height are specified directly\n                    String heightString = XPathUtils.selectStringValueNormalize(node, \"height\");\n                    width = Integer.parseInt(widthString);\n                    height = Integer.parseInt(heightString);\n                }\n                // Make sure we don't scale up if not allowed to\n                if (!scaleUp && (width > currentWidth || height > currentHeight)) {\n                    width = currentWidth;\n                    height = currentHeight;\n                }\n                // Chain filter if needed\n                if (currentWidth != width || currentHeight != height) {\n                    ImageFilter scaleFilter = lowQuality ? new ReplicateScaleFilter(width, height) : new AreaAveragingScaleFilter(width, height);\n                    producer = new FilteredImageSource(producer, scaleFilter);\n                    // Remember current width and height\n                    currentWidth = width;\n                    currentHeight = height;\n                }\n            } else if (\"crop\".equals(transformType)) {\n                // Crop image\n                int x = selectIntValue(node, \"x\", 0);\n                int y = selectIntValue(node, \"y\", 0);\n                int width = selectIntValue(node, \"width\", currentWidth - x);\n                int height = selectIntValue(node, \"height\", currentHeight - y);\n                // Calculate actual size\n                Rectangle2D rect = new Rectangle(x, y, width, height);\n                Rectangle2D imageRect = new Rectangle(0, 0, currentWidth, currentHeight);\n                Rectangle2D intersection = rect.createIntersection(imageRect);\n\n                // Make sure image is not empty\n                if (intersection.getWidth() < 0 || intersection.getHeight() < 0) {\n                    logger.info(\"Resulting image is empty after crop!\");\n                    throw new OXFException(\"Resulting image is empty after crop!\");\n                }\n\n                // Chain filter if needed\n                if (!imageRect.equals(intersection)) {\n                    ImageFilter cropFilter = new CropImageFilter((int) intersection.getX(),\n                            (int) intersection.getY(), (int) intersection.getWidth(), (int) intersection.getHeight());\n                    producer = new FilteredImageSource(producer, cropFilter);\n                    // Remember current width and height\n                    currentWidth = (int) intersection.getWidth();\n                    currentHeight = (int) intersection.getHeight();\n                }\n            } else if (\"draw\".equals(transformType)) {\n                // Don't do anything for now, this must be the last step\n                drawConfiguration.add(node);\n            }\n        }\n\n        Image filteredImg = Toolkit.getDefaultToolkit().createImage(producer);\n\n        // Create resulting image\n        BufferedImage newImage = new BufferedImage(currentWidth, currentHeight, srcImage.getType());\n        Graphics2D graphics = newImage.createGraphics();\n        graphics.drawImage(filteredImg, null, null);\n        // Check for drawing operation\n        for (Iterator drawConfigIterator = drawConfiguration.iterator(); drawConfigIterator.hasNext();) {\n            Node drawConfigNode = (Node) drawConfigIterator.next();\n            for (Iterator i = XPathUtils.selectIterator(drawConfigNode, \"rect | fill | line\"); i.hasNext();) {\n                Node node = (Node) i.next();\n                String operation = XPathUtils.selectStringValueNormalize(node, \"name()\");\n                if (\"rect\".equals(operation)) {\n                    int x = XPathUtils.selectIntegerValue(node, \"@x\").intValue();\n                    int y = XPathUtils.selectIntegerValue(node, \"@y\").intValue();\n                    int width = XPathUtils.selectIntegerValue(node, \"@width\").intValue() - 1;\n                    int height = XPathUtils.selectIntegerValue(node, \"@height\").intValue() - 1;\n                    Node colorNode = XPathUtils.selectSingleNode(node, \"color\");\n                    if (colorNode != null) {\n                        graphics.setColor(getColor(colorNode));\n                    }\n                    graphics.drawRect(x, y, width, height);\n                } else if (\"fill\".equals(operation)) {\n                    int x = XPathUtils.selectIntegerValue(node, \"@x\").intValue();\n                    int y = XPathUtils.selectIntegerValue(node, \"@y\").intValue();\n                    int width = XPathUtils.selectIntegerValue(node, \"@width\").intValue();\n                    int height = XPathUtils.selectIntegerValue(node, \"@height\").intValue();\n                    Node colorNode = XPathUtils.selectSingleNode(node, \"color\");\n                    if (colorNode != null) {\n                        graphics.setColor(getColor(colorNode));\n                    }\n                    graphics.fillRect(x, y, width, height);\n                } else if (\"line\".equals(operation)) {\n                    int x1 = XPathUtils.selectIntegerValue(node, \"@x1\").intValue();\n                    int y1 = XPathUtils.selectIntegerValue(node, \"@y1\").intValue();\n                    int x2 = XPathUtils.selectIntegerValue(node, \"@x2\").intValue();\n                    int y2 = XPathUtils.selectIntegerValue(node, \"@y2\").intValue();\n                    Node colorNode = XPathUtils.selectSingleNode(node, \"color\");\n                    if (colorNode != null) {\n                        graphics.setColor(getColor(colorNode));\n                    }\n                    graphics.drawLine(x1, y1, x2, y2);\n                }\n            }\n        }\n        graphics.dispose();\n\n        return newImage;\n    }","id":175,"modified_method":"private synchronized BufferedImage filter(BufferedImage img, Iterator transformIterator) {\n        // Copy the image to RGB if necessary (is there another way? Otherwise some images fail)\n        BufferedImage srcImage = img;\n        if (img.getType() != BufferedImage.TYPE_INT_RGB) {\n            srcImage = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_RGB);\n            Graphics2D graphics = srcImage.createGraphics();\n            graphics.drawImage(img, null, 0, 0);\n            graphics.dispose();\n        }\n\n        ImageProducer producer = srcImage.getSource();\n        int currentWidth = img.getWidth(null);\n        int currentHeight = img.getHeight(null);\n\n        // There may be one drawing operation\n        List<Node> drawConfiguration = new ArrayList<Node>();\n\n        // Iterate through all transforms\n        while (transformIterator.hasNext()) {\n            Node node = (Node) transformIterator.next();\n            String transformType = XPathUtils.selectStringValueNormalize(node, \"@type\");\n            if (\"scale\".equals(transformType)) {\n                // Scale image\n                String qualityString = XPathUtils.selectStringValueNormalize(node, \"quality\");\n                boolean lowQuality = \"low\".equals(qualityString);\n                boolean scaleUp = selectBooleanValue(node, \"scale-up\", DEFAULT_SCALE_UP);\n                String widthString = XPathUtils.selectStringValueNormalize(node, \"width\");\n                int width;\n                int height;\n                if (widthString == null) {\n                    // There must be a maximum, use it to compute width and height\n                    String maxSizeString = XPathUtils.selectStringValueNormalize(node, \"max-size\");\n                    String maxWidthString = XPathUtils.selectStringValueNormalize(node, \"max-width\");\n                    String maxHeightString = XPathUtils.selectStringValueNormalize(node, \"max-height\");\n                    if (maxSizeString != null) {\n                        int maxSize = Integer.parseInt(maxSizeString);\n                        double scale = (currentWidth > currentHeight)\n                                ? ((double) maxSize / (double) currentWidth)\n                                : ((double) maxSize / (double) currentHeight);\n                        width = (int) (scale * currentWidth);\n                        height = (int) (scale * currentHeight);\n                    } else if (maxWidthString != null) {\n                        int maxWidth = Integer.parseInt(maxWidthString);\n                        double scale = (double) maxWidth / (double) currentWidth;\n                        width = (int) (scale * currentWidth);\n                        height = (int) (scale * currentHeight);\n                    } else {\n                        int maxHeight = Integer.parseInt(maxHeightString);\n                        double scale = (double) maxHeight / (double) currentHeight;\n                        width = (int) (scale * currentWidth);\n                        height = (int) (scale * currentHeight);\n                    }\n                } else {\n                    // Width and height are specified directly\n                    String heightString = XPathUtils.selectStringValueNormalize(node, \"height\");\n                    width = Integer.parseInt(widthString);\n                    height = Integer.parseInt(heightString);\n                }\n                // Make sure we don't scale up if not allowed to\n                if (!scaleUp && (width > currentWidth || height > currentHeight)) {\n                    width = currentWidth;\n                    height = currentHeight;\n                }\n                // Chain filter if needed\n                if (currentWidth != width || currentHeight != height) {\n                    ImageFilter scaleFilter = lowQuality ? new ReplicateScaleFilter(width, height) : new AreaAveragingScaleFilter(width, height);\n                    producer = new FilteredImageSource(producer, scaleFilter);\n                    // Remember current width and height\n                    currentWidth = width;\n                    currentHeight = height;\n                }\n            } else if (\"crop\".equals(transformType)) {\n                // Crop image\n                int x = selectIntValue(node, \"x\", 0);\n                int y = selectIntValue(node, \"y\", 0);\n                int width = selectIntValue(node, \"width\", currentWidth - x);\n                int height = selectIntValue(node, \"height\", currentHeight - y);\n                // Calculate actual size\n                Rectangle2D rect = new Rectangle(x, y, width, height);\n                Rectangle2D imageRect = new Rectangle(0, 0, currentWidth, currentHeight);\n                Rectangle2D intersection = rect.createIntersection(imageRect);\n\n                // Make sure image is not empty\n                if (intersection.getWidth() < 0 || intersection.getHeight() < 0) {\n                    logger.info(\"Resulting image is empty after crop!\");\n                    throw new OXFException(\"Resulting image is empty after crop!\");\n                }\n\n                // Chain filter if needed\n                if (!imageRect.equals(intersection)) {\n                    ImageFilter cropFilter = new CropImageFilter((int) intersection.getX(),\n                            (int) intersection.getY(), (int) intersection.getWidth(), (int) intersection.getHeight());\n                    producer = new FilteredImageSource(producer, cropFilter);\n                    // Remember current width and height\n                    currentWidth = (int) intersection.getWidth();\n                    currentHeight = (int) intersection.getHeight();\n                }\n            } else if (\"draw\".equals(transformType)) {\n                // Don't do anything for now, this must be the last step\n                drawConfiguration.add(node);\n            }\n        }\n\n        Image filteredImg = Toolkit.getDefaultToolkit().createImage(producer);\n\n        // Create resulting image\n        BufferedImage newImage = new BufferedImage(currentWidth, currentHeight, srcImage.getType());\n        Graphics2D graphics = newImage.createGraphics();\n        graphics.drawImage(filteredImg, null, null);\n        // Check for drawing operation\n        for (Node drawConfigNode: drawConfiguration) {\n            for (Iterator i = XPathUtils.selectIterator(drawConfigNode, \"rect | fill | line\"); i.hasNext();) {\n                Node node = (Node) i.next();\n                String operation = XPathUtils.selectStringValueNormalize(node, \"name()\");\n                if (\"rect\".equals(operation)) {\n                    int x = XPathUtils.selectIntegerValue(node, \"@x\");\n                    int y = XPathUtils.selectIntegerValue(node, \"@y\");\n                    int width = XPathUtils.selectIntegerValue(node, \"@width\") - 1;\n                    int height = XPathUtils.selectIntegerValue(node, \"@height\") - 1;\n                    Node colorNode = XPathUtils.selectSingleNode(node, \"color\");\n                    if (colorNode != null) {\n                        graphics.setColor(getColor(colorNode));\n                    }\n                    graphics.drawRect(x, y, width, height);\n                } else if (\"fill\".equals(operation)) {\n                    int x = XPathUtils.selectIntegerValue(node, \"@x\");\n                    int y = XPathUtils.selectIntegerValue(node, \"@y\");\n                    int width = XPathUtils.selectIntegerValue(node, \"@width\");\n                    int height = XPathUtils.selectIntegerValue(node, \"@height\");\n                    Node colorNode = XPathUtils.selectSingleNode(node, \"color\");\n                    if (colorNode != null) {\n                        graphics.setColor(getColor(colorNode));\n                    }\n                    graphics.fillRect(x, y, width, height);\n                } else if (\"line\".equals(operation)) {\n                    int x1 = XPathUtils.selectIntegerValue(node, \"@x1\");\n                    int y1 = XPathUtils.selectIntegerValue(node, \"@y1\");\n                    int x2 = XPathUtils.selectIntegerValue(node, \"@x2\");\n                    int y2 = XPathUtils.selectIntegerValue(node, \"@y2\");\n                    Node colorNode = XPathUtils.selectSingleNode(node, \"color\");\n                    if (colorNode != null) {\n                        graphics.setColor(getColor(colorNode));\n                    }\n                    graphics.drawLine(x1, y1, x2, y2);\n                }\n            }\n        }\n        graphics.dispose();\n\n        return newImage;\n    }","commit_id":"e9c5cf1d3e1250205b8d6f755674d222b16e1521","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    public void doScope(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        // Get the base requests\n        final String old_servlet_path=baseRequest.getServletPath();\n        final String old_path_info=baseRequest.getPathInfo();\n\n        DispatcherType type = baseRequest.getDispatcherType();\n       \n        ServletHolder servlet_holder=null;\n        UserIdentity.Scope old_scope=null;\n\n        // find the servlet\n        if (target.startsWith(\"/\"))\n        {\n            // Look for the servlet by path\n            PathMap.Entry entry=getHolderEntry(target);\n            if (entry!=null)\n            {\n                servlet_holder=(ServletHolder)entry.getValue();\n\n                String servlet_path_spec=(String)entry.getKey(); \n                String servlet_path=entry.getMapped()!=null?entry.getMapped():PathMap.pathMatch(servlet_path_spec,target);\n                String path_info=PathMap.pathInfo(servlet_path_spec,target);\n\n                if (DispatcherType.INCLUDE.equals(type))\n                {\n                    baseRequest.setAttribute(Dispatcher.INCLUDE_SERVLET_PATH,servlet_path);\n                    baseRequest.setAttribute(Dispatcher.INCLUDE_PATH_INFO, path_info);\n                }\n                else\n                {\n                    baseRequest.setServletPath(servlet_path);\n                    baseRequest.setPathInfo(path_info);\n                }\n            }      \n        }\n        else\n        {\n            // look for a servlet by name!\n            servlet_holder=(ServletHolder)_servletNameMap.get(target);\n        }\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"servlet {}|{}|{} -> {}\",baseRequest.getContextPath(),baseRequest.getServletPath(),baseRequest.getPathInfo(),servlet_holder);\n\n        try\n        {\n            // Do the filter/handling thang\n            if (servlet_holder!=null)\n            {\n                old_scope=baseRequest.getUserIdentityScope();\n                baseRequest.setUserIdentityScope(servlet_holder);\n\n                // start manual inline of nextScope(target,baseRequest,request,response);\n                if (never())\n                    nextScope(target,baseRequest,request,response);\n                else if (_nextScope!=null)\n                    _nextScope.doScope(target,baseRequest,request, response);\n                else if (_outerScope!=null)\n                    _outerScope.doHandle(target,baseRequest,request, response);\n                else \n                    doHandle(target,baseRequest,request, response);\n                // end manual inline (pathentic attempt to reduce stack depth)\n            }\n        }\n        finally\n        {\n            if (old_scope!=null)\n                baseRequest.setUserIdentityScope(old_scope);\n\n            if (!(DispatcherType.INCLUDE.equals(type)))\n            {\n                baseRequest.setServletPath(old_servlet_path);\n                baseRequest.setPathInfo(old_path_info); \n            }\n        }\n    }","id":176,"modified_method":"@Override\n    public void doScope(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        // Get the base requests\n        final String old_servlet_path=baseRequest.getServletPath();\n        final String old_path_info=baseRequest.getPathInfo();\n\n        DispatcherType type = baseRequest.getDispatcherType();\n       \n        ServletHolder servlet_holder=null;\n        UserIdentity.Scope old_scope=null;\n\n        // find the servlet\n        if (target.startsWith(\"/\"))\n        {\n            // Look for the servlet by path\n            PathMap.Entry entry=getHolderEntry(target);\n            if (entry!=null)\n            {\n                servlet_holder=(ServletHolder)entry.getValue();\n\n                String servlet_path_spec=(String)entry.getKey(); \n                String servlet_path=entry.getMapped()!=null?entry.getMapped():PathMap.pathMatch(servlet_path_spec,target);\n                String path_info=PathMap.pathInfo(servlet_path_spec,target);\n\n                if (DispatcherType.INCLUDE.equals(type))\n                {\n                    baseRequest.setAttribute(Dispatcher.INCLUDE_SERVLET_PATH,servlet_path);\n                    baseRequest.setAttribute(Dispatcher.INCLUDE_PATH_INFO, path_info);\n                }\n                else\n                {\n                    baseRequest.setServletPath(servlet_path);\n                    baseRequest.setPathInfo(path_info);\n                }\n            }      \n        }\n        else\n        {\n            // look for a servlet by name!\n            servlet_holder=(ServletHolder)_servletNameMap.get(target);\n        }\n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"servlet {}|{}|{} -> {}\",baseRequest.getContextPath(),baseRequest.getServletPath(),baseRequest.getPathInfo(),servlet_holder);\n\n        try\n        {\n            // Do the filter/handling thang\n            old_scope=baseRequest.getUserIdentityScope();\n            baseRequest.setUserIdentityScope(servlet_holder);\n\n            // start manual inline of nextScope(target,baseRequest,request,response);\n            if (never())\n                nextScope(target,baseRequest,request,response);\n            else if (_nextScope!=null)\n                _nextScope.doScope(target,baseRequest,request, response);\n            else if (_outerScope!=null)\n                _outerScope.doHandle(target,baseRequest,request, response);\n            else \n                doHandle(target,baseRequest,request, response);\n            // end manual inline (pathentic attempt to reduce stack depth)\n        }\n        finally\n        {\n            if (old_scope!=null)\n                baseRequest.setUserIdentityScope(old_scope);\n\n            if (!(DispatcherType.INCLUDE.equals(type)))\n            {\n                baseRequest.setServletPath(old_servlet_path);\n                baseRequest.setPathInfo(old_path_info); \n            }\n        }\n    }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void notFound(HttpServletRequest request,\n                  HttpServletResponse response)\n        throws IOException\n    {\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"Not Found \"+request.getRequestURI());\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }","id":177,"modified_method":"protected void notFound(HttpServletRequest request,\n                  HttpServletResponse response)\n        throws IOException\n    {\n        new Throwable().printStackTrace();\n        if(LOG.isDebugEnabled())\n            LOG.debug(\"Not Found \"+request.getRequestURI());\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void doHandle(String target, Request baseRequest,HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException\n    {\n        DispatcherType type = baseRequest.getDispatcherType();\n        \n        ServletHolder servlet_holder=(ServletHolder) baseRequest.getUserIdentityScope();\n        FilterChain chain=null;\n\n        // find the servlet\n        if (target.startsWith(\"/\"))\n        {\n            if (servlet_holder!=null && _filterMappings!=null && _filterMappings.length>0)\n                chain=getFilterChain(baseRequest, target, servlet_holder);\n        }\n        else\n        {\n            if (servlet_holder!=null)\n            {\n                if (_filterMappings!=null && _filterMappings.length>0)\n                {\n                    chain=getFilterChain(baseRequest, null,servlet_holder);\n                }\n            }\n        }\n\n        LOG.debug(\"chain={}\",chain);\n        \n        try\n        {\n            if (servlet_holder==null)\n            {\n                notFound(request, response);\n            }\n            else\n            {\n                // unwrap any tunnelling of base Servlet request/responses\n                ServletRequest req = request;\n                if (req instanceof ServletRequestHttpWrapper)\n                    req = ((ServletRequestHttpWrapper)req).getRequest();\n                ServletResponse res = response;\n                if (res instanceof ServletResponseHttpWrapper)\n                    res = ((ServletResponseHttpWrapper)res).getResponse();\n\n                // Do the filter/handling thang\n                if (chain!=null)\n                    chain.doFilter(req, res);\n                else \n                    servlet_holder.handle(baseRequest,req,res);\n            }\n        }\n        catch(EofException e)\n        {\n            throw e;\n        }\n        catch(RuntimeIOException e)\n        {\n            throw e;\n        }\n        catch(ContinuationThrowable e)\n        {   \n            throw e;\n        }\n        catch(Exception e)\n        {\n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n            {\n                if (e instanceof IOException)\n                    throw (IOException)e;\n                if (e instanceof RuntimeException)\n                    throw (RuntimeException)e;\n                if (e instanceof ServletException)\n                    throw (ServletException)e;\n            }\n\n            // unwrap cause\n            Throwable th=e;\n            if (th instanceof UnavailableException)\n            {\n                LOG.debug(th); \n            }\n            else if (th instanceof ServletException)\n            {\n                LOG.debug(th);\n                Throwable cause=((ServletException)th).getRootCause();\n                if (cause!=null)\n                    th=cause;\n            }\n            else if (th instanceof RuntimeIOException)\n            {\n                LOG.debug(th);\n                Throwable cause=(IOException)((RuntimeIOException)th).getCause();\n                if (cause!=null)\n                    th=cause;\n            }\n\n            // handle or log exception\n            if (th instanceof HttpException)\n                throw (HttpException)th;\n            else if (th instanceof RuntimeIOException)\n                throw (RuntimeIOException)th;\n            else if (th instanceof EofException)\n                throw (EofException)th;\n\n            else if (LOG.isDebugEnabled())\n            {\n                LOG.warn(request.getRequestURI(), th); \n                LOG.debug(request.toString()); \n            }\n            else if (th instanceof IOException || th instanceof UnavailableException)\n            {\n                LOG.debug(request.getRequestURI(),th);\n            }\n            else\n            {\n                LOG.warn(request.getRequestURI(),th);\n            }\n\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,th.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,th);\n                if (th instanceof UnavailableException)\n                {\n                    UnavailableException ue = (UnavailableException)th;\n                    if (ue.isPermanent())\n                        response.sendError(HttpServletResponse.SC_NOT_FOUND,th.getMessage());\n                    else\n                        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,th.getMessage());\n                }\n                else\n                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,th.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \"+th);\n        }\n        catch(Error e)\n        {   \n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n                throw e;\n            LOG.warn(\"Error for \"+request.getRequestURI(),e);\n            if(LOG.isDebugEnabled())LOG.debug(request.toString());\n\n            // TODO httpResponse.getHttpConnection().forceClose();\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,e.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,e);\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,e.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \",e);\n        }\n        finally\n        {\n            baseRequest.setHandled(true);\n        }\n    }","id":178,"modified_method":"@Override\n    public void doHandle(String target, Request baseRequest,HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException\n    {\n        DispatcherType type = baseRequest.getDispatcherType();\n        \n        ServletHolder servlet_holder=(ServletHolder) baseRequest.getUserIdentityScope();\n        FilterChain chain=null;\n\n        // find the servlet\n        if (target.startsWith(\"/\"))\n        {\n            if (servlet_holder!=null && _filterMappings!=null && _filterMappings.length>0)\n                chain=getFilterChain(baseRequest, target, servlet_holder);\n        }\n        else\n        {\n            if (servlet_holder!=null)\n            {\n                if (_filterMappings!=null && _filterMappings.length>0)\n                {\n                    chain=getFilterChain(baseRequest, null,servlet_holder);\n                }\n            }\n        }\n\n        LOG.debug(\"chain={}\",chain);\n        \n        try\n        {\n            if (servlet_holder==null)\n            {\n                if (getHandler()==null)\n                    notFound(request, response);\n                else\n                    nextHandle(target,baseRequest,request,response);\n            }\n            else\n            {\n                // unwrap any tunnelling of base Servlet request/responses\n                ServletRequest req = request;\n                if (req instanceof ServletRequestHttpWrapper)\n                    req = ((ServletRequestHttpWrapper)req).getRequest();\n                ServletResponse res = response;\n                if (res instanceof ServletResponseHttpWrapper)\n                    res = ((ServletResponseHttpWrapper)res).getResponse();\n\n                // Do the filter/handling thang\n                if (chain!=null)\n                    chain.doFilter(req, res);\n                else \n                    servlet_holder.handle(baseRequest,req,res);\n            }\n        }\n        catch(EofException e)\n        {\n            throw e;\n        }\n        catch(RuntimeIOException e)\n        {\n            throw e;\n        }\n        catch(ContinuationThrowable e)\n        {   \n            throw e;\n        }\n        catch(Exception e)\n        {\n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n            {\n                if (e instanceof IOException)\n                    throw (IOException)e;\n                if (e instanceof RuntimeException)\n                    throw (RuntimeException)e;\n                if (e instanceof ServletException)\n                    throw (ServletException)e;\n            }\n\n            // unwrap cause\n            Throwable th=e;\n            if (th instanceof UnavailableException)\n            {\n                LOG.debug(th); \n            }\n            else if (th instanceof ServletException)\n            {\n                LOG.debug(th);\n                Throwable cause=((ServletException)th).getRootCause();\n                if (cause!=null)\n                    th=cause;\n            }\n            else if (th instanceof RuntimeIOException)\n            {\n                LOG.debug(th);\n                Throwable cause=(IOException)((RuntimeIOException)th).getCause();\n                if (cause!=null)\n                    th=cause;\n            }\n\n            // handle or log exception\n            if (th instanceof HttpException)\n                throw (HttpException)th;\n            else if (th instanceof RuntimeIOException)\n                throw (RuntimeIOException)th;\n            else if (th instanceof EofException)\n                throw (EofException)th;\n\n            else if (LOG.isDebugEnabled())\n            {\n                LOG.warn(request.getRequestURI(), th); \n                LOG.debug(request.toString()); \n            }\n            else if (th instanceof IOException || th instanceof UnavailableException)\n            {\n                LOG.debug(request.getRequestURI(),th);\n            }\n            else\n            {\n                LOG.warn(request.getRequestURI(),th);\n            }\n\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,th.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,th);\n                if (th instanceof UnavailableException)\n                {\n                    UnavailableException ue = (UnavailableException)th;\n                    if (ue.isPermanent())\n                        response.sendError(HttpServletResponse.SC_NOT_FOUND,th.getMessage());\n                    else\n                        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,th.getMessage());\n                }\n                else\n                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,th.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \"+th);\n        }\n        catch(Error e)\n        {   \n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n                throw e;\n            LOG.warn(\"Error for \"+request.getRequestURI(),e);\n            if(LOG.isDebugEnabled())LOG.debug(request.toString());\n\n            // TODO httpResponse.getHttpConnection().forceClose();\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,e.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,e);\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,e.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \",e);\n        }\n        finally\n        {\n            baseRequest.setHandled(true);\n        }\n    }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void doFilter(ServletRequest request, ServletResponse response) \n            throws IOException, ServletException\n        {\n            // pass to next filter\n            if (_filterHolder!=null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call filter \" + _filterHolder);\n                Filter filter= _filterHolder.getFilter();\n                if (_filterHolder.isAsyncSupported())\n                    filter.doFilter(request, response, _next);\n                else\n                {\n                    final Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n                    final boolean suspendable=baseRequest.isAsyncSupported();\n                    if (suspendable)\n                    {\n                        try\n                        {\n                            baseRequest.setAsyncSupported(false);\n                            filter.doFilter(request, response, _next);\n                        }\n                        finally\n                        {\n                            baseRequest.setAsyncSupported(true);\n                        }\n                    }\n                    else\n                        filter.doFilter(request, response, _next);\n                }\n                return;\n            }\n\n            // Call servlet\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call servlet \" + _servletHolder);\n                final Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n                _servletHolder.handle(baseRequest,request, response);\n            }\n            else // Not found\n                notFound((HttpServletRequest)request, (HttpServletResponse)response);\n        }","id":179,"modified_method":"public void doFilter(ServletRequest request, ServletResponse response) \n            throws IOException, ServletException\n        {                   \n            final Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n\n            // pass to next filter\n            if (_filterHolder!=null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call filter \" + _filterHolder);\n                Filter filter= _filterHolder.getFilter();\n                if (_filterHolder.isAsyncSupported())\n                    filter.doFilter(request, response, _next);\n                else\n                {\n                    final boolean suspendable=baseRequest.isAsyncSupported();\n                    if (suspendable)\n                    {\n                        try\n                        {\n                            baseRequest.setAsyncSupported(false);\n                            filter.doFilter(request, response, _next);\n                        }\n                        finally\n                        {\n                            baseRequest.setAsyncSupported(true);\n                        }\n                    }\n                    else\n                        filter.doFilter(request, response, _next);\n                }\n                return;\n            }\n\n            // Call servlet\n            \n            HttpServletRequest srequest = (HttpServletRequest)request;\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call servlet \" + _servletHolder);\n                _servletHolder.handle(baseRequest,request, response);\n            }\n            else if (getHandler()==null)\n                notFound(srequest, (HttpServletResponse)response);\n            else\n                nextHandle(URIUtil.addPaths(srequest.getServletPath(),srequest.getPathInfo()),\n                           baseRequest,srequest,(HttpServletResponse)response);\n            \n        }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void doFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException\n        {\n            if (LOG.isDebugEnabled()) \n                LOG.debug(\"doFilter \" + _filter);\n\n            // pass to next filter\n            if (_filter < LazyList.size(_chain))\n            {\n                FilterHolder holder= (FilterHolder)LazyList.get(_chain, _filter++);\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call filter \" + holder);\n                Filter filter= holder.getFilter();\n                \n                if (holder.isAsyncSupported() || !_baseRequest.isAsyncSupported())\n                {\n                    filter.doFilter(request, response, this);\n                }\n                else\n                {\n                    try\n                    {\n                        _baseRequest.setAsyncSupported(false);\n                        filter.doFilter(request, response, this);\n                    }\n                    finally\n                    {\n                        _baseRequest.setAsyncSupported(true);\n                    }\n                }\n                    \n                return;\n            }\n\n            // Call servlet\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call servlet \" + _servletHolder);\n                _servletHolder.handle(_baseRequest,request, response);\n            }\n            else // Not found\n                notFound((HttpServletRequest)request, (HttpServletResponse)response);\n        }","id":180,"modified_method":"public void doFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException\n        {\n            if (LOG.isDebugEnabled()) \n                LOG.debug(\"doFilter \" + _filter);\n\n            // pass to next filter\n            if (_filter < LazyList.size(_chain))\n            {\n                FilterHolder holder= (FilterHolder)LazyList.get(_chain, _filter++);\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call filter \" + holder);\n                Filter filter= holder.getFilter();\n                \n                if (holder.isAsyncSupported() || !_baseRequest.isAsyncSupported())\n                {\n                    filter.doFilter(request, response, this);\n                }\n                else\n                {\n                    try\n                    {\n                        _baseRequest.setAsyncSupported(false);\n                        filter.doFilter(request, response, this);\n                    }\n                    finally\n                    {\n                        _baseRequest.setAsyncSupported(true);\n                    }\n                }\n                    \n                return;\n            }\n\n            // Call servlet\n            HttpServletRequest srequest = (HttpServletRequest)request;\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call servlet \" + _servletHolder);\n                _servletHolder.handle(_baseRequest,request, response);\n            }\n            else if (getHandler()==null)\n                notFound(srequest, (HttpServletResponse)response);\n            else\n            {            \n                Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n                nextHandle(URIUtil.addPaths(srequest.getServletPath(),srequest.getPathInfo()),\n                           baseRequest,srequest,(HttpServletResponse)response);\n            }\n        }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void createView() {\n    commonParametersPanel.add(commonJavaParameters, BorderLayout.CENTER);\n\n    packageTest.setSelected(false);\n    suiteTest.setSelected(false);\n    suiteTest.setEnabled(true);\n    groupTest.setSelected(false);\n    groupTest.setEnabled(true);\n    classTest.setSelected(false);\n    classTest.setEnabled(true);\n    patternTest.setSelected(false);\n    patternTest.setEnabled(true);\n\n    classField.setComponent(new EditorTextFieldWithBrowseButton(project, true, new JavaCodeFragment.VisibilityChecker() {\n      @Override\n      public Visibility isDeclarationVisible(PsiElement declaration, PsiElement place) {\n        try {\n          if (declaration instanceof PsiClass && \n              new TestClassBrowser(project, TestNGConfigurationEditor.this).getFilter().isAccepted((PsiClass)declaration)) {\n            return Visibility.VISIBLE;\n          }\n        }\n        catch (MessageInfoException e) {\n          return Visibility.NOT_VISIBLE;\n        }\n        return Visibility.NOT_VISIBLE;\n      }\n    }));\n\n    final EditorTextFieldWithBrowseButton methodEditorTextField = new EditorTextFieldWithBrowseButton(project, true);\n    new TextFieldCompletionProvider() {\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        final String className = getClassName();\n        if (className.trim().length() == 0) {\n          return;\n        }\n        final PsiClass testClass = getModuleSelector().findClass(className);\n        if (testClass == null) return;\n        for (PsiMethod psiMethod : testClass.getAllMethods()) {\n          if (TestNGUtil.hasTest(psiMethod)) {\n            result.addElement(LookupElementBuilder.create(psiMethod.getName()));\n          }\n        }\n      }\n    }.apply(methodEditorTextField.getChildComponent());\n    methodField.setComponent(methodEditorTextField);\n\n    groupField.setComponent(new TextFieldWithBrowseButton.NoPathCompletion());\n    suiteField.setComponent(new TextFieldWithBrowseButton());\n    packageField.setVisible(true);\n    packageField.setEnabled(true);\n    packageField.setComponent(new EditorTextFieldWithBrowseButton(project, false));\n\n\n    TextFieldWithBrowseButton outputDirectoryButton = new TextFieldWithBrowseButton();\n    outputDirectory.setComponent(outputDirectoryButton);\n    outputDirectoryButton.addBrowseFolderListener(\"TestNG\", \"Select test output directory\", project,\n                                                  FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    moduleClasspath.setEnabled(true);\n    moduleClasspath.setComponent(new JComboBox());\n\n    propertiesTableModel = new TestNGParametersTableModel();\n    listenerModel = new TestNGListenersTableModel();\n\n    TextFieldWithBrowseButton textFieldWithBrowseButton = new TextFieldWithBrowseButton();\n    propertiesFile.setComponent(textFieldWithBrowseButton);\n\n    FileChooserDescriptor propertiesFileDescriptor = new FileChooserDescriptor(true, false, false, false, false, false)\n    {\n      @Override\n      public boolean isFileVisible(VirtualFile virtualFile, boolean showHidden) {\n        if (!showHidden && virtualFile.getName().charAt(0) == '.') return false;\n        return virtualFile.isDirectory() || \"properties\".equals(virtualFile.getExtension());\n      }\n    };\n\n    textFieldWithBrowseButton\n        .addBrowseFolderListener(\"TestNG\", \"Select .properties file for test properties\", project, propertiesFileDescriptor);\n\n    propertiesTableView.setModelAndUpdateColumns(propertiesTableModel);\n    propertiesTableView.setShowGrid(true);\n\n    listenersTable.setModel(listenerModel);\n\n    myAddButton.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent e) {\n        propertiesTableModel.addParameter();\n        int index = propertiesTableModel.getRowCount() - 1;\n        propertiesTableView.setRowSelectionInterval(index, index);\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent e) {\n        int idx = propertiesTableView.getSelectedRow() - 1;\n        for (int row : propertiesTableView.getSelectedRows()) {\n          propertiesTableModel.removeProperty(row);\n        }\n        if (idx > -1) propertiesTableView.setRowSelectionInterval(idx, idx);\n      }\n    });\n  }","id":181,"modified_method":"private void createView() {\n    commonParametersPanel.add(commonJavaParameters, BorderLayout.CENTER);\n\n    packageTest.setSelected(false);\n    suiteTest.setSelected(false);\n    suiteTest.setEnabled(true);\n    groupTest.setSelected(false);\n    groupTest.setEnabled(true);\n    classTest.setSelected(false);\n    classTest.setEnabled(true);\n    patternTest.setSelected(false);\n    patternTest.setEnabled(true);\n\n    classField.setComponent(new EditorTextFieldWithBrowseButton(project, true, new JavaCodeFragment.VisibilityChecker() {\n      @Override\n      public Visibility isDeclarationVisible(PsiElement declaration, PsiElement place) {\n        try {\n          if (declaration instanceof PsiClass &&\n              new TestClassBrowser(project, TestNGConfigurationEditor.this).getFilter().isAccepted((PsiClass)declaration)) {\n            return Visibility.VISIBLE;\n          }\n        }\n        catch (MessageInfoException e) {\n          return Visibility.NOT_VISIBLE;\n        }\n        return Visibility.NOT_VISIBLE;\n      }\n    }));\n\n    final EditorTextFieldWithBrowseButton methodEditorTextField = new EditorTextFieldWithBrowseButton(project, true);\n    new TextFieldCompletionProvider() {\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        final String className = getClassName();\n        if (className.trim().length() == 0) {\n          return;\n        }\n        final PsiClass testClass = getModuleSelector().findClass(className);\n        if (testClass == null) return;\n        for (PsiMethod psiMethod : testClass.getAllMethods()) {\n          if (TestNGUtil.hasTest(psiMethod)) {\n            result.addElement(LookupElementBuilder.create(psiMethod.getName()));\n          }\n        }\n      }\n    }.apply(methodEditorTextField.getChildComponent());\n    methodField.setComponent(methodEditorTextField);\n\n    groupField.setComponent(new TextFieldWithBrowseButton.NoPathCompletion());\n    suiteField.setComponent(new TextFieldWithBrowseButton());\n    packageField.setVisible(true);\n    packageField.setEnabled(true);\n    packageField.setComponent(new EditorTextFieldWithBrowseButton(project, false));\n\n\n    TextFieldWithBrowseButton outputDirectoryButton = new TextFieldWithBrowseButton();\n    outputDirectory.setComponent(outputDirectoryButton);\n    outputDirectoryButton.addBrowseFolderListener(\"TestNG\", \"Select test output directory\", project,\n                                                  FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    moduleClasspath.setEnabled(true);\n    moduleClasspath.setComponent(new JComboBox());\n\n    propertiesTableModel = new TestNGParametersTableModel();\n    listenerModel = new TestNGListenersTableModel();\n\n    TextFieldWithBrowseButton textFieldWithBrowseButton = new TextFieldWithBrowseButton();\n    propertiesFile.setComponent(textFieldWithBrowseButton);\n\n    FileChooserDescriptor propertiesFileDescriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n      @Override\n      public boolean isFileVisible(VirtualFile virtualFile, boolean showHidden) {\n        if (!showHidden && virtualFile.getName().charAt(0) == '.') return false;\n        return virtualFile.isDirectory() || \"properties\".equals(virtualFile.getExtension());\n      }\n    };\n\n    textFieldWithBrowseButton\n      .addBrowseFolderListener(\"TestNG\", \"Select .properties file for test properties\", project, propertiesFileDescriptor);\n\n    propertiesTableView = new TableView();\n    propertiesTableView.setModelAndUpdateColumns(propertiesTableModel);\n    propertiesTableView.setShowGrid(true);\n\n    myPropertiesPanel.add(\n      ToolbarDecorator.createDecorator(propertiesTableView)\n        .setAddAction(new AnActionButtonRunnable() {\n          @Override\n          public void run(AnActionButton button) {\n            propertiesTableModel.addParameter();\n            int index = propertiesTableModel.getRowCount() - 1;\n            propertiesTableView.setRowSelectionInterval(index, index);\n          }\n        }).setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          int idx = propertiesTableView.getSelectedRow() - 1;\n          for (int row : propertiesTableView.getSelectedRows()) {\n            propertiesTableModel.removeProperty(row);\n          }\n          if (idx > -1) propertiesTableView.setRowSelectionInterval(idx, idx);\n        }\n      }).disableUpDownActions().createPanel(), BorderLayout.CENTER);\n\n    myListenersList = new JBList(listenerModel);\n    myListenersPanel.add(\n      ToolbarDecorator.createDecorator(myListenersList).setAddAction(new AddActionButtonRunnable())\n        .setRemoveAction(new AnActionButtonRunnable() {\n          @Override\n          public void run(AnActionButton button) {\n            int idx = myListenersList.getSelectedIndex() - 1;\n            for (int row : myListenersList.getSelectedIndices()) {\n              listenerModel.removeListener(row);\n            }\n            if (idx > -1) myListenersList.setSelectedIndex(idx);\n          }\n        }).setAddActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          return !project.isDefault();\n        }\n      }).disableUpDownActions().createPanel(), BorderLayout.CENTER);\n  }","commit_id":"2205f88698d34923c7d76ba61086b708e611a83c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setAnchor(JComponent anchor) {\n    this.anchor = anchor;\n    methodField.setAnchor(anchor);\n    packageField.setAnchor(anchor);\n    groupField.setAnchor(anchor);\n    suiteField.setAnchor(anchor);\n    outputDirectory.setAnchor(anchor);\n    classField.setAnchor(anchor);\n  }","id":182,"modified_method":"@Override\n  public void setAnchor(JComponent anchor) {\n    this.anchor = anchor;\n    methodField.setAnchor(anchor);\n    packageField.setAnchor(anchor);\n    groupField.setAnchor(anchor);\n    suiteField.setAnchor(anchor);\n    outputDirectory.setAnchor(anchor);\n    classField.setAnchor(anchor);\n    myPattern.setAnchor(anchor);\n  }","commit_id":"2205f88698d34923c7d76ba61086b708e611a83c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestNGConfigurationEditor(Project project) {\n    this.project = project;\n    BrowseModuleValueActionListener[] browseListeners = new BrowseModuleValueActionListener[] {new PackageBrowser(project),\n        new TestClassBrowser(project, this), new MethodBrowser(project, this), new GroupBrowser(project, this), new SuiteBrowser(project),\n        new TestClassBrowser(project, this){\n          @Override\n          protected void onClassChoosen(PsiClass psiClass) {\n            final JTextField textField = myPatternTextField.getTextField();\n            final String text = textField.getText();\n            textField.setText(text + (text.length() > 0 ? \"||\" : \"\") + psiClass.getQualifiedName());\n          }\n\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            showDialog();\n          }\n        }};\n    model = new TestNGConfigurationModel(project);\n    model.setListener(this);\n    createView();\n    moduleSelector = new ConfigurationModuleSelector(project, getModulesComponent());\n    commonJavaParameters.setModuleContext(moduleSelector.getModule());\n    moduleClasspath.getComponent().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        commonJavaParameters.setModuleContext(moduleSelector.getModule());\n      }\n    });\n\n    final JPanel panel = myPattern.getComponent();\n    panel.setLayout(new BorderLayout());\n    myPatternTextField = new TextFieldWithBrowseButton();\n    myPatternTextField.setButtonIcon(PlatformIcons.ADD_ICON);\n    panel.add(myPatternTextField, BorderLayout.CENTER);\n    final FixedSizeButton editBtn = new FixedSizeButton();\n    editBtn.setIcon(IconLoader.getIcon(\"/actions/showViewer.png\"));\n    editBtn.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        Messages.showTextAreaDialog(myPatternTextField.getTextField(), \"Configure suite tests\", \"EditParametersPopupWindow\");\n      }\n    });\n    panel.add(editBtn, BorderLayout.EAST);\n\n    registerListener(new JRadioButton[] {packageTest, classTest, methodTest, groupTest, suiteTest, patternTest}, new ChangeListener()\n    {\n      public void stateChanged(ChangeEvent e) {\n        ButtonModel buttonModel = (ButtonModel) e.getSource();\n        if (buttonModel.isSelected()) {\n          if (buttonModel == packageTest.getModel()) {\n            model.setType(TestType.PACKAGE);\n          } else if (buttonModel == classTest.getModel()) {\n            model.setType(TestType.CLASS);\n          } else if (buttonModel == methodTest.getModel()) {\n            model.setType(TestType.METHOD);\n          } else if (buttonModel == groupTest.getModel()) {\n            model.setType(TestType.GROUP);\n          } else if (buttonModel == suiteTest.getModel()) {\n            model.setType(TestType.SUITE);\n          } else if (buttonModel == patternTest.getModel()) {\n            model.setType(TestType.PATTERN);\n          }\n          redisplay();\n        }\n      }\n    });\n    registerListener(new JRadioButton[] {packagesInProject, packagesInModule, packagesAcrossModules}, null);\n    packagesInProject.addChangeListener(new ChangeListener()\n    {\n      public void stateChanged(ChangeEvent e) {\n        evaluateModuleClassPath();\n      }\n    });\n\n    LabeledComponent[] components = new LabeledComponent[] {packageField, classField, methodField, groupField, suiteField, myPattern};\n    for (int i = 0; i < components.length; i++) {\n      JComponent field = components[i].getComponent();\n      Object document = model.getDocument(i);\n      if (field instanceof TextFieldWithBrowseButton) {\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((PlainDocument)document);\n      }\n      else if (field instanceof EditorTextFieldWithBrowseButton) {\n        final com.intellij.openapi.editor.Document componentDocument =\n          ((EditorTextFieldWithBrowseButton)field).getChildComponent().getDocument();\n        model.setDocument(i, componentDocument);\n      }\n      else {\n        field = myPatternTextField;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n        model.setDocument(i, document);\n      }\n            \n      browseListeners[i].setField((ComponentWithBrowseButton)field);\n    }\n    model.setType(TestType.CLASS);\n    addListener.addActionListener(new AddTestListenerListener());\n    addListener.setEnabled(!project.isDefault());\n    removeListener.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent event) {\n        int idx = listenersTable.getSelectedIndex() - 1;\n        for (int row : listenersTable.getSelectedIndices()) {\n          listenerModel.removeListener(row);\n        }\n        if (idx > -1) listenersTable.setSelectedIndex(idx);\n      }\n    });\n    propertiesFile.getComponent().getTextField().setDocument(model.getPropertiesFileDocument());\n    outputDirectory.getComponent().getTextField().setDocument(model.getOutputDirectoryDocument());\n\n    commonJavaParameters.setProgramParametersLabel(ExecutionBundle.message(\"junit.configuration.test.runner.parameters.label\"));\n\n    setAnchor(outputDirectory.getLabel());\n    alternateJDK.setAnchor(moduleClasspath.getLabel());\n    commonJavaParameters.setAnchor(moduleClasspath.getLabel());\n  }","id":183,"modified_method":"public TestNGConfigurationEditor(Project project) {\n    this.project = project;\n    BrowseModuleValueActionListener[] browseListeners = new BrowseModuleValueActionListener[]{new PackageBrowser(project),\n      new TestClassBrowser(project, this), new MethodBrowser(project, this), new GroupBrowser(project, this), new SuiteBrowser(project),\n      new TestClassBrowser(project, this) {\n        @Override\n        protected void onClassChoosen(PsiClass psiClass) {\n          final JTextField textField = myPatternTextField.getTextField();\n          final String text = textField.getText();\n          textField.setText(text + (text.length() > 0 ? \"||\" : \"\") + psiClass.getQualifiedName());\n        }\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          showDialog();\n        }\n      }};\n    model = new TestNGConfigurationModel(project);\n    model.setListener(this);\n    createView();\n    moduleSelector = new ConfigurationModuleSelector(project, getModulesComponent());\n    commonJavaParameters.setModuleContext(moduleSelector.getModule());\n    moduleClasspath.getComponent().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        commonJavaParameters.setModuleContext(moduleSelector.getModule());\n      }\n    });\n\n    final JPanel panel = myPattern.getComponent();\n    panel.setLayout(new BorderLayout());\n    myPatternTextField = new TextFieldWithBrowseButton();\n    myPatternTextField.setButtonIcon(PlatformIcons.ADD_ICON);\n    panel.add(myPatternTextField, BorderLayout.CENTER);\n    final FixedSizeButton editBtn = new FixedSizeButton();\n    editBtn.setIcon(IconLoader.getIcon(\"/actions/showViewer.png\"));\n    editBtn.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        Messages.showTextAreaDialog(myPatternTextField.getTextField(), \"Configure suite tests\", \"EditParametersPopupWindow\");\n      }\n    });\n    panel.add(editBtn, BorderLayout.EAST);\n\n    registerListener(new JRadioButton[]{packageTest, classTest, methodTest, groupTest, suiteTest, patternTest}, new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        ButtonModel buttonModel = (ButtonModel)e.getSource();\n        if (buttonModel.isSelected()) {\n          if (buttonModel == packageTest.getModel()) {\n            model.setType(TestType.PACKAGE);\n          }\n          else if (buttonModel == classTest.getModel()) {\n            model.setType(TestType.CLASS);\n          }\n          else if (buttonModel == methodTest.getModel()) {\n            model.setType(TestType.METHOD);\n          }\n          else if (buttonModel == groupTest.getModel()) {\n            model.setType(TestType.GROUP);\n          }\n          else if (buttonModel == suiteTest.getModel()) {\n            model.setType(TestType.SUITE);\n          }\n          else if (buttonModel == patternTest.getModel()) {\n            model.setType(TestType.PATTERN);\n          }\n          redisplay();\n        }\n      }\n    });\n    registerListener(new JRadioButton[]{packagesInProject, packagesInModule, packagesAcrossModules}, null);\n    packagesInProject.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        evaluateModuleClassPath();\n      }\n    });\n\n    LabeledComponent[] components = new LabeledComponent[]{packageField, classField, methodField, groupField, suiteField, myPattern};\n    for (int i = 0; i < components.length; i++) {\n      JComponent field = components[i].getComponent();\n      Object document = model.getDocument(i);\n      if (field instanceof TextFieldWithBrowseButton) {\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((PlainDocument)document);\n      }\n      else if (field instanceof EditorTextFieldWithBrowseButton) {\n        final com.intellij.openapi.editor.Document componentDocument =\n          ((EditorTextFieldWithBrowseButton)field).getChildComponent().getDocument();\n        model.setDocument(i, componentDocument);\n      }\n      else {\n        field = myPatternTextField;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n        model.setDocument(i, document);\n      }\n\n      browseListeners[i].setField((ComponentWithBrowseButton)field);\n    }\n    model.setType(TestType.CLASS);\n    propertiesFile.getComponent().getTextField().setDocument(model.getPropertiesFileDocument());\n    outputDirectory.getComponent().getTextField().setDocument(model.getOutputDirectoryDocument());\n\n    commonJavaParameters.setProgramParametersLabel(ExecutionBundle.message(\"junit.configuration.test.runner.parameters.label\"));\n\n    setAnchor(outputDirectory.getLabel());\n    alternateJDK.setAnchor(moduleClasspath.getLabel());\n    commonJavaParameters.setAnchor(moduleClasspath.getLabel());\n  }","commit_id":"2205f88698d34923c7d76ba61086b708e611a83c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LogConfigurationPanel() {\n    myModel = new ListTableModel<LogFileOptions>(IS_SHOW, FILE, IS_SKIP_CONTENT);\n    myFilesTable = new TableView<LogFileOptions>(myModel);\n    myFilesTable.getEmptyText().setText(DiagnosticBundle.message(\"log.monitor.no.files\"));\n\n    final JTableHeader tableHeader = myFilesTable.getTableHeader();\n    final FontMetrics fontMetrics = tableHeader.getFontMetrics(tableHeader.getFont());\n\n    int preferredWidth = fontMetrics.stringWidth(IS_SHOW.getName()) + 20;\n    setUpColumnWidth(tableHeader, preferredWidth, 0);\n\n    preferredWidth = fontMetrics.stringWidth(IS_SKIP_CONTENT.getName()) + 20;\n    setUpColumnWidth(tableHeader, preferredWidth, 2);\n\n    myFilesTable.setColumnSelectionAllowed(false);\n    myFilesTable.setShowGrid(false);\n    myFilesTable.setDragEnabled(false);\n    myFilesTable.setShowHorizontalLines(false);\n    myFilesTable.setShowVerticalLines(false);\n    myFilesTable.setIntercellSpacing(new Dimension(0, 0));\n    myAddButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        ArrayList<LogFileOptions> newList = new ArrayList<LogFileOptions>(myModel.getItems());\n        LogFileOptions newOptions = new LogFileOptions(\"\", \"\", true, true, false);\n        if (showEditorDialog(newOptions)) {\n          newList.add(newOptions);\n          myModel.setItems(newList);\n          int index = myModel.getRowCount() - 1;\n          myModel.fireTableRowsInserted(index, index);\n          myFilesTable.setRowSelectionInterval(index, index);\n        }\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        TableUtil.stopEditing(myFilesTable);\n        final int[] selected = myFilesTable.getSelectedRows();\n        if (selected == null || selected.length == 0) return;\n        for (int i = selected.length - 1; i >= 0; i--) {\n          myModel.removeRow(selected[i]);\n        }\n        for (int i = selected.length - 1; i >= 0; i--) {\n          int idx = selected[i];\n          myModel.fireTableRowsDeleted(idx, idx);\n        }\n        int selection = selected[0];\n        if (selection >= myModel.getRowCount()) {\n          selection = myModel.getRowCount() - 1;\n        }\n        if (selection >= 0) {\n          myFilesTable.setRowSelectionInterval(selection, selection);\n        }\n        myFilesTable.requestFocus();\n      }\n    });\n    myRemoveButton.setEnabled(false);\n    myFilesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        final boolean enabled = myFilesTable.getSelectedRowCount() >= 1 &&\n                                !myLog2Predefined.containsKey(myFilesTable.getSelectedObject());\n        myRemoveButton.setEnabled(enabled);\n        myEditButton.setEnabled(enabled && myFilesTable.getSelectedObject() != null);\n      }\n    });\n    myEditButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final int selectedRow = myFilesTable.getSelectedRow();\n        final LogFileOptions selectedOptions = myFilesTable.getSelectedObject();\n        showEditorDialog(selectedOptions);\n        myModel.fireTableDataChanged();\n        myFilesTable.setRowSelectionInterval(selectedRow, selectedRow);\n      }\n    });\n    myEditButton.setEnabled(false);\n    final JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myFilesTable);\n    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n    myScrollPanel.add(scrollPane, BorderLayout.CENTER);\n    myWholePanel.setPreferredSize(new Dimension(-1, 150));\n    myOutputFile.addBrowseFolderListener(\"Choose File to Save Console Output\", \"Console output would be saved to the specified file\", null,\n                                         FileChooserDescriptorFactory.createSingleFileOrFolderDescriptor(),\n                                         TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT);\n    myRedirectOutputCb.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myOutputFile.setEnabled(myRedirectOutputCb.isSelected());\n      }\n    });\n  }","id":184,"modified_method":"public LogConfigurationPanel() {\n    myModel = new ListTableModel<LogFileOptions>(IS_SHOW, FILE, IS_SKIP_CONTENT);\n    myFilesTable = new TableView<LogFileOptions>(myModel);\n    myFilesTable.getEmptyText().setText(DiagnosticBundle.message(\"log.monitor.no.files\"));\n\n    final JTableHeader tableHeader = myFilesTable.getTableHeader();\n    final FontMetrics fontMetrics = tableHeader.getFontMetrics(tableHeader.getFont());\n\n    int preferredWidth = fontMetrics.stringWidth(IS_SHOW.getName()) + 20;\n    setUpColumnWidth(tableHeader, preferredWidth, 0);\n\n    preferredWidth = fontMetrics.stringWidth(IS_SKIP_CONTENT.getName()) + 20;\n    setUpColumnWidth(tableHeader, preferredWidth, 2);\n\n    myFilesTable.setColumnSelectionAllowed(false);\n    myFilesTable.setShowGrid(false);\n    myFilesTable.setDragEnabled(false);\n    myFilesTable.setShowHorizontalLines(false);\n    myFilesTable.setShowVerticalLines(false);\n    myFilesTable.setIntercellSpacing(new Dimension(0, 0));\n\n    myScrollPanel.add(\n      ToolbarDecorator.createDecorator(myFilesTable)\n        .setAddAction(new AnActionButtonRunnable() {\n          @Override\n          public void run(AnActionButton button) {\n            ArrayList<LogFileOptions> newList = new ArrayList<LogFileOptions>(myModel.getItems());\n            LogFileOptions newOptions = new LogFileOptions(\"\", \"\", true, true, false);\n            if (showEditorDialog(newOptions)) {\n              newList.add(newOptions);\n              myModel.setItems(newList);\n              int index = myModel.getRowCount() - 1;\n              myModel.fireTableRowsInserted(index, index);\n              myFilesTable.setRowSelectionInterval(index, index);\n            }\n          }\n        }).setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          TableUtil.stopEditing(myFilesTable);\n          final int[] selected = myFilesTable.getSelectedRows();\n          if (selected == null || selected.length == 0) return;\n          for (int i = selected.length - 1; i >= 0; i--) {\n            myModel.removeRow(selected[i]);\n          }\n          for (int i = selected.length - 1; i >= 0; i--) {\n            int idx = selected[i];\n            myModel.fireTableRowsDeleted(idx, idx);\n          }\n          int selection = selected[0];\n          if (selection >= myModel.getRowCount()) {\n            selection = myModel.getRowCount() - 1;\n          }\n          if (selection >= 0) {\n            myFilesTable.setRowSelectionInterval(selection, selection);\n          }\n          myFilesTable.requestFocus();\n        }\n      }).setEditAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final int selectedRow = myFilesTable.getSelectedRow();\n          final LogFileOptions selectedOptions = myFilesTable.getSelectedObject();\n          showEditorDialog(selectedOptions);\n          myModel.fireTableDataChanged();\n          myFilesTable.setRowSelectionInterval(selectedRow, selectedRow);\n        }\n      }).setRemoveActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          return myFilesTable.getSelectedRowCount() >= 1 &&\n                 !myLog2Predefined.containsKey(myFilesTable.getSelectedObject());\n        }\n      }).setEditActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          return myFilesTable.getSelectedRowCount() >= 1 &&\n                 !myLog2Predefined.containsKey(myFilesTable.getSelectedObject()) &&\n                 myFilesTable.getSelectedObject() != null;\n        }\n      }).disableUpDownActions().createPanel(), BorderLayout.CENTER);\n\n    myWholePanel.setPreferredSize(new Dimension(-1, 150));\n    myOutputFile.addBrowseFolderListener(\"Choose File to Save Console Output\", \"Console output would be saved to the specified file\", null,\n                                         FileChooserDescriptorFactory.createSingleFileOrFolderDescriptor(),\n                                         TextComponentAccessor.TEXT_FIELD_WHOLE_TEXT);\n    myRedirectOutputCb.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myOutputFile.setEnabled(myRedirectOutputCb.isSelected());\n      }\n    });\n  }","commit_id":"f9922f231854e4286058954e780c40988565e44f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BranchConfigurationDialog(final Project project, final SvnBranchConfigurationNew configuration, final String rootUrl,\n                                   final VirtualFile root) {\n    super(project, true);\n    myRoot = root;\n    init();\n    setTitle(SvnBundle.message(\"configure.branches.title\"));\n\n    final String trunkUrl = configuration.getTrunkUrl();\n    if (trunkUrl == null || trunkUrl.trim().length() == 0) {\n      configuration.setTrunkUrl(rootUrl);\n    }\n\n    mySvnBranchConfigManager = SvnBranchConfigurationManager.getInstance(project).getSvnBranchConfigManager();\n\n    myTrunkLocationTextField.setText(configuration.getTrunkUrl());\n    myTrunkLocationTextField.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        final String selectedUrl = SelectLocationDialog.selectLocation(project, myTrunkLocationTextField.getText());\n        if (selectedUrl != null) {\n          myTrunkLocationTextField.setText(selectedUrl);\n        }\n      }\n    });\n\n    final TrunkUrlValidator trunkUrlValidator = new TrunkUrlValidator(rootUrl, configuration);\n    myTrunkLocationTextField.getTextField().getDocument().addDocumentListener(trunkUrlValidator);\n    trunkUrlValidator.textChanged(null);\n\n    final MyListModel listModel = new MyListModel(configuration);\n    myLocationList.setModel(listModel);\n    myAddButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final String selectedUrl = SelectLocationDialog.selectLocation(project, rootUrl);\n        if (selectedUrl != null) {\n          if (!configuration.getBranchUrls().contains(selectedUrl)) {\n            configuration.addBranches(selectedUrl, new InfoStorage<List<SvnBranchItem>>(new ArrayList<SvnBranchItem>(), InfoReliability.empty));\n            mySvnBranchConfigManager.reloadBranches(myRoot, selectedUrl, null);\n            listModel.fireItemAdded();\n            myLocationList.setSelectedIndex(listModel.getSize()-1);\n          }\n        }\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        int selIndex = myLocationList.getSelectedIndex();\n        Object[] selection = myLocationList.getSelectedValues();\n        for(Object urlObj: selection) {\n          String url = (String) urlObj;\n          int index = configuration.getBranchUrls().indexOf(url);\n          configuration.removeBranch(url);\n          listModel.fireItemRemoved(index);\n        }\n        if (listModel.getSize() > 0) {\n          if (selIndex >= listModel.getSize())\n            selIndex = listModel.getSize()-1;\n          myLocationList.setSelectedIndex(selIndex);\n        }\n      }\n    });\n  }","id":185,"modified_method":"public BranchConfigurationDialog(final Project project, final SvnBranchConfigurationNew configuration, final String rootUrl,\n                                   final VirtualFile root) {\n    super(project, true);\n    myRoot = root;\n    init();\n    setTitle(SvnBundle.message(\"configure.branches.title\"));\n\n    final String trunkUrl = configuration.getTrunkUrl();\n    if (trunkUrl == null || trunkUrl.trim().length() == 0) {\n      configuration.setTrunkUrl(rootUrl);\n    }\n\n    mySvnBranchConfigManager = SvnBranchConfigurationManager.getInstance(project).getSvnBranchConfigManager();\n\n    myTrunkLocationTextField.setText(configuration.getTrunkUrl());\n    myTrunkLocationTextField.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        final String selectedUrl = SelectLocationDialog.selectLocation(project, myTrunkLocationTextField.getText());\n        if (selectedUrl != null) {\n          myTrunkLocationTextField.setText(selectedUrl);\n        }\n      }\n    });\n\n    final TrunkUrlValidator trunkUrlValidator = new TrunkUrlValidator(rootUrl, configuration);\n    myTrunkLocationTextField.getTextField().getDocument().addDocumentListener(trunkUrlValidator);\n    trunkUrlValidator.textChanged(null);\n\n    final MyListModel listModel = new MyListModel(configuration);\n    myLocationList = new JBList(listModel);\n\n    myListPanel.add(\n      ToolbarDecorator.createDecorator(myLocationList)\n        .setAddAction(new AnActionButtonRunnable() {\n          @Override\n          public void run(AnActionButton button) {\n            final String selectedUrl = SelectLocationDialog.selectLocation(project, rootUrl);\n            if (selectedUrl != null) {\n              if (!configuration.getBranchUrls().contains(selectedUrl)) {\n                configuration\n                  .addBranches(selectedUrl, new InfoStorage<List<SvnBranchItem>>(new ArrayList<SvnBranchItem>(), InfoReliability.empty));\n                mySvnBranchConfigManager.reloadBranches(myRoot, selectedUrl, null);\n                listModel.fireItemAdded();\n                myLocationList.setSelectedIndex(listModel.getSize() - 1);\n              }\n            }\n          }\n        }).setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          int selIndex = myLocationList.getSelectedIndex();\n          Object[] selection = myLocationList.getSelectedValues();\n          for (Object urlObj : selection) {\n            String url = (String)urlObj;\n            int index = configuration.getBranchUrls().indexOf(url);\n            configuration.removeBranch(url);\n            listModel.fireItemRemoved(index);\n          }\n          if (listModel.getSize() > 0) {\n            if (selIndex >= listModel.getSize())\n              selIndex = listModel.getSize() - 1;\n            myLocationList.setSelectedIndex(selIndex);\n          }\n        }\n      }).disableUpDownActions().setToolbarPosition(ActionToolbarPosition.BOTTOM).createPanel(), BorderLayout.CENTER);\n  }","commit_id":"bc25dfb6959511e09b9efa5f89ddfbdbd28fef22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        queryTypeButtonGroup = new javax.swing.ButtonGroup();\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        keywordTextField = new javax.swing.JTextField();\n        searchButton = new javax.swing.JButton();\n        exactRadioButton = new javax.swing.JRadioButton();\n        substringRadioButton = new javax.swing.JRadioButton();\n        regexRadioButton = new javax.swing.JRadioButton();\n\n        org.openide.awt.Mnemonics.setLocalizedText(cutMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        org.openide.awt.Mnemonics.setLocalizedText(copyMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        org.openide.awt.Mnemonics.setLocalizedText(pasteMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        org.openide.awt.Mnemonics.setLocalizedText(selectAllMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        keywordTextField.setFont(new java.awt.Font(\"Monospaced\", 0, 14)); // NOI18N\n        keywordTextField.setText(org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.keywordTextField.text\")); // NOI18N\n        keywordTextField.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(192, 192, 192), 1, true));\n        keywordTextField.setMinimumSize(new java.awt.Dimension(2, 25));\n        keywordTextField.setPreferredSize(new java.awt.Dimension(2, 25));\n        keywordTextField.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                keywordTextFieldMouseClicked(evt);\n            }\n        });\n        keywordTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                keywordTextFieldActionPerformed(evt);\n            }\n        });\n\n        searchButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/search-icon.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(searchButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.searchButton.text\")); // NOI18N\n        searchButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                searchButtonActionPerformed(evt);\n            }\n        });\n\n        queryTypeButtonGroup.add(exactRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(exactRadioButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.exactRadioButton.text\")); // NOI18N\n\n        queryTypeButtonGroup.add(substringRadioButton);\n        substringRadioButton.setSelected(true);\n        org.openide.awt.Mnemonics.setLocalizedText(substringRadioButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.substringRadioButton.text\")); // NOI18N\n\n        queryTypeButtonGroup.add(regexRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(regexRadioButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.regexRadioButton.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(5, 5, 5)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(keywordTextField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(searchButton))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(regexRadioButton)\n                            .addComponent(substringRadioButton)\n                            .addComponent(exactRadioButton))\n                        .addGap(0, 217, Short.MAX_VALUE)))\n                .addGap(5, 5, 5))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(keywordTextField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(searchButton, javax.swing.GroupLayout.DEFAULT_SIZE, 26, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(exactRadioButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(substringRadioButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(regexRadioButton))\n        );\n    }","id":186,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        queryTypeButtonGroup = new javax.swing.ButtonGroup();\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        keywordTextField = new javax.swing.JTextField();\n        searchButton = new javax.swing.JButton();\n        exactRadioButton = new javax.swing.JRadioButton();\n        substringRadioButton = new javax.swing.JRadioButton();\n        regexRadioButton = new javax.swing.JRadioButton();\n\n        org.openide.awt.Mnemonics.setLocalizedText(cutMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        org.openide.awt.Mnemonics.setLocalizedText(copyMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        org.openide.awt.Mnemonics.setLocalizedText(pasteMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        org.openide.awt.Mnemonics.setLocalizedText(selectAllMenuItem, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        keywordTextField.setFont(new java.awt.Font(\"Monospaced\", 0, 14)); // NOI18N\n        keywordTextField.setText(org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.keywordTextField.text\")); // NOI18N\n        keywordTextField.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(192, 192, 192), 1, true));\n        keywordTextField.setMinimumSize(new java.awt.Dimension(2, 25));\n        keywordTextField.setPreferredSize(new java.awt.Dimension(2, 25));\n        keywordTextField.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                keywordTextFieldMouseClicked(evt);\n            }\n        });\n        keywordTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                keywordTextFieldActionPerformed(evt);\n            }\n        });\n\n        searchButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/keywordsearch/search-icon.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(searchButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.searchButton.text\")); // NOI18N\n        searchButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                searchButtonActionPerformed(evt);\n            }\n        });\n\n        queryTypeButtonGroup.add(exactRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(exactRadioButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.exactRadioButton.text\")); // NOI18N\n\n        queryTypeButtonGroup.add(substringRadioButton);\n        substringRadioButton.setSelected(true);\n        org.openide.awt.Mnemonics.setLocalizedText(substringRadioButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.substringRadioButton.text\")); // NOI18N\n\n        queryTypeButtonGroup.add(regexRadioButton);\n        org.openide.awt.Mnemonics.setLocalizedText(regexRadioButton, org.openide.util.NbBundle.getMessage(DropdownSearchPanel.class, \"DropdownSearchPanel.regexRadioButton.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(5, 5, 5)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(keywordTextField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(searchButton))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(exactRadioButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(substringRadioButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(regexRadioButton)\n                        .addGap(0, 27, Short.MAX_VALUE)))\n                .addGap(5, 5, 5))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(keywordTextField, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(searchButton, javax.swing.GroupLayout.DEFAULT_SIZE, 26, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(exactRadioButton)\n                    .addComponent(substringRadioButton)\n                    .addComponent(regexRadioButton))\n                .addContainerGap())\n        );\n    }","commit_id":"728fbc1947d833225fdb313fdf8674924417d617","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        dateToTextField = new JFormattedTextField(this.dateFormat);\n        jLabel1 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        dateCheckBox = new javax.swing.JCheckBox();\n        timeZoneComboBox = new JComboBox<>(this.timeZones.toArray(new String[this.timeZones.size()]));\n        timeZoneComboBox.setRenderer(new DateSearchFilter.ComboBoxRenderer());\n        jLabel3 = new javax.swing.JLabel();\n        dateFromTextField = new JFormattedTextField(this.dateFormat);\n        jLabel2 = new javax.swing.JLabel();\n        modifiedCheckBox = new javax.swing.JCheckBox();\n        changedCheckBox = new javax.swing.JCheckBox();\n        accessedCheckBox = new javax.swing.JCheckBox();\n        createdCheckBox = new javax.swing.JCheckBox();\n        dateFromButtonCalendar = new org.jbundle.thin.base.screen.jcalendarbutton.JCalendarButton();\n        dateToButtonCalendar = new org.jbundle.thin.base.screen.jcalendarbutton.JCalendarButton();\n\n        cutMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        pasteMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        dateToTextField.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateToTextField.text\")); // NOI18N\n        dateToTextField.addFocusListener(new java.awt.event.FocusAdapter() {\n            public void focusLost(java.awt.event.FocusEvent evt) {\n                dateToTextFieldFocusLost(evt);\n            }\n        });\n\n        jLabel1.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel1.text\")); // NOI18N\n\n        jLabel4.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel4.text\")); // NOI18N\n\n        dateCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateCheckBox.text\")); // NOI18N\n\n        jLabel3.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel3.text\")); // NOI18N\n\n        dateFromTextField.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateFromTextField.text\")); // NOI18N\n        dateFromTextField.addFocusListener(new java.awt.event.FocusAdapter() {\n            public void focusLost(java.awt.event.FocusEvent evt) {\n                dateFromTextFieldFocusLost(evt);\n            }\n        });\n\n        jLabel2.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel2.text\")); // NOI18N\n\n        modifiedCheckBox.setSelected(true);\n        modifiedCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.modifiedCheckBox.text\")); // NOI18N\n\n        changedCheckBox.setSelected(true);\n        changedCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.changedCheckBox.text\")); // NOI18N\n\n        accessedCheckBox.setSelected(true);\n        accessedCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.accessedCheckBox.text\")); // NOI18N\n\n        createdCheckBox.setSelected(true);\n        createdCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.createdCheckBox.text\")); // NOI18N\n\n        dateFromButtonCalendar.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateFromButtonCalendar.text\")); // NOI18N\n        dateFromButtonCalendar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                dateFromPopupChanged(evt);\n            }\n        });\n\n        dateToButtonCalendar.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateToButtonCalendar.text\")); // NOI18N\n        dateToButtonCalendar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                dateToPopupChanged(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(dateCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(dateFromTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 0, 0)\n                .addComponent(dateFromButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(dateToTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 0, 0)\n                .addComponent(dateToButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n            .addGroup(layout.createSequentialGroup()\n                .addGap(21, 21, 21)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(changedCheckBox)\n                            .addComponent(modifiedCheckBox))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(accessedCheckBox)\n                            .addComponent(createdCheckBox)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel4)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(21, 21, 21)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jLabel3)\n                            .addComponent(jLabel2)))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(dateCheckBox)\n                        .addComponent(dateFromTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(dateToButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(jLabel1)\n                        .addComponent(dateToTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(dateFromButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addGap(4, 4, 4)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel4)\n                    .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modifiedCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(changedCheckBox))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(accessedCheckBox)\n                        .addGap(23, 23, 23))\n                    .addComponent(createdCheckBox))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jLabel2)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addGap(0, 0, 0))\n        );\n    }","id":187,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        dateToTextField = new JFormattedTextField(this.dateFormat);\n        jLabel1 = new javax.swing.JLabel();\n        jLabel4 = new javax.swing.JLabel();\n        dateCheckBox = new javax.swing.JCheckBox();\n        timeZoneComboBox = new JComboBox<>(this.timeZones.toArray(new String[this.timeZones.size()]));\n        timeZoneComboBox.setRenderer(new DateSearchFilter.ComboBoxRenderer());\n        jLabel3 = new javax.swing.JLabel();\n        dateFromTextField = new JFormattedTextField(this.dateFormat);\n        jLabel2 = new javax.swing.JLabel();\n        modifiedCheckBox = new javax.swing.JCheckBox();\n        changedCheckBox = new javax.swing.JCheckBox();\n        accessedCheckBox = new javax.swing.JCheckBox();\n        createdCheckBox = new javax.swing.JCheckBox();\n        dateFromButtonCalendar = new org.jbundle.thin.base.screen.jcalendarbutton.JCalendarButton();\n        dateToButtonCalendar = new org.jbundle.thin.base.screen.jcalendarbutton.JCalendarButton();\n\n        cutMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        pasteMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        dateToTextField.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateToTextField.text\")); // NOI18N\n        dateToTextField.addFocusListener(new java.awt.event.FocusAdapter() {\n            public void focusLost(java.awt.event.FocusEvent evt) {\n                dateToTextFieldFocusLost(evt);\n            }\n        });\n\n        jLabel1.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel1.text\")); // NOI18N\n\n        jLabel4.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel4.text\")); // NOI18N\n\n        dateCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateCheckBox.text\")); // NOI18N\n\n        jLabel3.setFont(new java.awt.Font(\"Tahoma\", 0, 10)); // NOI18N\n        jLabel3.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel3.text\")); // NOI18N\n\n        dateFromTextField.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateFromTextField.text\")); // NOI18N\n        dateFromTextField.addFocusListener(new java.awt.event.FocusAdapter() {\n            public void focusLost(java.awt.event.FocusEvent evt) {\n                dateFromTextFieldFocusLost(evt);\n            }\n        });\n\n        jLabel2.setFont(new java.awt.Font(\"Tahoma\", 0, 10)); // NOI18N\n        jLabel2.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.jLabel2.text\")); // NOI18N\n\n        modifiedCheckBox.setSelected(true);\n        modifiedCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.modifiedCheckBox.text\")); // NOI18N\n\n        changedCheckBox.setSelected(true);\n        changedCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.changedCheckBox.text\")); // NOI18N\n\n        accessedCheckBox.setSelected(true);\n        accessedCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.accessedCheckBox.text\")); // NOI18N\n\n        createdCheckBox.setSelected(true);\n        createdCheckBox.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.createdCheckBox.text\")); // NOI18N\n\n        dateFromButtonCalendar.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateFromButtonCalendar.text\")); // NOI18N\n        dateFromButtonCalendar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                dateFromPopupChanged(evt);\n            }\n        });\n\n        dateToButtonCalendar.setText(org.openide.util.NbBundle.getMessage(DateSearchPanel.class, \"DateSearchPanel.dateToButtonCalendar.text\")); // NOI18N\n        dateToButtonCalendar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                dateToPopupChanged(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(dateCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(dateFromTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, 0)\n                        .addComponent(dateFromButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(jLabel1)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(dateToTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, 0)\n                        .addComponent(dateToButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jLabel2)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(jLabel3)))\n                .addContainerGap(26, Short.MAX_VALUE))\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addGap(0, 0, Short.MAX_VALUE)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel4)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modifiedCheckBox)\n                        .addGap(6, 6, 6)\n                        .addComponent(accessedCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(createdCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(changedCheckBox)))\n                .addGap(33, 33, 33))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(dateCheckBox)\n                            .addComponent(dateFromTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGap(18, 18, 18))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(dateToButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(jLabel1)\n                                .addComponent(dateToTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(dateFromButtonCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jLabel3)\n                            .addComponent(jLabel2))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jLabel4)\n                    .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(modifiedCheckBox, javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(accessedCheckBox)\n                        .addComponent(createdCheckBox)\n                        .addComponent(changedCheckBox)))\n                .addGap(0, 0, 0))\n        );\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private Collection<FileSearchFilter> getFilters() {\n        Collection<FileSearchFilter> filters = new ArrayList<FileSearchFilter>();\n\n        for (FilterArea fa : this.filterAreas) {\n            filters.addAll(fa.getFilters());\n        }\n\n        return filters;\n    }","id":188,"modified_method":"private Collection<FileSearchFilter> getFilters() {\n        Collection<FileSearchFilter> filters = new ArrayList<>();\n\n        for (FilterArea fa : this.filterAreas) {\n            filters.addAll(fa.getFilters());\n        }\n\n        return filters;\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private Collection<FileSearchFilter> getEnabledFilters() {\n        Collection<FileSearchFilter> enabledFilters = new ArrayList<FileSearchFilter>();\n\n        for (FileSearchFilter f : this.getFilters()) {\n            if (f.isEnabled()) {\n                enabledFilters.add(f);\n            }\n        }\n\n        return enabledFilters;\n    }","id":189,"modified_method":"private Collection<FileSearchFilter> getEnabledFilters() {\n        Collection<FileSearchFilter> enabledFilters = new ArrayList<>();\n\n        for (FileSearchFilter f : this.getFilters()) {\n            if (f.isEnabled()) {\n                enabledFilters.add(f);\n            }\n        }\n\n        return enabledFilters;\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        setPreferredSize(new java.awt.Dimension(300, 450));\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 300, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 376, Short.MAX_VALUE)\n        );\n    }","id":190,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        filterPanel = new javax.swing.JPanel();\n        searchButton = new javax.swing.JButton();\n\n        setPreferredSize(new java.awt.Dimension(300, 300));\n\n        filterPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));\n        filterPanel.setPreferredSize(new java.awt.Dimension(300, 400));\n        filterPanel.setLayout(new javax.swing.BoxLayout(filterPanel, javax.swing.BoxLayout.Y_AXIS));\n\n        searchButton.setText(org.openide.util.NbBundle.getMessage(FileSearchPanel.class, \"FileSearchPanel.searchButton.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(filterPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(searchButton)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(filterPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addGap(0, 0, 0)\n                .addComponent(searchButton)\n                .addContainerGap())\n        );\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     */\n    private void customizeComponents() {\n\n        this.setLayout(new BorderLayout());\n\n        JPanel filterPanel = new JPanel();\n        filterPanel.setLayout(new BoxLayout(filterPanel, BoxLayout.Y_AXIS));\n        filterPanel.setBorder(new EmptyBorder(10, 10, 10, 10));\n\n        this.add(filterPanel, BorderLayout.CENTER);\n\n        JLabel label = new JLabel(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.custComp.label.text\"));\n        label.setAlignmentX(Component.LEFT_ALIGNMENT);\n        label.setBorder(new EmptyBorder(0, 0, 10, 0));\n        filterPanel.add(label);\n\n        // Create and add filter areas\n        this.filterAreas.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.name\"), new NameSearchFilter()));\n\n        List<FileSearchFilter> metadataFilters = new ArrayList<FileSearchFilter>();\n        metadataFilters.add(new SizeSearchFilter());\n        metadataFilters.add(new MimeTypeFilter());\n        metadataFilters.add(new DateSearchFilter());\n        this.filterAreas.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.metadata\"), metadataFilters));\n\n        this.filterAreas.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.knownStatus\"), new KnownStatusSearchFilter()));\n\n        for (FilterArea fa : this.filterAreas) {\n            fa.setMaximumSize(new Dimension(Integer.MAX_VALUE, fa.getMinimumSize().height));\n            fa.setAlignmentX(Component.LEFT_ALIGNMENT);\n            filterPanel.add(fa);\n        }\n\n        // Create and add search button\n        this.searchButton = new JButton(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.searchButton.text\"));\n        this.searchButton.setAlignmentX(Component.LEFT_ALIGNMENT);\n        filterPanel.add(searchButton);\n\n        addListenerToAll(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                search();\n            }\n        });\n    }","id":191,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     */\n    private void customizeComponents() {\n\n        JLabel label = new JLabel(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.custComp.label.text\"));\n        label.setAlignmentX(Component.LEFT_ALIGNMENT);\n        label.setBorder(new EmptyBorder(0, 0, 10, 0));\n        filterPanel.add(label);\n\n        // Create and add filter areas\n        this.filterAreas.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.name\"), new NameSearchFilter()));\n\n        List<FileSearchFilter> metadataFilters = new ArrayList<>();\n        metadataFilters.add(new SizeSearchFilter());\n        metadataFilters.add(new MimeTypeFilter());\n        metadataFilters.add(new DateSearchFilter());\n        this.filterAreas.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.metadata\"), metadataFilters));\n\n        this.filterAreas.add(new FilterArea(NbBundle.getMessage(this.getClass(), \"FileSearchPanel.filterTitle.knownStatus\"), new KnownStatusSearchFilter()));\n\n        for (FilterArea fa : this.filterAreas) {\n            fa.setMaximumSize(new Dimension(Integer.MAX_VALUE, fa.getMinimumSize().height));\n            fa.setAlignmentX(Component.LEFT_ALIGNMENT);\n            filterPanel.add(fa);\n        }\n\n        addListenerToAll(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                search();\n            }\n        });\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        knownCheckBox = new javax.swing.JCheckBox();\n        unknownOptionCheckBox = new javax.swing.JCheckBox();\n        knownOptionCheckBox = new javax.swing.JCheckBox();\n        knownBadOptionCheckBox = new javax.swing.JCheckBox();\n\n        knownCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.knownCheckBox.text\")); // NOI18N\n\n        unknownOptionCheckBox.setSelected(true);\n        unknownOptionCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.unknownOptionCheckBox.text\")); // NOI18N\n\n        knownOptionCheckBox.setSelected(true);\n        knownOptionCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.knownOptionCheckBox.text\")); // NOI18N\n        knownOptionCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                knownOptionCheckBoxActionPerformed(evt);\n            }\n        });\n\n        knownBadOptionCheckBox.setSelected(true);\n        knownBadOptionCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.knownBadOptionCheckBox.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(knownCheckBox)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(21, 21, 21)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(knownBadOptionCheckBox)\n                    .addComponent(unknownOptionCheckBox)\n                    .addComponent(knownOptionCheckBox)))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(knownCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(unknownOptionCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(knownOptionCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(knownBadOptionCheckBox))\n        );\n    }","id":192,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        knownCheckBox = new javax.swing.JCheckBox();\n        unknownOptionCheckBox = new javax.swing.JCheckBox();\n        knownOptionCheckBox = new javax.swing.JCheckBox();\n        knownBadOptionCheckBox = new javax.swing.JCheckBox();\n\n        knownCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.knownCheckBox.text\")); // NOI18N\n\n        unknownOptionCheckBox.setSelected(true);\n        unknownOptionCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.unknownOptionCheckBox.text\")); // NOI18N\n\n        knownOptionCheckBox.setSelected(true);\n        knownOptionCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.knownOptionCheckBox.text\")); // NOI18N\n        knownOptionCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                knownOptionCheckBoxActionPerformed(evt);\n            }\n        });\n\n        knownBadOptionCheckBox.setSelected(true);\n        knownBadOptionCheckBox.setText(org.openide.util.NbBundle.getMessage(KnownStatusSearchPanel.class, \"KnownStatusSearchPanel.knownBadOptionCheckBox.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(knownCheckBox)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(21, 21, 21)\n                        .addComponent(unknownOptionCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(knownOptionCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(knownBadOptionCheckBox)))\n                .addContainerGap(28, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(knownCheckBox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(unknownOptionCheckBox)\n                    .addComponent(knownOptionCheckBox)\n                    .addComponent(knownBadOptionCheckBox)))\n        );\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        jList1 = new javax.swing.JList<String>();\n        jCheckBox1 = new javax.swing.JCheckBox();\n\n        setMinimumSize(new java.awt.Dimension(150, 150));\n        setPreferredSize(new java.awt.Dimension(100, 100));\n\n        jList1.setModel(new javax.swing.AbstractListModel() {\n            String[] strings = getMimeTypeArray();\n            public int getSize() { return strings.length; }\n            public Object getElementAt(int i) { return strings[i]; }\n        });\n        jList1.setMinimumSize(new java.awt.Dimension(0, 200));\n        jScrollPane1.setViewportView(jList1);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jCheckBox1, org.openide.util.NbBundle.getMessage(MimeTypePanel.class, \"MimeTypePanel.jCheckBox1.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 180, Short.MAX_VALUE)\n                .addContainerGap())\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jCheckBox1)\n                .addGap(0, 0, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(jCheckBox1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 164, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n    }","id":193,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        jList1 = new javax.swing.JList<String>();\n        jCheckBox1 = new javax.swing.JCheckBox();\n        jLabel1 = new javax.swing.JLabel();\n\n        setMinimumSize(new java.awt.Dimension(150, 150));\n        setPreferredSize(new java.awt.Dimension(100, 100));\n\n        jList1.setModel(new javax.swing.AbstractListModel() {\n            String[] strings = getMimeTypeArray();\n            public int getSize() { return strings.length; }\n            public Object getElementAt(int i) { return strings[i]; }\n        });\n        jList1.setMinimumSize(new java.awt.Dimension(0, 200));\n        jScrollPane1.setViewportView(jList1);\n\n        org.openide.awt.Mnemonics.setLocalizedText(jCheckBox1, org.openide.util.NbBundle.getMessage(MimeTypePanel.class, \"MimeTypePanel.jCheckBox1.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 0, 10)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(MimeTypePanel.class, \"MimeTypePanel.jLabel1.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jCheckBox1)\n                .addGap(0, 0, Short.MAX_VALUE))\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 246, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, Short.MAX_VALUE)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(jCheckBox1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 106, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel1)\n                .addGap(0, 0, 0))\n        );\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        nameCheckBox = new javax.swing.JCheckBox();\n        searchTextField = new javax.swing.JTextField();\n        noteNameLabel = new javax.swing.JLabel();\n\n        cutMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        pasteMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        nameCheckBox.setFont(nameCheckBox.getFont().deriveFont(nameCheckBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        nameCheckBox.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.nameCheckBox.text\")); // NOI18N\n\n        searchTextField.setFont(searchTextField.getFont().deriveFont(searchTextField.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        searchTextField.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.searchTextField.text\")); // NOI18N\n        searchTextField.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                searchTextFieldMouseClicked(evt);\n            }\n        });\n\n        noteNameLabel.setFont(noteNameLabel.getFont().deriveFont(noteNameLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 10));\n        noteNameLabel.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.noteNameLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(nameCheckBox)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(12, 12, 12)\n                        .addComponent(noteNameLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addContainerGap())\n                    .addGroup(layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(searchTextField))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(nameCheckBox)\n                    .addComponent(searchTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(noteNameLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        );\n    }","id":194,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        rightClickMenu = new javax.swing.JPopupMenu();\n        cutMenuItem = new javax.swing.JMenuItem();\n        copyMenuItem = new javax.swing.JMenuItem();\n        pasteMenuItem = new javax.swing.JMenuItem();\n        selectAllMenuItem = new javax.swing.JMenuItem();\n        nameCheckBox = new javax.swing.JCheckBox();\n        searchTextField = new javax.swing.JTextField();\n        noteNameLabel = new javax.swing.JLabel();\n\n        cutMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.cutMenuItem.text\")); // NOI18N\n        rightClickMenu.add(cutMenuItem);\n\n        copyMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.copyMenuItem.text\")); // NOI18N\n        rightClickMenu.add(copyMenuItem);\n\n        pasteMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.pasteMenuItem.text\")); // NOI18N\n        rightClickMenu.add(pasteMenuItem);\n\n        selectAllMenuItem.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.selectAllMenuItem.text\")); // NOI18N\n        rightClickMenu.add(selectAllMenuItem);\n\n        nameCheckBox.setFont(nameCheckBox.getFont().deriveFont(nameCheckBox.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        nameCheckBox.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.nameCheckBox.text\")); // NOI18N\n\n        searchTextField.setFont(searchTextField.getFont().deriveFont(searchTextField.getFont().getStyle() & ~java.awt.Font.BOLD, 11));\n        searchTextField.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.searchTextField.text\")); // NOI18N\n        searchTextField.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                searchTextFieldMouseClicked(evt);\n            }\n        });\n\n        noteNameLabel.setFont(noteNameLabel.getFont().deriveFont(noteNameLabel.getFont().getStyle() & ~java.awt.Font.BOLD, 10));\n        noteNameLabel.setText(org.openide.util.NbBundle.getMessage(NameSearchPanel.class, \"NameSearchPanel.noteNameLabel.text\")); // NOI18N\n        noteNameLabel.setMaximumSize(new java.awt.Dimension(250, 30));\n        noteNameLabel.setMinimumSize(new java.awt.Dimension(250, 30));\n        noteNameLabel.setPreferredSize(new java.awt.Dimension(250, 30));\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(0, 0, 0)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(noteNameLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 296, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(nameCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(searchTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 247, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addGap(0, 0, 0))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(nameCheckBox)\n                    .addComponent(searchTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(noteNameLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(0, 0, Short.MAX_VALUE))\n        );\n    }","commit_id":"49ee29ffcaf4c090ff4e856d427049c2e953c0d4","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Creates a file signature consisting of an ASCII string at a\n         * specific offset within a file.\n         *\n         * @param signatureString The ASCII string\n         * @param offset         The offset of the signature bytes.\n         * @param trailing       Determines whether this signature is trailing.\n         */\n        Signature(String signatureString, long offset, boolean trailing) {\n            this.signatureBytes = signatureString.getBytes(StandardCharsets.US_ASCII);\n            this.offset = offset;\n            this.type = Type.ASCII;\n            this.trailing = trailing;\n        }","id":195,"modified_method":"/**\n         * Creates a file signature consisting of an ASCII string at a\n         * specific offset within a file.\n         *\n         * @param signatureString The ASCII string\n         * @param offset         The offset of the signature bytes.\n         * @param isRelativeToStart     Determines whether this signature is relative to start.\n         */\n        Signature(String signatureString, long offset, boolean isRelativeToStart) {\n            this.signatureBytes = signatureString.getBytes(StandardCharsets.US_ASCII);\n            this.offset = offset;\n            this.type = Type.ASCII;\n            this.isRelativeToStart = isRelativeToStart;\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the signature associated with this file type.\n     *\n     * @return The signature.\n     */\n    Signature getSignature() {\n        return new Signature(signature.getSignatureBytes(), signature.getOffset(), signature.getType(), signature.isTrailing());\n    }","id":196,"modified_method":"/**\n     * Gets the signature associated with this file type.\n     *\n     * @return The signature.\n     */\n    Signature getSignature() {\n        return new Signature(signature.getSignatureBytes(), signature.getOffset(), signature.getType(), signature.isRelativeToStart());\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.\n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         * @param type           The type of data in the byte array. Impacts\n         *                       how it is displayed to the user in the UI. \n         */\n        Signature(final byte[] signatureBytes, long offset, Type type) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = type;\n            this.trailing = false;\n        }","id":197,"modified_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.\n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         * @param type           The type of data in the byte array. Impacts\n         *                       how it is displayed to the user in the UI. \n         */\n        Signature(final byte[] signatureBytes, long offset, Type type) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = type;\n            this.isRelativeToStart = true;\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Creates a file signature consisting of an ASCII string at a\n         * specific offset within a file.\n         *\n         * @param signatureString The ASCII string\n         * @param offset         The offset of the signature bytes.\n         */\n        Signature(String signatureString, long offset) {\n            this.signatureBytes = signatureString.getBytes(StandardCharsets.US_ASCII);\n            this.offset = offset;\n            this.type = Type.ASCII;\n            this.trailing = false;\n        }","id":198,"modified_method":"/**\n         * Creates a file signature consisting of an ASCII string at a\n         * specific offset within a file.\n         *\n         * @param signatureString The ASCII string\n         * @param offset         The offset of the signature bytes.\n         */\n        Signature(String signatureString, long offset) {\n            this.signatureBytes = signatureString.getBytes(StandardCharsets.US_ASCII);\n            this.offset = offset;\n            this.type = Type.ASCII;\n            this.isRelativeToStart = true;\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.  If bytes correspond to an ASCII\n         * string, use one of the other constructors so that the string is \n         * displayed to the user instead of the raw bytes. \n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         * @param trailing       Determines whether this signature is trailing.\n         */\n        Signature(final byte[] signatureBytes, long offset, boolean trailing) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = Type.RAW;\n            this.trailing = trailing;\n        }","id":199,"modified_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.  If bytes correspond to an ASCII\n         * string, use one of the other constructors so that the string is \n         * displayed to the user instead of the raw bytes. \n         *\n         * @param signatureBytes        The signature bytes.\n         * @param offset                The offset of the signature bytes.\n         * @param isRelativeToStart     Determines whether this signature is relative to start.\n         */\n        Signature(final byte[] signatureBytes, long offset, boolean isRelativeToStart) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = Type.RAW;\n            this.isRelativeToStart = isRelativeToStart;\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Determines whether or not the signature is contained within a given\n         * file.\n         *\n         * @param file The file to test\n         *\n         * @return True or false.\n         */\n        boolean containedIn(final AbstractFile file) {\n            long actualOffset = offset;\n            if(trailing)\n                actualOffset = file.getSize() - signatureBytes.length - offset;\n            if (file.getSize() < (actualOffset + signatureBytes.length)) {\n                return false; /// too small, can't contain this signature\n            }\n            try {\n                byte[] buffer = new byte[signatureBytes.length];\n                int bytesRead = file.read(buffer, actualOffset, signatureBytes.length);\n                return ((bytesRead == signatureBytes.length) && (Arrays.equals(buffer, signatureBytes)));\n            } catch (TskCoreException ex) {\n                /**\n                 * This exception is swallowed rather than propagated because\n                 * files in images are not always consistent with their file\n                 * system meta data making for read errors.\n                 */\n                Signature.logger.log(Level.WARNING, \"Error reading from file with objId = \" + file.getId(), ex); //NON-NLS\n                return false;\n            }\n        }","id":200,"modified_method":"/**\n         * Determines whether or not the signature is contained within a given\n         * file.\n         *\n         * @param file The file to test\n         *\n         * @return True or false.\n         */\n        boolean containedIn(final AbstractFile file) {\n            long actualOffset = offset;\n            if(!isRelativeToStart)\n                actualOffset = file.getSize() - offset;\n            if (file.getSize() < (actualOffset + signatureBytes.length)) {\n                return false; /// too small, can't contain this signature\n            }\n            try {\n                byte[] buffer = new byte[signatureBytes.length];\n                int bytesRead = file.read(buffer, actualOffset, signatureBytes.length);\n                return ((bytesRead == signatureBytes.length) && (Arrays.equals(buffer, signatureBytes)));\n            } catch (TskCoreException ex) {\n                /**\n                 * This exception is swallowed rather than propagated because\n                 * files in images are not always consistent with their file\n                 * system meta data making for read errors.\n                 */\n                Signature.logger.log(Level.WARNING, \"Error reading from file with objId = \" + file.getId(), ex); //NON-NLS\n                return false;\n            }\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.\n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         * @param type           The type of data in the byte array. Impacts\n         *                       how it is displayed to the user in the UI.\n         * @param trailing       Determines whether this signature is trailing.\n         */\n        Signature(final byte[] signatureBytes, long offset, Type type, boolean trailing) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = type;\n            this.trailing = trailing;\n        }","id":201,"modified_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.\n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         * @param type           The type of data in the byte array. Impacts\n         *                       how it is displayed to the user in the UI.\n         * @param isRelativeToStart     Determines whether this signature is relative to start.\n         */\n        Signature(final byte[] signatureBytes, long offset, Type type, boolean isRelativeToStart) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = type;\n            this.isRelativeToStart = isRelativeToStart;\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Creates a representation of a file type characterized by a file\n     * signature.\n     *\n     * @param mimeType     The mime type to associate with this file type.\n     * @param signature    The signature that characterizes this file type.\n     * @param filesSetName The name of an interesting files set that includes\n     *                     files of this type, may be the empty string.\n     * @param alert        Whether the user wishes to be alerted when a file\n     *                     matching this type is encountered.\n     */\n    FileType(String mimeType, final Signature signature, String filesSetName, boolean alert) {\n        this.mimeType = mimeType;\n        this.signature = new Signature(signature.getSignatureBytes(), signature.getOffset(), signature.getType(), signature.isTrailing());\n        this.interestingFilesSetName = filesSetName;\n        this.alert = alert;\n    }","id":202,"modified_method":"/**\n     * Creates a representation of a file type characterized by a file\n     * signature.\n     *\n     * @param mimeType     The mime type to associate with this file type.\n     * @param signature    The signature that characterizes this file type.\n     * @param filesSetName The name of an interesting files set that includes\n     *                     files of this type, may be the empty string.\n     * @param alert        Whether the user wishes to be alerted when a file\n     *                     matching this type is encountered.\n     */\n    FileType(String mimeType, final Signature signature, String filesSetName, boolean alert) {\n        this.mimeType = mimeType;\n        this.signature = new Signature(signature.getSignatureBytes(), signature.getOffset(), signature.getType(), signature.isRelativeToStart());\n        this.interestingFilesSetName = filesSetName;\n        this.alert = alert;\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.  If bytes correspond to an ASCII\n         * string, use one of the other constructors so that the string is \n         * displayed to the user instead of the raw bytes. \n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         */\n        Signature(final byte[] signatureBytes, long offset) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = Type.RAW;\n            this.trailing = false;\n        }","id":203,"modified_method":"/**\n         * Creates a file signature consisting of a sequence of bytes at a\n         * specific offset within a file.  If bytes correspond to an ASCII\n         * string, use one of the other constructors so that the string is \n         * displayed to the user instead of the raw bytes. \n         *\n         * @param signatureBytes The signature bytes.\n         * @param offset         The offset of the signature bytes.\n         */\n        Signature(final byte[] signatureBytes, long offset) {\n            this.signatureBytes = Arrays.copyOf(signatureBytes, signatureBytes.length);\n            this.offset = offset;\n            this.type = Type.RAW;\n            this.isRelativeToStart = true;\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Does child component initialization in addition to that done by the\n     * Matisse generated code.\n     */\n    private void customizeComponents() {\n        setFileTypesListModel();\n        setSignatureTypeComboBoxModel();\n        clearTypeDetailsComponents();\n        addTypeListSelectionListener();\n        addTextFieldListeners();\n    }","id":204,"modified_method":"/**\n     * Does child component initialization in addition to that done by the\n     * Matisse generated code.\n     */\n    private void customizeComponents() {\n        setFileTypesListModel();\n        setSignatureTypeComboBoxModel();\n        setOffsetRealtiveToComboBoxModel();\n        clearTypeDetailsComponents();\n        addTypeListSelectionListener();\n        addTextFieldListeners();\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Clears all of the components in the individual type details portion of\n     * the panel.\n     */\n    private void clearTypeDetailsComponents() {\n        typesList.clearSelection();\n        mimeTypeTextField.setText(\"\"); //NON-NLS\n        mimeTypeTextField.setEditable(true);\n        signatureTypeComboBox.setSelectedItem(FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n        hexPrefixLabel.setVisible(true);\n        signatureTextField.setText(\"0000\"); //NON-NLS\n        isTrailingCheckBox.setSelected(false);\n        offsetTextField.setText(\"\"); //NON-NLS\n        postHitCheckBox.setSelected(false);\n        filesSetNameTextField.setText(\"\"); //NON-NLS\n        filesSetNameTextField.setEnabled(false);\n        enableButtons();\n    }","id":205,"modified_method":"/**\n     * Clears all of the components in the individual type details portion of\n     * the panel.\n     */\n    private void clearTypeDetailsComponents() {\n        typesList.clearSelection();\n        mimeTypeTextField.setText(\"\"); //NON-NLS\n        mimeTypeTextField.setEditable(true);\n        signatureTypeComboBox.setSelectedItem(FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n        hexPrefixLabel.setVisible(true);\n        signatureTextField.setText(\"0000\"); //NON-NLS\n        offsetRelativeToComboBox.setSelectedItem(FileTypeIdGlobalSettingsPanel.START_OFFSET_RELATIVE_COMBO_BOX_ITEM);\n        offsetTextField.setText(\"\"); //NON-NLS\n        postHitCheckBox.setSelected(false);\n        filesSetNameTextField.setText(\"\"); //NON-NLS\n        filesSetNameTextField.setEnabled(false);\n        enableButtons();\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void saveTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveTypeButtonActionPerformed\n        /**\n         * Get the MIME type.\n         */\n        String typeName = mimeTypeTextField.getText();\n        if (typeName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the signature type.\n         */\n        FileType.Signature.Type sigType = signatureTypeComboBox.getSelectedItem() == FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM ? FileType.Signature.Type.RAW : FileType.Signature.Type.ASCII;\n\n        /**\n         * Get the signature bytes.\n         */\n        String sigString = signatureTextField.getText();\n        if (sigString.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        byte[] signatureBytes;\n        if (FileType.Signature.Type.RAW == sigType) {\n            try {\n                signatureBytes = DatatypeConverter.parseHexBinary(sigString);\n            } catch (IllegalArgumentException ex) {\n                JOptionPane.showMessageDialog(null,\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidRawSignatureBytes.message\"),\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignatureBytes.title\"),\n                        JOptionPane.ERROR_MESSAGE);\n                return;\n            }\n        } else {\n            signatureBytes = sigString.getBytes(Charset.forName(\"UTF-8\"));\n        }\n\n        /**\n         * Get the offset.\n         */\n        long offset;\n        try {\n                offset = Long.parseUnsignedLong(offsetTextField.getText());\n        } catch (NumberFormatException ex) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the interesting files set details.\n         */\n        String filesSetName = \"\";\n        if (postHitCheckBox.isSelected()) {\n            filesSetName = filesSetNameTextField.getText();\n        }\n        if (postHitCheckBox.isSelected() && filesSetName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Put it all together and reset the file types list component.\n         */\n        boolean isTrailing = isTrailingCheckBox.isSelected();\n        FileType.Signature signature = new FileType.Signature(signatureBytes, offset, sigType, isTrailingCheckBox.isSelected());\n        FileType fileType = new FileType(typeName, signature, filesSetName, postHitCheckBox.isSelected());\n        FileType selected = typesList.getSelectedValue();\n        if (selected != null) {\n            fileTypes.remove(selected);\n        }\n        fileTypes.add(fileType);\n        updateFileTypesListModel();\n        typesList.setSelectedValue(fileType.getMimeType(), true);\n    }","id":206,"modified_method":"private void saveTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveTypeButtonActionPerformed\n        /**\n         * Get the MIME type.\n         */\n        String typeName = mimeTypeTextField.getText();\n        if (typeName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidMIMEType.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the signature type.\n         */\n        FileType.Signature.Type sigType = signatureTypeComboBox.getSelectedItem() == FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM ? FileType.Signature.Type.RAW : FileType.Signature.Type.ASCII;\n\n        /**\n         * Get the signature bytes.\n         */\n        String sigString = signatureTextField.getText();\n        if (sigString.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignature.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        byte[] signatureBytes;\n        if (FileType.Signature.Type.RAW == sigType) {\n            try {\n                signatureBytes = DatatypeConverter.parseHexBinary(sigString);\n            } catch (IllegalArgumentException ex) {\n                JOptionPane.showMessageDialog(null,\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidRawSignatureBytes.message\"),\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidSignatureBytes.title\"),\n                        JOptionPane.ERROR_MESSAGE);\n                return;\n            }\n        } else {\n            signatureBytes = sigString.getBytes(Charset.forName(\"UTF-8\"));\n        }\n\n        /**\n         * Get the offset.\n         */\n        long offset;\n        boolean isRelativeToStart = offsetRelativeToComboBox.getSelectedItem() == FileTypeIdGlobalSettingsPanel.START_OFFSET_RELATIVE_COMBO_BOX_ITEM;\n        try {\n                offset = Long.parseUnsignedLong(offsetTextField.getText());\n                if(!isRelativeToStart && sigString.length() > offset) {\n                    JOptionPane.showMessageDialog(null,\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.length\"),\n                        NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"),\n                        JOptionPane.ERROR_MESSAGE);\n                    return;\n                }\n        } catch (NumberFormatException ex) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidOffset.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Get the interesting files set details.\n         */\n        String filesSetName = \"\";\n        if (postHitCheckBox.isSelected()) {\n            filesSetName = filesSetNameTextField.getText();\n        }\n        if (postHitCheckBox.isSelected() && filesSetName.isEmpty()) {\n            JOptionPane.showMessageDialog(null,\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.message\"),\n                    NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.invalidInterestingFilesSetName.title\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        /**\n         * Put it all together and reset the file types list component.\n         */\n        FileType.Signature signature = new FileType.Signature(signatureBytes, offset, sigType, isRelativeToStart);\n        FileType fileType = new FileType(typeName, signature, filesSetName, postHitCheckBox.isSelected());\n        FileType selected = typesList.getSelectedValue();\n        if (selected != null) {\n            fileTypes.remove(selected);\n        }\n        fileTypes.add(fileType);\n        updateFileTypesListModel();\n        typesList.setSelectedValue(fileType.getMimeType(), true);\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Populates all of the components in the file type details portion of the\n     * panel based on the current selection in the file types list.\n     */\n    private void populateTypeDetailsComponents() {\n        FileType fileType = typesList.getSelectedValue();\n        if (null != fileType) {\n            mimeTypeTextField.setText(fileType.getMimeType());\n            mimeTypeTextField.setEditable(false);\n            Signature signature = fileType.getSignature();\n            FileType.Signature.Type sigType = signature.getType();\n            signatureTypeComboBox.setSelectedItem(sigType == FileType.Signature.Type.RAW ? FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.ASCII_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n            String signatureBytes;\n            if (Signature.Type.RAW == signature.getType()) {\n                signatureBytes = DatatypeConverter.printHexBinary(signature.getSignatureBytes());\n            } else {\n                try {\n                    signatureBytes = new String(signature.getSignatureBytes(), \"UTF-8\");\n                } catch (UnsupportedEncodingException ex) {\n                    JOptionPane.showMessageDialog(null,\n                            ex.getLocalizedMessage(),\n                            NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.storeFailed.title\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    signatureBytes = \"\";\n                }\n            }\n            signatureTextField.setText(signatureBytes);\n            isTrailingCheckBox.setSelected(signature.isTrailing());\n            offsetTextField.setText(Long.toString(signature.getOffset()));\n            postHitCheckBox.setSelected(fileType.alertOnMatch());\n            filesSetNameTextField.setEnabled(postHitCheckBox.isSelected());\n            filesSetNameTextField.setText(fileType.getFilesSetName());\n        }\n        enableButtons();\n    }","id":207,"modified_method":"/**\n     * Populates all of the components in the file type details portion of the\n     * panel based on the current selection in the file types list.\n     */\n    private void populateTypeDetailsComponents() {\n        FileType fileType = typesList.getSelectedValue();\n        if (null != fileType) {\n            mimeTypeTextField.setText(fileType.getMimeType());\n            mimeTypeTextField.setEditable(false);\n            Signature signature = fileType.getSignature();\n            FileType.Signature.Type sigType = signature.getType();\n            signatureTypeComboBox.setSelectedItem(sigType == FileType.Signature.Type.RAW ? FileTypeIdGlobalSettingsPanel.RAW_SIGNATURE_TYPE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.ASCII_SIGNATURE_TYPE_COMBO_BOX_ITEM);\n            String signatureBytes;\n            if (Signature.Type.RAW == signature.getType()) {\n                signatureBytes = DatatypeConverter.printHexBinary(signature.getSignatureBytes());\n            } else {\n                try {\n                    signatureBytes = new String(signature.getSignatureBytes(), \"UTF-8\");\n                } catch (UnsupportedEncodingException ex) {\n                    JOptionPane.showMessageDialog(null,\n                            ex.getLocalizedMessage(),\n                            NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.JOptionPane.storeFailed.title\"),\n                            JOptionPane.ERROR_MESSAGE);\n                    signatureBytes = \"\";\n                }\n            }\n            signatureTextField.setText(signatureBytes);\n            offsetRelativeToComboBox.setSelectedItem(signature.isRelativeToStart() ? FileTypeIdGlobalSettingsPanel.START_OFFSET_RELATIVE_COMBO_BOX_ITEM : FileTypeIdGlobalSettingsPanel.END_OFFSET_RELATIVE_COMBO_BOX_ITEM);\n            offsetTextField.setText(Long.toString(signature.getOffset()));\n            postHitCheckBox.setSelected(fileType.alertOnMatch());\n            filesSetNameTextField.setEnabled(postHitCheckBox.isSelected());\n            filesSetNameTextField.setText(fileType.getFilesSetName());\n        }\n        enableButtons();\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        typesScrollPane = new javax.swing.JScrollPane();\n        typesList = new javax.swing.JList<FileType>();\n        separator = new javax.swing.JSeparator();\n        mimeTypeLabel = new javax.swing.JLabel();\n        mimeTypeTextField = new javax.swing.JTextField();\n        signatureTypeLabel = new javax.swing.JLabel();\n        signatureTextField = new javax.swing.JTextField();\n        offsetLabel = new javax.swing.JLabel();\n        offsetTextField = new javax.swing.JTextField();\n        newTypeButton = new javax.swing.JButton();\n        deleteTypeButton = new javax.swing.JButton();\n        saveTypeButton = new javax.swing.JButton();\n        hexPrefixLabel = new javax.swing.JLabel();\n        signatureTypeComboBox = new javax.swing.JComboBox<String>();\n        signatureLabel = new javax.swing.JLabel();\n        postHitCheckBox = new javax.swing.JCheckBox();\n        filesSetNameLabel = new javax.swing.JLabel();\n        filesSetNameTextField = new javax.swing.JTextField();\n        ingestRunningWarningLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        isTrailingCheckBox = new javax.swing.JCheckBox();\n\n        setMaximumSize(new java.awt.Dimension(500, 300));\n        setPreferredSize(new java.awt.Dimension(500, 300));\n\n        typesList.setMaximumSize(new java.awt.Dimension(150, 0));\n        typesList.setMinimumSize(new java.awt.Dimension(150, 0));\n        typesScrollPane.setViewportView(typesList);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeLabel.text\")); // NOI18N\n\n        mimeTypeTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTypeLabel.text\")); // NOI18N\n\n        signatureTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTextField.text\")); // NOI18N\n        signatureTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetLabel.text\")); // NOI18N\n\n        offsetTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(newTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.newTypeButton.text\")); // NOI18N\n        newTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deleteTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.deleteTypeButton.text\")); // NOI18N\n        deleteTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.saveTypeButton.text\")); // NOI18N\n        saveTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hexPrefixLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.hexPrefixLabel.text\")); // NOI18N\n\n        signatureTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(postHitCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.postHitCheckBox.text\")); // NOI18N\n        postHitCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                postHitCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(filesSetNameLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameLabel.text\")); // NOI18N\n\n        filesSetNameTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameTextField.text\")); // NOI18N\n\n        ingestRunningWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/modules/filetypeid/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestRunningWarningLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.ingestRunningWarningLabel.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel1.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel3.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(isTrailingCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.isTrailingCheckBox.text\")); // NOI18N\n        isTrailingCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                isTrailingCheckBoxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(ingestRunningWarningLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGap(30, 30, 30))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel2)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(10, 10, 10)\n                                        .addComponent(deleteTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addGap(18, 18, 18)\n                                        .addComponent(newTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                    .addComponent(typesScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 7, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(mimeTypeLabel)\n                                            .addGap(30, 30, 30)\n                                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addComponent(postHitCheckBox)\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(signatureTypeLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(signatureLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(hexPrefixLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                            .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addComponent(offsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                            .addGap(21, 21, 21)\n                                            .addComponent(filesSetNameLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                        .addComponent(saveTypeButton)\n                                        .addGap(8, 8, 8))\n                                    .addComponent(isTrailingCheckBox)))\n                            .addComponent(jLabel1)\n                            .addComponent(jLabel3))\n                        .addContainerGap(50, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel2)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(typesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 173, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(deleteTypeButton)\n                                    .addComponent(newTypeButton)))\n                            .addComponent(separator))\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestRunningWarningLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(mimeTypeLabel)\n                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(signatureTypeLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(hexPrefixLabel)\n                                .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(signatureLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(isTrailingCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(offsetLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(postHitCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(filesSetNameLabel)\n                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(saveTypeButton)\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n\n        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteTypeButton, newTypeButton, saveTypeButton});\n\n    }","id":208,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        typesScrollPane = new javax.swing.JScrollPane();\n        typesList = new javax.swing.JList<FileType>();\n        separator = new javax.swing.JSeparator();\n        mimeTypeLabel = new javax.swing.JLabel();\n        mimeTypeTextField = new javax.swing.JTextField();\n        signatureTypeLabel = new javax.swing.JLabel();\n        signatureTextField = new javax.swing.JTextField();\n        offsetLabel = new javax.swing.JLabel();\n        offsetTextField = new javax.swing.JTextField();\n        newTypeButton = new javax.swing.JButton();\n        deleteTypeButton = new javax.swing.JButton();\n        saveTypeButton = new javax.swing.JButton();\n        hexPrefixLabel = new javax.swing.JLabel();\n        signatureTypeComboBox = new javax.swing.JComboBox<String>();\n        signatureLabel = new javax.swing.JLabel();\n        postHitCheckBox = new javax.swing.JCheckBox();\n        filesSetNameLabel = new javax.swing.JLabel();\n        filesSetNameTextField = new javax.swing.JTextField();\n        ingestRunningWarningLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        jLabel3 = new javax.swing.JLabel();\n        offsetRelativeToComboBox = new javax.swing.JComboBox<String>();\n        offsetRelativeToLabel = new javax.swing.JLabel();\n\n        setMaximumSize(new java.awt.Dimension(500, 300));\n        setPreferredSize(new java.awt.Dimension(500, 300));\n\n        typesList.setMaximumSize(new java.awt.Dimension(150, 0));\n        typesList.setMinimumSize(new java.awt.Dimension(150, 0));\n        typesScrollPane.setViewportView(typesList);\n\n        separator.setOrientation(javax.swing.SwingConstants.VERTICAL);\n\n        org.openide.awt.Mnemonics.setLocalizedText(mimeTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeLabel.text\")); // NOI18N\n\n        mimeTypeTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.mimeTypeTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureTypeLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTypeLabel.text\")); // NOI18N\n\n        signatureTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureTextField.text\")); // NOI18N\n        signatureTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTextFieldActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetLabel.text\")); // NOI18N\n\n        offsetTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(newTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.newTypeButton.text\")); // NOI18N\n        newTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(deleteTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.deleteTypeButton.text\")); // NOI18N\n        deleteTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                deleteTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveTypeButton, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.saveTypeButton.text\")); // NOI18N\n        saveTypeButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveTypeButtonActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(hexPrefixLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.hexPrefixLabel.text\")); // NOI18N\n\n        signatureTypeComboBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                signatureTypeComboBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(signatureLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.signatureLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(postHitCheckBox, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.postHitCheckBox.text\")); // NOI18N\n        postHitCheckBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                postHitCheckBoxActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(filesSetNameLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameLabel.text\")); // NOI18N\n\n        filesSetNameTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.filesSetNameTextField.text\")); // NOI18N\n\n        ingestRunningWarningLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/org/sleuthkit/autopsy/modules/filetypeid/warning16.png\"))); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(ingestRunningWarningLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.ingestRunningWarningLabel.text\")); // NOI18N\n\n        jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel1.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.jLabel3.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(offsetRelativeToLabel, org.openide.util.NbBundle.getMessage(FileTypeIdGlobalSettingsPanel.class, \"FileTypeIdGlobalSettingsPanel.offsetRelativeToLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(ingestRunningWarningLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addGap(30, 30, 30))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(jLabel2)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(10, 10, 10)\n                                        .addComponent(deleteTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                        .addGap(18, 18, 18)\n                                        .addComponent(newTypeButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                    .addComponent(typesScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(separator, javax.swing.GroupLayout.PREFERRED_SIZE, 7, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                            .addGap(21, 21, 21)\n                                            .addComponent(filesSetNameLabel)\n                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                        .addGroup(layout.createSequentialGroup()\n                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                                .addGroup(layout.createSequentialGroup()\n                                                    .addComponent(mimeTypeLabel)\n                                                    .addGap(30, 30, 30)\n                                                    .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                                .addComponent(postHitCheckBox)\n                                                .addGroup(layout.createSequentialGroup()\n                                                    .addComponent(signatureTypeLabel)\n                                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                                    .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(layout.createSequentialGroup()\n                                                    .addComponent(signatureLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                                    .addComponent(hexPrefixLabel)\n                                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                                    .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE))\n                                                .addGroup(layout.createSequentialGroup()\n                                                    .addComponent(offsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                                    .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                                            .addGap(6, 6, 6)))\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                        .addComponent(saveTypeButton)\n                                        .addGap(8, 8, 8))\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addComponent(offsetRelativeToLabel)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                        .addComponent(offsetRelativeToComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))\n                            .addComponent(jLabel1)\n                            .addComponent(jLabel3))\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel3)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jLabel2)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(typesScrollPane)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                    .addComponent(deleteTypeButton)\n                                    .addComponent(newTypeButton)))\n                            .addComponent(separator))\n                        .addGap(18, 18, 18)\n                        .addComponent(ingestRunningWarningLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(mimeTypeLabel)\n                            .addComponent(mimeTypeTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(signatureTypeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(signatureTypeLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                                .addComponent(hexPrefixLabel)\n                                .addComponent(signatureTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                            .addComponent(signatureLabel))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(offsetLabel)\n                            .addComponent(offsetTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(offsetRelativeToComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addComponent(offsetRelativeToLabel))\n                        .addGap(16, 16, 16)\n                        .addComponent(postHitCheckBox)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(filesSetNameLabel)\n                            .addComponent(filesSetNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(saveTypeButton)\n                        .addGap(0, 0, Short.MAX_VALUE))))\n        );\n\n        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {deleteTypeButton, newTypeButton, saveTypeButton});\n\n    }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Gets the signature from a file type XML element.\n         *\n         * @param fileTypeElem The XML element.\n         *\n         * @return The signature.\n         */\n        private static Signature parseSignature(Element fileTypeElem) throws IllegalArgumentException, NumberFormatException {\n            NodeList signatureElems = fileTypeElem.getElementsByTagName(SIGNATURE_TAG_NAME);\n            Element signatureElem = (Element) signatureElems.item(0);\n\n            String sigTypeAttribute = signatureElem.getAttribute(SIGNATURE_TYPE_ATTRIBUTE);\n            Signature.Type signatureType = Signature.Type.valueOf(sigTypeAttribute);\n\n            String sigBytesString = getChildElementTextContent(signatureElem, BYTES_TAG_NAME);\n            byte[] signatureBytes = DatatypeConverter.parseHexBinary(sigBytesString);\n\n            String offsetString = getChildElementTextContent(signatureElem, OFFSET_TAG_NAME);\n            long offset = DatatypeConverter.parseLong(offsetString);\n            \n            String trailingString = getChildElementTextContent(signatureElem, TRAILING_TAG_NAME);\n            if(trailingString == null)\n                return new Signature(signatureBytes, offset, signatureType);\n            \n            boolean trailing = DatatypeConverter.parseBoolean(trailingString);\n\n            return new Signature(signatureBytes, offset, signatureType, trailing);\n        }","id":209,"modified_method":"/**\n         * Gets the signature from a file type XML element.\n         *\n         * @param fileTypeElem The XML element.\n         *\n         * @return The signature.\n         */\n        private static Signature parseSignature(Element fileTypeElem) throws IllegalArgumentException, NumberFormatException {\n            NodeList signatureElems = fileTypeElem.getElementsByTagName(SIGNATURE_TAG_NAME);\n            Element signatureElem = (Element) signatureElems.item(0);\n\n            String sigTypeAttribute = signatureElem.getAttribute(SIGNATURE_TYPE_ATTRIBUTE);\n            Signature.Type signatureType = Signature.Type.valueOf(sigTypeAttribute);\n\n            String sigBytesString = getChildElementTextContent(signatureElem, BYTES_TAG_NAME);\n            byte[] signatureBytes = DatatypeConverter.parseHexBinary(sigBytesString);\n\n            Element offsetElem = (Element) signatureElem.getElementsByTagName(OFFSET_TAG_NAME).item(0);\n            String offsetString = offsetElem.getTextContent();\n            long offset = DatatypeConverter.parseLong(offsetString);\n            \n            String relativeString = offsetElem.getAttribute(RELATIVE_ATTRIBUTE);\n            if(relativeString == null)\n                return new Signature(signatureBytes, offset, signatureType);\n            \n            boolean isRelative = DatatypeConverter.parseBoolean(relativeString);\n\n            return new Signature(signatureBytes, offset, signatureType, isRelative);\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Add a signature child element to a file type XML element.\n         *\n         * @param fileType The file type to use as a content source.\n         * @param fileTypeElem The parent file type element.\n         * @param doc The WC3 DOM object to use to create the XML.\n         */\n        private static void addSignatureElement(FileType fileType, Element fileTypeElem, Document doc) {\n            Signature signature = fileType.getSignature();\n            Element signatureElem = doc.createElement(SIGNATURE_TAG_NAME);\n\n            Element bytesElem = doc.createElement(BYTES_TAG_NAME);\n            bytesElem.setTextContent(DatatypeConverter.printHexBinary(signature.getSignatureBytes()));\n            signatureElem.appendChild(bytesElem);\n\n            Element offsetElem = doc.createElement(OFFSET_TAG_NAME);\n            offsetElem.setTextContent(DatatypeConverter.printLong(signature.getOffset()));\n            signatureElem.appendChild(offsetElem);\n            \n            Element trailingElem = doc.createElement(TRAILING_TAG_NAME);\n            trailingElem.setTextContent(DatatypeConverter.printBoolean(signature.isTrailing()));\n            signatureElem.appendChild(trailingElem);\n\n            signatureElem.setAttribute(SIGNATURE_TYPE_ATTRIBUTE, signature.getType().toString());\n            fileTypeElem.appendChild(signatureElem);\n        }","id":210,"modified_method":"/**\n         * Add a signature child element to a file type XML element.\n         *\n         * @param fileType The file type to use as a content source.\n         * @param fileTypeElem The parent file type element.\n         * @param doc The WC3 DOM object to use to create the XML.\n         */\n        private static void addSignatureElement(FileType fileType, Element fileTypeElem, Document doc) {\n            Signature signature = fileType.getSignature();\n            Element signatureElem = doc.createElement(SIGNATURE_TAG_NAME);\n\n            Element bytesElem = doc.createElement(BYTES_TAG_NAME);\n            bytesElem.setTextContent(DatatypeConverter.printHexBinary(signature.getSignatureBytes()));\n            signatureElem.appendChild(bytesElem);\n\n            Element offsetElem = doc.createElement(OFFSET_TAG_NAME);\n            offsetElem.setTextContent(DatatypeConverter.printLong(signature.getOffset()));\n            offsetElem.setAttribute(RELATIVE_ATTRIBUTE, String.valueOf(signature.isRelativeToStart()));\n            signatureElem.appendChild(offsetElem);\n\n            signatureElem.setAttribute(SIGNATURE_TYPE_ATTRIBUTE, signature.getType().toString());\n            fileTypeElem.appendChild(signatureElem);\n        }","commit_id":"c4d6c45ed9157c6c7d3dfbf334d0ea964284b34f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Register the transformers for the 1.4.0 version.\n     *\n     * @param subsystem the subsystems registration\n     */\n    protected static void registerTransformers_1_4(final SubsystemRegistration subsystem) {\n        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory\n                .createSubsystemInstance();\n        builder.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.DEFINED,\n                JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID);\n        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 4, 0));\n    }","id":211,"modified_method":"/**\n     * Register the transformers for the 1.3.0 version.\n     *\n     * @param subsystem the subsystems registration\n     */\n    protected static void registerTransformers(final SubsystemRegistration subsystem) {\n        ChainedTransformationDescriptionBuilder chained = ResourceTransformationDescriptionBuilder.Factory.createChainedSubystemInstance(CURRENT_MODEL_VERSION);\n        ModelVersion MODEL_VERSION_EAP64 = ModelVersion.create(1, 4, 0);\n        ModelVersion MODEL_VERSION_EAP63 = ModelVersion.create(1, 3, 0);//also EAP6.2\n\n        ResourceTransformationDescriptionBuilder builder64 = chained.createBuilder(CURRENT_MODEL_VERSION, MODEL_VERSION_EAP64);\n        builder64.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID.getDefaultValue()), JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID)\n                .setValueConverter(new AttributeConverter.DefaultValueAttributeConverter(JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES),JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES);\n\n\n        ResourceTransformationDescriptionBuilder builder63 = chained.createBuilder(MODEL_VERSION_EAP64, MODEL_VERSION_EAP63);\n        builder63.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORTransportConfigDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORASContextDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORSASContextDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .end()\n                .rejectChildResource(IORSettingsDefinition.INSTANCE.getPathElement());\n\n\n        chained.buildAndRegister(subsystem, new ModelVersion[]{\n                MODEL_VERSION_EAP64,\n                MODEL_VERSION_EAP63\n        });\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(JacORBSubsystemResource.INSTANCE);\n        subsystemRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(PARSER);\n\n        if (context.isRegisterTransformers()) {\n            // Register the model transformers\n            registerTransformers_1_3(subsystem);\n            registerTransformers_1_4(subsystem);\n        }\n    }","id":212,"modified_method":"@Override\n    protected Set<ManagementResourceRegistration> initializeLegacyModel(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(JacORBSubsystemResource.INSTANCE);\n        subsystem.registerXMLElementWriter(PARSER);\n\n        if (context.isRegisterTransformers()) {\n            // Register the model transformers\n            registerTransformers(subsystem);\n        }\n\n        return Collections.singleton(subsystemRegistration);\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_0.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_1.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_2.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_3.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_4.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_2_0.getUriString(), PARSER);\n    }","id":213,"modified_method":"@Override\n    protected void initializeLegacyParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_0.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_1.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_2.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_3.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_1_4.getUriString(), PARSER);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JacORBSubsystemParser.Namespace.JacORB_2_0.getUriString(), PARSER);\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void initializeExtraSubystemsAndModel(final ExtensionRegistry extensionRegistry, Resource rootResource,\n                final ManagementResourceRegistration rootRegistration) {\n\n\n            final OperationDefinition removeExtension = new SimpleOperationDefinitionBuilder(\"remove\", new StandardResourceDescriptionResolver(\"test\", \"test\", getClass().getClassLoader()))\n                    .build();\n\n            PathElement webExtension = PathElement.pathElement(EXTENSION, \"org.jboss.as.jacorb\");\n            rootRegistration.registerSubModel(new SimpleResourceDefinition(webExtension, ControllerResolver.getResolver(EXTENSION)))\n                    .registerOperationHandler(removeExtension, new ReloadRequiredRemoveStepHandler());\n            rootResource.registerChild(webExtension, Resource.Factory.create());\n\n            rootRegistration.registerSubModel(new SimpleResourceDefinition(PathElement.pathElement(EXTENSION),\n                    ControllerResolver.getResolver(EXTENSION), new OperationStepHandler() {\n                        @Override\n                        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                            extensionAdded = true;\n                            newSubsystem.initialize(extensionRegistry.getExtensionContext(\"org.wildfly.iiop-openjdk\",\n                                    rootRegistration, ExtensionRegistryType.SLAVE));\n                        }\n                    }, null));\n        }","id":214,"modified_method":"@Override\n        protected void initializeExtraSubystemsAndModel(ExtensionRegistry extensionRegistry, Resource rootResource, ManagementResourceRegistration rootRegistration, RuntimeCapabilityRegistry capabilityRegistry) {\n\n            final OperationDefinition removeExtension = new SimpleOperationDefinitionBuilder(\"remove\", new StandardResourceDescriptionResolver(\"test\", \"test\", getClass().getClassLoader()))\n                    .build();\n\n            PathElement webExtension = PathElement.pathElement(EXTENSION, \"org.jboss.as.jacorb\");\n            rootRegistration.registerSubModel(new SimpleResourceDefinition(webExtension, ControllerResolver.getResolver(EXTENSION)))\n                    .registerOperationHandler(removeExtension, new ReloadRequiredRemoveStepHandler());\n            rootResource.registerChild(webExtension, Resource.Factory.create());\n\n            rootRegistration.registerSubModel(new SimpleResourceDefinition(PathElement.pathElement(EXTENSION),\n                    ControllerResolver.getResolver(EXTENSION), new OperationStepHandler() {\n                        @Override\n                        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                            extensionAdded = true;\n                            newSubsystem.initialize(extensionRegistry.getExtensionContext(\"org.wildfly.iiop-openjdk\",\n                                    rootRegistration, ExtensionRegistryType.SLAVE));\n                        }\n                    }, null));\n        }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testTransformersSecurityIdentity_1_1_0(ModelTestControllerVersion controllerVersion) throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXml(readResource(\"subsystem-security-identity.xml\"));\n\n        // Add legacy subsystems\n        ModelVersion version_1_1_0 = ModelVersion.create(1, 1, 0);\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.MANAGEMENT, controllerVersion, version_1_1_0)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion());\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(version_1_1_0);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        ModelNode transformed = checkSubsystemModelTransformation(mainServices, version_1_1_0).get(SUBSYSTEM, JacORBExtension.SUBSYSTEM_NAME);\n        Assert.assertEquals(\"on\", transformed.get(\"security\").asString());\n        List<ModelNode> properties = transformed.get(ModelDescriptionConstants.PROPERTIES).asList();\n        Assert.assertEquals(1, properties.size());\n        Assert.assertEquals(\"some_value\", properties.get(0).get(\"some_property\").asString());\n    }","id":215,"modified_method":"private void testTransformersSecurityIdentity(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC)\n                .setSubsystemXml(readResource(\"subsystem-security-identity.xml\"));\n\n        // Add legacy subsystems\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion())\n                .configureReverseControllerCheck(AdditionalInitialization.ADMIN_ONLY_HC, null);\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        ModelNode transformed = checkSubsystemModelTransformation(mainServices, modelVersion).get(SUBSYSTEM, JacORBExtension.SUBSYSTEM_NAME);\n        Assert.assertEquals(\"identity\", transformed.get(\"security\").asString());\n        List<ModelNode> properties = transformed.get(ModelDescriptionConstants.PROPERTIES).asList();\n        Assert.assertEquals(1, properties.size());\n        Assert.assertEquals(\"some_value\", properties.get(0).get(\"some_property\").asString());\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformersSecurityClient713() throws Exception {\n        testTransformersSecurityClient_1_1_0(ModelTestControllerVersion.V7_1_3_FINAL);\n    }","id":216,"modified_method":"@Test\n    public void testTransformersSecurityClientEAP620() throws Exception {\n        testTransformersSecurityClient(ModelTestControllerVersion.EAP_6_2_0, ModelVersion.create(1, 3, 0));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformers712() throws Exception {\n        testTransformers(ModelTestControllerVersion.V7_1_2_FINAL);\n    }","id":217,"modified_method":"@Test\n    public void testTransformersEAP640() throws Exception {\n        testTransformers(ModelTestControllerVersion.EAP_6_4_0, ModelVersion.create(1, 4));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformersIORSettings713() throws Exception {\n        testTransformersIORSettings(ModelTestControllerVersion.V7_1_3_FINAL);\n    }","id":218,"modified_method":"@Test\n    public void testTransformersIORSettingsEAP620() throws Exception {\n        testTransformersIORSettings(ModelTestControllerVersion.EAP_6_2_0, ModelVersion.create(1, 3, 0));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformersIORSettings712() throws Exception {\n        testTransformersIORSettings(ModelTestControllerVersion.V7_1_2_FINAL);\n    }","id":219,"modified_method":"@Test\n    public void testTransformersIORSettingsEAP630() throws Exception {\n        testTransformersIORSettings(ModelTestControllerVersion.EAP_6_3_0, ModelVersion.create(1, 3, 0));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testTransformersIORSettings(ModelTestControllerVersion controllerVersion) throws Exception {\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT);\n\n        ModelVersion version = ModelVersion.create(1, 1, 0);\n        // Add legacy subsystems\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.MANAGEMENT, controllerVersion, version)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion());\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(version);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        ModelTestUtils.checkFailedTransformedBootOperations(\n                mainServices,\n                version,\n                builder.parseXmlResource(\"subsystem-ior-settings.xml\"),\n                new FailedOperationTransformationConfig()\n                        .addFailedAttribute(\n                                PathAddress.pathAddress(JacORBSubsystemResource.INSTANCE.getPathElement(),\n                                        JacORBSubsystemResource.INSTANCE.getPathElement()),\n                                FailedOperationTransformationConfig.REJECTED_RESOURCE));\n    }","id":220,"modified_method":"private void testTransformersIORSettings(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC);\n\n        // Add legacy subsystems\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion())\n                .configureReverseControllerCheck(AdditionalInitialization.ADMIN_ONLY_HC, null);\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion,\n                builder.parseXmlResource(\"subsystem-ior-settings.xml\"),\n                new FailedOperationTransformationConfig()\n                        .addFailedAttribute(PathAddress.pathAddress(JacORBSubsystemResource.INSTANCE.getPathElement(),\n                                IORSettingsDefinition.INSTANCE.getPathElement()),\n                                FailedOperationTransformationConfig.REJECTED_RESOURCE)\n                        .addFailedAttribute(PathAddress.pathAddress(JacORBSubsystemResource.INSTANCE.getPathElement(),\n                                IORSettingsDefinition.INSTANCE.getPathElement(),\n                                IORTransportConfigDefinition.INSTANCE.getPathElement()),\n                                FailedOperationTransformationConfig.REJECTED_RESOURCE)\n                        .addFailedAttribute(PathAddress.pathAddress(JacORBSubsystemResource.INSTANCE.getPathElement(),\n                                IORSettingsDefinition.INSTANCE.getPathElement(),\n                                IORASContextDefinition.INSTANCE.getPathElement()),\n                                FailedOperationTransformationConfig.REJECTED_RESOURCE)\n                        .addFailedAttribute(PathAddress.pathAddress(JacORBSubsystemResource.INSTANCE.getPathElement(),\n                                IORSettingsDefinition.INSTANCE.getPathElement(),\n                                IORSASContextDefinition.INSTANCE.getPathElement()),\n                                FailedOperationTransformationConfig.REJECTED_RESOURCE));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testTransformers(ModelTestControllerVersion controllerVersion) throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXml(readResource(\"subsystem.xml\"));\n\n        // Add legacy subsystems\n        ModelVersion version_1_1_0 = ModelVersion.create(1, 1, 0);\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, version_1_1_0)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion());\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(version_1_1_0);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        ModelNode transformed = checkSubsystemModelTransformation(mainServices, version_1_1_0).get(SUBSYSTEM, JacORBExtension.SUBSYSTEM_NAME);\n        Assert.assertEquals(\"off\", transformed.get(\"security\").asString());\n        List<ModelNode> properties = transformed.get(ModelDescriptionConstants.PROPERTIES).asList();\n        Assert.assertEquals(1, properties.size());\n        Assert.assertEquals(\"some_value\", properties.get(0).get(\"some_property\").asString());\n    }","id":221,"modified_method":"private void testTransformers(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC)\n                .setSubsystemXmlResource(\"subsystem-transform.xml\");\n\n        // Add legacy subsystems\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion())\n                .configureReverseControllerCheck(AdditionalInitialization.ADMIN_ONLY_HC, null);\n\n        KernelServices mainServices = builder.build();\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        checkSubsystemModelTransformation(mainServices, modelVersion, new ModelFixer() {\n            @Override\n            public ModelNode fixModel(ModelNode modelNode) {\n                //modelNode.get(JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID.getName()).set(JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID.getDefaultValue());\n                modelNode.get(JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES.getName()).set(JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES.getDefaultValue());\n                return modelNode;\n            }\n        });\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testTransformersSecurityClient_1_1_0(ModelTestControllerVersion controllerVersion) throws Exception {\n        //security=client is not allowed on 7.1.2\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT);\n\n        // Add legacy subsystems\n        ModelVersion version_1_1_0 = ModelVersion.create(1, 1, 0);\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.MANAGEMENT, controllerVersion, version_1_1_0)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion());\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(version_1_1_0);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig()\n        .addFailedAttribute(PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, \"jacorb\")),\n                new FailedOperationTransformationConfig.AttributesPathAddressConfig(JacORBSubsystemConstants.ORB_INIT_SECURITY) {\n\n                    @Override\n                    protected boolean isAttributeWritable(String attributeName) {\n                        return true;\n                    }\n\n                    @Override\n                    protected boolean checkValue(String attrName, ModelNode attribute, boolean isWriteAttribute) {\n                        return attribute.asString().equals(\"client\");\n                    }\n\n                    @Override\n                    protected ModelNode correctValue(ModelNode toResolve, boolean isWriteAttribute) {\n                        return new ModelNode(\"off\");\n                    }\n                });\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, version_1_1_0, builder.parseXmlResource(\"subsystem-security-client.xml\"), config);\n        checkSubsystemModelTransformation(mainServices, version_1_1_0, new ModelFixer() {\n            @Override\n            public ModelNode fixModel(ModelNode modelNode) {\n                //Set back to the value before the failed operation config kicked in\n                Assert.assertEquals(\"off\", modelNode.get(JacORBSubsystemConstants.ORB_INIT_SECURITY).asString());\n                modelNode.get(JacORBSubsystemConstants.ORB_INIT_SECURITY).set(\"client\");\n                return modelNode;\n            }\n        });\n    }","id":222,"modified_method":"private void testTransformersSecurityClient(ModelTestControllerVersion controllerVersion, ModelVersion modelVersion) throws Exception {\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC);\n\n        // Add legacy subsystems\n        builder.createLegacyKernelServicesBuilder(AdditionalInitialization.ADMIN_ONLY_HC, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-jacorb:\" + controllerVersion.getMavenGavVersion())\n                .configureReverseControllerCheck(AdditionalInitialization.ADMIN_ONLY_HC, null);\n\n        KernelServices mainServices = builder.build();\n        assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        assertNotNull(legacyServices);\n        assertTrue(legacyServices.isSuccessfulBoot());\n\n        FailedOperationTransformationConfig config = new FailedOperationTransformationConfig();\n\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, builder.parseXmlResource(\"subsystem-security-client.xml\"), config);\n        checkSubsystemModelTransformation(mainServices, modelVersion);\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformersSecurityIdentity712() throws Exception {\n        testTransformersSecurityIdentity_1_1_0(ModelTestControllerVersion.V7_1_2_FINAL);\n    }","id":223,"modified_method":"@Test\n    public void testTransformersSecurityIdentityEAP630() throws Exception {\n        testTransformersSecurityIdentity(ModelTestControllerVersion.EAP_6_3_0, ModelVersion.create(1, 3, 0));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformersSecurityIdentity713() throws Exception {\n        testTransformersSecurityIdentity_1_1_0(ModelTestControllerVersion.V7_1_3_FINAL);\n    }","id":224,"modified_method":"@Test\n    public void testTransformersSecurityIdentityEAP620() throws Exception {\n        testTransformersSecurityIdentity(ModelTestControllerVersion.EAP_6_2_0, ModelVersion.create(1, 3, 0));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformers713() throws Exception {\n        testTransformers(ModelTestControllerVersion.V7_1_3_FINAL);\n    }","id":225,"modified_method":"@Test\n    public void testTransformersEAP630() throws Exception {\n        testTransformers(ModelTestControllerVersion.EAP_6_3_0, ModelVersion.create(1, 4));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testTransformersSecurityClient712() throws Exception {\n        testTransformersSecurityClient_1_1_0(ModelTestControllerVersion.V7_1_2_FINAL);\n    }","id":226,"modified_method":"@Test\n    public void testTransformersSecurityClientEAP630() throws Exception {\n        testTransformersSecurityClient(ModelTestControllerVersion.EAP_6_3_0, ModelVersion.create(1, 3, 0));\n    }","commit_id":"46d666d2e3232badf7682eae83a0ead0db3d0af5","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** Optionally (only if the <i>print<\/i> argument is true and\n     *  TRANSFORMED_SQL_FILE_WRITER is non-null), prints the original and\n     *  modified SQL statements, to a \"Transformed SQL\" output file, for the\n     *  current SQLCoverage test suite (if any). */\n    static protected void printTransformedSql(String originalSql, String modifiedSql, boolean print) {\n        if (print && TRANSFORMED_SQL_FILE_WRITER != null) {\n            try {\n                TRANSFORMED_SQL_FILE_WRITER.write(\"original SQL: \" + originalSql + \"\\n\");\n                TRANSFORMED_SQL_FILE_WRITER.write(\"modified SQL: \" + modifiedSql + \"\\n\");\n            } catch (IOException e) {\n                System.out.println(\"Caught IOException:\\n    \" + e);\n                System.out.println(\"original SQL: \" + originalSql);\n                System.out.println(\"modified SQL: \" + modifiedSql);\n            }\n        }\n    }","id":227,"modified_method":"/** Prints the original and modified SQL statements, to the \"Transformed\n     *  SQL\" output file, assuming that that file is defined; and only if\n     *  the original and modified SQL are not the same, i.e., only if some\n     *  transformation has indeed taken place. */\n    static protected void printTransformedSql(String originalSql, String modifiedSql) {\n        if (TRANSFORMED_SQL_FILE_WRITER != null && !originalSql.equals(modifiedSql)) {\n            try {\n                TRANSFORMED_SQL_FILE_WRITER.write(\"original SQL: \" + originalSql + \"\\n\");\n                TRANSFORMED_SQL_FILE_WRITER.write(\"modified SQL: \" + modifiedSql + \"\\n\");\n            } catch (IOException e) {\n                System.out.println(\"Caught IOException:\\n    \" + e);\n                System.out.println(\"original SQL: \" + originalSql);\n                System.out.println(\"modified SQL: \" + modifiedSql);\n            }\n        }\n    }","commit_id":"2483e4edfd5920dfdabf71bc71a6419e86721c77","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Simply returns a String consisting of the <i>prefix<\/i>, <i>group<\/i>,\n     *  and <i>suffix<\/i> concatenated (in that order), but being careful not\n     *  to include more close-parentheses than open-parentheses; if the group\n     *  does contain more close-parens than open-parens, the <i>suffix<\/i> is\n     *  inserted before the extra close-parens, instead of at the very end. */\n    static private String handleParens(String group, String prefix, String suffix) {\n        int numOpenParens  = numOccurencesOfCharIn(group, '(');\n        int numCloseParens = numOccurencesOfCharIn(group, ')');\n        if (numOpenParens >= numCloseParens || suffix.isEmpty()) {\n            return (prefix + group + suffix);\n        } else {  // numOpenParens < numCloseParens\n            int index;\n            if (numOpenParens == 0) {\n                index = indexOfNthOccurrenceOfCharIn(group, ')', 1) - 1;\n            } else {\n                index = indexOfNthOccurrenceOfCharIn(group, ')', numOpenParens);\n            }\n            return (prefix + group.substring(0, index+1) + suffix + group.substring(index+1));\n        }\n    }","id":228,"modified_method":"/** Simply returns a String consisting of the <i>prefix<\/i>, <i>group<\/i>,\n     *  and <i>suffix<\/i> concatenated (in that order), but being careful not\n     *  to include more close-parentheses than open-parentheses: if the group\n     *  does contain more close-parens than open-parens, the <i>suffix<\/i> is\n     *  inserted just after the matching close-parens (i.e., after the number\n     *  of close-parens that equals the number of open-parens), instead of at\n     *  the very end; but if there are no open-parens, then the <i>suffix<\/i>\n     *  is inserted just before the first close-parens. */\n    static private String handleParens(String group, String prefix, String suffix) {\n        int numOpenParens  = numOccurencesOfCharIn(group, '(');\n        int numCloseParens = numOccurencesOfCharIn(group, ')');\n        if (numOpenParens >= numCloseParens || suffix.isEmpty()) {\n            return (prefix + group + suffix);\n        } else {  // numOpenParens < numCloseParens\n            int index;\n            if (numOpenParens == 0) {\n                index = indexOfNthOccurrenceOfCharIn(group, ')', 1);\n            } else {\n                index = indexOfNthOccurrenceOfCharIn(group, ')', numOpenParens) + 1;\n            }\n            return (prefix + group.substring(0, index) + suffix + group.substring(index));\n        }\n    }","commit_id":"2483e4edfd5920dfdabf71bc71a6419e86721c77","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Modifies DDL statements in such a way that PostGIS results will match\n     *  VoltDB results, and then passes the remaining work to the base class\n     *  version. */\n    @Override\n    public void runDDL(String ddl) {\n        String modifiedDdl = transformDDL(ddl);\n        printTransformedSql(ddl, modifiedDdl, ddl != null && !ddl.equals(modifiedDdl));\n        super.runDDL(modifiedDdl, false);\n    }","id":229,"modified_method":"/** Modifies DDL statements in such a way that PostGIS results will match\n     *  VoltDB results, and then passes the remaining work to the base class\n     *  version. */\n    @Override\n    public void runDDL(String ddl) {\n        String modifiedDdl = transformDDL(ddl);\n        printTransformedSql(ddl, modifiedDdl);\n        super.runDDL(modifiedDdl, false);\n    }","commit_id":"2483e4edfd5920dfdabf71bc71a6419e86721c77","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Modifies queries in such a way that PostgreSQL/PostGIS results will\n     *  match VoltDB results, and then passes the remaining work to the base\n     *  class version. */\n    @Override\n    public VoltTable runDML(String dml) {\n        String modifiedDml = transformDML(dml);\n        printTransformedSql(dml, modifiedDml, dml != null && !dml.equals(modifiedDml));\n        return super.runDML(modifiedDml, false);\n    }","id":230,"modified_method":"/** Modifies queries in such a way that PostgreSQL/PostGIS results will\n     *  match VoltDB results, and then passes the remaining work to the base\n     *  class version. */\n    @Override\n    public VoltTable runDML(String dml) {\n        String modifiedDml = transformDML(dml);\n        printTransformedSql(dml, modifiedDml);\n        return super.runDML(modifiedDml, false);\n    }","commit_id":"2483e4edfd5920dfdabf71bc71a6419e86721c77","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Optionally, modifies queries in such a way that PostgreSQL results will\n     *  match VoltDB results; and then passes the remaining work to the base\n     *  class version. */\n    protected VoltTable runDML(String dml, boolean transformDml) {\n        String modifiedDml = (transformDml ? transformDML(dml) : dml);\n        printTransformedSql(dml, modifiedDml, transformDml\n                && dml != null && !dml.equals(modifiedDml));\n        return super.runDML(modifiedDml);\n    }","id":231,"modified_method":"/** Optionally, modifies queries in such a way that PostgreSQL results will\n     *  match VoltDB results; and then passes the remaining work to the base\n     *  class version. */\n    protected VoltTable runDML(String dml, boolean transformDml) {\n        String modifiedDml = (transformDml ? transformDML(dml) : dml);\n        printTransformedSql(dml, modifiedDml);\n        return super.runDML(modifiedDml);\n    }","commit_id":"2483e4edfd5920dfdabf71bc71a6419e86721c77","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Optionally, modifies DDL statements in such a way that PostgreSQL\n     *  results will match VoltDB results; and then passes the remaining\n     *  work to the base class version. */\n    protected void runDDL(String ddl, boolean transformDdl) {\n        String modifiedDdl = (transformDdl ? transformDDL(ddl) : ddl);\n        printTransformedSql(ddl, modifiedDdl, transformDdl\n                && ddl != null && !ddl.equals(modifiedDdl));\n        super.runDDL(modifiedDdl);\n    }","id":232,"modified_method":"/** Optionally, modifies DDL statements in such a way that PostgreSQL\n     *  results will match VoltDB results; and then passes the remaining\n     *  work to the base class version. */\n    protected void runDDL(String ddl, boolean transformDdl) {\n        String modifiedDdl = (transformDdl ? transformDDL(ddl) : ddl);\n        printTransformedSql(ddl, modifiedDdl);\n        super.runDDL(modifiedDdl);\n    }","commit_id":"2483e4edfd5920dfdabf71bc71a6419e86721c77","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"Goal prefix is: \" + goalPrefix + \"; Maven currently expects it to be \" + defaultGoalPrefix );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        \n        pluginDescriptor.setGroupId( project.getGroupId() );\n        \n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n            \n            mojoScanner.populatePluginDescriptor( project, pluginDescriptor );\n\n            createGenerator().execute( getOutputDirectory(), pluginDescriptor );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\", e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\", e );\n        }\n    }","id":233,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        String defaultGoalPrefix = PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() );\n        if ( goalPrefix == null )\n        {\n            goalPrefix = defaultGoalPrefix;\n        }\n        else\n        {\n            getLog().warn( \"Goal prefix is: \" + goalPrefix + \"; Maven currently expects it to be \" + defaultGoalPrefix );\n        }\n\n        // TODO: could use this more, eg in the writing of the plugin descriptor!\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        \n        pluginDescriptor.setGroupId( project.getGroupId() );\n        \n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        pluginDescriptor.setGoalPrefix( goalPrefix );\n\n        try\n        {\n            pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getRuntimeDependencies() ) );\n            \n            mojoScanner.populatePluginDescriptor( project, pluginDescriptor );\n\n            getOutputDirectory().mkdirs();\n\n            createGenerator().execute( getOutputDirectory(), pluginDescriptor );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error writing plugin descriptor\", e );\n        }\n        catch ( InvalidPluginDescriptorException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\", e );\n        }\n        catch ( ExtractionException e )\n        {\n            throw new MojoExecutionException( \"Error extracting plugin descriptor: \\'\" + e.getLocalizedMessage() + \"\\'\", e );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected abstract String getOutputDirectory();","id":234,"modified_method":"protected abstract File getOutputDirectory();","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public void testGenerator()\n        throws Exception\n    {\n        setupGenerator();\n\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setGoal( \"testGoal\" );\n        mojoDescriptor.setImplementation( \"org.apache.maven.tools.plugin.generator.TestMojo\" );\n        mojoDescriptor.setDependencyResolutionRequired( \"compile\" );\n\n        List params = new ArrayList();\n\n        Parameter param = new Parameter();\n        param.setDefaultValue( \"value\" );\n        param.setExpression( \"${project.build.directory}\" );\n        param.setName( \"dir\" );\n        param.setRequired( true );\n        param.setType( \"java.lang.String\" );\n        param.setDescription( \"Test parameter description\" );\n\n        params.add( param );\n\n        mojoDescriptor.setParameters( params );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.addMojo( mojoDescriptor );\n\n        pluginDescriptor.setArtifactId( \"maven-unitTesting-plugin\" );\n        pluginDescriptor.setGoalPrefix( \"test\" );\n\n        ComponentDependency dependency = new ComponentDependency();\n        dependency.setGroupId( \"testGroup\" );\n        dependency.setArtifactId( \"testArtifact\" );\n        dependency.setVersion( \"0.0.0\" );\n\n        pluginDescriptor.setDependencies( Collections.singletonList( dependency ) );\n\n        File tempFile = File.createTempFile( \"testGenerator-outDir\", \".marker.txt\" ).getAbsoluteFile();\n        File destinationDirectory = tempFile.getParentFile();\n\n        generator.execute( destinationDirectory.getAbsolutePath(), pluginDescriptor );\n\n        validate( destinationDirectory );\n    }","id":235,"modified_method":"public void testGenerator()\n        throws Exception\n    {\n        setupGenerator();\n\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setGoal( \"testGoal\" );\n        mojoDescriptor.setImplementation( \"org.apache.maven.tools.plugin.generator.TestMojo\" );\n        mojoDescriptor.setDependencyResolutionRequired( \"compile\" );\n\n        List params = new ArrayList();\n\n        Parameter param = new Parameter();\n        param.setExpression( \"${project.build.directory}\" );\n        param.setName( \"dir\" );\n        param.setRequired( true );\n        param.setType( \"java.lang.String\" );\n        param.setDescription( \"Test parameter description\" );\n\n        params.add( param );\n\n        mojoDescriptor.setParameters( params );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        mojoDescriptor.setPluginDescriptor( pluginDescriptor );\n\n        pluginDescriptor.addMojo( mojoDescriptor );\n\n        pluginDescriptor.setArtifactId( \"maven-unitTesting-plugin\" );\n        pluginDescriptor.setGoalPrefix( \"test\" );\n\n        ComponentDependency dependency = new ComponentDependency();\n        dependency.setGroupId( \"testGroup\" );\n        dependency.setArtifactId( \"testArtifact\" );\n        dependency.setVersion( \"0.0.0\" );\n\n        pluginDescriptor.setDependencies( Collections.singletonList( dependency ) );\n\n        File tempFile = File.createTempFile( \"testGenerator-outDir\", \".marker.txt\" ).getAbsoluteFile();\n        File destinationDirectory = tempFile.getParentFile();\n\n        generator.execute( destinationDirectory, pluginDescriptor );\n\n        validate( destinationDirectory );\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected void processPluginDescriptor( MojoDescriptor descriptor, String destinationDirectory )\n        throws IOException\n    {\n        String implementation = descriptor.getImplementation();\n\n        String className = implementation.substring( implementation.lastIndexOf( \".\" ) + 1 ) + \"Bean\";\n\n        JClass jClass = new JClass( className );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        jClass.setSuperClass( \"org.apache.maven.plugin.BeanPluginAdapter\" );\n\n        jClass.addImport( \"java.util.*\" );\n\n        // ----------------------------------------------------------------------\n        // Use the same package as the plugin we are wrapping.\n        // ----------------------------------------------------------------------\n\n        String packageName = implementation.substring( 0, implementation.lastIndexOf( \".\" ) );\n\n        jClass.setPackageName( packageName );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        JConstructor constructor = new JConstructor( jClass );\n\n        constructor.getSourceCode().add( \"super( new \" + implementation + \"() );\" );\n\n        jClass.addConstructor( constructor );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        List parameters = descriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            jClass.addMethod( createSetter( parameter ) );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String packageDirectory = replace( packageName, \".\", \"/\", -1 );\n\n        File destination = new File( destinationDirectory, packageDirectory + \"/\" + className + \".java\" );\n\n        if ( !destination.getParentFile().exists() )\n        {\n            destination.getParentFile().mkdirs();\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( destination );\n\n            JSourceWriter sourceWriter = new JSourceWriter( writer );\n\n            jClass.print( sourceWriter );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","id":236,"modified_method":"protected void processPluginDescriptor( MojoDescriptor descriptor, File destinationDirectory )\n        throws IOException\n    {\n        String implementation = descriptor.getImplementation();\n\n        String className = implementation.substring( implementation.lastIndexOf( \".\" ) + 1 ) + \"Bean\";\n\n        JClass jClass = new JClass( className );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        jClass.setSuperClass( \"org.apache.maven.plugin.BeanPluginAdapter\" );\n\n        jClass.addImport( \"java.util.*\" );\n\n        // ----------------------------------------------------------------------\n        // Use the same package as the plugin we are wrapping.\n        // ----------------------------------------------------------------------\n\n        String packageName = implementation.substring( 0, implementation.lastIndexOf( \".\" ) );\n\n        jClass.setPackageName( packageName );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        JConstructor constructor = new JConstructor( jClass );\n\n        constructor.getSourceCode().add( \"super( new \" + implementation + \"() );\" );\n\n        jClass.addConstructor( constructor );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        List parameters = descriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            jClass.addMethod( createSetter( parameter ) );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String packageDirectory = replace( packageName, \".\", \"/\", -1 );\n\n        File destination = new File( destinationDirectory, packageDirectory + \"/\" + className + \".java\" );\n\n        if ( !destination.getParentFile().exists() )\n        {\n            destination.getParentFile().mkdirs();\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( destination );\n\n            JSourceWriter sourceWriter = new JSourceWriter( writer );\n\n            jClass.print( sourceWriter );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public void execute( String destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processPluginDescriptor( descriptor, destinationDirectory );\n        }\n    }","id":237,"modified_method":"public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processPluginDescriptor( descriptor, destinationDirectory );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected String getOutputDirectory()\n    {\n        return outputDirectory;\n    }","id":238,"modified_method":"protected File getOutputDirectory()\n    {\n        return outputDirectory;\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected String getOutputDirectory()\n    {\n        return outputDirectory;\n    }","id":239,"modified_method":"protected File getOutputDirectory()\n    {\n        return outputDirectory;\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected String getOutputDirectory()\n    {\n        return outputDirectory;\n    }","id":240,"modified_method":"protected File getOutputDirectory()\n    {\n        return outputDirectory;\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public void execute( String destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        FileWriter writer = null;\n        PrettyPrintXMLWriter w;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, \"plugin.jelly\" ) );\n\n            w = new PrettyPrintXMLWriter( writer );\n\n            writePluginFile( w, pluginDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        // ----------------------------------------------------------------------\n        // project.xml\n        // ----------------------------------------------------------------------\n\n        writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, \"project.xml\" ) );\n\n            w = new PrettyPrintXMLWriter( writer );\n\n            writeProjectFile( w, pluginDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","id":241,"modified_method":"public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        FileWriter writer = null;\n        PrettyPrintXMLWriter w;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, \"plugin.jelly\" ) );\n\n            w = new PrettyPrintXMLWriter( writer );\n\n            writePluginFile( w, pluginDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        // ----------------------------------------------------------------------\n        // project.xml\n        // ----------------------------------------------------------------------\n\n        writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, \"project.xml\" ) );\n\n            w = new PrettyPrintXMLWriter( writer );\n\n            writeProjectFile( w, pluginDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public static void main( String[] args )\n        throws Exception\n    {\n        if ( args.length != 5 )\n        {\n            System.err.println( \"Usage: pluggy <mode> <source directory> <output directory> <pom>\" );\n\n            System.exit( 1 );\n        }\n\n        // Make sense of the args.\n        String mode = args[0];\n\n        String sourceDirectory = args[1];\n\n        String outputDirectory = args[2];\n\n        String pom = args[3];\n\n        // Massage the local-repo path into an ArtifactRepository.\n\n\n        MavenXpp3Reader modelReader = new MavenXpp3Reader();\n        FileReader reader = new FileReader( pom );\n\n        Model model = modelReader.read( reader );\n\n        // Not doing inheritence, except for groupId and version\n        if ( model.getGroupId() == null )\n        {\n            model.setGroupId( model.getParent().getGroupId() );\n        }\n        if ( model.getVersion() == null )\n        {\n            model.setVersion( model.getParent().getVersion() );\n        }\n\n        MavenProject project = new MavenProject( model );\n        project.setFile( new File( pom ) );\n        project.addCompileSourceRoot( sourceDirectory );\n\n        // Lookup the mojo scanner instance, and use it to scan for mojo's, and\n        // extract their descriptors.\n        MojoScanner scanner = new DefaultMojoScanner(\n            Collections.singletonMap( \"java\", new JavaMojoDescriptorExtractor() ) );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        // TODO: should read this from the pom...\n        pluginDescriptor.setGoalPrefix( PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() ) );\n\n        pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getDependencies() ) );\n\n        scanner.populatePluginDescriptor( project, pluginDescriptor );\n        \n        // Create the generator.\n        Generator generator = null;\n\n        if ( mode.equals( \"descriptor\" ) )\n        {\n            generator = new PluginDescriptorGenerator();\n        }\n        else if ( mode.equals( \"xdoc\" ) )\n        {\n            generator = new PluginXdocGenerator();\n        }\n        else if ( mode.equals( \"jelly\" ) )\n        {\n            generator = new JellyHarnessGenerator();\n        }\n        else if ( mode.equals( \"bean\" ) )\n        {\n            generator = new BeanGenerator();\n        }\n\n        // Use the generator to process the discovered descriptors and produce\n        // something with them.\n        generator.execute( outputDirectory, pluginDescriptor );\n    }","id":242,"modified_method":"public static void main( String[] args )\n        throws Exception\n    {\n        if ( args.length != 5 )\n        {\n            System.err.println( \"Usage: pluggy <mode> <source directory> <output directory> <pom>\" );\n\n            System.exit( 1 );\n        }\n\n        // Make sense of the args.\n        String mode = args[0];\n\n        String sourceDirectory = args[1];\n\n        String outputDirectory = args[2];\n\n        String pom = args[3];\n\n        // Massage the local-repo path into an ArtifactRepository.\n\n\n        MavenXpp3Reader modelReader = new MavenXpp3Reader();\n        FileReader reader = new FileReader( pom );\n\n        Model model = modelReader.read( reader );\n\n        // Not doing inheritence, except for groupId and version\n        if ( model.getGroupId() == null )\n        {\n            model.setGroupId( model.getParent().getGroupId() );\n        }\n        if ( model.getVersion() == null )\n        {\n            model.setVersion( model.getParent().getVersion() );\n        }\n\n        MavenProject project = new MavenProject( model );\n        project.setFile( new File( pom ) );\n        project.addCompileSourceRoot( sourceDirectory );\n\n        // Lookup the mojo scanner instance, and use it to scan for mojo's, and\n        // extract their descriptors.\n        MojoScanner scanner = new DefaultMojoScanner(\n            Collections.singletonMap( \"java\", new JavaMojoDescriptorExtractor() ) );\n\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n\n        pluginDescriptor.setGroupId( project.getGroupId() );\n\n        pluginDescriptor.setArtifactId( project.getArtifactId() );\n\n        pluginDescriptor.setVersion( project.getVersion() );\n\n        // TODO: should read this from the pom...\n        pluginDescriptor.setGoalPrefix( PluginDescriptor.getGoalPrefixFromArtifactId( project.getArtifactId() ) );\n\n        pluginDescriptor.setDependencies( PluginUtils.toComponentDependencies( project.getDependencies() ) );\n\n        scanner.populatePluginDescriptor( project, pluginDescriptor );\n        \n        // Create the generator.\n        Generator generator = null;\n\n        if ( mode.equals( \"descriptor\" ) )\n        {\n            generator = new PluginDescriptorGenerator();\n        }\n        else if ( mode.equals( \"xdoc\" ) )\n        {\n            generator = new PluginXdocGenerator();\n        }\n        else if ( mode.equals( \"jelly\" ) )\n        {\n            generator = new JellyHarnessGenerator();\n        }\n        else if ( mode.equals( \"bean\" ) )\n        {\n            generator = new BeanGenerator();\n        }\n\n        // Use the generator to process the discovered descriptors and produce\n        // something with them.\n        generator.execute( new File( outputDirectory ), pluginDescriptor );\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public MojoDefinitionTagLibrary()\n    {\n        registerTag( \"description\", DescriptionTag.class );\n        registerTag( \"execute\", ExecuteTag.class );\n        registerTag( \"executionStrategy\", ExecutionStrategyTag.class );\n        registerTag( \"goal\", GoalTag.class );\n        registerTag( \"instantiationStrategy\", InstantiationStrategyTag.class );\n        registerTag( \"lifecyclePhase\", LifecyclePhaseTag.class );\n        registerTag( \"metadata\", MetadataTag.class );\n        registerTag( \"mojo\", MojoTag.class );\n        registerTag( \"parameters\", ParametersTag.class );\n        registerTag( \"parameter\", ParameterTag.class );\n        registerTag( \"requiresDependencyResolution\", RequiresDependencyResolutionTag.class );\n        registerTag( \"requiresProject\", RequiresProjectTag.class );\n        registerTag( \"name\", ParamNameTag.class );\n        registerTag( \"expression\", ParamExpressionTag.class );\n        registerTag( \"type\", ParamTypeTag.class );\n        registerTag( \"default\", ParamDefaultTag.class );\n        registerTag( \"validator\", ParamValidatorTag.class );\n        registerTag( \"required\", ParamRequiredTag.class );\n    }","id":243,"modified_method":"public MojoDefinitionTagLibrary()\n    {\n        registerTag( \"description\", DescriptionTag.class );\n        registerTag( \"execute\", ExecuteTag.class );\n        registerTag( \"executionStrategy\", ExecutionStrategyTag.class );\n        registerTag( \"goal\", GoalTag.class );\n        registerTag( \"instantiationStrategy\", InstantiationStrategyTag.class );\n        registerTag( \"lifecyclePhase\", LifecyclePhaseTag.class );\n        registerTag( \"metadata\", MetadataTag.class );\n        registerTag( \"mojo\", MojoTag.class );\n        registerTag( \"parameters\", ParametersTag.class );\n        registerTag( \"parameter\", ParameterTag.class );\n        registerTag( \"requiresDependencyResolution\", RequiresDependencyResolutionTag.class );\n        registerTag( \"requiresProject\", RequiresProjectTag.class );\n        registerTag( \"name\", ParamNameTag.class );\n        registerTag( \"expression\", ParamExpressionTag.class );\n        registerTag( \"type\", ParamTypeTag.class );\n        registerTag( \"default\", ParamDefaultTag.class );\n        registerTag( \"required\", ParamRequiredTag.class );\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public void setDefault( String defaultVal )\n    {\n        this.defaultVal = defaultVal;\n    }","id":244,"modified_method":"public void setDefault( String defaultVal )\n    {\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"private Parameter buildParameter()\n    {\n        Parameter param = new Parameter();\n\n        param.setName( name );\n        param.setDefaultValue( defaultVal );\n        param.setDescription( description );\n        param.setExpression( expression );\n        param.setRequired( required );\n        param.setType( type );\n        param.setValidator( validator );\n        param.setDeprecated( deprecated );\n\n        return param;\n    }","id":245,"modified_method":"private Parameter buildParameter()\n    {\n        Parameter param = new Parameter();\n\n        param.setName( name );\n        param.setDescription( description );\n        param.setExpression( expression );\n        param.setRequired( required );\n        param.setType( type );\n        param.setDeprecated( deprecated );\n\n        return param;\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n        mojo.setPluginDescriptor( pluginDescriptor );\n\n        mojo.setGoal( c.getChild( \"goal\" ).getValue() );\n\n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        PlexusConfiguration configuratorConfig = c.getChild( \"configurator\" );\n\n        if ( configuratorConfig != null )\n        {\n            mojo.setComponentConfigurator( configuratorConfig.getValue() );\n        }\n\n        PlexusConfiguration composerConfig = c.getChild( \"composer\" );\n\n        if ( composerConfig != null )\n        {\n            mojo.setComponentComposer( composerConfig.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        String executePhase = c.getChild( \"executePhase\" ).getValue();\n\n        if ( executePhase != null )\n        {\n            mojo.setExecutePhase( executePhase );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String dependencyResolution = c.getChild( \"requiresDependencyResolution\" ).getValue();\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setDependencyResolutionRequired( dependencyResolution );\n        }\n\n        String requiresProject = c.getChild( \"requiresProject\" ).getValue();\n\n        if ( requiresProject != null )\n        {\n            mojo.setProjectRequired( Boolean.valueOf( requiresProject ).booleanValue() );\n        }\n\n        String requiresOnline = c.getChild( \"requiresOnline\" ).getValue();\n\n        if ( requiresOnline != null )\n        {\n            mojo.setOnlineRequired( Boolean.valueOf( requiresOnline ).booleanValue() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List parameters = new ArrayList();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setAlias( d.getChild( \"alias\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String required = d.getChild( \"required\" ).getValue();\n\n            parameter.setRequired( Boolean.valueOf( required ).booleanValue() );\n\n            PlexusConfiguration editableConfig = d.getChild( \"editable\" );\n\n            // we need the null check for pre-build legacy plugins...\n            if ( editableConfig != null )\n            {\n                String editable = d.getChild( \"editable\" ).getValue();\n\n                parameter.setEditable( editable == null || Boolean.valueOf( editable ).booleanValue() );\n            }\n\n            parameter.setValidator( d.getChild( \"validator\" ).getValue() );\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setExpression( d.getChild( \"expression\" ).getValue() );\n\n            parameter.setDeprecated( d.getChild( \"deprecated\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n\n        // TODO: Go back to this when we get the container ready to configure mojos...\n        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","id":246,"modified_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n        mojo.setPluginDescriptor( pluginDescriptor );\n\n        mojo.setGoal( c.getChild( \"goal\" ).getValue() );\n\n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        PlexusConfiguration configuratorConfig = c.getChild( \"configurator\" );\n\n        if ( configuratorConfig != null )\n        {\n            mojo.setComponentConfigurator( configuratorConfig.getValue() );\n        }\n\n        PlexusConfiguration composerConfig = c.getChild( \"composer\" );\n\n        if ( composerConfig != null )\n        {\n            mojo.setComponentComposer( composerConfig.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        String executePhase = c.getChild( \"executePhase\" ).getValue();\n\n        if ( executePhase != null )\n        {\n            mojo.setExecutePhase( executePhase );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String dependencyResolution = c.getChild( \"requiresDependencyResolution\" ).getValue();\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setDependencyResolutionRequired( dependencyResolution );\n        }\n\n        String requiresProject = c.getChild( \"requiresProject\" ).getValue();\n\n        if ( requiresProject != null )\n        {\n            mojo.setProjectRequired( Boolean.valueOf( requiresProject ).booleanValue() );\n        }\n\n        String requiresOnline = c.getChild( \"requiresOnline\" ).getValue();\n\n        if ( requiresOnline != null )\n        {\n            mojo.setOnlineRequired( Boolean.valueOf( requiresOnline ).booleanValue() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List parameters = new ArrayList();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setAlias( d.getChild( \"alias\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String required = d.getChild( \"required\" ).getValue();\n\n            parameter.setRequired( Boolean.valueOf( required ).booleanValue() );\n\n            PlexusConfiguration editableConfig = d.getChild( \"editable\" );\n\n            // we need the null check for pre-build legacy plugins...\n            if ( editableConfig != null )\n            {\n                String editable = d.getChild( \"editable\" ).getValue();\n\n                parameter.setEditable( editable == null || Boolean.valueOf( editable ).booleanValue() );\n            }\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setExpression( d.getChild( \"expression\" ).getValue() );\n\n            parameter.setDeprecated( d.getChild( \"deprecated\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n\n        // TODO: Go back to this when we get the container ready to configure mojos...\n        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n\n        w.writeText( mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n\n            w.writeText( mojoDescriptor.getComponentComposer() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n        \n        Map configuration = new HashMap();\n        \n        if( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                Parameter parameter = (Parameter) parameters.get( j );\n\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    requirements.add( parameter );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        element( w, \"deprecated\", parameter.getDeprecated() );\n                    }\n\n                    // TODO: do we still need this?\n                    element( w, \"validator\", parameter.getValidator() );\n\n                    element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    element( w, \"description\", parameter.getDescription() );\n\n                    if ( expression != null && expression.length() > 0 )\n                    {\n                        configuration.put( parameter, expression );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.keySet().iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                w.writeText( (String) configuration.get( parameter ) );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                // remove \"component.\" plus expression delimiters\n                String expression = requirement.getExpression();\n                String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                element( w, \"role\", role );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","id":247,"modified_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n\n        w.writeText( mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n\n            w.writeText( mojoDescriptor.getComponentComposer() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n        \n        Map configuration = new HashMap();\n        \n        if( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                Parameter parameter = (Parameter) parameters.get( j );\n\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    requirements.add( parameter );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        element( w, \"deprecated\", parameter.getDeprecated() );\n                    }\n\n                    element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    element( w, \"description\", parameter.getDescription() );\n\n                    if ( expression != null && expression.length() > 0 )\n                    {\n                        configuration.put( parameter, expression );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.keySet().iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                w.writeText( (String) configuration.get( parameter ) );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                // remove \"component.\" plus expression delimiters\n                String expression = requirement.getExpression();\n                String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                element( w, \"role\", role );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public void execute( String destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        File f = new File( destinationDirectory, \"plugin.xml\" );\n\n        if ( !f.getParentFile().exists() )\n        {\n            f.getParentFile().mkdirs();\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( f );\n\n            XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n            w.startElement( \"plugin\" );\n\n            element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            element( w, \"version\", pluginDescriptor.getVersion() );\n\n            element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n             w.startElement( \"mojos\" );\n\n            for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n            {\n                MojoDescriptor descriptor = (MojoDescriptor) it.next();\n                processMojoDescriptor( descriptor, w );\n            }\n\n            w.endElement();\n\n            PluginUtils.writeDependencies( w, pluginDescriptor );\n\n            w.endElement();\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","id":248,"modified_method":"public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        File f = new File( destinationDirectory, \"plugin.xml\" );\n\n        if ( !f.getParentFile().exists() )\n        {\n            f.getParentFile().mkdirs();\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( f );\n\n            XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n            w.startElement( \"plugin\" );\n\n            element( w, \"groupId\", pluginDescriptor.getGroupId() );\n\n            element( w, \"artifactId\", pluginDescriptor.getArtifactId() );\n\n            element( w, \"version\", pluginDescriptor.getVersion() );\n\n            element( w, \"goalPrefix\", pluginDescriptor.getGoalPrefix() );\n\n             w.startElement( \"mojos\" );\n\n            for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n            {\n                MojoDescriptor descriptor = (MojoDescriptor) it.next();\n                processMojoDescriptor( descriptor, w );\n            }\n\n            w.endElement();\n\n            PluginUtils.writeDependencies( w, pluginDescriptor );\n\n            w.endElement();\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"protected void processPluginDescriptor( MojoDescriptor mojoDescriptor, String destinationDirectory )\n        throws IOException\n    {\n        String id = mojoDescriptor.getGoal();\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, id + \"-plugin.xml\" ) );\n\n            writeBody( writer, id, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","id":249,"modified_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, File destinationDirectory )\n        throws IOException\n    {\n        String id = mojoDescriptor.getGoal();\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( destinationDirectory, id + \"-mojo.xml\" ) );\n\n            writeBody( writer, id, mojoDescriptor );\n\n            writer.flush();\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"private void writeBody( FileWriter writer, String id, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        w.writeText( \"Documentation for the \" + id + \" plugin.\" );\n\n        w.endElement();\n\n        w.startElement( \"author\" );\n\n        w.addAttribute( \"email\", \"dev@maven.apache.org\" );\n\n        w.writeText( \"Maven development team.\" );\n\n        w.endElement();\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", \"Goals\" );\n\n        w.startElement( \"p\" );\n\n        w.writeText( \"The goals for the \" + id + \" are as follows:\" );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"subsection\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getGoal() );\n\n        if ( mojoDescriptor.getDescription() != null )\n        {\n            w.startElement( \"p\" );\n\n            w.writeText( mojoDescriptor.getDescription() );\n\n            w.endElement();\n        }\n\n        w.startElement( \"p\" );\n\n        w.writeText( \"These parameters for this goal: \" );\n\n        w.endElement();\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","id":250,"modified_method":"private void writeBody( FileWriter writer, String id, MojoDescriptor mojoDescriptor )\n    {\n        XMLWriter w = new PrettyPrintXMLWriter( writer );\n\n        w.startElement( \"document\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"properties\" );\n\n        w.startElement( \"title\" );\n\n        // TODO: need a friendly name for a plugin\n        w.writeText( mojoDescriptor.getPluginDescriptor().getArtifactId() + \" - \" + mojoDescriptor.getFullGoalName() );\n\n        w.endElement();\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"section\" );\n\n        w.addAttribute( \"name\", mojoDescriptor.getFullGoalName() );\n\n        w.startElement( \"p\" );\n\n        if ( mojoDescriptor.getDescription() != null )\n        {\n            w.writeMarkup( mojoDescriptor.getDescription() );\n        }\n        else\n        {\n            w.writeText( \"No description.\" );\n        }\n\n        w.endElement();\n\n        w.startElement( \"p\" );\n\n        w.writeText( \"Parameters for the goal: \" );\n\n        w.endElement();\n\n        writeGoalParameterTable( mojoDescriptor, w );\n\n        w.endElement();\n\n        w.endElement();\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"p\" );\n\n        w.startElement( \"table\" );\n\n        w.startElement( \"tr\" );\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Parameter\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Type\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Expression\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Description\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Required?\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Deprecated?\" );\n\n        w.endElement();\n\n        w.endElement();\n\n        List parameters = mojoDescriptor.getParameters();\n\n        Map parameterMap = mojoDescriptor.getParameterMap();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            w.startElement( \"tr\" );\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            String paramName = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( paramName ) )\n            {\n                paramName = parameter.getName();\n            }\n\n            w.writeText( paramName );\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.writeText( parameter.getType() );\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.writeText( parameter.getExpression() );\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.writeText( parameter.getDescription() );\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.writeText( Boolean.toString( parameter.isRequired() ) );\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            String deprecationWarning = parameter.getDeprecated();\n            if ( StringUtils.isNotEmpty( deprecationWarning ) )\n            {\n                w.startElement( \"td\" );\n\n                w.writeText( deprecationWarning );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        w.endElement();\n\n        w.endElement();\n    }","id":251,"modified_method":"private void writeGoalParameterTable( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"table\" );\n\n        w.startElement( \"tr\" );\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Parameter\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Type\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Expression\" );\n\n        w.endElement();\n\n        w.startElement( \"th\" );\n\n        w.writeText( \"Description\" );\n\n        w.endElement();\n\n        w.endElement();\n\n        List parameters = mojoDescriptor.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            w.startElement( \"tr\" );\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            String paramName = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( paramName ) )\n            {\n                paramName = parameter.getName();\n            }\n\n            w.startElement( \"code\" );\n\n            w.writeText( paramName );\n\n            w.endElement();\n\n            if ( !parameter.isRequired() )\n            {\n                w.writeMarkup( \" <i>(Optional)<\/i>\");\n            }\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            w.writeText( parameter.getType() );\n\n            w.endElement();\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            w.startElement( \"code\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getExpression() ) )\n            {\n                w.writeText( parameter.getExpression() );\n            }\n            else\n            {\n                w.writeText( \"-\" );\n            }\n\n            w.endElement();\n\n            w.endElement();\n\n            // ----------------------------------------------------------------------\n            //\n            // ----------------------------------------------------------------------\n\n            w.startElement( \"td\" );\n\n            if ( StringUtils.isNotEmpty( parameter.getDescription() ) )\n            {\n                w.writeMarkup( parameter.getDescription() );\n            }\n            else\n            {\n                w.writeText( \"No description.\" );\n            }\n\n            String deprecationWarning = parameter.getDeprecated();\n            if ( deprecationWarning != null )\n            {\n                w.writeMarkup( \"<br/><b>Deprecated:<\/b> \");\n                w.writeMarkup( deprecationWarning );\n                if ( deprecationWarning.length() == 0 )\n                {\n                    w.writeText( \"No reason given.\" );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n\n            w.endElement();\n        }\n\n        w.endElement();\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"public void execute( String destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processPluginDescriptor( descriptor, destinationDirectory );\n        }\n    }","id":252,"modified_method":"public void execute( File destinationDirectory, PluginDescriptor pluginDescriptor )\n        throws IOException\n    {\n        // TODO: write an overview page\n\n        for ( Iterator it = pluginDescriptor.getMojos().iterator(); it.hasNext(); )\n        {\n            MojoDescriptor descriptor = (MojoDescriptor) it.next();\n            processMojoDescriptor( descriptor, destinationDirectory );\n        }\n    }","commit_id":"640ee60806fb3dd950abacfb1e6ecc9d4f5c7a05","url":"https://github.com/apache/maven"},{"original_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    return create(new BufferedInputStream(new FileInputStream(filename)));\n  }","id":253,"modified_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    InputStream stream = new BufferedInputStream(new FileInputStream(filename));\n    Annotation anno = create(stream);\n    IOUtils.closeIgnoringExceptions(stream);\n    return anno;\n  }","commit_id":"400587ad1b959081cd762979bd7e97610da54b94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return create(new BufferedInputStream(new FileInputStream(file)));\n  }","id":254,"modified_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return createFromFile(file.getAbsoluteFile());\n  }","commit_id":"400587ad1b959081cd762979bd7e97610da54b94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    return create(IOUtils.getBufferedFileReader(filename));\n  }","id":255,"modified_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    Reader r = IOUtils.getBufferedFileReader(filename);\n    Annotation anno = create(r);\n    IOUtils.closeIgnoringExceptions(r);\n    return anno;\n  }","commit_id":"400587ad1b959081cd762979bd7e97610da54b94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return create(IOUtils.getBufferedFileReader(file.getAbsolutePath()));\n  }","id":256,"modified_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return createFromFile(file.getAbsolutePath());\n  }","commit_id":"400587ad1b959081cd762979bd7e97610da54b94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    return create(new BufferedInputStream(new FileInputStream(filename)));\n  }","id":257,"modified_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    InputStream stream = new BufferedInputStream(new FileInputStream(filename));\n    Annotation anno = create(stream);\n    IOUtils.closeIgnoringExceptions(stream);\n    return anno;\n  }","commit_id":"32cdbcaa7f6ca07e7cfeb6cdcbe6f987990dc9c4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return create(new BufferedInputStream(new FileInputStream(file)));\n  }","id":258,"modified_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return createFromFile(file.getAbsoluteFile());\n  }","commit_id":"32cdbcaa7f6ca07e7cfeb6cdcbe6f987990dc9c4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    return create(IOUtils.getBufferedFileReader(filename));\n  }","id":259,"modified_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    Reader r = IOUtils.getBufferedFileReader(filename);\n    Annotation anno = create(r);\n    IOUtils.closeIgnoringExceptions(r);\n    return anno;\n  }","commit_id":"32cdbcaa7f6ca07e7cfeb6cdcbe6f987990dc9c4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return create(IOUtils.getBufferedFileReader(file.getAbsolutePath()));\n  }","id":260,"modified_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return createFromFile(file.getAbsolutePath());\n  }","commit_id":"32cdbcaa7f6ca07e7cfeb6cdcbe6f987990dc9c4","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    return create(new BufferedInputStream(new FileInputStream(filename)));\n  }","id":261,"modified_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    InputStream stream = new BufferedInputStream(new FileInputStream(filename));\n    Annotation anno = create(stream);\n    IOUtils.closeIgnoringExceptions(stream);\n    return anno;\n  }","commit_id":"134da55d836c4584535babe70f18e270cd3d8303","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return create(new BufferedInputStream(new FileInputStream(file)));\n  }","id":262,"modified_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return createFromFile(file.getAbsoluteFile());\n  }","commit_id":"134da55d836c4584535babe70f18e270cd3d8303","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return create(IOUtils.getBufferedFileReader(file.getAbsolutePath()));\n  }","id":263,"modified_method":"@Override\n  public Annotation createFromFile(File file) throws IOException {\n    return createFromFile(file.getAbsolutePath());\n  }","commit_id":"134da55d836c4584535babe70f18e270cd3d8303","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    return create(IOUtils.getBufferedFileReader(filename));\n  }","id":264,"modified_method":"@Override\n  public Annotation createFromFile(String filename) throws IOException {\n    Reader r = IOUtils.getBufferedFileReader(filename);\n    Annotation anno = create(r);\n    IOUtils.closeIgnoringExceptions(r);\n    return anno;\n  }","commit_id":"134da55d836c4584535babe70f18e270cd3d8303","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Transactional\n   public void parseAndSaveTMX(InputStream input, final TransMemory tm) throws XMLStreamException\n   {\n      parseTMX(input,\n            new Effect<Element>()\n            {\n               @Override\n               public void e(Element element)\n               {\n                  transMemoryAdapter.persistHeader(tm, element);\n               }\n            },\n            new Effect<Element>()\n            {\n               @Override\n               public void e(Element element)\n               {\n                  transMemoryAdapter.persistTransUnit(tm, element);\n               }\n            }\n      );\n   }","id":265,"modified_method":"@Transactional\n   public void parseAndSaveTMX(InputStream input, TransMemory transMemory) throws XMLStreamException, SecurityException, IllegalStateException, RollbackException, HeuristicMixedException, HeuristicRollbackException, SystemException, NotSupportedException\n   {\n      try\n      {\n         session.setFlushMode(FlushMode.MANUAL);\n         session.setCacheMode(CacheMode.IGNORE);\n         XMLInputFactory factory = XMLInputFactory.newInstance();\n         factory.setProperty(XMLInputFactory.IS_VALIDATING, false);\n         factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n         @Cleanup\n         XMLEventReader reader = factory.createXMLEventReader(input);\n\n         QName tu = new QName(\"tu\");\n         QName header = new QName(\"header\");\n         int handledTUs = 0;\n\n         while (reader.hasNext())\n         {\n            if( handledTUs > 0 && handledTUs % BATCH_SIZE == 0 )\n            {\n               commitBatch(handledTUs, true);\n            }\n            XMLEvent event = reader.nextEvent();\n            if (event.isStartElement())\n            {\n               StartElement elem = event.asStartElement();\n               if (elem.getName().equals(tu))\n               {\n                  Element tuElem = ElementBuilder.buildElement(elem, reader);\n                  transMemoryAdapter.processTransUnit(transMemory, tuElem);\n                  handledTUs++;\n               }\n               else if (elem.getName().equals(header))\n               {\n                  Element headerElem = ElementBuilder.buildElement(elem, reader);\n                  transMemoryAdapter.processHeader(transMemory, headerElem);\n               }\n            }\n         }\n         commitBatch(handledTUs, false);\n      }\n      catch (EntityExistsException e)\n      {\n         String msg = \"Possible duplicate TU (duplicate tuid or duplicate\" +\n               \"src content without tuid)\";\n         throw new EntityExistsException(msg, e);\n      }\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void updateProgress(int processed)\n   {\n      if( asynchronousProcessHandle != null )\n      {\n         // TODO Piggybacking on the messages field. We should move to {@link java.util.concurrent.Future}\n         // or implement a specific TMX Import handler.\n         asynchronousProcessHandle.setMessages(Lists.newArrayList(\"Processed Entries: \" + processed));\n      }\n   }","id":266,"modified_method":"private void updateProgress(int numProcessed)\n   {\n      if( asynchronousProcessHandle != null )\n      {\n         // TODO Piggybacking on the messages field. We should move to {@link java.util.concurrent.Future}\n         // or implement a specific TMX Import handler.\n         asynchronousProcessHandle.setMessages(Lists.newArrayList(\"Processed Entries: \" + numProcessed));\n      }\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void populateTMFromFile(TransMemory tm, String file) throws XMLStreamException\n   {\n      TMXParser parser = seam.autowire(TMXParser.class);\n      InputStream is = getClass().getResourceAsStream(file);\n\n      parser.parseAndSaveTMX(is, tm);\n   }","id":267,"modified_method":"private void populateTMFromFile(TransMemory tm, String file) throws Exception\n   {\n      TMXParser parser = seam.autowire(TMXParser.class);\n      InputStream is = getClass().getResourceAsStream(file);\n\n      parser.parseAndSaveTMX(is, tm);\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void parseTMX() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Dates were modified to match the TM header in the file\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(tm.getCreationDate());\n      assertThat(cal.get(Calendar.YEAR), is(2013));\n      assertThat(cal.get(Calendar.MONTH), is(4));\n      assertThat(cal.get(Calendar.DATE), is(10));\n\n      assertThat(tm.getSourceLanguage(), equalTo(\"en\"));\n\n      // TM metadata\n      assertThat(tm.getMetadata().size(), greaterThan(0));\n      assertThat(tm.getMetadata().get(TMMetadataType.TMX14), notNullValue());\n\n      // Translation Units\n      for(TransMemoryUnit tu : tm.getTranslationUnits())\n      {\n         assertThat(tu.getTransUnitVariants().size(), greaterThan(0));\n      }\n   }","id":268,"modified_method":"@Test\n   public void parseTMX() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Dates were modified to match the TM header in the file\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(tm.getCreationDate());\n      assertThat(cal.get(Calendar.YEAR), is(2013));\n      assertThat(cal.get(Calendar.MONTH), is(4));\n      assertThat(cal.get(Calendar.DATE), is(10));\n\n      assertThat(tm.getSourceLanguage(), equalTo(\"en\"));\n\n      // TM metadata\n      assertThat(tm.getMetadata().size(), greaterThan(0));\n      assertThat(tm.getMetadata().get(TMMetadataType.TMX14), notNullValue());\n\n      // Translation Units\n      for(TransMemoryUnit tu : tm.getTranslationUnits())\n      {\n         assertThat(tu.getTransUnitVariants().size(), greaterThan(0));\n      }\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void mergeComplementaryTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should add all new tuids)\n      populateTMFromFile(tm, \"/tmx/valid-tm-with-tuids.tmx\");\n\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(8));\n   }","id":269,"modified_method":"@Test\n   public void mergeComplementaryTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should add all new tuids)\n      populateTMFromFile(tm, \"/tmx/valid-tm-with-tuids.tmx\");\n\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(8));\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TransMemory createTMFromFile(String file) throws XMLStreamException\n   {\n      TransMemoryDAO transMemoryDAO = seam.autowire(TransMemoryDAO.class);\n      TransMemory tm = new TransMemory();\n      tm.setSlug(\"new-tm\");\n      tm.setDescription(\"New test tm\");\n      transMemoryDAO.makePersistent(tm);\n\n      populateTMFromFile(tm, file);\n      return tm;\n   }","id":270,"modified_method":"private TransMemory createTMFromFile(String file) throws Exception\n   {\n      TransMemoryDAO transMemoryDAO = seam.autowire(TransMemoryDAO.class);\n      TransMemory tm = new TransMemory();\n      tm.setSlug(\"new-tm\");\n      tm.setDescription(\"New test tm\");\n      transMemoryDAO.makePersistent(tm);\n\n      populateTMFromFile(tm, file);\n      return tm;\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void parseTMXWithMetadata() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/valid-tmx-with-metadata.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n\n      // Metadata at the header level\n      Map<String,String> tmAtts = TMXMetadataHelper.getAttributes(tm);\n      assertThat(tmAtts.size(), is(9));\n      assertThat(tmAtts, hasEntry(\"segtype\", \"paragraph\"));\n      assertThat(tmAtts, hasEntry(\"creationtoolversion\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"creationtool\", \"Zanata TransMemoryExportTMXStrategy\"));\n      assertThat(tmAtts, hasEntry(\"datatype\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"adminlang\", \"en\"));\n      assertThat(tmAtts, hasEntry(\"o-tmf\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"srclang\", \"*all*\"));\n      assertThat(tmAtts, hasKey(\"creationdate\"));\n      assertThat(tmAtts, hasKey(\"changedate\"));\n\n      List<Element> tmChildren = TMXMetadataHelper.getChildren(tm);\n      assertThat(tmChildren.size(), is(2));\n      assertThat(tmChildren.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tmChildren.get(0).getValue(), is(\"Header Prop value\"));\n      assertThat(tmChildren.get(1).getLocalName(), is(\"note\"));\n      assertThat(tmChildren.get(1).getValue(), is(\"Header Note value\"));\n\n      // Metadata at the TU level\n      TransMemoryUnit tu0 = findInCollection(tm.getTranslationUnits(), \"doc0:resId0\");\n      Map<String,String> tu0Atts = TMXMetadataHelper.getAttributes(tu0);\n      assertThat(tu0Atts.size(), is(4));\n      assertThat(tu0Atts, hasEntry(\"tuid\", \"doc0:resId0\"));\n      assertThat(tu0Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu0Atts, hasKey(\"creationdate\"));\n      assertThat(tu0Atts, hasKey(\"changedate\"));\n\n      List<Element> tu0Children = TMXMetadataHelper.getChildren(tu0);\n      assertThat(tu0Children.size(), is(2));\n      assertThat(tu0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu0Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tu0Children.get(1).getValue(), is(\"Custom note\"));\n\n      TransMemoryUnit tu1 = findInCollection(tm.getTranslationUnits(), \"doc0:resId1\");\n      Map<String,String> tu1Atts = TMXMetadataHelper.getAttributes(tu1);\n      assertThat(tu1Atts.size(), is(4));\n      assertThat(tu1Atts, hasEntry(\"tuid\", \"doc0:resId1\"));\n      assertThat(tu1Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu1Atts, hasKey(\"creationdate\"));\n      assertThat(tu1Atts, hasKey(\"changedate\"));\n\n      List<Element> tu1Children = TMXMetadataHelper.getChildren(tu1);\n      assertThat(tu1Children.size(), is(4));\n      assertThat(tu1Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu1Children.get(1).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(1).getValue(), is(\"Custom prop1 value\"));\n      assertThat(tu1Children.get(2).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(2).getValue(), is(\"Custom note0\"));\n      assertThat(tu1Children.get(3).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(3).getValue(), is(\"Custom note1\"));\n\n      // Metadata at the TUV level\n      TransMemoryUnitVariant tuv0 = tu0.getTransUnitVariants().get(\"en\");\n      Map<String, String> tuv0Atts = TMXMetadataHelper.getAttributes(tuv0);\n      assertThat(tuv0Atts.size(), is(3));\n      assertThat(tuv0Atts, hasEntry(\"xml:lang\", \"en\"));\n      assertThat(tuv0Atts, hasKey(\"creationdate\"));\n      assertThat(tuv0Atts, hasKey(\"changedate\"));\n\n      List<Element> tuv0Children = TMXMetadataHelper.getChildren(tuv0);\n      assertThat(tuv0Children.size(), is(2));\n      assertThat(tuv0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tuv0Children.get(0).getValue(), is(\"Custom prop0 value on tuv\"));\n      assertThat(tuv0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tuv0Children.get(1).getValue(), is(\"Custom note on tuv\"));\n   }","id":271,"modified_method":"@Test\n   public void parseTMXWithMetadata() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/valid-tmx-with-metadata.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n\n      // Metadata at the header level\n      Map<String,String> tmAtts = TMXMetadataHelper.getAttributes(tm);\n      assertThat(tmAtts.size(), is(9));\n      assertThat(tmAtts, hasEntry(\"segtype\", \"paragraph\"));\n      assertThat(tmAtts, hasEntry(\"creationtoolversion\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"creationtool\", \"Zanata TransMemoryExportTMXStrategy\"));\n      assertThat(tmAtts, hasEntry(\"datatype\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"adminlang\", \"en\"));\n      assertThat(tmAtts, hasEntry(\"o-tmf\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"srclang\", \"*all*\"));\n      assertThat(tmAtts, hasKey(\"creationdate\"));\n      assertThat(tmAtts, hasKey(\"changedate\"));\n\n      List<Element> tmChildren = TMXMetadataHelper.getChildren(tm);\n      assertThat(tmChildren.size(), is(2));\n      assertThat(tmChildren.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tmChildren.get(0).getValue(), is(\"Header Prop value\"));\n      assertThat(tmChildren.get(1).getLocalName(), is(\"note\"));\n      assertThat(tmChildren.get(1).getValue(), is(\"Header Note value\"));\n\n      // Metadata at the TU level\n      TransMemoryUnit tu0 = findInCollection(tm.getTranslationUnits(), \"doc0:resId0\");\n      Map<String,String> tu0Atts = TMXMetadataHelper.getAttributes(tu0);\n      assertThat(tu0Atts.size(), is(4));\n      assertThat(tu0Atts, hasEntry(\"tuid\", \"doc0:resId0\"));\n      assertThat(tu0Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu0Atts, hasKey(\"creationdate\"));\n      assertThat(tu0Atts, hasKey(\"changedate\"));\n\n      List<Element> tu0Children = TMXMetadataHelper.getChildren(tu0);\n      assertThat(tu0Children.size(), is(2));\n      assertThat(tu0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu0Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tu0Children.get(1).getValue(), is(\"Custom note\"));\n\n      TransMemoryUnit tu1 = findInCollection(tm.getTranslationUnits(), \"doc0:resId1\");\n      Map<String,String> tu1Atts = TMXMetadataHelper.getAttributes(tu1);\n      assertThat(tu1Atts.size(), is(4));\n      assertThat(tu1Atts, hasEntry(\"tuid\", \"doc0:resId1\"));\n      assertThat(tu1Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu1Atts, hasKey(\"creationdate\"));\n      assertThat(tu1Atts, hasKey(\"changedate\"));\n\n      List<Element> tu1Children = TMXMetadataHelper.getChildren(tu1);\n      assertThat(tu1Children.size(), is(4));\n      assertThat(tu1Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu1Children.get(1).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(1).getValue(), is(\"Custom prop1 value\"));\n      assertThat(tu1Children.get(2).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(2).getValue(), is(\"Custom note0\"));\n      assertThat(tu1Children.get(3).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(3).getValue(), is(\"Custom note1\"));\n\n      // Metadata at the TUV level\n      TransMemoryUnitVariant tuv0 = tu0.getTransUnitVariants().get(\"en\");\n      Map<String, String> tuv0Atts = TMXMetadataHelper.getAttributes(tuv0);\n      assertThat(tuv0Atts.size(), is(3));\n      assertThat(tuv0Atts, hasEntry(\"xml:lang\", \"en\"));\n      assertThat(tuv0Atts, hasKey(\"creationdate\"));\n      assertThat(tuv0Atts, hasKey(\"changedate\"));\n\n      List<Element> tuv0Children = TMXMetadataHelper.getChildren(tuv0);\n      assertThat(tuv0Children.size(), is(2));\n      assertThat(tuv0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tuv0Children.get(0).getValue(), is(\"Custom prop0 value on tuv\"));\n      assertThat(tuv0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tuv0Children.get(1).getValue(), is(\"Custom note on tuv\"));\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void mergeSameTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should yield the same result)\n      populateTMFromFile(tm, \"/tmx/default-valid-tm.tmx\");\n\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n   }","id":272,"modified_method":"@Test\n   public void mergeSameTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should yield the same result)\n      populateTMFromFile(tm, \"/tmx/default-valid-tm.tmx\");\n\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Persists a translation unit when a tu\n    * element is encountered while parsing.\n    */\n   public void persistTransUnit(TransMemory tm, Element tuElem)\n   {\n      TransMemoryUnit tu = new TransMemoryUnit();\n      tu.setTranslationMemory(tm);\n\n      TMXMetadataHelper.setMetadata(tu, tuElem, tm.getSourceLanguage());\n      tu.setVersionNum(0);\n\n      addTUVs(tu, tuElem.getChildElements(\"tuv\"));\n\n      tu.setUniqueId(determineUniqueId(tu));\n\n      removeExistingTUIfAny(tm.getSlug(), tu.getUniqueId());\n      entityManager.persist(tu);\n      entityManager.flush();\n   }","id":273,"modified_method":"/**\n    * Persists a translation unit when a tu\n    * element is encountered while parsing.\n    */\n   public void processTransUnit(TransMemory tm, Element tuElem)\n   {\n      TransMemoryUnit tu = new TransMemoryUnit();\n      tu.setTranslationMemory(tm);\n\n      TMXMetadataHelper.setMetadata(tu, tuElem, tm.getSourceLanguage());\n      tu.setVersionNum(0);\n\n      addTUVs(tu, tuElem.getChildElements(\"tuv\"));\n\n      tu.setUniqueId(determineUniqueId(tu));\n\n      removeExistingTUIfAny(tm.getSlug(), tu.getUniqueId());\n      entityManager.persist(tu);\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Persists the header elements when\n    * encountered while parsing. This modifies the translation memory fields and\n    * metadata.\n    */\n   public void persistHeader(TransMemory tm, Element headerElem)\n   {\n      TMXMetadataHelper.setMetadata(tm, headerElem);\n      entityManager.merge(tm);\n   }","id":274,"modified_method":"/**\n    * Persists the header elements when\n    * encountered while parsing. This modifies the translation memory fields and\n    * metadata.\n    */\n   public void processHeader(TransMemory tm, Element headerElem)\n   {\n      TMXMetadataHelper.setMetadata(tm, headerElem);\n      entityManager.merge(tm);\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"public @Nullable\n   TransMemoryUnit findTranslationUnit(@Nonnull String tmSlug, @Nonnull String uniqueId)\n   {\n\n      List results = getSession()\n            .createQuery(\"from TransMemoryUnit tu where tu.uniqueId = :uniqueId and tu.translationMemory.slug = :tmSlug\")\n            .setString(\"uniqueId\", uniqueId)\n            .setString(\"tmSlug\", tmSlug)\n            .list();\n      if( results.size() > 0 )\n      {\n         return (TransMemoryUnit)results.get(0);\n      }\n      return null;\n   }","id":275,"modified_method":"public @Nullable TransMemoryUnit findTranslationUnit(\n         @Nonnull String tmSlug, @Nonnull String uniqueId)\n   {\n      return (TransMemoryUnit) getSession()\n            .createQuery(\"from TransMemoryUnit tu where tu.uniqueId = :uniqueId and tu.translationMemory.slug = :tmSlug\")\n            .setString(\"uniqueId\", uniqueId)\n            .setString(\"tmSlug\", tmSlug)\n            .setCacheable(false)\n            .uniqueResult();\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\r\n   * Draws a string and checks mouse position.\r\n   * @param g graphics reference\r\n   * @param pre pre value\r\n   * @param x horizontal coordinate\r\n   * @param y vertical coordinate\r\n   */\r\n  void drawString(final Graphics g, final int pre, final int x, final int y) {\r\n    final Data data = gui.context.data();\r\n    final Nodes marked = gui.context.marked();\r\n\r\n    final int kind = data.kind(pre);\r\n    final boolean elem = kind == Data.ELEM || kind == Data.DOC;\r\n\r\n    Color col = Color.black;\r\n    Font fnt = font;\r\n    if(marked.find(pre) >= 0) {\r\n      // mark node\r\n      col = colormark3;\r\n      fnt = bfont;\r\n    }\r\n    if(y < -lineH) return;\r\n\r\n    g.setColor(color2);\r\n    g.drawLine(2, y + boxMargin - 1, totalW - 5, y + boxMargin - 1);\r\n\r\n    final boolean fs = data.fs != null;\r\n    final boolean file = fs && data.fs.isFile(pre);\r\n    final boolean dir = fs && data.fs.isDir(pre);\r\n    final byte[] name = file || dir ? ViewData.tag(data, pre) :\r\n      ViewData.content(data, pre, false);\r\n\r\n    int p = gui.focused;\r\n    while(p > pre) p = ViewData.parent(data, p);\r\n    if(pre == p) {\r\n      g.setColor(color3);\r\n      g.fillRect(0, y - boxW - boxMargin, totalW, lineH + 1);\r\n    }\r\n    int xx = x;\r\n    final int yy = y;\r\n\r\n    if(elem) {\r\n      if(fs) {\r\n        // print file icon\r\n        Image img = null;\r\n        if(file) {\r\n          img = GUIFS.images(name, 0);\r\n        } else if(dir) {\r\n          img = opened[pre] ? GUIFS.folder2[0] : GUIFS.folder1[0];\r\n        } else {\r\n          img = opened[pre] ? openedBox : closedBox;\r\n        }\r\n        g.drawImage(img, xx - lineH, yy - boxW - 1, this);\r\n        if(file || dir) xx += 5;\r\n      } else {\r\n        final Image box = opened[pre] ? openedBox : closedBox;\r\n        g.drawImage(box, xx - lineH, yy - boxW - 1, this);\r\n      }\r\n    }\r\n\r\n    g.setFont(fnt);\r\n    g.setColor(col);\r\n\r\n    int tw = totalW + 6;\r\n    if(file && tw - xx > 140) {\r\n      final long size = Token.toLong(data.fs.size(pre));\r\n      final String text = Performance.format(size, false);\r\n      tw -= BaseXLayout.width(g, text) + 10;\r\n      g.drawString(text, tw, yy);\r\n    }\r\n    BaseXLayout.chopString(g, name, xx, yy - GUIProp.fontsize, tw - xx - 10);\r\n\r\n    if(gui.focused == pre) {\r\n      g.setColor(color6);\r\n      g.drawRect(1, yy - boxW - boxMargin, totalW - 3, lineH + 1);\r\n      g.drawRect(2, yy - boxW - boxMargin + 1, totalW - 5, lineH - 1);\r\n    }\r\n  }","id":276,"modified_method":"/**\r\n   * Draws a string and checks mouse position.\r\n   * @param g graphics reference\r\n   * @param pre pre value\r\n   * @param x horizontal coordinate\r\n   * @param y vertical coordinate\r\n   */\r\n  void drawString(final Graphics g, final int pre, final int x, final int y) {\r\n    final Data data = gui.context.data();\r\n    final Nodes marked = gui.context.marked();\r\n\r\n    final int kind = data.kind(pre);\r\n    final boolean elem = kind == Data.ELEM || kind == Data.DOC;\r\n\r\n    Color col = Color.black;\r\n    Font fnt = font;\r\n    if(marked.find(pre) >= 0) {\r\n      // mark node\r\n      col = colormark3;\r\n      fnt = bfont;\r\n    }\r\n    if(y < -lineH) return;\r\n\r\n    g.setColor(color2);\r\n    g.drawLine(2, y + boxMargin - 1, totalW - 5, y + boxMargin - 1);\r\n\r\n    final boolean fs = data.fs != null;\r\n    final boolean file = fs && data.fs.isFile(pre);\r\n    final boolean dir = fs && data.fs.isDir(pre);\r\n    final byte[] name = file || dir ? ViewData.tag(data, pre) :\r\n      ViewData.content(data, pre, false);\r\n\r\n    int p = gui.focused;\r\n    while(p > pre) p = ViewData.parent(data, p);\r\n    if(pre == p) {\r\n      g.setColor(color3);\r\n      g.fillRect(0, y - boxW - boxMargin, totalW, lineH + 1);\r\n    }\r\n    int xx = x;\r\n\r\n    if(elem) {\r\n      final boolean large = GUIProp.fontsize > 20; \r\n      final int off = large ? 1 : 0;\r\n      final int yy = y - boxW - (large ? 6 : 3);\r\n      Image box = opened[pre] ? openedBox : closedBox;\r\n      // print file icon\r\n      if(file) {\r\n        box = GUIFS.images(name, off);\r\n      } else if(dir) {\r\n        box = opened[pre] ? GUIFS.folder2[off] : GUIFS.folder1[off];\r\n      }\r\n      g.drawImage(box, xx - lineH, yy, this);\r\n      if(fs && (file || dir)) xx += large ? 12 : 6;\r\n    }\r\n\r\n    g.setFont(fnt);\r\n    g.setColor(col);\r\n\r\n    int yy = y;\r\n    int tw = totalW + 6;\r\n    if(file && tw - xx > 140) {\r\n      final long size = Token.toLong(data.fs.size(pre));\r\n      final String text = Performance.format(size, false);\r\n      tw -= BaseXLayout.width(g, text) + 10;\r\n      g.drawString(text, tw, yy);\r\n    }\r\n    BaseXLayout.chopString(g, name, xx, yy - GUIProp.fontsize, tw - xx - 10);\r\n\r\n    if(gui.focused == pre) {\r\n      g.setColor(color6);\r\n      g.drawRect(1, yy - boxW - boxMargin, totalW - 3, lineH + 1);\r\n      g.drawRect(2, yy - boxW - boxMargin + 1, totalW - 5, lineH - 1);\r\n    }\r\n  }","commit_id":"717b53ac329bf94b3064235e6e27f96d39ef4958","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * Creates a button with custom background image and icon image.\n     *\n     * @param bgImage       The background image.\n     * @param pressedImage  The pressed image.\n     * @param iconImage     The icon.\n     */\n    public SIPCommButton(   Image bgImage,\n                            Image pressedImage,\n                            Image iconImage)\n    {\n        this(bgImage, null, pressedImage, iconImage);\n    }","id":277,"modified_method":"/**\n     * Creates a button with custom background image and icon image.\n     *\n     * @param bgImage       The background image.\n     * @param pressedImage  The pressed image.\n     * @param iconImage     The icon.\n     */\n    public SIPCommButton(   Image bgImage,\n                            Image pressedImage,\n                            Image iconImage)\n    {\n        this(bgImage, pressedImage, iconImage, null, null);\n    }","commit_id":"c1bb719f68828ad6c5a2b22a65afc0b9c7d90e69","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the rollover image of this button.\n     *\n     * @param rolloverImage the rollover image of this button.\n     */\n    public void setRolloverImage(Image rolloverImage)\n    {\n        this.rolloverImage = rolloverImage;\n    }","id":278,"modified_method":"/**\n     * Sets the rollover icon image of this button.\n     *\n     * @param rolloverIconImage the rollover icon image of this button.\n     */\n    public void setRolloverIcon(Image rolloverIconImage)\n    {\n        this.rolloverIconImage = rolloverIconImage;\n    }","commit_id":"c1bb719f68828ad6c5a2b22a65afc0b9c7d90e69","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Paints this button.\n     * @param g the <tt>Graphics<\/tt> object used for painting\n     */\n    private void internalPaintComponent(Graphics g)\n    {\n        AntialiasingManager.activateAntialiasing(g);\n        /*\n         * As JComponent#paintComponent says, if you do not invoke super's\n         * implementation you must honor the opaque property, that is if this\n         * component is opaque, you must completely fill in the background in a\n         * non-opaque color. If you do not honor the opaque property you will\n         * likely see visual artifacts.\n         */\n        if (isOpaque())\n        {\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n\n        if (this.bgImage != null)\n        {\n            // If there's no icon, we make grey the backgroundImage\n            // when disabled.\n            Image paintBgImage;\n            if (this.iconImage == null && !isEnabled())\n            {\n                paintBgImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(bgImage)).getImage();\n            }\n            else\n                paintBgImage = bgImage;\n\n            g.drawImage(paintBgImage,\n                        this.getWidth()/2 - this.bgImage.getWidth(null)/2,\n                        this.getHeight()/2 - this.bgImage.getHeight(null)/2,\n                        this);\n        }\n\n        // Paint pressed state.\n        if (this.getModel().isPressed())\n        {\n            if (this.pressedImage != null)\n            {\n                g.drawImage(this.pressedImage, 0, 0, this);\n            }\n            else if (this.iconImage != null)\n            {\n                g.drawImage(this.iconImage,\n                    this.getWidth()/2 - this.iconImage.getWidth(null)/2 + 1,\n                    this.getHeight()/2 - this.iconImage.getHeight(null)/2 + 1,\n                    this);\n            }\n        }\n        else if (this.getModel().isRollover() && this.rolloverImage != null)\n        {\n            g.drawImage(this.rolloverImage, 0, 0, this);\n        }\n\n        if (rolloverImage == null)\n        {\n         // Paint a roll over fade out.\n            FadeTracker fadeTracker = FadeTracker.getInstance();\n\n            float visibility = this.getModel().isRollover() ? 1.0f : 0.0f;\n            if (fadeTracker.isTracked(this, FadeKind.ROLLOVER))\n            {\n                visibility = fadeTracker.getFade(this, FadeKind.ROLLOVER);\n            }\n\n            visibility /= 2;\n\n            g.setColor(new Color(1.0f, 1.0f, 1.0f, visibility));\n\n            if (this.bgImage != null)\n            {\n                g.fillRoundRect(\n                    this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,\n                    this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,\n                    bgImage.getWidth(null),\n                    bgImage.getHeight(null),\n                    10, 10);\n            }\n            else if (isContentAreaFilled() || (visibility != 0.0f))\n            {\n                g.fillRoundRect(\n                    0, 0, this.getWidth(), this.getHeight(), 10, 10);\n            }\n        }\n\n        if (this.iconImage != null)\n        {\n            Image paintIconImage;\n            if (!isEnabled())\n            {\n                paintIconImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(iconImage)).getImage();\n            }\n            else\n                paintIconImage = iconImage;\n\n            g.drawImage(paintIconImage,\n                        this.getWidth()/2 - this.iconImage.getWidth(null)/2,\n                        this.getHeight()/2 - this.iconImage.getHeight(null)/2,\n                        this);\n        }\n    }","id":279,"modified_method":"/**\n     * Paints this button.\n     * @param g the <tt>Graphics<\/tt> object used for painting\n     */\n    private void internalPaintComponent(Graphics g)\n    {\n        AntialiasingManager.activateAntialiasing(g);\n        /*\n         * As JComponent#paintComponent says, if you do not invoke super's\n         * implementation you must honor the opaque property, that is if this\n         * component is opaque, you must completely fill in the background in a\n         * non-opaque color. If you do not honor the opaque property you will\n         * likely see visual artifacts.\n         */\n        if (isOpaque())\n        {\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n\n        if (this.bgImage != null)\n        {\n            // If there's no icon, we make grey the backgroundImage\n            // when disabled.\n            Image paintBgImage;\n            if (this.iconImage == null && !isEnabled())\n            {\n                paintBgImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(bgImage)).getImage();\n            }\n            else\n                paintBgImage = bgImage;\n\n            g.drawImage(paintBgImage,\n                        this.getWidth()/2 - this.bgImage.getWidth(null)/2,\n                        this.getHeight()/2 - this.bgImage.getHeight(null)/2,\n                        this);\n        }\n\n        // Paint pressed state.\n        if (this.getModel().isPressed() && this.pressedImage != null)\n        {\n            g.drawImage(this.pressedImage, 0, 0, this);\n        }\n\n        // Paint a roll over fade out.\n        FadeTracker fadeTracker = FadeTracker.getInstance();\n\n        float visibility = this.getModel().isRollover() ? 1.0f : 0.0f;\n        if (fadeTracker.isTracked(this, FadeKind.ROLLOVER))\n        {\n            visibility = fadeTracker.getFade(this, FadeKind.ROLLOVER);\n        }\n\n        visibility /= 2;\n\n        g.setColor(new Color(1.0f, 1.0f, 1.0f, visibility));\n\n        if (this.bgImage != null)\n        {\n            g.fillRoundRect(\n                this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,\n                this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,\n                bgImage.getWidth(null),\n                bgImage.getHeight(null),\n                10, 10);\n        }\n        else if (isContentAreaFilled() || (visibility != 0.0f))\n        {\n            g.fillRoundRect(\n                0, 0, this.getWidth(), this.getHeight(), 10, 10);\n        }\n\n        Image paintIconImage = null;\n        if (getModel().isPressed() && pressedIconImage != null)\n        {\n            paintIconImage = pressedIconImage;\n        }\n        else if (this.getModel().isRollover() && rolloverIconImage != null)\n        {\n            paintIconImage = rolloverIconImage;\n        }\n        else if (this.iconImage != null)\n        {\n            if (!isEnabled())\n            {\n                paintIconImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(iconImage)).getImage();\n            }\n            else\n                paintIconImage = iconImage;\n        }\n\n        if (paintIconImage != null)\n            g.drawImage(paintIconImage,\n                this.getWidth()/2 - this.iconImage.getWidth(null)/2,\n                this.getHeight()/2 - this.iconImage.getHeight(null)/2,\n                this);\n    }","commit_id":"c1bb719f68828ad6c5a2b22a65afc0b9c7d90e69","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a button with custom background image and icon image.\n     *\n     * @param bgImage       The background image.\n     * @param rolloverImage The rollover image.\n     * @param pressedImage  The pressed image.\n     * @param iconImage     The icon.\n     */\n    public SIPCommButton(   Image bgImage,\n                            Image rolloverImage,\n                            Image pressedImage,\n                            Image iconImage)\n    {\n        MouseRolloverHandler mouseHandler = new MouseRolloverHandler();\n\n        this.addMouseListener(mouseHandler);\n        this.addMouseMotionListener(mouseHandler);\n\n        /*\n         * Explicitly remove all borders that may be set from the current look\n         * and feel.\n         */\n        this.setBorder(null);\n        this.setContentAreaFilled(false);\n\n        this.bgImage = bgImage;\n        this.rolloverImage = rolloverImage;\n        this.pressedImage = pressedImage;\n        this.iconImage = iconImage;\n\n        if (bgImage != null)\n        {\n            this.setPreferredSize(new Dimension(bgImage.getWidth(null),\n                                                bgImage.getHeight(null)));\n\n            this.setIcon(new ImageIcon(this.bgImage));\n        }\n    }","id":280,"modified_method":"/**\n     * Creates a button with custom background image and icon image.\n     *\n     * @param bgImage       The background image.\n     * @param pressedImage  The pressed image.\n     * @param iconImage     The icon.\n     * @param rolloverIconImage The rollover icon image.\n     * @param pressedIconImage The pressed icon image.\n     */\n    public SIPCommButton(   Image bgImage,\n                            Image pressedImage,\n                            Image iconImage,\n                            Image rolloverIconImage,\n                            Image pressedIconImage)\n    {\n        MouseRolloverHandler mouseHandler = new MouseRolloverHandler();\n\n        this.addMouseListener(mouseHandler);\n        this.addMouseMotionListener(mouseHandler);\n\n        /*\n         * Explicitly remove all borders that may be set from the current look\n         * and feel.\n         */\n        this.setContentAreaFilled(false);\n\n        this.bgImage = bgImage;\n        this.rolloverIconImage = rolloverIconImage;\n        this.pressedIconImage = pressedIconImage;\n        this.pressedImage = pressedImage;\n        this.iconImage = iconImage;\n\n        if (bgImage != null)\n        {\n            this.setPreferredSize(new Dimension(bgImage.getWidth(null),\n                                                bgImage.getHeight(null)));\n\n            this.setIcon(new ImageIcon(this.bgImage));\n        }\n    }","commit_id":"c1bb719f68828ad6c5a2b22a65afc0b9c7d90e69","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Paints this button.\n     * @param g the <tt>Graphics<\/tt> object used for painting\n     */\n    private void internalPaintComponent(Graphics g)\n    {\n        AntialiasingManager.activateAntialiasing(g);\n        /*\n         * As JComponent#paintComponent says, if you do not invoke super's\n         * implementation you must honor the opaque property, that is if this\n         * component is opaque, you must completely fill in the background in a\n         * non-opaque color. If you do not honor the opaque property you will\n         * likely see visual artifacts.\n         */\n        if (isOpaque())\n        {\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n\n        if (this.bgImage != null)\n        {\n            // If there's no icon, we make grey the backgroundImage\n            // when disabled.\n            Image paintBgImage;\n            if (this.iconImage == null && !isEnabled())\n            {\n                paintBgImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(bgImage)).getImage();\n            }\n            else\n                paintBgImage = bgImage;\n\n            g.drawImage(paintBgImage,\n                        this.getWidth()/2 - paintBgImage.getWidth(null)/2,\n                        this.getHeight()/2 - paintBgImage.getHeight(null)/2,\n                        this);\n        }\n\n        // Paint a roll over fade out.\n        if (rolloverImage == null)\n        {\n            FadeTracker fadeTracker = FadeTracker.getInstance();\n\n            float visibility = this.getModel().isRollover() ? 1.0f : 0.0f;\n            if (fadeTracker.isTracked(this, FadeKind.ROLLOVER))\n            {\n                visibility = fadeTracker.getFade(this, FadeKind.ROLLOVER);\n            }\n\n            visibility /= 2;\n\n            g.setColor(new Color(1.0f, 1.0f, 1.0f, visibility));\n\n            if (this.bgImage == null\n                && (isContentAreaFilled() || (visibility != 0.0f)))\n            {\n                g.fillRoundRect(\n                    0, 0, this.getWidth(), this.getHeight(), 8, 8);\n            }\n        }\n\n        // Paint pressed state.\n        if (this.getModel().isPressed() && this.pressedImage != null)\n        {\n            g.drawImage(this.pressedImage, 0, 0, this);\n        }\n        else if (this.getModel().isRollover() && this.rolloverImage != null)\n        {\n            g.drawImage(this.rolloverImage, 0, 0, this);\n        }\n\n        Image paintIconImage = null;\n        if (getModel().isPressed() && pressedIconImage != null)\n        {\n            paintIconImage = pressedIconImage;\n        }\n        else if (this.getModel().isRollover() && rolloverIconImage != null)\n        {\n            paintIconImage = rolloverIconImage;\n        }\n        else if (this.iconImage != null)\n        {\n            if (!isEnabled())\n            {\n                paintIconImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(iconImage)).getImage();\n            }\n            else\n                paintIconImage = iconImage;\n        }\n\n        if (paintIconImage != null)\n            g.drawImage(paintIconImage,\n                this.getWidth()/2 - paintIconImage.getWidth(null)/2,\n                this.getHeight()/2 - paintIconImage.getHeight(null)/2,\n                this);\n    }","id":281,"modified_method":"/**\n     * Paints this button.\n     * @param g the <tt>Graphics<\/tt> object used for painting\n     */\n    private void internalPaintComponent(Graphics g)\n    {\n        AntialiasingManager.activateAntialiasing(g);\n        /*\n         * As JComponent#paintComponent says, if you do not invoke super's\n         * implementation you must honor the opaque property, that is if this\n         * component is opaque, you must completely fill in the background in a\n         * non-opaque color. If you do not honor the opaque property you will\n         * likely see visual artifacts.\n         */\n        if (isOpaque())\n        {\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n\n        // Paint pressed state.\n        Image paintBgImage = null;\n        if (this.getModel().isPressed() && this.pressedBgImage != null)\n        {\n            paintBgImage = this.pressedBgImage;\n        }\n        else if (this.getModel().isRollover() && this.rolloverBgImage != null)\n        {\n            paintBgImage = this.rolloverBgImage;\n        }\n        else if (this.bgImage != null)\n        {\n            // If there's no icon, we make grey the backgroundImage\n            // when disabled.\n            if (this.iconImage == null && !isEnabled())\n            {\n                paintBgImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(bgImage)).getImage();\n            }\n            else\n                paintBgImage = bgImage;\n        }\n\n        if (paintBgImage != null)\n        {\n            g.drawImage(paintBgImage,\n                        this.getWidth()/2 - paintBgImage.getWidth(null)/2,\n                        this.getHeight()/2 - paintBgImage.getHeight(null)/2,\n                        this);\n        }\n\n        // Paint a roll over fade out.\n        if (rolloverBgImage == null)\n        {\n            FadeTracker fadeTracker = FadeTracker.getInstance();\n\n            float visibility = this.getModel().isRollover() ? 1.0f : 0.0f;\n            if (fadeTracker.isTracked(this, FadeKind.ROLLOVER))\n            {\n                visibility = fadeTracker.getFade(this, FadeKind.ROLLOVER);\n            }\n\n            visibility /= 2;\n\n            g.setColor(new Color(1.0f, 1.0f, 1.0f, visibility));\n\n            if (this.bgImage == null\n                && (isContentAreaFilled() || (visibility != 0.0f)))\n            {\n                g.fillRoundRect(\n                    0, 0, this.getWidth(), this.getHeight(), 8, 8);\n            }\n        }\n\n        Image paintIconImage = null;\n        if (getModel().isPressed() && pressedIconImage != null)\n        {\n            paintIconImage = pressedIconImage;\n        }\n        else if (this.getModel().isRollover() && rolloverIconImage != null)\n        {\n            paintIconImage = rolloverIconImage;\n        }\n        else if (this.iconImage != null)\n        {\n            if (!isEnabled())\n            {\n                paintIconImage = new ImageIcon(LightGrayFilter\n                        .createDisabledImage(iconImage)).getImage();\n            }\n            else\n                paintIconImage = iconImage;\n        }\n\n        if (paintIconImage != null)\n            g.drawImage(paintIconImage,\n                this.getWidth()/2 - paintIconImage.getWidth(null)/2,\n                this.getHeight()/2 - paintIconImage.getHeight(null)/2,\n                this);\n    }","commit_id":"99f600eb84e4fc19f3506498e985333b8672f800","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the pressed image of this button.\n     *\n     * @param pressedImage the pressed image of this button.\n     */\n    public void setPressedImage(Image pressedImage)\n    {\n        this.pressedImage = pressedImage;\n    }","id":282,"modified_method":"/**\n     * Sets the pressed background image of this button.\n     *\n     * @param pressedImage the pressed background image of this button.\n     */\n    public void setPressedImage(Image pressedImage)\n    {\n        this.pressedBgImage = pressedImage;\n    }","commit_id":"99f600eb84e4fc19f3506498e985333b8672f800","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a button with custom background image and icon image.\n     *\n     * @param bgImage       The background image.\n     * @param rolloverImage The rollover background image.\n     * @param pressedImage  The pressed image.\n     * @param iconImage     The icon.\n     * @param rolloverIconImage The rollover icon image.\n     * @param pressedIconImage The pressed icon image.\n     */\n    public SIPCommButton(   Image bgImage,\n                            Image rolloverImage,\n                            Image pressedImage,\n                            Image iconImage,\n                            Image rolloverIconImage,\n                            Image pressedIconImage)\n    {\n        MouseRolloverHandler mouseHandler = new MouseRolloverHandler();\n\n        this.addMouseListener(mouseHandler);\n        this.addMouseMotionListener(mouseHandler);\n\n        /*\n         * Explicitly remove all borders that may be set from the current look\n         * and feel.\n         */\n        this.setContentAreaFilled(false);\n        this.setBorder(null);\n\n        this.bgImage = bgImage;\n        this.rolloverImage = rolloverImage;\n        this.pressedImage = pressedImage;\n        this.rolloverIconImage = rolloverIconImage;\n        this.pressedIconImage = pressedIconImage;\n        this.iconImage = iconImage;\n\n        if (bgImage != null)\n        {\n            this.setPreferredSize(new Dimension(bgImage.getWidth(null),\n                                                bgImage.getHeight(null)));\n\n            this.setIcon(new ImageIcon(this.bgImage));\n        }\n    }","id":283,"modified_method":"/**\n     * Creates a button with custom background image and icon image.\n     *\n     * @param bgImage       The background image.\n     * @param rolloverImage The rollover background image.\n     * @param pressedImage  The pressed image.\n     * @param iconImage     The icon.\n     * @param rolloverIconImage The rollover icon image.\n     * @param pressedIconImage The pressed icon image.\n     */\n    public SIPCommButton(   Image bgImage,\n                            Image rolloverImage,\n                            Image pressedImage,\n                            Image iconImage,\n                            Image rolloverIconImage,\n                            Image pressedIconImage)\n    {\n        MouseRolloverHandler mouseHandler = new MouseRolloverHandler();\n\n        this.addMouseListener(mouseHandler);\n        this.addMouseMotionListener(mouseHandler);\n\n        /*\n         * Explicitly remove all borders that may be set from the current look\n         * and feel.\n         */\n        this.setContentAreaFilled(false);\n        this.setBorder(null);\n\n        this.bgImage = bgImage;\n        this.rolloverBgImage = rolloverImage;\n        this.pressedBgImage = pressedImage;\n        this.rolloverIconImage = rolloverIconImage;\n        this.pressedIconImage = pressedIconImage;\n        this.iconImage = iconImage;\n\n        if (bgImage != null)\n        {\n            this.setPreferredSize(new Dimension(bgImage.getWidth(null),\n                                                bgImage.getHeight(null)));\n\n            this.setIcon(new ImageIcon(this.bgImage));\n        }\n    }","commit_id":"99f600eb84e4fc19f3506498e985333b8672f800","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the rollover background image of this button.\n     *\n     * @param rolloverImage the rollover background image of this button.\n     */\n    public void setRolloverImage(Image rolloverImage)\n    {\n        this.rolloverImage = rolloverImage;\n    }","id":284,"modified_method":"/**\n     * Sets the rollover background image of this button.\n     *\n     * @param rolloverImage the rollover background image of this button.\n     */\n    public void setRolloverImage(Image rolloverImage)\n    {\n        this.rolloverBgImage = rolloverImage;\n    }","commit_id":"99f600eb84e4fc19f3506498e985333b8672f800","url":"https://github.com/jitsi/jitsi"},{"original_method":"@NotNull\n  protected GlobalSearchScope getSearchScope() {\n    final TestData data = myConfig.getPersistantData();\n    final Module module = myConfig.getConfigurationModule().getModule();\n    return data.TEST_OBJECT.equals(TestType.PACKAGE.getType())\n           ? myConfig.getPersistantData().getScope().getSourceScope(myConfig).getGlobalSearchScope()\n           : module != null ? GlobalSearchScope.moduleWithDependenciesScope(module) : GlobalSearchScope.projectScope(myConfig.getProject());\n  }","id":285,"modified_method":"@NotNull\n  protected GlobalSearchScope getSearchScope() {\n    final TestData data = myConfig.getPersistantData();\n    final Module module = myConfig.getConfigurationModule().getModule();\n    if (data.TEST_OBJECT.equals(TestType.PACKAGE.getType())) {\n      SourceScope scope = myConfig.getPersistantData().getScope().getSourceScope(myConfig);\n      if (scope != null) {\n        return scope.getGlobalSearchScope();\n      }\n    }\n    else if (module != null) {\n      return GlobalSearchScope.moduleWithDependenciesScope(module);\n    }\n    return GlobalSearchScope.projectScope(myConfig.getProject());\n  }","commit_id":"e00caa280b3980702c0a65aa138b4d46a49a115d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes) throws CantRunException {\n    final String packageName = myConfig.getPersistantData().getPackageName();\n    PsiPackage psiPackage = ApplicationManager.getApplication().runReadAction(\n      new Computable<PsiPackage>() {\n        @Nullable\n        public PsiPackage compute() {\n          return JavaPsiFacade.getInstance(myConfig.getProject()).findPackage(packageName);\n        }\n      }\n    );\n    if (psiPackage == null) {\n      throw CantRunException.packageNotFound(packageName);\n    }\n    else {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      //TODO we should narrow this down by module really, if that's what's specified\n      TestClassFilter projectFilter =\n        new TestClassFilter(scope.getSourceScope(myConfig).getGlobalSearchScope(), myConfig.getProject(), true, true);\n      TestClassFilter filter = projectFilter.intersectionWith(PackageScope.packageScope(psiPackage, true));\n      calculateDependencies(null, classes, getSearchScope(), TestNGUtil.getAllTestClasses(filter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in the package \\\"\" + packageName + '\\\"');\n      }\n    }\n  }","id":286,"modified_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes) throws CantRunException {\n    final String packageName = myConfig.getPersistantData().getPackageName();\n    PsiPackage psiPackage = ApplicationManager.getApplication().runReadAction(\n      new Computable<PsiPackage>() {\n        @Nullable\n        public PsiPackage compute() {\n          return JavaPsiFacade.getInstance(myConfig.getProject()).findPackage(packageName);\n        }\n      }\n    );\n    if (psiPackage == null) {\n      throw CantRunException.packageNotFound(packageName);\n    }\n    else {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      //TODO we should narrow this down by module really, if that's what's specified\n      SourceScope sourceScope = scope.getSourceScope(myConfig);\n      TestClassFilter projectFilter =\n        new TestClassFilter(sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.projectScope(myConfig.getProject()), myConfig.getProject(), true, true);\n      TestClassFilter filter = projectFilter.intersectionWith(PackageScope.packageScope(psiPackage, true));\n      calculateDependencies(null, classes, getSearchScope(), TestNGUtil.getAllTestClasses(filter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in the package \\\"\" + packageName + '\\\"');\n      }\n    }\n  }","commit_id":"e00caa280b3980702c0a65aa138b4d46a49a115d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected GlobalSearchScope initScope() {\n    final String testObject = myConfiguration.getPersistantData().TEST_OBJECT;\n    if (TestType.CLASS.getType().equals(testObject) ||\n        TestType.METHOD.getType().equals(testObject)) {\n      return super.initScope();\n    }\n    else {\n      return myConfiguration.getPersistantData().getScope().getSourceScope(myConfiguration).getGlobalSearchScope();\n    }\n  }","id":287,"modified_method":"@NotNull\n  @Override\n  protected GlobalSearchScope initScope() {\n    final String testObject = myConfiguration.getPersistantData().TEST_OBJECT;\n    if (TestType.CLASS.getType().equals(testObject) ||\n        TestType.METHOD.getType().equals(testObject)) {\n      return super.initScope();\n    }\n    else {\n      final SourceScope sourceScope = myConfiguration.getPersistantData().getScope().getSourceScope(myConfiguration);\n      return sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.allScope(getProject());\n    }\n  }","commit_id":"ef27a59a57e5d11ef9b43dffdf65c2d0259135f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    //for a group, we include all classes\n    final TestClassFilter classFilter =\n      new TestClassFilter(data.getScope().getSourceScope(myConfig).getGlobalSearchScope(), myConfig.getProject(), true, true);\n    PsiClass[] testClasses = TestNGUtil.getAllTestClasses(classFilter, false);\n    if (testClasses != null) {\n      for (PsiClass c : testClasses) {\n        classes.put(c, new LinkedHashMap<PsiMethod, List<String>>());\n      }\n    }\n  }","id":288,"modified_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    //for a group, we include all classes\n    final SourceScope sourceScope = data.getScope().getSourceScope(myConfig);\n    final TestClassFilter classFilter =\n      new TestClassFilter(sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.allScope(myConfig.getProject()),\n                          myConfig.getProject(), true, true);\n    PsiClass[] testClasses = TestNGUtil.getAllTestClasses(classFilter, false);\n    if (testClasses != null) {\n      for (PsiClass c : testClasses) {\n        classes.put(c, new LinkedHashMap<PsiMethod, List<String>>());\n      }\n    }\n  }","commit_id":"ef27a59a57e5d11ef9b43dffdf65c2d0259135f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    for (final String pattern : data.getPatterns()) {\n      final String className;\n      final String methodName;\n      if (pattern.contains(\",\")) {\n        methodName = StringUtil.getShortName(pattern, ',');\n        className = StringUtil.getPackageName(pattern, ',');\n      } else {\n        className = pattern;\n        methodName = null;\n      }\n\n      final PsiClass psiClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n        @Nullable\n        @Override\n        public PsiClass compute() {\n          return ClassUtil.findPsiClass(PsiManager.getInstance(myConfig.getProject()), className.replace('/', '.'), null, true, getSearchScope());\n        }\n      });\n      if (psiClass != null) {\n        final Boolean hasTest = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            return TestNGUtil.hasTest(psiClass);\n          }\n        });\n        if (hasTest) {\n          if (StringUtil.isEmpty(methodName)) {\n            calculateDependencies(null, classes, psiClass);\n          }\n          else {\n            collectTestMethods(classes, psiClass, methodName);\n          }\n        } else {\n          throw new CantRunException(\"No tests found in class \" + className);\n        }\n      }\n    }\n    if (classes.size() != data.getPatterns().size()) {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      final List<Pattern> compilePatterns = new ArrayList<Pattern>();\n      for (String p : data.getPatterns()) {\n        final Pattern compilePattern;\n        try {\n          compilePattern = Pattern.compile(p);\n        }\n        catch (PatternSyntaxException e) {\n          continue;\n        }\n        if (compilePattern != null) {\n          compilePatterns.add(compilePattern);\n        }\n      }\n      TestClassFilter projectFilter =\n        new TestClassFilter(scope.getSourceScope(myConfig).getGlobalSearchScope(), myConfig.getProject(), true, true){\n          @Override\n          public boolean isAccepted(PsiClass psiClass) {\n            if (super.isAccepted(psiClass)) {\n              final String qualifiedName = psiClass.getQualifiedName();\n              LOG.assertTrue(qualifiedName != null);\n              for (Pattern pattern : compilePatterns) {\n                if (pattern.matcher(qualifiedName).matches()) return true;\n              }\n            }\n            return false;\n          }\n        };\n      calculateDependencies(null, classes, TestNGUtil.getAllTestClasses(projectFilter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in for patterns \\\"\" + StringUtil.join(data.getPatterns(), \" || \") + '\\\"');\n      }\n    }\n  }","id":289,"modified_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    for (final String pattern : data.getPatterns()) {\n      final String className;\n      final String methodName;\n      if (pattern.contains(\",\")) {\n        methodName = StringUtil.getShortName(pattern, ',');\n        className = StringUtil.getPackageName(pattern, ',');\n      } else {\n        className = pattern;\n        methodName = null;\n      }\n\n      final PsiClass psiClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n        @Nullable\n        @Override\n        public PsiClass compute() {\n          return ClassUtil.findPsiClass(PsiManager.getInstance(myConfig.getProject()), className.replace('/', '.'), null, true, getSearchScope());\n        }\n      });\n      if (psiClass != null) {\n        final Boolean hasTest = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            return TestNGUtil.hasTest(psiClass);\n          }\n        });\n        if (hasTest) {\n          if (StringUtil.isEmpty(methodName)) {\n            calculateDependencies(null, classes, psiClass);\n          }\n          else {\n            collectTestMethods(classes, psiClass, methodName);\n          }\n        } else {\n          throw new CantRunException(\"No tests found in class \" + className);\n        }\n      }\n    }\n    if (classes.size() != data.getPatterns().size()) {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      final List<Pattern> compilePatterns = new ArrayList<Pattern>();\n      for (String p : data.getPatterns()) {\n        final Pattern compilePattern;\n        try {\n          compilePattern = Pattern.compile(p);\n        }\n        catch (PatternSyntaxException e) {\n          continue;\n        }\n        compilePatterns.add(compilePattern);\n      }\n      final SourceScope sourceScope = scope.getSourceScope(myConfig);\n      TestClassFilter projectFilter =\n        new TestClassFilter(sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.allScope(myConfig.getProject()), myConfig.getProject(), true, true){\n          @Override\n          public boolean isAccepted(PsiClass psiClass) {\n            if (super.isAccepted(psiClass)) {\n              final String qualifiedName = psiClass.getQualifiedName();\n              LOG.assertTrue(qualifiedName != null);\n              for (Pattern pattern : compilePatterns) {\n                if (pattern.matcher(qualifiedName).matches()) return true;\n              }\n            }\n            return false;\n          }\n        };\n      calculateDependencies(null, classes, TestNGUtil.getAllTestClasses(projectFilter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in for patterns \\\"\" + StringUtil.join(data.getPatterns(), \" || \") + '\\\"');\n      }\n    }\n  }","commit_id":"ef27a59a57e5d11ef9b43dffdf65c2d0259135f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void initializeLater(Procedure1<JvmDeclaredType> lateInitialization) {\n\t\t\tif (lateInitialization != null && lastAccepted != null) {\n\t\t\t\tlater.add(new Pair<JvmDeclaredType, Procedure1<JvmDeclaredType>>(lastAccepted, lateInitialization));\n\t\t\t}\n\t\t}","id":290,"modified_method":"public void initializeLater(Procedure1<? super JvmDeclaredType> lateInitialization) {\n\t\t\tif (lateInitialization != null && lastAccepted != null) {\n\t\t\t\tlater.add(new Pair<JvmDeclaredType, Procedure1<? super JvmDeclaredType>>(lastAccepted, lateInitialization));\n\t\t\t}\n\t\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"public void installDerivedState(final DerivedStateAwareResource resource, boolean preIndexingPhase) {\n\t\tif (resource.getContents().isEmpty())\n\t\t\treturn;\n\t\tEObject eObject = resource.getContents().get(0);\n\t\tJvmDeclaredTypeAcceptor acceptor = new JvmDeclaredTypeAcceptor(resource);\n\t\tinferrer.infer(eObject, acceptor, preIndexingPhase);\n\t\tif (!preIndexingPhase) {\n\t\t\tfor (Pair<JvmDeclaredType, Procedure1<JvmDeclaredType>> initializer: acceptor.later) {\n\t\t\t\tinitializer.getValue().apply(initializer.getKey());\n\t\t\t\tcompleter.complete(initializer.getKey());\n\t\t\t}\n\t\t}\n\t}","id":291,"modified_method":"public void installDerivedState(final DerivedStateAwareResource resource, boolean preIndexingPhase) {\n\t\tif (resource.getContents().isEmpty())\n\t\t\treturn;\n\t\tEObject eObject = resource.getContents().get(0);\n\t\tJvmDeclaredTypeAcceptor acceptor = new JvmDeclaredTypeAcceptor(resource);\n\t\tinferrer.infer(eObject, acceptor, preIndexingPhase);\n\t\tif (!preIndexingPhase) {\n\t\t\tfor (Pair<JvmDeclaredType, Procedure1<? super JvmDeclaredType>> initializer: acceptor.later) {\n\t\t\t\tinitializer.getValue().apply(initializer.getKey());\n\t\t\t\tcompleter.complete(initializer.getKey());\n\t\t\t}\n\t\t}\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Same as {@link #toEnumerationLiteral(EObject, String)} but with an initializer passed as the last argument.\n\t */\n\t@Nullable \n\tpublic JvmEnumerationLiteral toEnumerationLiteral(@Nullable EObject sourceElement, @Nullable String name, \n\t\t\t@Nullable Procedure1<JvmEnumerationLiteral> initializer) {\n\t\tif (sourceElement == null || name == null)\n\t\t\treturn null;\n\t\tJvmEnumerationLiteral result = typesFactory.createJvmEnumerationLiteral();\n\t\tresult.setSimpleName(name);\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\t\treturn result;\n\t}","id":292,"modified_method":"/**\n\t * Same as {@link #toEnumerationLiteral(EObject, String)} but with an initializer passed as the last argument.\n\t */\n\t@Nullable \n\tpublic JvmEnumerationLiteral toEnumerationLiteral(@Nullable EObject sourceElement, @Nullable String name, \n\t\t\t@Nullable Procedure1<? super JvmEnumerationLiteral> initializer) {\n\t\tif (sourceElement == null || name == null)\n\t\t\treturn null;\n\t\tJvmEnumerationLiteral result = typesFactory.createJvmEnumerationLiteral();\n\t\tresult.setSimpleName(name);\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tassociate(sourceElement, result);\n\t\treturn initializeSafely(result, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public annotation declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created annotation. If <code>null<\/code>, the annotation won't be initialized.\n\t * \n\t * @return a {@link JvmAnnotationType} representing a Java annotation of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmAnnotationType toAnnotationType(@Nullable EObject sourceElement, @Nullable String name, \n\t\t\t@Nullable Procedure1<JvmAnnotationType> initializer) {\n\t\tif (sourceElement == null || name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmAnnotationType annotationType = typesFactory.createJvmAnnotationType();\n\t\tannotationType.setSimpleName(fullName.getSecond());\n\t\tif (fullName.getFirst() != null)\n\t\t\tannotationType.setPackageName(fullName.getFirst());\n\t\tassociate(sourceElement, annotationType);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(annotationType);\n\t\treturn annotationType;\n\t}","id":293,"modified_method":"/**\n\t * Creates a public annotation declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created annotation. If <code>null<\/code>, the annotation won't be initialized.\n\t * \n\t * @return a {@link JvmAnnotationType} representing a Java annotation of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmAnnotationType toAnnotationType(@Nullable EObject sourceElement, @Nullable String name, \n\t\t\t@Nullable Procedure1<? super JvmAnnotationType> initializer) {\n\t\tif (sourceElement == null || name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmAnnotationType annotationType = typesFactory.createJvmAnnotationType();\n\t\tannotationType.setSimpleName(fullName.getSecond());\n\t\tif (fullName.getFirst() != null)\n\t\t\tannotationType.setPackageName(fullName.getFirst());\n\t\tassociate(sourceElement, annotationType);\n\t\treturn initializeSafely(annotationType, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public interface declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created interface element. If <code>null<\/code>, the interface won't be initialized.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmGenericType toInterface(@Nullable EObject sourceElement, @Nullable String name, @Nullable Procedure1<JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tresult.setInterface(true);\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\t\treturn result;\n\t}","id":294,"modified_method":"/**\n\t * Creates a public interface declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created interface element. If <code>null<\/code>, the interface won't be initialized.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmGenericType toInterface(@Nullable EObject sourceElement, @Nullable String name, @Nullable Procedure1<? super JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tresult.setInterface(true);\n\t\tassociate(sourceElement, result);\n\t\treturn initializeSafely(result, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public method with the given name and the given return type and associates it with the given\n\t * sourceElement.\n\t * \n\t * @param sourceElement \n\t * \t\tthe sourceElement the method should be associated with.\n\t * @param name\n\t * \t\tthe simple name of the method to be created.\n\t * @param returnType\n\t * \t\tthe return type of the created method.\n\t * @param initializer\n\t *            the initializer to apply on the created method. If <code>null<\/code>, the method won't be initialized.\n\t * \n\t * @return a result representing a Java method with the given name, <code>null<\/code> if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable\n\tpublic JvmOperation toMethod(@Nullable EObject sourceElement, @Nullable String name, @Nullable JvmTypeReference returnType,\n\t\t\t@Nullable Procedure1<JvmOperation> initializer) {\n\t\tif(sourceElement == null || name == null) \n\t\t\treturn null;\n\t\tJvmOperation result = typesFactory.createJvmOperation();\n\t\tresult.setSimpleName(name);\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tresult.setReturnType(cloneWithProxies(returnType));\n\t\tassociate(sourceElement, result);\n\t\tif (initializer != null)\n\t\t\tinitializer.apply(result);\n\t\treturn result;\n\t}","id":295,"modified_method":"/**\n\t * Creates a public method with the given name and the given return type and associates it with the given\n\t * sourceElement.\n\t * \n\t * @param sourceElement \n\t * \t\tthe sourceElement the method should be associated with.\n\t * @param name\n\t * \t\tthe simple name of the method to be created.\n\t * @param returnType\n\t * \t\tthe return type of the created method.\n\t * @param initializer\n\t *            the initializer to apply on the created method. If <code>null<\/code>, the method won't be initialized.\n\t * \n\t * @return a result representing a Java method with the given name, <code>null<\/code> if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable\n\tpublic JvmOperation toMethod(@Nullable EObject sourceElement, @Nullable String name, @Nullable JvmTypeReference returnType,\n\t\t\t@Nullable Procedure1<? super JvmOperation> initializer) {\n\t\tif(sourceElement == null || name == null) \n\t\t\treturn null;\n\t\tJvmOperation result = typesFactory.createJvmOperation();\n\t\tresult.setSimpleName(name);\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tresult.setReturnType(cloneWithProxies(returnType));\n\t\tassociate(sourceElement, result);\n\t\treturn initializeSafely(result, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public class declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created class element. If <code>null<\/code>, the class won't be initialized.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmGenericType toClass(@Nullable EObject sourceElement, @Nullable String name, @Nullable Procedure1<JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\t\treturn result;\n\t}","id":296,"modified_method":"/**\n\t * Creates a public class declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created class element. If <code>null<\/code>, the class won't be initialized.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmGenericType toClass(@Nullable EObject sourceElement, @Nullable String name, @Nullable Procedure1<? super JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tassociate(sourceElement, result);\n\t\treturn initializeSafely(result, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Same as {@link #toField(EObject, String, JvmTypeReference)} but with an initializer passed as the last argument.\n\t */\n\t@Nullable\t\n\tpublic JvmField toField(@Nullable EObject sourceElement, @Nullable String name, @Nullable JvmTypeReference typeRef, \n\t\t\t@Nullable Procedure1<JvmField> initializer) {\n\t\tif(sourceElement == null || name == null) \n\t\t\treturn null;\n\t\tJvmField result = typesFactory.createJvmField();\n\t\tresult.setSimpleName(name);\n\t\tresult.setVisibility(JvmVisibility.PRIVATE);\n\t\tresult.setType(cloneWithProxies(typeRef));\n\t\tif (initializer != null)\n\t\t\tinitializer.apply(result);\n\t\treturn associate(sourceElement, result);\n\t}","id":297,"modified_method":"/**\n\t * Same as {@link #toField(EObject, String, JvmTypeReference)} but with an initializer passed as the last argument.\n\t */\n\t@Nullable\t\n\tpublic JvmField toField(@Nullable EObject sourceElement, @Nullable String name, @Nullable JvmTypeReference typeRef, \n\t\t\t@Nullable Procedure1<? super JvmField> initializer) {\n\t\tif(sourceElement == null || name == null) \n\t\t\treturn null;\n\t\tJvmField result = typesFactory.createJvmField();\n\t\tresult.setSimpleName(name);\n\t\tresult.setVisibility(JvmVisibility.PRIVATE);\n\t\tresult.setType(cloneWithProxies(typeRef));\n\t\tassociate(sourceElement, result);\n\t\treturn initializeSafely(result, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates and returns a constructor with the given simple name associated to the given source element. By default\n\t * the constructor will have an empty body and no arguments, hence the Java default constructor.\n\t *\n\t * @param sourceElement \n\t * \t\t      the sourceElement the constructor should be associated with.\n\t * @param initializer\n\t *            the initializer to apply on the created constructor. If <code>null<\/code>, the method won't be initialized.\n\t * \n\t * @return a result representing a Java constructor with the given name, <code>null<\/code> if sourceElement is <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmConstructor toConstructor(@Nullable EObject sourceElement, @Nullable Procedure1<JvmConstructor> initializer) {\n\t\tif(sourceElement == null)\n\t\t\treturn null;\n\t\tJvmConstructor constructor = typesFactory.createJvmConstructor();\n\t\tconstructor.setVisibility(JvmVisibility.PUBLIC);\n\t\tassociate(sourceElement, constructor);\n\t\tif (initializer != null)\n\t\t\tinitializer.apply(constructor);\n\t\treturn constructor;\n\t}","id":298,"modified_method":"/**\n\t * Creates and returns a constructor with the given simple name associated to the given source element. By default\n\t * the constructor will have an empty body and no arguments, hence the Java default constructor.\n\t *\n\t * @param sourceElement \n\t * \t\t      the sourceElement the constructor should be associated with.\n\t * @param initializer\n\t *            the initializer to apply on the created constructor. If <code>null<\/code>, the method won't be initialized.\n\t * \n\t * @return a result representing a Java constructor with the given name, <code>null<\/code> if sourceElement is <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmConstructor toConstructor(@Nullable EObject sourceElement, @Nullable Procedure1<? super JvmConstructor> initializer) {\n\t\tif(sourceElement == null)\n\t\t\treturn null;\n\t\tJvmConstructor constructor = typesFactory.createJvmConstructor();\n\t\tconstructor.setVisibility(JvmVisibility.PUBLIC);\n\t\tassociate(sourceElement, constructor);\n\t\treturn initializeSafely(constructor, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public class declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the {@link QualifiedName} of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created class element. If <code>null<\/code>, the class won't be initialized.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmGenericType toClass(@Nullable EObject sourceElement, @Nullable QualifiedName name, @Nullable Procedure1<JvmGenericType> initializer) {\n\t\treturn toClass(sourceElement, name != null ? name.toString() : null, initializer);\n\t}","id":299,"modified_method":"/**\n\t * Creates a public class declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the {@link QualifiedName} of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created class element. If <code>null<\/code>, the class won't be initialized.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmGenericType toClass(@Nullable EObject sourceElement, @Nullable QualifiedName name, @Nullable Procedure1<? super JvmGenericType> initializer) {\n\t\treturn toClass(sourceElement, name != null ? name.toString() : null, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public enum declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting enum type.\n\t * @param initializer\n\t *            the initializer to apply on the created enumeration type. If <code>null<\/code>, the enum won't be initialized.\n\t * \n\t * @return a result representing a Java enum type with the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmEnumerationType toEnumerationType(@Nullable EObject sourceElement, @Nullable String name, \n\t\t\t@Nullable Procedure1<JvmEnumerationType> initializer) {\n\t\tif (sourceElement == null || name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmEnumerationType result = typesFactory.createJvmEnumerationType();\n\t\tresult.setSimpleName(fullName.getSecond());\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tif (fullName.getFirst() != null)\n\t\t\tresult.setPackageName(fullName.getFirst());\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\t\treturn result;\n\t}","id":300,"modified_method":"/**\n\t * Creates a public enum declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param name\n\t *            the qualified name of the resulting enum type.\n\t * @param initializer\n\t *            the initializer to apply on the created enumeration type. If <code>null<\/code>, the enum won't be initialized.\n\t * \n\t * @return a result representing a Java enum type with the given name, <code>null<\/code> \n\t *            if sourceElement or name are <code>null<\/code>.\n\t */\n\t@Nullable \n\tpublic JvmEnumerationType toEnumerationType(@Nullable EObject sourceElement, @Nullable String name, \n\t\t\t@Nullable Procedure1<? super JvmEnumerationType> initializer) {\n\t\tif (sourceElement == null || name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmEnumerationType result = typesFactory.createJvmEnumerationType();\n\t\tresult.setSimpleName(fullName.getSecond());\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tif (fullName.getFirst() != null)\n\t\t\tresult.setPackageName(fullName.getFirst());\n\t\tassociate(sourceElement, result);\n\t\treturn initializeSafely(result, initializer);\n\t}","commit_id":"977608ff211e2d37a1be06c8129b2f3019062337","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean isTopLevel() {\n    if (getValue() == null) return false;\n    return getValue().getParent() instanceof PsiFile;\n  }","id":301,"modified_method":"public boolean isTopLevel() {\n    final PsiClass aClass = getValue();\n    return aClass != null && aClass.getParent() instanceof PsiFile;\n  }","commit_id":"3f8d1c24b825c9b5d175e519d4b8740601cd676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateImpl(PresentationData data) {\n    final PsiClass value = getValue();\n    if (value != null) {\n      data.setPresentableText(value.getName());\n    }\n  }","id":302,"modified_method":"public void updateImpl(PresentationData data) {\n    final PsiClass aClass = getValue();\n    if (aClass != null) {\n      data.setPresentableText(aClass.getName());\n      final String qName = aClass.getQualifiedName();\n      if (qName != null) {\n        final CoverageDataManager coverageManager = CoverageDataManager.getInstance(aClass.getProject());\n        final String coverageString = coverageManager.getClassCoverageInormationString(qName);\n        if (coverageString != null) {\n          data.setLocationString(coverageString);\n        }\n      }\n    }\n  }","commit_id":"3f8d1c24b825c9b5d175e519d4b8740601cd676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean showFwName(final PsiPackage aPackage) {\n    final boolean showFqName;\n    if (!getSettings().isFlattenPackages()) {\n      showFqName = false;\n    }\n    else {\n      showFqName = aPackage.getQualifiedName().length() > 0;\n    }\n    return showFqName;\n  }","id":303,"modified_method":"private boolean showFwName(final PsiPackage aPackage) {\n    final boolean showFqName;\n    showFqName = getSettings().isFlattenPackages() &&\n                 aPackage.getQualifiedName().length() > 0;\n    return showFqName;\n  }","commit_id":"3f8d1c24b825c9b5d175e519d4b8740601cd676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateValidData(final PresentationData presentation) {\n    final PsiPackage aPackage = getValue().getPackage();\n\n    if (!getSettings().isFlattenPackages()) {\n      if (getSettings().isHideEmptyMiddlePackages()) {\n        if (PackageUtil.isPackageEmpty(aPackage, getValue().getModule(), true, isLibraryElement())) {\n          setValue(null);\n          return;\n        }\n      }\n    }\n\n    if (showFwName(aPackage)) {\n      presentation.setPresentableText(getSettings().isAbbreviatePackageNames()\n                                      ? TreeViewUtil.calcAbbreviatedPackageFQName(aPackage)\n                                      : aPackage.getQualifiedName());\n    }\n    else {\n      if (!(getParentValue() instanceof PackageElement)) {\n        presentation.setPresentableText(aPackage.getQualifiedName());\n      }\n      else {\n        final PsiPackage parentPackageInTree = ((PackageElement)getParentValue()).getPackage();\n        PsiPackage parentPackage = aPackage.getParentPackage();\n        final StringBuffer buf = new StringBuffer();\n        buf.append(aPackage.getName());\n        while (parentPackage != null && !parentPackage.equals(parentPackageInTree)) {\n          buf.insert(0, \".\");\n          buf.insert(0, parentPackage.getName());\n          parentPackage = parentPackage.getParentPackage();\n        }\n        presentation.setPresentableText(buf.toString());\n      }\n    }\n\n    presentation.setOpenIcon(Icons.PACKAGE_OPEN_ICON);\n    presentation.setClosedIcon(Icons.PACKAGE_ICON);\n  }","id":304,"modified_method":"private void updateValidData(final PresentationData presentation) {\n    final PsiPackage aPackage = getValue().getPackage();\n    final String qName = aPackage.getQualifiedName();\n    final CoverageDataManager coverageManager = CoverageDataManager.getInstance(aPackage.getProject());\n    final String coverageString = coverageManager.getPackageCoverageInormationString(qName);\n    if (coverageString != null) {\n      presentation.setLocationString(coverageString);\n    }\n\n    if (!getSettings().isFlattenPackages()) {\n      if (getSettings().isHideEmptyMiddlePackages()) {\n        if (PackageUtil.isPackageEmpty(aPackage, getValue().getModule(), true, isLibraryElement())) {\n          setValue(null);\n          return;\n        }\n      }\n    }\n\n    if (showFwName(aPackage)) {\n      presentation.setPresentableText(getSettings().isAbbreviatePackageNames()\n                                      ? TreeViewUtil.calcAbbreviatedPackageFQName(aPackage)\n                                      : aPackage.getQualifiedName());\n    }\n    else {\n      if (!(getParentValue() instanceof PackageElement)) {\n        presentation.setPresentableText(qName);\n      }\n      else {\n        final PsiPackage parentPackageInTree = ((PackageElement)getParentValue()).getPackage();\n        PsiPackage parentPackage = aPackage.getParentPackage();\n        final StringBuffer buf = new StringBuffer();\n        buf.append(aPackage.getName());\n        while (parentPackage != null && !parentPackage.equals(parentPackageInTree)) {\n          buf.insert(0, \".\");\n          buf.insert(0, parentPackage.getName());\n          parentPackage = parentPackage.getParentPackage();\n        }\n        presentation.setPresentableText(buf.toString());\n      }\n    }\n\n    presentation.setOpenIcon(Icons.PACKAGE_OPEN_ICON);\n    presentation.setClosedIcon(Icons.PACKAGE_ICON);\n  }","commit_id":"3f8d1c24b825c9b5d175e519d4b8740601cd676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateImpl(PresentationData data) {\n    final PsiClass value = getPsiClass();\n    if (value != null) {\n      data.setPresentableText(value.getName());\n    }\n  }","id":305,"modified_method":"public void updateImpl(PresentationData data) {\n    final PsiClass aClass = getPsiClass();\n    if (aClass != null) {\n      data.setPresentableText(aClass.getName());\n      final String qName = aClass.getQualifiedName();\n      if (qName != null) {\n        final CoverageDataManager coverageManager = CoverageDataManager.getInstance(myProject);\n        data.setLocationString(coverageManager.getClassCoverageInformationString(qName));\n      }\n    }\n  }","commit_id":"a97ad858cc65e177a22f2de7d8e3b0e47ac86521","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FavoritesTreeViewPanel(Project project, String helpId, String name) {\n    super(new BorderLayout());\n    myProject = project;\n    myHelpId = helpId;\n    myListName = name;\n\n    myFavoritesTreeStructure = new FavoritesTreeStructure(project, myListName);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode();\n    root.setUserObject(myFavoritesTreeStructure.getRootElement());\n    final DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    myTree = new DnDAwareTree(treeModel) {\n      public void setRowHeight(int i) {\n        super.setRowHeight(0);\n      }\n    };\n    myBuilder = new FavoritesViewTreeBuilder(myProject, myTree, treeModel, myFavoritesTreeStructure, myListName);\n\n    TreeUtil.installActions(myTree);\n    UIUtil.setLineStyleAngled(myTree);\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n    myTree.setLargeModel(true);\n    new TreeSpeedSearch(myTree);\n    ToolTipManager.sharedInstance().registerComponent(myTree);\n    TreeToolTipHandler.install(myTree);\n    myTree.setCellRenderer(new NodeRenderer() {\n      public void customizeCellRenderer(JTree tree,\n                                        Object value,\n                                        boolean selected,\n                                        boolean expanded,\n                                        boolean leaf,\n                                        int row,\n                                        boolean hasFocus) {\n        super.customizeCellRenderer(tree, value, selected, expanded, leaf, row,\n                                    hasFocus);\n        if (value instanceof DefaultMutableTreeNode) {\n          DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;\n          //only favorites roots to explain\n          if (node.getParent() == null || node.getParent().getParent() != null) {\n            return;\n          }\n          Object userObject = node.getUserObject();\n\n          if (userObject instanceof FavoritesTreeNodeDescriptor) {\n            final FavoritesTreeNodeDescriptor favoritesTreeNodeDescriptor = (FavoritesTreeNodeDescriptor)userObject;\n            AbstractTreeNode treeNode = favoritesTreeNodeDescriptor.getElement();\n            final ItemPresentation presentation = treeNode.getPresentation();\n            String locationString = presentation != null ? presentation.getLocationString() : null;\n            if (locationString != null && locationString.length() > 0) {\n              append(\" (\" + locationString + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n            }\n            else {\n              final String location = favoritesTreeNodeDescriptor.getLocation();\n              if (location != null && location.length() > 0) {\n                append(\" (\" + location + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n              }\n            }\n          }\n        }\n      }\n    });\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTree);\n    myTreePopupHandler = PopupHandler.installPopupHandler(myTree,\n                                                          (ActionGroup)CustomizableActionsSchemas.getInstance()\n                                                            .getCorrectedAction(IdeActions.GROUP_FAVORITES_VIEW_POPUP),\n                                                          ActionPlaces.FAVORITES_VIEW_POPUP, ActionManager.getInstance());\n    add(scrollPane, BorderLayout.CENTER);\n    //add(createActionsToolbar(), BorderLayout.NORTH);\n\n    EditSourceOnDoubleClickHandler.install(myTree);\n    myTree.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        if (!e.isPopupTrigger() && e.getClickCount() == 2) {\n          OpenSourceUtil.openSourcesFrom(DataManager.getInstance().getDataContext(FavoritesTreeViewPanel.this), true);\n        }\n      }\n    });\n\n    myTree.addKeyListener(new KeyAdapter() {\n      public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          OpenSourceUtil.openSourcesFrom(DataManager.getInstance().getDataContext(FavoritesTreeViewPanel.this), false);\n        }\n      }\n    });\n    myCopyPasteDelegator = new CopyPasteManagerEx.CopyPasteDelegator(myProject, this) {\n      @NotNull\n      protected PsiElement[] getSelectedElements() {\n        return getSelectedPsiElements();\n      }\n    };\n  }","id":306,"modified_method":"public FavoritesTreeViewPanel(Project project, String helpId, String name) {\n    super(new BorderLayout());\n    myProject = project;\n    myHelpId = helpId;\n    myListName = name;\n\n    myFavoritesTreeStructure = new FavoritesTreeStructure(project, myListName);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode();\n    root.setUserObject(myFavoritesTreeStructure.getRootElement());\n    final DefaultTreeModel treeModel = new DefaultTreeModel(root);\n    myTree = new DnDAwareTree(treeModel) {\n      public void setRowHeight(int i) {\n        super.setRowHeight(0);\n      }\n    };\n    myBuilder = new FavoritesViewTreeBuilder(myProject, myTree, treeModel, myFavoritesTreeStructure, myListName);\n\n    TreeUtil.installActions(myTree);\n    UIUtil.setLineStyleAngled(myTree);\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n    myTree.setLargeModel(true);\n    new TreeSpeedSearch(myTree);\n    ToolTipManager.sharedInstance().registerComponent(myTree);\n    TreeToolTipHandler.install(myTree);\n    myTree.setCellRenderer(new NodeRenderer() {\n      public void customizeCellRenderer(JTree tree,\n                                        Object value,\n                                        boolean selected,\n                                        boolean expanded,\n                                        boolean leaf,\n                                        int row,\n                                        boolean hasFocus) {\n        super.customizeCellRenderer(tree, value, selected, expanded, leaf, row,\n                                    hasFocus);\n        if (value instanceof DefaultMutableTreeNode) {\n          final DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;\n          //only favorites roots to explain\n          final Object userObject = node.getUserObject();\n          if (userObject instanceof FavoritesTreeNodeDescriptor) {\n            final FavoritesTreeNodeDescriptor favoritesTreeNodeDescriptor = (FavoritesTreeNodeDescriptor)userObject;\n            AbstractTreeNode treeNode = favoritesTreeNodeDescriptor.getElement();\n            final ItemPresentation presentation = treeNode.getPresentation();\n            String locationString = presentation != null ? presentation.getLocationString() : null;\n            if (locationString != null && locationString.length() > 0) {\n              append(\" (\" + locationString + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n            }\n            else if (node.getParent() != null && node.getParent().getParent() == null){\n              final String location = favoritesTreeNodeDescriptor.getLocation();\n              if (location != null && location.length() > 0) {\n                append(\" (\" + location + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n              }\n            }\n          }\n        }\n      }\n    });\n    JScrollPane scrollPane = ScrollPaneFactory.createScrollPane(myTree);\n    myTreePopupHandler = PopupHandler.installPopupHandler(myTree,\n                                                          (ActionGroup)CustomizableActionsSchemas.getInstance()\n                                                            .getCorrectedAction(IdeActions.GROUP_FAVORITES_VIEW_POPUP),\n                                                          ActionPlaces.FAVORITES_VIEW_POPUP, ActionManager.getInstance());\n    add(scrollPane, BorderLayout.CENTER);\n    //add(createActionsToolbar(), BorderLayout.NORTH);\n\n    EditSourceOnDoubleClickHandler.install(myTree);\n    myTree.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        if (!e.isPopupTrigger() && e.getClickCount() == 2) {\n          OpenSourceUtil.openSourcesFrom(DataManager.getInstance().getDataContext(FavoritesTreeViewPanel.this), true);\n        }\n      }\n    });\n\n    myTree.addKeyListener(new KeyAdapter() {\n      public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          OpenSourceUtil.openSourcesFrom(DataManager.getInstance().getDataContext(FavoritesTreeViewPanel.this), false);\n        }\n      }\n    });\n    myCopyPasteDelegator = new CopyPasteManagerEx.CopyPasteDelegator(myProject, this) {\n      @NotNull\n      protected PsiElement[] getSelectedElements() {\n        return getSelectedPsiElements();\n      }\n    };\n  }","commit_id":"a97ad858cc65e177a22f2de7d8e3b0e47ac86521","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void customizeCellRenderer(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n      if (value instanceof PackageDependenciesNode) {\n        PackageDependenciesNode node = (PackageDependenciesNode)value;\n        if (expanded) {\n          setIcon(node.getOpenIcon());\n        }\n        else {\n          setIcon(node.getClosedIcon());\n        }\n        final SimpleTextAttributes regularAttributes = SimpleTextAttributes.REGULAR_ATTRIBUTES;\n        TextAttributes textAttributes = null;\n        if (node instanceof DirectoryNode) {\n          final DirectoryNode directoryNode = (DirectoryNode)node;\n          append(directoryNode.getDirName(), regularAttributes);\n          final String locationString = directoryNode.getLocationString();\n          if (locationString != null) {\n            append(\" (\" + locationString + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n          }\n        }\n        else {\n          final PsiElement psiElement = node.getPsiElement();\n          if (psiElement instanceof PsiDocCommentOwner && ((PsiDocCommentOwner)psiElement).isDeprecated()){\n            textAttributes = EditorColorsManager.getInstance().getGlobalScheme().getAttributes(CodeInsightColors.DEPRECATED_ATTRIBUTES).clone();\n          }\n          if (textAttributes == null){\n            textAttributes = regularAttributes.toTextAttributes();\n          }\n          textAttributes.setForegroundColor(node.getStatus().getColor());\n          append(node.toString(), SimpleTextAttributes.fromTextAttributes(textAttributes));\n        }\n      }\n    }","id":307,"modified_method":"public void customizeCellRenderer(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n      if (value instanceof PackageDependenciesNode) {\n        PackageDependenciesNode node = (PackageDependenciesNode)value;\n        if (expanded) {\n          setIcon(node.getOpenIcon());\n        }\n        else {\n          setIcon(node.getClosedIcon());\n        }\n        final SimpleTextAttributes regularAttributes = SimpleTextAttributes.REGULAR_ATTRIBUTES;\n        TextAttributes textAttributes = null;\n        final String locationString;\n        final PsiElement psiElement = node.getPsiElement();\n        final CoverageDataManager coverageDataManager = CoverageDataManager.getInstance(myProject);\n        if (node instanceof DirectoryNode) {\n          final DirectoryNode directoryNode = (DirectoryNode)node;\n          append(directoryNode.getDirName(), regularAttributes);\n          final String informationString = psiElement != null ? coverageDataManager.getDirCoverageInformationString((PsiDirectory)psiElement) : null;\n          locationString = informationString != null ? informationString : directoryNode.getLocationString();\n        }\n        else {\n          if (psiElement instanceof PsiDocCommentOwner && ((PsiDocCommentOwner)psiElement).isDeprecated()) {\n            textAttributes =\n              EditorColorsManager.getInstance().getGlobalScheme().getAttributes(CodeInsightColors.DEPRECATED_ATTRIBUTES).clone();\n          }\n          if (textAttributes == null) {\n            textAttributes = regularAttributes.toTextAttributes();\n          }\n          textAttributes.setForegroundColor(node.getStatus().getColor());\n          append(node.toString(), SimpleTextAttributes.fromTextAttributes(textAttributes));\n          if (psiElement instanceof PsiClass) {\n            locationString = coverageDataManager.getClassCoverageInformationString(((PsiClass)psiElement).getQualifiedName());\n          }\n          else {\n            locationString = null;\n          }\n        }\n        if (locationString != null) {\n          append(\" (\" + locationString + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n        }\n      }\n    }","commit_id":"a97ad858cc65e177a22f2de7d8e3b0e47ac86521","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void updateImpl(PresentationData data) {\n        JetClassOrObject value = getValue();\n        if (value != null) {\n            data.setPresentableText(value.getName());\n        }\n    }","id":308,"modified_method":"@Override\n    protected void updateImpl(PresentationData data) {\n        JetClassOrObject classOrObject = getValue();\n        if (classOrObject != null) {\n            data.setPresentableText(classOrObject.getName());\n\n            AbstractTreeNode parent = getParent();\n            if (JetIconProvider.getMainClass((JetFile) classOrObject.getContainingFile()) != null) {\n                if (parent instanceof JetFileTreeNode) {\n                    update(parent.getParent());\n                }\n            }\n            else {\n                if (!(parent instanceof JetClassOrObjectTreeNode) && !(parent instanceof JetFileTreeNode)) {\n                    update(parent);\n                }\n            }\n        }\n    }","commit_id":"9aee8a98e0c19b5ae037b34b57be91e0501e14a0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void init(Object context, Configuration config) {\n\t\tif (_config != null)\n\t\t\tthrow new IllegalStateException(\"Cannot be initialized twice\");\n\t\tif (config == null)\n\t\t\tthrow new IllegalArgumentException(\"null\");\n\t\tfinal WebApp oldwapp = config.getWebApp();\n\t\tif (oldwapp != null && oldwapp != this)\n\t\t\tthrow new IllegalArgumentException(\"config already belongs to other Web app, \"+oldwapp);\n\n\t\t_config = config;\n\t\t_config.setWebApp(this);\n\n\t\tClass cls = _config.getUiEngineClass();\n\t\tif (cls == null) {\n\t\t\t_engine = new UiEngineImpl();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_engine = (UiEngine)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getDesktopCacheProviderClass();\n\t\tif (cls == null) {\n\t\t\t_provider = new SessionDesktopCacheProvider();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_provider = (DesktopCacheProvider)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getUiFactoryClass();\n\t\tif (cls == null) {\n\t\t\t_factory = new SimpleUiFactory();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_factory = (UiFactory)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getFailoverManagerClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_failover = (FailoverManager)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\t\tcls = _config.getIdGeneratorClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_idgen = (IdGenerator)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getSessionCacheClass();\n\t\tif (cls == null) {\n\t\t\t_sesscache = new SimpleSessionCache();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_sesscache = (SessionCache)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\t_engine.start(this);\n\t\t_provider.start(this);\n\t\t_factory.start(this);\n\t\ttry {\n\t\t\t_failover.start(this);\n\t\t} catch (AbstractMethodError ex) { //backward compatible\n\t\t}\n\t\t_sesscache.init(this);\n\n\t\t_config.invokeWebAppInits();\n\t}","id":309,"modified_method":"public void init(Object context, Configuration config) {\n\t\tif (_config != null)\n\t\t\tthrow new IllegalStateException(\"Cannot be initialized twice\");\n\t\tif (config == null)\n\t\t\tthrow new IllegalArgumentException(\"null\");\n\t\tfinal WebApp oldwapp = config.getWebApp();\n\t\tif (oldwapp != null && oldwapp != this)\n\t\t\tthrow new IllegalArgumentException(\"config already belongs to other Web app, \"+oldwapp);\n\n\t\t_config = config;\n\t\t_config.setWebApp(this);\n\n\t\tClass cls = _config.getUiEngineClass();\n\t\tif (cls == null) {\n\t\t\t_engine = new UiEngineImpl();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_engine = (UiEngine)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getDesktopCacheProviderClass();\n\t\tif (cls == null) {\n\t\t\t_provider = new SessionDesktopCacheProvider();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_provider = (DesktopCacheProvider)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getUiFactoryClass();\n\t\tif (cls == null) {\n\t\t\t_factory = new SimpleUiFactory();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_factory = (UiFactory)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getFailoverManagerClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_failover = (FailoverManager)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\t\tcls = _config.getIdGeneratorClass();\n\t\tif (cls != null) {\n\t\t\ttry {\n\t\t\t\t_idgen = (IdGenerator)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\tcls = _config.getSessionCacheClass();\n\t\tif (cls == null) {\n\t\t\t_sesscache = new SimpleSessionCache();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t_sesscache = (SessionCache)cls.newInstance();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow UiException.Aide.wrap(ex, \"Unable to construct \"+cls);\n\t\t\t}\n\t\t}\n\n\t\t_engine.start(this);\n\t\t_provider.start(this);\n\t\t_factory.start(this);\n\t\tif (_failover != null) {\n\t\t\ttry {\n\t\t\t\t_failover.start(this);\n\t\t\t} catch (AbstractMethodError ex) { //backward compatible\n\t\t\t}\n\t\t}\n\t\t_sesscache.init(this);\n\n\t\t_config.invokeWebAppInits();\n\t}","commit_id":"8babcf934feb5a618f946cffd45628d5b8800243","url":"https://github.com/zkoss/zk"},{"original_method":"public void destroy() {\n\t\t_config.invokeWebAppCleanups();\n\n\t\t_config.detroyRichlets();\n\n\t\ttry {\n\t\t\t_sesscache.destroy(this);\n\t\t} catch (AbstractMethodError ex) { //backward compatible\n\t\t}\n\t\t_factory.stop(this);\n\t\t_provider.stop(this);\n\t\t_engine.stop(this);\n\t\ttry {\n\t\t\t_failover.stop(this);\n\t\t} catch (AbstractMethodError ex) { //backward compatible\n\t\t}\n\t\t_factory = null;\n\t\t_provider = null;\n\t\t_engine = null;\n\t\t_failover = null;\n\t\t_sesscache = null;\n\n\t\t//we don't reset _config since WebApp cannot be re-inited after stop\n\t}","id":310,"modified_method":"public void destroy() {\n\t\t_config.invokeWebAppCleanups();\n\n\t\t_config.detroyRichlets();\n\n\t\ttry {\n\t\t\t_sesscache.destroy(this);\n\t\t} catch (AbstractMethodError ex) { //backward compatible\n\t\t}\n\t\t_factory.stop(this);\n\t\t_provider.stop(this);\n\t\t_engine.stop(this);\n\t\tif (_failover != null) {\n\t\t\ttry {\n\t\t\t\t_failover.stop(this);\n\t\t\t} catch (AbstractMethodError ex) { //backward compatible\n\t\t\t}\n\t\t\t_failover = null;\n\t\t}\n\t\t_factory = null;\n\t\t_provider = null;\n\t\t_engine = null;\n\t\t_sesscache = null;\n\n\t\t//we don't reset _config since WebApp cannot be re-inited after stop\n\t}","commit_id":"8babcf934feb5a618f946cffd45628d5b8800243","url":"https://github.com/zkoss/zk"},{"original_method":"public void setFailoverManager(FailoverManager failover) {\n\t\tif (failover == null) throw new IllegalArgumentException();\n\t\t_failover.stop(this);\n\t\t_failover = failover;\n\t\t_failover.start(this);\n\t}","id":311,"modified_method":"public void setFailoverManager(FailoverManager failover) {\n\t\tif (_failover != null)\n\t\t\t_failover.stop(this);\n\t\t_failover = failover;\n\t\tif (_failover != null)\n\t\t\t_failover.start(this);\n\t}","commit_id":"8babcf934feb5a618f946cffd45628d5b8800243","url":"https://github.com/zkoss/zk"},{"original_method":"public void setIdGenerator(IdGenerator idgen) {\n\t\tif (idgen == null) throw new IllegalArgumentException();\n\t\t_idgen = idgen;\n\t}","id":312,"modified_method":"public void setIdGenerator(IdGenerator idgen) {\n\t\t_idgen = idgen;\n\t}","commit_id":"8babcf934feb5a618f946cffd45628d5b8800243","url":"https://github.com/zkoss/zk"},{"original_method":"public void setHashFunctionFactory(HashFunctionFactory hash_function_factory) {\n        this.hash_function_factory=hash_function_factory;\n    }","id":313,"modified_method":"public void setHashFunctionFactory(HashFunctionFactory<K> hash_function_factory) {\n        this.hash_function_factory=hash_function_factory;\n    }","commit_id":"90d520fb57debe7e62b4f7047c828e65ddcc0ab4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setL2Cache(Cache<K,Value<V>> cache) {\n        if(l2_cache != null)\n            l2_cache.stop();\n        l2_cache=cache;\n    }","id":314,"modified_method":"public void setL2Cache(Cache<K,Value<V>> cache) {\n        if(cache != null) {\n            l2_cache.stop();\n            l2_cache=cache;\n        }\n    }","commit_id":"90d520fb57debe7e62b4f7047c828e65ddcc0ab4","url":"https://github.com/belaban/JGroups"},{"original_method":"private void rebalance(List<Address> old_nodes, List<Address> new_nodes) {\n        HashFunction<K> old_func=hash_function_factory.create();\n        old_func.installNodes(old_nodes);\n\n        HashFunction<K> new_func=hash_function_factory.create();\n        new_func.installNodes(new_nodes);\n\n        boolean is_coord=Util.isCoordinator(ch);\n\n        for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n            K key=entry.getKey();\n            Cache.Value<Value<V>> val=entry.getValue();\n            if(val == null)\n                continue;\n            Value<V> tmp=val.getValue();\n            if(tmp == null)\n                continue;\n            V real_value=tmp.getVal();\n            short repl_count=tmp.getReplicationCount();\n            List<Address> new_mbrs=Util.newMembers(old_nodes, new_nodes);\n\n            if(repl_count == -1) {\n                if(is_coord) {\n                    for(Address new_mbr: new_mbrs) {\n                        move(new_mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                    }\n                }\n            }\n            else if(repl_count == 1) {\n                List<Address> tmp_nodes=new_func.hash(key, repl_count);\n                if(!tmp_nodes.isEmpty()) {\n                    Address mbr=tmp_nodes.get(0);\n                    if(!mbr.equals(local_addr)) {\n                        move(mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                        if(l2_cache != null)\n                            l2_cache.remove(key);\n                        if(l1_cache != null)\n                            l1_cache.remove(key);\n                    }\n                }\n\n            }\n            else if(repl_count > 1) {\n                \n            }\n            else {\n                // failure: illegal state\n                throw new IllegalStateException(\"replication count is invalid (\" + repl_count + \")\");\n            }\n            \n        }\n\n    }","id":315,"modified_method":"private void rebalance(List<Address> old_nodes, List<Address> new_nodes) {\n        HashFunction<K> old_func=hash_function_factory.create();\n        old_func.installNodes(old_nodes);\n\n        HashFunction<K> new_func=hash_function_factory.create();\n        new_func.installNodes(new_nodes);\n\n        boolean is_coord=Util.isCoordinator(ch);\n\n        for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n            K key=entry.getKey();\n            Cache.Value<Value<V>> val=entry.getValue();\n            if(val == null)\n                continue;\n            Value<V> tmp=val.getValue();\n            if(tmp == null)\n                continue;\n            V real_value=tmp.getVal();\n            short repl_count=tmp.getReplicationCount();\n            List<Address> new_mbrs=Util.newMembers(old_nodes, new_nodes);\n\n            if(repl_count == -1) {\n                if(is_coord) {\n                    for(Address new_mbr: new_mbrs) {\n                        move(new_mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                    }\n                }\n            }\n            else if(repl_count == 1) {\n                List<Address> tmp_nodes=new_func.hash(key, repl_count);\n                if(!tmp_nodes.isEmpty()) {\n                    Address mbr=tmp_nodes.get(0);\n                    if(!mbr.equals(local_addr)) {\n                        move(mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                        _remove(key);\n                    }\n                }\n\n            }\n            else if(repl_count > 1) {\n                List<Address> tmp_old=old_func.hash(key, repl_count);\n                List<Address> tmp_new=new_func.hash(key, repl_count);\n                if(tmp_old != null && tmp_new != null && tmp_old.equals(tmp_new))\n                    return;\n                mcastPut(key, real_value, repl_count, val.getExpirationTime(), false);\n                if(tmp_new != null && !tmp_new.contains(local_addr)) {\n                    _remove(key);\n                }\n            }\n            else {\n                // failure: illegal state\n                throw new IllegalStateException(\"replication count is invalid (\" + repl_count + \")\");\n            }\n            \n        }\n\n    }","commit_id":"90d520fb57debe7e62b4f7047c828e65ddcc0ab4","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public void stop() {\n        if(l1_cache != null)\n            l1_cache.stop();\n        if(migrate_data) {\n            List<Address> members_without_me=new ArrayList<Address>(view.getMembers());\n            members_without_me.remove(local_addr);\n\n            HashFunction<K> tmp_hash_function=hash_function_factory.create();\n            tmp_hash_function.installNodes(members_without_me);\n\n            for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n                K key=entry.getKey();\n                Cache.Value<Value<V>> val=entry.getValue();\n                if(val == null)\n                    continue;\n                Value<V> tmp=val.getValue();\n                if(tmp == null)\n                    continue;\n                short repl_count=tmp.getReplicationCount();\n                if(repl_count != 1) // we only handle keys which are not replicated and which are stored by us\n                    continue;\n\n                List<Address> nodes=tmp_hash_function.hash(key, repl_count);\n                if(nodes == null || nodes.isEmpty())\n                    continue;\n                if(!nodes.contains(local_addr)) {\n                    Address dest=nodes.get(0); // should only have 1 element anyway\n                    move(dest, key, tmp.getVal(), repl_count, val.getExpirationTime(), true);\n                    if(l2_cache != null)\n                        l2_cache.remove(key);\n                    if(l1_cache != null)\n                        l1_cache.remove(key);\n                }\n            }\n        }\n        if(l2_cache != null)\n            l2_cache.stop();\n        disp.stop();\n        ch.close();\n    }","id":316,"modified_method":"@ManagedOperation\n    public void stop() {\n        if(l1_cache != null)\n            l1_cache.stop();\n        if(migrate_data) {\n            List<Address> members_without_me=new ArrayList<Address>(view.getMembers());\n            members_without_me.remove(local_addr);\n\n            HashFunction<K> tmp_hash_function=hash_function_factory.create();\n            tmp_hash_function.installNodes(members_without_me);\n\n            for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n                K key=entry.getKey();\n                Cache.Value<Value<V>> val=entry.getValue();\n                if(val == null)\n                    continue;\n                Value<V> tmp=val.getValue();\n                if(tmp == null)\n                    continue;\n                short repl_count=tmp.getReplicationCount();\n                if(repl_count != 1) // we only handle keys which are not replicated and which are stored by us\n                    continue;\n\n                List<Address> nodes=tmp_hash_function.hash(key, repl_count);\n                if(nodes == null || nodes.isEmpty())\n                    continue;\n                if(!nodes.contains(local_addr)) {\n                    Address dest=nodes.get(0); // should only have 1 element anyway\n                    move(dest, key, tmp.getVal(), repl_count, val.getExpirationTime(), true);\n                    _remove(key);\n                }\n            }\n        }\n        l2_cache.stop();\n        disp.stop();\n        ch.close();\n    }","commit_id":"90d520fb57debe7e62b4f7047c828e65ddcc0ab4","url":"https://github.com/belaban/JGroups"},{"original_method":"private void rebalance(List<Address> old_nodes, List<Address> new_nodes) {\n        HashFunction<K> old_func=hash_function_factory.create();\n        old_func.installNodes(old_nodes);\n\n        HashFunction<K> new_func=hash_function_factory.create();\n        new_func.installNodes(new_nodes);\n\n        boolean is_coord=Util.isCoordinator(ch);\n\n        for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n            K key=entry.getKey();\n            Cache.Value<Value<V>> val=entry.getValue();\n            if(val == null)\n                continue;\n            Value<V> tmp=val.getValue();\n            if(tmp == null)\n                continue;\n            V real_value=tmp.getVal();\n            short repl_count=tmp.getReplicationCount();\n            List<Address> new_mbrs=Util.newMembers(old_nodes, new_nodes);\n\n            if(repl_count == -1) {\n                if(is_coord) {\n                    for(Address new_mbr: new_mbrs) {\n                        move(new_mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                    }\n                }\n            }\n            else if(repl_count == 1) {\n                List<Address> tmp_nodes=new_func.hash(key, repl_count);\n                if(!tmp_nodes.isEmpty()) {\n                    Address mbr=tmp_nodes.get(0);\n                    if(!mbr.equals(local_addr)) {\n                        move(mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                        if(l2_cache != null)\n                            l2_cache.remove(key);\n                        if(l1_cache != null)\n                            l1_cache.remove(key);\n                    }\n                }\n\n            }\n            else if(repl_count > 1) {\n                \n            }\n            else {\n                // failure: illegal state\n                throw new IllegalStateException(\"replication count is invalid (\" + repl_count + \")\");\n            }\n            \n        }\n\n    }","id":317,"modified_method":"private void rebalance(List<Address> old_nodes, List<Address> new_nodes) {\n        HashFunction<K> old_func=hash_function_factory.create();\n        old_func.installNodes(old_nodes);\n\n        HashFunction<K> new_func=hash_function_factory.create();\n        new_func.installNodes(new_nodes);\n\n        boolean is_coord=Util.isCoordinator(ch);\n\n        for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n            K key=entry.getKey();\n            Cache.Value<Value<V>> val=entry.getValue();\n            if(val == null)\n                continue;\n            Value<V> tmp=val.getValue();\n            if(tmp == null)\n                continue;\n            V real_value=tmp.getVal();\n            short repl_count=tmp.getReplicationCount();\n            List<Address> new_mbrs=Util.newMembers(old_nodes, new_nodes);\n\n            if(repl_count == -1) {\n                if(is_coord) {\n                    for(Address new_mbr: new_mbrs) {\n                        move(new_mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                    }\n                }\n            }\n            else if(repl_count == 1) {\n                List<Address> tmp_nodes=new_func.hash(key, repl_count);\n                if(!tmp_nodes.isEmpty()) {\n                    Address mbr=tmp_nodes.get(0);\n                    if(!mbr.equals(local_addr)) {\n                        move(mbr, key, real_value, repl_count, val.getExpirationTime(), false);\n                        _remove(key);\n                    }\n                }\n\n            }\n            else if(repl_count > 1) {\n                List<Address> tmp_old=old_func.hash(key, repl_count);\n                List<Address> tmp_new=new_func.hash(key, repl_count);\n                if(tmp_old != null && tmp_new != null && tmp_old.equals(tmp_new))\n                    return;\n                mcastPut(key, real_value, repl_count, val.getExpirationTime(), false);\n                if(tmp_new != null && !tmp_new.contains(local_addr)) {\n                    _remove(key);\n                }\n            }\n            else {\n                // failure: illegal state\n                throw new IllegalStateException(\"replication count is invalid (\" + repl_count + \")\");\n            }\n            \n        }\n\n    }","commit_id":"00ce187837bbca3856207cf67deb3344118db93b","url":"https://github.com/belaban/JGroups"},{"original_method":"@ManagedOperation\n    public void stop() {\n        if(l1_cache != null)\n            l1_cache.stop();\n        if(migrate_data) {\n            List<Address> members_without_me=new ArrayList<Address>(view.getMembers());\n            members_without_me.remove(local_addr);\n\n            HashFunction<K> tmp_hash_function=hash_function_factory.create();\n            tmp_hash_function.installNodes(members_without_me);\n\n            for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n                K key=entry.getKey();\n                Cache.Value<Value<V>> val=entry.getValue();\n                if(val == null)\n                    continue;\n                Value<V> tmp=val.getValue();\n                if(tmp == null)\n                    continue;\n                short repl_count=tmp.getReplicationCount();\n                if(repl_count != 1) // we only handle keys which are not replicated and which are stored by us\n                    continue;\n\n                List<Address> nodes=tmp_hash_function.hash(key, repl_count);\n                if(nodes == null || nodes.isEmpty())\n                    continue;\n                if(!nodes.contains(local_addr)) {\n                    Address dest=nodes.get(0); // should only have 1 element anyway\n                    move(dest, key, tmp.getVal(), repl_count, val.getExpirationTime(), true);\n                    if(l2_cache != null)\n                        l2_cache.remove(key);\n                    if(l1_cache != null)\n                        l1_cache.remove(key);\n                }\n            }\n        }\n        if(l2_cache != null)\n            l2_cache.stop();\n        disp.stop();\n        ch.close();\n    }","id":318,"modified_method":"@ManagedOperation\n    public void stop() {\n        if(l1_cache != null)\n            l1_cache.stop();\n        if(migrate_data) {\n            List<Address> members_without_me=new ArrayList<Address>(view.getMembers());\n            members_without_me.remove(local_addr);\n\n            HashFunction<K> tmp_hash_function=hash_function_factory.create();\n            tmp_hash_function.installNodes(members_without_me);\n\n            for(Map.Entry<K,Cache.Value<Value<V>>> entry: l2_cache.entrySet()) {\n                K key=entry.getKey();\n                Cache.Value<Value<V>> val=entry.getValue();\n                if(val == null)\n                    continue;\n                Value<V> tmp=val.getValue();\n                if(tmp == null)\n                    continue;\n                short repl_count=tmp.getReplicationCount();\n                if(repl_count != 1) // we only handle keys which are not replicated and which are stored by us\n                    continue;\n\n                List<Address> nodes=tmp_hash_function.hash(key, repl_count);\n                if(nodes == null || nodes.isEmpty())\n                    continue;\n                if(!nodes.contains(local_addr)) {\n                    Address dest=nodes.get(0); // should only have 1 element anyway\n                    move(dest, key, tmp.getVal(), repl_count, val.getExpirationTime(), true);\n                    _remove(key);\n                }\n            }\n        }\n        l2_cache.stop();\n        disp.stop();\n        ch.close();\n    }","commit_id":"00ce187837bbca3856207cf67deb3344118db93b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setHashFunctionFactory(HashFunctionFactory hash_function_factory) {\n        this.hash_function_factory=hash_function_factory;\n    }","id":319,"modified_method":"public void setHashFunctionFactory(HashFunctionFactory<K> hash_function_factory) {\n        this.hash_function_factory=hash_function_factory;\n    }","commit_id":"00ce187837bbca3856207cf67deb3344118db93b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setL2Cache(Cache<K,Value<V>> cache) {\n        if(l2_cache != null)\n            l2_cache.stop();\n        l2_cache=cache;\n    }","id":320,"modified_method":"public void setL2Cache(Cache<K,Value<V>> cache) {\n        if(cache != null) {\n            l2_cache.stop();\n            l2_cache=cache;\n        }\n    }","commit_id":"00ce187837bbca3856207cf67deb3344118db93b","url":"https://github.com/belaban/JGroups"},{"original_method":"@SuppressWarnings( \"hiding\" )\n        ByteData( ReadableByteChannel channel ) throws IOException\n        {\n            int size = 0, chunk = 0;\n            List<byte[]> data = new LinkedList<byte[]>();\n            ByteBuffer buffer = ByteBuffer.allocateDirect( 1 * MEGA );\n            while ( ( chunk = channel.read( buffer ) ) >= 0 )\n            {\n                size += chunk;\n                byte[] bytes = new byte[chunk];\n                buffer.flip();\n                buffer.get( bytes );\n                buffer.clear();\n                data.add( bytes );\n            }\n            this.data = data;\n            this.size = size;\n        }","id":321,"modified_method":"@SuppressWarnings( \"hiding\" )\n        ByteData( ReadableByteChannel channel ) throws IOException\n        {\n            this( channel, 1 * MEGA );\n        }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"boxing\" )\n    private static SlaveContext readSlaveContext( ChannelBuffer buffer )\n    {\n        int machineId = buffer.readInt();\n        int eventIdentifier = buffer.readInt();\n        int txsSize = buffer.readByte();\n        Pair<String, Long>[] lastAppliedTransactions = new Pair[txsSize];\n        for ( int i = 0; i < txsSize; i++ )\n        {\n            lastAppliedTransactions[i] = new Pair<String, Long>(\n                    readString( buffer ), buffer.readLong() );\n        }\n        return new SlaveContext( machineId, eventIdentifier, lastAppliedTransactions );\n    }","id":322,"modified_method":"@SuppressWarnings( \"boxing\" )\n    static SlaveContext readSlaveContext( ChannelBuffer buffer )\n    {\n        int machineId = buffer.readInt();\n        int eventIdentifier = buffer.readInt();\n        int txsSize = buffer.readByte();\n        Pair<String, Long>[] lastAppliedTransactions = new Pair[txsSize];\n        for ( int i = 0; i < txsSize; i++ )\n        {\n            lastAppliedTransactions[i] = new Pair<String, Long>(\n                    readString( buffer ), buffer.readLong() );\n        }\n        return new SlaveContext( machineId, eventIdentifier, lastAppliedTransactions );\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            Channel channel = getChannel();\n            channel.write( buffer );\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n\n            ChannelBuffer message = reader.read( 20, TimeUnit.SECONDS );\n            if ( message == null )\n            {\n                throw new HaCommunicationException( \"Channel has been closed\" );\n            }\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( message ) : TransactionStreams.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":323,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            Channel channel = getChannel();\n            ( (InputReader) channel.getPipeline().get( \"transactionReader\" ) ).setDeserializer( deserializer );\n            channel.write( buffer );\n            @SuppressWarnings( \"unchecked\" ) BlockingReadHandler<Response<T>> reader = (BlockingReadHandler<Response<T>>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n\n            Response<T> result = reader.read( 20, TimeUnit.SECONDS );\n            if ( result == null )\n            {\n                throw new HaCommunicationException( \"Channel has been closed\" );\n            }\n            return result;\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        BlockingReadHandler<ChannelBuffer> reader = new BlockingReadHandler<ChannelBuffer>();\n        pipeline.addLast( \"blockingHandler\", reader );\n        return pipeline;\n    }","id":324,"modified_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        /*\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        */\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"transactionReader\", new InputReader() );\n        pipeline.addLast( \"blockingHandler\", new BlockingReadHandler<Response<?>>() );\n        return pipeline;\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","id":325,"modified_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer )\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","id":326,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer )\n            {\n                return buffer.readLong();\n            }\n        });\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Integer> createRelationshipType( SlaveContext context, final String name )\n    {\n        return sendRequest( RequestType.CREATE_RELATIONSHIP_TYPE, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, name );\n            }\n        }, new Deserializer<Integer>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Integer read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readInt();\n            }\n        } );\n    }","id":327,"modified_method":"public Response<Integer> createRelationshipType( SlaveContext context, final String name )\n    {\n        return sendRequest( RequestType.CREATE_RELATIONSHIP_TYPE, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, name );\n            }\n        }, new Deserializer<Integer>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Integer read( ChannelBuffer buffer )\n            {\n                return buffer.readInt();\n            }\n        } );\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"serverHandler\", new ServerHandler() );\n        return pipeline;\n    }","id":328,"modified_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"chunkedWriter\", new ChunkedWriteHandler() );\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        // pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"serverHandler\", new ServerHandler() );\n        return pipeline;\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent event )\n                throws Exception\n        {\n            try\n            {\n                ChannelBuffer message = (ChannelBuffer) event.getMessage();\n                ChannelBuffer result = handleRequest( realMaster, message, \n                        event.getChannel(), MasterServer.this );\n                event.getChannel().write( result );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace();\n                throw e;\n            }\n        }","id":329,"modified_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent event )\n                throws Exception\n        {\n            try\n            {\n                ChannelBuffer message = (ChannelBuffer) event.getMessage();\n                RequestType type = RequestType.values()[message.readByte()];\n                Channel channel = event.getChannel();\n                SlaveContext context = null;\n                if ( type.includesSlaveContext() )\n                {\n                    context = CommunicationProtocol.readSlaveContext( message );\n                    mapSlave( channel, context );\n                }\n                channel.write( new ChunkedResponse( type.caller.callMaster( realMaster, context,\n                        message ), type.serializer, type.includesSlaveContext() ) );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace();\n                throw e;\n            }\n        }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        getServer().getDb().shutdown();\n        return null;\n    }","id":330,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        getServer().getDb().shutdown();\n        return \"exit\";\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":331,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        FakeMasterBroker broker = new FakeMasterBroker( masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","id":332,"modified_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        Broker broker = makeMasterBroker( master, masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"boxing\" )\n    private static SlaveContext readSlaveContext( ChannelBuffer buffer )\n    {\n        int machineId = buffer.readInt();\n        int eventIdentifier = buffer.readInt();\n        int txsSize = buffer.readByte();\n        Pair<String, Long>[] lastAppliedTransactions = new Pair[txsSize];\n        for ( int i = 0; i < txsSize; i++ )\n        {\n            lastAppliedTransactions[i] = new Pair<String, Long>(\n                    readString( buffer ), buffer.readLong() );\n        }\n        return new SlaveContext( machineId, eventIdentifier, lastAppliedTransactions );\n    }","id":333,"modified_method":"@SuppressWarnings( \"boxing\" )\n    static SlaveContext readSlaveContext( ChannelBuffer buffer )\n    {\n        int machineId = buffer.readInt();\n        int eventIdentifier = buffer.readInt();\n        int txsSize = buffer.readByte();\n        Pair<String, Long>[] lastAppliedTransactions = new Pair[txsSize];\n        for ( int i = 0; i < txsSize; i++ )\n        {\n            lastAppliedTransactions[i] = new Pair<String, Long>(\n                    readString( buffer ), buffer.readLong() );\n        }\n        return new SlaveContext( machineId, eventIdentifier, lastAppliedTransactions );\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"hiding\" )\n        ByteData( ReadableByteChannel channel ) throws IOException\n        {\n            int size = 0, chunk = 0;\n            List<byte[]> data = new LinkedList<byte[]>();\n            ByteBuffer buffer = ByteBuffer.allocateDirect( 1 * MEGA );\n            while ( ( chunk = channel.read( buffer ) ) >= 0 )\n            {\n                size += chunk;\n                byte[] bytes = new byte[chunk];\n                buffer.flip();\n                buffer.get( bytes );\n                buffer.clear();\n                data.add( bytes );\n            }\n            this.data = data;\n            this.size = size;\n        }","id":334,"modified_method":"@SuppressWarnings( \"hiding\" )\n        ByteData( ReadableByteChannel channel ) throws IOException\n        {\n            this( channel, 1 * MEGA );\n        }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","id":335,"modified_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer )\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","id":336,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer )\n            {\n                return buffer.readLong();\n            }\n        });\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Integer> createRelationshipType( SlaveContext context, final String name )\n    {\n        return sendRequest( RequestType.CREATE_RELATIONSHIP_TYPE, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, name );\n            }\n        }, new Deserializer<Integer>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Integer read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readInt();\n            }\n        } );\n    }","id":337,"modified_method":"public Response<Integer> createRelationshipType( SlaveContext context, final String name )\n    {\n        return sendRequest( RequestType.CREATE_RELATIONSHIP_TYPE, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, name );\n            }\n        }, new Deserializer<Integer>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Integer read( ChannelBuffer buffer )\n            {\n                return buffer.readInt();\n            }\n        } );\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            Channel channel = getChannel();\n            channel.write( buffer );\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n\n            ChannelBuffer message = reader.read( 20, TimeUnit.SECONDS );\n            if ( message == null )\n            {\n                throw new HaCommunicationException( \"Channel has been closed\" );\n            }\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( message ) : TransactionStreams.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":338,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            Channel channel = getChannel();\n            ( (InputReader) channel.getPipeline().get( \"transactionReader\" ) ).setDeserializer( deserializer );\n            channel.write( buffer );\n            @SuppressWarnings( \"unchecked\" ) BlockingReadHandler<Response<T>> reader = (BlockingReadHandler<Response<T>>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n\n            Response<T> result = reader.read( 20, TimeUnit.SECONDS );\n            if ( result == null )\n            {\n                throw new HaCommunicationException( \"Channel has been closed\" );\n            }\n            return result;\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        BlockingReadHandler<ChannelBuffer> reader = new BlockingReadHandler<ChannelBuffer>();\n        pipeline.addLast( \"blockingHandler\", reader );\n        return pipeline;\n    }","id":339,"modified_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        /*\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        */\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"transactionReader\", new InputReader() );\n        pipeline.addLast( \"blockingHandler\", new BlockingReadHandler<Response<?>>() );\n        return pipeline;\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"serverHandler\", new ServerHandler() );\n        return pipeline;\n    }","id":340,"modified_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"chunkedWriter\", new ChunkedWriteHandler() );\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        // pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"serverHandler\", new ServerHandler() );\n        return pipeline;\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent event )\n                throws Exception\n        {\n            try\n            {\n                ChannelBuffer message = (ChannelBuffer) event.getMessage();\n                ChannelBuffer result = handleRequest( realMaster, message, \n                        event.getChannel(), MasterServer.this );\n                event.getChannel().write( result );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace();\n                throw e;\n            }\n        }","id":341,"modified_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent event )\n                throws Exception\n        {\n            try\n            {\n                ChannelBuffer message = (ChannelBuffer) event.getMessage();\n                RequestType type = RequestType.values()[message.readByte()];\n                Channel channel = event.getChannel();\n                SlaveContext context = null;\n                if ( type.includesSlaveContext() )\n                {\n                    context = CommunicationProtocol.readSlaveContext( message );\n                    mapSlave( channel, context );\n                }\n                channel.write( new ChunkedResponse( type.caller.callMaster( realMaster, context,\n                        message ), type.serializer, type.includesSlaveContext() ) );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace();\n                throw e;\n            }\n        }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        getServer().getDb().shutdown();\n        return null;\n    }","id":342,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        getServer().getDb().shutdown();\n        return \"exit\";\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":343,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        FakeMasterBroker broker = new FakeMasterBroker( masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","id":344,"modified_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        Broker broker = makeMasterBroker( master, masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        FakeMasterBroker broker = new FakeMasterBroker( masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","id":345,"modified_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        Broker broker = makeMasterBroker( master, masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","commit_id":"9be424b4481c15bc98772c49ff9063b125d27d93","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":346,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"9be424b4481c15bc98772c49ff9063b125d27d93","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":347,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"71385703557babd76a92606bceac6c7bce914383","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        FakeMasterBroker broker = new FakeMasterBroker( masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","id":348,"modified_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        Broker broker = makeMasterBroker( master, masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","commit_id":"71385703557babd76a92606bceac6c7bce914383","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":349,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"799d4d91102cec187bed5d9aef4199b019e041f5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        FakeMasterBroker broker = new FakeMasterBroker( masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","id":350,"modified_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        Broker broker = makeMasterBroker( master, masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","commit_id":"799d4d91102cec187bed5d9aef4199b019e041f5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"boxing\" )\n    private static SlaveContext readSlaveContext( ChannelBuffer buffer )\n    {\n        int machineId = buffer.readInt();\n        int eventIdentifier = buffer.readInt();\n        int txsSize = buffer.readByte();\n        Pair<String, Long>[] lastAppliedTransactions = new Pair[txsSize];\n        for ( int i = 0; i < txsSize; i++ )\n        {\n            lastAppliedTransactions[i] = new Pair<String, Long>(\n                    readString( buffer ), buffer.readLong() );\n        }\n        return new SlaveContext( machineId, eventIdentifier, lastAppliedTransactions );\n    }","id":351,"modified_method":"@SuppressWarnings( \"boxing\" )\n    static SlaveContext readSlaveContext( ChannelBuffer buffer )\n    {\n        int machineId = buffer.readInt();\n        int eventIdentifier = buffer.readInt();\n        int txsSize = buffer.readByte();\n        Pair<String, Long>[] lastAppliedTransactions = new Pair[txsSize];\n        for ( int i = 0; i < txsSize; i++ )\n        {\n            lastAppliedTransactions[i] = new Pair<String, Long>(\n                    readString( buffer ), buffer.readLong() );\n        }\n        return new SlaveContext( machineId, eventIdentifier, lastAppliedTransactions );\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"hiding\" )\n        ByteData( ReadableByteChannel channel ) throws IOException\n        {\n            int size = 0, chunk = 0;\n            List<byte[]> data = new LinkedList<byte[]>();\n            ByteBuffer buffer = ByteBuffer.allocateDirect( 1 * MEGA );\n            while ( ( chunk = channel.read( buffer ) ) >= 0 )\n            {\n                size += chunk;\n                byte[] bytes = new byte[chunk];\n                buffer.flip();\n                buffer.get( bytes );\n                buffer.clear();\n                data.add( bytes );\n            }\n            this.data = data;\n            this.size = size;\n        }","id":352,"modified_method":"@SuppressWarnings( \"hiding\" )\n        ByteData( ReadableByteChannel channel ) throws IOException\n        {\n            this( channel, 1 * MEGA );\n        }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        BlockingReadHandler<ChannelBuffer> reader = new BlockingReadHandler<ChannelBuffer>();\n        pipeline.addLast( \"blockingHandler\", reader );\n        return pipeline;\n    }","id":353,"modified_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        /*\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        */\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"transactionReader\", new InputReader() );\n        pipeline.addLast( \"blockingHandler\", new BlockingReadHandler<Response<?>>() );\n        return pipeline;\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","id":354,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer )\n            {\n                return buffer.readLong();\n            }\n        });\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            Channel channel = getChannel();\n            channel.write( buffer );\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n\n            ChannelBuffer message = reader.read( 20, TimeUnit.SECONDS );\n            if ( message == null )\n            {\n                throw new HaCommunicationException( \"Channel has been closed\" );\n            }\n            T response = deserializer.read( message );\n            TransactionStreams txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( message ) : TransactionStreams.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":355,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        try\n        {\n            // Send 'em over the wire\n            ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer );\n            Channel channel = getChannel();\n            ( (InputReader) channel.getPipeline().get( \"transactionReader\" ) ).setDeserializer( deserializer );\n            channel.write( buffer );\n            @SuppressWarnings( \"unchecked\" ) BlockingReadHandler<Response<T>> reader = (BlockingReadHandler<Response<T>>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n\n            Response<T> result = reader.read( 20, TimeUnit.SECONDS );\n            if ( result == null )\n            {\n                throw new HaCommunicationException( \"Channel has been closed\" );\n            }\n            return result;\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer ) throws IOException\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","id":356,"modified_method":"public IdAllocation allocateIds( final IdType idType )\n    {\n        return sendRequest( RequestType.ALLOCATE_IDS, null, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeByte( idType.ordinal() );\n            }\n        }, new Deserializer<IdAllocation>()\n        {\n            public IdAllocation read( ChannelBuffer buffer )\n            {\n                return readIdAllocation( buffer );\n            }\n        } ).response();\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Integer> createRelationshipType( SlaveContext context, final String name )\n    {\n        return sendRequest( RequestType.CREATE_RELATIONSHIP_TYPE, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, name );\n            }\n        }, new Deserializer<Integer>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Integer read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readInt();\n            }\n        } );\n    }","id":357,"modified_method":"public Response<Integer> createRelationshipType( SlaveContext context, final String name )\n    {\n        return sendRequest( RequestType.CREATE_RELATIONSHIP_TYPE, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, name );\n            }\n        }, new Deserializer<Integer>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Integer read( ChannelBuffer buffer )\n            {\n                return buffer.readInt();\n            }\n        } );\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent event )\n                throws Exception\n        {\n            try\n            {\n                ChannelBuffer message = (ChannelBuffer) event.getMessage();\n                ChannelBuffer result = handleRequest( realMaster, message, \n                        event.getChannel(), MasterServer.this );\n                event.getChannel().write( result );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace();\n                throw e;\n            }\n        }","id":358,"modified_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent event )\n                throws Exception\n        {\n            try\n            {\n                ChannelBuffer message = (ChannelBuffer) event.getMessage();\n                RequestType type = RequestType.values()[message.readByte()];\n                Channel channel = event.getChannel();\n                SlaveContext context = null;\n                if ( type.includesSlaveContext() )\n                {\n                    context = CommunicationProtocol.readSlaveContext( message );\n                    mapSlave( channel, context );\n                }\n                channel.write( new ChunkedResponse( type.caller.callMaster( realMaster, context,\n                        message ), type.serializer, type.includesSlaveContext() ) );\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace();\n                throw e;\n            }\n        }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"serverHandler\", new ServerHandler() );\n        return pipeline;\n    }","id":359,"modified_method":"public ChannelPipeline getPipeline() throws Exception\n    {\n        ChannelPipeline pipeline = Channels.pipeline();\n        pipeline.addLast( \"chunkedWriter\", new ChunkedWriteHandler() );\n        pipeline.addLast( \"frameDecoder\", new LengthFieldBasedFrameDecoder( MAX_FRAME_LENGTH,\n                0, 4, 0, 4 ) );\n        // pipeline.addLast( \"frameEncoder\", new LengthFieldPrepender( 4 ) );\n        pipeline.addLast( \"serverHandler\", new ServerHandler() );\n        return pipeline;\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        getServer().getDb().shutdown();\n        return null;\n    }","id":360,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out ) throws Exception\n    {\n        getServer().getDb().shutdown();\n        return \"exit\";\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":361,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        FakeMasterBroker broker = new FakeMasterBroker( masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","id":362,"modified_method":"@Override\n    protected void startUpMaster( Map<String, String> extraConfig )\n    {\n        int masterId = 0;\n        Map<String, String> config = MapUtil.stringMap( extraConfig,\n                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, String.valueOf( masterId ) );\n        Broker broker = makeMasterBroker( master, masterId, dbPath( 0 ).getAbsolutePath() );\n        HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase( dbPath( 0 ).getAbsolutePath(),\n                config, AbstractBroker.wrapSingleBroker( broker ) );\n        // db.newMaster( null, new Exception() );\n        master = new MasterImpl( db );\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void _initialize(boolean loadSpringXML) {\n\t\tif (_initialized) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\tPropsUtil.setProps(new PropsImpl());\n\n\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\tnew PortalExecutorManagerUtil();\n\n\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\tnew MockPortalExecutorManager());\n\n\t\tif (loadSpringXML) {\n\t\t\tString servletContextName = StringUtil.randomId();\n\n\t\t\tClass<?> clazz = getClass();\n\n\t\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t\tClassLoaderPool.register(servletContextName, classLoader);\n\t\t\tPortletClassLoaderUtil.setServletContextName(servletContextName);\n\n\t\t\ttry {\n\t\t\t\tApplicationContext applicationContext =\n\t\t\t\t\tnew FileSystemXmlApplicationContext(\n\t\t\t\t\t\t\"portal-impl/test/unit/com/liferay/portal/cluster/\" +\n\t\t\t\t\t\t\t\"test-spring.xml\");\n\n\t\t\t\tBeanLocator beanLocator = new BeanLocatorImpl(\n\t\t\t\t\tclassLoader, applicationContext);\n\n\t\t\t\tPortalBeanLocatorUtil.setBeanLocator(beanLocator);\n\n\t\t\t\tPortletBeanLocatorUtil.setBeanLocator(\n\t\t\t\t\tSERVLET_CONTEXT_NAME, beanLocator);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tClassLoaderPool.unregister(servletContextName);\n\t\t\t\tPortletClassLoaderUtil.setServletContextName(null);\n\t\t\t}\n\t\t}\n\n\t\t_initialized = true;\n\t}","id":363,"modified_method":"private void _initialize() {\n\t\tif (_initialized) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\tPropsUtil.setProps(new PropsImpl());\n\n\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\tnew PortalExecutorManagerUtil();\n\n\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\tnew MockPortalExecutorManager());\n\n\t\t_initialized = true;\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected ClusterExecutorImpl getClusterExecutorImpl(\n\t\tboolean useMockReceiver, boolean loadSpringXML) {\n\n\t\t_initialize(loadSpringXML);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\tclusterExecutorImpl.afterPropertiesSet();\n\n\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\tif (useMockReceiver) {\n\t\t\tChannel channel = clusterExecutorImpl.getControlChannel();\n\n\t\t\tchannel.setReceiver(\n\t\t\t\tnew MockClusterRequestReceiver(clusterExecutorImpl));\n\t\t}\n\n\t\tclusterExecutorImpl.initialize();\n\n\t\treturn clusterExecutorImpl;\n\t}","id":364,"modified_method":"protected ClusterExecutorImpl getClusterExecutorImpl() {\n\t\t_initialize();\n\n\t\tClusterExecutorImpl clusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\tclusterExecutorImpl.afterPropertiesSet();\n\n\t\tclusterExecutorImpl.initialize();\n\n\t\treturn clusterExecutorImpl;\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() {\n\t\t_captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterBase.class.getName(), Level.OFF);\n\t}","id":365,"modified_method":"@Before\n\tpublic void setUp() {\n\t\t_clusterBaseCaptureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterBase.class.getName(), Level.OFF);\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Around(\"call(* org.jgroups.JChannel.send(..))\")\n\t\tpublic Object throwException(ProceedingJoinPoint proceedingJoinPoint)\n\t\t\tthrows Throwable {\n\n\t\t\tthrow new Exception();\n\t\t}","id":366,"modified_method":"@Around(\"call(* org.jgroups.JChannel.send(..))\")\n\t\tpublic Object send(ProceedingJoinPoint proceedingJoinPoint)\n\t\t\tthrows Throwable {\n\n\t\t\tthrow new Exception();\n\t\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@After\n\tpublic void tearDown() {\n\t\t_captureHandler.close();\n\t}","id":367,"modified_method":"@After\n\tpublic void tearDown() {\n\t\t_clusterBaseCaptureHandler.close();\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class, JChannelExceptionAdvice.class,\n\t\t\tSetBadPortalInetSocketAddressAdvice.class\n\t\t})\n\t@Test\n\tpublic void testErrorLogAndExceptions() throws UnknownHostException {\n\t\tSetBadPortalInetSocketAddressAdvice.setPort(8080);\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\tPropsUtil.setProps(new PropsImpl());\n\n\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\tnew PortalExecutorManagerUtil();\n\n\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\tnew ClusterExecutorImplTest.MockPortalExecutorManager());\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterExecutorImpl.class.getName(), Level.SEVERE);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\t\tclusterExecutorImpl.afterPropertiesSet();\n\n\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to parse portal InetSocketAddress from bad \" +\n\t\t\t\t\t\"address:8080\",\n\t\t\t\tlogRecord.getMessage());\n\n\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\tAssert.assertSame(UnknownHostException.class, throwable.getClass());\n\n\t\t\tlogRecord = logRecords.get(1);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to send notify message\", logRecord.getMessage());\n\n\t\t\tthrowable = logRecord.getThrown();\n\n\t\t\tAssert.assertSame(Exception.class, throwable.getClass());\n\n\t\t\tlogRecords.clear();\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(InetAddress.getLocalHost(), 80));\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to determine configure node port\",\n\t\t\t\tException.class);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(null);\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send multicast request\", e.getMessage());\n\t\t\t}\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, new AddressImpl(new MockAddress()));\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send unicast request\", e.getMessage());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":368,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class, JChannelExceptionAdvice.class,\n\t\t\tSetBadPortalInetSocketAddressAdvice.class\n\t\t})\n\t@Test\n\tpublic void testErrorLogAndExceptions() throws UnknownHostException {\n\t\tSetBadPortalInetSocketAddressAdvice.setPort(8080);\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(new PortalImpl());\n\n\t\tPortalUUIDUtil portalUUIDUtil = new PortalUUIDUtil();\n\n\t\tportalUUIDUtil.setPortalUUID(new PortalUUIDImpl());\n\n\t\tPropsUtil.setProps(new PropsImpl());\n\n\t\tPortalExecutorManagerUtil portalExecutorManagerUtil =\n\t\t\tnew PortalExecutorManagerUtil();\n\n\t\tportalExecutorManagerUtil.setPortalExecutorManager(\n\t\t\tnew ClusterExecutorImplTest.MockPortalExecutorManager());\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterExecutorImpl.class.getName(), Level.SEVERE);\n\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\n\t\t\t// Test 1, exception in initialization with log enabled\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\t\tclusterExecutorImpl.afterPropertiesSet();\n\n\t\t\tJChannelExceptionAdvice.setConnectException(new Exception());\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\t\t\t\tassertLogger(\n\t\t\t\t\tlogRecords, \"Unable to initialize\", Exception.class);\n\t\t\t}\n\n\t\t\t// Test 2, exception in initialization with log disabled\n\n\t\t\tlogRecords = captureHandler.resetLogLevel(Level.OFF);\n\n\t\t\tclusterExecutorImpl = new ClusterExecutorImpl();\n\n\t\t\tclusterExecutorImpl.afterPropertiesSet();\n\n\t\t\tJChannelExceptionAdvice.setConnectException(new Exception());\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\t\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t\t}\n\n\t\t\t// Test 2, exception in sendNotifyRequest\n\n\t\t\tJChannelExceptionAdvice.setConnectException(null);\n\n\t\t\tlogRecords = captureHandler.resetLogLevel(Level.SEVERE);\n\n\t\t\tclusterExecutorImpl.initialize();\n\n\t\t\tAssert.assertEquals(2, logRecords.size());\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to parse portal InetSocketAddress from bad \" +\n\t\t\t\t\t\"address:8080\",\n\t\t\t\tlogRecords.get(0).getMessage());\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to send notify message\",\n\t\t\t\tlogRecords.get(1).getMessage());\n\n\t\t\t// Test 3, exception in portalLocalInetSockAddressConfigured\n\n\t\t\tlogRecords = captureHandler.resetLogLevel(Level.SEVERE);\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(InetAddress.getLocalHost(), 80));\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to determine configure node port\",\n\t\t\t\tException.class);\n\n\t\t\t// Test 4, exception in execute multicast request\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(null);\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send multicast request\", e.getMessage());\n\t\t\t}\n\n\t\t\t// Test 5, exception in execute unicast request\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, new AddressImpl(new MockAddress()));\n\n\t\t\ttry {\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to send unicast request\", e.getMessage());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteByShortcutMethod() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(true, false);\n\n\t\t\tChannel channel = clusterExecutorImpl.getControlChannel();\n\n\t\t\tMockClusterRequestReceiver mockClusterRequestReceiver =\n\t\t\t\t(MockClusterRequestReceiver)channel.getReceiver();\n\n\t\t\tClusterRequest localClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.NOTIFY,\n\t\t\t\tlocalClusterRequest.getClusterMessageType());\n\n\t\t\t// shortcutLocalMethod is false\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tlocalClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.EXECUTE,\n\t\t\t\tlocalClusterRequest.getClusterMessageType());\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\n\t\t\t// shortcutLocalMethod is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tlocalClusterRequest =\n\t\t\t\tmockClusterRequestReceiver.waitLocalRequestMessage();\n\n\t\t\tAssert.assertNull(localClusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":369,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tBaseReceiverAdvice.class, DisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteByShortcutMethod() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\n\t\t\t// Test 1, notify message\n\n\t\t\tBaseReceiverAdvice.reset(1);\n\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tChannel channel = clusterExecutorImpl.getControlChannel();\n\n\t\t\tBaseReceiverAdvice.awaitMessageReceived();\n\n\t\t\tObject object = BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\tchannel.getReceiver(), channel.getAddress());\n\n\t\t\tClusterRequest clusterRequest = (ClusterRequest)object;\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.NOTIFY,\n\t\t\t\tclusterRequest.getClusterMessageType());\n\n\t\t\t// Test 2, shortcutLocalMethod is false\n\n\t\t\tBaseReceiverAdvice.reset(1);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler,\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress());\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(false);\n\n\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tBaseReceiverAdvice.awaitMessageReceived();\n\n\t\t\tobject = BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\tchannel.getReceiver(), channel.getAddress());\n\n\t\t\tclusterRequest = (ClusterRequest)object;\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tClusterMessageType.EXECUTE,\n\t\t\t\tclusterRequest.getClusterMessageType());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmethodHandler.toString(),\n\t\t\t\tclusterRequest.getMethodHandler().toString());\n\n\t\t\t// Test 3, shortcutLocalMethod is true\n\n\t\t\tBaseReceiverAdvice.reset(1);\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod1MethodKey, timestamp),\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress());\n\n\t\t\tclusterExecutorImpl.setShortcutLocalMethod(true);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tBaseReceiverAdvice.awaitMessageReceived();\n\n\t\t\tAssert.assertNull(\n\t\t\t\tBaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\t\tchannel.getReceiver(), channel.getAddress()));\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, clusterExecutorImpl.getLocalClusterNodeAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteBySkipLocal() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\t// skipLocal is false\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setSkipLocal(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\n\t\t\t// skipLocal is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setSkipLocal(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tAssert.assertEquals(0, futureClusterResponses.get().size());\n\t\t\tAssert.assertFalse(TestBean.TIMESTAMP.equals(timestamp));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":370,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteBySkipLocal() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\t// Test 1, skipLocal is false\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setSkipLocal(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, address);\n\n\t\t\t// Test 2, skipLocal is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tclusterRequest.setSkipLocal(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tAssert.assertEquals(0, futureClusterResponses.get().size());\n\t\t\tAssert.assertFalse(TestBean.TIMESTAMP.equals(timestamp));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteByLocalMethod4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":371,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteByLocalMethod() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\n\t\t\t// Test 1, execute TestBean.testMethod1\n\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod1MethodKey, StringPool.BLANK),\n\t\t\t\tclusterNode.getClusterNodeId());\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(), null,\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress());\n\n\t\t\t// Test 2, execute TestBean.testMethod2\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod2MethodKey),\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(),\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress(),\n\t\t\t\t\"Return value is not serializable\");\n\n\t\t\t// Test 3, execute TestBean.testMethod3\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod3MethodKey, timestamp),\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(),\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress(), timestamp);\n\n\t\t\t// Test 4, execute TestBean.testMethod4\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, clusterExecutorImpl.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(),\n\t\t\t\tclusterExecutorImpl.getLocalClusterNodeAddress(),\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tSetPortalInetSocketAddressAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":372,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tSetPortalInetSocketAddressAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testClusterTopology() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\t// Disconnected network\n\n\t\t\tupdateView(clusterExecutorImpl1);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitDepartMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.DEPART, clusterNode2);\n\n\t\t\t// Reconnected network\n\n\t\t\tupdateView(clusterExecutorImpl1, clusterExecutorImpl2);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":373,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testClusterTopology() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl();\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\t// Disconnected network\n\n\t\t\tupdateView(clusterExecutorImpl1);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitDepartMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.DEPART, clusterNode2);\n\n\t\t\t// Reconnected network\n\n\t\t\tupdateView(clusterExecutorImpl1, clusterExecutorImpl2);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteByFireAndForget() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\t\tString timestamp = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\t// fireAndForget is false\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(methodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, clusterExecutorImpl1.getClusterNodeAddresses());\n\n\t\t\t// fireAndForget is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\t\tmethodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tfutureClusterResponses.get(1000, TimeUnit.MILLISECONDS);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TimeoutException te) {\n\t\t\tAssert.assertEquals(TestBean.TIMESTAMP, timestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":374,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteByFireAndForget() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\t\tString timestamp = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl();\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl();\n\n\t\t\t// fireAndForget is false\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tClusterRequest clusterRequest =\n\t\t\t\tClusterRequest.createMulticastRequest(methodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(false);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, clusterExecutorImpl1.getClusterNodeAddresses());\n\n\t\t\t// fireAndForget is true\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tmethodHandler = new MethodHandler(testMethod1MethodKey, timestamp);\n\n\t\t\tclusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\t\tmethodHandler);\n\n\t\t\tclusterRequest.setFireAndForget(true);\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tfutureClusterResponses.get(1000, TimeUnit.MILLISECONDS);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (TimeoutException te) {\n\t\t\tAssert.assertEquals(TestBean.TIMESTAMP, timestamp);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testMemberRemoved() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tList<Address> addresses = new ArrayList<Address>();\n\n\t\t\taddresses.add(new AddressImpl(new MockAddress()));\n\n\t\t\tclusterExecutorImpl.memberRemoved(addresses);\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitDepartMessage();\n\n\t\t\tAssert.assertNull(clusterEvent);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":375,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testMemberRemoved() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tList<Address> addresses = new ArrayList<Address>();\n\n\t\t\taddresses.add(new AddressImpl(new MockAddress()));\n\n\t\t\tclusterExecutorImpl.memberRemoved(addresses);\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitDepartMessage();\n\n\t\t\tAssert.assertNull(clusterEvent);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tSetBadPortalInetSocketAddressAdvice.class,\n\t\t\tSetWebServerProtocolAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tAssert.assertNull(clusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":376,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tSetBadPortalInetSocketAddressAdvice.class,\n\t\t\tSetWebServerProtocolAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured4() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tAssert.assertNull(clusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tEnableClusterExecutorDebugAdvice.class, EnableLiveUsersAdvice.class\n\t\t})\n\t@Test\n\tpublic void testClusterEventListener1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tList<ClusterEventListener> clusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t// Add\n\n\t\t\tClusterEventListener clusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(clusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\n\t\t\t// Remove\n\n\t\t\tclusterExecutorImpl.removeClusterEventListener(\n\t\t\t\tclusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t// Set\n\n\t\t\tclusterEventListeners = new ArrayList<ClusterEventListener>();\n\n\t\t\tclusterEventListeners.add(clusterEventListener);\n\n\t\t\tclusterExecutorImpl.setClusterEventListeners(clusterEventListeners);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":377,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tEnableClusterExecutorDebugAdvice.class, EnableLiveUsersAdvice.class\n\t\t})\n\t@Test\n\tpublic void testClusterEventListener() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tList<ClusterEventListener> clusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t// Add\n\n\t\t\tClusterEventListener clusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl.addClusterEventListener(clusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\n\t\t\t// Remove\n\n\t\t\tclusterExecutorImpl.removeClusterEventListener(\n\t\t\t\tclusterEventListener);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(2, clusterEventListeners.size());\n\n\t\t\t// Set\n\n\t\t\tclusterEventListeners = new ArrayList<ClusterEventListener>();\n\n\t\t\tclusterEventListeners.add(clusterEventListener);\n\n\t\t\tclusterExecutorImpl.setClusterEventListeners(clusterEventListeners);\n\n\t\t\tclusterEventListeners =\n\t\t\t\tclusterExecutorImpl.getClusterEventListeners();\n\n\t\t\tAssert.assertEquals(3, clusterEventListeners.size());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tupdateView(clusterExecutorImpl1);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitDepartMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.DEPART, clusterNode2);\n\n\t\t\tAssert.assertNull(clusterNode2.getPortalInetSocketAddress());\n\n\t\t\tInetAddress inetAddress = InetAddress.getLocalHost();\n\t\t\tint port = 8080;\n\n\t\t\tclusterExecutorImpl2.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(inetAddress, port));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(inetAddress, port),\n\t\t\t\tclusterNode2.getPortalInetSocketAddress());\n\n\t\t\tclusterEvent = mockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":378,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured1() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl();\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tupdateView(clusterExecutorImpl1);\n\n\t\t\tclusterEvent = mockClusterEventListener.waitDepartMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.DEPART, clusterNode2);\n\n\t\t\tAssert.assertNull(clusterNode2.getPortalInetSocketAddress());\n\n\t\t\tInetAddress inetAddress = InetAddress.getLocalHost();\n\t\t\tint port = 8080;\n\n\t\t\tclusterExecutorImpl2.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(inetAddress, port));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(inetAddress, port),\n\t\t\t\tclusterNode2.getPortalInetSocketAddress());\n\n\t\t\tclusterEvent = mockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteWithCallBack() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tMockClusterResponseCallback mockClusterResponseCallback =\n\t\t\t\tnew MockClusterResponseCallback();\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(\n\t\t\t\t\tclusterRequest, mockClusterResponseCallback);\n\n\t\t\tBlockingQueue<ClusterNodeResponse> blockingQueue =\n\t\t\t\tmockClusterResponseCallback.waitMessage();\n\n\t\t\tAssert.assertSame(\n\t\t\t\tfutureClusterResponses.getPartialResults(), blockingQueue);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":379,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testExecuteWithCallBack() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod1MethodKey, timestamp);\n\n\t\t\tAddress address = clusterExecutorImpl.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tMockClusterResponseCallback mockClusterResponseCallback =\n\t\t\t\tnew MockClusterResponseCallback();\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl.execute(\n\t\t\t\t\tclusterRequest, mockClusterResponseCallback);\n\n\t\t\tBlockingQueue<ClusterNodeResponse> blockingQueue =\n\t\t\t\tmockClusterResponseCallback.waitMessage();\n\n\t\t\tAssert.assertSame(\n\t\t\t\tfutureClusterResponses.getPartialResults(), blockingQueue);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tSetPortalInetSocketAddressAdvice.class,\n\t\t\tSetWebServerProtocolAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":380,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tSetPortalInetSocketAddressAdvice.class,\n\t\t\tSetWebServerProtocolAdvice.class\n\t\t})\n\t@Test\n\tpublic void testPortalConfigured3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode = clusterExecutorImpl.getLocalClusterNode();\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\n\t\t\tclusterExecutorImpl.portalLocalInetSockAddressConfigured(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.PORTAL_PORT));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tnew InetSocketAddress(\n\t\t\t\t\tInetAddress.getByName(\n\t\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_ADDRESS),\n\t\t\t\t\tSetPortalInetSocketAddressAdvice.SECURE_PORTAL_PORT),\n\t\t\t\tclusterNode.getPortalInetSocketAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl != null) {\n\t\t\t\tclusterExecutorImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testGetMethods2() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tClusterNode clusterNode1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNode();\n\n\t\t\tAssert.assertNotNull(clusterNode1);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tAssert.assertNotNull(clusterNode2);\n\n\t\t\tAddress address1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(address1);\n\n\t\t\tAddress address2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(address2);\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterExecutorImpl1.getClusterNodeAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\t\t\tAssert.assertTrue(addresses.contains(address1));\n\t\t\tAssert.assertTrue(addresses.contains(address2));\n\n\t\t\tList<ClusterNode> clusterNodes =\n\t\t\t\tclusterExecutorImpl1.getClusterNodes();\n\n\t\t\tAssert.assertEquals(2, clusterNodes.size());\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode1));\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode2));\n\n\t\t\tboolean clusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\tclusterNode2.getClusterNodeId());\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tclusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\t\tclusterNode2.getClusterNodeId()));\n\n\t\t\tclusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\taddress2);\n\n\t\t\tAssert.assertTrue(clusterNodeAlive);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":381,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testGetMethods() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl();\n\n\t\t\tMockClusterEventListener mockClusterEventListener =\n\t\t\t\tnew MockClusterEventListener();\n\n\t\t\tclusterExecutorImpl1.addClusterEventListener(\n\t\t\t\tmockClusterEventListener);\n\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl();\n\n\t\t\tClusterNode clusterNode1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNode();\n\n\t\t\tAssert.assertNotNull(clusterNode1);\n\n\t\t\tClusterNode clusterNode2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNode();\n\n\t\t\tAssert.assertNotNull(clusterNode2);\n\n\t\t\tAddress address1 =\n\t\t\t\tclusterExecutorImpl1.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(address1);\n\n\t\t\tAddress address2 =\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tAssert.assertNotNull(address2);\n\n\t\t\tClusterEvent clusterEvent =\n\t\t\t\tmockClusterEventListener.waitJoinMessage();\n\n\t\t\tassertClusterEvent(\n\t\t\t\tclusterEvent, ClusterEventType.JOIN, clusterNode2);\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterExecutorImpl1.getClusterNodeAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\t\t\tAssert.assertTrue(addresses.contains(address1));\n\t\t\tAssert.assertTrue(addresses.contains(address2));\n\n\t\t\tList<ClusterNode> clusterNodes =\n\t\t\t\tclusterExecutorImpl1.getClusterNodes();\n\n\t\t\tAssert.assertEquals(2, clusterNodes.size());\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode1));\n\t\t\tAssert.assertTrue(clusterNodes.contains(clusterNode2));\n\n\t\t\tboolean clusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\tclusterNode2.getClusterNodeId());\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tclusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\t\tclusterNode2.getClusterNodeId()));\n\n\t\t\tclusterNodeAlive = clusterExecutorImpl1.isClusterNodeAlive(\n\t\t\t\taddress2);\n\n\t\t\tAssert.assertTrue(clusterNodeAlive);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testInitChannel2() throws Exception {\n\t\ttry {\n\t\t\tgetClusterLinkImpl();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t}\n\t}","id":382,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testInitChannel() throws Exception {\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.OFF);\n\n\t\ttry {\n\n\t\t\t// Test 1, create ClusterLinkImpl.MAX_CHANNEL_COUNT channels\n\n\t\t\tTransportationConfigurationAdvice.setChannelCount(\n\t\t\t\tClusterLinkImpl.MAX_CHANNEL_COUNT + 1);\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\ttry {\n\t\t\t\tgetClusterLinkImpl();\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\t\t\t\tAssert.assertEquals(0, logRecords.size());\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"java.lang.IllegalArgumentException: Channel count must \" +\n\t\t\t\t\t\t\"be between 1 and \" + ClusterLinkImpl.MAX_CHANNEL_COUNT,\n\t\t\t\t\tise.getMessage());\n\t\t\t}\n\n\t\t\t// Test 2, create 0 channel\n\n\t\t\tTransportationConfigurationAdvice.setChannelCount(0);\n\n\t\t\tlogRecords = captureHandler.resetLogLevel(Level.SEVERE);\n\n\t\t\ttry {\n\t\t\t\tgetClusterLinkImpl();\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\t\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"Unable to initialize channels\",\n\t\t\t\t\tlogRecords.get(0).getMessage());\n\n\t\t\t\tAssert.assertEquals(\n\t\t\t\t\t\"java.lang.IllegalArgumentException: Channel count must \" +\n\t\t\t\t\t\t\"be between 1 and \" + ClusterLinkImpl.MAX_CHANNEL_COUNT,\n\t\t\t\t\tise.getMessage());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage2() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\t\tTestReceiver testReceiver1 = getTestReceiver(jChannels1, 0);\n\t\t\tTestReceiver testReceiver2 = getTestReceiver(jChannels2, 0);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl1.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(jChannels2.get(0).getAddress()), message,\n\t\t\t\tPriority.LEVEL1);\n\n\t\t\tString localMessage1 = testReceiver1.waitLocalMessage();\n\t\t\tString remoteMessage1 = testReceiver1.waitRemoteMessage();\n\t\t\tString localMessage2 = testReceiver2.waitLocalMessage();\n\t\t\tString remoteMessage2 = testReceiver2.waitRemoteMessage();\n\n\t\t\tString messageKey = (String)message.getPayload();\n\n\t\t\tAssert.assertNull(localMessage1);\n\t\t\tAssert.assertNull(remoteMessage1);\n\t\t\tAssert.assertNull(localMessage2);\n\t\t\tAssert.assertEquals(messageKey, remoteMessage2);\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":383,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessageWithError() {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\n\t\t\t// Test 1, send message when clusterLinkImpl is destroyed\n\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tclusterLinkImpl.destroy();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\n\t\t\t// Test 2, send message when clusterLinkImpl is disconnected\n\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.disconnect();\n\n\t\t\tlogRecords = captureHandler.resetLogLevel(Level.WARNING);\n\n\t\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected ClusterLinkImpl getClusterLinkImpl() {\n\t\tClusterLinkImpl clusterLinkImpl = new ClusterLinkImpl();\n\n\t\tclusterLinkImpl.setClusterForwardMessageListener(\n\t\t\tnew ClusterForwardMessageListener());\n\n\t\tclusterLinkImpl.afterPropertiesSet();\n\n\t\tif (clusterLinkImpl.isEnabled()) {\n\t\t\tAssert.assertNotNull(clusterLinkImpl.getBindInetAddress());\n\t\t}\n\n\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\tif (jChannels != null) {\n\t\t\tfor (JChannel channel : jChannels) {\n\t\t\t\tchannel.setReceiver(\n\t\t\t\t\tnew TestReceiver(new AddressImpl(channel.getAddress())));\n\t\t\t}\n\t\t}\n\n\t\treturn clusterLinkImpl;\n\t}","id":384,"modified_method":"protected ClusterLinkImpl getClusterLinkImpl() {\n\t\tClusterLinkImpl clusterLinkImpl = new ClusterLinkImpl();\n\n\t\tclusterLinkImpl.afterPropertiesSet();\n\n\t\tclusterLinkImpl.initialize();\n\n\t\tif (clusterLinkImpl.isEnabled()) {\n\t\t\tAssert.assertNotNull(clusterLinkImpl.getBindInetAddress());\n\t\t}\n\n\t\treturn clusterLinkImpl;\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage4() {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.disconnect();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterLinkImpl.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(new MockAddress()), message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send unicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":385,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tBaseReceiverAdvice.class, DisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendUnicastMessage() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tBaseReceiverAdvice.reset(1);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\t\tJChannel jChannel1 = jChannels1.get(0);\n\t\t\tJChannel jChannel2 = jChannels2.get(0);\n\n\t\t\tReceiver receiver1 = jChannel1.getReceiver();\n\t\t\tReceiver receiver2 = jChannel2.getReceiver();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl1.sendUnicastMessage(\n\t\t\t\tnew AddressImpl(jChannels2.get(0).getAddress()), message,\n\t\t\t\tPriority.LEVEL1);\n\n\t\t\torg.jgroups.Address sourceAddress = jChannel1.getAddress();\n\n\t\t\tBaseReceiverAdvice.awaitMessageReceived();\n\n\t\t\tMessage receivedMessage1 =\n\t\t\t\t(Message)BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\t\treceiver1, sourceAddress);\n\t\t\tMessage receivedMessage2 =\n\t\t\t\t(Message)BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\t\treceiver2, sourceAddress);\n\n\t\t\tAssert.assertNull(receivedMessage1);\n\t\t\tAssert.assertEquals(\n\t\t\t\tmessage.getPayload(), receivedMessage2.getPayload());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testDestroy1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":386,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testDestroy() {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\t\tAssert.assertTrue(isOpen(jChannels.get(0)));\n\t\t\tAssert.assertTrue(isOpen(jChannels.get(1)));\n\n\t\t\tclusterLinkImpl.destroy();\n\n\t\t\tAssert.assertFalse(isOpen(jChannels.get(0)));\n\t\t\tAssert.assertFalse(isOpen(jChannels.get(1)));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage4() {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.disconnect();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":387,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessageWithError() {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\n\t\t\t// Test 1, send message when clusterLinkImpl is destroyed\n\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tclusterLinkImpl.destroy();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\n\t\t\t// Test 2, send message when clusterLinkImpl is disconnected\n\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.disconnect();\n\n\t\t\tlogRecords = captureHandler.resetLogLevel(Level.WARNING);\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetLocalTransportAddresses2() {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterLinkImpl.getLocalTransportAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tgetJGroupsAddress(jChannels, 0), getRealAddress(addresses, 0));\n\t\t\tAssert.assertSame(\n\t\t\t\tgetJGroupsAddress(jChannels, 1), getRealAddress(addresses, 1));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":388,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetLocalTransportAddresses() {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<Address> addresses =\n\t\t\t\tclusterLinkImpl.getLocalTransportAddresses();\n\n\t\t\tAssert.assertEquals(2, addresses.size());\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(0).getAddress(),\n\t\t\t\taddresses.get(0).getRealAddress());\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(1).getAddress(),\n\t\t\t\taddresses.get(1).getRealAddress());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetChannel() {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.FINE);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL1));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL2));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL3));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL4));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL5));\n\n\t\t\tjChannel = jChannels.get(1);\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL6));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL7));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL8));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL9));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannel, clusterLinkImpl.getChannel(Priority.LEVEL10));\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":389,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetChannel() {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.FINE);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tAssert.assertEquals(2, jChannels.size());\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(0), clusterLinkImpl.getChannel(Priority.LEVEL1));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(0), clusterLinkImpl.getChannel(Priority.LEVEL2));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(0), clusterLinkImpl.getChannel(Priority.LEVEL3));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(0), clusterLinkImpl.getChannel(Priority.LEVEL4));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(0), clusterLinkImpl.getChannel(Priority.LEVEL5));\n\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(1), clusterLinkImpl.getChannel(Priority.LEVEL6));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(1), clusterLinkImpl.getChannel(Priority.LEVEL7));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(1), clusterLinkImpl.getChannel(Priority.LEVEL8));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(1), clusterLinkImpl.getChannel(Priority.LEVEL9));\n\t\t\tAssert.assertSame(\n\t\t\t\tjChannels.get(1), clusterLinkImpl.getChannel(Priority.LEVEL10));\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(adviceClasses = {DisableClusterLinkAdvice.class})\n\t@Test\n\tpublic void testGetTransportAddressesByPriority1() throws Exception {\n\t\tClusterLinkImpl clusterLinkImpl = getClusterLinkImpl();\n\n\t\tList<Address> addresses = clusterLinkImpl.getTransportAddresses(\n\t\t\tPriority.LEVEL1);\n\n\t\tAssert.assertSame(Collections.emptyList(), addresses);\n\n\t\tclusterLinkImpl.destroy();\n\t}","id":390,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\t)\n\t@Test\n\tpublic void testGetTransportAddressesByPriority() {\n\t\tTransportationConfigurationAdvice.setChannelCount(2);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\n\t\t\tAssert.assertEquals(2, jChannels1.size());\n\t\t\tAssert.assertEquals(2, jChannels2.size());\n\n\t\t\tList<Address> addresses1 = clusterLinkImpl1.getTransportAddresses(\n\t\t\t\tPriority.LEVEL1);\n\t\t\tList<Address> addresses2 = clusterLinkImpl1.getTransportAddresses(\n\t\t\t\tPriority.LEVEL6);\n\n\t\t\tAssert.assertEquals(2, addresses1.size());\n\t\t\tAssert.assertEquals(2, addresses2.size());\n\n\t\t\tAssert.assertTrue(\n\t\t\t\taddresses1.contains(\n\t\t\t\t\tnew AddressImpl(jChannels1.get(0).getAddress())));\n\t\t\tAssert.assertTrue(\n\t\t\t\taddresses1.contains(\n\t\t\t\t\tnew AddressImpl(jChannels2.get(0).getAddress())));\n\n\t\t\tAssert.assertTrue(\n\t\t\t\taddresses2.contains(\n\t\t\t\t\tnew AddressImpl(jChannels1.get(1).getAddress())));\n\t\t\tAssert.assertTrue(\n\t\t\t\taddresses2.contains(\n\t\t\t\t\tnew AddressImpl(jChannels2.get(1).getAddress())));\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage3() {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterLinkImpl.class.getName(), Level.WARNING);\n\n\t\tClusterLinkImpl clusterLinkImpl = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl = getClusterLinkImpl();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tList<JChannel> jChannels = getJChannels(clusterLinkImpl);\n\n\t\t\tJChannel jChannel = jChannels.get(0);\n\n\t\t\tjChannel.close();\n\n\t\t\tList<LogRecord> logRecords = captureHandler.getLogRecords();\n\n\t\t\tclusterLinkImpl.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\tassertLogger(\n\t\t\t\tlogRecords, \"Unable to send multicast message \" + message,\n\t\t\t\tIllegalStateException.class);\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterLinkImpl != null) {\n\t\t\t\tclusterLinkImpl.destroy();\n\t\t\t}\n\t\t}\n\t}","id":391,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tBaseReceiverAdvice.class, DisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class,\n\t\t\tTransportationConfigurationAdvice.class\n\t\t}\n\n\t)\n\t@Test\n\tpublic void testSendMulticastMessage() throws Exception {\n\t\tTransportationConfigurationAdvice.setChannelCount(1);\n\n\t\tBaseReceiverAdvice.reset(3);\n\n\t\tClusterLinkImpl clusterLinkImpl1 = null;\n\t\tClusterLinkImpl clusterLinkImpl2 = null;\n\t\tClusterLinkImpl clusterLinkImpl3 = null;\n\n\t\ttry {\n\t\t\tclusterLinkImpl1 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl2 = getClusterLinkImpl();\n\t\t\tclusterLinkImpl3 = getClusterLinkImpl();\n\n\t\t\tList<JChannel> jChannels1 = getJChannels(clusterLinkImpl1);\n\t\t\tList<JChannel> jChannels2 = getJChannels(clusterLinkImpl2);\n\t\t\tList<JChannel> jChannels3 = getJChannels(clusterLinkImpl3);\n\n\t\t\tJChannel jChannel1 = jChannels1.get(0);\n\t\t\tJChannel jChannel2 = jChannels2.get(0);\n\t\t\tJChannel jChannel3 = jChannels3.get(0);\n\n\t\t\tReceiver receiver1 = jChannel1.getReceiver();\n\t\t\tReceiver receiver2 = jChannel2.getReceiver();\n\t\t\tReceiver receiver3 = jChannel3.getReceiver();\n\n\t\t\tMessage message = createMessage();\n\n\t\t\tclusterLinkImpl1.sendMulticastMessage(message, Priority.LEVEL1);\n\n\t\t\torg.jgroups.Address sourceAddress = jChannel1.getAddress();\n\n\t\t\tBaseReceiverAdvice.awaitMessageReceived();\n\n\t\t\tMessage receivedMessage1 =\n\t\t\t\t(Message)BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\t\treceiver1, sourceAddress);\n\t\t\tMessage receivedMessage2 =\n\t\t\t\t(Message)BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\t\treceiver2, sourceAddress);\n\t\t\tMessage receivedMessage3 =\n\t\t\t\t(Message)BaseReceiverAdvice.getJgroupsMessagePayload(\n\t\t\t\t\treceiver3, sourceAddress);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tmessage.getPayload(), receivedMessage1.getPayload());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmessage.getPayload(), receivedMessage2.getPayload());\n\t\t\tAssert.assertEquals(\n\t\t\t\tmessage.getPayload(), receivedMessage3.getPayload());\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterLinkImpl1 != null) {\n\t\t\t\tclusterLinkImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl2 != null) {\n\t\t\t\tclusterLinkImpl2.destroy();\n\t\t\t}\n\n\t\t\tif (clusterLinkImpl3 != null) {\n\t\t\t\tclusterLinkImpl3.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testInvoke3() throws Exception {\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl(false, false);\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl(false, false);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\ttestMethod2MethodKey);\n\n\t\t\tAddress address = clusterExecutorImpl2.getLocalClusterNodeAddress();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tmethodHandler, address);\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(), address,\n\t\t\t\t\"Return value is not serializable\");\n\t\t}\n\t\tfinally {\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","id":392,"modified_method":"@AdviseWith(\n\t\tadviceClasses = {\n\t\t\tDisableAutodetectedAddressAdvice.class,\n\t\t\tEnableClusterLinkAdvice.class\n\t\t})\n\t@Test\n\tpublic void testInvoke() throws Exception {\n\t\tCaptureHandler captureHandler = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tClusterRequestReceiver.class.getName(), Level.OFF);\n\n\t\tClusterExecutorImpl clusterExecutorImpl1 = null;\n\t\tClusterExecutorImpl clusterExecutorImpl2 = null;\n\n\t\ttry {\n\n\t\t\t// Test 1, return value is null\n\n\t\t\tclusterExecutorImpl1 = getClusterExecutorImpl();\n\t\t\tclusterExecutorImpl2 = getClusterExecutorImpl();\n\n\t\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod1MethodKey, StringPool.BLANK),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tclusterExecutorImpl1.execute(clusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(), null,\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\t// Test 2, return value is not null\n\n\t\t\tString timestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod1MethodKey, timestamp),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithoutException(\n\t\t\t\tfutureClusterResponses.get(), clusterRequest.getUuid(),\n\t\t\t\ttimestamp, clusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\t// Test 3, return value is not serializable\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod2MethodKey),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress(),\n\t\t\t\t\"Return value is not serializable\");\n\n\t\t\t// Test 4, exception\n\n\t\t\ttimestamp = String.valueOf(System.currentTimeMillis());\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnew MethodHandler(testMethod3MethodKey, timestamp),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress(), timestamp);\n\n\t\t\t// Test 5, methodHandler is null\n\n\t\t\tclusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\t\tnull, clusterExecutorImpl2.getLocalClusterNodeAddress());\n\n\t\t\tfutureClusterResponses = clusterExecutorImpl1.execute(\n\t\t\t\tclusterRequest);\n\n\t\t\tassertFutureClusterResponsesWithException(\n\t\t\t\tfutureClusterResponses, clusterRequest.getUuid(),\n\t\t\t\tclusterExecutorImpl2.getLocalClusterNodeAddress(),\n\t\t\t\t\"Payload is not of type \" + MethodHandler.class.getName());\n\t\t}\n\t\tfinally {\n\t\t\tcaptureHandler.close();\n\n\t\t\tif (clusterExecutorImpl1 != null) {\n\t\t\t\tclusterExecutorImpl1.destroy();\n\t\t\t}\n\n\t\t\tif (clusterExecutorImpl2 != null) {\n\t\t\t\tclusterExecutorImpl2.destroy();\n\t\t\t}\n\t\t}\n\t}","commit_id":"33ed75d3e0d4b257bd2b0899310c9522b3e54237","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Builds a mapping between groups and duty schedules. These are used when\n     * determining to send a notice to a given group. This helps speed up the decision process.\n     * @param groups the map of groups parsed from the xml config file\n     */\n    private static void buildDutySchedules(Map groups) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        Iterator i = groups.keySet().iterator();\n        while(i.hasNext()) {\n            String key = (String)i.next();\n            Group curGroup = (Group)groups.get(key);\n            if (curGroup.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                Enumeration duties = curGroup.enumerateDutySchedule();\n                while(duties.hasMoreElements()) {\n                    dutyList.add(new DutySchedule( (String)duties.nextElement() ));\n                }\n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","id":393,"modified_method":"/**\n     * Builds a mapping between groups and duty schedules. These are used when\n     * determining to send a notice to a given group. This helps speed up the decision process.\n     * @param groups the map of groups parsed from the XML configuration file\n     */\n    private static void buildDutySchedules(Map<String, Group> groups) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        Iterator<String> i = groups.keySet().iterator();\n        while(i.hasNext()) {\n            String key = i.next();\n            Group curGroup = groups.get(key);\n            if (curGroup.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                for (String duty : curGroup.getDutyScheduleCollection()) {\n                \tdutyList.add(new DutySchedule(duty));\n                }\n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Renames the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void renameGroup(String oldName, String newName) throws Exception {\n    \tif (oldName != null || !oldName.equals(\"\")) {\n    \t\tif (m_groups.containsKey(oldName)) {\n    \t\t\tGroup grp = (Group)m_groups.get(oldName);\n    \t\t\tgrp.setName(newName);\n    \t\t\tm_groups.put(newName, grp);\n    \t\t} else {\n    \t\t\tthrow new Exception(\"GroupFactory.renameGroup: Group doesn't exist: \" + oldName);\n    \t\t}\n    \t\t// Save into groups.xml\n    \t\tsaveGroups();\n    \t}\n    }","id":394,"modified_method":"/**\n     * Renames the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void renameGroup(String oldName, String newName) throws Exception {\n    \tif (oldName != null && !oldName.equals(\"\")) {\n    \t\tif (m_groups.containsKey(oldName)) {\n    \t\t\tGroup grp = m_groups.get(oldName);\n    \t\t\tgrp.setName(newName);\n    \t\t\tm_groups.put(newName, grp);\n    \t\t} else {\n    \t\t\tthrow new Exception(\"GroupFactory.renameGroup: Group doesn't exist: \" + oldName);\n    \t\t}\n    \t\t// Save into groups.xml\n    \t\tsaveGroups();\n    \t}\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OwnedIntervalSequence getRoleScheduleEntries(String roleid, Date start, Date end) throws MarshalException, ValidationException, IOException {\n        update();\n\n        OwnedIntervalSequence schedEntries = new OwnedIntervalSequence();\n        Role role = getRole(roleid);\n        for (int i = 0; i < role.getScheduleCount(); i++) {\n            Schedule sched = (Schedule) role.getSchedule(i);\n            Owner owner = new Owner(roleid, sched.getName(), i);\n            schedEntries.addAll(BasicScheduleUtils.getIntervalsCovering(start, end, sched, owner));\n        }\n        \n        OwnedIntervalSequence defaultEntries = new OwnedIntervalSequence(new OwnedInterval(start, end));\n        defaultEntries.removeAll(schedEntries);\n        Owner supervisor = new Owner(roleid, role.getSupervisor());\n        for (Iterator it = defaultEntries.iterator(); it.hasNext();) {\n            OwnedInterval interval = (OwnedInterval) it.next();\n            interval.addOwner(supervisor);\n        }\n        \n        schedEntries.addAll(defaultEntries);\n        return schedEntries;\n        \n    }","id":395,"modified_method":"public OwnedIntervalSequence getRoleScheduleEntries(String roleid, Date start, Date end) throws MarshalException, ValidationException, IOException {\n        update();\n\n        OwnedIntervalSequence schedEntries = new OwnedIntervalSequence();\n        Role role = getRole(roleid);\n        for (int i = 0; i < role.getScheduleCount(); i++) {\n            Schedule sched = role.getSchedule(i);\n            Owner owner = new Owner(roleid, sched.getName(), i);\n            schedEntries.addAll(BasicScheduleUtils.getIntervalsCovering(start, end, sched, owner));\n        }\n        \n        OwnedIntervalSequence defaultEntries = new OwnedIntervalSequence(new OwnedInterval(start, end));\n        defaultEntries.removeAll(schedEntries);\n        Owner supervisor = new Owner(roleid, role.getSupervisor());\n        for (Iterator<TimeInterval> it = defaultEntries.iterator(); it.hasNext();) {\n        \tOwnedInterval interval = new OwnedInterval(it.next());\n            interval.addOwner(supervisor);\n        }\n        \n        schedEntries.addAll(defaultEntries);\n        return schedEntries;\n        \n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Removes the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteGroup(String name) throws Exception {\n        // Check if the group exists\n        if (name != null || !name.equals(\"\")) {\n            if (m_groups.containsKey(name)) {\n                // Remove the group.\n                m_groups.remove(name);\n    \n            } else\n                throw new Exception(\"GroupFactory:delete Group doesnt exist:\" + name);\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user group:\" + name);\n        }\n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","id":396,"modified_method":"/**\n     * Removes the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteGroup(String name) throws Exception {\n        // Check if the group exists\n        if (name != null && !name.equals(\"\")) {\n            if (m_groups.containsKey(name)) {\n                // Remove the group.\n                m_groups.remove(name);\n            } else\n                throw new Exception(\"GroupFactory:delete Group doesnt exist:\" + name);\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user group:\" + name);\n        }\n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines when a group is next on duty. If a group has no duty schedules\n     * listed in the config file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return long, the time in millisec until the group is next on duty\n     */\n    public long groupNextOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        long next = -1;\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return 0;\n        }\n        List dutySchedules = (List)m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule)dutySchedules.get(i);\n            long tempnext =  curSchedule.nextInSchedule(time);\n            if( tempnext < next || next == -1 ) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isGroupOnDuty: On duty in \" + tempnext + \" millisec from schedule \" + i);\n                }\n                next = tempnext;\n            }\n        }\n        return next;\n    }","id":397,"modified_method":"/**\n     * Determines when a group is next on duty. If a group has no duty schedules\n     * listed in the configuration file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return long, the time in milliseconds until the group is next on duty\n     */\n    public long groupNextOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        long next = -1;\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return 0;\n        }\n        List<DutySchedule> dutySchedules = m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = dutySchedules.get(i);\n            long tempnext =  curSchedule.nextInSchedule(time);\n            if( tempnext < next || next == -1 ) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isGroupOnDuty: On duty in \" + tempnext + \" millisec from schedule \" + i);\n                }\n                next = tempnext;\n            }\n        }\n        return next;\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean userHasRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        Role role = getRole(roleid);\n        Iterator j = role.getScheduleCollection().iterator();\n        while(j.hasNext()) {\n            Schedule sched = (Schedule)j.next();\n            if (userId.equals(sched.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":398,"modified_method":"public boolean userHasRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        for (Schedule sched : getRole(roleid).getScheduleCollection()) {\n            if (userId.equals(sched.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List getUserSchedulesForRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> scheds = new ArrayList<Schedule>();\n        Role role = getRole(roleid);\n        Iterator it = role.getScheduleCollection().iterator();\n        while(it.hasNext()) {\n            Schedule sched = (Schedule)it.next();\n            if (userId.equals(sched.getName())) {\n                scheds.add(sched);\n            }\n        }\n        return scheds;\n        \n    }","id":399,"modified_method":"public List<Schedule> getUserSchedulesForRole(String userId, String roleId) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> scheds = new ArrayList<Schedule>();\n        for (Schedule sched : getRole(roleId).getScheduleCollection()) {\n            if (userId.equals(sched.getName())) {\n                scheds.add(sched);\n            }\n        }\n        return scheds;\n        \n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * When this method is called group name is changed, so also is the\n     * groupname belonging to the view. Also overwrites the \"groups.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (oldName == null || newName == null || oldName == \"\" || newName == \"\") {\n            throw new Exception(\"Group Factory: Rename user.. no value \");\n        } else {\n            Collection coll = (Collection) m_groups.values();\n            Iterator iter = (Iterator) coll.iterator();\n            Map<String, Group> map = new LinkedHashMap<String, Group>();\n    \n            while (iter.hasNext()) {\n                Group group = (Group) iter.next();\n                Enumeration en = group.enumerateUser();\n                String name = \"\";\n                while (en.hasMoreElements()) {\n                    name = (String) en.nextElement();\n                    if (name.equals(oldName)) {\n                        group.removeUser(oldName);\n                        group.addUser(newName);\n                    }\n                }\n                map.put(group.getName(), group);\n            }\n            m_groups.clear();\n            m_groups = map;\n            \n            Iterator it = m_roles.values().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                Iterator j = role.getScheduleCollection().iterator();\n                while(j.hasNext()) {\n                    Schedule sched = (Schedule)j.next();\n                    if (oldName.equals(sched.getName())) {\n                        sched.setName(newName);\n                    }\n                }\n            }\n            \n            saveGroups();\n        }\n    }","id":400,"modified_method":"/**\n     * When this method is called group name is changed, so also is the\n     * group name belonging to the view. Also overwrites the \"groups.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (oldName == null || newName == null || oldName == \"\" || newName == \"\") {\n            throw new Exception(\"Group Factory: Rename user.. no value \");\n        } else {\n            Map<String, Group> map = new LinkedHashMap<String, Group>();\n            \n        \tfor (Group group : m_groups.values()) {\n        \t\tfor (String name : group.getUserCollection()) {\n                    if (name.equals(oldName)) {\n                        group.removeUser(oldName);\n                        group.addUser(newName);\n                    }\n                }\n                map.put(group.getName(), group);\n            }\n            m_groups.clear();\n            m_groups.putAll(map);\n\n            for (Role role : m_roles.values()) {\n            \tfor (Schedule sched : role.getScheduleCollection()) {\n                    if (oldName.equals(sched.getName())) {\n                        sched.setName(newName);\n                    }\n                }\n            }\n            \n            saveGroups();\n        }\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if a group is on duty at a given time. If a group has no duty schedules\n     * listed in the config file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return boolean, true if the group is on duty, false otherwise.\n     */\n    public boolean isGroupOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return true;\n        }\n        boolean result = false;\n        List dutySchedules = (List)m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule)dutySchedules.get(i);\n            result = curSchedule.isInSchedule(time);\n            //don't continue if the time is in this schedule\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }","id":401,"modified_method":"/**\n     * Determines if a group is on duty at a given time. If a group has no duty schedules\n     * listed in the configuration file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return boolean, true if the group is on duty, false otherwise.\n     */\n    public boolean isGroupOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return true;\n        }\n        List<DutySchedule> dutySchedules = m_dutySchedules.get(group);\n        for (DutySchedule curSchedule : dutySchedules) {\n        \tif (curSchedule.isInSchedule(time)) {\n        \t\treturn true;\n        \t}\n        }\n        return false;\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Removes the user from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteUser(String name) throws Exception {\n        // Check if the user exists\n        if (name != null || !name.equals(\"\")) {\n            // Remove the user in the group.\n            Set grps = (Set) m_groups.keySet();\n            Iterator iterator = (Iterator) grps.iterator();\n            while (iterator.hasNext()) {\n                Group group;\n                group = (Group) m_groups.get((String) iterator.next());\n                group.removeUser(name);\n            }\n            \n            Iterator it = m_roles.values().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                Iterator j = role.getScheduleCollection().iterator();\n                while(j.hasNext()) {\n                    Schedule sched = (Schedule)j.next();\n                    if (name.equals(sched.getName())) {\n                        j.remove();\n                    }\n                }\n            }\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user name:\" + name);\n        }\n        \n        \n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","id":402,"modified_method":"/**\n     * Removes the user from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteUser(String name) throws Exception {\n        // Check if the user exists\n        if (name != null && !name.equals(\"\")) {\n            // Remove the user in the group.\n        \tfor (Group group : m_groups.values()) {\n        \t\tgroup.removeUser(name);\n        \t}\n\n        \tfor (Role role : m_roles.values()) {\n                Iterator<Schedule> s = role.getScheduleCollection().iterator();\n                while(s.hasNext()) {\n                    Schedule sched = s.next();\n                    if (name.equals(sched.getName())) {\n                        s.remove();\n                    }\n                }\n            }\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user name:\" + name);\n        }\n        \n        \n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean isUserScheduledForRole(String userId, String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List scheds = getUserSchedulesForRole(userId, roleid);\n        for (Iterator it = scheds.iterator(); it.hasNext();) {\n            Schedule sched = (Schedule) it.next();\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                return true;\n            }\n        }\n        \n        // if no user is scheduled then the supervisor is schedule by default \n        Role role = getRole(roleid);\n        if (userId.equals(role.getSupervisor())) {\n            for (Iterator it = role.getScheduleCollection().iterator(); it.hasNext();) {\n                Schedule sched = (Schedule) it.next();\n                if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                    // we found another scheduled user\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":403,"modified_method":"public boolean isUserScheduledForRole(String userId, String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        for (Schedule sched : getUserSchedulesForRole(userId, roleId)) {\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                return true;\n            }\n        }\n        \n        // if no user is scheduled then the supervisor is schedule by default \n        Role role = getRole(roleId);\n        if (userId.equals(role.getSupervisor())) {\n        \tfor (Schedule sched : role.getScheduleCollection()) {\n                if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                    // we found another scheduled user\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public synchronized void saveGroups() throws Exception {\n        Header header = m_oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Groups groups = new Groups();\n        Collection collgroups = (Collection) m_groups.values();\n        Iterator iter = collgroups.iterator();\n        while (iter != null && iter.hasNext()) {\n            Group grp = (Group) iter.next();\n            groups.addGroup(grp);\n        }\n        \n        \n        Roles roles = new Roles();\n        Iterator it = m_roles.values().iterator();\n        while(it.hasNext()) {\n            Role role = (Role)it.next();\n            roles.addRole(role);\n        }\n    \n        Groupinfo groupinfo = new Groupinfo();\n        groupinfo.setGroups(groups);\n        if (roles.getRoleCount() > 0)\n            groupinfo.setRoles(roles);\n        groupinfo.setHeader(header);\n    \n        m_oldHeader = header;\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(groupinfo, stringWriter);\n        String data = stringWriter.toString();\n        saveXml(data);\n    }","id":404,"modified_method":"/**\n     */\n    public synchronized void saveGroups() throws Exception {\n        Header header = m_oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Groups groups = new Groups();\n        for (Group grp : m_groups.values()) {\n            groups.addGroup(grp);\n        }\n        \n        \n        Roles roles = new Roles();\n        for (Role role : m_roles.values()) {\n            roles.addRole(role);\n        }\n    \n        Groupinfo groupinfo = new Groupinfo();\n        groupinfo.setGroups(groups);\n        if (roles.getRoleCount() > 0)\n            groupinfo.setRoles(roles);\n        groupinfo.setHeader(header);\n    \n        m_oldHeader = header;\n    \n        // marshal to a string first, then write the string to the file. This\n        // way the original configuration\n        // isn't lost if the XML from the marshal is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(groupinfo, stringWriter);\n        String data = stringWriter.toString();\n        saveXml(data);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected synchronized void parseXml(Reader reader) throws MarshalException, ValidationException {\n        Groupinfo groupinfo = (Groupinfo) Unmarshaller.unmarshal(Groupinfo.class, reader);\n        Groups groups = groupinfo.getGroups();\n        m_groups = new LinkedHashMap<String, Group>();\n        Collection groupList = groups.getGroupCollection();\n        m_oldHeader = groupinfo.getHeader();\n        Iterator i = groupList.iterator();\n        while (i.hasNext()) {\n            Group curGroup = (Group) i.next();\n            m_groups.put(curGroup.getName(), curGroup);\n        }\n        buildDutySchedules(m_groups);\n        \n        Roles roles = groupinfo.getRoles();\n        m_roles = new LinkedHashMap<String, Role>();\n        if (roles != null) {\n            Iterator it = roles.getRoleCollection().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                m_roles.put(role.getName(), role);\n            }\n        }\n    }","id":405,"modified_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected synchronized void parseXml(Reader reader) throws MarshalException, ValidationException {\n        Groupinfo groupinfo = (Groupinfo) Unmarshaller.unmarshal(Groupinfo.class, reader);\n        Groups groups = groupinfo.getGroups();\n        m_groups = new LinkedHashMap<String, Group>();\n        m_oldHeader = groupinfo.getHeader();\n        for (Group curGroup : groups.getGroupCollection()) {\n            m_groups.put(curGroup.getName(), curGroup);\n        }\n        buildDutySchedules(m_groups);\n        \n        Roles roles = groupinfo.getRoles();\n        m_roles = new LinkedHashMap<String, Role>();\n        if (roles != null) {\n        \tfor (Role role : roles.getRoleCollection()) {\n                m_roles.put(role.getName(), role);\n            }\n        }\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<Schedule> getSchedulesForRoleAt(String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        Role role = getRole(roleId);\n        List<Schedule> schedules = new ArrayList<Schedule>();\n        for (Iterator it = role.getScheduleCollection().iterator(); it.hasNext();) {\n            Schedule sched = (Schedule) it.next();\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                schedules.add(sched);\n            }\n        }\n        return schedules;\n    }","id":406,"modified_method":"public List<Schedule> getSchedulesForRoleAt(String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> schedules = new ArrayList<Schedule>();\n        for (Schedule sched : getRole(roleId).getScheduleCollection()) {\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                schedules.add(sched);\n            }\n        }\n        return schedules;\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get an XMPP address by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the XMPP address\n     */\n\n    public String getXMPPAddress(String userid) throws IOException, MarshalException, ValidationException {\n\n        update();\n        \n        User user = (User) m_users.get(userid);\n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n            \tif (contact.getType().equals(\"xmppAddress\")) {\n            \t\tvalue = contact.getInfo();\n            \t\tbreak;\n            \t}\n            }\n        }\n        return value;\n\n    }","id":407,"modified_method":"/**\n     * Get an XMPP address by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the XMPP address\n     */\n\n    public String getXMPPAddress(String userID) throws IOException, MarshalException, ValidationException {\n\n        update();\n        \n        User user = m_users.get(userID);\n        if (user == null)\n            return \"\";\n        \n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(\"xmppAddress\")) {\n        \t\treturn contact.getInfo();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the password for this user, first encrypting it\n     * \n     * @param userID\n     *            the user ID to change the pasword for\n     * @param aPassword\n     *            the password\n     */\n    public void setUnencryptedPassword(String userID, String aPassword) throws Exception {\n        User user = (User) m_users.get(userID);\n        if (user != null) {\n            user.setPassword(encryptedPassword(aPassword));\n        }\n    \n        saveCurrent();\n    }","id":408,"modified_method":"/**\n     * Sets the password for this user, first encrypting it\n     * \n     * @param userID\n     *            the user ID to change the password for\n     * @param aPassword\n     *            the password\n     */\n    public void setUnencryptedPassword(String userID, String aPassword) throws Exception {\n        User user =  m_users.get(userID);\n        if (user != null) {\n            user.setPassword(encryptedPassword(aPassword));\n        }\n    \n        saveCurrent();\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a text pin\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the text pin\n     */\n    public String getTextPin(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"textPage\");\n    }","id":409,"modified_method":"/**\n     * Get a text pin\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the text pin\n     */\n    public String getTextPin(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"textPage\");\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a numeric pin\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the numeric pin\n     */\n    public String getNumericPin(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"numericPage\");\n    }","id":410,"modified_method":"/**\n     * Get a numeric pin\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the numeric pin\n     */\n    public String getNumericPin(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"numericPage\");\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a mapping between user ids and duty schedules. These are used by\n     * Notifd when determining to send a notice to a given user. This helps\n     * speed up the decision process.\n     * \n     * @param users\n     *            the map of users parsed from the xml config file\n     */\n    private void buildDutySchedules(Map<String, User> users) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        \n        for (String key : users.keySet()) {\n            User curUser = (User) users.get(key);\n    \n            if (curUser.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                Enumeration duties = curUser.enumerateDutySchedule();\n    \n                while (duties.hasMoreElements()) {\n                    dutyList.add(new DutySchedule((String) duties.nextElement()));\n                }\n    \n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","id":411,"modified_method":"/**\n     * Builds a mapping between user IDs and duty schedules. These are used by\n     * Notifd when determining to send a notice to a given user. This helps\n     * speed up the decision process.\n     * \n     * @param users\n     *            the map of users parsed from the XML configuration file\n     */\n    private void buildDutySchedules(Map<String, User> users) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        \n        for (String key : users.keySet()) {\n            User curUser = users.get(key);\n    \n            if (curUser.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                for (String duty : curUser.getDutyScheduleCollection()) {\n                \tdutyList.add(new DutySchedule(duty));\n                }\n    \n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a Text Page Service Provider\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the text page service provider.\n     */\n    public String getTextPage(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userid, \"textPage\");\n    }","id":412,"modified_method":"/**\n     * Get a Text Page Service Provider\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the text page service provider.\n     */\n    public String getTextPage(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userID, \"textPage\");\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a email by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the email specified by name\n     */\n    public String getEmail(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"email\");\n    }","id":413,"modified_method":"/**\n     * Get a email by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the email specified by name\n     */\n    public String getEmail(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"email\");\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a numeric service provider\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the service provider\n     */\n    public String getNumericPage(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userid, \"numericPage\");\n    }","id":414,"modified_method":"/**\n     * Get a numeric service provider\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the service provider\n     */\n    public String getNumericPage(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userID, \"numericPage\");\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves into \"users.xml\" file\n     */\n    private synchronized void saveCurrent() throws Exception {\n        Header header = oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Users users = new Users();\n        Collection collUsers = (Collection) m_users.values();\n        Iterator iter = collUsers.iterator();\n        while (iter != null && iter.hasNext()) {\n            User tmpUser = (User) iter.next();\n            users.addUser(tmpUser);\n        }\n    \n        Userinfo userinfo = new Userinfo();\n        userinfo.setUsers(users);\n        userinfo.setHeader(header);\n    \n        oldHeader = header;\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(userinfo, stringWriter);\n        String writerString = stringWriter.toString();\n        saveXML(writerString);\n    }","id":415,"modified_method":"/**\n     * Saves into \"users.xml\" file\n     */\n    private synchronized void saveCurrent() throws Exception {\n        Header header = oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Users users = new Users();\n        Collection<User> collUsers = m_users.values();\n        Iterator<User> iter = collUsers.iterator();\n        while (iter != null && iter.hasNext()) {\n            User tmpUser = iter.next();\n            users.addUser(tmpUser);\n        }\n    \n        Userinfo userinfo = new Userinfo();\n        userinfo.setUsers(users);\n        userinfo.setHeader(header);\n    \n        oldHeader = header;\n    \n        // marshal to a string first, then write the string to the file. This\n        // way the original configuration\n        // isn't lost if the XML from the marshal is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(userinfo, stringWriter);\n        String writerString = stringWriter.toString();\n        saveXML(writerString);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * When this method is called users name is changed, so also is the username\n     * belonging to the group and the view. Also overwrites the \"users.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (m_users.containsKey(oldName)) {\n            User data = (User) m_users.get(oldName);\n            if (data == null) {\n                m_users.remove(oldName);\n                throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n            } else {\n                // Rename the user in the user map.\n                m_users.remove(oldName);\n                data.setUserId(newName);\n                m_users.put(newName, data);\n    \n                // Rename the user in the group.\n                m_groupManager.renameUser(oldName, newName);\n    \n                // Rename the user in the view.\n                // viewFactory.renameUser(oldName, newName);\n            }\n        } else {\n            throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n        }\n    \n        saveCurrent();\n    }","id":416,"modified_method":"/**\n     * When this method is called users name is changed, so also is the username\n     * belonging to the group and the view. Also overwrites the \"users.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (m_users.containsKey(oldName)) {\n            User data = m_users.get(oldName);\n            if (data == null) {\n                m_users.remove(oldName);\n                throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n            } else {\n                // Rename the user in the user map.\n                m_users.remove(oldName);\n                data.setUserId(newName);\n                m_users.put(newName, data);\n    \n                // Rename the user in the group.\n                m_groupManager.renameUser(oldName, newName);\n    \n                // Rename the user in the view.\n                // viewFactory.renameUser(oldName, newName);\n            }\n        } else {\n            throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n        }\n    \n        saveCurrent();\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if a user is on duty at a given time. If a user has no duty\n     * schedules listed in the config file, that user is assumed to always be on\n     * duty.\n     * \n     * @param user\n     *            the user id\n     * @param time\n     *            the time to check for a duty schedule\n     * @return boolean, true if the user is on duty, false otherwise.\n     */\n    public boolean isUserOnDuty(String user, Calendar time) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        // if the user has no duty schedules then he is on duty\n        if (!m_dutySchedules.containsKey(user))\n            return true;\n    \n        boolean result = false;\n        List dutySchedules = (List) m_dutySchedules.get(user);\n    \n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule) dutySchedules.get(i);\n    \n            result = curSchedule.isInSchedule(time);\n    \n            // don't continue if the time is in this schedule\n            if (result)\n                break;\n        }\n    \n        return result;\n    }","id":417,"modified_method":"/**\n     * Determines if a user is on duty at a given time. If a user has no duty\n     * schedules listed in the configuration file, that user is assumed to always be on\n     * duty.\n     * \n     * @param user\n     *            the user id\n     * @param time\n     *            the time to check for a duty schedule\n     * @return boolean, true if the user is on duty, false otherwise.\n     */\n    public boolean isUserOnDuty(String user, Calendar time) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        // if the user has no duty schedules then he is on duty\n        if (!m_dutySchedules.containsKey(user))\n            return true;\n\n        for (DutySchedule curSchedule : m_dutySchedules.get(user)) {\n        \tif (curSchedule.isInSchedule(time)) {\n        \t\treturn true;\n        \t}\n        }\n        \n        return false;\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a pager email by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the pager email\n     */\n    public String getPagerEmail(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"pagerEmail\");\n    }","id":418,"modified_method":"/**\n     * Get a pager email by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the pager email\n     */\n    public String getPagerEmail(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"pagerEmail\");\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method compares two encrypted strings for equality.\n     * \n     * @param userID\n     *            the user ID to check against.\n     * @param aPassword\n     *            the password to check for equality\n     * @return true if the two passwords are equal (after encryption), false\n     *         otherwise\n     */\n    public boolean comparePasswords(String userID, String aPassword) {\n        User user = (User) m_users.get(userID);\n        if (user == null)\n            return false;\n    \n        return user.getPassword().equals(encryptedPassword(aPassword));\n    }","id":419,"modified_method":"/**\n     * This method compares two encrypted strings for equality.\n     * \n     * @param userID\n     *            the user ID to check against.\n     * @param aPassword\n     *            the password to check for equality\n     * @return true if the two passwords are equal (after encryption), false\n     *         otherwise\n     */\n    public boolean comparePasswords(String userID, String aPassword) {\n        User user = m_users.get(userID);\n        if (user == null)\n            return false;\n    \n        return user.getPassword().equals(encryptedPassword(aPassword));\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String[] getUsersScheduledForRole(String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n        \n        List<String> usersScheduledForRole = new ArrayList<String>();\n        \n        Iterator i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = (User)i.next();\n            if (isUserScheduledForRole(user, roleid, time)) {\n                usersScheduledForRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersScheduledForRole.toArray(new String[usersScheduledForRole.size()]);\n    }","id":420,"modified_method":"public String[] getUsersScheduledForRole(String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n        \n        List<String> usersScheduledForRole = new ArrayList<String>();\n        \n        Iterator<User> i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = i.next();\n            if (isUserScheduledForRole(user, roleid, time)) {\n                usersScheduledForRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersScheduledForRole.toArray(new String[usersScheduledForRole.size()]);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getContactInfo(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n                if (contact.getType().equals(command)) {\n                    value = contact.getInfo();\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":421,"modified_method":"public String getContactInfo(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        \n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(command)) {\n        \t\treturn contact.getInfo();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getContactServiceProvider(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n                if (contact.getType().equals(command)) {\n                    value = contact.getServiceProvider();\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":422,"modified_method":"public String getContactServiceProvider(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n\n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(command)) {\n        \t\treturn contact.getServiceProvider();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the password for this user, assuming that the value passed in is\n     * already encrypted properly\n     * \n     * @param userID\n     *            the user ID to change the pasword for\n     * @param aPassword\n     *            the encrypted password\n     */\n    public void setEncryptedPassword(String userID, String aPassword) throws Exception {\n        User user = (User) m_users.get(userID);\n        if (user != null) {\n            user.setPassword(aPassword);\n        }\n    \n        saveCurrent();\n    }","id":423,"modified_method":"/**\n     * Sets the password for this user, assuming that the value passed in is\n     * already encrypted properly\n     * \n     * @param userID\n     *            the user ID to change the password for\n     * @param aPassword\n     *            the encrypted password\n     */\n    public void setEncryptedPassword(String userID, String aPassword) throws Exception {\n        User user = m_users.get(userID);\n        if (user != null) {\n            user.setPassword(aPassword);\n        }\n    \n        saveCurrent();\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void parseXML(Reader reader) throws MarshalException, ValidationException {\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, reader);\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection usersList = users.getUserCollection();\n        m_users = new HashMap<String, User>();\n    \n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n        buildDutySchedules(m_users);\n    }","id":424,"modified_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void parseXML(Reader reader) throws MarshalException, ValidationException {\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, reader);\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection<User> usersList = users.getUserCollection();\n        m_users = new HashMap<String, User>();\n\n        for (User curUser : usersList) {\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n        buildDutySchedules(m_users);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public synchronized void saveUsers(Collection usersList) throws Exception {\n        // clear out the interanal structure and reload it\n        m_users.clear();\n    \n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n    }","id":425,"modified_method":"/**\n     */\n    public synchronized void saveUsers(Collection<User> usersList) throws Exception {\n        // clear out the internal structure and reload it\n        m_users.clear();\n    \n        for (User curUser : usersList) {\n        \tm_users.put(curUser.getUserId(), curUser);\n        }\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String[] getUsersWithRole(String roleid) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        List<String> usersWithRole = new ArrayList<String>();\n        \n        Iterator i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = (User)i.next();\n            if (userHasRole(user, roleid)) {\n                usersWithRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersWithRole.toArray(new String[usersWithRole.size()]);\n        \n    }","id":426,"modified_method":"public String[] getUsersWithRole(String roleid) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        List<String> usersWithRole = new ArrayList<String>();\n        \n        Iterator<User> i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = i.next();\n            if (userHasRole(user, roleid)) {\n                usersWithRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersWithRole.toArray(new String[usersWithRole.size()]);\n        \n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the contact info given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactInfo(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        User user = (User) m_users.get(userID);\n        return getContactInfo(user, command);\n    }","id":427,"modified_method":"/**\n     * Get the contact info given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactInfo(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        User user = m_users.get(userID);\n        return getContactInfo(user, command);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a user by name\n     * \n     * @param name\n     *            the name of the user to return\n     * @return the user specified by name\n     */\n    public User getUser(String name) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        return (User) m_users.get(name);\n    }","id":428,"modified_method":"/**\n     * Get a user by name\n     * \n     * @param name\n     *            the name of the user to return\n     * @return the user specified by name\n     */\n    public User getUser(String name) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        return m_users.get(name);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the contact service provider, given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactServiceProvider(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        User user = (User) m_users.get(userID);\n        return getContactServiceProvider(user, command);\n    }","id":429,"modified_method":"/**\n     * Get the contact service provider, given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactServiceProvider(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        User user = m_users.get(userID);\n        return getContactServiceProvider(user, command);\n    }","commit_id":"537306f4084c404b7d017781a62f09e39b0c9e44","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Renames the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void renameGroup(String oldName, String newName) throws Exception {\n    \tif (oldName != null || !oldName.equals(\"\")) {\n    \t\tif (m_groups.containsKey(oldName)) {\n    \t\t\tGroup grp = (Group)m_groups.get(oldName);\n    \t\t\tgrp.setName(newName);\n    \t\t\tm_groups.put(newName, grp);\n    \t\t} else {\n    \t\t\tthrow new Exception(\"GroupFactory.renameGroup: Group doesn't exist: \" + oldName);\n    \t\t}\n    \t\t// Save into groups.xml\n    \t\tsaveGroups();\n    \t}\n    }","id":430,"modified_method":"/**\n     * Renames the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void renameGroup(String oldName, String newName) throws Exception {\n    \tif (oldName != null && !oldName.equals(\"\")) {\n    \t\tif (m_groups.containsKey(oldName)) {\n    \t\t\tGroup grp = m_groups.get(oldName);\n    \t\t\tgrp.setName(newName);\n    \t\t\tm_groups.put(newName, grp);\n    \t\t} else {\n    \t\t\tthrow new Exception(\"GroupFactory.renameGroup: Group doesn't exist: \" + oldName);\n    \t\t}\n    \t\t// Save into groups.xml\n    \t\tsaveGroups();\n    \t}\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Removes the user from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteUser(String name) throws Exception {\n        // Check if the user exists\n        if (name != null || !name.equals(\"\")) {\n            // Remove the user in the group.\n            Set grps = (Set) m_groups.keySet();\n            Iterator iterator = (Iterator) grps.iterator();\n            while (iterator.hasNext()) {\n                Group group;\n                group = (Group) m_groups.get((String) iterator.next());\n                group.removeUser(name);\n            }\n            \n            Iterator it = m_roles.values().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                Iterator j = role.getScheduleCollection().iterator();\n                while(j.hasNext()) {\n                    Schedule sched = (Schedule)j.next();\n                    if (name.equals(sched.getName())) {\n                        j.remove();\n                    }\n                }\n            }\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user name:\" + name);\n        }\n        \n        \n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","id":431,"modified_method":"/**\n     * Removes the user from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteUser(String name) throws Exception {\n        // Check if the user exists\n        if (name != null && !name.equals(\"\")) {\n            // Remove the user in the group.\n        \tfor (Group group : m_groups.values()) {\n        \t\tgroup.removeUser(name);\n        \t}\n\n        \tfor (Role role : m_roles.values()) {\n                Iterator<Schedule> s = role.getScheduleCollection().iterator();\n                while(s.hasNext()) {\n                    Schedule sched = s.next();\n                    if (name.equals(sched.getName())) {\n                        s.remove();\n                    }\n                }\n            }\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user name:\" + name);\n        }\n        \n        \n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Removes the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteGroup(String name) throws Exception {\n        // Check if the group exists\n        if (name != null || !name.equals(\"\")) {\n            if (m_groups.containsKey(name)) {\n                // Remove the group.\n                m_groups.remove(name);\n    \n            } else\n                throw new Exception(\"GroupFactory:delete Group doesnt exist:\" + name);\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user group:\" + name);\n        }\n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","id":432,"modified_method":"/**\n     * Removes the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteGroup(String name) throws Exception {\n        // Check if the group exists\n        if (name != null && !name.equals(\"\")) {\n            if (m_groups.containsKey(name)) {\n                // Remove the group.\n                m_groups.remove(name);\n            } else\n                throw new Exception(\"GroupFactory:delete Group doesnt exist:\" + name);\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user group:\" + name);\n        }\n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List getUserSchedulesForRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> scheds = new ArrayList<Schedule>();\n        Role role = getRole(roleid);\n        Iterator it = role.getScheduleCollection().iterator();\n        while(it.hasNext()) {\n            Schedule sched = (Schedule)it.next();\n            if (userId.equals(sched.getName())) {\n                scheds.add(sched);\n            }\n        }\n        return scheds;\n        \n    }","id":433,"modified_method":"public List<Schedule> getUserSchedulesForRole(String userId, String roleId) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> scheds = new ArrayList<Schedule>();\n        for (Schedule sched : getRole(roleId).getScheduleCollection()) {\n            if (userId.equals(sched.getName())) {\n                scheds.add(sched);\n            }\n        }\n        return scheds;\n        \n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines when a group is next on duty. If a group has no duty schedules\n     * listed in the config file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return long, the time in millisec until the group is next on duty\n     */\n    public long groupNextOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        long next = -1;\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return 0;\n        }\n        List dutySchedules = (List)m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule)dutySchedules.get(i);\n            long tempnext =  curSchedule.nextInSchedule(time);\n            if( tempnext < next || next == -1 ) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isGroupOnDuty: On duty in \" + tempnext + \" millisec from schedule \" + i);\n                }\n                next = tempnext;\n            }\n        }\n        return next;\n    }","id":434,"modified_method":"/**\n     * Determines when a group is next on duty. If a group has no duty schedules\n     * listed in the configuration file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return long, the time in milliseconds until the group is next on duty\n     */\n    public long groupNextOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        long next = -1;\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return 0;\n        }\n        List<DutySchedule> dutySchedules = m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = dutySchedules.get(i);\n            long tempnext =  curSchedule.nextInSchedule(time);\n            if( tempnext < next || next == -1 ) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isGroupOnDuty: On duty in \" + tempnext + \" millisec from schedule \" + i);\n                }\n                next = tempnext;\n            }\n        }\n        return next;\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean userHasRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        Role role = getRole(roleid);\n        Iterator j = role.getScheduleCollection().iterator();\n        while(j.hasNext()) {\n            Schedule sched = (Schedule)j.next();\n            if (userId.equals(sched.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":435,"modified_method":"public boolean userHasRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        for (Schedule sched : getRole(roleid).getScheduleCollection()) {\n            if (userId.equals(sched.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * When this method is called group name is changed, so also is the\n     * groupname belonging to the view. Also overwrites the \"groups.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (oldName == null || newName == null || oldName == \"\" || newName == \"\") {\n            throw new Exception(\"Group Factory: Rename user.. no value \");\n        } else {\n            Collection coll = (Collection) m_groups.values();\n            Iterator iter = (Iterator) coll.iterator();\n            Map<String, Group> map = new LinkedHashMap<String, Group>();\n    \n            while (iter.hasNext()) {\n                Group group = (Group) iter.next();\n                Enumeration en = group.enumerateUser();\n                String name = \"\";\n                while (en.hasMoreElements()) {\n                    name = (String) en.nextElement();\n                    if (name.equals(oldName)) {\n                        group.removeUser(oldName);\n                        group.addUser(newName);\n                    }\n                }\n                map.put(group.getName(), group);\n            }\n            m_groups.clear();\n            m_groups = map;\n            \n            Iterator it = m_roles.values().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                Iterator j = role.getScheduleCollection().iterator();\n                while(j.hasNext()) {\n                    Schedule sched = (Schedule)j.next();\n                    if (oldName.equals(sched.getName())) {\n                        sched.setName(newName);\n                    }\n                }\n            }\n            \n            saveGroups();\n        }\n    }","id":436,"modified_method":"/**\n     * When this method is called group name is changed, so also is the\n     * group name belonging to the view. Also overwrites the \"groups.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (oldName == null || newName == null || oldName == \"\" || newName == \"\") {\n            throw new Exception(\"Group Factory: Rename user.. no value \");\n        } else {\n            Map<String, Group> map = new LinkedHashMap<String, Group>();\n            \n        \tfor (Group group : m_groups.values()) {\n        \t\tfor (String name : group.getUserCollection()) {\n                    if (name.equals(oldName)) {\n                        group.removeUser(oldName);\n                        group.addUser(newName);\n                    }\n                }\n                map.put(group.getName(), group);\n            }\n            m_groups.clear();\n            m_groups.putAll(map);\n\n            for (Role role : m_roles.values()) {\n            \tfor (Schedule sched : role.getScheduleCollection()) {\n                    if (oldName.equals(sched.getName())) {\n                        sched.setName(newName);\n                    }\n                }\n            }\n            \n            saveGroups();\n        }\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected synchronized void parseXml(Reader reader) throws MarshalException, ValidationException {\n        Groupinfo groupinfo = (Groupinfo) Unmarshaller.unmarshal(Groupinfo.class, reader);\n        Groups groups = groupinfo.getGroups();\n        m_groups = new LinkedHashMap<String, Group>();\n        Collection groupList = groups.getGroupCollection();\n        m_oldHeader = groupinfo.getHeader();\n        Iterator i = groupList.iterator();\n        while (i.hasNext()) {\n            Group curGroup = (Group) i.next();\n            m_groups.put(curGroup.getName(), curGroup);\n        }\n        buildDutySchedules(m_groups);\n        \n        Roles roles = groupinfo.getRoles();\n        m_roles = new LinkedHashMap<String, Role>();\n        if (roles != null) {\n            Iterator it = roles.getRoleCollection().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                m_roles.put(role.getName(), role);\n            }\n        }\n    }","id":437,"modified_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected synchronized void parseXml(Reader reader) throws MarshalException, ValidationException {\n        Groupinfo groupinfo = (Groupinfo) Unmarshaller.unmarshal(Groupinfo.class, reader);\n        Groups groups = groupinfo.getGroups();\n        m_groups = new LinkedHashMap<String, Group>();\n        m_oldHeader = groupinfo.getHeader();\n        for (Group curGroup : groups.getGroupCollection()) {\n            m_groups.put(curGroup.getName(), curGroup);\n        }\n        buildDutySchedules(m_groups);\n        \n        Roles roles = groupinfo.getRoles();\n        m_roles = new LinkedHashMap<String, Role>();\n        if (roles != null) {\n        \tfor (Role role : roles.getRoleCollection()) {\n                m_roles.put(role.getName(), role);\n            }\n        }\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OwnedIntervalSequence getRoleScheduleEntries(String roleid, Date start, Date end) throws MarshalException, ValidationException, IOException {\n        update();\n\n        OwnedIntervalSequence schedEntries = new OwnedIntervalSequence();\n        Role role = getRole(roleid);\n        for (int i = 0; i < role.getScheduleCount(); i++) {\n            Schedule sched = (Schedule) role.getSchedule(i);\n            Owner owner = new Owner(roleid, sched.getName(), i);\n            schedEntries.addAll(BasicScheduleUtils.getIntervalsCovering(start, end, sched, owner));\n        }\n        \n        OwnedIntervalSequence defaultEntries = new OwnedIntervalSequence(new OwnedInterval(start, end));\n        defaultEntries.removeAll(schedEntries);\n        Owner supervisor = new Owner(roleid, role.getSupervisor());\n        for (Iterator it = defaultEntries.iterator(); it.hasNext();) {\n            OwnedInterval interval = (OwnedInterval) it.next();\n            interval.addOwner(supervisor);\n        }\n        \n        schedEntries.addAll(defaultEntries);\n        return schedEntries;\n        \n    }","id":438,"modified_method":"public OwnedIntervalSequence getRoleScheduleEntries(String roleid, Date start, Date end) throws MarshalException, ValidationException, IOException {\n        update();\n\n        OwnedIntervalSequence schedEntries = new OwnedIntervalSequence();\n        Role role = getRole(roleid);\n        for (int i = 0; i < role.getScheduleCount(); i++) {\n            Schedule sched = role.getSchedule(i);\n            Owner owner = new Owner(roleid, sched.getName(), i);\n            schedEntries.addAll(BasicScheduleUtils.getIntervalsCovering(start, end, sched, owner));\n        }\n        \n        OwnedIntervalSequence defaultEntries = new OwnedIntervalSequence(new OwnedInterval(start, end));\n        defaultEntries.removeAll(schedEntries);\n        Owner supervisor = new Owner(roleid, role.getSupervisor());\n        for (Iterator<TimeInterval> it = defaultEntries.iterator(); it.hasNext();) {\n        \tOwnedInterval interval = new OwnedInterval(it.next());\n            interval.addOwner(supervisor);\n        }\n        \n        schedEntries.addAll(defaultEntries);\n        return schedEntries;\n        \n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<Schedule> getSchedulesForRoleAt(String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        Role role = getRole(roleId);\n        List<Schedule> schedules = new ArrayList<Schedule>();\n        for (Iterator it = role.getScheduleCollection().iterator(); it.hasNext();) {\n            Schedule sched = (Schedule) it.next();\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                schedules.add(sched);\n            }\n        }\n        return schedules;\n    }","id":439,"modified_method":"public List<Schedule> getSchedulesForRoleAt(String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> schedules = new ArrayList<Schedule>();\n        for (Schedule sched : getRole(roleId).getScheduleCollection()) {\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                schedules.add(sched);\n            }\n        }\n        return schedules;\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public synchronized void saveGroups() throws Exception {\n        Header header = m_oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Groups groups = new Groups();\n        Collection collgroups = (Collection) m_groups.values();\n        Iterator iter = collgroups.iterator();\n        while (iter != null && iter.hasNext()) {\n            Group grp = (Group) iter.next();\n            groups.addGroup(grp);\n        }\n        \n        \n        Roles roles = new Roles();\n        Iterator it = m_roles.values().iterator();\n        while(it.hasNext()) {\n            Role role = (Role)it.next();\n            roles.addRole(role);\n        }\n    \n        Groupinfo groupinfo = new Groupinfo();\n        groupinfo.setGroups(groups);\n        if (roles.getRoleCount() > 0)\n            groupinfo.setRoles(roles);\n        groupinfo.setHeader(header);\n    \n        m_oldHeader = header;\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(groupinfo, stringWriter);\n        String data = stringWriter.toString();\n        saveXml(data);\n    }","id":440,"modified_method":"/**\n     */\n    public synchronized void saveGroups() throws Exception {\n        Header header = m_oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Groups groups = new Groups();\n        for (Group grp : m_groups.values()) {\n            groups.addGroup(grp);\n        }\n        \n        \n        Roles roles = new Roles();\n        for (Role role : m_roles.values()) {\n            roles.addRole(role);\n        }\n    \n        Groupinfo groupinfo = new Groupinfo();\n        groupinfo.setGroups(groups);\n        if (roles.getRoleCount() > 0)\n            groupinfo.setRoles(roles);\n        groupinfo.setHeader(header);\n    \n        m_oldHeader = header;\n    \n        // marshal to a string first, then write the string to the file. This\n        // way the original configuration\n        // isn't lost if the XML from the marshal is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(groupinfo, stringWriter);\n        String data = stringWriter.toString();\n        saveXml(data);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a mapping between groups and duty schedules. These are used when\n     * determining to send a notice to a given group. This helps speed up the decision process.\n     * @param groups the map of groups parsed from the xml config file\n     */\n    private static void buildDutySchedules(Map groups) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        Iterator i = groups.keySet().iterator();\n        while(i.hasNext()) {\n            String key = (String)i.next();\n            Group curGroup = (Group)groups.get(key);\n            if (curGroup.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                Enumeration duties = curGroup.enumerateDutySchedule();\n                while(duties.hasMoreElements()) {\n                    dutyList.add(new DutySchedule( (String)duties.nextElement() ));\n                }\n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","id":441,"modified_method":"/**\n     * Builds a mapping between groups and duty schedules. These are used when\n     * determining to send a notice to a given group. This helps speed up the decision process.\n     * @param groups the map of groups parsed from the XML configuration file\n     */\n    private static void buildDutySchedules(Map<String, Group> groups) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        Iterator<String> i = groups.keySet().iterator();\n        while(i.hasNext()) {\n            String key = i.next();\n            Group curGroup = groups.get(key);\n            if (curGroup.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                for (String duty : curGroup.getDutyScheduleCollection()) {\n                \tdutyList.add(new DutySchedule(duty));\n                }\n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean isUserScheduledForRole(String userId, String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List scheds = getUserSchedulesForRole(userId, roleid);\n        for (Iterator it = scheds.iterator(); it.hasNext();) {\n            Schedule sched = (Schedule) it.next();\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                return true;\n            }\n        }\n        \n        // if no user is scheduled then the supervisor is schedule by default \n        Role role = getRole(roleid);\n        if (userId.equals(role.getSupervisor())) {\n            for (Iterator it = role.getScheduleCollection().iterator(); it.hasNext();) {\n                Schedule sched = (Schedule) it.next();\n                if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                    // we found another scheduled user\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":442,"modified_method":"public boolean isUserScheduledForRole(String userId, String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        for (Schedule sched : getUserSchedulesForRole(userId, roleId)) {\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                return true;\n            }\n        }\n        \n        // if no user is scheduled then the supervisor is schedule by default \n        Role role = getRole(roleId);\n        if (userId.equals(role.getSupervisor())) {\n        \tfor (Schedule sched : role.getScheduleCollection()) {\n                if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                    // we found another scheduled user\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if a group is on duty at a given time. If a group has no duty schedules\n     * listed in the config file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return boolean, true if the group is on duty, false otherwise.\n     */\n    public boolean isGroupOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return true;\n        }\n        boolean result = false;\n        List dutySchedules = (List)m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule)dutySchedules.get(i);\n            result = curSchedule.isInSchedule(time);\n            //don't continue if the time is in this schedule\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }","id":443,"modified_method":"/**\n     * Determines if a group is on duty at a given time. If a group has no duty schedules\n     * listed in the configuration file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return boolean, true if the group is on duty, false otherwise.\n     */\n    public boolean isGroupOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return true;\n        }\n        List<DutySchedule> dutySchedules = m_dutySchedules.get(group);\n        for (DutySchedule curSchedule : dutySchedules) {\n        \tif (curSchedule.isInSchedule(time)) {\n        \t\treturn true;\n        \t}\n        }\n        return false;\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getContactServiceProvider(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n                if (contact.getType().equals(command)) {\n                    value = contact.getServiceProvider();\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":444,"modified_method":"public String getContactServiceProvider(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n\n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(command)) {\n        \t\treturn contact.getServiceProvider();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the contact service provider, given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactServiceProvider(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        User user = (User) m_users.get(userID);\n        return getContactServiceProvider(user, command);\n    }","id":445,"modified_method":"/**\n     * Get the contact service provider, given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactServiceProvider(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        User user = m_users.get(userID);\n        return getContactServiceProvider(user, command);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * When this method is called users name is changed, so also is the username\n     * belonging to the group and the view. Also overwrites the \"users.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (m_users.containsKey(oldName)) {\n            User data = (User) m_users.get(oldName);\n            if (data == null) {\n                m_users.remove(oldName);\n                throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n            } else {\n                // Rename the user in the user map.\n                m_users.remove(oldName);\n                data.setUserId(newName);\n                m_users.put(newName, data);\n    \n                // Rename the user in the group.\n                m_groupManager.renameUser(oldName, newName);\n    \n                // Rename the user in the view.\n                // viewFactory.renameUser(oldName, newName);\n            }\n        } else {\n            throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n        }\n    \n        saveCurrent();\n    }","id":446,"modified_method":"/**\n     * When this method is called users name is changed, so also is the username\n     * belonging to the group and the view. Also overwrites the \"users.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (m_users.containsKey(oldName)) {\n            User data = m_users.get(oldName);\n            if (data == null) {\n                m_users.remove(oldName);\n                throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n            } else {\n                // Rename the user in the user map.\n                m_users.remove(oldName);\n                data.setUserId(newName);\n                m_users.put(newName, data);\n    \n                // Rename the user in the group.\n                m_groupManager.renameUser(oldName, newName);\n    \n                // Rename the user in the view.\n                // viewFactory.renameUser(oldName, newName);\n            }\n        } else {\n            throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n        }\n    \n        saveCurrent();\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void parseXML(Reader reader) throws MarshalException, ValidationException {\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, reader);\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection usersList = users.getUserCollection();\n        m_users = new HashMap<String, User>();\n    \n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n        buildDutySchedules(m_users);\n    }","id":447,"modified_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void parseXML(Reader reader) throws MarshalException, ValidationException {\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, reader);\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection<User> usersList = users.getUserCollection();\n        m_users = new HashMap<String, User>();\n\n        for (User curUser : usersList) {\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n        buildDutySchedules(m_users);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if a user is on duty at a given time. If a user has no duty\n     * schedules listed in the config file, that user is assumed to always be on\n     * duty.\n     * \n     * @param user\n     *            the user id\n     * @param time\n     *            the time to check for a duty schedule\n     * @return boolean, true if the user is on duty, false otherwise.\n     */\n    public boolean isUserOnDuty(String user, Calendar time) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        // if the user has no duty schedules then he is on duty\n        if (!m_dutySchedules.containsKey(user))\n            return true;\n    \n        boolean result = false;\n        List dutySchedules = (List) m_dutySchedules.get(user);\n    \n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule) dutySchedules.get(i);\n    \n            result = curSchedule.isInSchedule(time);\n    \n            // don't continue if the time is in this schedule\n            if (result)\n                break;\n        }\n    \n        return result;\n    }","id":448,"modified_method":"/**\n     * Determines if a user is on duty at a given time. If a user has no duty\n     * schedules listed in the configuration file, that user is assumed to always be on\n     * duty.\n     * \n     * @param user\n     *            the user id\n     * @param time\n     *            the time to check for a duty schedule\n     * @return boolean, true if the user is on duty, false otherwise.\n     */\n    public boolean isUserOnDuty(String user, Calendar time) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        // if the user has no duty schedules then he is on duty\n        if (!m_dutySchedules.containsKey(user))\n            return true;\n\n        for (DutySchedule curSchedule : m_dutySchedules.get(user)) {\n        \tif (curSchedule.isInSchedule(time)) {\n        \t\treturn true;\n        \t}\n        }\n        \n        return false;\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the password for this user, assuming that the value passed in is\n     * already encrypted properly\n     * \n     * @param userID\n     *            the user ID to change the pasword for\n     * @param aPassword\n     *            the encrypted password\n     */\n    public void setEncryptedPassword(String userID, String aPassword) throws Exception {\n        User user = (User) m_users.get(userID);\n        if (user != null) {\n            user.setPassword(aPassword);\n        }\n    \n        saveCurrent();\n    }","id":449,"modified_method":"/**\n     * Sets the password for this user, assuming that the value passed in is\n     * already encrypted properly\n     * \n     * @param userID\n     *            the user ID to change the password for\n     * @param aPassword\n     *            the encrypted password\n     */\n    public void setEncryptedPassword(String userID, String aPassword) throws Exception {\n        User user = m_users.get(userID);\n        if (user != null) {\n            user.setPassword(aPassword);\n        }\n    \n        saveCurrent();\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a numeric pin\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the numeric pin\n     */\n    public String getNumericPin(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"numericPage\");\n    }","id":450,"modified_method":"/**\n     * Get a numeric pin\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the numeric pin\n     */\n    public String getNumericPin(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"numericPage\");\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String[] getUsersScheduledForRole(String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n        \n        List<String> usersScheduledForRole = new ArrayList<String>();\n        \n        Iterator i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = (User)i.next();\n            if (isUserScheduledForRole(user, roleid, time)) {\n                usersScheduledForRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersScheduledForRole.toArray(new String[usersScheduledForRole.size()]);\n    }","id":451,"modified_method":"public String[] getUsersScheduledForRole(String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n        \n        List<String> usersScheduledForRole = new ArrayList<String>();\n        \n        Iterator<User> i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = i.next();\n            if (isUserScheduledForRole(user, roleid, time)) {\n                usersScheduledForRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersScheduledForRole.toArray(new String[usersScheduledForRole.size()]);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a mapping between user ids and duty schedules. These are used by\n     * Notifd when determining to send a notice to a given user. This helps\n     * speed up the decision process.\n     * \n     * @param users\n     *            the map of users parsed from the xml config file\n     */\n    private void buildDutySchedules(Map<String, User> users) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        \n        for (String key : users.keySet()) {\n            User curUser = (User) users.get(key);\n    \n            if (curUser.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                Enumeration duties = curUser.enumerateDutySchedule();\n    \n                while (duties.hasMoreElements()) {\n                    dutyList.add(new DutySchedule((String) duties.nextElement()));\n                }\n    \n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","id":452,"modified_method":"/**\n     * Builds a mapping between user IDs and duty schedules. These are used by\n     * Notifd when determining to send a notice to a given user. This helps\n     * speed up the decision process.\n     * \n     * @param users\n     *            the map of users parsed from the XML configuration file\n     */\n    private void buildDutySchedules(Map<String, User> users) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        \n        for (String key : users.keySet()) {\n            User curUser = users.get(key);\n    \n            if (curUser.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                for (String duty : curUser.getDutyScheduleCollection()) {\n                \tdutyList.add(new DutySchedule(duty));\n                }\n    \n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String[] getUsersWithRole(String roleid) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        List<String> usersWithRole = new ArrayList<String>();\n        \n        Iterator i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = (User)i.next();\n            if (userHasRole(user, roleid)) {\n                usersWithRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersWithRole.toArray(new String[usersWithRole.size()]);\n        \n    }","id":453,"modified_method":"public String[] getUsersWithRole(String roleid) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        List<String> usersWithRole = new ArrayList<String>();\n        \n        Iterator<User> i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = i.next();\n            if (userHasRole(user, roleid)) {\n                usersWithRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersWithRole.toArray(new String[usersWithRole.size()]);\n        \n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a pager email by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the pager email\n     */\n    public String getPagerEmail(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"pagerEmail\");\n    }","id":454,"modified_method":"/**\n     * Get a pager email by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the pager email\n     */\n    public String getPagerEmail(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"pagerEmail\");\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getContactInfo(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n                if (contact.getType().equals(command)) {\n                    value = contact.getInfo();\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":455,"modified_method":"public String getContactInfo(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        \n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(command)) {\n        \t\treturn contact.getInfo();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the password for this user, first encrypting it\n     * \n     * @param userID\n     *            the user ID to change the pasword for\n     * @param aPassword\n     *            the password\n     */\n    public void setUnencryptedPassword(String userID, String aPassword) throws Exception {\n        User user = (User) m_users.get(userID);\n        if (user != null) {\n            user.setPassword(encryptedPassword(aPassword));\n        }\n    \n        saveCurrent();\n    }","id":456,"modified_method":"/**\n     * Sets the password for this user, first encrypting it\n     * \n     * @param userID\n     *            the user ID to change the password for\n     * @param aPassword\n     *            the password\n     */\n    public void setUnencryptedPassword(String userID, String aPassword) throws Exception {\n        User user =  m_users.get(userID);\n        if (user != null) {\n            user.setPassword(encryptedPassword(aPassword));\n        }\n    \n        saveCurrent();\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get an XMPP address by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the XMPP address\n     */\n\n    public String getXMPPAddress(String userid) throws IOException, MarshalException, ValidationException {\n\n        update();\n        \n        User user = (User) m_users.get(userid);\n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n            \tif (contact.getType().equals(\"xmppAddress\")) {\n            \t\tvalue = contact.getInfo();\n            \t\tbreak;\n            \t}\n            }\n        }\n        return value;\n\n    }","id":457,"modified_method":"/**\n     * Get an XMPP address by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the XMPP address\n     */\n\n    public String getXMPPAddress(String userID) throws IOException, MarshalException, ValidationException {\n\n        update();\n        \n        User user = m_users.get(userID);\n        if (user == null)\n            return \"\";\n        \n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(\"xmppAddress\")) {\n        \t\treturn contact.getInfo();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a text pin\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the text pin\n     */\n    public String getTextPin(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"textPage\");\n    }","id":458,"modified_method":"/**\n     * Get a text pin\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the text pin\n     */\n    public String getTextPin(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"textPage\");\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves into \"users.xml\" file\n     */\n    private synchronized void saveCurrent() throws Exception {\n        Header header = oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Users users = new Users();\n        Collection collUsers = (Collection) m_users.values();\n        Iterator iter = collUsers.iterator();\n        while (iter != null && iter.hasNext()) {\n            User tmpUser = (User) iter.next();\n            users.addUser(tmpUser);\n        }\n    \n        Userinfo userinfo = new Userinfo();\n        userinfo.setUsers(users);\n        userinfo.setHeader(header);\n    \n        oldHeader = header;\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(userinfo, stringWriter);\n        String writerString = stringWriter.toString();\n        saveXML(writerString);\n    }","id":459,"modified_method":"/**\n     * Saves into \"users.xml\" file\n     */\n    private synchronized void saveCurrent() throws Exception {\n        Header header = oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Users users = new Users();\n        Collection<User> collUsers = m_users.values();\n        Iterator<User> iter = collUsers.iterator();\n        while (iter != null && iter.hasNext()) {\n            User tmpUser = iter.next();\n            users.addUser(tmpUser);\n        }\n    \n        Userinfo userinfo = new Userinfo();\n        userinfo.setUsers(users);\n        userinfo.setHeader(header);\n    \n        oldHeader = header;\n    \n        // marshal to a string first, then write the string to the file. This\n        // way the original configuration\n        // isn't lost if the XML from the marshal is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(userinfo, stringWriter);\n        String writerString = stringWriter.toString();\n        saveXML(writerString);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a numeric service provider\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the service provider\n     */\n    public String getNumericPage(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userid, \"numericPage\");\n    }","id":460,"modified_method":"/**\n     * Get a numeric service provider\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the service provider\n     */\n    public String getNumericPage(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userID, \"numericPage\");\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method compares two encrypted strings for equality.\n     * \n     * @param userID\n     *            the user ID to check against.\n     * @param aPassword\n     *            the password to check for equality\n     * @return true if the two passwords are equal (after encryption), false\n     *         otherwise\n     */\n    public boolean comparePasswords(String userID, String aPassword) {\n        User user = (User) m_users.get(userID);\n        if (user == null)\n            return false;\n    \n        return user.getPassword().equals(encryptedPassword(aPassword));\n    }","id":461,"modified_method":"/**\n     * This method compares two encrypted strings for equality.\n     * \n     * @param userID\n     *            the user ID to check against.\n     * @param aPassword\n     *            the password to check for equality\n     * @return true if the two passwords are equal (after encryption), false\n     *         otherwise\n     */\n    public boolean comparePasswords(String userID, String aPassword) {\n        User user = m_users.get(userID);\n        if (user == null)\n            return false;\n    \n        return user.getPassword().equals(encryptedPassword(aPassword));\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the contact info given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactInfo(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        User user = (User) m_users.get(userID);\n        return getContactInfo(user, command);\n    }","id":462,"modified_method":"/**\n     * Get the contact info given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactInfo(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        User user = m_users.get(userID);\n        return getContactInfo(user, command);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public synchronized void saveUsers(Collection usersList) throws Exception {\n        // clear out the interanal structure and reload it\n        m_users.clear();\n    \n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n    }","id":463,"modified_method":"/**\n     */\n    public synchronized void saveUsers(Collection<User> usersList) throws Exception {\n        // clear out the internal structure and reload it\n        m_users.clear();\n    \n        for (User curUser : usersList) {\n        \tm_users.put(curUser.getUserId(), curUser);\n        }\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a email by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the email specified by name\n     */\n    public String getEmail(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"email\");\n    }","id":464,"modified_method":"/**\n     * Get a email by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the email specified by name\n     */\n    public String getEmail(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"email\");\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a user by name\n     * \n     * @param name\n     *            the name of the user to return\n     * @return the user specified by name\n     */\n    public User getUser(String name) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        return (User) m_users.get(name);\n    }","id":465,"modified_method":"/**\n     * Get a user by name\n     * \n     * @param name\n     *            the name of the user to return\n     * @return the user specified by name\n     */\n    public User getUser(String name) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        return m_users.get(name);\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a Text Page Service Provider\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the text page service provider.\n     */\n    public String getTextPage(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userid, \"textPage\");\n    }","id":466,"modified_method":"/**\n     * Get a Text Page Service Provider\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the text page service provider.\n     */\n    public String getTextPage(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userID, \"textPage\");\n    }","commit_id":"0a1d47795faee89a3be33c92d525aadc22bdeca0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List getUserSchedulesForRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> scheds = new ArrayList<Schedule>();\n        Role role = getRole(roleid);\n        Iterator it = role.getScheduleCollection().iterator();\n        while(it.hasNext()) {\n            Schedule sched = (Schedule)it.next();\n            if (userId.equals(sched.getName())) {\n                scheds.add(sched);\n            }\n        }\n        return scheds;\n        \n    }","id":467,"modified_method":"public List<Schedule> getUserSchedulesForRole(String userId, String roleId) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> scheds = new ArrayList<Schedule>();\n        for (Schedule sched : getRole(roleId).getScheduleCollection()) {\n            if (userId.equals(sched.getName())) {\n                scheds.add(sched);\n            }\n        }\n        return scheds;\n        \n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<Schedule> getSchedulesForRoleAt(String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        Role role = getRole(roleId);\n        List<Schedule> schedules = new ArrayList<Schedule>();\n        for (Iterator it = role.getScheduleCollection().iterator(); it.hasNext();) {\n            Schedule sched = (Schedule) it.next();\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                schedules.add(sched);\n            }\n        }\n        return schedules;\n    }","id":468,"modified_method":"public List<Schedule> getSchedulesForRoleAt(String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List<Schedule> schedules = new ArrayList<Schedule>();\n        for (Schedule sched : getRole(roleId).getScheduleCollection()) {\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                schedules.add(sched);\n            }\n        }\n        return schedules;\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * When this method is called group name is changed, so also is the\n     * groupname belonging to the view. Also overwrites the \"groups.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (oldName == null || newName == null || oldName == \"\" || newName == \"\") {\n            throw new Exception(\"Group Factory: Rename user.. no value \");\n        } else {\n            Collection coll = (Collection) m_groups.values();\n            Iterator iter = (Iterator) coll.iterator();\n            Map<String, Group> map = new LinkedHashMap<String, Group>();\n    \n            while (iter.hasNext()) {\n                Group group = (Group) iter.next();\n                Enumeration en = group.enumerateUser();\n                String name = \"\";\n                while (en.hasMoreElements()) {\n                    name = (String) en.nextElement();\n                    if (name.equals(oldName)) {\n                        group.removeUser(oldName);\n                        group.addUser(newName);\n                    }\n                }\n                map.put(group.getName(), group);\n            }\n            m_groups.clear();\n            m_groups = map;\n            \n            Iterator it = m_roles.values().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                Iterator j = role.getScheduleCollection().iterator();\n                while(j.hasNext()) {\n                    Schedule sched = (Schedule)j.next();\n                    if (oldName.equals(sched.getName())) {\n                        sched.setName(newName);\n                    }\n                }\n            }\n            \n            saveGroups();\n        }\n    }","id":469,"modified_method":"/**\n     * When this method is called group name is changed, so also is the\n     * group name belonging to the view. Also overwrites the \"groups.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (oldName == null || newName == null || oldName == \"\" || newName == \"\") {\n            throw new Exception(\"Group Factory: Rename user.. no value \");\n        } else {\n            Map<String, Group> map = new LinkedHashMap<String, Group>();\n            \n        \tfor (Group group : m_groups.values()) {\n        \t\tfor (String name : group.getUserCollection()) {\n                    if (name.equals(oldName)) {\n                        group.removeUser(oldName);\n                        group.addUser(newName);\n                    }\n                }\n                map.put(group.getName(), group);\n            }\n            m_groups.clear();\n            m_groups.putAll(map);\n\n            for (Role role : m_roles.values()) {\n            \tfor (Schedule sched : role.getScheduleCollection()) {\n                    if (oldName.equals(sched.getName())) {\n                        sched.setName(newName);\n                    }\n                }\n            }\n            \n            saveGroups();\n        }\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines when a group is next on duty. If a group has no duty schedules\n     * listed in the config file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return long, the time in millisec until the group is next on duty\n     */\n    public long groupNextOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        long next = -1;\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return 0;\n        }\n        List dutySchedules = (List)m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule)dutySchedules.get(i);\n            long tempnext =  curSchedule.nextInSchedule(time);\n            if( tempnext < next || next == -1 ) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isGroupOnDuty: On duty in \" + tempnext + \" millisec from schedule \" + i);\n                }\n                next = tempnext;\n            }\n        }\n        return next;\n    }","id":470,"modified_method":"/**\n     * Determines when a group is next on duty. If a group has no duty schedules\n     * listed in the configuration file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return long, the time in milliseconds until the group is next on duty\n     */\n    public long groupNextOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        Category log = ThreadCategory.getInstance(this.getClass());\n        long next = -1;\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return 0;\n        }\n        List<DutySchedule> dutySchedules = m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = dutySchedules.get(i);\n            long tempnext =  curSchedule.nextInSchedule(time);\n            if( tempnext < next || next == -1 ) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"isGroupOnDuty: On duty in \" + tempnext + \" millisec from schedule \" + i);\n                }\n                next = tempnext;\n            }\n        }\n        return next;\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OwnedIntervalSequence getRoleScheduleEntries(String roleid, Date start, Date end) throws MarshalException, ValidationException, IOException {\n        update();\n\n        OwnedIntervalSequence schedEntries = new OwnedIntervalSequence();\n        Role role = getRole(roleid);\n        for (int i = 0; i < role.getScheduleCount(); i++) {\n            Schedule sched = (Schedule) role.getSchedule(i);\n            Owner owner = new Owner(roleid, sched.getName(), i);\n            schedEntries.addAll(BasicScheduleUtils.getIntervalsCovering(start, end, sched, owner));\n        }\n        \n        OwnedIntervalSequence defaultEntries = new OwnedIntervalSequence(new OwnedInterval(start, end));\n        defaultEntries.removeAll(schedEntries);\n        Owner supervisor = new Owner(roleid, role.getSupervisor());\n        for (Iterator it = defaultEntries.iterator(); it.hasNext();) {\n            OwnedInterval interval = (OwnedInterval) it.next();\n            interval.addOwner(supervisor);\n        }\n        \n        schedEntries.addAll(defaultEntries);\n        return schedEntries;\n        \n    }","id":471,"modified_method":"public OwnedIntervalSequence getRoleScheduleEntries(String roleid, Date start, Date end) throws MarshalException, ValidationException, IOException {\n        update();\n\n        OwnedIntervalSequence schedEntries = new OwnedIntervalSequence();\n        Role role = getRole(roleid);\n        for (int i = 0; i < role.getScheduleCount(); i++) {\n            Schedule sched = role.getSchedule(i);\n            Owner owner = new Owner(roleid, sched.getName(), i);\n            schedEntries.addAll(BasicScheduleUtils.getIntervalsCovering(start, end, sched, owner));\n        }\n        \n        OwnedIntervalSequence defaultEntries = new OwnedIntervalSequence(new OwnedInterval(start, end));\n        defaultEntries.removeAll(schedEntries);\n        Owner supervisor = new Owner(roleid, role.getSupervisor());\n        for (Iterator<TimeInterval> it = defaultEntries.iterator(); it.hasNext();) {\n        \tOwnedInterval interval = new OwnedInterval(it.next());\n            interval.addOwner(supervisor);\n        }\n        \n        schedEntries.addAll(defaultEntries);\n        return schedEntries;\n        \n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Removes the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteGroup(String name) throws Exception {\n        // Check if the group exists\n        if (name != null || !name.equals(\"\")) {\n            if (m_groups.containsKey(name)) {\n                // Remove the group.\n                m_groups.remove(name);\n    \n            } else\n                throw new Exception(\"GroupFactory:delete Group doesnt exist:\" + name);\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user group:\" + name);\n        }\n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","id":472,"modified_method":"/**\n     * Removes the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteGroup(String name) throws Exception {\n        // Check if the group exists\n        if (name != null && !name.equals(\"\")) {\n            if (m_groups.containsKey(name)) {\n                // Remove the group.\n                m_groups.remove(name);\n            } else\n                throw new Exception(\"GroupFactory:delete Group doesnt exist:\" + name);\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user group:\" + name);\n        }\n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Renames the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void renameGroup(String oldName, String newName) throws Exception {\n    \tif (oldName != null || !oldName.equals(\"\")) {\n    \t\tif (m_groups.containsKey(oldName)) {\n    \t\t\tGroup grp = (Group)m_groups.get(oldName);\n    \t\t\tgrp.setName(newName);\n    \t\t\tm_groups.put(newName, grp);\n    \t\t} else {\n    \t\t\tthrow new Exception(\"GroupFactory.renameGroup: Group doesn't exist: \" + oldName);\n    \t\t}\n    \t\t// Save into groups.xml\n    \t\tsaveGroups();\n    \t}\n    }","id":473,"modified_method":"/**\n     * Renames the group from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void renameGroup(String oldName, String newName) throws Exception {\n    \tif (oldName != null && !oldName.equals(\"\")) {\n    \t\tif (m_groups.containsKey(oldName)) {\n    \t\t\tGroup grp = m_groups.get(oldName);\n    \t\t\tgrp.setName(newName);\n    \t\t\tm_groups.put(newName, grp);\n    \t\t} else {\n    \t\t\tthrow new Exception(\"GroupFactory.renameGroup: Group doesn't exist: \" + oldName);\n    \t\t}\n    \t\t// Save into groups.xml\n    \t\tsaveGroups();\n    \t}\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public synchronized void saveGroups() throws Exception {\n        Header header = m_oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Groups groups = new Groups();\n        Collection collgroups = (Collection) m_groups.values();\n        Iterator iter = collgroups.iterator();\n        while (iter != null && iter.hasNext()) {\n            Group grp = (Group) iter.next();\n            groups.addGroup(grp);\n        }\n        \n        \n        Roles roles = new Roles();\n        Iterator it = m_roles.values().iterator();\n        while(it.hasNext()) {\n            Role role = (Role)it.next();\n            roles.addRole(role);\n        }\n    \n        Groupinfo groupinfo = new Groupinfo();\n        groupinfo.setGroups(groups);\n        if (roles.getRoleCount() > 0)\n            groupinfo.setRoles(roles);\n        groupinfo.setHeader(header);\n    \n        m_oldHeader = header;\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(groupinfo, stringWriter);\n        String data = stringWriter.toString();\n        saveXml(data);\n    }","id":474,"modified_method":"/**\n     */\n    public synchronized void saveGroups() throws Exception {\n        Header header = m_oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Groups groups = new Groups();\n        for (Group grp : m_groups.values()) {\n            groups.addGroup(grp);\n        }\n        \n        \n        Roles roles = new Roles();\n        for (Role role : m_roles.values()) {\n            roles.addRole(role);\n        }\n    \n        Groupinfo groupinfo = new Groupinfo();\n        groupinfo.setGroups(groups);\n        if (roles.getRoleCount() > 0)\n            groupinfo.setRoles(roles);\n        groupinfo.setHeader(header);\n    \n        m_oldHeader = header;\n    \n        // marshal to a string first, then write the string to the file. This\n        // way the original configuration\n        // isn't lost if the XML from the marshal is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(groupinfo, stringWriter);\n        String data = stringWriter.toString();\n        saveXml(data);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean isUserScheduledForRole(String userId, String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        List scheds = getUserSchedulesForRole(userId, roleid);\n        for (Iterator it = scheds.iterator(); it.hasNext();) {\n            Schedule sched = (Schedule) it.next();\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                return true;\n            }\n        }\n        \n        // if no user is scheduled then the supervisor is schedule by default \n        Role role = getRole(roleid);\n        if (userId.equals(role.getSupervisor())) {\n            for (Iterator it = role.getScheduleCollection().iterator(); it.hasNext();) {\n                Schedule sched = (Schedule) it.next();\n                if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                    // we found another scheduled user\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":475,"modified_method":"public boolean isUserScheduledForRole(String userId, String roleId, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n\n        for (Schedule sched : getUserSchedulesForRole(userId, roleId)) {\n            if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                return true;\n            }\n        }\n        \n        // if no user is scheduled then the supervisor is schedule by default \n        Role role = getRole(roleId);\n        if (userId.equals(role.getSupervisor())) {\n        \tfor (Schedule sched : role.getScheduleCollection()) {\n                if (BasicScheduleUtils.isTimeInSchedule(time, sched)) {\n                    // we found another scheduled user\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected synchronized void parseXml(Reader reader) throws MarshalException, ValidationException {\n        Groupinfo groupinfo = (Groupinfo) Unmarshaller.unmarshal(Groupinfo.class, reader);\n        Groups groups = groupinfo.getGroups();\n        m_groups = new LinkedHashMap<String, Group>();\n        Collection groupList = groups.getGroupCollection();\n        m_oldHeader = groupinfo.getHeader();\n        Iterator i = groupList.iterator();\n        while (i.hasNext()) {\n            Group curGroup = (Group) i.next();\n            m_groups.put(curGroup.getName(), curGroup);\n        }\n        buildDutySchedules(m_groups);\n        \n        Roles roles = groupinfo.getRoles();\n        m_roles = new LinkedHashMap<String, Role>();\n        if (roles != null) {\n            Iterator it = roles.getRoleCollection().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                m_roles.put(role.getName(), role);\n            }\n        }\n    }","id":476,"modified_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    protected synchronized void parseXml(Reader reader) throws MarshalException, ValidationException {\n        Groupinfo groupinfo = (Groupinfo) Unmarshaller.unmarshal(Groupinfo.class, reader);\n        Groups groups = groupinfo.getGroups();\n        m_groups = new LinkedHashMap<String, Group>();\n        m_oldHeader = groupinfo.getHeader();\n        for (Group curGroup : groups.getGroupCollection()) {\n            m_groups.put(curGroup.getName(), curGroup);\n        }\n        buildDutySchedules(m_groups);\n        \n        Roles roles = groupinfo.getRoles();\n        m_roles = new LinkedHashMap<String, Role>();\n        if (roles != null) {\n        \tfor (Role role : roles.getRoleCollection()) {\n                m_roles.put(role.getName(), role);\n            }\n        }\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a mapping between groups and duty schedules. These are used when\n     * determining to send a notice to a given group. This helps speed up the decision process.\n     * @param groups the map of groups parsed from the xml config file\n     */\n    private static void buildDutySchedules(Map groups) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        Iterator i = groups.keySet().iterator();\n        while(i.hasNext()) {\n            String key = (String)i.next();\n            Group curGroup = (Group)groups.get(key);\n            if (curGroup.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                Enumeration duties = curGroup.enumerateDutySchedule();\n                while(duties.hasMoreElements()) {\n                    dutyList.add(new DutySchedule( (String)duties.nextElement() ));\n                }\n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","id":477,"modified_method":"/**\n     * Builds a mapping between groups and duty schedules. These are used when\n     * determining to send a notice to a given group. This helps speed up the decision process.\n     * @param groups the map of groups parsed from the XML configuration file\n     */\n    private static void buildDutySchedules(Map<String, Group> groups) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        Iterator<String> i = groups.keySet().iterator();\n        while(i.hasNext()) {\n            String key = i.next();\n            Group curGroup = groups.get(key);\n            if (curGroup.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                for (String duty : curGroup.getDutyScheduleCollection()) {\n                \tdutyList.add(new DutySchedule(duty));\n                }\n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Removes the user from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteUser(String name) throws Exception {\n        // Check if the user exists\n        if (name != null || !name.equals(\"\")) {\n            // Remove the user in the group.\n            Set grps = (Set) m_groups.keySet();\n            Iterator iterator = (Iterator) grps.iterator();\n            while (iterator.hasNext()) {\n                Group group;\n                group = (Group) m_groups.get((String) iterator.next());\n                group.removeUser(name);\n            }\n            \n            Iterator it = m_roles.values().iterator();\n            while(it.hasNext()) {\n                Role role = (Role)it.next();\n                Iterator j = role.getScheduleCollection().iterator();\n                while(j.hasNext()) {\n                    Schedule sched = (Schedule)j.next();\n                    if (name.equals(sched.getName())) {\n                        j.remove();\n                    }\n                }\n            }\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user name:\" + name);\n        }\n        \n        \n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","id":478,"modified_method":"/**\n     * Removes the user from the list of groups. Then overwrites to the\n     * \"groups.xml\"\n     */\n    public synchronized void deleteUser(String name) throws Exception {\n        // Check if the user exists\n        if (name != null && !name.equals(\"\")) {\n            // Remove the user in the group.\n        \tfor (Group group : m_groups.values()) {\n        \t\tgroup.removeUser(name);\n        \t}\n\n        \tfor (Role role : m_roles.values()) {\n                Iterator<Schedule> s = role.getScheduleCollection().iterator();\n                while(s.hasNext()) {\n                    Schedule sched = s.next();\n                    if (name.equals(sched.getName())) {\n                        s.remove();\n                    }\n                }\n            }\n        } else {\n            throw new Exception(\"GroupFactory:delete Invalid user name:\" + name);\n        }\n        \n        \n        // Saves into \"groups.xml\" file\n        saveGroups();\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if a group is on duty at a given time. If a group has no duty schedules\n     * listed in the config file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return boolean, true if the group is on duty, false otherwise.\n     */\n    public boolean isGroupOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return true;\n        }\n        boolean result = false;\n        List dutySchedules = (List)m_dutySchedules.get(group);\n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule)dutySchedules.get(i);\n            result = curSchedule.isInSchedule(time);\n            //don't continue if the time is in this schedule\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }","id":479,"modified_method":"/**\n     * Determines if a group is on duty at a given time. If a group has no duty schedules\n     * listed in the configuration file, that group is assumed to always be on duty.\n     * @param group the group whose duty schedule we want\n     * @param time the time to check for a duty schedule\n     * @return boolean, true if the group is on duty, false otherwise.\n     */\n    public boolean isGroupOnDuty(String group, Calendar time) throws IOException, MarshalException, ValidationException {\n        update();\n        //if the group has no duty schedules then it is on duty\n        if (!m_dutySchedules.containsKey(group)) {\n            return true;\n        }\n        List<DutySchedule> dutySchedules = m_dutySchedules.get(group);\n        for (DutySchedule curSchedule : dutySchedules) {\n        \tif (curSchedule.isInSchedule(time)) {\n        \t\treturn true;\n        \t}\n        }\n        return false;\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean userHasRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        Role role = getRole(roleid);\n        Iterator j = role.getScheduleCollection().iterator();\n        while(j.hasNext()) {\n            Schedule sched = (Schedule)j.next();\n            if (userId.equals(sched.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","id":480,"modified_method":"public boolean userHasRole(String userId, String roleid) throws MarshalException, ValidationException, IOException {\n        update();\n\n        for (Schedule sched : getRole(roleid).getScheduleCollection()) {\n            if (userId.equals(sched.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a pager email by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the pager email\n     */\n    public String getPagerEmail(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"pagerEmail\");\n    }","id":481,"modified_method":"/**\n     * Get a pager email by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the pager email\n     */\n    public String getPagerEmail(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"pagerEmail\");\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if a user is on duty at a given time. If a user has no duty\n     * schedules listed in the config file, that user is assumed to always be on\n     * duty.\n     * \n     * @param user\n     *            the user id\n     * @param time\n     *            the time to check for a duty schedule\n     * @return boolean, true if the user is on duty, false otherwise.\n     */\n    public boolean isUserOnDuty(String user, Calendar time) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        // if the user has no duty schedules then he is on duty\n        if (!m_dutySchedules.containsKey(user))\n            return true;\n    \n        boolean result = false;\n        List dutySchedules = (List) m_dutySchedules.get(user);\n    \n        for (int i = 0; i < dutySchedules.size(); i++) {\n            DutySchedule curSchedule = (DutySchedule) dutySchedules.get(i);\n    \n            result = curSchedule.isInSchedule(time);\n    \n            // don't continue if the time is in this schedule\n            if (result)\n                break;\n        }\n    \n        return result;\n    }","id":482,"modified_method":"/**\n     * Determines if a user is on duty at a given time. If a user has no duty\n     * schedules listed in the configuration file, that user is assumed to always be on\n     * duty.\n     * \n     * @param user\n     *            the user id\n     * @param time\n     *            the time to check for a duty schedule\n     * @return boolean, true if the user is on duty, false otherwise.\n     */\n    public boolean isUserOnDuty(String user, Calendar time) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        // if the user has no duty schedules then he is on duty\n        if (!m_dutySchedules.containsKey(user))\n            return true;\n\n        for (DutySchedule curSchedule : m_dutySchedules.get(user)) {\n        \tif (curSchedule.isInSchedule(time)) {\n        \t\treturn true;\n        \t}\n        }\n        \n        return false;\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a Text Page Service Provider\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the text page service provider.\n     */\n    public String getTextPage(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userid, \"textPage\");\n    }","id":483,"modified_method":"/**\n     * Get a Text Page Service Provider\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the text page service provider.\n     */\n    public String getTextPage(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userID, \"textPage\");\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * When this method is called users name is changed, so also is the username\n     * belonging to the group and the view. Also overwrites the \"users.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (m_users.containsKey(oldName)) {\n            User data = (User) m_users.get(oldName);\n            if (data == null) {\n                m_users.remove(oldName);\n                throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n            } else {\n                // Rename the user in the user map.\n                m_users.remove(oldName);\n                data.setUserId(newName);\n                m_users.put(newName, data);\n    \n                // Rename the user in the group.\n                m_groupManager.renameUser(oldName, newName);\n    \n                // Rename the user in the view.\n                // viewFactory.renameUser(oldName, newName);\n            }\n        } else {\n            throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n        }\n    \n        saveCurrent();\n    }","id":484,"modified_method":"/**\n     * When this method is called users name is changed, so also is the username\n     * belonging to the group and the view. Also overwrites the \"users.xml\" file\n     */\n    public synchronized void renameUser(String oldName, String newName) throws Exception {\n        // Get the old data\n        if (m_users.containsKey(oldName)) {\n            User data = m_users.get(oldName);\n            if (data == null) {\n                m_users.remove(oldName);\n                throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n            } else {\n                // Rename the user in the user map.\n                m_users.remove(oldName);\n                data.setUserId(newName);\n                m_users.put(newName, data);\n    \n                // Rename the user in the group.\n                m_groupManager.renameUser(oldName, newName);\n    \n                // Rename the user in the view.\n                // viewFactory.renameUser(oldName, newName);\n            }\n        } else {\n            throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n        }\n    \n        saveCurrent();\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a numeric service provider\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the service provider\n     */\n    public String getNumericPage(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userid, \"numericPage\");\n    }","id":485,"modified_method":"/**\n     * Get a numeric service provider\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the service provider\n     */\n    public String getNumericPage(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactServiceProvider(userID, \"numericPage\");\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a text pin\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the text pin\n     */\n    public String getTextPin(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"textPage\");\n    }","id":486,"modified_method":"/**\n     * Get a text pin\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the text pin\n     */\n    public String getTextPin(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"textPage\");\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Saves into \"users.xml\" file\n     */\n    private synchronized void saveCurrent() throws Exception {\n        Header header = oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Users users = new Users();\n        Collection collUsers = (Collection) m_users.values();\n        Iterator iter = collUsers.iterator();\n        while (iter != null && iter.hasNext()) {\n            User tmpUser = (User) iter.next();\n            users.addUser(tmpUser);\n        }\n    \n        Userinfo userinfo = new Userinfo();\n        userinfo.setUsers(users);\n        userinfo.setHeader(header);\n    \n        oldHeader = header;\n    \n        // marshall to a string first, then write the string to the file. This\n        // way the original config\n        // isn't lost if the xml from the marshall is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(userinfo, stringWriter);\n        String writerString = stringWriter.toString();\n        saveXML(writerString);\n    }","id":487,"modified_method":"/**\n     * Saves into \"users.xml\" file\n     */\n    private synchronized void saveCurrent() throws Exception {\n        Header header = oldHeader;\n    \n        header.setCreated(EventConstants.formatToString(new Date()));\n    \n        Users users = new Users();\n        Collection<User> collUsers = m_users.values();\n        Iterator<User> iter = collUsers.iterator();\n        while (iter != null && iter.hasNext()) {\n            User tmpUser = iter.next();\n            users.addUser(tmpUser);\n        }\n    \n        Userinfo userinfo = new Userinfo();\n        userinfo.setUsers(users);\n        userinfo.setHeader(header);\n    \n        oldHeader = header;\n    \n        // marshal to a string first, then write the string to the file. This\n        // way the original configuration\n        // isn't lost if the XML from the marshal is hosed.\n        StringWriter stringWriter = new StringWriter();\n        Marshaller.marshal(userinfo, stringWriter);\n        String writerString = stringWriter.toString();\n        saveXML(writerString);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get an XMPP address by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the XMPP address\n     */\n\n    public String getXMPPAddress(String userid) throws IOException, MarshalException, ValidationException {\n\n        update();\n        \n        User user = (User) m_users.get(userid);\n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n            \tif (contact.getType().equals(\"xmppAddress\")) {\n            \t\tvalue = contact.getInfo();\n            \t\tbreak;\n            \t}\n            }\n        }\n        return value;\n\n    }","id":488,"modified_method":"/**\n     * Get an XMPP address by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the XMPP address\n     */\n\n    public String getXMPPAddress(String userID) throws IOException, MarshalException, ValidationException {\n\n        update();\n        \n        User user = m_users.get(userID);\n        if (user == null)\n            return \"\";\n        \n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(\"xmppAddress\")) {\n        \t\treturn contact.getInfo();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a numeric pin\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the numeric pin\n     */\n    public String getNumericPin(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"numericPage\");\n    }","id":489,"modified_method":"/**\n     * Get a numeric pin\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the numeric pin\n     */\n    public String getNumericPin(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"numericPage\");\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the password for this user, first encrypting it\n     * \n     * @param userID\n     *            the user ID to change the pasword for\n     * @param aPassword\n     *            the password\n     */\n    public void setUnencryptedPassword(String userID, String aPassword) throws Exception {\n        User user = (User) m_users.get(userID);\n        if (user != null) {\n            user.setPassword(encryptedPassword(aPassword));\n        }\n    \n        saveCurrent();\n    }","id":490,"modified_method":"/**\n     * Sets the password for this user, first encrypting it\n     * \n     * @param userID\n     *            the user ID to change the password for\n     * @param aPassword\n     *            the password\n     */\n    public void setUnencryptedPassword(String userID, String aPassword) throws Exception {\n        User user =  m_users.get(userID);\n        if (user != null) {\n            user.setPassword(encryptedPassword(aPassword));\n        }\n    \n        saveCurrent();\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method compares two encrypted strings for equality.\n     * \n     * @param userID\n     *            the user ID to check against.\n     * @param aPassword\n     *            the password to check for equality\n     * @return true if the two passwords are equal (after encryption), false\n     *         otherwise\n     */\n    public boolean comparePasswords(String userID, String aPassword) {\n        User user = (User) m_users.get(userID);\n        if (user == null)\n            return false;\n    \n        return user.getPassword().equals(encryptedPassword(aPassword));\n    }","id":491,"modified_method":"/**\n     * This method compares two encrypted strings for equality.\n     * \n     * @param userID\n     *            the user ID to check against.\n     * @param aPassword\n     *            the password to check for equality\n     * @return true if the two passwords are equal (after encryption), false\n     *         otherwise\n     */\n    public boolean comparePasswords(String userID, String aPassword) {\n        User user = m_users.get(userID);\n        if (user == null)\n            return false;\n    \n        return user.getPassword().equals(encryptedPassword(aPassword));\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void parseXML(Reader reader) throws MarshalException, ValidationException {\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, reader);\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection usersList = users.getUserCollection();\n        m_users = new HashMap<String, User>();\n    \n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n        buildDutySchedules(m_users);\n    }","id":492,"modified_method":"/**\n     * @param reader\n     * @throws MarshalException\n     * @throws ValidationException\n     */\n    public void parseXML(Reader reader) throws MarshalException, ValidationException {\n        Userinfo userinfo = (Userinfo) Unmarshaller.unmarshal(Userinfo.class, reader);\n        Users users = userinfo.getUsers();\n        oldHeader = userinfo.getHeader();\n        Collection<User> usersList = users.getUserCollection();\n        m_users = new HashMap<String, User>();\n\n        for (User curUser : usersList) {\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n        buildDutySchedules(m_users);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the contact info given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactInfo(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        User user = (User) m_users.get(userID);\n        return getContactInfo(user, command);\n    }","id":493,"modified_method":"/**\n     * Get the contact info given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactInfo(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        User user = m_users.get(userID);\n        return getContactInfo(user, command);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the contact service provider, given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactServiceProvider(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        User user = (User) m_users.get(userID);\n        return getContactServiceProvider(user, command);\n    }","id":494,"modified_method":"/**\n     * Get the contact service provider, given a command string\n     * \n     * @param userID\n     *            the name of the user\n     * @param command\n     *            the command to look up the contact info for\n     * @return the contact information\n     */\n    public String getContactServiceProvider(String userID, String command) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        User user = m_users.get(userID);\n        return getContactServiceProvider(user, command);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Sets the password for this user, assuming that the value passed in is\n     * already encrypted properly\n     * \n     * @param userID\n     *            the user ID to change the pasword for\n     * @param aPassword\n     *            the encrypted password\n     */\n    public void setEncryptedPassword(String userID, String aPassword) throws Exception {\n        User user = (User) m_users.get(userID);\n        if (user != null) {\n            user.setPassword(aPassword);\n        }\n    \n        saveCurrent();\n    }","id":495,"modified_method":"/**\n     * Sets the password for this user, assuming that the value passed in is\n     * already encrypted properly\n     * \n     * @param userID\n     *            the user ID to change the password for\n     * @param aPassword\n     *            the encrypted password\n     */\n    public void setEncryptedPassword(String userID, String aPassword) throws Exception {\n        User user = m_users.get(userID);\n        if (user != null) {\n            user.setPassword(aPassword);\n        }\n    \n        saveCurrent();\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a user by name\n     * \n     * @param name\n     *            the name of the user to return\n     * @return the user specified by name\n     */\n    public User getUser(String name) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        return (User) m_users.get(name);\n    }","id":496,"modified_method":"/**\n     * Get a user by name\n     * \n     * @param name\n     *            the name of the user to return\n     * @return the user specified by name\n     */\n    public User getUser(String name) throws IOException, MarshalException, ValidationException {\n    \n        update();\n    \n        return m_users.get(name);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Builds a mapping between user ids and duty schedules. These are used by\n     * Notifd when determining to send a notice to a given user. This helps\n     * speed up the decision process.\n     * \n     * @param users\n     *            the map of users parsed from the xml config file\n     */\n    private void buildDutySchedules(Map<String, User> users) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        \n        for (String key : users.keySet()) {\n            User curUser = (User) users.get(key);\n    \n            if (curUser.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                Enumeration duties = curUser.enumerateDutySchedule();\n    \n                while (duties.hasMoreElements()) {\n                    dutyList.add(new DutySchedule((String) duties.nextElement()));\n                }\n    \n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","id":497,"modified_method":"/**\n     * Builds a mapping between user IDs and duty schedules. These are used by\n     * Notifd when determining to send a notice to a given user. This helps\n     * speed up the decision process.\n     * \n     * @param users\n     *            the map of users parsed from the XML configuration file\n     */\n    private void buildDutySchedules(Map<String, User> users) {\n        m_dutySchedules = new HashMap<String, List<DutySchedule>>();\n        \n        for (String key : users.keySet()) {\n            User curUser = users.get(key);\n    \n            if (curUser.getDutyScheduleCount() > 0) {\n                List<DutySchedule> dutyList = new ArrayList<DutySchedule>();\n                for (String duty : curUser.getDutyScheduleCollection()) {\n                \tdutyList.add(new DutySchedule(duty));\n                }\n    \n                m_dutySchedules.put(key, dutyList);\n            }\n        }\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getContactServiceProvider(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n                if (contact.getType().equals(command)) {\n                    value = contact.getServiceProvider();\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":498,"modified_method":"public String getContactServiceProvider(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n\n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(command)) {\n        \t\treturn contact.getServiceProvider();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getContactInfo(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        String value = \"\";\n        Enumeration contacts = user.enumerateContact();\n        while (contacts != null && contacts.hasMoreElements()) {\n            Contact contact = (Contact) contacts.nextElement();\n            if (contact != null) {\n                if (contact.getType().equals(command)) {\n                    value = contact.getInfo();\n                    break;\n                }\n            }\n        }\n        return value;\n    }","id":499,"modified_method":"public String getContactInfo(User user, String command) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        if (user == null)\n            return \"\";\n        \n        for (Contact contact : user.getContactCollection()) {\n        \tif (contact != null && contact.getType().equals(command)) {\n        \t\treturn contact.getInfo();\n        \t}\n        }\n        \n        return \"\";\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String[] getUsersScheduledForRole(String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n        \n        List<String> usersScheduledForRole = new ArrayList<String>();\n        \n        Iterator i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = (User)i.next();\n            if (isUserScheduledForRole(user, roleid, time)) {\n                usersScheduledForRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersScheduledForRole.toArray(new String[usersScheduledForRole.size()]);\n    }","id":500,"modified_method":"public String[] getUsersScheduledForRole(String roleid, Date time) throws MarshalException, ValidationException, IOException {\n        update();\n        \n        List<String> usersScheduledForRole = new ArrayList<String>();\n        \n        Iterator<User> i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = i.next();\n            if (isUserScheduledForRole(user, roleid, time)) {\n                usersScheduledForRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersScheduledForRole.toArray(new String[usersScheduledForRole.size()]);\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get a email by name\n     * \n     * @param userid\n     *            the userid of the user to return\n     * @return String the email specified by name\n     */\n    public String getEmail(String userid) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userid, \"email\");\n    }","id":501,"modified_method":"/**\n     * Get a email by name\n     * \n     * @param userID\n     *            the user ID of the user to return\n     * @return String the email specified by name\n     */\n    public String getEmail(String userID) throws IOException, MarshalException, ValidationException {\n        return getContactInfo(userID, \"email\");\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String[] getUsersWithRole(String roleid) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        List<String> usersWithRole = new ArrayList<String>();\n        \n        Iterator i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = (User)i.next();\n            if (userHasRole(user, roleid)) {\n                usersWithRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersWithRole.toArray(new String[usersWithRole.size()]);\n        \n    }","id":502,"modified_method":"public String[] getUsersWithRole(String roleid) throws IOException, MarshalException, ValidationException {\n        update();\n        \n        List<String> usersWithRole = new ArrayList<String>();\n        \n        Iterator<User> i = m_users.values().iterator();\n        \n        while (i.hasNext()) {\n            User user = i.next();\n            if (userHasRole(user, roleid)) {\n                usersWithRole.add(user.getUserId());\n            }\n        }\n        \n        return (String[]) usersWithRole.toArray(new String[usersWithRole.size()]);\n        \n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     */\n    public synchronized void saveUsers(Collection usersList) throws Exception {\n        // clear out the interanal structure and reload it\n        m_users.clear();\n    \n        Iterator i = usersList.iterator();\n        while (i.hasNext()) {\n            User curUser = (User) i.next();\n            m_users.put(curUser.getUserId(), curUser);\n        }\n    \n    }","id":503,"modified_method":"/**\n     */\n    public synchronized void saveUsers(Collection<User> usersList) throws Exception {\n        // clear out the internal structure and reload it\n        m_users.clear();\n    \n        for (User curUser : usersList) {\n        \tm_users.put(curUser.getUserId(), curUser);\n        }\n    }","commit_id":"ce9d93eec6ce2342674431412e2efcae454fbaa5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            prepareNextLevel();\n        }","id":504,"modified_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            \n            if ( sharedCurrentDepth.value < maxDepth )\n            {\n                prepareNextLevel();\n            }\n            else\n            {\n                this.nextRelationships = Collections.<Relationship>emptyList().iterator();\n            }\n        }","commit_id":"cbf41d1e195b5be27030620879f59d9366129671","url":"https://github.com/neo4j/neo4j"},{"original_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            prepareNextLevel();\n        }","id":505,"modified_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            \n            if ( sharedCurrentDepth.value < maxDepth )\n            {\n                prepareNextLevel();\n            }\n            else\n            {\n                this.nextRelationships = Collections.<Relationship>emptyList().iterator();\n            }\n        }","commit_id":"6d1cee1f931c634a2a9f500fe01c38aa127c004a","url":"https://github.com/neo4j/neo4j"},{"original_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            prepareNextLevel();\n        }","id":506,"modified_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            \n            if ( sharedCurrentDepth.value < maxDepth )\n            {\n                prepareNextLevel();\n            }\n            else\n            {\n                this.nextRelationships = Collections.<Relationship>emptyList().iterator();\n            }\n        }","commit_id":"e6a9493a54aeef9ee3be6c6fe63cb7d847013c54","url":"https://github.com/neo4j/neo4j"},{"original_method":"public AssetEntry updateAsset(\n\t\t\tlong userId, FileEntry fileEntry, FileVersion fileVersion,\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames, String mimeType,\n\t\t\tboolean addDraftAssetEntry, boolean visible)\n\t\tthrows PortalException, SystemException {\n\n\t\tAssetEntry assetEntry = null;\n\n\t\tif (addDraftAssetEntry) {\n\t\t\tassetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileVersion.getFileVersionId(), fileEntry.getUuid(),\n\t\t\t\tassetCategoryIds, assetTagNames, false, null, null, null, null,\n\t\t\t\tmimeType, fileEntry.getTitle(), fileEntry.getDescription(),\n\t\t\t\tnull, null, null, 0, 0, null, false);\n\t\t}\n\t\telse {\n\t\t\tassetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileEntry.getFileEntryId(), fileEntry.getUuid(),\n\t\t\t\tassetCategoryIds, assetTagNames, visible, null, null, null,\n\t\t\t\tnull, mimeType, fileEntry.getTitle(),\n\t\t\t\tfileEntry.getDescription(), null, null, null, 0, 0, null,\n\t\t\t\tfalse);\n\n\t\t\tList<DLFileShortcut> fileShortcuts =\n\t\t\t\tdlFileShortcutPersistence.findByToFileEntryId(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\tuserId, fileShortcut.getGroupId(),\n\t\t\t\t\tDLFileShortcut.class.getName(),\n\t\t\t\t\tfileShortcut.getFileShortcutId(), fileShortcut.getUuid(),\n\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null, null,\n\t\t\t\t\tnull, mimeType, fileEntry.getTitle(),\n\t\t\t\t\tfileEntry.getDescription(), null, null, null, 0, 0, null,\n\t\t\t\t\tfalse);\n\t\t\t}\n\t\t}\n\n\t\treturn assetEntry;\n\t}","id":507,"modified_method":"public AssetEntry updateAsset(\n\t\t\tlong userId, FileEntry fileEntry, FileVersion fileVersion,\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames,\n\t\t\tlong[] assetLinkEntryIds, String mimeType,\n\t\t\tboolean addDraftAssetEntry, boolean visible)\n\t\tthrows PortalException, SystemException {\n\n\t\tAssetEntry assetEntry = null;\n\n\t\tif (addDraftAssetEntry) {\n\t\t\tassetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileVersion.getFileVersionId(), fileEntry.getUuid(),\n\t\t\t\tassetCategoryIds, assetTagNames, false, null, null, null, null,\n\t\t\t\tmimeType, fileEntry.getTitle(), fileEntry.getDescription(),\n\t\t\t\tnull, null, null, 0, 0, null, false);\n\t\t}\n\t\telse {\n\t\t\tassetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\tfileEntry.getFileEntryId(), fileEntry.getUuid(),\n\t\t\t\tassetCategoryIds, assetTagNames, visible, null, null, null,\n\t\t\t\tnull, mimeType, fileEntry.getTitle(),\n\t\t\t\tfileEntry.getDescription(), null, null, null, 0, 0, null,\n\t\t\t\tfalse);\n\n\t\t\tList<DLFileShortcut> fileShortcuts =\n\t\t\t\tdlFileShortcutPersistence.findByToFileEntryId(\n\t\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\tuserId, fileShortcut.getGroupId(),\n\t\t\t\t\tDLFileShortcut.class.getName(),\n\t\t\t\t\tfileShortcut.getFileShortcutId(), fileShortcut.getUuid(),\n\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null, null,\n\t\t\t\t\tnull, mimeType, fileEntry.getTitle(),\n\t\t\t\t\tfileEntry.getDescription(), null, null, null, 0, 0, null,\n\t\t\t\t\tfalse);\n\t\t\t}\n\t\t}\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\n\t\treturn assetEntry;\n\t}","commit_id":"7653508bfb11000df49f45246c5c0fc1a03a8263","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateStatus(\n\t\t\tlong userId, FileEntry fileEntry, FileVersion latestFileVersion,\n\t\t\tint status)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tString latestFileVersionVersion = latestFileVersion.getVersion();\n\n\t\t\tif (latestFileVersionVersion.equals(fileEntry.getVersion())) {\n\t\t\t\tif (!latestFileVersionVersion.equals(\n\t\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\t\tAssetEntry draftAssetEntry = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdraftAssetEntry = assetEntryLocalService.getEntry(\n\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\tlatestFileVersion.getPrimaryKey());\n\n\t\t\t\t\t\tlong[] assetCategoryIds =\n\t\t\t\t\t\t\tdraftAssetEntry.getCategoryIds();\n\t\t\t\t\t\tString[] assetTagNames = draftAssetEntry.getTagNames();\n\n\t\t\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\tfileEntry.getFileEntryId(), fileEntry.getUuid(),\n\t\t\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null,\n\t\t\t\t\t\t\tnull, null, draftAssetEntry.getMimeType(),\n\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(),\n\t\t\t\t\t\t\tnull, null, null, 0, 0, null, false);\n\n\t\t\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\t\t\tdraftAssetEntry.getEntryId());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\tfileEntry.getFileEntryId(), true);\n\t\t\t}\n\n\t\t\t// Social\n\n\t\t\tint activityType = DLActivityKeys.UPDATE_FILE_ENTRY;\n\n\t\t\tif (latestFileVersionVersion.equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\tactivityType = DLActivityKeys.ADD_FILE_ENTRY;\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addUniqueActivity(\n\t\t\t\tlatestFileVersion.getStatusByUserId(),\n\t\t\t\tfileEntry.getGroupId(), latestFileVersion.getCreateDate(),\n\t\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId(),\n\t\t\t\tactivityType, StringPool.BLANK, 0);\n\t\t}\n\t\telse {\n\n\t\t\t// Asset\n\n\t\t\tif (Validator.isNull(fileEntry.getVersion())) {\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\tfileEntry.getFileEntryId(), false);\n\t\t\t}\n\t\t}\n\t}","id":508,"modified_method":"public void updateStatus(\n\t\t\tlong userId, FileEntry fileEntry, FileVersion latestFileVersion,\n\t\t\tint status)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tString latestFileVersionVersion = latestFileVersion.getVersion();\n\n\t\t\tif (latestFileVersionVersion.equals(fileEntry.getVersion())) {\n\t\t\t\tif (!latestFileVersionVersion.equals(\n\t\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\t\tAssetEntry draftAssetEntry = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdraftAssetEntry = assetEntryLocalService.getEntry(\n\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\tlatestFileVersion.getPrimaryKey());\n\n\t\t\t\t\t\tlong[] assetCategoryIds =\n\t\t\t\t\t\t\tdraftAssetEntry.getCategoryIds();\n\t\t\t\t\t\tString[] assetTagNames = draftAssetEntry.getTagNames();\n\n\t\t\t\t\t\tList<AssetLink> assetLinks =\n\t\t\t\t\t\t\tassetLinkLocalService.getDirectLinks(\n\t\t\t\t\t\t\t\tdraftAssetEntry.getEntryId(),\n\t\t\t\t\t\t\t\tAssetLinkConstants.TYPE_RELATED);\n\n\t\t\t\t\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\t\t\t\t\tListUtil.toString(assetLinks, \"entryId2\"), 0L);\n\n\t\t\t\t\t\tAssetEntry assetEntry =\n\t\t\t\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\t\t\t\tuserId, fileEntry.getGroupId(),\n\t\t\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\t\t\tfileEntry.getFileEntryId(), fileEntry.getUuid(),\n\t\t\t\t\t\t\t\tassetCategoryIds, assetTagNames, true, null,\n\t\t\t\t\t\t\t\tnull, null, null, draftAssetEntry.getMimeType(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, null, null, 0,\n\t\t\t\t\t\t\t\t0, null, false);\n\n\t\t\t\t\t\t// Asset Links\n\n\t\t\t\t\t\tassetLinkLocalService.updateLinks(\n\t\t\t\t\t\t\tuserId, assetEntry.getEntryId(),\n\t\t\t\t\t\t\tassetLinkEntryIds, AssetLinkConstants.TYPE_RELATED);\n\n\t\t\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\t\t\tdraftAssetEntry.getEntryId());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\tfileEntry.getFileEntryId(), true);\n\t\t\t}\n\n\t\t\t// Social\n\n\t\t\tint activityType = DLActivityKeys.UPDATE_FILE_ENTRY;\n\n\t\t\tif (latestFileVersionVersion.equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\tactivityType = DLActivityKeys.ADD_FILE_ENTRY;\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addUniqueActivity(\n\t\t\t\tlatestFileVersion.getStatusByUserId(),\n\t\t\t\tfileEntry.getGroupId(), latestFileVersion.getCreateDate(),\n\t\t\t\tDLFileEntryConstants.getClassName(), fileEntry.getFileEntryId(),\n\t\t\t\tactivityType, StringPool.BLANK, 0);\n\t\t}\n\t\telse {\n\n\t\t\t// Asset\n\n\t\t\tif (Validator.isNull(fileEntry.getVersion())) {\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\tfileEntry.getFileEntryId(), false);\n\t\t\t}\n\t\t}\n\t}","commit_id":"7653508bfb11000df49f45246c5c0fc1a03a8263","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry addFileEntry(\n\t\t\tlong userId, long groupId, long repositoryId, long folderId,\n\t\t\tString title, String description, String changeLog, InputStream is,\n\t\t\tlong size, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = dlFolderLocalService.getFolderId(\n\t\t\tuser.getCompanyId(), folderId);\n\t\tString name = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\t\tString extension = (String)serviceContext.getAttribute(\"extension\");\n\t\tString mimeType = (String)serviceContext.getAttribute(\"contentType\");\n\n\t\tLong documentTypeId = (Long)serviceContext.getAttribute(\n\t\t\t\"documentTypeId\");\n\n\t\tif (documentTypeId == null) {\n\t\t\tdocumentTypeId = 0L;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFile(groupId, folderId, title, extension, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tdlFileEntry.setUuid(serviceContext.getUuid());\n\t\tdlFileEntry.setGroupId(groupId);\n\t\tdlFileEntry.setCompanyId(user.getCompanyId());\n\t\tdlFileEntry.setUserId(user.getUserId());\n\t\tdlFileEntry.setUserName(user.getFullName());\n\t\tdlFileEntry.setVersionUserId(user.getUserId());\n\t\tdlFileEntry.setVersionUserName(user.getFullName());\n\t\tdlFileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tdlFileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tdlFileEntry.setRepositoryId(repositoryId);\n\t\tdlFileEntry.setFolderId(folderId);\n\t\tdlFileEntry.setName(name);\n\t\tdlFileEntry.setExtension(extension);\n\t\tdlFileEntry.setMimeType(mimeType);\n\t\tdlFileEntry.setTitle(title);\n\t\tdlFileEntry.setDescription(description);\n\t\tdlFileEntry.setDocumentTypeId(documentTypeId);\n\t\tdlFileEntry.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\tdlFileEntry.setSize(size);\n\t\tdlFileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\n\t\tdlFileEntryPersistence.update(dlFileEntry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tdlFileEntry, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tdlFileEntry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// File version\n\n\t\tDLFileVersion dlFileVersion = addFileVersion(\n\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now), extension,\n\t\t\tmimeType, title, description, null, StringPool.BLANK,\n\t\t\tdocumentTypeId, DLFileEntryConstants.DEFAULT_VERSION, size,\n\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// DLApp\n\n\t\tdlAppHelperLocalService.addFileEntry(\n\t\t\tnew LiferayFileEntry(dlFileEntry),\n\t\t\tnew LiferayFileVersion(dlFileVersion), serviceContext);\n\n\t\t// File\n\n\t\tdlLocalService.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(), name,\n\t\t\tfalse, fileEntryId, dlFileEntry.getLuceneProperties(),\n\t\t\tdlFileEntry.getModifiedDate(), serviceContext, is);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId, DLFileEntry.class.getName(),\n\t\t\tfileEntryId, dlFileEntry, serviceContext);\n\n\t\treturn dlFileEntry;\n\t}","id":509,"modified_method":"public DLFileEntry addFileEntry(\n\t\t\tlong userId, long groupId, long repositoryId, long folderId,\n\t\t\tString title, String description, String changeLog, InputStream is,\n\t\t\tlong size, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = dlFolderLocalService.getFolderId(\n\t\t\tuser.getCompanyId(), folderId);\n\t\tString name = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\t\tString extension = (String)serviceContext.getAttribute(\"extension\");\n\t\tString mimeType = (String)serviceContext.getAttribute(\"contentType\");\n\n\t\tLong documentTypeId = (Long)serviceContext.getAttribute(\n\t\t\t\"documentTypeId\");\n\n\t\tif (documentTypeId == null) {\n\t\t\tdocumentTypeId = 0L;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFile(groupId, folderId, title, extension, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tdlFileEntry.setUuid(serviceContext.getUuid());\n\t\tdlFileEntry.setGroupId(groupId);\n\t\tdlFileEntry.setCompanyId(user.getCompanyId());\n\t\tdlFileEntry.setUserId(user.getUserId());\n\t\tdlFileEntry.setUserName(user.getFullName());\n\t\tdlFileEntry.setVersionUserId(user.getUserId());\n\t\tdlFileEntry.setVersionUserName(user.getFullName());\n\t\tdlFileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tdlFileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tdlFileEntry.setRepositoryId(repositoryId);\n\t\tdlFileEntry.setFolderId(folderId);\n\t\tdlFileEntry.setName(name);\n\t\tdlFileEntry.setExtension(extension);\n\t\tdlFileEntry.setMimeType(mimeType);\n\t\tdlFileEntry.setTitle(title);\n\t\tdlFileEntry.setDescription(description);\n\t\tdlFileEntry.setDocumentTypeId(documentTypeId);\n\t\tdlFileEntry.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\tdlFileEntry.setSize(size);\n\t\tdlFileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\n\t\tdlFileEntryPersistence.update(dlFileEntry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tdlFileEntry, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tdlFileEntry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// File version\n\n\t\tDLFileVersion dlFileVersion = addFileVersion(\n\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now), extension,\n\t\t\tmimeType, title, description, null, StringPool.BLANK,\n\t\t\tdocumentTypeId, DLFileEntryConstants.DEFAULT_VERSION, size,\n\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// DLApp\n\n\t\tdlAppHelperLocalService.addFileEntry(\n\t\t\tnew LiferayFileEntry(dlFileEntry),\n\t\t\tnew LiferayFileVersion(dlFileVersion), serviceContext);\n\n\t\t// File\n\n\t\tdlLocalService.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(), name,\n\t\t\tfalse, fileEntryId, dlFileEntry.getLuceneProperties(),\n\t\t\tdlFileEntry.getModifiedDate(), serviceContext, is);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId, DLFileEntry.class.getName(),\n\t\t\tfileEntryId, dlFileEntry, serviceContext);\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"7653508bfb11000df49f45246c5c0fc1a03a8263","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DLFileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName, String title,\n\t\t\tString description, String changeLog, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tString extension = (String)serviceContext.getAttribute(\"extension\");\n\n\t\tif (Validator.isNull(extension)) {\n\t\t\textension = dlFileEntry.getExtension();\n\t\t}\n\n\t\tString mimeType = (String)serviceContext.getAttribute(\"contentType\");\n\n\t\tif (Validator.isNull(mimeType)) {\n\t\t\tmimeType = dlFileEntry.getMimeType();\n\t\t}\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = dlFileEntry.getTitle();\n\t\t\t}\n\t\t}\n\n\t\tLong documentTypeId = (Long)serviceContext.getAttribute(\n\t\t\t\"documentTypeId\");\n\n\t\tif (documentTypeId == null) {\n\t\t\tdocumentTypeId = 0L;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFile(\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getFolderId(),\n\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getExtension(), title,\n\t\t\tsourceFileName, is);\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\tDLFileVersion dlFileVersion = null;\n\n\t\tboolean updatedFileVersion = false;\n\n\t\ttry {\n\t\t\tDLFileVersion latestDLFileVersion =\n\t\t\t\tdlFileEntry.getLatestFileVersion();\n\n\t\t\tif (size == 0) {\n\t\t\t\tsize = latestDLFileVersion.getSize();\n\t\t\t}\n\n\t\t\tif (!latestDLFileVersion.isApproved()) {\n\t\t\t\tif (!PropsValues.DL_FILE_ENTRY_DRAFTS_ENABLED) {\n\t\t\t\t\tversion = latestDLFileVersion.getVersion();\n\t\t\t\t}\n\n\t\t\t\tif (version.equals(latestDLFileVersion.getVersion())) {\n\t\t\t\t\tupdatedFileVersion = true;\n\t\t\t\t}\n\n\t\t\t\tif (latestDLFileVersion.isPending()) {\n\t\t\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t\t\t}\n\n\t\t\t\tupdateFileVersion(\n\t\t\t\t\tuser, latestDLFileVersion, sourceFileName, extension,\n\t\t\t\t\tmimeType, title, description, changeLog, extraSettings,\n\t\t\t\t\tdocumentTypeId, version, size,\n\t\t\t\t\tlatestDLFileVersion.getStatus(),\n\t\t\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (latestDLFileVersion.getSize() == 0) {\n\t\t\t\t\tversion = latestDLFileVersion.getVersion();\n\n\t\t\t\t\tupdateFileVersion(\n\t\t\t\t\t\tuser, latestDLFileVersion, sourceFileName, extension,\n\t\t\t\t\t\tmimeType, title, description, changeLog, extraSettings,\n\t\t\t\t\t\tdocumentTypeId, version, size,\n\t\t\t\t\t\tlatestDLFileVersion.getStatus(),\n\t\t\t\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\t\t\textension, mimeType, title, description, changeLog,\n\t\t\t\t\t\textraSettings, documentTypeId, version, size,\n\t\t\t\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dlFileVersion == null) {\n\t\t\t\tdlFileVersion = latestDLFileVersion;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\textension, mimeType, title, description, changeLog,\n\t\t\t\textraSettings, documentTypeId, version, size,\n\t\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\t\t}\n\n\t\tFile file = null;\n\n\t\tif ((is == null) && !updatedFileVersion) {\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\t\tdlFileEntry.getName());\n\n\t\t\t\t\tfile = FileUtil.createTempFile(\n\t\t\t\t\t\tFileUtil.getExtension(title));\n\n\t\t\t\t\tFileUtil.write(file, is);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tthrow new SystemException(ioe);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder, false);\n\t\t}\n\n\t\t// File\n\n\t\tif ((is != null) || (file != null)) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tversion);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\n\t\t\tif (file != null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = new FileInputStream(file);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tthrow new SystemException(ioe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), dlFileEntry.getExtension(), false,\n\t\t\t\tversion, sourceFileName, dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry.getLuceneProperties(),\n\t\t\t\tdlFileEntry.getModifiedDate(), serviceContext, is);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getGroupId(), userId,\n\t\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry, serviceContext);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":510,"modified_method":"protected DLFileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName, String title,\n\t\t\tString description, String changeLog, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tString extension = (String)serviceContext.getAttribute(\"extension\");\n\n\t\tif (Validator.isNull(extension)) {\n\t\t\textension = dlFileEntry.getExtension();\n\t\t}\n\n\t\tString mimeType = (String)serviceContext.getAttribute(\"contentType\");\n\n\t\tif (Validator.isNull(mimeType)) {\n\t\t\tmimeType = dlFileEntry.getMimeType();\n\t\t}\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = dlFileEntry.getTitle();\n\t\t\t}\n\t\t}\n\n\t\tLong documentTypeId = (Long)serviceContext.getAttribute(\n\t\t\t\"documentTypeId\");\n\n\t\tif (documentTypeId == null) {\n\t\t\tdocumentTypeId = 0L;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFile(\n\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getFolderId(),\n\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getExtension(), title,\n\t\t\tsourceFileName, is);\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\tDLFileVersion dlFileVersion = null;\n\n\t\tboolean updatedFileVersion = false;\n\n\t\ttry {\n\t\t\tDLFileVersion latestDLFileVersion =\n\t\t\t\tdlFileEntry.getLatestFileVersion();\n\n\t\t\tif (size == 0) {\n\t\t\t\tsize = latestDLFileVersion.getSize();\n\t\t\t}\n\n\t\t\tif (!latestDLFileVersion.isApproved()) {\n\t\t\t\tif (!PropsValues.DL_FILE_ENTRY_DRAFTS_ENABLED) {\n\t\t\t\t\tversion = latestDLFileVersion.getVersion();\n\t\t\t\t}\n\n\t\t\t\tif (version.equals(latestDLFileVersion.getVersion())) {\n\t\t\t\t\tupdatedFileVersion = true;\n\t\t\t\t}\n\n\t\t\t\tif (latestDLFileVersion.isPending()) {\n\t\t\t\t\tserviceContext.setWorkflowAction(\n\t\t\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\t\t\t\t}\n\n\t\t\t\tupdateFileVersion(\n\t\t\t\t\tuser, latestDLFileVersion, sourceFileName, extension,\n\t\t\t\t\tmimeType, title, description, changeLog, extraSettings,\n\t\t\t\t\tdocumentTypeId, version, size,\n\t\t\t\t\tlatestDLFileVersion.getStatus(),\n\t\t\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (latestDLFileVersion.getSize() == 0) {\n\t\t\t\t\tversion = latestDLFileVersion.getVersion();\n\n\t\t\t\t\tupdateFileVersion(\n\t\t\t\t\t\tuser, latestDLFileVersion, sourceFileName, extension,\n\t\t\t\t\t\tmimeType, title, description, changeLog, extraSettings,\n\t\t\t\t\t\tdocumentTypeId, version, size,\n\t\t\t\t\t\tlatestDLFileVersion.getStatus(),\n\t\t\t\t\t\tserviceContext.getModifiedDate(now), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\t\t\textension, mimeType, title, description, changeLog,\n\t\t\t\t\t\textraSettings, documentTypeId, version, size,\n\t\t\t\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dlFileVersion == null) {\n\t\t\t\tdlFileVersion = latestDLFileVersion;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\tdlFileVersion = addFileVersion(\n\t\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\textension, mimeType, title, description, changeLog,\n\t\t\t\textraSettings, documentTypeId, version, size,\n\t\t\t\tWorkflowConstants.STATUS_DRAFT, serviceContext);\n\t\t}\n\n\t\tFile file = null;\n\n\t\tif ((is == null) && !updatedFileVersion) {\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\t\tdlFileEntry.getName());\n\n\t\t\t\t\tfile = FileUtil.createTempFile(\n\t\t\t\t\t\tFileUtil.getExtension(title));\n\n\t\t\t\t\tFileUtil.write(file, is);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tthrow new SystemException(ioe);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder, false);\n\t\t}\n\n\t\t// File\n\n\t\tif ((is != null) || (file != null)) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tversion);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\n\t\t\tif (file != null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = new FileInputStream(file);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tthrow new SystemException(ioe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tdlFileEntry.getGroupId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), dlFileEntry.getExtension(), false,\n\t\t\t\tversion, sourceFileName, dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry.getLuceneProperties(),\n\t\t\t\tdlFileEntry.getModifiedDate(), serviceContext, is);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getGroupId(), userId,\n\t\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\t\tdlFileEntry, serviceContext);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"7653508bfb11000df49f45246c5c0fc1a03a8263","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AssetEntry updateAsset(\n\t\t\tlong userId, DLFileEntry dlFileEntry, DLFileVersion dlFileVersion,\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean addDraftAssetEntry = false;\n\n\t\tif ((dlFileVersion != null) && !dlFileVersion.isApproved()) {\n\t\t\tString version = dlFileVersion.getVersion();\n\n\t\t\tif (!version.equals(DLFileEntryConstants.DEFAULT_VERSION)) {\n\t\t\t\tint approvedArticlesCount = dlFileVersionPersistence.countByF_S(\n\t\t\t\t\tdlFileEntry.getFileEntryId(),\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tif (approvedArticlesCount > 0) {\n\t\t\t\t\taddDraftAssetEntry = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean visible = true;\n\n\t\tif ((dlFileVersion != null) && !dlFileVersion.isApproved()) {\n\t\t\tvisible = false;\n\t\t}\n\n\t\treturn dlAppHelperLocalService.updateAsset(\n\t\t\tuserId, new LiferayFileEntry(dlFileEntry),\n\t\t\tnew LiferayFileVersion(dlFileVersion), assetCategoryIds,\n\t\t\tassetTagNames, dlFileEntry.getMimeType(), addDraftAssetEntry,\n\t\t\tvisible);\n\t}","id":511,"modified_method":"public AssetEntry updateAsset(\n\t\t\tlong userId, DLFileEntry dlFileEntry, DLFileVersion dlFileVersion,\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn updateAsset(\n\t\t\tuserId, dlFileEntry, dlFileVersion, assetCategoryIds, assetTagNames,\n\t\t\tnull);\n\t}","commit_id":"7653508bfb11000df49f45246c5c0fc1a03a8263","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateAssets() throws Exception {\n\t\tList<DLFileEntry> fileEntries =\n\t\t\tDLFileEntryLocalServiceUtil.getNoAssetFileEntries();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + fileEntries.size() +\n\t\t\t\t\t\" file entries with no asset\");\n\t\t}\n\n\t\tfor (DLFileEntry fileEntry : fileEntries) {\n\t\t\ttry {\n\t\t\t\tDLFileEntryLocalServiceUtil.updateAsset(\n\t\t\t\t\tfileEntry.getUserId(), fileEntry, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for file entries\");\n\t\t}\n\t}","id":512,"modified_method":"protected void updateAssets() throws Exception {\n\t\tList<DLFileEntry> fileEntries =\n\t\t\tDLFileEntryLocalServiceUtil.getNoAssetFileEntries();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + fileEntries.size() +\n\t\t\t\t\t\" file entries with no asset\");\n\t\t}\n\n\t\tfor (DLFileEntry fileEntry : fileEntries) {\n\t\t\ttry {\n\t\t\t\tDLFileEntryLocalServiceUtil.updateAsset(\n\t\t\t\t\tfileEntry.getUserId(), fileEntry, null, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for file entries\");\n\t\t}\n\t}","commit_id":"7653508bfb11000df49f45246c5c0fc1a03a8263","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, CalendarBooking calendarBooking,\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong assetGroupId = calendarBooking.getGroupId();\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarBooking.getCalendarResource();\n\n\t\tif (calendarResource.getClassNameId() ==\n\t\t\t\tPortalUtil.getClassNameId(Group.class)) {\n\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcalendarResource.getClassPK());\n\n\t\t\tassetGroupId = group.getGroupId();\n\t\t}\n\n\t\tboolean visible = false;\n\n\t\tif (calendarBooking.isApproved()) {\n\t\t\tvisible = true;\n\t\t}\n\n\t\tString summary = HtmlUtil.extractText(\n\t\t\tStringUtil.shorten(calendarBooking.getDescription(), 500));\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, assetGroupId, calendarBooking.getCreateDate(),\n\t\t\tcalendarBooking.getModifiedDate(), CalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(), calendarBooking.getUuid(), 0,\n\t\t\tassetCategoryIds, assetTagNames, visible, null, null, null,\n\t\t\tContentTypes.TEXT_HTML, calendarBooking.getTitle(),\n\t\t\tcalendarBooking.getDescription(), summary, null, null, 0, 0, null,\n\t\t\tfalse);\n\t}","id":513,"modified_method":"public void updateAsset(\n\t\t\tlong userId, CalendarBooking calendarBooking,\n\t\t\tlong[] assetCategoryIds, String[] assetTagNames,\n\t\t\tlong[] assetLinkEntryIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong assetGroupId = calendarBooking.getGroupId();\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarBooking.getCalendarResource();\n\n\t\tlong classNameId = calendarResource.getClassNameId();\n\t\tlong groupClassNameId = PortalUtil.getClassNameId(Group.class);\n\n\t\tif (classNameId == groupClassNameId) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcalendarResource.getClassPK());\n\n\t\t\tassetGroupId = group.getGroupId();\n\t\t}\n\n\t\tboolean visible = false;\n\n\t\tif (calendarBooking.isApproved()) {\n\t\t\tvisible = true;\n\t\t}\n\n\t\tString summary = HtmlUtil.extractText(\n\t\t\tStringUtil.shorten(calendarBooking.getDescription(), 500));\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, assetGroupId, calendarBooking.getCreateDate(),\n\t\t\tcalendarBooking.getModifiedDate(), CalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(), calendarBooking.getUuid(),\n\t\t\t0, assetCategoryIds, assetTagNames, visible, null, null, null,\n\t\t\tContentTypes.TEXT_HTML, calendarBooking.getTitle(),\n\t\t\tcalendarBooking.getDescription(), summary, null, null, 0, 0, null,\n\t\t\tfalse);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"7ab2cd307bf5b0600934be67287641b60821ab52","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarBooking updateCalendarBooking(\n\t\t\tlong userId, long calendarBookingId, long calendarId,\n\t\t\tlong[] childCalendarIds, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendarBooking calendarBooking =\n\t\t\tcalendarBookingPersistence.findByPrimaryKey(calendarBookingId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\t\tcalendarBooking.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.invokeTransition(\n\t\t\tuserId, calendarBookingId,\n\t\t\tCalendarBookingWorkflowConstants.toLabel(status), serviceContext);\n\n\t\treturn calendarBooking;\n\t}","id":514,"modified_method":"public CalendarBooking updateCalendarBooking(\n\t\t\tlong userId, long calendarBookingId, long calendarId,\n\t\t\tlong[] childCalendarIds, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendarBooking calendarBooking =\n\t\t\tcalendarBookingPersistence.findByPrimaryKey(calendarBookingId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.invokeTransition(\n\t\t\tuserId, calendarBookingId,\n\t\t\tCalendarBookingWorkflowConstants.toLabel(status), serviceContext);\n\n\t\t// Asset\n\n\t\tcalendarBooking = fetchCalendarBooking(calendarBookingId);\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\treturn calendarBooking;\n\t}","commit_id":"7ab2cd307bf5b0600934be67287641b60821ab52","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarBooking addCalendarBooking(\n\t\t\tlong userId, long calendarId, long[] childCalendarIds,\n\t\t\tlong parentCalendarBookingId, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tlong calendarBookingId = counterLocalService.increment();\n\n\t\tCalendarBooking calendarBooking = calendarBookingPersistence.create(\n\t\t\tcalendarBookingId);\n\n\t\tcalendarBooking.setUuid(serviceContext.getUuid());\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setCalendarResourceId(calendar.getCalendarResourceId());\n\n\t\tif (parentCalendarBookingId > 0) {\n\t\t\tcalendarBooking.setParentCalendarBookingId(parentCalendarBookingId);\n\t\t}\n\t\telse {\n\t\t\tcalendarBooking.setParentCalendarBookingId(calendarBookingId);\n\t\t}\n\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\t\tcalendarBooking.setExpandoBridgeAttributes(serviceContext);\n\n\t\tint status = CalendarBookingWorkflowConstants.STATUS_PENDING;\n\n\t\tif (parentCalendarBookingId == 0) {\n\t\t\tstatus = CalendarBookingWorkflowConstants.STATUS_APPROVED;\n\t\t}\n\n\t\tcalendarBooking.setStatus(status);\n\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.startWorkflow(\n\t\t\tuserId, calendarBookingId, serviceContext);\n\n\t\treturn calendarBooking;\n\t}","id":515,"modified_method":"public CalendarBooking addCalendarBooking(\n\t\t\tlong userId, long calendarId, long[] childCalendarIds,\n\t\t\tlong parentCalendarBookingId, Map<Locale, String> titleMap,\n\t\t\tMap<Locale, String> descriptionMap, String location, long startDate,\n\t\t\tlong endDate, boolean allDay, String recurrence, long firstReminder,\n\t\t\tString firstReminderType, long secondReminder,\n\t\t\tString secondReminderType, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tCalendar calendar = calendarPersistence.findByPrimaryKey(calendarId);\n\n\t\tjava.util.Calendar startDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tstartDate);\n\t\tjava.util.Calendar endDateJCalendar = JCalendarUtil.getJCalendar(\n\t\t\tendDate);\n\n\t\tif (allDay) {\n\t\t\tstartDateJCalendar = JCalendarUtil.toMidnightJCalendar(\n\t\t\t\tstartDateJCalendar);\n\t\t\tendDateJCalendar = JCalendarUtil.toLastHourJCalendar(\n\t\t\t\tendDateJCalendar);\n\t\t}\n\n\t\tif (firstReminder < secondReminder) {\n\t\t\tlong originalSecondReminder = secondReminder;\n\n\t\t\tsecondReminder = firstReminder;\n\t\t\tfirstReminder = originalSecondReminder;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(titleMap, startDateJCalendar, endDateJCalendar);\n\n\t\tlong calendarBookingId = counterLocalService.increment();\n\n\t\tCalendarBooking calendarBooking = calendarBookingPersistence.create(\n\t\t\tcalendarBookingId);\n\n\t\tcalendarBooking.setUuid(serviceContext.getUuid());\n\t\tcalendarBooking.setGroupId(calendar.getGroupId());\n\t\tcalendarBooking.setCompanyId(user.getCompanyId());\n\t\tcalendarBooking.setUserId(user.getUserId());\n\t\tcalendarBooking.setUserName(user.getFullName());\n\t\tcalendarBooking.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setCalendarId(calendarId);\n\t\tcalendarBooking.setCalendarResourceId(calendar.getCalendarResourceId());\n\n\t\tif (parentCalendarBookingId > 0) {\n\t\t\tcalendarBooking.setParentCalendarBookingId(parentCalendarBookingId);\n\t\t}\n\t\telse {\n\t\t\tcalendarBooking.setParentCalendarBookingId(calendarBookingId);\n\t\t}\n\n\t\tcalendarBooking.setTitleMap(titleMap);\n\t\tcalendarBooking.setDescriptionMap(descriptionMap);\n\t\tcalendarBooking.setLocation(location);\n\t\tcalendarBooking.setStartDate(startDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setEndDate(endDateJCalendar.getTimeInMillis());\n\t\tcalendarBooking.setAllDay(allDay);\n\t\tcalendarBooking.setRecurrence(recurrence);\n\t\tcalendarBooking.setFirstReminder(firstReminder);\n\t\tcalendarBooking.setFirstReminderType(firstReminderType);\n\t\tcalendarBooking.setSecondReminder(secondReminder);\n\t\tcalendarBooking.setSecondReminderType(secondReminderType);\n\n\t\tint status = CalendarBookingWorkflowConstants.STATUS_PENDING;\n\n\t\tif (parentCalendarBookingId == 0) {\n\t\t\tstatus = CalendarBookingWorkflowConstants.STATUS_APPROVED;\n\t\t}\n\n\t\tcalendarBooking.setStatus(status);\n\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\taddChildCalendarBookings(\n\t\t\tcalendarBooking, childCalendarIds, serviceContext);\n\n\t\t// Workflow\n\n\t\tcalendarBookingApprovalWorkflow.startWorkflow(\n\t\t\tuserId, calendarBookingId, serviceContext);\n\n\t\t// Asset\n\n\t\tcalendarBooking = fetchCalendarBooking(calendarBookingId);\n\n\t\tupdateAsset(\n\t\t\tuserId, calendarBooking, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\treturn calendarBooking;\n\t}","commit_id":"7ab2cd307bf5b0600934be67287641b60821ab52","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doVerify() throws Exception {\n\t\tList<WikiPage> pages = WikiPageLocalServiceUtil.getNoAssetPages();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Processing \" + pages.size() + \" pages with no asset\");\n\t\t}\n\n\t\tfor (WikiPage page : pages) {\n\t\t\ttry {\n\t\t\t\tWikiPageLocalServiceUtil.updateAsset(\n\t\t\t\t\tpage.getUserId(), page, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for page \" + page.getPageId() +\n\t\t\t\t\t\t\t\": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for pages\");\n\t\t}\n\t}","id":516,"modified_method":"protected void doVerify() throws Exception {\n\t\tList<WikiPage> pages = WikiPageLocalServiceUtil.getNoAssetPages();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Processing \" + pages.size() + \" pages with no asset\");\n\t\t}\n\n\t\tfor (WikiPage page : pages) {\n\t\t\ttry {\n\t\t\t\tWikiPageLocalServiceUtil.updateAsset(\n\t\t\t\t\tpage.getUserId(), page, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for page \" + page.getPageId() +\n\t\t\t\t\t\t\t\": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for pages\");\n\t\t}\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WikiPage updateStatus(\n\t\t\tlong userId, WikiPage page, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(page.getNodeId());\n\n\t\tDate now = new Date();\n\n\t\tint oldStatus = page.getStatus();\n\n\t\tpage.setStatus(status);\n\t\tpage.setStatusByUserId(userId);\n\t\tpage.setStatusByUserName(user.getFullName());\n\t\tpage.setStatusDate(now);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t(page.getVersion() != WikiPageConstants.DEFAULT_VERSION)) {\n\n\t\t\t\ttry {\n\t\t\t\t\tAssetEntry draftAssetEntry =\n\t\t\t\t\t\tassetEntryLocalService.getEntry(\n\t\t\t\t\t\t\tWikiPage.class.getName(), page.getPrimaryKey());\n\n\t\t\t\t\tlong[] assetCategoryIds = draftAssetEntry.getCategoryIds();\n\t\t\t\t\tString[] assetTagNames = draftAssetEntry.getTagNames();\n\n\t\t\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\t\t\tpage.getResourcePrimKey(), page.getUuid(),\n\t\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null, null,\n\t\t\t\t\t\tnull, ContentTypes.TEXT_HTML, page.getTitle(), null,\n\t\t\t\t\t\tnull, null, null, 0, 0, null, false);\n\n\t\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\t\tdraftAssetEntry.getEntryId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(), true);\n\n\t\t\t// Social\n\n\t\t\tint activity = WikiActivityKeys.ADD_PAGE;\n\t\t\tString actionId = ActionKeys.ADD_PAGE;\n\n\t\t\tif (page.getVersion() > 1.1) {\n\t\t\t\tactivity = WikiActivityKeys.UPDATE_PAGE;\n\t\t\t\tactionId = ActionKeys.UPDATE;\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getResourcePrimKey(), activity, StringPool.BLANK, 0);\n\n\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\tuserId, WikiPage.class.getName(), page.getResourcePrimKey(),\n\t\t\t\tactionId, StringPool.BLANK);\n\n\t\t\t// Subscriptions\n\n\t\t\tif (!page.isMinorEdit() && NotificationThreadLocal.isEnabled()) {\n\t\t\t\tboolean update = false;\n\n\t\t\t\tif (page.getVersion() > 1.1) {\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\n\t\t\t\tnotifySubscribers(node, page, serviceContext, update);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(WikiPage.class);\n\n\t\t\tindexer.reindex(page);\n\n\t\t\t// Cache\n\n\t\t\tclearPageCache(page);\n\n\t\t\t// Head\n\n\t\t\tpage.setHead(true);\n\n\t\t\tList<WikiPage> pages = wikiPagePersistence.findByN_T_H(\n\t\t\t\tpage.getNodeId(), page.getTitle(), true);\n\n\t\t\tfor (WikiPage curPage : pages) {\n\t\t\t\tif (!curPage.equals(page)) {\n\t\t\t\t\tcurPage.setHead(false);\n\n\t\t\t\t\twikiPagePersistence.update(curPage, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Head\n\n\t\t\tpage.setHead(false);\n\n\t\t\tList<WikiPage> pages = wikiPagePersistence.findByN_T_S(\n\t\t\t\tpage.getNodeId(), page.getTitle(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tfor (WikiPage curPage : pages) {\n\t\t\t\tif (!curPage.equals(page)) {\n\t\t\t\t\tcurPage.setHead(true);\n\n\t\t\t\t\twikiPagePersistence.update(curPage, false);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn wikiPagePersistence.update(page, false);\n\t}","id":517,"modified_method":"public WikiPage updateStatus(\n\t\t\tlong userId, WikiPage page, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(page.getNodeId());\n\n\t\tDate now = new Date();\n\n\t\tint oldStatus = page.getStatus();\n\n\t\tpage.setStatus(status);\n\t\tpage.setStatusByUserId(userId);\n\t\tpage.setStatusByUserName(user.getFullName());\n\t\tpage.setStatusDate(now);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t// Asset\n\n\t\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t(page.getVersion() != WikiPageConstants.DEFAULT_VERSION)) {\n\n\t\t\t\ttry {\n\t\t\t\t\tAssetEntry draftAssetEntry =\n\t\t\t\t\t\tassetEntryLocalService.getEntry(\n\t\t\t\t\t\t\tWikiPage.class.getName(), page.getPrimaryKey());\n\n\t\t\t\t\tlong[] assetCategoryIds = draftAssetEntry.getCategoryIds();\n\t\t\t\t\tString[] assetTagNames = draftAssetEntry.getTagNames();\n\n\t\t\t\t\tList<AssetLink> assetLinks =\n\t\t\t\t\t\tassetLinkLocalService.getDirectLinks(\n\t\t\t\t\t\t\tdraftAssetEntry.getEntryId(),\n\t\t\t\t\t\t\tAssetLinkConstants.TYPE_RELATED);\n\n\t\t\t\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\t\t\t\tListUtil.toString(assetLinks, \"entryId2\"), 0L);\n\n\t\t\t\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\t\t\tpage.getResourcePrimKey(), page.getUuid(),\n\t\t\t\t\t\tassetCategoryIds, assetTagNames, true, null, null, null,\n\t\t\t\t\t\tnull, ContentTypes.TEXT_HTML, page.getTitle(), null,\n\t\t\t\t\t\tnull, null, null, 0, 0, null, false);\n\n\t\t\t\t\t// Asset Links\n\n\t\t\t\t\tassetLinkLocalService.updateLinks(\n\t\t\t\t\t\tuserId, assetEntry.getEntryId(),\n\t\t\t\t\t\tassetLinkEntryIds, AssetLinkConstants.TYPE_RELATED);\n\n\t\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\t\tdraftAssetEntry.getEntryId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(), true);\n\n\t\t\t// Social\n\n\t\t\tint activity = WikiActivityKeys.ADD_PAGE;\n\t\t\tString actionId = ActionKeys.ADD_PAGE;\n\n\t\t\tif (page.getVersion() > 1.1) {\n\t\t\t\tactivity = WikiActivityKeys.UPDATE_PAGE;\n\t\t\t\tactionId = ActionKeys.UPDATE;\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getResourcePrimKey(), activity, StringPool.BLANK, 0);\n\n\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\tuserId, WikiPage.class.getName(), page.getResourcePrimKey(),\n\t\t\t\tactionId, StringPool.BLANK);\n\n\t\t\t// Subscriptions\n\n\t\t\tif (!page.isMinorEdit() && NotificationThreadLocal.isEnabled()) {\n\t\t\t\tboolean update = false;\n\n\t\t\t\tif (page.getVersion() > 1.1) {\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\n\t\t\t\tnotifySubscribers(node, page, serviceContext, update);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(WikiPage.class);\n\n\t\t\tindexer.reindex(page);\n\n\t\t\t// Cache\n\n\t\t\tclearPageCache(page);\n\n\t\t\t// Head\n\n\t\t\tpage.setHead(true);\n\n\t\t\tList<WikiPage> pages = wikiPagePersistence.findByN_T_H(\n\t\t\t\tpage.getNodeId(), page.getTitle(), true);\n\n\t\t\tfor (WikiPage curPage : pages) {\n\t\t\t\tif (!curPage.equals(page)) {\n\t\t\t\t\tcurPage.setHead(false);\n\n\t\t\t\t\twikiPagePersistence.update(curPage, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Head\n\n\t\t\tpage.setHead(false);\n\n\t\t\tList<WikiPage> pages = wikiPagePersistence.findByN_T_S(\n\t\t\t\tpage.getNodeId(), page.getTitle(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tfor (WikiPage curPage : pages) {\n\t\t\t\tif (!curPage.equals(page)) {\n\t\t\t\t\tcurPage.setHead(true);\n\n\t\t\t\t\twikiPagePersistence.update(curPage, false);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn wikiPagePersistence.update(page, false);\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, WikiPage page, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean addDraftAssetEntry = false;\n\n\t\tif (!page.isApproved() &&\n\t\t\t(page.getVersion() != WikiPageConstants.DEFAULT_VERSION)) {\n\n\t\t\tint approvedPagesCount = wikiPagePersistence.countByN_T_S(\n\t\t\t\tpage.getNodeId(), page.getTitle(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif (approvedPagesCount > 0) {\n\t\t\t\taddDraftAssetEntry = true;\n\t\t\t}\n\t\t}\n\n\t\tif (addDraftAssetEntry) {\n\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getPrimaryKey(), page.getUuid(), assetCategoryIds,\n\t\t\t\tassetTagNames, false, null, null, null, null,\n\t\t\t\tContentTypes.TEXT_HTML, page.getTitle(), null, null, null, null,\n\t\t\t\t0, 0, null, false);\n\t\t}\n\t\telse {\n\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getResourcePrimKey(), page.getUuid(), assetCategoryIds,\n\t\t\t\tassetTagNames, page.isApproved(), null, null, null, null,\n\t\t\t\tContentTypes.TEXT_HTML, page.getTitle(), null, null, null, null,\n\t\t\t\t0, 0, null, false);\n\t\t}\n\t}","id":518,"modified_method":"public void updateAsset(\n\t\t\tlong userId, WikiPage page, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean addDraftAssetEntry = false;\n\n\t\tif (!page.isApproved() &&\n\t\t\t(page.getVersion() != WikiPageConstants.DEFAULT_VERSION)) {\n\n\t\t\tint approvedPagesCount = wikiPagePersistence.countByN_T_S(\n\t\t\t\tpage.getNodeId(), page.getTitle(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif (approvedPagesCount > 0) {\n\t\t\t\taddDraftAssetEntry = true;\n\t\t\t}\n\t\t}\n\n\t\tAssetEntry assetEntry = null;\n\n\t\tif (addDraftAssetEntry) {\n\t\t\tassetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getPrimaryKey(), page.getUuid(), assetCategoryIds,\n\t\t\t\tassetTagNames, false, null, null, null, null,\n\t\t\t\tContentTypes.TEXT_HTML, page.getTitle(), null, null, null, null,\n\t\t\t\t0, 0, null, false);\n\t\t}\n\t\telse {\n\t\t\tassetEntry = assetEntryLocalService.updateEntry(\n\t\t\t\tuserId, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getResourcePrimKey(), page.getUuid(), assetCategoryIds,\n\t\t\t\tassetTagNames, page.isApproved(), null, null, null, null,\n\t\t\t\tContentTypes.TEXT_HTML, page.getTitle(), null, null, null, null,\n\t\t\t\t0, 0, null, false);\n\t\t}\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WikiPage addPage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tString content, String summary, boolean minorEdit, String format,\n\t\t\tboolean head, String parentTitle, String redirectTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Page\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(nodeId);\n\n\t\tDate now = new Date();\n\n\t\tvalidate(title, nodeId, content, format);\n\n\t\tlong pageId = counterLocalService.increment();\n\n\t\tlong resourcePrimKey =\n\t\t\twikiPageResourceLocalService.getPageResourcePrimKey(nodeId, title);\n\n\t\tWikiPage page = wikiPagePersistence.create(pageId);\n\n\t\tpage.setUuid(serviceContext.getUuid());\n\t\tpage.setResourcePrimKey(resourcePrimKey);\n\t\tpage.setGroupId(node.getGroupId());\n\t\tpage.setCompanyId(user.getCompanyId());\n\t\tpage.setUserId(user.getUserId());\n\t\tpage.setUserName(user.getFullName());\n\t\tpage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tpage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tpage.setNodeId(nodeId);\n\t\tpage.setTitle(title);\n\t\tpage.setVersion(version);\n\t\tpage.setMinorEdit(minorEdit);\n\t\tpage.setContent(content);\n\t\tpage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tpage.setSummary(summary);\n\t\tpage.setFormat(format);\n\t\tpage.setHead(head);\n\t\tpage.setParentTitle(parentTitle);\n\t\tpage.setRedirectTitle(redirectTitle);\n\n\t\twikiPagePersistence.update(page, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddPageResources(\n\t\t\t\tpage, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddPageResources(\n\t\t\t\tpage, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Node\n\n\t\tnode.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\twikiNodePersistence.update(node, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, page, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = page.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Message boards\n\n\t\tif (PropsValues.WIKI_PAGE_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, page.getUserName(), page.getGroupId(),\n\t\t\t\tWikiPage.class.getName(), resourcePrimKey,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), page.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(), page,\n\t\t\tserviceContext);\n\n\t\treturn page;\n\t}","id":519,"modified_method":"public WikiPage addPage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tString content, String summary, boolean minorEdit, String format,\n\t\t\tboolean head, String parentTitle, String redirectTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Page\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(nodeId);\n\n\t\tDate now = new Date();\n\n\t\tvalidate(title, nodeId, content, format);\n\n\t\tlong pageId = counterLocalService.increment();\n\n\t\tlong resourcePrimKey =\n\t\t\twikiPageResourceLocalService.getPageResourcePrimKey(nodeId, title);\n\n\t\tWikiPage page = wikiPagePersistence.create(pageId);\n\n\t\tpage.setUuid(serviceContext.getUuid());\n\t\tpage.setResourcePrimKey(resourcePrimKey);\n\t\tpage.setGroupId(node.getGroupId());\n\t\tpage.setCompanyId(user.getCompanyId());\n\t\tpage.setUserId(user.getUserId());\n\t\tpage.setUserName(user.getFullName());\n\t\tpage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tpage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tpage.setNodeId(nodeId);\n\t\tpage.setTitle(title);\n\t\tpage.setVersion(version);\n\t\tpage.setMinorEdit(minorEdit);\n\t\tpage.setContent(content);\n\t\tpage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tpage.setSummary(summary);\n\t\tpage.setFormat(format);\n\t\tpage.setHead(head);\n\t\tpage.setParentTitle(parentTitle);\n\t\tpage.setRedirectTitle(redirectTitle);\n\n\t\twikiPagePersistence.update(page, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddPageResources(\n\t\t\t\tpage, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddPageResources(\n\t\t\t\tpage, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Node\n\n\t\tnode.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\twikiNodePersistence.update(node, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, page, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = page.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Message boards\n\n\t\tif (PropsValues.WIKI_PAGE_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, page.getUserName(), page.getGroupId(),\n\t\t\t\tWikiPage.class.getName(), resourcePrimKey,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), page.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(), page,\n\t\t\tserviceContext);\n\n\t\treturn page;\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void movePage(\n\t\t\tlong userId, long nodeId, String title, String newTitle,\n\t\t\tboolean strict, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidateTitle(newTitle);\n\n\t\t// Check if the new title already exists\n\n\t\tif (title.equalsIgnoreCase(newTitle)) {\n\t\t\tthrow new DuplicatePageException(newTitle);\n\t\t}\n\n\t\tif (isUsedTitle(nodeId, newTitle)) {\n\t\t\tWikiPage page = getPage(nodeId, newTitle);\n\n\t\t\t// Support moving back to a previously moved title\n\n\t\t\tif (((page.getVersion() == WikiPageConstants.DEFAULT_VERSION) &&\n\t\t\t\t (page.getContent().length() < 200)) ||\n\t\t\t\t!strict) {\n\n\t\t\t\tdeletePage(nodeId, newTitle);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new DuplicatePageException(newTitle);\n\t\t\t}\n\t\t}\n\n\t\t// All versions\n\n\t\tList<WikiPage> pageVersions = wikiPagePersistence.findByN_T(\n\t\t\tnodeId, title);\n\n\t\tif (pageVersions.size() == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (WikiPage page : pageVersions) {\n\t\t\tpage.setTitle(newTitle);\n\n\t\t\twikiPagePersistence.update(page, false);\n\t\t}\n\n\t\t// Children\n\n\t\tList<WikiPage> children = wikiPagePersistence.findByN_P(nodeId, title);\n\n\t\tfor (WikiPage page : children) {\n\t\t\tpage.setParentTitle(newTitle);\n\n\t\t\twikiPagePersistence.update(page, false);\n\t\t}\n\n\t\tWikiPage page = pageVersions.get(pageVersions.size() - 1);\n\n\t\tlong resourcePrimKey = page.getResourcePrimKey();\n\n\t\t// Page resource\n\n\t\tWikiPageResource wikiPageResource =\n\t\t\twikiPageResourcePersistence.findByPrimaryKey(resourcePrimKey);\n\n\t\twikiPageResource.setTitle(newTitle);\n\n\t\twikiPageResourcePersistence.update(wikiPageResource, false);\n\n\t\t// Create stub page at the old location\n\n\t\tdouble version = WikiPageConstants.DEFAULT_VERSION;\n\t\tString summary = WikiPageConstants.MOVED + \" to \" + title;\n\t\tString format = page.getFormat();\n\t\tboolean head = true;\n\t\tString parentTitle = page.getParentTitle();\n\t\tString redirectTitle = page.getTitle();\n\t\tString content =\n\t\t\tStringPool.DOUBLE_OPEN_BRACKET + redirectTitle +\n\t\t\t\tStringPool.DOUBLE_CLOSE_BRACKET;\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\taddPage(\n\t\t\tuserId, nodeId, title, version, content, summary, false, format,\n\t\t\thead, parentTitle, redirectTitle, serviceContext);\n\n\t\t// Move redirects to point to the page with the new title\n\n\t\tList<WikiPage> redirectedPages = wikiPagePersistence.findByN_R(\n\t\t\tnodeId, title);\n\n\t\tfor (WikiPage redirectedPage : redirectedPages) {\n\t\t\tredirectedPage.setRedirectTitle(newTitle);\n\n\t\t\twikiPagePersistence.update(redirectedPage, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(userId, page, null, null);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(WikiPage.class);\n\n\t\tindexer.delete(\n\t\t\tnew Object[] {page.getCompanyId(), page.getNodeId(), title});\n\n\t\tindexer.reindex(page);\n\t}","id":520,"modified_method":"public void movePage(\n\t\t\tlong userId, long nodeId, String title, String newTitle,\n\t\t\tboolean strict, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidateTitle(newTitle);\n\n\t\t// Check if the new title already exists\n\n\t\tif (title.equalsIgnoreCase(newTitle)) {\n\t\t\tthrow new DuplicatePageException(newTitle);\n\t\t}\n\n\t\tif (isUsedTitle(nodeId, newTitle)) {\n\t\t\tWikiPage page = getPage(nodeId, newTitle);\n\n\t\t\t// Support moving back to a previously moved title\n\n\t\t\tif (((page.getVersion() == WikiPageConstants.DEFAULT_VERSION) &&\n\t\t\t\t (page.getContent().length() < 200)) ||\n\t\t\t\t!strict) {\n\n\t\t\t\tdeletePage(nodeId, newTitle);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new DuplicatePageException(newTitle);\n\t\t\t}\n\t\t}\n\n\t\t// All versions\n\n\t\tList<WikiPage> pageVersions = wikiPagePersistence.findByN_T(\n\t\t\tnodeId, title);\n\n\t\tif (pageVersions.size() == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (WikiPage page : pageVersions) {\n\t\t\tpage.setTitle(newTitle);\n\n\t\t\twikiPagePersistence.update(page, false);\n\t\t}\n\n\t\t// Children\n\n\t\tList<WikiPage> children = wikiPagePersistence.findByN_P(nodeId, title);\n\n\t\tfor (WikiPage page : children) {\n\t\t\tpage.setParentTitle(newTitle);\n\n\t\t\twikiPagePersistence.update(page, false);\n\t\t}\n\n\t\tWikiPage page = pageVersions.get(pageVersions.size() - 1);\n\n\t\tlong resourcePrimKey = page.getResourcePrimKey();\n\n\t\t// Page resource\n\n\t\tWikiPageResource wikiPageResource =\n\t\t\twikiPageResourcePersistence.findByPrimaryKey(resourcePrimKey);\n\n\t\twikiPageResource.setTitle(newTitle);\n\n\t\twikiPageResourcePersistence.update(wikiPageResource, false);\n\n\t\t// Create stub page at the old location\n\n\t\tdouble version = WikiPageConstants.DEFAULT_VERSION;\n\t\tString summary = WikiPageConstants.MOVED + \" to \" + title;\n\t\tString format = page.getFormat();\n\t\tboolean head = true;\n\t\tString parentTitle = page.getParentTitle();\n\t\tString redirectTitle = page.getTitle();\n\t\tString content =\n\t\t\tStringPool.DOUBLE_OPEN_BRACKET + redirectTitle +\n\t\t\t\tStringPool.DOUBLE_CLOSE_BRACKET;\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tAssetEntry assetEntry =\n\t\t\tassetEntryLocalService.getEntry(\n\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\n\t\tList<AssetLink> assetLinks =\n\t\t\tassetLinkLocalService.getDirectLinks(\n\t\t\t\tassetEntry.getEntryId(), AssetLinkConstants.TYPE_RELATED);\n\n\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\tListUtil.toString(assetLinks, \"entryId2\"), 0L);\n\n\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\n\t\taddPage(\n\t\t\tuserId, nodeId, title, version, content, summary, false, format,\n\t\t\thead, parentTitle, redirectTitle, serviceContext);\n\n\t\t// Move redirects to point to the page with the new title\n\n\t\tList<WikiPage> redirectedPages = wikiPagePersistence.findByN_R(\n\t\t\tnodeId, title);\n\n\t\tfor (WikiPage redirectedPage : redirectedPages) {\n\t\t\tredirectedPage.setRedirectTitle(newTitle);\n\n\t\t\twikiPagePersistence.update(redirectedPage, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(userId, page, null, null, null);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(WikiPage.class);\n\n\t\tindexer.delete(\n\t\t\tnew Object[] {page.getCompanyId(), page.getNodeId(), title});\n\n\t\tindexer.reindex(page);\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void changeParent(\n\t\t\tlong userId, long nodeId, String title, String newParentTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNotNull(newParentTitle)) {\n\t\t\tWikiPage parentPage = getPage(nodeId, newParentTitle);\n\n\t\t\tif (Validator.isNotNull(parentPage.getRedirectTitle())) {\n\t\t\t\tnewParentTitle = parentPage.getRedirectTitle();\n\t\t\t}\n\t\t}\n\n\t\tWikiPage page = getPage(nodeId, title);\n\n\t\tString originalParentTitle = page.getParentTitle();\n\n\t\tdouble version = page.getVersion();\n\t\tString content = page.getContent();\n\t\tString summary = LanguageUtil.format(\n\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\"changed-parent-from-x\", originalParentTitle);\n\t\tboolean minorEdit = false;\n\t\tString format = page.getFormat();\n\t\tString redirectTitle = page.getRedirectTitle();\n\n\t\tlong[] assetCategoryIds = assetCategoryLocalService.getCategoryIds(\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\t\tString[] assetTagNames = assetTagLocalService.getTagNames(\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\n\t\tupdatePage(\n\t\t\tuserId, nodeId, title, version, content, summary, minorEdit,\n\t\t\tformat, newParentTitle, redirectTitle, serviceContext);\n\n\t\tList<WikiPage> oldPages = wikiPagePersistence.findByN_T_H(\n\t\t\tnodeId, title, false);\n\n\t\tfor (WikiPage oldPage : oldPages) {\n\t\t\toldPage.setParentTitle(originalParentTitle);\n\n\t\t\twikiPagePersistence.update(oldPage, false);\n\t\t}\n\t}","id":521,"modified_method":"public void changeParent(\n\t\t\tlong userId, long nodeId, String title, String newParentTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNotNull(newParentTitle)) {\n\t\t\tWikiPage parentPage = getPage(nodeId, newParentTitle);\n\n\t\t\tif (Validator.isNotNull(parentPage.getRedirectTitle())) {\n\t\t\t\tnewParentTitle = parentPage.getRedirectTitle();\n\t\t\t}\n\t\t}\n\n\t\tWikiPage page = getPage(nodeId, title);\n\n\t\tString originalParentTitle = page.getParentTitle();\n\n\t\tdouble version = page.getVersion();\n\t\tString content = page.getContent();\n\t\tString summary = LanguageUtil.format(\n\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\"changed-parent-from-x\", originalParentTitle);\n\t\tboolean minorEdit = false;\n\t\tString format = page.getFormat();\n\t\tString redirectTitle = page.getRedirectTitle();\n\n\t\tlong[] assetCategoryIds = assetCategoryLocalService.getCategoryIds(\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\t\tString[] assetTagNames = assetTagLocalService.getTagNames(\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey());\n\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setAssetLinkEntryIds(null);\n\n\t\tupdatePage(\n\t\t\tuserId, nodeId, title, version, content, summary, minorEdit,\n\t\t\tformat, newParentTitle, redirectTitle, serviceContext);\n\n\t\tList<WikiPage> oldPages = wikiPagePersistence.findByN_T_H(\n\t\t\tnodeId, title, false);\n\n\t\tfor (WikiPage oldPage : oldPages) {\n\t\t\toldPage.setParentTitle(originalParentTitle);\n\n\t\t\twikiPagePersistence.update(oldPage, false);\n\t\t}\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public WikiPage updatePage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tString content, String summary, boolean minorEdit, String format,\n\t\t\tString parentTitle, String redirectTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Page\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tvalidate(nodeId, content, format);\n\n\t\tWikiPage oldPage = null;\n\n\t\ttry {\n\t\t\toldPage = wikiPagePersistence.findByN_T_First(nodeId, title, null);\n\t\t}\n\t\tcatch (NoSuchPageException nspe) {\n\t\t\treturn addPage(\n\t\t\t\tuserId, nodeId, title, WikiPageConstants.DEFAULT_VERSION,\n\t\t\t\tcontent, summary, minorEdit, format, true, parentTitle,\n\t\t\t\tredirectTitle, serviceContext);\n\t\t}\n\n\t\tdouble oldVersion = oldPage.getVersion();\n\n\t\tif ((version > 0) && (version != oldVersion)) {\n\t\t\tthrow new PageVersionException();\n\t\t}\n\n\t\tlong resourcePrimKey =\n\t\t\twikiPageResourceLocalService.getPageResourcePrimKey(\n\t\t\t\tnodeId, title);\n\t\tlong groupId = oldPage.getGroupId();\n\n\t\tWikiPage page = oldPage;\n\n\t\tdouble newVersion = oldVersion;\n\n\t\tif (oldPage.isApproved()) {\n\t\t\tnewVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\t\tlong pageId = counterLocalService.increment();\n\n\t\t\tpage = wikiPagePersistence.create(pageId);\n\t\t}\n\n\t\tpage.setResourcePrimKey(resourcePrimKey);\n\t\tpage.setGroupId(groupId);\n\t\tpage.setCompanyId(user.getCompanyId());\n\t\tpage.setUserId(user.getUserId());\n\t\tpage.setUserName(user.getFullName());\n\t\tpage.setCreateDate(serviceContext.getModifiedDate(now));\n\t\tpage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tpage.setNodeId(nodeId);\n\t\tpage.setTitle(title);\n\t\tpage.setVersion(newVersion);\n\t\tpage.setMinorEdit(minorEdit);\n\t\tpage.setContent(content);\n\n\t\tif (oldPage.isPending()) {\n\t\t\tpage.setStatus(oldPage.getStatus());\n\t\t}\n\t\telse {\n\t\t\tpage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tpage.setSummary(summary);\n\t\tpage.setFormat(format);\n\n\t\tif (Validator.isNotNull(parentTitle)) {\n\t\t\tpage.setParentTitle(parentTitle);\n\t\t}\n\n\t\tif (Validator.isNotNull(redirectTitle)) {\n\t\t\tpage.setRedirectTitle(redirectTitle);\n\t\t}\n\n\t\twikiPagePersistence.update(page, false);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = page.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Node\n\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(nodeId);\n\n\t\tnode.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\twikiNodePersistence.update(node, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, page, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), page.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(), page,\n\t\t\tserviceContext);\n\n\t\treturn page;\n\t}","id":522,"modified_method":"public WikiPage updatePage(\n\t\t\tlong userId, long nodeId, String title, double version,\n\t\t\tString content, String summary, boolean minorEdit, String format,\n\t\t\tString parentTitle, String redirectTitle,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Page\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tvalidate(nodeId, content, format);\n\n\t\tWikiPage oldPage = null;\n\n\t\ttry {\n\t\t\toldPage = wikiPagePersistence.findByN_T_First(nodeId, title, null);\n\t\t}\n\t\tcatch (NoSuchPageException nspe) {\n\t\t\treturn addPage(\n\t\t\t\tuserId, nodeId, title, WikiPageConstants.DEFAULT_VERSION,\n\t\t\t\tcontent, summary, minorEdit, format, true, parentTitle,\n\t\t\t\tredirectTitle, serviceContext);\n\t\t}\n\n\t\tdouble oldVersion = oldPage.getVersion();\n\n\t\tif ((version > 0) && (version != oldVersion)) {\n\t\t\tthrow new PageVersionException();\n\t\t}\n\n\t\tlong resourcePrimKey =\n\t\t\twikiPageResourceLocalService.getPageResourcePrimKey(\n\t\t\t\tnodeId, title);\n\t\tlong groupId = oldPage.getGroupId();\n\n\t\tWikiPage page = oldPage;\n\n\t\tdouble newVersion = oldVersion;\n\n\t\tif (oldPage.isApproved()) {\n\t\t\tnewVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\t\tlong pageId = counterLocalService.increment();\n\n\t\t\tpage = wikiPagePersistence.create(pageId);\n\t\t}\n\n\t\tpage.setResourcePrimKey(resourcePrimKey);\n\t\tpage.setGroupId(groupId);\n\t\tpage.setCompanyId(user.getCompanyId());\n\t\tpage.setUserId(user.getUserId());\n\t\tpage.setUserName(user.getFullName());\n\t\tpage.setCreateDate(serviceContext.getModifiedDate(now));\n\t\tpage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tpage.setNodeId(nodeId);\n\t\tpage.setTitle(title);\n\t\tpage.setVersion(newVersion);\n\t\tpage.setMinorEdit(minorEdit);\n\t\tpage.setContent(content);\n\n\t\tif (oldPage.isPending()) {\n\t\t\tpage.setStatus(oldPage.getStatus());\n\t\t}\n\t\telse {\n\t\t\tpage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tpage.setSummary(summary);\n\t\tpage.setFormat(format);\n\n\t\tif (Validator.isNotNull(parentTitle)) {\n\t\t\tpage.setParentTitle(parentTitle);\n\t\t}\n\n\t\tif (Validator.isNotNull(redirectTitle)) {\n\t\t\tpage.setRedirectTitle(redirectTitle);\n\t\t}\n\n\t\twikiPagePersistence.update(page, false);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = page.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Node\n\n\t\tWikiNode node = wikiNodePersistence.findByPrimaryKey(nodeId);\n\n\t\tnode.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\twikiNodePersistence.update(node, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, page, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), page.getGroupId(), userId,\n\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(), page,\n\t\t\tserviceContext);\n\n\t\treturn page;\n\t}","commit_id":"7605bf578f2a8dce139339aa428fe710acb5ac84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, MBMessage message, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean visible = false;\n\n\t\tif ((message.getStatus() == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t((message.getClassNameId() == 0) ||\n\t\t\t (message.getParentMessageId() != 0))) {\n\n\t\t\tvisible = true;\n\t\t}\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, message.getGroupId(), message.getWorkflowClassName(),\n\t\t\tmessage.getMessageId(), message.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, visible, null, null, null, null,\n\t\t\tContentTypes.TEXT_HTML, message.getSubject(), null, null, null,\n\t\t\tnull, 0, 0, null, false);\n\t}","id":523,"modified_method":"public void updateAsset(\n\t\t\tlong userId, MBMessage message, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean visible = false;\n\n\t\tif ((message.getStatus() == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t((message.getClassNameId() == 0) ||\n\t\t\t (message.getParentMessageId() != 0))) {\n\n\t\t\tvisible = true;\n\t\t}\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, message.getGroupId(), message.getWorkflowClassName(),\n\t\t\tmessage.getMessageId(), message.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, visible, null, null, null, null,\n\t\t\tContentTypes.TEXT_HTML, message.getSubject(), null, null, null,\n\t\t\tnull, 0, 0, null, false);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"1d4bf7a618ad9885c9c99c75589ca39990195935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\tif (!message.isPending() &&\n\t\t\t(serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlLocalService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlLocalService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tserviceContext.setAttribute(\"update\", Boolean.TRUE.toString());\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tcompanyId, message.getGroupId(), userId,\n\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), message,\n\t\t\tserviceContext);\n\n\t\treturn message;\n\t}","id":524,"modified_method":"public MBMessage updateMessage(\n\t\t\tlong userId, long messageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files,\n\t\t\tList<String> existingFiles, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tMBMessage message = mbMessagePersistence.findByPrimaryKey(messageId);\n\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty() || !existingFiles.isEmpty());\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\tif (!message.isPending() &&\n\t\t\t(serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\t// Attachments\n\n\t\tlong companyId = message.getCompanyId();\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\tString dirName = message.getAttachmentsDir();\n\n\t\tif (!files.isEmpty() || !existingFiles.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tdlLocalService.addDirectory(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (DuplicateDirectoryException dde) {\n\t\t\t}\n\n\t\t\tString[] fileNames = dlLocalService.getFileNames(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\n\t\t\tfor (String fileName: fileNames) {\n\t\t\t\tif (!existingFiles.contains(fileName)) {\n\t\t\t\t\tdlLocalService.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlLocalService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t}\n\t\t}\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tserviceContext.setAttribute(\"update\", Boolean.TRUE.toString());\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tcompanyId, message.getGroupId(), userId,\n\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), message,\n\t\t\tserviceContext);\n\n\t\treturn message;\n\t}","commit_id":"1d4bf7a618ad9885c9c99c75589ca39990195935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tString format, List<ObjectValuePair<String, byte[]>> files,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(serviceContext.getUuid());\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t// Thread\n\n\t\tif (parentMessageId != MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\t\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\tparentMessageId);\n\n\t\t\tif (parentMessage == null) {\n\t\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t\t}\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCompanyId(user.getCompanyId());\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setRootMessageUserId(user.getUserId());\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setRootMessageId(thread.getRootMessageId());\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setFormat(format);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\tif (message.isDiscussion()) {\n\t\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\t\t(String)serviceContext.getAttribute(\"className\"));\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\tmessage.setClassNameId(classNameId);\n\t\t\tmessage.setClassPK(classPK);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlLocalService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\telse if (serviceContext.getAddGroupPermissions() ||\n\t\t\t\t\t serviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddGroupPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getGroupPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), message,\n\t\t\tserviceContext);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\treturn message;\n\t}","id":525,"modified_method":"public MBMessage addMessage(\n\t\t\tlong userId, String userName, long groupId, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tString format, List<ObjectValuePair<String, byte[]>> files,\n\t\t\tboolean anonymous, double priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(serviceContext.getUuid());\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t// Thread\n\n\t\tif (parentMessageId != MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\t\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\tparentMessageId);\n\n\t\t\tif (parentMessage == null) {\n\t\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t\t}\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCompanyId(user.getCompanyId());\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setRootMessageUserId(user.getUserId());\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setRootMessageId(thread.getRootMessageId());\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setFormat(format);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\tif (message.isDiscussion()) {\n\t\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\t\t(String)serviceContext.getAttribute(\"className\"));\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\tmessage.setClassNameId(classNameId);\n\t\t\tmessage.setClassPK(classPK);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlLocalService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlLocalService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlLocalService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\telse if (serviceContext.getAddGroupPermissions() ||\n\t\t\t\t\t serviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddGroupPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getGroupPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), message,\n\t\t\tserviceContext);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\treturn message;\n\t}","commit_id":"1d4bf7a618ad9885c9c99c75589ca39990195935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doVerify() throws Exception {\n\t\tList<MBCategory> categories =\n\t\t\tMBCategoryLocalServiceUtil.getMBCategories(\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + categories.size() +\n\t\t\t\t\t\" categories for statistics accuracy\");\n\t\t}\n\n\t\tfor (MBCategory category : categories) {\n\t\t\tint threadCount = MBThreadLocalServiceUtil.getCategoryThreadsCount(\n\t\t\t\tcategory.getGroupId(), category.getCategoryId(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\t\t\tint messageCount =\n\t\t\t\tMBMessageLocalServiceUtil.getCategoryMessagesCount(\n\t\t\t\t\tcategory.getGroupId(), category.getCategoryId(),\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif ((category.getThreadCount() != threadCount) ||\n\t\t\t\t(category.getMessageCount() != messageCount)) {\n\n\t\t\t\tcategory.setThreadCount(threadCount);\n\t\t\t\tcategory.setMessageCount(messageCount);\n\n\t\t\t\tMBCategoryLocalServiceUtil.updateMBCategory(category);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Statistics verified for categories\");\n\t\t}\n\n\t\tList<MBThread> threads = MBThreadLocalServiceUtil.getMBThreads(\n\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + threads.size() +\n\t\t\t\t\t\" threads for statistics accuracy\");\n\t\t}\n\n\t\tfor (MBThread thread : threads) {\n\t\t\tint messageCount = MBMessageLocalServiceUtil.getThreadMessagesCount(\n\t\t\t\tthread.getThreadId(), WorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif (thread.getMessageCount() != messageCount) {\n\t\t\t\tthread.setMessageCount(messageCount);\n\n\t\t\t\tMBThreadLocalServiceUtil.updateMBThread(thread);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Statistics verified for threads\");\n\t\t}\n\n\t\tList<MBMessage> messages =\n\t\t\tMBMessageLocalServiceUtil.getNoAssetMessages();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + messages.size() + \" messages with no asset\");\n\t\t}\n\n\t\tfor (MBMessage message : messages) {\n\t\t\ttry {\n\t\t\t\tMBMessageLocalServiceUtil.updateAsset(\n\t\t\t\t\tmessage.getUserId(), message, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for message \" +\n\t\t\t\t\t\t\tmessage.getMessageId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for messages\");\n\t\t}\n\t}","id":526,"modified_method":"protected void doVerify() throws Exception {\n\t\tList<MBCategory> categories =\n\t\t\tMBCategoryLocalServiceUtil.getMBCategories(\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + categories.size() +\n\t\t\t\t\t\" categories for statistics accuracy\");\n\t\t}\n\n\t\tfor (MBCategory category : categories) {\n\t\t\tint threadCount = MBThreadLocalServiceUtil.getCategoryThreadsCount(\n\t\t\t\tcategory.getGroupId(), category.getCategoryId(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\t\t\tint messageCount =\n\t\t\t\tMBMessageLocalServiceUtil.getCategoryMessagesCount(\n\t\t\t\t\tcategory.getGroupId(), category.getCategoryId(),\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif ((category.getThreadCount() != threadCount) ||\n\t\t\t\t(category.getMessageCount() != messageCount)) {\n\n\t\t\t\tcategory.setThreadCount(threadCount);\n\t\t\t\tcategory.setMessageCount(messageCount);\n\n\t\t\t\tMBCategoryLocalServiceUtil.updateMBCategory(category);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Statistics verified for categories\");\n\t\t}\n\n\t\tList<MBThread> threads = MBThreadLocalServiceUtil.getMBThreads(\n\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + threads.size() +\n\t\t\t\t\t\" threads for statistics accuracy\");\n\t\t}\n\n\t\tfor (MBThread thread : threads) {\n\t\t\tint messageCount = MBMessageLocalServiceUtil.getThreadMessagesCount(\n\t\t\t\tthread.getThreadId(), WorkflowConstants.STATUS_APPROVED);\n\n\t\t\tif (thread.getMessageCount() != messageCount) {\n\t\t\t\tthread.setMessageCount(messageCount);\n\n\t\t\t\tMBThreadLocalServiceUtil.updateMBThread(thread);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Statistics verified for threads\");\n\t\t}\n\n\t\tList<MBMessage> messages =\n\t\t\tMBMessageLocalServiceUtil.getNoAssetMessages();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + messages.size() + \" messages with no asset\");\n\t\t}\n\n\t\tfor (MBMessage message : messages) {\n\t\t\ttry {\n\t\t\t\tMBMessageLocalServiceUtil.updateAsset(\n\t\t\t\t\tmessage.getUserId(), message, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for message \" +\n\t\t\t\t\t\t\tmessage.getMessageId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for messages\");\n\t\t}\n\t}","commit_id":"1d4bf7a618ad9885c9c99c75589ca39990195935","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public IGImage updateImage(\n\t\t\tlong userId, long imageId, long groupId, long folderId, String name,\n\t\t\tString description, byte[] bytes, String contentType,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\n\t\t\t// Image\n\n\t\t\tIGImage image = igImagePersistence.findByPrimaryKey(imageId);\n\n\t\t\tfolderId = getFolder(image, folderId);\n\n\t\t\tRenderedImage renderedImage = null;\n\n\t\t\tif (bytes != null) {\n\t\t\t\trenderedImage = ImageProcessorUtil.read(\n\t\t\t\t\tbytes).getRenderedImage();\n\n\t\t\t\tvalidate(bytes);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(name) && !name.equals(image.getName())) {\n\t\t\t\tString nameWithExtension = IGImageImpl.getNameWithExtension(\n\t\t\t\t\tname, image.getImageType());\n\n\t\t\t\tvalidate(groupId, folderId, nameWithExtension);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tname = image.getName();\n\t\t\t}\n\n\t\t\timage.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\t\timage.setFolderId(folderId);\n\t\t\timage.setName(name);\n\t\t\timage.setDescription(description);\n\t\t\timage.setExpandoBridgeAttributes(serviceContext);\n\n\t\t\tigImagePersistence.update(image, false);\n\n\t\t\t// Images\n\n\t\t\tif (renderedImage != null) {\n\t\t\t\tsaveImages(\n\t\t\t\t\timage.getLargeImageId(), renderedImage,\n\t\t\t\t\timage.getSmallImageId(), image.getCustom1ImageId(),\n\t\t\t\t\timage.getCustom2ImageId(), bytes, contentType);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tlong[] assetCategoryIds = serviceContext.getAssetCategoryIds();\n\t\t\tString[] assetTagNames = serviceContext.getAssetTagNames();\n\n\t\t\tupdateAsset(\n\t\t\t\tuserId, image, assetCategoryIds, assetTagNames, contentType);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, image.getGroupId(), IGImage.class.getName(), imageId,\n\t\t\t\tIGActivityKeys.UPDATE_IMAGE, StringPool.BLANK, 0);\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(IGImage.class);\n\n\t\t\tindexer.reindex(image);\n\n\t\t\treturn image;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new ImageSizeException(ioe);\n\t\t}\n\t}","id":527,"modified_method":"public IGImage updateImage(\n\t\t\tlong userId, long imageId, long groupId, long folderId, String name,\n\t\t\tString description, byte[] bytes, String contentType,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\n\t\t\t// Image\n\n\t\t\tIGImage image = igImagePersistence.findByPrimaryKey(imageId);\n\n\t\t\tfolderId = getFolder(image, folderId);\n\n\t\t\tRenderedImage renderedImage = null;\n\n\t\t\tif (bytes != null) {\n\t\t\t\trenderedImage = ImageProcessorUtil.read(\n\t\t\t\t\tbytes).getRenderedImage();\n\n\t\t\t\tvalidate(bytes);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(name) && !name.equals(image.getName())) {\n\t\t\t\tString nameWithExtension = IGImageImpl.getNameWithExtension(\n\t\t\t\t\tname, image.getImageType());\n\n\t\t\t\tvalidate(groupId, folderId, nameWithExtension);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tname = image.getName();\n\t\t\t}\n\n\t\t\timage.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\t\timage.setFolderId(folderId);\n\t\t\timage.setName(name);\n\t\t\timage.setDescription(description);\n\t\t\timage.setExpandoBridgeAttributes(serviceContext);\n\n\t\t\tigImagePersistence.update(image, false);\n\n\t\t\t// Images\n\n\t\t\tif (renderedImage != null) {\n\t\t\t\tsaveImages(\n\t\t\t\t\timage.getLargeImageId(), renderedImage,\n\t\t\t\t\timage.getSmallImageId(), image.getCustom1ImageId(),\n\t\t\t\t\timage.getCustom2ImageId(), bytes, contentType);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tlong[] assetCategoryIds = serviceContext.getAssetCategoryIds();\n\t\t\tString[] assetTagNames = serviceContext.getAssetTagNames();\n\t\t\tlong[] assetLinkEntryIds = serviceContext.getAssetLinkEntryIds();\n\n\t\t\tupdateAsset(\n\t\t\t\tuserId, image, assetCategoryIds, assetTagNames,\n\t\t\t\tassetLinkEntryIds, contentType);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, image.getGroupId(), IGImage.class.getName(), imageId,\n\t\t\t\tIGActivityKeys.UPDATE_IMAGE, StringPool.BLANK, 0);\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(IGImage.class);\n\n\t\t\tindexer.reindex(image);\n\n\t\t\treturn image;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new ImageSizeException(ioe);\n\t\t}\n\t}","commit_id":"85739ae92567d5602f8064c8603f47634a285520","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, IGImage image, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, String contentType)\n\t\tthrows PortalException, SystemException {\n\n\t\tImage largeImage = imageLocalService.getImage(image.getLargeImageId());\n\n\t\tif (largeImage == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (contentType == null) {\n\t\t\tcontentType = MimeTypesUtil.getContentType(largeImage.getType());\n\t\t}\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, image.getGroupId(), IGImage.class.getName(),\n\t\t\timage.getImageId(), image.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, true, null, null, null, null, contentType,\n\t\t\timage.getName(), image.getDescription(), null, null, null,\n\t\t\tlargeImage.getHeight(), largeImage.getWidth(), null, false);\n\t}","id":528,"modified_method":"public void updateAsset(\n\t\t\tlong userId, IGImage image, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds,\n\t\t\tString contentType)\n\t\tthrows PortalException, SystemException {\n\n\t\tImage largeImage = imageLocalService.getImage(image.getLargeImageId());\n\n\t\tif (largeImage == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (contentType == null) {\n\t\t\tcontentType = MimeTypesUtil.getContentType(largeImage.getType());\n\t\t}\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, image.getGroupId(), IGImage.class.getName(),\n\t\t\timage.getImageId(), image.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, true, null, null, null, null, contentType,\n\t\t\timage.getName(), image.getDescription(), null, null, null,\n\t\t\tlargeImage.getHeight(), largeImage.getWidth(), null, false);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"85739ae92567d5602f8064c8603f47634a285520","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public IGImage addImage(\n\t\t\tlong userId, long groupId, long folderId, String name,\n\t\t\tString description, String fileName, byte[] bytes,\n\t\t\tString contentType, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\n\t\t\t// Image\n\n\t\t\tString extension = FileUtil.getExtension(fileName);\n\n\t\t\tif (Validator.isNotNull(name) &&\n\t\t\t\tStringUtil.endsWith(name, extension)) {\n\n\t\t\t\tname = FileUtil.stripExtension(name);\n\t\t\t}\n\n\t\t\tString nameWithExtension = name + StringPool.PERIOD + extension;\n\n\t\t\tvalidate(groupId, folderId, nameWithExtension, fileName, bytes);\n\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\t\tRenderedImage renderedImage = ImageProcessorUtil.read(\n\t\t\t\tbytes).getRenderedImage();\n\t\t\tDate now = new Date();\n\n\t\t\tlong imageId = counterLocalService.increment();\n\n\t\t\tif (Validator.isNull(name)) {\n\t\t\t\tname = String.valueOf(imageId);\n\t\t\t}\n\n\t\t\tIGImage image = igImagePersistence.create(imageId);\n\n\t\t\timage.setUuid(serviceContext.getUuid());\n\t\t\timage.setGroupId(groupId);\n\t\t\timage.setCompanyId(user.getCompanyId());\n\t\t\timage.setUserId(user.getUserId());\n\t\t\timage.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\timage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\timage.setFolderId(folderId);\n\t\t\timage.setName(name);\n\t\t\timage.setDescription(description);\n\t\t\timage.setSmallImageId(counterLocalService.increment());\n\t\t\timage.setLargeImageId(counterLocalService.increment());\n\n\t\t\tif (PropsValues.IG_IMAGE_CUSTOM_1_MAX_DIMENSION > 0) {\n\t\t\t\timage.setCustom1ImageId(counterLocalService.increment());\n\t\t\t}\n\n\t\t\tif (PropsValues.IG_IMAGE_CUSTOM_2_MAX_DIMENSION > 0) {\n\t\t\t\timage.setCustom2ImageId(counterLocalService.increment());\n\t\t\t}\n\n\t\t\timage.setExpandoBridgeAttributes(serviceContext);\n\n\t\t\tigImagePersistence.update(image, false);\n\n\t\t\t// Resources\n\n\t\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddImageResources(\n\t\t\t\t\timage, serviceContext.getAddGroupPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddImageResources(\n\t\t\t\t\timage, serviceContext.getGroupPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\n\t\t\t// Images\n\n\t\t\tsaveImages(\n\t\t\t\timage.getLargeImageId(), renderedImage, image.getSmallImageId(),\n\t\t\t\timage.getCustom1ImageId(), image.getCustom2ImageId(), bytes,\n\t\t\t\tcontentType);\n\n\t\t\t// Asset\n\n\t\t\tupdateAsset(\n\t\t\t\tuserId, image, serviceContext.getAssetCategoryIds(),\n\t\t\t\tserviceContext.getAssetTagNames(), contentType);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, image.getGroupId(), IGImage.class.getName(), imageId,\n\t\t\t\tIGActivityKeys.ADD_IMAGE, StringPool.BLANK, 0);\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(IGImage.class);\n\n\t\t\tindexer.reindex(image);\n\n\t\t\treturn image;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new ImageSizeException(ioe);\n\t\t}\n\t}","id":529,"modified_method":"public IGImage addImage(\n\t\t\tlong userId, long groupId, long folderId, String name,\n\t\t\tString description, String fileName, byte[] bytes,\n\t\t\tString contentType, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\n\t\t\t// Image\n\n\t\t\tString extension = FileUtil.getExtension(fileName);\n\n\t\t\tif (Validator.isNotNull(name) &&\n\t\t\t\tStringUtil.endsWith(name, extension)) {\n\n\t\t\t\tname = FileUtil.stripExtension(name);\n\t\t\t}\n\n\t\t\tString nameWithExtension = name + StringPool.PERIOD + extension;\n\n\t\t\tvalidate(groupId, folderId, nameWithExtension, fileName, bytes);\n\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\t\tRenderedImage renderedImage = ImageProcessorUtil.read(\n\t\t\t\tbytes).getRenderedImage();\n\t\t\tDate now = new Date();\n\n\t\t\tlong imageId = counterLocalService.increment();\n\n\t\t\tif (Validator.isNull(name)) {\n\t\t\t\tname = String.valueOf(imageId);\n\t\t\t}\n\n\t\t\tIGImage image = igImagePersistence.create(imageId);\n\n\t\t\timage.setUuid(serviceContext.getUuid());\n\t\t\timage.setGroupId(groupId);\n\t\t\timage.setCompanyId(user.getCompanyId());\n\t\t\timage.setUserId(user.getUserId());\n\t\t\timage.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\timage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\timage.setFolderId(folderId);\n\t\t\timage.setName(name);\n\t\t\timage.setDescription(description);\n\t\t\timage.setSmallImageId(counterLocalService.increment());\n\t\t\timage.setLargeImageId(counterLocalService.increment());\n\n\t\t\tif (PropsValues.IG_IMAGE_CUSTOM_1_MAX_DIMENSION > 0) {\n\t\t\t\timage.setCustom1ImageId(counterLocalService.increment());\n\t\t\t}\n\n\t\t\tif (PropsValues.IG_IMAGE_CUSTOM_2_MAX_DIMENSION > 0) {\n\t\t\t\timage.setCustom2ImageId(counterLocalService.increment());\n\t\t\t}\n\n\t\t\timage.setExpandoBridgeAttributes(serviceContext);\n\n\t\t\tigImagePersistence.update(image, false);\n\n\t\t\t// Resources\n\n\t\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddImageResources(\n\t\t\t\t\timage, serviceContext.getAddGroupPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddImageResources(\n\t\t\t\t\timage, serviceContext.getGroupPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\n\t\t\t// Images\n\n\t\t\tsaveImages(\n\t\t\t\timage.getLargeImageId(), renderedImage, image.getSmallImageId(),\n\t\t\t\timage.getCustom1ImageId(), image.getCustom2ImageId(), bytes,\n\t\t\t\tcontentType);\n\n\t\t\t// Asset\n\n\t\t\tupdateAsset(\n\t\t\t\tuserId, image, serviceContext.getAssetCategoryIds(),\n\t\t\t\tserviceContext.getAssetTagNames(),\n\t\t\t\tserviceContext.getAssetLinkEntryIds(), contentType);\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, image.getGroupId(), IGImage.class.getName(), imageId,\n\t\t\t\tIGActivityKeys.ADD_IMAGE, StringPool.BLANK, 0);\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(IGImage.class);\n\n\t\t\tindexer.reindex(image);\n\n\t\t\treturn image;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new ImageSizeException(ioe);\n\t\t}\n\t}","commit_id":"85739ae92567d5602f8064c8603f47634a285520","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doVerify() throws Exception {\n\t\tList<IGImage> images = IGImageLocalServiceUtil.getNoAssetImages();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Processing \" + images.size() + \" images with no asset\");\n\t\t}\n\n\t\tfor (IGImage image : images) {\n\t\t\ttry {\n\t\t\t\tIGImageLocalServiceUtil.updateAsset(\n\t\t\t\t\timage.getUserId(), image, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for image \" +\n\t\t\t\t\t\t\timage.getImageId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for images\");\n\t\t}\n\t}","id":530,"modified_method":"protected void doVerify() throws Exception {\n\t\tList<IGImage> images = IGImageLocalServiceUtil.getNoAssetImages();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Processing \" + images.size() + \" images with no asset\");\n\t\t}\n\n\t\tfor (IGImage image : images) {\n\t\t\ttry {\n\t\t\t\tIGImageLocalServiceUtil.updateAsset(\n\t\t\t\t\timage.getUserId(), image, null, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for image \" +\n\t\t\t\t\t\t\timage.getImageId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for images\");\n\t\t}\n\t}","commit_id":"85739ae92567d5602f8064c8603f47634a285520","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BlogsEntry addEntry(\n\t\t\tlong userId, String title, String description, String content,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks, boolean smallImage,\n\t\t\tString smallImageURL, File smallFile, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tnew EntryDisplayDateException());\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallFile, smallBytes);\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setUrlTitle(getUniqueUrlTitle(entryId, groupId, title));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\tentry.setSmallImageURL(smallImageURL);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, entry.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, entry.getUserName(), groupId,\n\t\t\t\tBlogsEntry.class.getName(), entryId,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif ((trackbacks != null) && (trackbacks.length > 0)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId, BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry, serviceContext);\n\n\t\treturn entry;\n\t}","id":531,"modified_method":"public BlogsEntry addEntry(\n\t\t\tlong userId, String title, String description, String content,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks, boolean smallImage,\n\t\t\tString smallImageURL, File smallFile, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tnew EntryDisplayDateException());\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallFile, smallBytes);\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setUrlTitle(getUniqueUrlTitle(entryId, groupId, title));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\tentry.setSmallImageURL(smallImageURL);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, entry.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, entry.getUserName(), groupId,\n\t\t\t\tBlogsEntry.class.getName(), entryId,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif ((trackbacks != null) && (trackbacks.length > 0)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId, BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry, serviceContext);\n\n\t\treturn entry;\n\t}","commit_id":"fd463979fd5b69c4a044f96f99ea03627c2f419b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, BlogsEntry entry, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean visible = false;\n\n\t\tif (entry.getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tvisible = true;\n\t\t}\n\n\t\tString summary = HtmlUtil.extractText(\n\t\t\tStringUtil.shorten(entry.getContent(), 500));\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, visible, null, null, entry.getDisplayDate(), null,\n\t\t\tContentTypes.TEXT_HTML, entry.getTitle(), null, summary, null, null,\n\t\t\t0, 0, null, false);\n\t}","id":532,"modified_method":"public void updateAsset(\n\t\t\tlong userId, BlogsEntry entry, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean visible = false;\n\n\t\tif (entry.getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tvisible = true;\n\t\t}\n\n\t\tString summary = HtmlUtil.extractText(\n\t\t\tStringUtil.shorten(entry.getContent(), 500));\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, visible, null, null, entry.getDisplayDate(), null,\n\t\t\tContentTypes.TEXT_HTML, entry.getTitle(), null, summary, null, null,\n\t\t\t0, 0, null, false);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"fd463979fd5b69c4a044f96f99ea03627c2f419b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String description,\n\t\t\tString content, int displayDateMonth, int displayDateDay,\n\t\t\tint displayDateYear, int displayDateHour, int displayDateMinute,\n\t\t\tboolean allowPingbacks,\tboolean allowTrackbacks,\n\t\t\tString[] trackbacks, boolean smallImage, String smallImageURL,\n\t\t\tFile smallFile, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tnew EntryDisplayDateException());\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallFile, smallBytes);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, entry.getGroupId(), title));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\n\t\tif (entry.getSmallImageId() == 0) {\n\t\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\t}\n\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tif (!entry.isPending()) {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry, false);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, entry.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (Validator.isNotNull(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), entry.getGroupId(), userId,\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId(), entry,\n\t\t\tserviceContext);\n\n\t\treturn entry;\n\t}","id":533,"modified_method":"public BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String description,\n\t\t\tString content, int displayDateMonth, int displayDateDay,\n\t\t\tint displayDateYear, int displayDateHour, int displayDateMinute,\n\t\t\tboolean allowPingbacks,\tboolean allowTrackbacks,\n\t\t\tString[] trackbacks, boolean smallImage, String smallImageURL,\n\t\t\tFile smallFile, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tnew EntryDisplayDateException());\n\n\t\tbyte[] smallBytes = null;\n\n\t\ttry {\n\t\t\tsmallBytes = FileUtil.getBytes(smallFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallFile, smallBytes);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, entry.getGroupId(), title));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\n\t\tif (entry.getSmallImageId() == 0) {\n\t\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\t}\n\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tif (!entry.isPending()) {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry, false);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(\n\t\t\tsmallImage, entry.getSmallImageId(), smallFile, smallBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (Validator.isNotNull(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), entry.getGroupId(), userId,\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId(), entry,\n\t\t\tserviceContext);\n\n\t\treturn entry;\n\t}","commit_id":"fd463979fd5b69c4a044f96f99ea03627c2f419b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doVerify() throws Exception {\n\t\tList<BlogsEntry> entries =\n\t\t\tBlogsEntryLocalServiceUtil.getNoAssetEntries();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + entries.size() + \" entries with no asset\");\n\t\t}\n\n\t\tfor (BlogsEntry entry : entries) {\n\t\t\ttry {\n\t\t\t\tBlogsEntryLocalServiceUtil.updateAsset(\n\t\t\t\t\tentry.getUserId(), entry, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for entry \" +\n\t\t\t\t\t\t\tentry.getEntryId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for entries\");\n\t\t}\n\t}","id":534,"modified_method":"protected void doVerify() throws Exception {\n\t\tList<BlogsEntry> entries =\n\t\t\tBlogsEntryLocalServiceUtil.getNoAssetEntries();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + entries.size() + \" entries with no asset\");\n\t\t}\n\n\t\tfor (BlogsEntry entry : entries) {\n\t\t\ttry {\n\t\t\t\tBlogsEntryLocalServiceUtil.updateAsset(\n\t\t\t\t\tentry.getUserId(), entry, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for entry \" +\n\t\t\t\t\t\t\tentry.getEntryId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for entries\");\n\t\t}\n\t}","commit_id":"fd463979fd5b69c4a044f96f99ea03627c2f419b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void updateKBArticleAsset(\n\t\t\tlong userId, KBArticle kbArticle, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames)\n\t\tthrows PortalException {\n\n\t\t// TODO\n\n\t\tlong classTypeId = 0;\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, kbArticle.getGroupId(), kbArticle.getCreateDate(),\n\t\t\tkbArticle.getModifiedDate(), KBArticle.class.getName(),\n\t\t\tkbArticle.getClassPK(), kbArticle.getUuid(), classTypeId,\n\t\t\tassetCategoryIds, assetTagNames, false, null, null, null,\n\t\t\tContentTypes.TEXT_HTML, kbArticle.getTitle(),\n\t\t\tkbArticle.getDescription(), null, null, null, 0, 0, null, false);\n\t}","id":535,"modified_method":"@Override\n\tpublic void updateKBArticleAsset(\n\t\t\tlong userId, KBArticle kbArticle, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds)\n\t\tthrows PortalException {\n\n\t\t// TODO\n\n\t\tlong classTypeId = 0;\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, kbArticle.getGroupId(), kbArticle.getCreateDate(),\n\t\t\tkbArticle.getModifiedDate(), KBArticle.class.getName(),\n\t\t\tkbArticle.getClassPK(), kbArticle.getUuid(), classTypeId,\n\t\t\tassetCategoryIds, assetTagNames, false, null, null, null,\n\t\t\tContentTypes.TEXT_HTML, kbArticle.getTitle(),\n\t\t\tkbArticle.getDescription(), null, null, null, 0, 0, null, false);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"8b20892619c4d0d4f6aa69bcb65c527a34218ba8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic KBArticle updateKBArticle(\n\t\t\tlong userId, long resourcePrimKey, String title, String content,\n\t\t\tString description, String[] sections, String dirName,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// KB article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tvalidate(title, content);\n\n\t\tKBArticle oldKBArticle = getLatestKBArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tint oldVersion = oldKBArticle.getVersion();\n\n\t\tKBArticle kbArticle = null;\n\n\t\tif (oldKBArticle.isApproved()) {\n\t\t\tlong kbArticleId = counterLocalService.increment();\n\n\t\t\tkbArticle = kbArticlePersistence.create(kbArticleId);\n\n\t\t\tkbArticle.setUuid(serviceContext.getUuid());\n\t\t\tkbArticle.setResourcePrimKey(oldKBArticle.getResourcePrimKey());\n\t\t\tkbArticle.setGroupId(oldKBArticle.getGroupId());\n\t\t\tkbArticle.setCompanyId(user.getCompanyId());\n\t\t\tkbArticle.setUserId(user.getUserId());\n\t\t\tkbArticle.setUserName(user.getFullName());\n\t\t\tkbArticle.setCreateDate(oldKBArticle.getCreateDate());\n\t\t\tkbArticle.setRootResourcePrimKey(\n\t\t\t\toldKBArticle.getRootResourcePrimKey());\n\t\t\tkbArticle.setParentResourcePrimKey(\n\t\t\t\toldKBArticle.getParentResourcePrimKey());\n\t\t\tkbArticle.setVersion(oldVersion + 1);\n\t\t\tkbArticle.setUrlTitle(oldKBArticle.getUrlTitle());\n\t\t\tkbArticle.setPriority(oldKBArticle.getPriority());\n\t\t\tkbArticle.setViewCount(oldKBArticle.getViewCount());\n\t\t}\n\t\telse {\n\t\t\tkbArticle = oldKBArticle;\n\t\t}\n\n\t\tif (oldKBArticle.isPending()) {\n\t\t\tkbArticle.setStatus(WorkflowConstants.STATUS_PENDING);\n\t\t}\n\t\telse {\n\t\t\tkbArticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tkbArticle.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tkbArticle.setTitle(title);\n\t\tkbArticle.setContent(content);\n\t\tkbArticle.setDescription(description);\n\t\tkbArticle.setSections(\n\t\t\tStringUtil.merge(AdminUtil.escapeSections(sections)));\n\t\tkbArticle.setLatest(true);\n\t\tkbArticle.setMain(false);\n\n\t\tkbArticlePersistence.update(kbArticle);\n\n\t\tif (oldKBArticle.isApproved()) {\n\t\t\toldKBArticle.setLatest(false);\n\n\t\t\tkbArticlePersistence.update(oldKBArticle);\n\t\t}\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateKBArticleResources(\n\t\t\t\tkbArticle, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateKBArticleAsset(\n\t\t\tuserId, kbArticle, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Attachments\n\n\t\tupdateKBArticleAttachments(\n\t\t\tuserId, kbArticle, oldVersion, dirName, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), kbArticle.getGroupId(), userId,\n\t\t\tKBArticle.class.getName(), resourcePrimKey, kbArticle,\n\t\t\tserviceContext);\n\n\t\treturn kbArticle;\n\t}","id":536,"modified_method":"@Override\n\tpublic KBArticle updateKBArticle(\n\t\t\tlong userId, long resourcePrimKey, String title, String content,\n\t\t\tString description, String[] sections, String dirName,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// KB article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tvalidate(title, content);\n\n\t\tKBArticle oldKBArticle = getLatestKBArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tint oldVersion = oldKBArticle.getVersion();\n\n\t\tKBArticle kbArticle = null;\n\n\t\tif (oldKBArticle.isApproved()) {\n\t\t\tlong kbArticleId = counterLocalService.increment();\n\n\t\t\tkbArticle = kbArticlePersistence.create(kbArticleId);\n\n\t\t\tkbArticle.setUuid(serviceContext.getUuid());\n\t\t\tkbArticle.setResourcePrimKey(oldKBArticle.getResourcePrimKey());\n\t\t\tkbArticle.setGroupId(oldKBArticle.getGroupId());\n\t\t\tkbArticle.setCompanyId(user.getCompanyId());\n\t\t\tkbArticle.setUserId(user.getUserId());\n\t\t\tkbArticle.setUserName(user.getFullName());\n\t\t\tkbArticle.setCreateDate(oldKBArticle.getCreateDate());\n\t\t\tkbArticle.setRootResourcePrimKey(\n\t\t\t\toldKBArticle.getRootResourcePrimKey());\n\t\t\tkbArticle.setParentResourcePrimKey(\n\t\t\t\toldKBArticle.getParentResourcePrimKey());\n\t\t\tkbArticle.setVersion(oldVersion + 1);\n\t\t\tkbArticle.setUrlTitle(oldKBArticle.getUrlTitle());\n\t\t\tkbArticle.setPriority(oldKBArticle.getPriority());\n\t\t\tkbArticle.setViewCount(oldKBArticle.getViewCount());\n\t\t}\n\t\telse {\n\t\t\tkbArticle = oldKBArticle;\n\t\t}\n\n\t\tif (oldKBArticle.isPending()) {\n\t\t\tkbArticle.setStatus(WorkflowConstants.STATUS_PENDING);\n\t\t}\n\t\telse {\n\t\t\tkbArticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tkbArticle.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tkbArticle.setTitle(title);\n\t\tkbArticle.setContent(content);\n\t\tkbArticle.setDescription(description);\n\t\tkbArticle.setSections(\n\t\t\tStringUtil.merge(AdminUtil.escapeSections(sections)));\n\t\tkbArticle.setLatest(true);\n\t\tkbArticle.setMain(false);\n\n\t\tkbArticlePersistence.update(kbArticle);\n\n\t\tif (oldKBArticle.isApproved()) {\n\t\t\toldKBArticle.setLatest(false);\n\n\t\t\tkbArticlePersistence.update(oldKBArticle);\n\t\t}\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateKBArticleResources(\n\t\t\t\tkbArticle, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateKBArticleAsset(\n\t\t\tuserId, kbArticle, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Attachments\n\n\t\tupdateKBArticleAttachments(\n\t\t\tuserId, kbArticle, oldVersion, dirName, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), kbArticle.getGroupId(), userId,\n\t\t\tKBArticle.class.getName(), resourcePrimKey, kbArticle,\n\t\t\tserviceContext);\n\n\t\treturn kbArticle;\n\t}","commit_id":"8b20892619c4d0d4f6aa69bcb65c527a34218ba8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic KBArticle updateStatus(\n\t\t\tlong userId, long resourcePrimKey, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// KB article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tboolean main = false;\n\t\tDate now = new Date();\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tmain = true;\n\t\t}\n\n\t\tKBArticle kbArticle = getLatestKBArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tkbArticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tkbArticle.setMain(main);\n\t\tkbArticle.setStatus(status);\n\t\tkbArticle.setStatusByUserId(user.getUserId());\n\t\tkbArticle.setStatusByUserName(user.getFullName());\n\t\tkbArticle.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tkbArticlePersistence.update(kbArticle);\n\n\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn kbArticle;\n\t\t}\n\n\t\tif (!kbArticle.isFirstVersion()) {\n\t\t\tKBArticle oldKBArticle = kbArticlePersistence.findByR_V(\n\t\t\t\tresourcePrimKey, kbArticle.getVersion() - 1);\n\n\t\t\toldKBArticle.setMain(false);\n\n\t\t\tkbArticlePersistence.update(oldKBArticle);\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.getEntry(\n\t\t\tKBArticle.class.getName(), kbArticle.getKbArticleId());\n\n\t\tupdateKBArticleAsset(\n\t\t\tuserId, kbArticle, assetEntry.getCategoryIds(),\n\t\t\tassetEntry.getTagNames());\n\n\t\tSystemEventHierarchyEntryThreadLocal.push(KBArticle.class);\n\n\t\ttry {\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tKBArticle.class.getName(), kbArticle.getKbArticleId());\n\t\t}\n\t\tfinally {\n\t\t\tSystemEventHierarchyEntryThreadLocal.pop(KBArticle.class);\n\t\t}\n\n\t\tassetEntryLocalService.updateVisible(\n\t\t\tKBArticle.class.getName(), kbArticle.getResourcePrimKey(), true);\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", kbArticle.getTitle());\n\n\t\tif (!kbArticle.isFirstVersion()) {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, kbArticle.getGroupId(), KBArticle.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.UPDATE_KB_ARTICLE,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\t\telse {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, kbArticle.getGroupId(), KBArticle.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.ADD_KB_ARTICLE,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(KBArticle.class);\n\n\t\tindexer.reindex(kbArticle);\n\n\t\t// Attachments\n\n\t\tif (!kbArticle.isFirstVersion()) {\n\t\t\tdeleteKBArticleAttachments(kbArticle, resourcePrimKey);\n\t\t}\n\n\t\tString dirName =\n\t\t\tKBArticleConstants.DIR_NAME_PREFIX + kbArticle.getKbArticleId();\n\n\t\taddKBArticleAttachments(userId, kbArticle, dirName, serviceContext);\n\n\t\tdeleteKBArticleAttachments(kbArticle, kbArticle.getKbArticleId());\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(kbArticle, serviceContext);\n\n\t\treturn kbArticle;\n\t}","id":537,"modified_method":"@Override\n\tpublic KBArticle updateStatus(\n\t\t\tlong userId, long resourcePrimKey, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// KB article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tboolean main = false;\n\t\tDate now = new Date();\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tmain = true;\n\t\t}\n\n\t\tKBArticle kbArticle = getLatestKBArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tkbArticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tkbArticle.setMain(main);\n\t\tkbArticle.setStatus(status);\n\t\tkbArticle.setStatusByUserId(user.getUserId());\n\t\tkbArticle.setStatusByUserName(user.getFullName());\n\t\tkbArticle.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tkbArticlePersistence.update(kbArticle);\n\n\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn kbArticle;\n\t\t}\n\n\t\tif (!kbArticle.isFirstVersion()) {\n\t\t\tKBArticle oldKBArticle = kbArticlePersistence.findByR_V(\n\t\t\t\tresourcePrimKey, kbArticle.getVersion() - 1);\n\n\t\t\toldKBArticle.setMain(false);\n\n\t\t\tkbArticlePersistence.update(oldKBArticle);\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.getEntry(\n\t\t\tKBArticle.class.getName(), kbArticle.getKbArticleId());\n\n\t\tlong[] assetLinkEntryIds = getAssetLinksEntryIds(assetEntry);\n\n\t\tupdateKBArticleAsset(\n\t\t\tuserId, kbArticle, assetEntry.getCategoryIds(),\n\t\t\tassetEntry.getTagNames(), assetLinkEntryIds);\n\n\t\tSystemEventHierarchyEntryThreadLocal.push(KBArticle.class);\n\n\t\ttry {\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tKBArticle.class.getName(), kbArticle.getKbArticleId());\n\t\t}\n\t\tfinally {\n\t\t\tSystemEventHierarchyEntryThreadLocal.pop(KBArticle.class);\n\t\t}\n\n\t\tassetEntryLocalService.updateVisible(\n\t\t\tKBArticle.class.getName(), kbArticle.getResourcePrimKey(), true);\n\n\t\t// Social\n\n\t\tJSONObject extraDataJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\textraDataJSONObject.put(\"title\", kbArticle.getTitle());\n\n\t\tif (!kbArticle.isFirstVersion()) {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, kbArticle.getGroupId(), KBArticle.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.UPDATE_KB_ARTICLE,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\t\telse {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, kbArticle.getGroupId(), KBArticle.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.ADD_KB_ARTICLE,\n\t\t\t\textraDataJSONObject.toString(), 0);\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(KBArticle.class);\n\n\t\tindexer.reindex(kbArticle);\n\n\t\t// Attachments\n\n\t\tif (!kbArticle.isFirstVersion()) {\n\t\t\tdeleteKBArticleAttachments(kbArticle, resourcePrimKey);\n\t\t}\n\n\t\tString dirName =\n\t\t\tKBArticleConstants.DIR_NAME_PREFIX + kbArticle.getKbArticleId();\n\n\t\taddKBArticleAttachments(userId, kbArticle, dirName, serviceContext);\n\n\t\tdeleteKBArticleAttachments(kbArticle, kbArticle.getKbArticleId());\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(kbArticle, serviceContext);\n\n\t\treturn kbArticle;\n\t}","commit_id":"8b20892619c4d0d4f6aa69bcb65c527a34218ba8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic KBArticle addKBArticle(\n\t\t\tlong userId, long parentResourcePrimKey, String title,\n\t\t\tString urlTitle, String content, String description,\n\t\t\tString[] sections, String dirName, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// KB article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tdouble priority = getPriority(groupId, parentResourcePrimKey);\n\t\tDate now = new Date();\n\n\t\tvalidate(title, content);\n\n\t\tlong kbArticleId = counterLocalService.increment();\n\n\t\tlong resourcePrimKey = counterLocalService.increment();\n\n\t\tlong rootResourcePrimKey = getRootResourcePrimKey(\n\t\t\tresourcePrimKey, parentResourcePrimKey);\n\n\t\tKBArticle kbArticle = kbArticlePersistence.create(kbArticleId);\n\n\t\tkbArticle.setUuid(serviceContext.getUuid());\n\t\tkbArticle.setResourcePrimKey(resourcePrimKey);\n\t\tkbArticle.setGroupId(groupId);\n\t\tkbArticle.setCompanyId(user.getCompanyId());\n\t\tkbArticle.setUserId(user.getUserId());\n\t\tkbArticle.setUserName(user.getFullName());\n\t\tkbArticle.setCreateDate(serviceContext.getCreateDate(now));\n\t\tkbArticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tkbArticle.setRootResourcePrimKey(rootResourcePrimKey);\n\t\tkbArticle.setParentResourcePrimKey(parentResourcePrimKey);\n\t\tkbArticle.setVersion(KBArticleConstants.DEFAULT_VERSION);\n\t\tkbArticle.setTitle(title);\n\t\tkbArticle.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(kbArticleId, title, urlTitle, serviceContext));\n\t\tkbArticle.setContent(content);\n\t\tkbArticle.setDescription(description);\n\t\tkbArticle.setPriority(priority);\n\t\tkbArticle.setSections(\n\t\t\tStringUtil.merge(AdminUtil.escapeSections(sections)));\n\t\tkbArticle.setViewCount(0);\n\t\tkbArticle.setLatest(true);\n\t\tkbArticle.setMain(false);\n\t\tkbArticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\n\t\tkbArticlePersistence.update(kbArticle);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddKBArticleResources(\n\t\t\t\tkbArticle, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddKBArticleResources(\n\t\t\t\tkbArticle, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateKBArticleAsset(\n\t\t\tuserId, kbArticle, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Attachments\n\n\t\taddKBArticleAttachments(userId, kbArticle, dirName, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId, KBArticle.class.getName(),\n\t\t\tresourcePrimKey, kbArticle, serviceContext);\n\n\t\treturn kbArticle;\n\t}","id":538,"modified_method":"@Override\n\tpublic KBArticle addKBArticle(\n\t\t\tlong userId, long parentResourcePrimKey, String title,\n\t\t\tString urlTitle, String content, String description,\n\t\t\tString[] sections, String dirName, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// KB article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tdouble priority = getPriority(groupId, parentResourcePrimKey);\n\t\tDate now = new Date();\n\n\t\tvalidate(title, content);\n\n\t\tlong kbArticleId = counterLocalService.increment();\n\n\t\tlong resourcePrimKey = counterLocalService.increment();\n\n\t\tlong rootResourcePrimKey = getRootResourcePrimKey(\n\t\t\tresourcePrimKey, parentResourcePrimKey);\n\n\t\tKBArticle kbArticle = kbArticlePersistence.create(kbArticleId);\n\n\t\tkbArticle.setUuid(serviceContext.getUuid());\n\t\tkbArticle.setResourcePrimKey(resourcePrimKey);\n\t\tkbArticle.setGroupId(groupId);\n\t\tkbArticle.setCompanyId(user.getCompanyId());\n\t\tkbArticle.setUserId(user.getUserId());\n\t\tkbArticle.setUserName(user.getFullName());\n\t\tkbArticle.setCreateDate(serviceContext.getCreateDate(now));\n\t\tkbArticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tkbArticle.setRootResourcePrimKey(rootResourcePrimKey);\n\t\tkbArticle.setParentResourcePrimKey(parentResourcePrimKey);\n\t\tkbArticle.setVersion(KBArticleConstants.DEFAULT_VERSION);\n\t\tkbArticle.setTitle(title);\n\t\tkbArticle.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(kbArticleId, title, urlTitle, serviceContext));\n\t\tkbArticle.setContent(content);\n\t\tkbArticle.setDescription(description);\n\t\tkbArticle.setPriority(priority);\n\t\tkbArticle.setSections(\n\t\t\tStringUtil.merge(AdminUtil.escapeSections(sections)));\n\t\tkbArticle.setViewCount(0);\n\t\tkbArticle.setLatest(true);\n\t\tkbArticle.setMain(false);\n\t\tkbArticle.setStatus(WorkflowConstants.STATUS_DRAFT);\n\n\t\tkbArticlePersistence.update(kbArticle);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddKBArticleResources(\n\t\t\t\tkbArticle, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddKBArticleResources(\n\t\t\t\tkbArticle, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateKBArticleAsset(\n\t\t\tuserId, kbArticle, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Attachments\n\n\t\taddKBArticleAttachments(userId, kbArticle, dirName, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), groupId, userId, KBArticle.class.getName(),\n\t\t\tresourcePrimKey, kbArticle, serviceContext);\n\n\t\treturn kbArticle;\n\t}","commit_id":"8b20892619c4d0d4f6aa69bcb65c527a34218ba8","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalEvent addEvent(\n\t\t\tlong userId, String title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int endDateMonth,\n\t\t\tint endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tDate now = new Date();\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tCalendar endDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tendDate.set(Calendar.MONTH, endDateMonth);\n\t\tendDate.set(Calendar.DATE, endDateDay);\n\t\tendDate.set(Calendar.YEAR, endDateYear);\n\t\tendDate.set(Calendar.HOUR_OF_DAY, 23);\n\t\tendDate.set(Calendar.MINUTE, 59);\n\t\tendDate.set(Calendar.SECOND, 59);\n\t\tendDate.set(Calendar.MILLISECOND, 990);\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, endDateMonth,\n\t\t\tendDateDay, endDateYear, durationHour, durationMinute, allDay,\n\t\t\trepeating, recurrence);\n\n\t\tlong eventId = counterLocalService.increment();\n\n\t\tCalEvent event = calEventPersistence.create(eventId);\n\n\t\tevent.setUuid(serviceContext.getUuid());\n\t\tevent.setGroupId(groupId);\n\t\tevent.setCompanyId(user.getCompanyId());\n\t\tevent.setUserId(user.getUserId());\n\t\tevent.setUserName(user.getFullName());\n\t\tevent.setCreateDate(serviceContext.getCreateDate(now));\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate.getTime());\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, groupId, CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.ADD_EVENT, StringPool.BLANK, 0);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(CalEvent.class);\n\n\t\tindexer.reindex(event);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","id":539,"modified_method":"public CalEvent addEvent(\n\t\t\tlong userId, String title, String description, String location,\n\t\t\tint startDateMonth, int startDateDay, int startDateYear,\n\t\t\tint startDateHour, int startDateMinute, int endDateMonth,\n\t\t\tint endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tDate now = new Date();\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tCalendar endDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tendDate.set(Calendar.MONTH, endDateMonth);\n\t\tendDate.set(Calendar.DATE, endDateDay);\n\t\tendDate.set(Calendar.YEAR, endDateYear);\n\t\tendDate.set(Calendar.HOUR_OF_DAY, 23);\n\t\tendDate.set(Calendar.MINUTE, 59);\n\t\tendDate.set(Calendar.SECOND, 59);\n\t\tendDate.set(Calendar.MILLISECOND, 990);\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, endDateMonth,\n\t\t\tendDateDay, endDateYear, durationHour, durationMinute, allDay,\n\t\t\trepeating, recurrence);\n\n\t\tlong eventId = counterLocalService.increment();\n\n\t\tCalEvent event = calEventPersistence.create(eventId);\n\n\t\tevent.setUuid(serviceContext.getUuid());\n\t\tevent.setGroupId(groupId);\n\t\tevent.setCompanyId(user.getCompanyId());\n\t\tevent.setUserId(user.getUserId());\n\t\tevent.setUserName(user.getFullName());\n\t\tevent.setCreateDate(serviceContext.getCreateDate(now));\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate.getTime());\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEventResources(\n\t\t\t\tevent, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, groupId, CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.ADD_EVENT, StringPool.BLANK, 0);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(CalEvent.class);\n\n\t\tindexer.reindex(event);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","commit_id":"14a08167508c7f97c9b35e075441109cb0c2722c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CalEvent updateEvent(\n\t\t\tlong userId, long eventId, String title, String description,\n\t\t\tString location, int startDateMonth, int startDateDay,\n\t\t\tint startDateYear, int startDateHour, int startDateMinute,\n\t\t\tint endDateMonth, int endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tCalendar endDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tendDate.set(Calendar.MONTH, endDateMonth);\n\t\tendDate.set(Calendar.DATE, endDateDay);\n\t\tendDate.set(Calendar.YEAR, endDateYear);\n\t\tendDate.set(Calendar.HOUR_OF_DAY, 23);\n\t\tendDate.set(Calendar.MINUTE, 59);\n\t\tendDate.set(Calendar.SECOND, 59);\n\t\tendDate.set(Calendar.MILLISECOND, 990);\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, endDateMonth,\n\t\t\tendDateDay, endDateYear, durationHour, durationMinute, allDay,\n\t\t\trepeating, recurrence);\n\n\t\tCalEvent event = calEventPersistence.findByPrimaryKey(eventId);\n\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate.getTime());\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, event.getGroupId(), CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.UPDATE_EVENT, StringPool.BLANK, 0);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(CalEvent.class);\n\n\t\tindexer.reindex(event);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","id":540,"modified_method":"public CalEvent updateEvent(\n\t\t\tlong userId, long eventId, String title, String description,\n\t\t\tString location, int startDateMonth, int startDateDay,\n\t\t\tint startDateYear, int startDateHour, int startDateMinute,\n\t\t\tint endDateMonth, int endDateDay, int endDateYear, int durationHour,\n\t\t\tint durationMinute, boolean allDay, boolean timeZoneSensitive,\n\t\t\tString type, boolean repeating, TZSRecurrence recurrence,\n\t\t\tint remindBy, int firstReminder, int secondReminder,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Event\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tLocale locale = null;\n\t\tTimeZone timeZone = null;\n\n\t\tif (timeZoneSensitive) {\n\t\t\tlocale = user.getLocale();\n\t\t\ttimeZone = user.getTimeZone();\n\t\t}\n\t\telse {\n\t\t\tlocale = LocaleUtil.getDefault();\n\t\t\ttimeZone = TimeZoneUtil.getDefault();\n\t\t}\n\n\t\tCalendar startDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tstartDate.set(Calendar.MONTH, startDateMonth);\n\t\tstartDate.set(Calendar.DATE, startDateDay);\n\t\tstartDate.set(Calendar.YEAR, startDateYear);\n\t\tstartDate.set(Calendar.HOUR_OF_DAY, startDateHour);\n\t\tstartDate.set(Calendar.MINUTE, startDateMinute);\n\t\tstartDate.set(Calendar.SECOND, 0);\n\t\tstartDate.set(Calendar.MILLISECOND, 0);\n\n\t\tCalendar endDate = CalendarFactoryUtil.getCalendar(timeZone, locale);\n\n\t\tendDate.set(Calendar.MONTH, endDateMonth);\n\t\tendDate.set(Calendar.DATE, endDateDay);\n\t\tendDate.set(Calendar.YEAR, endDateYear);\n\t\tendDate.set(Calendar.HOUR_OF_DAY, 23);\n\t\tendDate.set(Calendar.MINUTE, 59);\n\t\tendDate.set(Calendar.SECOND, 59);\n\t\tendDate.set(Calendar.MILLISECOND, 990);\n\n\t\tif (allDay) {\n\t\t\tstartDate.set(Calendar.HOUR_OF_DAY, 0);\n\t\t\tstartDate.set(Calendar.MINUTE, 0);\n\n\t\t\tdurationHour = 24;\n\t\t\tdurationMinute = 0;\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, startDateMonth, startDateDay, startDateYear, endDateMonth,\n\t\t\tendDateDay, endDateYear, durationHour, durationMinute, allDay,\n\t\t\trepeating, recurrence);\n\n\t\tCalEvent event = calEventPersistence.findByPrimaryKey(eventId);\n\n\t\tevent.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tevent.setTitle(title);\n\t\tevent.setDescription(description);\n\t\tevent.setLocation(location);\n\t\tevent.setStartDate(startDate.getTime());\n\t\tevent.setEndDate(endDate.getTime());\n\t\tevent.setDurationHour(durationHour);\n\t\tevent.setDurationMinute(durationMinute);\n\t\tevent.setAllDay(allDay);\n\t\tevent.setTimeZoneSensitive(timeZoneSensitive);\n\t\tevent.setType(type);\n\t\tevent.setRepeating(repeating);\n\t\tevent.setRecurrenceObj(recurrence);\n\t\tevent.setRemindBy(remindBy);\n\t\tevent.setFirstReminder(firstReminder);\n\t\tevent.setSecondReminder(secondReminder);\n\t\tevent.setExpandoBridgeAttributes(serviceContext);\n\n\t\tcalEventPersistence.update(event, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, event, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, event.getGroupId(), CalEvent.class.getName(), eventId,\n\t\t\tCalendarActivityKeys.UPDATE_EVENT, StringPool.BLANK, 0);\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(CalEvent.class);\n\n\t\tindexer.reindex(event);\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\treturn event;\n\t}","commit_id":"14a08167508c7f97c9b35e075441109cb0c2722c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, CalEvent event, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, event.getGroupId(), CalEvent.class.getName(),\n\t\t\tevent.getEventId(), event.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, true, null, null, null, null, ContentTypes.TEXT_HTML,\n\t\t\tevent.getTitle(), event.getDescription(), null, null, null, 0, 0,\n\t\t\tnull, false);\n\t}","id":541,"modified_method":"public void updateAsset(\n\t\t\tlong userId, CalEvent event, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, event.getGroupId(), CalEvent.class.getName(),\n\t\t\tevent.getEventId(), event.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, true, null, null, null, null, ContentTypes.TEXT_HTML,\n\t\t\tevent.getTitle(), event.getDescription(), null, null, null, 0, 0,\n\t\t\tnull, false);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"14a08167508c7f97c9b35e075441109cb0c2722c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doVerify() throws Exception {\n\t\tList<CalEvent> events = CalEventLocalServiceUtil.getNoAssetEvents();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + events.size() + \" events with no asset\");\n\t\t}\n\n\t\tfor (CalEvent event : events) {\n\t\t\ttry {\n\t\t\t\tCalEventLocalServiceUtil.updateAsset(\n\t\t\t\t\tevent.getUserId(), event, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for event \" +\n\t\t\t\t\t\t\tevent.getEventId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for events\");\n\t\t}\n\n\t}","id":542,"modified_method":"protected void doVerify() throws Exception {\n\t\tList<CalEvent> events = CalEventLocalServiceUtil.getNoAssetEvents();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + events.size() + \" events with no asset\");\n\t\t}\n\n\t\tfor (CalEvent event : events) {\n\t\t\ttry {\n\t\t\t\tCalEventLocalServiceUtil.updateAsset(\n\t\t\t\t\tevent.getUserId(), event, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for event \" +\n\t\t\t\t\t\t\tevent.getEventId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for events\");\n\t\t}\n\n\t}","commit_id":"14a08167508c7f97c9b35e075441109cb0c2722c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BookmarksEntry updateEntry(\n\t\t\tlong userId, long entryId, long groupId, long folderId, String name,\n\t\t\tString url, String description, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tBookmarksEntry entry =\n\t\t\tbookmarksEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tif (Validator.isNull(name)) {\n\t\t\tname = url;\n\t\t}\n\n\t\tvalidate(url);\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setFolderId(folderId);\n\t\tentry.setName(name);\n\t\tentry.setUrl(url);\n\t\tentry.setDescription(description);\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tbookmarksEntryPersistence.update(entry, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tBookmarksEntry.class);\n\n\t\tindexer.reindex(entry);\n\n\t\treturn entry;\n\t}","id":543,"modified_method":"public BookmarksEntry updateEntry(\n\t\t\tlong userId, long entryId, long groupId, long folderId, String name,\n\t\t\tString url, String description, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tBookmarksEntry entry =\n\t\t\tbookmarksEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tif (Validator.isNull(name)) {\n\t\t\tname = url;\n\t\t}\n\n\t\tvalidate(url);\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setFolderId(folderId);\n\t\tentry.setName(name);\n\t\tentry.setUrl(url);\n\t\tentry.setDescription(description);\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tbookmarksEntryPersistence.update(entry, false);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tBookmarksEntry.class);\n\n\t\tindexer.reindex(entry);\n\n\t\treturn entry;\n\t}","commit_id":"6c60e5fadb8c14812d776cb978cc4a32b3bc1d17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BookmarksEntry addEntry(\n\t\t\tlong userId, long groupId, long folderId, String name, String url,\n\t\t\tString description, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (Validator.isNull(name)) {\n\t\t\tname = url;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(url);\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tBookmarksEntry entry = bookmarksEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setFolderId(folderId);\n\t\tentry.setName(name);\n\t\tentry.setUrl(url);\n\t\tentry.setDescription(description);\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tbookmarksEntryPersistence.update(entry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tBookmarksEntry.class);\n\n\t\tindexer.reindex(entry);\n\n\t\treturn entry;\n\t}","id":544,"modified_method":"public BookmarksEntry addEntry(\n\t\t\tlong userId, long groupId, long folderId, String name, String url,\n\t\t\tString description, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (Validator.isNull(name)) {\n\t\t\tname = url;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(url);\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tBookmarksEntry entry = bookmarksEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setFolderId(folderId);\n\t\tentry.setName(name);\n\t\tentry.setUrl(url);\n\t\tentry.setDescription(description);\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tbookmarksEntryPersistence.update(entry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddGroupPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getAddGroupPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tBookmarksEntry.class);\n\n\t\tindexer.reindex(entry);\n\n\t\treturn entry;\n\t}","commit_id":"6c60e5fadb8c14812d776cb978cc4a32b3bc1d17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateAsset(\n\t\t\tlong userId, BookmarksEntry entry, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tassetEntryLocalService.updateEntry(\n\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, true, null, null, null, null,\n\t\t\tContentTypes.TEXT_PLAIN, entry.getName(), entry.getDescription(),\n\t\t\tnull, null, entry.getUrl(), 0, 0, null, false);\n\t}","id":545,"modified_method":"public void updateAsset(\n\t\t\tlong userId, BookmarksEntry entry, long[] assetCategoryIds,\n\t\t\tString[] assetTagNames, long[] assetLinkEntryIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.updateEntry(\n\t\t\tuserId, entry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tentry.getEntryId(), entry.getUuid(), assetCategoryIds,\n\t\t\tassetTagNames, true, null, null, null, null,\n\t\t\tContentTypes.TEXT_PLAIN, entry.getName(), entry.getDescription(),\n\t\t\tnull, null, entry.getUrl(), 0, 0, null, false);\n\n\t\tassetLinkLocalService.updateLinks(\n\t\t\tuserId, assetEntry.getEntryId(), assetLinkEntryIds,\n\t\t\tAssetLinkConstants.TYPE_RELATED);\n\t}","commit_id":"6c60e5fadb8c14812d776cb978cc4a32b3bc1d17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doVerify() throws Exception {\n\t\tList<BookmarksEntry> entries =\n\t\t\tBookmarksEntryLocalServiceUtil.getNoAssetEntries();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + entries.size() + \" entries with no asset\");\n\t\t}\n\n\t\tfor (BookmarksEntry entry : entries) {\n\t\t\ttry {\n\t\t\t\tBookmarksEntryLocalServiceUtil.updateAsset(\n\t\t\t\t\tentry.getUserId(), entry, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for entry \" +\n\t\t\t\t\t\t\tentry.getEntryId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for entries\");\n\t\t}\n\t}","id":546,"modified_method":"protected void doVerify() throws Exception {\n\t\tList<BookmarksEntry> entries =\n\t\t\tBookmarksEntryLocalServiceUtil.getNoAssetEntries();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Processing \" + entries.size() + \" entries with no asset\");\n\t\t}\n\n\t\tfor (BookmarksEntry entry : entries) {\n\t\t\ttry {\n\t\t\t\tBookmarksEntryLocalServiceUtil.updateAsset(\n\t\t\t\t\tentry.getUserId(), entry, null, null, null);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to update asset for entry \" +\n\t\t\t\t\t\t\tentry.getEntryId() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Assets verified for entries\");\n\t\t}\n\t}","commit_id":"6c60e5fadb8c14812d776cb978cc4a32b3bc1d17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Don't forget to register new UpgradeCatalogs in {@link org.apache.ambari.server.upgrade.SchemaUpgradeHelper.UpgradeHelperModule#configure()}\n   *\n   * @param injector Guice injector to track dependencies and uses bindings to inject them.\n   */\n  @Inject\n  public UpgradeCatalog240(Injector injector) {\n    super(injector);\n    this.injector = injector;\n  }","id":547,"modified_method":"/**\n   * Don't forget to register new UpgradeCatalogs in {@link org.apache.ambari.server.upgrade.SchemaUpgradeHelper.UpgradeHelperModule#configure()}\n   *\n   * @param injector Guice injector to track dependencies and uses bindings to inject them.\n   */\n  @Inject\n  public UpgradeCatalog240(Injector injector) {\n    super(injector);\n    injector.injectMembers(this);\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void executeDDLUpdates() throws AmbariException, SQLException {\n    updateAdminPermissionTable();\n  }","id":548,"modified_method":"@Override\n  protected void executeDDLUpdates() throws AmbariException, SQLException {\n    updateAdminPermissionTable();\n    createSettingTable();\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"protected void updateAlerts() {\n    LOG.info(\"Updating alert definitions.\");\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    AlertDefinitionDAO alertDefinitionDAO = injector.getInstance(AlertDefinitionDAO.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    Map<String, Cluster> clusterMap = getCheckedClusterMap(clusters);\n    for (final Cluster cluster : clusterMap.values()) {\n      long clusterID = cluster.getClusterId();\n\n      final AlertDefinitionEntity namenodeLastCheckpointAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"namenode_last_checkpoint\");\n      final AlertDefinitionEntity namenodeHAHealthAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"namenode_ha_health\");\n      final AlertDefinitionEntity nodemanagerHealthAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"yarn_nodemanager_health\");\n      final AlertDefinitionEntity nodemanagerHealthSummaryAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"nodemanager_health_summary\");\n      final AlertDefinitionEntity hiveMetastoreProcessAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"hive_metastore_process\");\n      final AlertDefinitionEntity hiveServerProcessAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"hive_server_process\");\n      final AlertDefinitionEntity hiveWebhcatServerStatusAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"hive_webhcat_server_status\");\n      final AlertDefinitionEntity flumeAgentStatusAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"flume_agent_status\");\n\n      Map<AlertDefinitionEntity, List<String>> alertDefinitionParams = new HashMap<>();\n      checkedPutToMap(alertDefinitionParams, namenodeLastCheckpointAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"connection.timeout\", \"checkpoint.time.warning.threshold\", \"checkpoint.time.critical.threshold\")));\n      checkedPutToMap(alertDefinitionParams, namenodeHAHealthAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"connection.timeout\")));\n      checkedPutToMap(alertDefinitionParams, nodemanagerHealthAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"connection.timeout\")));\n      checkedPutToMap(alertDefinitionParams, nodemanagerHealthSummaryAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"connection.timeout\")));\n      checkedPutToMap(alertDefinitionParams, hiveMetastoreProcessAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"default.smoke.user\", \"default.smoke.principal\", \"default.smoke.keytab\")));\n      checkedPutToMap(alertDefinitionParams, hiveServerProcessAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"default.smoke.user\", \"default.smoke.principal\", \"default.smoke.keytab\")));\n      checkedPutToMap(alertDefinitionParams, hiveWebhcatServerStatusAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"default.smoke.user\", \"connection.timeout\")));\n      checkedPutToMap(alertDefinitionParams, flumeAgentStatusAlertDefinitionEntity,\n              new ArrayList<String>(Arrays.asList(\"run.directory\")));\n\n      for(Map.Entry<AlertDefinitionEntity, List<String>> entry : alertDefinitionParams.entrySet()){\n        AlertDefinitionEntity alertDefinition = entry.getKey();\n        String source = alertDefinition.getSource();\n\n        alertDefinition.setSource(addParam(source, entry.getValue()));\n        alertDefinition.setHash(UUID.randomUUID().toString());\n\n        alertDefinitionDAO.merge(alertDefinition);\n      }\n\n    }\n  }","id":549,"modified_method":"protected void updateAlerts() {\n    LOG.info(\"Updating alert definitions.\");\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    AlertDefinitionDAO alertDefinitionDAO = injector.getInstance(AlertDefinitionDAO.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    Map<String, Cluster> clusterMap = getCheckedClusterMap(clusters);\n    for (final Cluster cluster : clusterMap.values()) {\n      long clusterID = cluster.getClusterId();\n\n      final AlertDefinitionEntity namenodeLastCheckpointAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"namenode_last_checkpoint\");\n      final AlertDefinitionEntity namenodeHAHealthAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"namenode_ha_health\");\n      final AlertDefinitionEntity nodemanagerHealthAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"yarn_nodemanager_health\");\n      final AlertDefinitionEntity nodemanagerHealthSummaryAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"nodemanager_health_summary\");\n      final AlertDefinitionEntity hiveMetastoreProcessAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"hive_metastore_process\");\n      final AlertDefinitionEntity hiveServerProcessAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"hive_server_process\");\n      final AlertDefinitionEntity hiveWebhcatServerStatusAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"hive_webhcat_server_status\");\n      final AlertDefinitionEntity flumeAgentStatusAlertDefinitionEntity = alertDefinitionDAO.findByName(\n              clusterID, \"flume_agent_status\");\n\n      Map<AlertDefinitionEntity, List<String>> alertDefinitionParams = new HashMap<>();\n      checkedPutToMap(alertDefinitionParams, namenodeLastCheckpointAlertDefinitionEntity,\n              Lists.newArrayList(\"connection.timeout\", \"checkpoint.time.warning.threshold\", \"checkpoint.time.critical.threshold\"));\n      checkedPutToMap(alertDefinitionParams, namenodeHAHealthAlertDefinitionEntity,\n              Lists.newArrayList(\"connection.timeout\"));\n      checkedPutToMap(alertDefinitionParams, nodemanagerHealthAlertDefinitionEntity,\n              Lists.newArrayList(\"connection.timeout\"));\n      checkedPutToMap(alertDefinitionParams, nodemanagerHealthSummaryAlertDefinitionEntity,\n              Lists.newArrayList(\"connection.timeout\"));\n      checkedPutToMap(alertDefinitionParams, hiveMetastoreProcessAlertDefinitionEntity,\n              Lists.newArrayList(\"default.smoke.user\", \"default.smoke.principal\", \"default.smoke.keytab\"));\n      checkedPutToMap(alertDefinitionParams, hiveServerProcessAlertDefinitionEntity,\n              Lists.newArrayList(\"default.smoke.user\", \"default.smoke.principal\", \"default.smoke.keytab\"));\n      checkedPutToMap(alertDefinitionParams, hiveWebhcatServerStatusAlertDefinitionEntity,\n              Lists.newArrayList(\"default.smoke.user\", \"connection.timeout\"));\n      checkedPutToMap(alertDefinitionParams, flumeAgentStatusAlertDefinitionEntity,\n              Lists.newArrayList(\"run.directory\"));\n\n      for(Map.Entry<AlertDefinitionEntity, List<String>> entry : alertDefinitionParams.entrySet()){\n        AlertDefinitionEntity alertDefinition = entry.getKey();\n        String source = alertDefinition.getSource();\n\n        alertDefinition.setSource(addParam(source, entry.getValue()));\n        alertDefinition.setHash(UUID.randomUUID().toString());\n\n        alertDefinitionDAO.merge(alertDefinition);\n      }\n\n    }\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n    addNewConfigurationsFromXml();\n    updateAlerts();\n    setRoleSortOrder();\n\n  }","id":550,"modified_method":"@Override\n  protected void executeDMLUpdates() throws AmbariException, SQLException {\n    addNewConfigurationsFromXml();\n    updateAlerts();\n    setRoleSortOrder();\n    addSettingPermission();\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void test_addParam_ParamsAvailableWithOneOFNeededItem() {\n\n    UpgradeCatalog240 upgradeCatalog240 = new UpgradeCatalog240(injector);\n    String inputSource = \"{\\\"path\\\":\\\"test_path\\\",\\\"type\\\":\\\"SCRIPT\\\",\\\"parameters\\\":[{\\\"name\\\":\\\"connection.timeout\\\",\\\"display_name\\\":\\\"Connection Timeout\\\",\\\"value\\\":5.0,\\\"type\\\":\\\"NUMERIC\\\",\\\"description\\\":\\\"The maximum time before this alert is considered to be CRITICAL\\\",\\\"units\\\":\\\"seconds\\\",\\\"threshold\\\":\\\"CRITICAL\\\"}]}\";\n    List<String> params = new ArrayList<String>(Arrays.asList(\"connection.timeout\", \"checkpoint.time.warning.threshold\", \"checkpoint.time.critical.threshold\"));\n    String expectedSource = \"{\\\"path\\\":\\\"test_path\\\",\\\"type\\\":\\\"SCRIPT\\\",\\\"parameters\\\":[{\\\"name\\\":\\\"connection.timeout\\\",\\\"display_name\\\":\\\"Connection Timeout\\\",\\\"value\\\":5.0,\\\"type\\\":\\\"NUMERIC\\\",\\\"description\\\":\\\"The maximum time before this alert is considered to be CRITICAL\\\",\\\"units\\\":\\\"seconds\\\",\\\"threshold\\\":\\\"CRITICAL\\\"},{\\\"name\\\":\\\"checkpoint.time.warning.threshold\\\",\\\"display_name\\\":\\\"Checkpoint Warning\\\",\\\"value\\\":2.0,\\\"type\\\":\\\"PERCENT\\\",\\\"description\\\":\\\"The percentage of the last checkpoint time greater than the interval in order to trigger a warning alert.\\\",\\\"units\\\":\\\"%\\\",\\\"threshold\\\":\\\"WARNING\\\"},{\\\"name\\\":\\\"checkpoint.time.critical.threshold\\\",\\\"display_name\\\":\\\"Checkpoint Critical\\\",\\\"value\\\":2.0,\\\"type\\\":\\\"PERCENT\\\",\\\"description\\\":\\\"The percentage of the last checkpoint time greater than the interval in order to trigger a critical alert.\\\",\\\"units\\\":\\\"%\\\",\\\"threshold\\\":\\\"CRITICAL\\\"}]}\";\n\n    String result = upgradeCatalog240.addParam(inputSource, params);\n    Assert.assertEquals(result, expectedSource);\n  }","id":551,"modified_method":"@Test\n  public void test_addParam_ParamsAvailableWithOneOFNeededItem() {\n\n    UpgradeCatalog240 upgradeCatalog240 = new UpgradeCatalog240(injector);\n    String inputSource = \"{\\\"path\\\":\\\"test_path\\\",\\\"type\\\":\\\"SCRIPT\\\",\\\"parameters\\\":[{\\\"name\\\":\\\"connection.timeout\\\",\\\"display_name\\\":\\\"Connection Timeout\\\",\\\"value\\\":5.0,\\\"type\\\":\\\"NUMERIC\\\",\\\"description\\\":\\\"The maximum time before this alert is considered to be CRITICAL\\\",\\\"units\\\":\\\"seconds\\\",\\\"threshold\\\":\\\"CRITICAL\\\"}]}\";\n    List<String> params = new ArrayList<>(Arrays.asList(\"connection.timeout\", \"checkpoint.time.warning.threshold\", \"checkpoint.time.critical.threshold\"));\n    String expectedSource = \"{\\\"path\\\":\\\"test_path\\\",\\\"type\\\":\\\"SCRIPT\\\",\\\"parameters\\\":[{\\\"name\\\":\\\"connection.timeout\\\",\\\"display_name\\\":\\\"Connection Timeout\\\",\\\"value\\\":5.0,\\\"type\\\":\\\"NUMERIC\\\",\\\"description\\\":\\\"The maximum time before this alert is considered to be CRITICAL\\\",\\\"units\\\":\\\"seconds\\\",\\\"threshold\\\":\\\"CRITICAL\\\"},{\\\"name\\\":\\\"checkpoint.time.warning.threshold\\\",\\\"display_name\\\":\\\"Checkpoint Warning\\\",\\\"value\\\":2.0,\\\"type\\\":\\\"PERCENT\\\",\\\"description\\\":\\\"The percentage of the last checkpoint time greater than the interval in order to trigger a warning alert.\\\",\\\"units\\\":\\\"%\\\",\\\"threshold\\\":\\\"WARNING\\\"},{\\\"name\\\":\\\"checkpoint.time.critical.threshold\\\",\\\"display_name\\\":\\\"Checkpoint Critical\\\",\\\"value\\\":2.0,\\\"type\\\":\\\"PERCENT\\\",\\\"description\\\":\\\"The percentage of the last checkpoint time greater than the interval in order to trigger a critical alert.\\\",\\\"units\\\":\\\"%\\\",\\\"threshold\\\":\\\"CRITICAL\\\"}]}\";\n\n    String result = upgradeCatalog240.addParam(inputSource, params);\n    Assert.assertEquals(result, expectedSource);\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@After\n  public void tearDown() {\n    injector.getInstance(PersistService.class).stop();\n  }","id":552,"modified_method":"@After\n  public void tearDown() {\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@Before\n  public void init() {\n    reset(entityManagerProvider);\n    expect(entityManagerProvider.get()).andReturn(entityManager).anyTimes();\n    replay(entityManagerProvider);\n    injector = Guice.createInjector(new InMemoryDefaultTestModule());\n    injector.getInstance(GuiceJpaInitializer.class);\n\n    upgradeCatalogHelper = injector.getInstance(UpgradeCatalogHelper.class);\n    // inject AmbariMetaInfo to ensure that stacks get populated in the DB\n    injector.getInstance(AmbariMetaInfo.class);\n    // load the stack entity\n    StackDAO stackDAO = injector.getInstance(StackDAO.class);\n    desiredStackEntity = stackDAO.find(\"HDP\", \"2.2.0\");\n  }","id":553,"modified_method":"@Before\n  public void init() {\n    reset(entityManagerProvider);\n    expect(entityManagerProvider.get()).andReturn(entityManager).anyTimes();\n    replay(entityManagerProvider);\n\n    injector.getInstance(UpgradeCatalogHelper.class);\n    // inject AmbariMetaInfo to ensure that stacks get populated in the DB\n    injector.getInstance(AmbariMetaInfo.class);\n    // load the stack entity\n    StackDAO stackDAO = injector.getInstance(StackDAO.class);\n    stackDAO.find(\"HDP\", \"2.2.0\");\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Method addNewConfigurationsFromXml = AbstractUpgradeCatalog.class.getDeclaredMethod(\"addNewConfigurationsFromXml\");\n    Method updateAlerts = UpgradeCatalog240.class.getDeclaredMethod(\"updateAlerts\");\n\n    Capture<String> capturedStatements = newCapture(CaptureType.ALL);\n\n    DBAccessor dbAccessor = createStrictMock(DBAccessor.class);\n    expect(dbAccessor.executeUpdate(capture(capturedStatements))).andReturn(1).times(7);\n\n    UpgradeCatalog240 upgradeCatalog240 = createMockBuilder(UpgradeCatalog240.class)\n            .addMockedMethod(addNewConfigurationsFromXml)\n            .addMockedMethod(updateAlerts)\n            .createMock();\n\n    Field field = AbstractUpgradeCatalog.class.getDeclaredField(\"dbAccessor\");\n    field.set(upgradeCatalog240, dbAccessor);\n\n    upgradeCatalog240.addNewConfigurationsFromXml();\n    expectLastCall().once();\n    upgradeCatalog240.updateAlerts();\n    expectLastCall().once();\n\n    replay(upgradeCatalog240, dbAccessor);\n\n    upgradeCatalog240.executeDMLUpdates();\n\n    verify(upgradeCatalog240, dbAccessor);\n\n    List<String> statements = capturedStatements.getValues();\n    Assert.assertNotNull(statements);\n    Assert.assertEquals(7, statements.size());\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=1 WHERE permission_name='AMBARI.ADMINISTRATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=2 WHERE permission_name='CLUSTER.ADMINISTRATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=3 WHERE permission_name='CLUSTER.OPERATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=4 WHERE permission_name='SERVICE.ADMINISTRATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=5 WHERE permission_name='SERVICE.OPERATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=6 WHERE permission_name='CLUSTER.USER'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=7 WHERE permission_name='VIEW.USER'\"));\n  }","id":554,"modified_method":"@Test\n  public void testExecuteDMLUpdates() throws Exception {\n    Method addNewConfigurationsFromXml = AbstractUpgradeCatalog.class.getDeclaredMethod(\"addNewConfigurationsFromXml\");\n    Method updateAlerts = UpgradeCatalog240.class.getDeclaredMethod(\"updateAlerts\");\n    Method addSettingPermission = UpgradeCatalog240.class.getDeclaredMethod(\"addSettingPermission\");\n\n    Capture<String> capturedStatements = newCapture(CaptureType.ALL);\n\n    DBAccessor dbAccessor = createStrictMock(DBAccessor.class);\n    expect(dbAccessor.executeUpdate(capture(capturedStatements))).andReturn(1).times(7);\n\n    UpgradeCatalog240 upgradeCatalog240 = createMockBuilder(UpgradeCatalog240.class)\n            .addMockedMethod(addNewConfigurationsFromXml)\n            .addMockedMethod(updateAlerts)\n            .addMockedMethod(addSettingPermission)\n            .createMock();\n\n    Field field = AbstractUpgradeCatalog.class.getDeclaredField(\"dbAccessor\");\n    field.set(upgradeCatalog240, dbAccessor);\n\n    upgradeCatalog240.addNewConfigurationsFromXml();\n    upgradeCatalog240.updateAlerts();\n    upgradeCatalog240.addSettingPermission();\n\n    replay(upgradeCatalog240, dbAccessor);\n\n    upgradeCatalog240.executeDMLUpdates();\n\n    verify(upgradeCatalog240, dbAccessor);\n\n    List<String> statements = capturedStatements.getValues();\n    Assert.assertNotNull(statements);\n    Assert.assertEquals(7, statements.size());\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=1 WHERE permission_name='AMBARI.ADMINISTRATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=2 WHERE permission_name='CLUSTER.ADMINISTRATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=3 WHERE permission_name='CLUSTER.OPERATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=4 WHERE permission_name='SERVICE.ADMINISTRATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=5 WHERE permission_name='SERVICE.OPERATOR'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=6 WHERE permission_name='CLUSTER.USER'\"));\n    Assert.assertTrue(statements.contains(\"UPDATE adminpermission SET sort_order=7 WHERE permission_name='VIEW.USER'\"));\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecuteDDLUpdates() throws Exception {\n    UpgradeCatalog240 upgradeCatalog240 = injector.getInstance(UpgradeCatalog240.class);\n\n    Capture<DBAccessor.DBColumnInfo> capturedColumnInfo = newCapture();\n\n    DBAccessor dbAccessor = createStrictMock(DBAccessor.class);\n    dbAccessor.addColumn(eq(\"adminpermission\"), capture(capturedColumnInfo));\n    expectLastCall().once();\n\n    Field field = AbstractUpgradeCatalog.class.getDeclaredField(\"dbAccessor\");\n    field.set(upgradeCatalog240, dbAccessor);\n\n    replay(dbAccessor);\n\n    upgradeCatalog240.executeDDLUpdates();\n\n    verify(dbAccessor);\n\n    DBAccessor.DBColumnInfo columnInfo = capturedColumnInfo.getValue();\n    Assert.assertNotNull(columnInfo);\n    Assert.assertEquals(UpgradeCatalog240.SORT_ORDER_COL, columnInfo.getName());\n    Assert.assertEquals(null, columnInfo.getLength());\n    Assert.assertEquals(Short.class, columnInfo.getType());\n    Assert.assertEquals(1, columnInfo.getDefaultValue());\n    Assert.assertEquals(false, columnInfo.isNullable());\n  }","id":555,"modified_method":"@Test\n  public void testExecuteDDLUpdates() throws SQLException, AmbariException {\n    Capture<DBAccessor.DBColumnInfo> capturedColumnInfo = newCapture();\n    final DBAccessor dbAccessor = createStrictMock(DBAccessor.class);\n    Configuration configuration = createNiceMock(Configuration.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n    Capture<List<DBAccessor.DBColumnInfo>> capturedSettingColumns = EasyMock.newCapture();\n\n    dbAccessor.addColumn(eq(\"adminpermission\"), capture(capturedColumnInfo));\n    dbAccessor.createTable(eq(\"setting\"), capture(capturedSettingColumns), eq(\"id\"));\n    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();\n    expect(dbAccessor.getConnection()).andReturn(connection);\n    expect(connection.createStatement()).andReturn(statement);\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet);\n\n    replay(dbAccessor);\n    Module module = new Module() {\n      @Override\n      public void configure(Binder binder) {\n        binder.bind(DBAccessor.class).toInstance(dbAccessor);\n        binder.bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class));\n        binder.bind(EntityManager.class).toInstance(entityManager);\n      }\n    };\n\n    Injector injector = Guice.createInjector(module);\n    UpgradeCatalog240 upgradeCatalog240 = injector.getInstance(UpgradeCatalog240.class);\n    upgradeCatalog240.executeDDLUpdates();\n\n    DBAccessor.DBColumnInfo columnInfo = capturedColumnInfo.getValue();\n    Assert.assertNotNull(columnInfo);\n    Assert.assertEquals(UpgradeCatalog240.SORT_ORDER_COL, columnInfo.getName());\n    Assert.assertEquals(null, columnInfo.getLength());\n    Assert.assertEquals(Short.class, columnInfo.getType());\n    Assert.assertEquals(1, columnInfo.getDefaultValue());\n    Assert.assertEquals(false, columnInfo.isNullable());\n\n    Map<String, Class> expectedCaptures = new HashMap<>();\n    expectedCaptures.put(\"id\", Long.class);\n    expectedCaptures.put(\"name\", String.class);\n    expectedCaptures.put(\"setting_type\", String.class);\n    expectedCaptures.put(\"content\", String.class);\n    expectedCaptures.put(\"updated_by\", String.class);\n    expectedCaptures.put(\"update_timestamp\", Long.class);\n\n    Map<String, Class> actualCaptures = new HashMap<>();\n    for(DBAccessor.DBColumnInfo settingColumnInfo : capturedSettingColumns.getValue()) {\n      actualCaptures.put(settingColumnInfo.getName(), settingColumnInfo.getType());\n    }\n    assertEquals(expectedCaptures, actualCaptures);\n\n    verify(dbAccessor);\n  }","commit_id":"7d06e8bf68abe725620c0eb60cce16959901c747","url":"https://github.com/apache/ambari"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserAccount disableUser(Long userId) {\n        UserVO user = _userDao.findById(userId);\n        if (user == null || user.getRemoved() != null) {\n            throw new InvalidParameterValueException(\"Unable to find active user by id \" + userId);\n        }        \n\n        int regionId = user.getRegionId();\n\n        String command = \"disableUser\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, user.getUuid()));\n\n        if(getId() == regionId){\n            return _accountMgr.disableUser(userId);\n        } else {\n            //First disable in the Region where user was created\n            Region region = _regionDao.findById(regionId);\n            UserAccount disabledUser = RegionsApiUtil.makeUserAccountAPICall(region, command, params);\n            if (disabledUser != null) {\n                s_logger.debug(\"Successfully disabled user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n                return disabledUser;\n            } else {\n                throw new CloudRuntimeException(\"Error while disabling user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":556,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserAccount disableUser(Long userId) {\n        UserVO user = _userDao.findById(userId);\n        if (user == null || user.getRemoved() != null) {\n            throw new InvalidParameterValueException(\"Unable to find active user by id \" + userId);\n        }        \n\n        int regionId = user.getRegionId();\n\n        String command = \"disableUser\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, user.getUuid()));\n\n        if(getId() == regionId){\n            return _accountMgr.disableUser(userId);\n        } else {\n            //First disable in the Region where user was created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully disabled user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n                return _userAccountDao.findById(userId);\n            } else {\n                throw new CloudRuntimeException(\"Error while disabling user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Domain updateDomain(UpdateDomainCmd cmd) {\n        long id = cmd.getId();\n        DomainVO domain = _domainDao.findById(id);\n        if(domain == null){\n            throw new InvalidParameterValueException(\"The specified domain doesn't exist in the system\");\n        }\n\n        String domainUUID = domain.getUuid();\n\n        String command = \"updateDomain\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, domainUUID));\n        params.add(new NameValuePair(ApiConstants.NAME, cmd.getDomainName()));\n        params.add(new NameValuePair(ApiConstants.NETWORK_DOMAIN, cmd.getNetworkDomain()));\n\n        int regionId = domain.getRegionId();\n        if(getId() == regionId){\n            return _domainMgr.updateDomain(cmd);\n        } else {\n            //First update in the Region where domain was created\n            Region region = _regionDao.findById(regionId);\n            RegionDomain updatedDomain = RegionsApiUtil.makeDomainAPICall(region, command, params);\n            if (updatedDomain != null) {\n                Long parentId = _identityDao.getIdentityId(\"domain\", updatedDomain.getParentUuid());\n                updatedDomain.setParent(parentId);\n                s_logger.debug(\"Successfully updated user :\"+domainUUID+\" in source Region: \"+region.getId());\n                return (DomainVO)updatedDomain;\n            } else {\n                throw new CloudRuntimeException(\"Error while updating user :\"+domainUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":557,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Domain updateDomain(UpdateDomainCmd cmd) {\n        long id = cmd.getId();\n        DomainVO domain = _domainDao.findById(id);\n        if(domain == null){\n            throw new InvalidParameterValueException(\"The specified domain doesn't exist in the system\");\n        }\n\n        String domainUUID = domain.getUuid();\n\n        String command = \"updateDomain\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, domainUUID));\n        params.add(new NameValuePair(ApiConstants.NAME, cmd.getDomainName()));\n        params.add(new NameValuePair(ApiConstants.NETWORK_DOMAIN, cmd.getNetworkDomain()));\n\n        int regionId = domain.getRegionId();\n        if(getId() == regionId){\n            return _domainMgr.updateDomain(cmd);\n        } else {\n            //First update in the Region where domain was created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully updated user :\"+domainUUID+\" in source Region: \"+region.getId());\n                return domain;\n            } else {\n                throw new CloudRuntimeException(\"Error while updating user :\"+domainUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * {@inheritDoc}\n     */ \n    @Override\n    public Account updateAccount(UpdateAccountCmd cmd) {\n        Long accountId = cmd.getId();\n        Long domainId = cmd.getDomainId();\n        DomainVO domain = _domainDao.findById(domainId);\n        String accountName = cmd.getAccountName();\n        String newAccountName = cmd.getNewName();\n        String networkDomain = cmd.getNetworkDomain();\n        //ToDo send details\n        Map<String, String> details = cmd.getDetails();\n\n        Account account = null;\n        if (accountId != null) {\n            account = _accountDao.findById(accountId);\n        } else {\n            account = _accountDao.findEnabledAccount(accountName, domainId);\n        }\n\n        // Check if account exists\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            s_logger.error(\"Unable to find account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n        }\n\n        String command = \"updateAccount\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.NEW_NAME, newAccountName));\n        params.add(new NameValuePair(ApiConstants.ID, account.getUuid()));\n        params.add(new NameValuePair(ApiConstants.ACCOUNT, accountName));\n        params.add(new NameValuePair(ApiConstants.DOMAIN_ID, domain.getUuid()));\n        params.add(new NameValuePair(ApiConstants.NETWORK_DOMAIN, networkDomain));\n        params.add(new NameValuePair(ApiConstants.NEW_NAME, newAccountName));\n        if(details != null){\n            params.add(new NameValuePair(ApiConstants.ACCOUNT_DETAILS, details.toString()));\n        }\n        int regionId = account.getRegionId();\n        if(getId() == regionId){\n            return _accountMgr.updateAccount(cmd);\n        } else {\n            //First update in the Region where account is created\n            Region region = _regionDao.findById(regionId);\n            RegionAccount updatedAccount = RegionsApiUtil.makeAccountAPICall(region, command, params);\n            if (updatedAccount != null) {\n                Long id = _identityDao.getIdentityId(\"account\", updatedAccount.getUuid());\n                updatedAccount.setId(id);\n                Long domainID = _identityDao.getIdentityId(\"domain\", updatedAccount.getDomainUuid());\n                updatedAccount.setDomainId(domainID);\n                s_logger.debug(\"Successfully updated account :\"+account.getUuid()+\" in source Region: \"+region.getId());\n                return updatedAccount;\n            } else {\n                throw new CloudRuntimeException(\"Error while updating account :\"+account.getUuid()+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":558,"modified_method":"/**\n     * {@inheritDoc}\n     */ \n    @Override\n    public Account updateAccount(UpdateAccountCmd cmd) {\n        Long accountId = cmd.getId();\n        Long domainId = cmd.getDomainId();\n        DomainVO domain = _domainDao.findById(domainId);\n        String accountName = cmd.getAccountName();\n        String newAccountName = cmd.getNewName();\n        String networkDomain = cmd.getNetworkDomain();\n        //ToDo send details\n        Map<String, String> details = cmd.getDetails();\n\n        Account account = null;\n        if (accountId != null) {\n            account = _accountDao.findById(accountId);\n        } else {\n            account = _accountDao.findEnabledAccount(accountName, domainId);\n        }\n\n        // Check if account exists\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            s_logger.error(\"Unable to find account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n        }\n\n        String command = \"updateAccount\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, account.getUuid()));\n        params.add(new NameValuePair(ApiConstants.ACCOUNT, accountName));\n        params.add(new NameValuePair(ApiConstants.DOMAIN_ID, domain.getUuid()));\n        params.add(new NameValuePair(ApiConstants.NETWORK_DOMAIN, networkDomain));\n        params.add(new NameValuePair(ApiConstants.NEW_NAME, newAccountName));\n        if(details != null){\n            params.add(new NameValuePair(ApiConstants.ACCOUNT_DETAILS, details.toString()));\n        }\n        int regionId = account.getRegionId();\n        if(getId() == regionId){\n            return _accountMgr.updateAccount(cmd);\n        } else {\n            //First update in the Region where account is created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully updated account :\"+account.getUuid()+\" in source Region: \"+region.getId());\n                return account;\n            } else {\n                throw new CloudRuntimeException(\"Error while updating account :\"+account.getUuid()+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * {@inheritDoc}\n     */ \n    @Override\n    public Account enableAccount(String accountName, Long domainId, Long accountId) {\n        // Check if account exists\n        Account account = null;\n        if (accountId != null) {\n            account = _accountDao.findById(accountId);\n        } else {\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n        }\n\n        String accountUUID = account.getUuid();\n\n        String command = \"enableAccount\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, accountUUID));\n        params.add(new NameValuePair(ApiConstants.ACCOUNT, accountName));\n        DomainVO domain = _domainDao.findById(domainId);\n        if(domain != null){\n            params.add(new NameValuePair(ApiConstants.DOMAIN_ID, domain.getUuid()));\n        }\n\n        int regionId = account.getRegionId();\n        if(getId() == regionId){\n            return _accountMgr.enableAccount(accountName, domainId, accountId);\n        } else {\n            //First disable account in the Region where account is created\n            Region region = _regionDao.findById(regionId);\n            Account retAccount = RegionsApiUtil.makeAccountAPICall(region, command, params);\n            if (retAccount != null) {\n                s_logger.debug(\"Successfully enabled account :\"+accountUUID+\" in source Region: \"+region.getId());\n                return retAccount;\n            } else {\n                throw new CloudRuntimeException(\"Error while enabling account :\"+accountUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":559,"modified_method":"/**\n     * {@inheritDoc}\n     */ \n    @Override\n    public Account enableAccount(String accountName, Long domainId, Long accountId) {\n        // Check if account exists\n        Account account = null;\n        if (accountId != null) {\n            account = _accountDao.findById(accountId);\n        } else {\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n        }\n\n        String accountUUID = account.getUuid();\n\n        String command = \"enableAccount\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, accountUUID));\n        params.add(new NameValuePair(ApiConstants.ACCOUNT, accountName));\n        DomainVO domain = _domainDao.findById(domainId);\n        if(domain != null){\n            params.add(new NameValuePair(ApiConstants.DOMAIN_ID, domain.getUuid()));\n        }\n\n        int regionId = account.getRegionId();\n        if(getId() == regionId){\n            return _accountMgr.enableAccount(accountName, domainId, accountId);\n        } else {\n            //First disable account in the Region where account is created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully enabled account :\"+accountUUID+\" in source Region: \"+region.getId());\n                return account;\n            } else {\n                throw new CloudRuntimeException(\"Error while enabling account :\"+accountUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserAccount updateUser(UpdateUserCmd cmd) {\n        long id = cmd.getId();\n\n        UserVO user = _userDao.findById(id);\n        if (user == null) {\n            throw new InvalidParameterValueException(\"The specified user doesn't exist in the system\");\n        }\n\n        String userUUID = user.getUuid();\n\n        String command = \"updateUser\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, userUUID));\n        params.add(new NameValuePair(ApiConstants.API_KEY, cmd.getApiKey()));\n        params.add(new NameValuePair(ApiConstants.EMAIL, cmd.getEmail()));\n        params.add(new NameValuePair(ApiConstants.FIRSTNAME, cmd.getFirstname()));\n        params.add(new NameValuePair(ApiConstants.LASTNAME, cmd.getLastname()));\n        params.add(new NameValuePair(ApiConstants.PASSWORD, cmd.getPassword()));\n        params.add(new NameValuePair(ApiConstants.SECRET_KEY, cmd.getSecretKey()));\n        params.add(new NameValuePair(ApiConstants.TIMEZONE, cmd.getTimezone()));\n        params.add(new NameValuePair(ApiConstants.USERNAME, cmd.getUsername()));\n\n        int regionId = user.getRegionId();\n        if(getId() == regionId){\n            return _accountMgr.updateUser(cmd);\n        } else {\n            //First update in the Region where user was created\n            Region region = _regionDao.findById(regionId);\n            UserAccount updateUser = RegionsApiUtil.makeUserAccountAPICall(region, command, params);\n            if (updateUser != null) {\n                s_logger.debug(\"Successfully updated user :\"+userUUID+\" in source Region: \"+region.getId());\n                return updateUser;\n            } else {\n                throw new CloudRuntimeException(\"Error while updating user :\"+userUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":560,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserAccount updateUser(UpdateUserCmd cmd) {\n        long id = cmd.getId();\n\n        UserVO user = _userDao.findById(id);\n        if (user == null) {\n            throw new InvalidParameterValueException(\"The specified user doesn't exist in the system\");\n        }\n\n        String userUUID = user.getUuid();\n\n        String command = \"updateUser\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, userUUID));\n        params.add(new NameValuePair(ApiConstants.API_KEY, cmd.getApiKey()));\n        params.add(new NameValuePair(ApiConstants.EMAIL, cmd.getEmail()));\n        params.add(new NameValuePair(ApiConstants.FIRSTNAME, cmd.getFirstname()));\n        params.add(new NameValuePair(ApiConstants.LASTNAME, cmd.getLastname()));\n        params.add(new NameValuePair(ApiConstants.PASSWORD, cmd.getPassword()));\n        params.add(new NameValuePair(ApiConstants.SECRET_KEY, cmd.getSecretKey()));\n        params.add(new NameValuePair(ApiConstants.TIMEZONE, cmd.getTimezone()));\n        params.add(new NameValuePair(ApiConstants.USERNAME, cmd.getUsername()));\n\n        int regionId = user.getRegionId();\n        if(getId() == regionId){\n            return _accountMgr.updateUser(cmd);\n        } else {\n            //First update in the Region where user was created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully updated user :\"+userUUID+\" in source Region: \"+region.getId());\n                return _userAccountDao.findById(id);\n            } else {\n                throw new CloudRuntimeException(\"Error while updating user :\"+userUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * {@inheritDoc}\n     */ \n    @Override\n    public Account disableAccount(String accountName, Long domainId, Long accountId, Boolean lockRequested) throws ConcurrentOperationException, ResourceUnavailableException {\n        Account account = null;\n        if (accountId != null) {\n            account = _accountDao.findById(accountId);\n        } else {\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find active account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n        }\n\n        String accountUUID = account.getUuid();\n\n        String command = \"disableAccount\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.LOCK, lockRequested.toString()));\n        params.add(new NameValuePair(ApiConstants.ID, accountUUID));\n        DomainVO domain = _domainDao.findById(domainId);\n        if(domain != null){\n            params.add(new NameValuePair(ApiConstants.DOMAIN_ID, domain.getUuid()));\n        }\n\n        int regionId = account.getRegionId();\n        if(getId() == regionId){\n            Account retAccount = null;\n            if(lockRequested){\n                retAccount = _accountMgr.lockAccount(accountName, domainId, accountId);\n            } else {\n                retAccount = _accountMgr.disableAccount(accountName, domainId, accountId);\n            }\n            return retAccount;\n        } else {\n            //First disable account in the Region where account is created\n            Region region = _regionDao.findById(regionId);\n            Account retAccount = RegionsApiUtil.makeAccountAPICall(region, command, params);\n            if (retAccount != null) {\n                s_logger.debug(\"Successfully disabled account :\"+accountUUID+\" in source Region: \"+region.getId());\n                return retAccount;\n            } else {\n                throw new CloudRuntimeException(\"Error while disabling account :\"+accountUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":561,"modified_method":"/**\n     * {@inheritDoc}\n     */ \n    @Override\n    public Account disableAccount(String accountName, Long domainId, Long accountId, Boolean lockRequested) throws ConcurrentOperationException, ResourceUnavailableException {\n        Account account = null;\n        if (accountId != null) {\n            account = _accountDao.findById(accountId);\n        } else {\n            account = _accountDao.findActiveAccount(accountName, domainId);\n        }\n\n        if (account == null || account.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Unable to find active account by accountId: \" + accountId + \" OR by name: \" + accountName + \" in domain \" + domainId);\n        }\n\n        String accountUUID = account.getUuid();\n\n        String command = \"disableAccount\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.LOCK, lockRequested.toString()));\n        params.add(new NameValuePair(ApiConstants.ID, accountUUID));\n        DomainVO domain = _domainDao.findById(domainId);\n        if(domain != null){\n            params.add(new NameValuePair(ApiConstants.DOMAIN_ID, domain.getUuid()));\n        }\n\n        int regionId = account.getRegionId();\n        if(getId() == regionId){\n            Account retAccount = null;\n            if(lockRequested){\n                retAccount = _accountMgr.lockAccount(accountName, domainId, accountId);\n            } else {\n                retAccount = _accountMgr.disableAccount(accountName, domainId, accountId);\n            }\n            return retAccount;\n        } else {\n            //First disable account in the Region where account is created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully disabled account :\"+accountUUID+\" in source Region: \"+region.getId());\n                return account;\n            } else {\n                throw new CloudRuntimeException(\"Error while disabling account :\"+accountUUID+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserAccount enableUser(long userId) {\n        UserVO user = _userDao.findById(userId);\n        if (user == null || user.getRemoved() != null) {\n            throw new InvalidParameterValueException(\"Unable to find active user by id \" + userId);\n        }\n\n        int regionId = user.getRegionId();\n\n        String command = \"enableUser\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, user.getUuid()));\n\n        if(getId() == regionId){\n            return _accountMgr.enableUser(userId);\n        } else {\n            //First enable in the Region where user was created\n            Region region = _regionDao.findById(regionId);\n            UserAccount enabledUser = RegionsApiUtil.makeUserAccountAPICall(region, command, params);\n            if (enabledUser != null) {\n                s_logger.debug(\"Successfully enabled user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n                return enabledUser;\n            } else {\n                throw new CloudRuntimeException(\"Error while enabling user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n            }\n        }\n    }","id":562,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public UserAccount enableUser(long userId) {\n        UserVO user = _userDao.findById(userId);\n        if (user == null || user.getRemoved() != null) {\n            throw new InvalidParameterValueException(\"Unable to find active user by id \" + userId);\n        }\n\n        int regionId = user.getRegionId();\n\n        String command = \"enableUser\";\n        List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new NameValuePair(ApiConstants.ID, user.getUuid()));\n\n        if(getId() == regionId){\n            return _accountMgr.enableUser(userId);\n        } else {\n            //First enable in the Region where user was created\n            Region region = _regionDao.findById(regionId);\n            if (RegionsApiUtil.makeAPICall(region, command, params)) {\n                s_logger.debug(\"Successfully enabled user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n                return _userAccountDao.findById(userId);\n            } else {\n                throw new CloudRuntimeException(\"Error while enabling user :\"+user.getUuid()+\" in source Region: \"+region.getId());\n            }\n        }\n    }","commit_id":"603b5ad985e2d952891be880699e8e8973f9007d","url":"https://github.com/apache/cloudstack"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if (defaultSettings == null) {\r\n            defaultSettings = serverFileUtils.loadHashMap(new File(env.getRootPath(), \"yacy.init\"));\r\n        }\r\n        prop.put(\"gc\", 0);\r\n        String set = \"\";\r\n        if (post != null) {\r\n            if (post.containsKey(\"setCustom\")) {\r\n                env.setConfig(\"ramCacheRWI\", Long.parseLong(post.get(\"ramCacheRWI\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheHTTP\", Long.parseLong(post.get(\"ramCacheHTTP\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheLURL\", Long.parseLong(post.get(\"ramCacheLURL\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheNURL\", Long.parseLong(post.get(\"ramCacheNURL\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheEURL\", Long.parseLong(post.get(\"ramCacheEURL\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheDHT\", Long.parseLong(post.get(\"ramCacheDHT\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheMessage\", Long.parseLong(post.get(\"ramCacheMessage\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheWiki\", Long.parseLong(post.get(\"ramCacheWiki\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheBlog\", Long.parseLong(post.get(\"ramCacheBlog\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheNews\", Long.parseLong(post.get(\"ramCacheNews\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheRobots\", Long.parseLong(post.get(\"ramCacheRobots\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheProfiles\", Long.parseLong(post.get(\"ramCacheProfiles\", \"0\")) * KB);\r\n                env.setConfig(\"ramCachePreNURL\", Long.parseLong(post.get(\"ramCachePreNURL\", \"0\")) * KB);\r\n            }\r\n            if (post.containsKey(\"setDefault\")) {\r\n                env.setConfig(\"ramCacheRWI\", Long.parseLong((String) defaultSettings.get(\"ramCacheRWI\")));\r\n                env.setConfig(\"ramCacheHTTP\", Long.parseLong((String) defaultSettings.get(\"ramCacheHTTP\")));\r\n                env.setConfig(\"ramCacheLURL\", Long.parseLong((String) defaultSettings.get(\"ramCacheLURL\")));\r\n                env.setConfig(\"ramCacheNURL\", Long.parseLong((String) defaultSettings.get(\"ramCacheNURL\")));\r\n                env.setConfig(\"ramCacheEURL\", Long.parseLong((String) defaultSettings.get(\"ramCacheEURL\")));\r\n                env.setConfig(\"ramCacheDHT\", Long.parseLong((String) defaultSettings.get(\"ramCacheDHT\")));\r\n                env.setConfig(\"ramCacheMessage\", Long.parseLong((String) defaultSettings.get(\"ramCacheMessage\")));\r\n                env.setConfig(\"ramCacheWiki\", Long.parseLong((String) defaultSettings.get(\"ramCacheWiki\")));\r\n                env.setConfig(\"ramCacheWiki\", Long.parseLong((String) defaultSettings.get(\"ramCacheBlog\")));\r\n                env.setConfig(\"ramCacheNews\", Long.parseLong((String) defaultSettings.get(\"ramCacheNews\")));\r\n                env.setConfig(\"ramCacheRobots\", Long.parseLong((String) defaultSettings.get(\"ramCacheRobots\")));\r\n                env.setConfig(\"ramCacheProfiles\", Long.parseLong((String) defaultSettings.get(\"ramCacheProfiles\")));\r\n                env.setConfig(\"ramCachePreNURL\", Long.parseLong((String) defaultSettings.get(\"ramCachePreNURL\")));\r\n            }\r\n            if (post.containsKey(\"setGood\")) set = \"setGood\";\r\n            if (post.containsKey(\"setBest\")) set = \"setBest\";\r\n            if (post.containsKey(\"gc\")) {\r\n                Runtime.getRuntime().gc();\r\n                prop.put(\"gc\", 1);\r\n            }\r\n            \r\n            int xms = 10; \r\n            if (post.containsKey(\"Xms\")) {\r\n                try { xms = Integer.valueOf(post.get(\"Xms\", \"10\")).intValue(); } catch (NumberFormatException e){}\r\n                env.setConfig(\"javastart_Xms\", \"Xms\" + xms + \"m\");               \r\n            }            \r\n            int xmx = 64; // default maximum heap size\r\n            if (post.containsKey(\"Xmx\")) {\r\n                try { xmx = Integer.valueOf(post.get(\"Xmx\", \"64\")).intValue(); } catch (NumberFormatException e){}\r\n                // initial heap size must be less than or equal to the maximum heap size \r\n                if (xmx < xms) xmx = xms;\r\n                env.setConfig(\"javastart_Xmx\", \"Xmx\" + xmx + \"m\");\r\n            } else if (xmx < xms) {\r\n                env.setConfig(\"javastart_Xmx\", \"Xmx\" + xmx + \"m\");\r\n            }\r\n        }\r\n        \r\n        long memoryFreeNow = Runtime.getRuntime().freeMemory();\r\n        long memoryFreeAfterInitBGC = Long.parseLong(env.getConfig(\"memoryFreeAfterInitBGC\", \"0\"));\r\n        long memoryFreeAfterInitAGC = Long.parseLong(env.getConfig(\"memoryFreeAfterInitAGC\", \"0\"));\r\n        long memoryFreeAfterStartup = Long.parseLong(env.getConfig(\"memoryFreeAfterStartup\", \"0\"));\r\n        long memoryTotalNow = Runtime.getRuntime().totalMemory();\r\n        long memoryTotalAfterInitBGC = Long.parseLong(env.getConfig(\"memoryTotalAfterInitBGC\", \"0\"));\r\n        long memoryTotalAfterInitAGC = Long.parseLong(env.getConfig(\"memoryTotalAfterInitAGC\", \"0\"));\r\n        long memoryTotalAfterStartup = Long.parseLong(env.getConfig(\"memoryTotalAfterStartup\", \"0\"));\r\n        long memoryMax = serverMemory.max;\r\n        \r\n        prop.put(\"memoryMax\", memoryMax / MB);\r\n        prop.put(\"memoryAvailAfterStartup\", (memoryMax - memoryTotalAfterStartup + memoryFreeAfterStartup) / MB);\r\n        prop.put(\"memoryAvailAfterInitBGC\", (memoryMax - memoryTotalAfterInitBGC + memoryFreeAfterInitBGC) / MB);\r\n        prop.put(\"memoryAvailAfterInitAGC\", (memoryMax - memoryTotalAfterInitAGC + memoryFreeAfterInitAGC) / MB);\r\n        prop.put(\"memoryAvailNow\", (memoryMax - memoryTotalNow + memoryFreeNow) / MB);\r\n        prop.put(\"memoryTotalAfterStartup\", memoryTotalAfterStartup / KB);\r\n        prop.put(\"memoryTotalAfterInitBGC\", memoryTotalAfterInitBGC / KB);\r\n        prop.put(\"memoryTotalAfterInitAGC\", memoryTotalAfterInitAGC / KB);\r\n        prop.put(\"memoryTotalNow\", memoryTotalNow / MB);\r\n        prop.put(\"memoryFreeAfterStartup\", memoryFreeAfterStartup / KB);\r\n        prop.put(\"memoryFreeAfterInitBGC\", memoryFreeAfterInitBGC / KB);\r\n        prop.put(\"memoryFreeAfterInitAGC\", memoryFreeAfterInitAGC / KB);\r\n        prop.put(\"memoryFreeNow\", memoryFreeNow / MB);\r\n        prop.put(\"memoryUsedAfterStartup\", (memoryTotalAfterStartup - memoryFreeAfterStartup) / KB);\r\n        prop.put(\"memoryUsedAfterInitBGC\", (memoryTotalAfterInitBGC - memoryFreeAfterInitBGC) / KB);\r\n        prop.put(\"memoryUsedAfterInitAGC\", (memoryTotalAfterInitAGC - memoryFreeAfterInitAGC) / KB);\r\n        prop.put(\"memoryUsedNow\", (memoryTotalNow - memoryFreeNow) / MB);\r\n        \r\n        usedTotal = 0;\r\n        currTotal = 0;\r\n        dfltTotal = 0;\r\n        bestTotal = 0;\r\n    \r\n        req = sb.wordIndex.size();\r\n        chk = sb.wordIndex.assortmentsCacheChunkSizeAvg();\r\n        obj = sb.wordIndex.assortmentsCacheObjectSizeAvg();\r\n        slt = sb.wordIndex.assortmentsCacheNodeStatus();\r\n        ost = sb.wordIndex.assortmentsCacheObjectStatus();\r\n        putprop(prop, env, \"RWI\", set);\r\n         \r\n        req = sb.cacheManager.dbSize();\r\n        chk = sb.cacheManager.cacheNodeChunkSize();\r\n        obj = sb.cacheManager.cacheObjectChunkSize();\r\n        slt = sb.cacheManager.cacheNodeStatus();\r\n        ost = sb.cacheManager.cacheObjectStatus();\r\n        putprop(prop, env, \"HTTP\", set);\r\n        \r\n        req = sb.urlPool.loadedURL.size();\r\n        chk = sb.urlPool.loadedURL.cacheNodeChunkSize();\r\n        obj = sb.urlPool.loadedURL.cacheObjectChunkSize();\r\n        slt = sb.urlPool.loadedURL.cacheNodeStatus();\r\n        ost = sb.urlPool.loadedURL.cacheObjectStatus();\r\n        putprop(prop, env, \"LURL\", set);\r\n        \r\n        req = sb.sbStackCrawlThread.size();\r\n        chk = sb.sbStackCrawlThread.cacheNodeChunkSize();\r\n        obj = sb.sbStackCrawlThread.cacheObjectChunkSize();\r\n        slt = sb.sbStackCrawlThread.cacheNodeStatus();\r\n        ost = sb.sbStackCrawlThread.cacheObjectStatus();\r\n        putprop(prop, env, \"PreNURL\", set);\r\n        \r\n        req = sb.urlPool.noticeURL.size();\r\n        chk = sb.urlPool.noticeURL.cacheNodeChunkSize();\r\n        obj = sb.urlPool.noticeURL.cacheObjectChunkSize();\r\n        slt = sb.urlPool.noticeURL.cacheNodeStatus();\r\n        ost = sb.urlPool.noticeURL.cacheObjectStatus();\r\n        putprop(prop, env, \"NURL\", set);\r\n        \r\n        req = sb.urlPool.errorURL.size();\r\n        chk = sb.urlPool.errorURL.cacheNodeChunkSize();\r\n        obj = sb.urlPool.errorURL.cacheObjectChunkSize();\r\n        slt = sb.urlPool.errorURL.cacheNodeStatus();\r\n        ost = sb.urlPool.errorURL.cacheObjectStatus();\r\n        putprop(prop, env, \"EURL\", set);\r\n        \r\n        req = yacyCore.seedDB.sizeConnected() + yacyCore.seedDB.sizeDisconnected() + yacyCore.seedDB.sizePotential();\r\n        chk = yacyCore.seedDB.cacheNodeChunkSize();\r\n        obj = yacyCore.seedDB.cacheObjectChunkSize();\r\n        slt = yacyCore.seedDB.cacheNodeStatus();\r\n        ost = yacyCore.seedDB.cacheObjectStatus();\r\n        putprop(prop, env, \"DHT\", set);\r\n        \r\n        req = sb.messageDB.size();\r\n        chk = sb.messageDB.cacheNodeChunkSize();\r\n        obj = sb.messageDB.cacheObjectChunkSize();\r\n        slt = sb.messageDB.cacheNodeStatus();\r\n        ost = sb.messageDB.cacheObjectStatus();\r\n        putprop(prop, env, \"Message\", set);\r\n        \r\n        req = sb.wikiDB.sizeOfTwo();\r\n        chk = sb.wikiDB.cacheNodeChunkSize();\r\n        obj = sb.wikiDB.cacheObjectChunkSize();\r\n        slt = sb.wikiDB.cacheNodeStatus();\r\n        ost = sb.wikiDB.cacheObjectStatus();\r\n        putprop(prop, env, \"Wiki\", set);\r\n        \r\n        req = sb.blogDB.size();\r\n        chk = sb.blogDB.cacheNodeChunkSize();\r\n        obj = sb.blogDB.cacheObjectChunkSize();\r\n        slt = sb.blogDB.cacheNodeStatus();\r\n        ost = sb.blogDB.cacheObjectStatus();\r\n        putprop(prop, env, \"Blog\", set);\r\n        \r\n        req = yacyCore.newsPool.dbSize();\r\n        chk = yacyCore.newsPool.cacheNodeChunkSize();\r\n        obj = yacyCore.newsPool.cacheObjectChunkSize();\r\n        slt = yacyCore.newsPool.cacheNodeStatus();\r\n        ost = yacyCore.newsPool.cacheObjectStatus();\r\n        putprop(prop, env, \"News\", set);\r\n        \r\n        req = plasmaSwitchboard.robots.size();\r\n        chk = plasmaSwitchboard.robots.cacheNodeChunkSize();\r\n        obj = plasmaSwitchboard.robots.cacheObjectChunkSize();\r\n        slt = plasmaSwitchboard.robots.cacheNodeStatus();\r\n        ost = plasmaSwitchboard.robots.cacheObjectStatus();\r\n        putprop(prop, env, \"Robots\", set);\r\n        \r\n        req = sb.profiles.size();\r\n        chk = sb.profiles.cacheNodeChunkSize();\r\n        obj = sb.profiles.cacheObjectChunkSize();\r\n        slt = sb.profiles.cacheNodeStatus();\r\n        ost = sb.profiles.cacheObjectStatus();\r\n        putprop(prop, env, \"Profiles\", set);\r\n        \r\n        prop.put(\"usedTotal\", usedTotal / MB);\r\n        prop.put(\"currTotal\", currTotal / MB);\r\n        prop.put(\"dfltTotal\", dfltTotal / MB);\r\n        prop.put(\"bestTotal\", bestTotal / MB);\r\n        \r\n        // parse initialization memory settings\r\n        String Xmx = env.getConfig(\"javastart_Xmx\", \"Xmx64m\").substring(3);\r\n        prop.put(\"Xmx\", Xmx.substring(0, Xmx.length() - 1));\r\n        String Xms = env.getConfig(\"javastart_Xms\", \"Xms10m\").substring(3);\r\n        prop.put(\"Xms\", Xms.substring(0, Xms.length() - 1));\r\n\r\n        /*\r\n        // create statistics about write cache object space\r\n        int chunksizes = ((kelondroObjectSpace.statAlive().size() > 0) &&\r\n                          (kelondroObjectSpace.statHeap().size() > 0)) ?\r\n                          Math.max(\r\n                           ((Integer) kelondroObjectSpace.statAlive().lastKey()).intValue(),\r\n                           ((Integer) kelondroObjectSpace.statHeap().lastKey()).intValue()\r\n                          ) : 0;\r\n        int[] statAlive = new int[chunksizes];\r\n        int[] statHeap  = new int[chunksizes];\r\n        for (int i = 0; i < chunksizes; i++) { statAlive[i] = 0; statHeap[i] = 0; }\r\n        Map.Entry entry;\r\n        Iterator i = kelondroObjectSpace.statAlive().entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            entry = (Map.Entry) i.next();\r\n            statAlive[((Integer) entry.getKey()).intValue() - 1] = ((Integer) entry.getValue()).intValue();\r\n        }\r\n        i = kelondroObjectSpace.statHeap().entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            entry = (Map.Entry) i.next();\r\n            statHeap[((Integer) entry.getKey()).intValue() - 1] = ((Integer) entry.getValue()).intValue();\r\n        }\r\n        int c = 0;\r\n        for (int j = 0; j < chunksizes; j++) {\r\n            if ((statAlive[j] > 0) || (statHeap[j] > 0)) {\r\n                prop.put(\"sizes_\" + c + \"_chunk\", Integer.toString(j + 1));\r\n                prop.put(\"alive_\" + c + \"_count\", Integer.toString(statAlive[j]));\r\n                prop.put(\"heap_\"  + c + \"_count\", Integer.toString(statHeap[j]));\r\n                c++;\r\n            }\r\n        }\r\n        prop.put(\"sizes\", Integer.toString(c));\r\n        prop.put(\"alive\", Integer.toString(c));\r\n        prop.put(\"heap\" , Integer.toString(c));\r\n        */\r\n        \r\n        // other caching structures\r\n        long amount = httpc.nameCacheHitSize();\r\n        prop.put(\"namecache.hit\",Long.toString(amount));\r\n        amount = httpc.nameCacheNoCachingListSize();\r\n        prop.put(\"namecache.noCache\",Long.toString(amount));\r\n        amount = plasmaSwitchboard.urlBlacklist.blacklistCacheSize();\r\n        prop.put(\"blacklistcache.size\",Long.toString(amount));\r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","id":563,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        serverObjects prop = new serverObjects();\r\n        if (defaultSettings == null) {\r\n            defaultSettings = serverFileUtils.loadHashMap(new File(env.getRootPath(), \"yacy.init\"));\r\n        }\r\n        prop.put(\"gc\", 0);\r\n        String set = \"\";\r\n        if (post != null) {\r\n            if (post.containsKey(\"setCustom\")) {\r\n                env.setConfig(\"ramCacheRWI\", Long.parseLong(post.get(\"ramCacheRWI\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheHTTP\", Long.parseLong(post.get(\"ramCacheHTTP\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheLURL\", Long.parseLong(post.get(\"ramCacheLURL\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheNURL\", Long.parseLong(post.get(\"ramCacheNURL\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheEURL\", Long.parseLong(post.get(\"ramCacheEURL\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheDHT\", Long.parseLong(post.get(\"ramCacheDHT\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheMessage\", Long.parseLong(post.get(\"ramCacheMessage\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheWiki\", Long.parseLong(post.get(\"ramCacheWiki\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheBlog\", Long.parseLong(post.get(\"ramCacheBlog\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheNews\", Long.parseLong(post.get(\"ramCacheNews\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheRobots\", Long.parseLong(post.get(\"ramCacheRobots\", \"0\")) * KB);\r\n                env.setConfig(\"ramCacheProfiles\", Long.parseLong(post.get(\"ramCacheProfiles\", \"0\")) * KB);\r\n                env.setConfig(\"ramCachePreNURL\", Long.parseLong(post.get(\"ramCachePreNURL\", \"0\")) * KB);\r\n            }\r\n            if (post.containsKey(\"setDefault\")) {\r\n                env.setConfig(\"ramCacheRWI\", Long.parseLong((String) defaultSettings.get(\"ramCacheRWI\")));\r\n                env.setConfig(\"ramCacheHTTP\", Long.parseLong((String) defaultSettings.get(\"ramCacheHTTP\")));\r\n                env.setConfig(\"ramCacheLURL\", Long.parseLong((String) defaultSettings.get(\"ramCacheLURL\")));\r\n                env.setConfig(\"ramCacheNURL\", Long.parseLong((String) defaultSettings.get(\"ramCacheNURL\")));\r\n                env.setConfig(\"ramCacheEURL\", Long.parseLong((String) defaultSettings.get(\"ramCacheEURL\")));\r\n                env.setConfig(\"ramCacheDHT\", Long.parseLong((String) defaultSettings.get(\"ramCacheDHT\")));\r\n                env.setConfig(\"ramCacheMessage\", Long.parseLong((String) defaultSettings.get(\"ramCacheMessage\")));\r\n                env.setConfig(\"ramCacheWiki\", Long.parseLong((String) defaultSettings.get(\"ramCacheWiki\")));\r\n                env.setConfig(\"ramCacheWiki\", Long.parseLong((String) defaultSettings.get(\"ramCacheBlog\")));\r\n                env.setConfig(\"ramCacheNews\", Long.parseLong((String) defaultSettings.get(\"ramCacheNews\")));\r\n                env.setConfig(\"ramCacheRobots\", Long.parseLong((String) defaultSettings.get(\"ramCacheRobots\")));\r\n                env.setConfig(\"ramCacheProfiles\", Long.parseLong((String) defaultSettings.get(\"ramCacheProfiles\")));\r\n                env.setConfig(\"ramCachePreNURL\", Long.parseLong((String) defaultSettings.get(\"ramCachePreNURL\")));\r\n            }\r\n            if (post.containsKey(\"setGood\")) set = \"setGood\";\r\n            if (post.containsKey(\"setBest\")) set = \"setBest\";\r\n            if (post.containsKey(\"gc\")) {\r\n                Runtime.getRuntime().gc();\r\n                prop.put(\"gc\", 1);\r\n            }\r\n            \r\n            int xms = 10; \r\n            if (post.containsKey(\"Xms\")) {\r\n                try { xms = Integer.valueOf(post.get(\"Xms\", \"10\")).intValue(); } catch (NumberFormatException e){}\r\n                env.setConfig(\"javastart_Xms\", \"Xms\" + xms + \"m\");               \r\n            }            \r\n            int xmx = 64; // default maximum heap size\r\n            if (post.containsKey(\"Xmx\")) {\r\n                try { xmx = Integer.valueOf(post.get(\"Xmx\", \"64\")).intValue(); } catch (NumberFormatException e){}\r\n                // initial heap size must be less than or equal to the maximum heap size \r\n                if (xmx < xms) xmx = xms;\r\n                env.setConfig(\"javastart_Xmx\", \"Xmx\" + xmx + \"m\");\r\n            } else if (xmx < xms) {\r\n                env.setConfig(\"javastart_Xmx\", \"Xmx\" + xmx + \"m\");\r\n            }\r\n        }\r\n        \r\n        long memoryFreeNow = Runtime.getRuntime().freeMemory();\r\n        long memoryFreeAfterInitBGC = Long.parseLong(env.getConfig(\"memoryFreeAfterInitBGC\", \"0\"));\r\n        long memoryFreeAfterInitAGC = Long.parseLong(env.getConfig(\"memoryFreeAfterInitAGC\", \"0\"));\r\n        long memoryFreeAfterStartup = Long.parseLong(env.getConfig(\"memoryFreeAfterStartup\", \"0\"));\r\n        long memoryTotalNow = Runtime.getRuntime().totalMemory();\r\n        long memoryTotalAfterInitBGC = Long.parseLong(env.getConfig(\"memoryTotalAfterInitBGC\", \"0\"));\r\n        long memoryTotalAfterInitAGC = Long.parseLong(env.getConfig(\"memoryTotalAfterInitAGC\", \"0\"));\r\n        long memoryTotalAfterStartup = Long.parseLong(env.getConfig(\"memoryTotalAfterStartup\", \"0\"));\r\n        long memoryMax = serverMemory.max;\r\n        \r\n        prop.put(\"memoryMax\", memoryMax / MB);\r\n        prop.put(\"memoryAvailAfterStartup\", (memoryMax - memoryTotalAfterStartup + memoryFreeAfterStartup) / MB);\r\n        prop.put(\"memoryAvailAfterInitBGC\", (memoryMax - memoryTotalAfterInitBGC + memoryFreeAfterInitBGC) / MB);\r\n        prop.put(\"memoryAvailAfterInitAGC\", (memoryMax - memoryTotalAfterInitAGC + memoryFreeAfterInitAGC) / MB);\r\n        prop.put(\"memoryAvailNow\", (memoryMax - memoryTotalNow + memoryFreeNow) / MB);\r\n        prop.put(\"memoryTotalAfterStartup\", memoryTotalAfterStartup / KB);\r\n        prop.put(\"memoryTotalAfterInitBGC\", memoryTotalAfterInitBGC / KB);\r\n        prop.put(\"memoryTotalAfterInitAGC\", memoryTotalAfterInitAGC / KB);\r\n        prop.put(\"memoryTotalNow\", memoryTotalNow / MB);\r\n        prop.put(\"memoryFreeAfterStartup\", memoryFreeAfterStartup / KB);\r\n        prop.put(\"memoryFreeAfterInitBGC\", memoryFreeAfterInitBGC / KB);\r\n        prop.put(\"memoryFreeAfterInitAGC\", memoryFreeAfterInitAGC / KB);\r\n        prop.put(\"memoryFreeNow\", memoryFreeNow / MB);\r\n        prop.put(\"memoryUsedAfterStartup\", (memoryTotalAfterStartup - memoryFreeAfterStartup) / KB);\r\n        prop.put(\"memoryUsedAfterInitBGC\", (memoryTotalAfterInitBGC - memoryFreeAfterInitBGC) / KB);\r\n        prop.put(\"memoryUsedAfterInitAGC\", (memoryTotalAfterInitAGC - memoryFreeAfterInitAGC) / KB);\r\n        prop.put(\"memoryUsedNow\", (memoryTotalNow - memoryFreeNow) / MB);\r\n        \r\n        usedTotal = 0;\r\n        currTotal = 0;\r\n        dfltTotal = 0;\r\n        bestTotal = 0;\r\n        \r\n        if (sb.wordIndex.useCollectionIndex) {\r\n            prop.put(\"useRWICache\", 0);\r\n        } else {\r\n            prop.put(\"useRWICache\", 1);\r\n            req = sb.wordIndex.size();\r\n            chk = sb.wordIndex.assortmentsCacheChunkSizeAvg();\r\n            obj = sb.wordIndex.assortmentsCacheObjectSizeAvg();\r\n            slt = sb.wordIndex.assortmentsCacheNodeStatus();\r\n            ost = sb.wordIndex.assortmentsCacheObjectStatus();\r\n            putprop(prop, env, \"useRWICache\", \"RWI\", set);\r\n        }\r\n         \r\n        req = sb.cacheManager.dbSize();\r\n        chk = sb.cacheManager.cacheNodeChunkSize();\r\n        obj = sb.cacheManager.cacheObjectChunkSize();\r\n        slt = sb.cacheManager.cacheNodeStatus();\r\n        ost = sb.cacheManager.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"HTTP\", set);\r\n        \r\n        req = sb.urlPool.loadedURL.size();\r\n        chk = sb.urlPool.loadedURL.cacheNodeChunkSize();\r\n        obj = sb.urlPool.loadedURL.cacheObjectChunkSize();\r\n        slt = sb.urlPool.loadedURL.cacheNodeStatus();\r\n        ost = sb.urlPool.loadedURL.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"LURL\", set);\r\n        \r\n        if (sb.sbStackCrawlThread.getDBType() != de.anomic.plasma.plasmaCrawlStacker.QUEUE_DB_TYPE_TREE) {\r\n            prop.put(\"usePreNURLCache\", 0);\r\n        } else {\r\n            prop.put(\"usePreNURLCache\", 1);\r\n            req = sb.sbStackCrawlThread.size();\r\n            chk = sb.sbStackCrawlThread.cacheNodeChunkSize();\r\n            obj = sb.sbStackCrawlThread.cacheObjectChunkSize();\r\n            slt = sb.sbStackCrawlThread.cacheNodeStatus();\r\n            ost = sb.sbStackCrawlThread.cacheObjectStatus();\r\n            putprop(prop, env, \"usePreNURLCache\", \"PreNURL\", set);\r\n        }\r\n        \r\n        if (sb.urlPool.noticeURL.getUseNewDB()) {\r\n            prop.put(\"useNURLCache\", 0);\r\n        } else {\r\n            prop.put(\"useNURLCache\", 1);\r\n            req = sb.urlPool.noticeURL.size();\r\n            chk = sb.urlPool.noticeURL.cacheNodeChunkSize();\r\n            obj = sb.urlPool.noticeURL.cacheObjectChunkSize();\r\n            slt = sb.urlPool.noticeURL.cacheNodeStatus();\r\n            ost = sb.urlPool.noticeURL.cacheObjectStatus();\r\n            putprop(prop, env, \"useNURLCache\", \"NURL\", set);\r\n        }\r\n        \r\n        if (sb.urlPool.errorURL.getUseNewDB()) {\r\n            prop.put(\"useEURLCache\", 0);\r\n        } else {\r\n            prop.put(\"useEURLCache\", 1);\r\n            req = sb.urlPool.errorURL.size();\r\n            chk = sb.urlPool.errorURL.cacheNodeChunkSize();\r\n            obj = sb.urlPool.errorURL.cacheObjectChunkSize();\r\n            slt = sb.urlPool.errorURL.cacheNodeStatus();\r\n            ost = sb.urlPool.errorURL.cacheObjectStatus();\r\n            putprop(prop, env, \"useEURLCache\", \"EURL\", set);\r\n        }\r\n        \r\n        req = yacyCore.seedDB.sizeConnected() + yacyCore.seedDB.sizeDisconnected() + yacyCore.seedDB.sizePotential();\r\n        chk = yacyCore.seedDB.cacheNodeChunkSize();\r\n        obj = yacyCore.seedDB.cacheObjectChunkSize();\r\n        slt = yacyCore.seedDB.cacheNodeStatus();\r\n        ost = yacyCore.seedDB.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"DHT\", set);\r\n        \r\n        req = sb.messageDB.size();\r\n        chk = sb.messageDB.cacheNodeChunkSize();\r\n        obj = sb.messageDB.cacheObjectChunkSize();\r\n        slt = sb.messageDB.cacheNodeStatus();\r\n        ost = sb.messageDB.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"Message\", set);\r\n        \r\n        req = sb.wikiDB.sizeOfTwo();\r\n        chk = sb.wikiDB.cacheNodeChunkSize();\r\n        obj = sb.wikiDB.cacheObjectChunkSize();\r\n        slt = sb.wikiDB.cacheNodeStatus();\r\n        ost = sb.wikiDB.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"Wiki\", set);\r\n        \r\n        req = sb.blogDB.size();\r\n        chk = sb.blogDB.cacheNodeChunkSize();\r\n        obj = sb.blogDB.cacheObjectChunkSize();\r\n        slt = sb.blogDB.cacheNodeStatus();\r\n        ost = sb.blogDB.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"Blog\", set);\r\n        \r\n        req = yacyCore.newsPool.dbSize();\r\n        chk = yacyCore.newsPool.cacheNodeChunkSize();\r\n        obj = yacyCore.newsPool.cacheObjectChunkSize();\r\n        slt = yacyCore.newsPool.cacheNodeStatus();\r\n        ost = yacyCore.newsPool.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"News\", set);\r\n        \r\n        req = plasmaSwitchboard.robots.size();\r\n        chk = plasmaSwitchboard.robots.cacheNodeChunkSize();\r\n        obj = plasmaSwitchboard.robots.cacheObjectChunkSize();\r\n        slt = plasmaSwitchboard.robots.cacheNodeStatus();\r\n        ost = plasmaSwitchboard.robots.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"Robots\", set);\r\n        \r\n        req = sb.profiles.size();\r\n        chk = sb.profiles.cacheNodeChunkSize();\r\n        obj = sb.profiles.cacheObjectChunkSize();\r\n        slt = sb.profiles.cacheNodeStatus();\r\n        ost = sb.profiles.cacheObjectStatus();\r\n        putprop(prop, env, \"\", \"Profiles\", set);\r\n        \r\n        prop.put(\"usedTotal\", usedTotal / MB);\r\n        prop.put(\"currTotal\", currTotal / MB);\r\n        prop.put(\"dfltTotal\", dfltTotal / MB);\r\n        prop.put(\"bestTotal\", bestTotal / MB);\r\n        \r\n        // parse initialization memory settings\r\n        String Xmx = env.getConfig(\"javastart_Xmx\", \"Xmx64m\").substring(3);\r\n        prop.put(\"Xmx\", Xmx.substring(0, Xmx.length() - 1));\r\n        String Xms = env.getConfig(\"javastart_Xms\", \"Xms10m\").substring(3);\r\n        prop.put(\"Xms\", Xms.substring(0, Xms.length() - 1));\r\n\r\n        /*\r\n        // create statistics about write cache object space\r\n        int chunksizes = ((kelondroObjectSpace.statAlive().size() > 0) &&\r\n                          (kelondroObjectSpace.statHeap().size() > 0)) ?\r\n                          Math.max(\r\n                           ((Integer) kelondroObjectSpace.statAlive().lastKey()).intValue(),\r\n                           ((Integer) kelondroObjectSpace.statHeap().lastKey()).intValue()\r\n                          ) : 0;\r\n        int[] statAlive = new int[chunksizes];\r\n        int[] statHeap  = new int[chunksizes];\r\n        for (int i = 0; i < chunksizes; i++) { statAlive[i] = 0; statHeap[i] = 0; }\r\n        Map.Entry entry;\r\n        Iterator i = kelondroObjectSpace.statAlive().entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            entry = (Map.Entry) i.next();\r\n            statAlive[((Integer) entry.getKey()).intValue() - 1] = ((Integer) entry.getValue()).intValue();\r\n        }\r\n        i = kelondroObjectSpace.statHeap().entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            entry = (Map.Entry) i.next();\r\n            statHeap[((Integer) entry.getKey()).intValue() - 1] = ((Integer) entry.getValue()).intValue();\r\n        }\r\n        int c = 0;\r\n        for (int j = 0; j < chunksizes; j++) {\r\n            if ((statAlive[j] > 0) || (statHeap[j] > 0)) {\r\n                prop.put(\"sizes_\" + c + \"_chunk\", Integer.toString(j + 1));\r\n                prop.put(\"alive_\" + c + \"_count\", Integer.toString(statAlive[j]));\r\n                prop.put(\"heap_\"  + c + \"_count\", Integer.toString(statHeap[j]));\r\n                c++;\r\n            }\r\n        }\r\n        prop.put(\"sizes\", Integer.toString(c));\r\n        prop.put(\"alive\", Integer.toString(c));\r\n        prop.put(\"heap\" , Integer.toString(c));\r\n        */\r\n        \r\n        // other caching structures\r\n        long amount = httpc.nameCacheHitSize();\r\n        prop.put(\"namecache.hit\",Long.toString(amount));\r\n        amount = httpc.nameCacheNoCachingListSize();\r\n        prop.put(\"namecache.noCache\",Long.toString(amount));\r\n        amount = plasmaSwitchboard.urlBlacklist.blacklistCacheSize();\r\n        prop.put(\"blacklistcache.size\",Long.toString(amount));\r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","commit_id":"ebf0da2a45834e39953ef1f09d39596c7c482ce8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void putprop(serverObjects prop, serverSwitch env, String db, String set) {\r\n        usd = chk * slt[1] + obj * ost[2] /*hit*/ + kelondroTree.cacheObjectMissSize * ost[3] /*miss*/;\r\n        bst = (((((long) chk) * ((long) req)) >> 10) + 1) << 10;\r\n        if (set.equals(\"setBest\")) env.setConfig(\"ramCache\" + db, bst);\r\n        prop.put(\"nodsz\" + db, chk);\r\n        prop.put(\"ochunksiz\" + db, obj);\r\n        prop.put(\"slreq\" + db, req);\r\n        prop.put(\"slemp\" + db, slt[0] - slt[1]);\r\n        prop.put(\"slfil\" + db, slt[1]);\r\n        prop.put(\"slhittmiss\" + db, slt[4] + \":\" + slt[5]);\r\n        prop.put(\"sluniqdoub\" + db, slt[6] + \":\" + slt[7]);\r\n        prop.put(\"slflush\" + db, slt[8] + \":\" + slt[9]);\r\n        prop.put(\"ochunkmax\" + db, ost[0]);\r\n        prop.put(\"omisscmax\" + db, ost[1]);\r\n        prop.put(\"ochunkcur\" + db, ost[2] + \"<br>\" + ost[3]);\r\n        prop.put(\"ohittmiss\" + db, ost[7] + \":\" + ost[8]);\r\n        prop.put(\"ouniqdoub\" + db, ost[9] + \":\" + ost[10]);\r\n        prop.put(\"oflush\" + db, ost[11] + \":\" + ost[12]);\r\n        prop.put(\"nhittmiss\" + db, ost[13] + \":\" + ost[14]);\r\n        prop.put(\"nuniqdoub\" + db, ost[15] + \":\" + ost[16]);\r\n        prop.put(\"nflush\" + db, ost[17] + \":\" + ost[18]);\r\n        prop.put(\"used\" + db, usd / KB);\r\n        prop.put(\"best\" + db, bst / KB);\r\n        prop.put(\"dflt\" + db, Long.parseLong((String) defaultSettings.get(\"ramCache\" + db)) / KB);\r\n        prop.put(\"ramCache\" + db, Long.parseLong(env.getConfig(\"ramCache\" + db, \"0\")) / KB);\r\n        usedTotal += usd;\r\n        currTotal += Long.parseLong(env.getConfig(\"ramCache\" + db, \"0\"));\r\n        dfltTotal += Long.parseLong((String) defaultSettings.get(\"ramCache\" + db));\r\n        bestTotal += bst;\r\n    }","id":564,"modified_method":"private static void putprop(serverObjects prop, serverSwitch env, String wdb, String db, String set) {\r\n        usd = chk * slt[1] + obj * ost[2] /*hit*/ + kelondroTree.cacheObjectMissSize * ost[3] /*miss*/;\r\n        bst = (((((long) chk) * ((long) req)) >> 10) + 1) << 10;\r\n        if (set.equals(\"setBest\")) env.setConfig(\"ramCache\" + db, bst);\r\n        System.out.println(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"nodsc\" + db);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"nodsz\" + db, chk);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"ochunksiz\" + db, obj);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"slreq\" + db, req);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"slemp\" + db, slt[0] - slt[1]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"slfil\" + db, slt[1]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"slhittmiss\" + db, slt[4] + \":\" + slt[5]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"sluniqdoub\" + db, slt[6] + \":\" + slt[7]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"slflush\" + db, slt[8] + \":\" + slt[9]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"ochunkmax\" + db, ost[0]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"omisscmax\" + db, ost[1]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"ochunkcur\" + db, ost[2] + \"<br>\" + ost[3]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"ohittmiss\" + db, ost[7] + \":\" + ost[8]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"ouniqdoub\" + db, ost[9] + \":\" + ost[10]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"oflush\" + db, ost[11] + \":\" + ost[12]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"nhittmiss\" + db, ost[13] + \":\" + ost[14]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"nuniqdoub\" + db, ost[15] + \":\" + ost[16]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"nflush\" + db, ost[17] + \":\" + ost[18]);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"used\" + db, usd / KB);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"best\" + db, bst / KB);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"dflt\" + db, Long.parseLong((String) defaultSettings.get(\"ramCache\" + db)) / KB);\r\n        prop.put(wdb + ((wdb.length() > 0) ? (\"_\") : (\"\")) + \"ramCache\" + db, Long.parseLong(env.getConfig(\"ramCache\" + db, \"0\")) / KB);\r\n        usedTotal += usd;\r\n        currTotal += Long.parseLong(env.getConfig(\"ramCache\" + db, \"0\"));\r\n        dfltTotal += Long.parseLong((String) defaultSettings.get(\"ramCache\" + db));\r\n        bestTotal += bst;\r\n    }","commit_id":"ebf0da2a45834e39953ef1f09d39596c7c482ce8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Try to assign unassigned jobs as there might be changes in:\n     * - queue configurations\n     * - topology\n     * - capabilities\n     */\n    public void assignUnassignedJobs() {\n        if ( caps.isLeader() && caps.isActive() ) {\n            logger.debug(\"Checking unassigned jobs...\");\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            try {\n                final Resource unassignedRoot = resolver.getResource(this.configuration.getUnassignedJobsPath());\n                logger.debug(\"Got unassigned root {}\", unassignedRoot);\n\n                // this resource should exist, but we check anyway\n                if ( unassignedRoot != null ) {\n                    assignJobs(unassignedRoot, false);\n                }\n            } finally {\n                resolver.close();\n            }\n        }\n    }","id":565,"modified_method":"/**\n     * Try to assign unassigned jobs as there might be changes in:\n     * - queue configurations\n     * - topology\n     * - capabilities\n     */\n    public void assignUnassignedJobs() {\n        if ( caps.isLeader() && caps.isActive() ) {\n            logger.debug(\"Checking unassigned jobs...\");\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            if ( resolver != null ) {\n                try {\n                    final Resource unassignedRoot = resolver.getResource(this.configuration.getUnassignedJobsPath());\n                    logger.debug(\"Got unassigned root {}\", unassignedRoot);\n\n                    // this resource should exist, but we check anyway\n                    if ( unassignedRoot != null ) {\n                        assignJobs(unassignedRoot, false);\n                    }\n                } finally {\n                    resolver.close();\n                }\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Reassign stale jobs from this instance\n     */\n    private void reassignStaleJobs() {\n        if ( caps.isActive() ) {\n            this.logger.debug(\"Checking for stale jobs...\");\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            try {\n                final Resource jobsRoot = resolver.getResource(this.configuration.getLocalJobsPath());\n\n                // this resource should exist, but we check anyway\n                if ( jobsRoot != null ) {\n                    // check if this instance supports bridged jobs\n                    final List<InstanceDescription> bridgedTargets = caps.getPotentialTargets(\"/\", null);\n                    boolean flag = false;\n                    for(final InstanceDescription desc : bridgedTargets) {\n                        if ( desc.isLocal() ) {\n                            flag = true;\n                            break;\n                        }\n                    }\n                    final boolean supportsBridged = flag;\n\n                    final Iterator<Resource> topicIter = jobsRoot.listChildren();\n                    while ( caps.isActive() && topicIter.hasNext() ) {\n                        final Resource topicResource = topicIter.next();\n\n                        final String topicName = topicResource.getName().replace('.', '/');\n                        this.logger.debug(\"Checking topic {}...\" , topicName);\n                        final List<InstanceDescription> potentialTargets = caps.getPotentialTargets(topicName, null);\n                        boolean reassign = true;\n                        for(final InstanceDescription desc : potentialTargets) {\n                            if ( desc.isLocal() ) {\n                                reassign = false;\n                                break;\n                            }\n                        }\n                        if ( reassign ) {\n                            final QueueInfo info = this.configuration.getQueueConfigurationManager().getQueueInfo(topicName);\n                            JobTopicTraverser.traverse(this.logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n                                @Override\n                                public boolean handle(final Resource rsrc) {\n                                    try {\n                                        final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                                        if ( !supportsBridged || vm.get(JobImpl.PROPERTY_BRIDGED_EVENT) == null ) {\n                                            final String targetId = caps.detectTarget(topicName, vm, info);\n\n                                            final Map<String, Object> props = new HashMap<String, Object>(vm);\n                                            props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n\n                                            final String newPath;\n                                            if ( targetId != null ) {\n                                                newPath = configuration.getAssginedJobsPath() + '/' + targetId + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                                                props.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                                                props.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                                            } else {\n                                                newPath = configuration.getUnassignedJobsPath() + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                                                props.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n                                                props.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n                                            }\n                                            try {\n                                                ResourceHelper.getOrCreateResource(resolver, newPath, props);\n                                                resolver.delete(rsrc);\n                                                resolver.commit();\n                                            } catch ( final PersistenceException pe ) {\n                                                logger.warn(\"Unable to move stale job from \" + rsrc.getPath() + \" to \" + newPath, pe);\n                                                resolver.refresh();\n                                                resolver.revert();\n                                            }\n                                        }\n                                    } catch (final InstantiationException ie) {\n                                        // something happened with the resource in the meantime\n                                        logger.warn(\"Unable to move stale job from \" + rsrc.getPath(), ie);\n                                        resolver.refresh();\n                                        resolver.revert();\n                                    }\n                                    return caps.isActive();\n                                }\n                            });\n\n                        }\n                    }\n                }\n            } finally {\n                resolver.close();\n            }\n        }\n    }","id":566,"modified_method":"/**\n     * Reassign stale jobs from this instance\n     */\n    private void reassignStaleJobs() {\n        if ( caps.isActive() ) {\n            this.logger.debug(\"Checking for stale jobs...\");\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            if ( resolver != null ) {\n                try {\n                    final Resource jobsRoot = resolver.getResource(this.configuration.getLocalJobsPath());\n\n                    // this resource should exist, but we check anyway\n                    if ( jobsRoot != null ) {\n                        // check if this instance supports bridged jobs\n                        final List<InstanceDescription> bridgedTargets = caps.getPotentialTargets(\"/\", null);\n                        boolean flag = false;\n                        for(final InstanceDescription desc : bridgedTargets) {\n                            if ( desc.isLocal() ) {\n                                flag = true;\n                                break;\n                            }\n                        }\n                        final boolean supportsBridged = flag;\n\n                        final Iterator<Resource> topicIter = jobsRoot.listChildren();\n                        while ( caps.isActive() && topicIter.hasNext() ) {\n                            final Resource topicResource = topicIter.next();\n\n                            final String topicName = topicResource.getName().replace('.', '/');\n                            this.logger.debug(\"Checking topic {}...\" , topicName);\n                            final List<InstanceDescription> potentialTargets = caps.getPotentialTargets(topicName, null);\n                            boolean reassign = true;\n                            for(final InstanceDescription desc : potentialTargets) {\n                                if ( desc.isLocal() ) {\n                                    reassign = false;\n                                    break;\n                                }\n                            }\n                            if ( reassign ) {\n                                final QueueConfigurationManager qcm = this.configuration.getQueueConfigurationManager();\n                                if ( qcm == null ) {\n                                    break;\n                                }\n                                final QueueInfo info = qcm.getQueueInfo(topicName);\n                                JobTopicTraverser.traverse(this.logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n                                    @Override\n                                    public boolean handle(final Resource rsrc) {\n                                        try {\n                                            final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                                            if ( !supportsBridged || vm.get(JobImpl.PROPERTY_BRIDGED_EVENT) == null ) {\n                                                final String targetId = caps.detectTarget(topicName, vm, info);\n\n                                                final Map<String, Object> props = new HashMap<String, Object>(vm);\n                                                props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n\n                                                final String newPath;\n                                                if ( targetId != null ) {\n                                                    newPath = configuration.getAssginedJobsPath() + '/' + targetId + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                                                    props.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                                                    props.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                                                } else {\n                                                    newPath = configuration.getUnassignedJobsPath() + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                                                    props.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n                                                    props.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n                                                }\n                                                try {\n                                                    ResourceHelper.getOrCreateResource(resolver, newPath, props);\n                                                    resolver.delete(rsrc);\n                                                    resolver.commit();\n                                                } catch ( final PersistenceException pe ) {\n                                                    logger.warn(\"Unable to move stale job from \" + rsrc.getPath() + \" to \" + newPath, pe);\n                                                    resolver.refresh();\n                                                    resolver.revert();\n                                                }\n                                            }\n                                        } catch (final InstantiationException ie) {\n                                            // something happened with the resource in the meantime\n                                            logger.warn(\"Unable to move stale job from \" + rsrc.getPath(), ie);\n                                            resolver.refresh();\n                                            resolver.revert();\n                                        }\n                                        return caps.isActive();\n                                    }\n                                });\n\n                            }\n                        }\n                    }\n                } finally {\n                    resolver.close();\n                }\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Reassign jobs from stopped instance.\n     */\n    private void reassignJobsFromStoppedInstances() {\n        if ( caps.isLeader() && caps.isActive() ) {\n            this.logger.debug(\"Checking for stopped instances...\");\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            try {\n                final Resource jobsRoot = resolver.getResource(this.configuration.getAssginedJobsPath());\n                this.logger.debug(\"Got jobs root {}\", jobsRoot);\n\n                // this resource should exist, but we check anyway\n                if ( jobsRoot != null ) {\n                    final Iterator<Resource> instanceIter = jobsRoot.listChildren();\n                    while ( caps.isActive() && instanceIter.hasNext() ) {\n                        final Resource instanceResource = instanceIter.next();\n\n                        final String instanceId = instanceResource.getName();\n                        if ( !caps.isActive(instanceId) ) {\n                            logger.debug(\"Found stopped instance {}\", instanceId);\n                            assignJobs(instanceResource, true);\n                        }\n                    }\n                }\n            } finally {\n                resolver.close();\n            }\n        }\n    }","id":567,"modified_method":"/**\n     * Reassign jobs from stopped instance.\n     */\n    private void reassignJobsFromStoppedInstances() {\n        if ( caps.isLeader() && caps.isActive() ) {\n            this.logger.debug(\"Checking for stopped instances...\");\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            if ( resolver != null ) {\n                try {\n                    final Resource jobsRoot = resolver.getResource(this.configuration.getAssginedJobsPath());\n                    this.logger.debug(\"Got jobs root {}\", jobsRoot);\n\n                    // this resource should exist, but we check anyway\n                    if ( jobsRoot != null ) {\n                        final Iterator<Resource> instanceIter = jobsRoot.listChildren();\n                        while ( caps.isActive() && instanceIter.hasNext() ) {\n                            final Resource instanceResource = instanceIter.next();\n\n                            final String instanceId = instanceResource.getName();\n                            if ( !caps.isActive(instanceId) ) {\n                                logger.debug(\"Found stopped instance {}\", instanceId);\n                                assignJobs(instanceResource, true);\n                            }\n                        }\n                    }\n                } finally {\n                    resolver.close();\n                }\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Try to assign all jobs from the jobs root.\n     * The jobs are stored by topic\n     * @param jobsRoot The root of the jobs\n     * @param unassign Whether to unassign the job if no instance is found.\n     */\n    private void assignJobs(final Resource jobsRoot,\n            final boolean unassign) {\n        final ResourceResolver resolver = jobsRoot.getResourceResolver();\n\n        final Iterator<Resource> topicIter = jobsRoot.listChildren();\n        while ( caps.isActive() && topicIter.hasNext() ) {\n            final Resource topicResource = topicIter.next();\n\n            final String topicName = topicResource.getName().replace('.', '/');\n            logger.debug(\"Found topic {}\", topicName);\n\n            // first check if there is an instance for these topics\n            final List<InstanceDescription> potentialTargets = caps.getPotentialTargets(topicName, BRIDGED_JOB);\n            if ( potentialTargets != null && potentialTargets.size() > 0 ) {\n                final QueueInfo info = this.configuration.getQueueConfigurationManager().getQueueInfo(topicName);\n                logger.debug(\"Found queue {} for {}\", info.queueConfiguration, topicName);\n\n                JobTopicTraverser.traverse(this.logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n                    @Override\n                    public boolean handle(final Resource rsrc) {\n                        try {\n                            final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                            final String targetId = caps.detectTarget(topicName, vm, info);\n\n                            if ( targetId != null ) {\n                                final String newPath = configuration.getAssginedJobsPath() + '/' + targetId + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                                final Map<String, Object> props = new HashMap<String, Object>(vm);\n                                props.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                                props.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                                props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n                                try {\n                                    ResourceHelper.getOrCreateResource(resolver, newPath, props);\n                                    resolver.delete(rsrc);\n                                    resolver.commit();\n                                } catch ( final PersistenceException pe ) {\n                                    logger.warn(\"Unable to move unassigned job from \" + rsrc.getPath() + \" to \" + newPath, pe);\n                                    resolver.refresh();\n                                    resolver.revert();\n                                }\n                            }\n                        } catch (final InstantiationException ie) {\n                            // something happened with the resource in the meantime\n                            logger.warn(\"Unable to move unassigned job from \" + rsrc.getPath(), ie);\n                            resolver.refresh();\n                            resolver.revert();\n                        }\n                        return caps.isActive();\n                    }\n                });\n            }\n            // now unassign if there are still jobs\n            if ( caps.isActive() && unassign ) {\n                // we have to move everything to the unassigned area\n                JobTopicTraverser.traverse(this.logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n                    @Override\n                    public boolean handle(final Resource rsrc) {\n                        try {\n                            final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                            final String newPath = configuration.getUnassignedJobsPath() + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                            final Map<String, Object> props = new HashMap<String, Object>(vm);\n                            props.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n                            props.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n                            props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n\n                            try {\n                                ResourceHelper.getOrCreateResource(resolver, newPath, props);\n                                resolver.delete(rsrc);\n                                resolver.commit();\n                            } catch ( final PersistenceException pe ) {\n                                logger.warn(\"Unable to unassigned job from \" + rsrc.getPath() + \" to \" + newPath, pe);\n                                resolver.refresh();\n                                resolver.revert();\n                            }\n                        } catch (final InstantiationException ie) {\n                            // something happened with the resource in the meantime\n                            logger.warn(\"Unable to unassigned job from \" + rsrc.getPath(), ie);\n                            resolver.refresh();\n                            resolver.revert();\n                        }\n                        return caps.isActive();\n                    }\n                });\n            }\n        }\n    }","id":568,"modified_method":"/**\n     * Try to assign all jobs from the jobs root.\n     * The jobs are stored by topic\n     * @param jobsRoot The root of the jobs\n     * @param unassign Whether to unassign the job if no instance is found.\n     */\n    private void assignJobs(final Resource jobsRoot,\n            final boolean unassign) {\n        final ResourceResolver resolver = jobsRoot.getResourceResolver();\n\n        final Iterator<Resource> topicIter = jobsRoot.listChildren();\n        while ( caps.isActive() && topicIter.hasNext() ) {\n            final Resource topicResource = topicIter.next();\n\n            final String topicName = topicResource.getName().replace('.', '/');\n            logger.debug(\"Found topic {}\", topicName);\n\n            // first check if there is an instance for these topics\n            final List<InstanceDescription> potentialTargets = caps.getPotentialTargets(topicName, BRIDGED_JOB);\n            if ( potentialTargets != null && potentialTargets.size() > 0 ) {\n                final QueueConfigurationManager qcm = this.configuration.getQueueConfigurationManager();\n                if ( qcm == null ) {\n                    break;\n                }\n                final QueueInfo info = qcm.getQueueInfo(topicName);\n                logger.debug(\"Found queue {} for {}\", info.queueConfiguration, topicName);\n\n                JobTopicTraverser.traverse(this.logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n                    @Override\n                    public boolean handle(final Resource rsrc) {\n                        try {\n                            final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                            final String targetId = caps.detectTarget(topicName, vm, info);\n\n                            if ( targetId != null ) {\n                                final String newPath = configuration.getAssginedJobsPath() + '/' + targetId + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                                final Map<String, Object> props = new HashMap<String, Object>(vm);\n                                props.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                                props.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                                props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n                                try {\n                                    ResourceHelper.getOrCreateResource(resolver, newPath, props);\n                                    resolver.delete(rsrc);\n                                    resolver.commit();\n                                } catch ( final PersistenceException pe ) {\n                                    logger.warn(\"Unable to move unassigned job from \" + rsrc.getPath() + \" to \" + newPath, pe);\n                                    resolver.refresh();\n                                    resolver.revert();\n                                }\n                            }\n                        } catch (final InstantiationException ie) {\n                            // something happened with the resource in the meantime\n                            logger.warn(\"Unable to move unassigned job from \" + rsrc.getPath(), ie);\n                            resolver.refresh();\n                            resolver.revert();\n                        }\n                        return caps.isActive();\n                    }\n                });\n            }\n            // now unassign if there are still jobs\n            if ( caps.isActive() && unassign ) {\n                // we have to move everything to the unassigned area\n                JobTopicTraverser.traverse(this.logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n                    @Override\n                    public boolean handle(final Resource rsrc) {\n                        try {\n                            final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                            final String newPath = configuration.getUnassignedJobsPath() + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                            final Map<String, Object> props = new HashMap<String, Object>(vm);\n                            props.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n                            props.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n                            props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n\n                            try {\n                                ResourceHelper.getOrCreateResource(resolver, newPath, props);\n                                resolver.delete(rsrc);\n                                resolver.commit();\n                            } catch ( final PersistenceException pe ) {\n                                logger.warn(\"Unable to unassigned job from \" + rsrc.getPath() + \" to \" + newPath, pe);\n                                resolver.refresh();\n                                resolver.revert();\n                            }\n                        } catch (final InstantiationException ie) {\n                            // something happened with the resource in the meantime\n                            logger.warn(\"Unable to unassigned job from \" + rsrc.getPath(), ie);\n                            resolver.refresh();\n                            resolver.revert();\n                        }\n                        return caps.isActive();\n                    }\n                });\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Full cleanup - this scans all directories!\n     */\n    private void fullEmptyFolderCleanup(final TopologyCapabilities caps, final String basePath) {\n        this.logger.debug(\"Cleaning up job resource tree: removing ALL empty folders\");\n        final ResourceResolver resolver = this.configuration.createResourceResolver();\n        try {\n            final Resource baseResource = resolver.getResource(basePath);\n            // sanity check - should never be null\n            if ( baseResource != null ) {\n                final Calendar now = Calendar.getInstance();\n\n                final Iterator<Resource> topicIter = baseResource.listChildren();\n                while ( caps.isActive() && topicIter.hasNext() ) {\n                    final Resource topicResource = topicIter.next();\n\n                    // now years\n                    final Iterator<Resource> yearIter = topicResource.listChildren();\n                    while ( caps.isActive() && yearIter.hasNext() ) {\n                        final Resource yearResource = yearIter.next();\n                        final int year = Integer.valueOf(yearResource.getName());\n                        final boolean oldYear = year < now.get(Calendar.YEAR);\n\n                        // months\n                        final Iterator<Resource> monthIter = yearResource.listChildren();\n                        while ( caps.isActive() && monthIter.hasNext() ) {\n                            final Resource monthResource = monthIter.next();\n                            final int month = Integer.valueOf(monthResource.getName());\n                            final boolean oldMonth = oldYear || month < (now.get(Calendar.MONTH) + 1);\n\n                            // days\n                            final Iterator<Resource> dayIter = monthResource.listChildren();\n                            while ( caps.isActive() && dayIter.hasNext() ) {\n                                final Resource dayResource = dayIter.next();\n                                final int day = Integer.valueOf(dayResource.getName());\n                                final boolean oldDay = oldMonth || day < now.get(Calendar.DAY_OF_MONTH);\n\n                                // hours\n                                final Iterator<Resource> hourIter = dayResource.listChildren();\n                                while ( caps.isActive() && hourIter.hasNext() ) {\n                                    final Resource hourResource = hourIter.next();\n                                    final int hour = Integer.valueOf(hourResource.getName());\n                                    final boolean oldHour = (oldDay && (oldMonth || now.get(Calendar.HOUR_OF_DAY) > 0)) || hour < (now.get(Calendar.HOUR_OF_DAY) -1);\n\n                                    // we only remove minutes if the hour is old\n                                    if ( oldHour ) {\n                                        final Iterator<Resource> minuteIter = hourResource.listChildren();\n                                        while ( caps.isActive() && minuteIter.hasNext() ) {\n                                            final Resource minuteResource = minuteIter.next();\n\n                                            // check if we can delete the minute\n                                            if ( !minuteResource.listChildren().hasNext() ) {\n                                                resolver.delete(minuteResource);\n                                                resolver.commit();\n                                            }\n                                        }\n                                    }\n\n                                    // check if we can delete the hour\n                                    if ( caps.isActive() && oldHour && !hourResource.listChildren().hasNext()) {\n                                        resolver.delete(hourResource);\n                                        resolver.commit();\n                                    }\n                                }\n                                // check if we can delete the day\n                                if ( caps.isActive() && oldDay && !dayResource.listChildren().hasNext()) {\n                                    resolver.delete(dayResource);\n                                    resolver.commit();\n                                }\n                            }\n\n                            // check if we can delete the month\n                            if ( caps.isActive() && oldMonth && !monthResource.listChildren().hasNext() ) {\n                                resolver.delete(monthResource);\n                                resolver.commit();\n                            }\n                        }\n\n                        // check if we can delete the year\n                        if ( caps.isActive() && oldYear && !yearResource.listChildren().hasNext() ) {\n                            resolver.delete(yearResource);\n                            resolver.commit();\n                        }\n                    }\n                }\n            }\n\n        } catch (final PersistenceException pe) {\n            // in the case of an error, we just log this as a warning\n            this.logger.warn(\"Exception during job resource tree cleanup.\", pe);\n        } finally {\n            resolver.close();\n        }\n    }","id":569,"modified_method":"/**\n     * Full cleanup - this scans all directories!\n     */\n    private void fullEmptyFolderCleanup(final TopologyCapabilities caps, final String basePath) {\n        this.logger.debug(\"Cleaning up job resource tree: removing ALL empty folders\");\n        final ResourceResolver resolver = this.configuration.createResourceResolver();\n        if ( resolver == null ) {\n            return;\n        }\n        try {\n            final Resource baseResource = resolver.getResource(basePath);\n            // sanity check - should never be null\n            if ( baseResource != null ) {\n                final Calendar now = Calendar.getInstance();\n\n                final Iterator<Resource> topicIter = baseResource.listChildren();\n                while ( caps.isActive() && topicIter.hasNext() ) {\n                    final Resource topicResource = topicIter.next();\n\n                    // now years\n                    final Iterator<Resource> yearIter = topicResource.listChildren();\n                    while ( caps.isActive() && yearIter.hasNext() ) {\n                        final Resource yearResource = yearIter.next();\n                        final int year = Integer.valueOf(yearResource.getName());\n                        final boolean oldYear = year < now.get(Calendar.YEAR);\n\n                        // months\n                        final Iterator<Resource> monthIter = yearResource.listChildren();\n                        while ( caps.isActive() && monthIter.hasNext() ) {\n                            final Resource monthResource = monthIter.next();\n                            final int month = Integer.valueOf(monthResource.getName());\n                            final boolean oldMonth = oldYear || month < (now.get(Calendar.MONTH) + 1);\n\n                            // days\n                            final Iterator<Resource> dayIter = monthResource.listChildren();\n                            while ( caps.isActive() && dayIter.hasNext() ) {\n                                final Resource dayResource = dayIter.next();\n                                final int day = Integer.valueOf(dayResource.getName());\n                                final boolean oldDay = oldMonth || day < now.get(Calendar.DAY_OF_MONTH);\n\n                                // hours\n                                final Iterator<Resource> hourIter = dayResource.listChildren();\n                                while ( caps.isActive() && hourIter.hasNext() ) {\n                                    final Resource hourResource = hourIter.next();\n                                    final int hour = Integer.valueOf(hourResource.getName());\n                                    final boolean oldHour = (oldDay && (oldMonth || now.get(Calendar.HOUR_OF_DAY) > 0)) || hour < (now.get(Calendar.HOUR_OF_DAY) -1);\n\n                                    // we only remove minutes if the hour is old\n                                    if ( oldHour ) {\n                                        final Iterator<Resource> minuteIter = hourResource.listChildren();\n                                        while ( caps.isActive() && minuteIter.hasNext() ) {\n                                            final Resource minuteResource = minuteIter.next();\n\n                                            // check if we can delete the minute\n                                            if ( !minuteResource.listChildren().hasNext() ) {\n                                                resolver.delete(minuteResource);\n                                                resolver.commit();\n                                            }\n                                        }\n                                    }\n\n                                    // check if we can delete the hour\n                                    if ( caps.isActive() && oldHour && !hourResource.listChildren().hasNext()) {\n                                        resolver.delete(hourResource);\n                                        resolver.commit();\n                                    }\n                                }\n                                // check if we can delete the day\n                                if ( caps.isActive() && oldDay && !dayResource.listChildren().hasNext()) {\n                                    resolver.delete(dayResource);\n                                    resolver.commit();\n                                }\n                            }\n\n                            // check if we can delete the month\n                            if ( caps.isActive() && oldMonth && !monthResource.listChildren().hasNext() ) {\n                                resolver.delete(monthResource);\n                                resolver.commit();\n                            }\n                        }\n\n                        // check if we can delete the year\n                        if ( caps.isActive() && oldYear && !yearResource.listChildren().hasNext() ) {\n                            resolver.delete(yearResource);\n                            resolver.commit();\n                        }\n                    }\n                }\n            }\n\n        } catch (final PersistenceException pe) {\n            // in the case of an error, we just log this as a warning\n            this.logger.warn(\"Exception during job resource tree cleanup.\", pe);\n        } finally {\n            resolver.close();\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Clean up the locks\n     * All locks older than two minutes are removed\n     */\n    private void lockCleanup(final TopologyCapabilities caps) {\n        if ( caps != null && caps.isLeader() ) {\n            this.logger.debug(\"Cleaning up job resource tree: removing obsolete locks\");\n            final List<Resource> candidates = new ArrayList<Resource>();\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            try {\n                final Resource parentResource = resolver.getResource(this.configuration.getLocksPath());\n                final Calendar startDate = Calendar.getInstance();\n                startDate.add(Calendar.MINUTE, -2);\n\n                this.lockCleanup(caps, candidates, parentResource, startDate);\n                final BatchResourceRemover remover = new BatchResourceRemover();\n                boolean batchRemove = true;\n                for(final Resource lockResource : candidates) {\n                    if ( caps.isActive() ) {\n                        try {\n                            if ( batchRemove ) {\n                                remover.delete(lockResource);\n                            } else {\n                                resolver.delete(lockResource);\n                                resolver.commit();\n                            }\n                        } catch ( final PersistenceException pe) {\n                            batchRemove = false;\n                            this.ignoreException(pe);\n                            resolver.refresh();\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                try {\n                    resolver.commit();\n                } catch ( final PersistenceException pe) {\n                    this.ignoreException(pe);\n                    resolver.refresh();\n                }\n            } finally {\n                resolver.close();\n            }\n        }\n    }","id":570,"modified_method":"/**\n     * Clean up the locks\n     * All locks older than two minutes are removed\n     */\n    private void lockCleanup(final TopologyCapabilities caps) {\n        if ( caps != null && caps.isLeader() ) {\n            this.logger.debug(\"Cleaning up job resource tree: removing obsolete locks\");\n            final List<Resource> candidates = new ArrayList<Resource>();\n            final ResourceResolver resolver = this.configuration.createResourceResolver();\n            if ( resolver != null ) {\n                try {\n                    final Resource parentResource = resolver.getResource(this.configuration.getLocksPath());\n                    final Calendar startDate = Calendar.getInstance();\n                    startDate.add(Calendar.MINUTE, -2);\n\n                    this.lockCleanup(caps, candidates, parentResource, startDate);\n                    final BatchResourceRemover remover = new BatchResourceRemover();\n                    boolean batchRemove = true;\n                    for(final Resource lockResource : candidates) {\n                        if ( caps.isActive() ) {\n                            try {\n                                if ( batchRemove ) {\n                                    remover.delete(lockResource);\n                                } else {\n                                    resolver.delete(lockResource);\n                                    resolver.commit();\n                                }\n                            } catch ( final PersistenceException pe) {\n                                batchRemove = false;\n                                this.ignoreException(pe);\n                                resolver.refresh();\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                    try {\n                        resolver.commit();\n                    } catch ( final PersistenceException pe) {\n                        this.ignoreException(pe);\n                        resolver.refresh();\n                    }\n                } finally {\n                    resolver.close();\n                }\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Scan the resource tree for unfinished jobs from previous runs\n     */\n    private void initialScan() {\n        logger.debug(\"Scanning repository for unfinished jobs...\");\n        final ResourceResolver resolver = configuration.createResourceResolver();\n        try {\n            final Resource baseResource = resolver.getResource(configuration.getLocalJobsPath());\n\n            // sanity check - should never be null\n            if ( baseResource != null ) {\n                final Iterator<Resource> topicIter = baseResource.listChildren();\n                while ( topicIter.hasNext() ) {\n                    final Resource topicResource = topicIter.next();\n                    logger.debug(\"Found topic {}\", topicResource.getName());\n\n                    // init topic\n                    initTopic(topicResource);\n                }\n            }\n        } finally {\n            resolver.close();\n        }\n    }","id":571,"modified_method":"/**\n     * Scan the resource tree for unfinished jobs from previous runs\n     */\n    private void initialScan() {\n        logger.debug(\"Scanning repository for unfinished jobs...\");\n        final ResourceResolver resolver = configuration.createResourceResolver();\n        if ( resolver == null ) {\n            return;\n        }\n        try {\n            final Resource baseResource = resolver.getResource(configuration.getLocalJobsPath());\n\n            // sanity check - should never be null\n            if ( baseResource != null ) {\n                final Iterator<Resource> topicIter = baseResource.listChildren();\n                while ( topicIter.hasNext() ) {\n                    final Resource topicResource = topicIter.next();\n                    logger.debug(\"Found topic {}\", topicResource.getName());\n\n                    // init topic\n                    initTopic(topicResource);\n                }\n            }\n        } finally {\n            resolver.close();\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create a new resource resolver for reading and writing the resource tree.\n     * The resolver needs to be closed by the client.\n     * @return A resource resolver\n     * @throws RuntimeException if the resolver can't be created.\n     */\n    public ResourceResolver createResourceResolver() {\n        ResourceResolver resolver = null;\n        try {\n            resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n        } catch ( final LoginException le) {\n            logger.error(\"Unable to create new resource resolver: \" + le.getMessage(), le);\n            throw new RuntimeException(le);\n        }\n        return resolver;\n    }","id":572,"modified_method":"/**\n     * Create a new resource resolver for reading and writing the resource tree.\n     * The resolver needs to be closed by the client.\n     * @return A resource resolver or {@code null} if the component is already deactivated.\n     * @throws RuntimeException if the resolver can't be created.\n     */\n    public ResourceResolver createResourceResolver() {\n        ResourceResolver resolver = null;\n        final ResourceResolverFactory factory = this.resourceResolverFactory;\n        if ( factory != null ) {\n            try {\n                resolver = this.resourceResolverFactory.getAdministrativeResourceResolver(null);\n            } catch ( final LoginException le) {\n                logger.error(\"Unable to create new resource resolver: \" + le.getMessage(), le);\n                throw new RuntimeException(le);\n            }\n        }\n        return resolver;\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Upgrade bridged jobs\n     * @param rootResource  The root resource (topic resource)\n     */\n    private void upgradeBridgedJobs(final Resource topicResource) {\n        final String topicName = topicResource.getName().replace('.', '/');\n        final QueueInfo info = configuration.getQueueConfigurationManager().getQueueInfo(topicName);\n        JobTopicTraverser.traverse(logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n            @Override\n            public boolean handle(final Resource rsrc) {\n                try {\n                    final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                    final String targetId = caps.detectTarget(topicName, vm, info);\n\n                    final Map<String, Object> props = new HashMap<String, Object>(vm);\n                    final String newPath;\n                    if ( targetId != null ) {\n                        newPath = configuration.getAssginedJobsPath() + '/' + targetId + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                        props.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                        props.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                    } else {\n                        newPath = configuration.getUnassignedJobsPath() + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                        props.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n                        props.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n                    }\n                    props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n                    try {\n                        ResourceHelper.getOrCreateResource(topicResource.getResourceResolver(), newPath, props);\n                        topicResource.getResourceResolver().delete(rsrc);\n                        topicResource.getResourceResolver().commit();\n                    } catch ( final PersistenceException pe ) {\n                        logger.warn(\"Unable to move job from previous version \" + rsrc.getPath(), pe);\n                        topicResource.getResourceResolver().refresh();\n                        topicResource.getResourceResolver().revert();\n                    }\n                } catch (final InstantiationException ie) {\n                    logger.warn(\"Unable to move job from previous version \" + rsrc.getPath(), ie);\n                    topicResource.getResourceResolver().refresh();\n                    topicResource.getResourceResolver().revert();\n                }\n                return caps.isActive();\n            }\n        });\n    }","id":573,"modified_method":"/**\n     * Upgrade bridged jobs\n     * @param rootResource  The root resource (topic resource)\n     */\n    private void upgradeBridgedJobs(final Resource topicResource) {\n        final String topicName = topicResource.getName().replace('.', '/');\n        final QueueConfigurationManager qcm = configuration.getQueueConfigurationManager();\n        if ( qcm == null ) {\n            return;\n        }\n        final QueueInfo info = qcm.getQueueInfo(topicName);\n        JobTopicTraverser.traverse(logger, topicResource, new JobTopicTraverser.ResourceCallback() {\n\n            @Override\n            public boolean handle(final Resource rsrc) {\n                try {\n                    final ValueMap vm = ResourceHelper.getValueMap(rsrc);\n                    final String targetId = caps.detectTarget(topicName, vm, info);\n\n                    final Map<String, Object> props = new HashMap<String, Object>(vm);\n                    final String newPath;\n                    if ( targetId != null ) {\n                        newPath = configuration.getAssginedJobsPath() + '/' + targetId + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                        props.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                        props.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                    } else {\n                        newPath = configuration.getUnassignedJobsPath() + '/' + topicResource.getName() + rsrc.getPath().substring(topicResource.getPath().length());\n                        props.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n                        props.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n                    }\n                    props.remove(Job.PROPERTY_JOB_STARTED_TIME);\n                    try {\n                        ResourceHelper.getOrCreateResource(topicResource.getResourceResolver(), newPath, props);\n                        topicResource.getResourceResolver().delete(rsrc);\n                        topicResource.getResourceResolver().commit();\n                    } catch ( final PersistenceException pe ) {\n                        logger.warn(\"Unable to move job from previous version \" + rsrc.getPath(), pe);\n                        topicResource.getResourceResolver().refresh();\n                        topicResource.getResourceResolver().revert();\n                    }\n                } catch (final InstantiationException ie) {\n                    logger.warn(\"Unable to move job from previous version \" + rsrc.getPath(), ie);\n                    topicResource.getResourceResolver().refresh();\n                    topicResource.getResourceResolver().revert();\n                }\n                return caps.isActive();\n            }\n        });\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Upgrade bridged jobs.\n     * In previous versions, bridged jobs were stored under a special topic.\n     * This has changed, the jobs are now stored with their real topic.\n     */\n    private void upgradeBridgedJobs() {\n        final String path = configuration.getLocalJobsPath() + '/' + JobImpl.PROPERTY_BRIDGED_EVENT;\n        final ResourceResolver resolver = configuration.createResourceResolver();\n        try {\n            final Resource rootResource = resolver.getResource(path);\n            if ( rootResource != null ) {\n                upgradeBridgedJobs(rootResource);\n            }\n            if ( caps.isLeader() ) {\n                final Resource unassignedRoot = resolver.getResource(configuration.getUnassignedJobsPath() + '/' + JobImpl.PROPERTY_BRIDGED_EVENT);\n                if ( unassignedRoot != null ) {\n                    upgradeBridgedJobs(unassignedRoot);\n                }\n            }\n        } finally {\n            resolver.close();\n        }\n    }","id":574,"modified_method":"/**\n     * Upgrade bridged jobs.\n     * In previous versions, bridged jobs were stored under a special topic.\n     * This has changed, the jobs are now stored with their real topic.\n     */\n    private void upgradeBridgedJobs() {\n        final String path = configuration.getLocalJobsPath() + '/' + JobImpl.PROPERTY_BRIDGED_EVENT;\n        final ResourceResolver resolver = configuration.createResourceResolver();\n        if ( resolver != null ) {\n            try {\n                final Resource rootResource = resolver.getResource(path);\n                if ( rootResource != null ) {\n                    upgradeBridgedJobs(rootResource);\n                }\n                if ( caps.isLeader() ) {\n                    final Resource unassignedRoot = resolver.getResource(configuration.getUnassignedJobsPath() + '/' + JobImpl.PROPERTY_BRIDGED_EVENT);\n                    if ( unassignedRoot != null ) {\n                        upgradeBridgedJobs(unassignedRoot);\n                    }\n                }\n            } finally {\n                resolver.close();\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Move a single job\n     */\n    private void moveJobFromPreviousVersion(final Resource jobResource)\n    throws PersistenceException {\n        final ResourceResolver resolver = jobResource.getResourceResolver();\n\n        try {\n            final ValueMap vm = ResourceHelper.getValueMap(jobResource);\n            // check for binary properties\n            Map<String, Object> binaryProperties = new HashMap<String, Object>();\n            final ObjectInputStream ois = vm.get(\"slingevent:properties\", ObjectInputStream.class);\n            if ( ois != null ) {\n                try {\n                    int length = ois.readInt();\n                    for(int i=0;i<length;i++) {\n                        final String key = (String)ois.readObject();\n                        final Object value = ois.readObject();\n                        binaryProperties.put(key, value);\n                    }\n                } catch (final ClassNotFoundException cnfe) {\n                    throw new PersistenceException(\"Class not found.\", cnfe);\n                } catch (final java.io.InvalidClassException ice) {\n                    throw new PersistenceException(\"Invalid class.\", ice);\n                } catch (final IOException ioe) {\n                    throw new PersistenceException(\"Unable to deserialize job properties.\", ioe);\n                } finally {\n                    try {\n                        ois.close();\n                    } catch (final IOException ioe) {\n                        throw new PersistenceException(\"Unable to deserialize job properties.\", ioe);\n                    }\n                }\n            }\n\n            final Map<String, Object> properties = ResourceHelper.cloneValueMap(vm);\n\n            properties.put(JobImpl.PROPERTY_BRIDGED_EVENT, true);\n            final String topic = (String)properties.remove(\"slingevent:topic\");\n            properties.put(ResourceHelper.PROPERTY_JOB_TOPIC, topic);\n\n            properties.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n            properties.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n            // and binary properties\n            properties.putAll(binaryProperties);\n            properties.remove(\"slingevent:properties\");\n\n            if ( !properties.containsKey(Job.PROPERTY_JOB_RETRIES) ) {\n                properties.put(Job.PROPERTY_JOB_RETRIES, 10); // we put a dummy value here; this gets updated by the queue\n            }\n            if ( !properties.containsKey(Job.PROPERTY_JOB_RETRY_COUNT) ) {\n                properties.put(Job.PROPERTY_JOB_RETRY_COUNT, 0);\n            }\n\n            final List<InstanceDescription> potentialTargets = caps.getPotentialTargets(\"/\", null);\n            String targetId = null;\n            if ( potentialTargets != null && potentialTargets.size() > 0 ) {\n                final QueueInfo info = configuration.getQueueConfigurationManager().getQueueInfo(topic);\n                logger.debug(\"Found queue {} for {}\", info.queueConfiguration, topic);\n                targetId = caps.detectTarget(topic, vm, info);\n                if ( targetId != null ) {\n                    properties.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                    properties.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                    properties.put(Job.PROPERTY_JOB_RETRIES, info.queueConfiguration.getMaxRetries());\n                }\n            }\n\n            properties.put(Job.PROPERTY_JOB_CREATED_INSTANCE, \"old:\" + Environment.APPLICATION_ID);\n            properties.put(ResourceResolver.PROPERTY_RESOURCE_TYPE, ResourceHelper.RESOURCE_TYPE_JOB);\n\n            final String jobId = configuration.getUniqueId(topic);\n            properties.put(ResourceHelper.PROPERTY_JOB_ID, jobId);\n            properties.remove(Job.PROPERTY_JOB_STARTED_TIME);\n\n            final String newPath = configuration.getUniquePath(targetId, topic, jobId, vm);\n            this.logger.debug(\"Moving 'old' job from {} to {}\", jobResource.getPath(), newPath);\n\n            ResourceHelper.getOrCreateResource(resolver, newPath, properties);\n            resolver.delete(jobResource);\n            resolver.commit();\n        } catch (final InstantiationException ie) {\n            throw new PersistenceException(\"Exception while reading reasource: \" + ie.getMessage(), ie.getCause());\n        }\n    }","id":575,"modified_method":"/**\n     * Move a single job\n     */\n    private void moveJobFromPreviousVersion(final Resource jobResource)\n    throws PersistenceException {\n        final ResourceResolver resolver = jobResource.getResourceResolver();\n\n        try {\n            final ValueMap vm = ResourceHelper.getValueMap(jobResource);\n            // check for binary properties\n            Map<String, Object> binaryProperties = new HashMap<String, Object>();\n            final ObjectInputStream ois = vm.get(\"slingevent:properties\", ObjectInputStream.class);\n            if ( ois != null ) {\n                try {\n                    int length = ois.readInt();\n                    for(int i=0;i<length;i++) {\n                        final String key = (String)ois.readObject();\n                        final Object value = ois.readObject();\n                        binaryProperties.put(key, value);\n                    }\n                } catch (final ClassNotFoundException cnfe) {\n                    throw new PersistenceException(\"Class not found.\", cnfe);\n                } catch (final java.io.InvalidClassException ice) {\n                    throw new PersistenceException(\"Invalid class.\", ice);\n                } catch (final IOException ioe) {\n                    throw new PersistenceException(\"Unable to deserialize job properties.\", ioe);\n                } finally {\n                    try {\n                        ois.close();\n                    } catch (final IOException ioe) {\n                        throw new PersistenceException(\"Unable to deserialize job properties.\", ioe);\n                    }\n                }\n            }\n\n            final Map<String, Object> properties = ResourceHelper.cloneValueMap(vm);\n\n            properties.put(JobImpl.PROPERTY_BRIDGED_EVENT, true);\n            final String topic = (String)properties.remove(\"slingevent:topic\");\n            properties.put(ResourceHelper.PROPERTY_JOB_TOPIC, topic);\n\n            properties.remove(Job.PROPERTY_JOB_QUEUE_NAME);\n            properties.remove(Job.PROPERTY_JOB_TARGET_INSTANCE);\n            // and binary properties\n            properties.putAll(binaryProperties);\n            properties.remove(\"slingevent:properties\");\n\n            if ( !properties.containsKey(Job.PROPERTY_JOB_RETRIES) ) {\n                properties.put(Job.PROPERTY_JOB_RETRIES, 10); // we put a dummy value here; this gets updated by the queue\n            }\n            if ( !properties.containsKey(Job.PROPERTY_JOB_RETRY_COUNT) ) {\n                properties.put(Job.PROPERTY_JOB_RETRY_COUNT, 0);\n            }\n\n            final List<InstanceDescription> potentialTargets = caps.getPotentialTargets(\"/\", null);\n            String targetId = null;\n            if ( potentialTargets != null && potentialTargets.size() > 0 ) {\n                final QueueConfigurationManager qcm = configuration.getQueueConfigurationManager();\n                if ( qcm == null ) {\n                    resolver.revert();\n                    return;\n                }\n                final QueueInfo info = qcm.getQueueInfo(topic);\n                logger.debug(\"Found queue {} for {}\", info.queueConfiguration, topic);\n                targetId = caps.detectTarget(topic, vm, info);\n                if ( targetId != null ) {\n                    properties.put(Job.PROPERTY_JOB_QUEUE_NAME, info.queueName);\n                    properties.put(Job.PROPERTY_JOB_TARGET_INSTANCE, targetId);\n                    properties.put(Job.PROPERTY_JOB_RETRIES, info.queueConfiguration.getMaxRetries());\n                }\n            }\n\n            properties.put(Job.PROPERTY_JOB_CREATED_INSTANCE, \"old:\" + Environment.APPLICATION_ID);\n            properties.put(ResourceResolver.PROPERTY_RESOURCE_TYPE, ResourceHelper.RESOURCE_TYPE_JOB);\n\n            final String jobId = configuration.getUniqueId(topic);\n            properties.put(ResourceHelper.PROPERTY_JOB_ID, jobId);\n            properties.remove(Job.PROPERTY_JOB_STARTED_TIME);\n\n            final String newPath = configuration.getUniquePath(targetId, topic, jobId, vm);\n            this.logger.debug(\"Moving 'old' job from {} to {}\", jobResource.getPath(), newPath);\n\n            ResourceHelper.getOrCreateResource(resolver, newPath, properties);\n            resolver.delete(jobResource);\n            resolver.commit();\n        } catch (final InstantiationException ie) {\n            throw new PersistenceException(\"Exception while reading reasource: \" + ie.getMessage(), ie.getCause());\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Handle jobs from previous versions (<= 3.1.4) by moving them to the unassigned area\n     */\n    private void processJobsFromPreviousVersions() {\n        final ResourceResolver resolver = configuration.createResourceResolver();\n        try {\n            this.processJobsFromPreviousVersions(resolver.getResource(configuration.getPreviousVersionAnonPath()));\n            this.processJobsFromPreviousVersions(resolver.getResource(configuration.getPreviousVersionIdentifiedPath()));\n        } catch ( final PersistenceException pe ) {\n            this.logger.warn(\"Problems moving jobs from previous version.\", pe);\n        } finally {\n            resolver.close();\n        }\n    }","id":576,"modified_method":"/**\n     * Handle jobs from previous versions (<= 3.1.4) by moving them to the unassigned area\n     */\n    private void processJobsFromPreviousVersions() {\n        final ResourceResolver resolver = configuration.createResourceResolver();\n        if ( resolver != null ) {\n            try {\n                this.processJobsFromPreviousVersions(resolver.getResource(configuration.getPreviousVersionAnonPath()));\n                this.processJobsFromPreviousVersions(resolver.getResource(configuration.getPreviousVersionIdentifiedPath()));\n            } catch ( final PersistenceException pe ) {\n                this.logger.warn(\"Problems moving jobs from previous version.\", pe);\n            } finally {\n                resolver.close();\n            }\n        }\n    }","commit_id":"6b13b245a296daea04e424bbddd473eaeeebc49c","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected String getTag(String title, boolean shouldUseHtml)\n\t{\n\t\tif (shouldUseHtml) {\n\t\t\treturn (\"<hr/><br/>\" + rb.getString(\"this\") + \" \"\n\t\t\t\t\t+ ServerConfigurationService.getString(\"ui.service\", \"Sakai\") + \" (<a href=\\\"\"\n\t\t\t\t\t+ ServerConfigurationService.getPortalUrl() + \"\\\">\" + ServerConfigurationService.getPortalUrl() + \"<\/a>) \"\n\t\t\t\t\t+ rb.getString(\"forthe\") + \" \" + title + \" \" + rb.getString(\"site\") + \"<br/>\" + rb.getString(\"youcan\") + \"<br/>\");\n\t\t} else {\n\t\t\treturn (rb.getString(\"separator\") + \"\\n\" + rb.getString(\"this\") + \" \"\n\t\t\t\t\t+ ServerConfigurationService.getString(\"ui.service\", \"Sakai\") + \" (\" + ServerConfigurationService.getPortalUrl()\n\t\t\t\t\t+ \") \" + rb.getString(\"forthe\") + \" \" + title + \" \" + rb.getString(\"site\") + \"\\n\" + rb.getString(\"youcan\")\n\t\t\t\t\t+ \"\\n\");\n\t\t}\n\t}","id":577,"modified_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected String getTag(String title, boolean shouldUseHtml)\n\t{\n\t\tif (shouldUseHtml) {\n\t\t\treturn rb.getFormattedMessage(\"noti.tag.html\", new Object[]{ServerConfigurationService.getString(\"ui.service\", \"Sakai\"), ServerConfigurationService.getPortalUrl(), title});\n\t\t} else {\n\t\t\treturn rb.getFormattedMessage(\"noti.tag\", new Object[]{ServerConfigurationService.getString(\"ui.service\", \"Sakai\"), ServerConfigurationService.getPortalUrl(), title});\n\t\t}\n\t}","commit_id":"53bd21f9b28484a2eda3d6a170a6bf75bf280761","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Format the announcement notification subject line.\n\t * \n\t * @param event\n\t *        The event that matched criteria to cause the notification.\n\t * @return the announcement notification subject line.\n\t */\n\tprotected String getSubject(Event event)\n\t{\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tAnnouncementMessage msg = (AnnouncementMessage) ref.getEntity();\n\t\tAnnouncementMessageHeader hdr = (AnnouncementMessageHeader) msg.getAnnouncementHeader();\n\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore)\n\t\t{\n\t\t}\n\n\t\t// use the message's subject\n\t\treturn \"[ \" + title + \" - \" + rb.getString(\"Announcement\") + \" ]   \" + hdr.getSubject();\n\t}","id":578,"modified_method":"/**\n\t * Format the announcement notification subject line.\n\t * \n\t * @param event\n\t *        The event that matched criteria to cause the notification.\n\t * @return the announcement notification subject line.\n\t */\n\tprotected String getSubject(Event event)\n\t{\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tAnnouncementMessage msg = (AnnouncementMessage) ref.getEntity();\n\t\tAnnouncementMessageHeader hdr = (AnnouncementMessageHeader) msg.getAnnouncementHeader();\n\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore)\n\t\t{\n\t\t}\n\n\t\t// use the message's subject\n\t\treturn rb.getFormattedMessage(\"noti.subj\", new Object[]{title, hdr.getSubject()});\n\t}","commit_id":"53bd21f9b28484a2eda3d6a170a6bf75bf280761","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected String htmlContent(Event event)\n\t{\n\t\tStringBuilder buf = new StringBuilder();\n\t\tString newline = \"<br />\\n\";\n\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tAnnouncementMessage msg = (AnnouncementMessage) ref.getEntity();\n\t\tAnnouncementMessageHeader hdr = (AnnouncementMessageHeader) msg.getAnnouncementHeader();\n\t\t\t\t\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore)\n\t\t{\n\t\t}\n\n\t\t// Now build up the message text.\n\t\tbuf.append(rb.getString(\"An_announcement_has_been\"));\n\t\tif (AnnouncementService.SECURE_ANNC_ADD.equals(event.getEvent()))\n\t\t{\n\t\t\tbuf.append(\" \" + rb.getString(\"added\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuf.append(\" \" + rb.getString(\"updated\"));\n\t\t}\n\t\tbuf.append(\" \" + rb.getString(\"in_the\") + \" \\\"\");\n\t\tbuf.append(title);\n\t\tbuf.append(\"\\\" \" + rb.getString(\"site_at\"));\n\t\tbuf.append(\" \" + ServerConfigurationService.getString(\"ui.service\", \"Sakai\"));\n\t\tbuf.append(\" (<a href=\\\"\");\n\t\tbuf.append(ServerConfigurationService.getPortalUrl());\n\t\tbuf.append(\"/site/\");\n\t\tbuf.append(siteId);\n\t\tbuf.append(\"\\\">\");\n\t\tbuf.append(ServerConfigurationService.getPortalUrl());\n\t\tbuf.append(\"/site/\");\n\t\tbuf.append(siteId);\n\t\tbuf.append(\"<\/a>)\");\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Subject\") + \": \");\n\t\tbuf.append(hdr.getSubject());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"From\") + \": \");\n\t\tbuf.append(hdr.getFrom().getDisplayName());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Date\") + \": \");\n\t\tbuf.append(hdr.getDate().toStringLocalFull());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Group\") + \": \");\n\t\tbuf.append(getAnnouncementGroup(msg));\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Message\") + \": \");\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(msg.getBody());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\n\t\t// add any attachments\n\t\tList attachments = hdr.getAttachments();\n\t\tif (attachments.size() > 0)\n\t\t{\n\t\t\tbuf.append(newline + rb.getString(\"Attachments\") + newline);\n\t\t\tfor (Iterator iAttachments = attachments.iterator(); iAttachments.hasNext();)\n\t\t\t{\n\t\t\t\tReference attachment = (Reference) iAttachments.next();\n\t\t\t\tString attachmentTitle = attachment.getProperties().getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\t\t\t\tbuf.append(\"<a href=\\\"\" + attachment.getUrl() + \"\\\">\" + attachmentTitle + \"<\/a>\" + newline);\n\t\t\t}\n\t\t}\n\n\t\treturn buf.toString();\n\t}","id":579,"modified_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected String htmlContent(Event event)\n\t{\n\t\tStringBuilder buf = new StringBuilder();\n\t\tString newline = \"<br />\\n\";\n\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tAnnouncementMessage msg = (AnnouncementMessage) ref.getEntity();\n\t\tAnnouncementMessageHeader hdr = (AnnouncementMessageHeader) msg.getAnnouncementHeader();\n\t\t\t\t\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore)\n\t\t{\n\t\t}\n\n\t\t// Now build up the message text.\n\t\tif (AnnouncementService.SECURE_ANNC_ADD.equals(event.getEvent()))\n\t\t{\n\t\t\tbuf.append(rb.getFormattedMessage(\"noti.header.add\", new Object[]{title,ServerConfigurationService.getString(\"ui.service\", \"Sakai\"),ServerConfigurationService.getPortalUrl(), siteId}));\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuf.append(rb.getFormattedMessage(\"noti.header.update\", new Object[]{title,ServerConfigurationService.getString(\"ui.service\", \"Sakai\"),ServerConfigurationService.getPortalUrl(), siteId}));\n\n\t\t}\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Subject\"));\n\t\tbuf.append(hdr.getSubject());\n\t\t//buf.append(rb.getString(\"Subject\") + \": \"); buf.append(hdr.getSubject());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"From\"));\n\t\tbuf.append(hdr.getFrom().getDisplayName());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Date\"));\n\t\tbuf.append(hdr.getDate().toStringLocalFull());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Group\"));\n\t\tbuf.append(getAnnouncementGroup(msg));\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(rb.getString(\"Message\"));\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\t\tbuf.append(msg.getBody());\n\t\tbuf.append(newline);\n\t\tbuf.append(newline);\n\n\t\t// add any attachments\n\t\tList attachments = hdr.getAttachments();\n\t\tif (attachments.size() > 0)\n\t\t{\n\t\t\tbuf.append(newline + rb.getString(\"Attachments\") + newline);\n\t\t\tfor (Iterator iAttachments = attachments.iterator(); iAttachments.hasNext();)\n\t\t\t{\n\t\t\t\tReference attachment = (Reference) iAttachments.next();\n\t\t\t\tString attachmentTitle = attachment.getProperties().getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\t\t\t\tbuf.append(\"<a href=\\\"\" + attachment.getUrl() + \"\\\">\" + attachmentTitle + \"<\/a>\" + newline);\n\t\t\t}\n\t\t}\n\n\t\treturn buf.toString();\n\t}","commit_id":"53bd21f9b28484a2eda3d6a170a6bf75bf280761","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t\t * a (MailArchiveMessage) cover for addMessage to add a new message to this channel.\n\t\t * \n\t\t * @param subject\n\t\t *        The message header subject.\n\t\t * @param fromAddress\n\t\t *        The mail from: address from the message.\n\t\t * @param dateSent\n\t\t *        The date: sent from the message.\n\t\t * @param mailHeaders\n\t\t *        The full set of mail headers from the message.\n\t\t * @param attachments\n\t\t *        The message header attachments, a vector of Reference objects.\n\t\t * @param body\n\t\t *        The message body.\n\t\t * @return The newly added message.\n\t\t * @exception PermissionException\n\t\t *            If the user does not have write permission to the channel.\n\t\t */\n\t\tpublic MailArchiveMessage addMailArchiveMessage(String subject, String fromAddress, Time dateSent, List mailHeaders,\n\t\t\t\tList attachments, String body) throws PermissionException\n\t\t{\n\t\t\tMailArchiveMessageEdit edit = (MailArchiveMessageEdit) addMessage();\n\t\t\tMailArchiveMessageHeaderEdit header = edit.getMailArchiveHeaderEdit();\n\t\t\tedit.setBody(body);\n\t\t\theader.replaceAttachments(attachments);\n\t\t\theader.setSubject(subject);\n\t\t\theader.setFromAddress(fromAddress);\n\t\t\theader.setDateSent(dateSent);\n\t\t\theader.setMailHeaders(mailHeaders);\n\n\t\t\t// lets make sure that folks who have signed up for email get it\n\t\t\tcommitMessage(edit, NotificationService.NOTI_OPTIONAL);\n\n\t\t\treturn edit;\n\n\t\t}","id":580,"modified_method":"/**\n\t\t * a (MailArchiveMessage) cover for addMessage to add a new message to this channel.\n\t\t * \n\t\t * @param subject\n\t\t *        The message header subject.\n\t\t * @param fromAddress\n\t\t *        The mail from: address from the message.\n\t\t * @param dateSent\n\t\t *        The date: sent from the message.\n\t\t * @param mailHeaders\n\t\t *        The full set of mail headers from the message.\n\t\t * @param attachments\n\t\t *        The message header attachments, a vector of Reference objects.\n\t\t * @param body\n\t\t *        The message body.- body[0] is plain/text; body[1] is html/text\n\t\t * @return The newly added message.\n\t\t * @exception PermissionException\n\t\t *            If the user does not have write permission to the channel.\n\t\t */\n\t\tpublic MailArchiveMessage addMailArchiveMessage(String subject, String fromAddress, Time dateSent, List mailHeaders,\n\t\t\t\tList attachments, String[] body) throws PermissionException\n\t\t{\n\t\t\tMailArchiveMessageEdit edit = (MailArchiveMessageEdit) addMessage();\n\t\t\tMailArchiveMessageHeaderEdit header = edit.getMailArchiveHeaderEdit();\n\t\t\tedit.setBody(body[0]); \n\t\t\tedit.setHtmlBody(body[1]);\n\t\t\theader.replaceAttachments(attachments);\n\t\t\theader.setSubject(subject);\n\t\t\theader.setFromAddress(fromAddress);\n\t\t\theader.setDateSent(dateSent);\n\t\t\theader.setMailHeaders(mailHeaders);\n\n\t\t\t// lets make sure that folks who have signed up for email get it\n\t\t\tcommitMessage(edit, NotificationService.NOTI_OPTIONAL);\n\n\t\t\treturn edit;\n\n\t\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param channel\n\t\t *        The channel in which this message lives.\n\t\t * @param id\n\t\t *        The message id.\n\t\t */\n\t\tpublic BaseMailArchiveMessageEdit(MessageChannel channel, String id)\n\t\t{\n\t\t\tsuper(channel, id);\n\n\t\t}","id":581,"modified_method":"/**\n\t\t * Construct.\n\t\t * \n\t\t * @param channel\n\t\t *        The channel in which this message lives.\n\t\t * @param id\n\t\t *        The message id.\n\t\t */\n\t\tpublic BaseMailArchiveMessageEdit(MessageChannel channel, String id)\n\t\t{\n\t\t\tsuper(channel, id);\n\t\t\tm_html_body = \"\";\n\n\t\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t\t * Construct from an existing definition, in xml.\n\t\t * \n\t\t * @param channel\n\t\t *        The channel in which this message lives.\n\t\t * @param el\n\t\t *        The message in XML in a DOM element.\n\t\t */\n\t\tpublic BaseMailArchiveMessageEdit(MessageChannel channel, Element el)\n\t\t{\n\t\t\tsuper(channel, el);\n\n\t\t}","id":582,"modified_method":"/**\n\t\t * Construct from an existing definition, in xml.\n\t\t * \n\t\t * @param channel\n\t\t *        The channel in which this message lives.\n\t\t * @param el\n\t\t *        The message in XML in a DOM element.\n\t\t */\n\t\tpublic BaseMailArchiveMessageEdit(MessageChannel channel, Element el)\n\t\t{\n\t\t\tthis(channel, \"\");\n\n\t\t\tm_html_body = Xml.decodeAttribute(el, \"body-html\");\n\t\t\tm_body      = Xml.decodeAttribute(el, \"body\");\n\n\t\t\t// the children (header, body)\n\t\t\tNodeList children = el.getChildNodes();\n\t\t\tfinal int length = children.getLength();\n\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tNode child = children.item(i);\n\t\t\t\tif (child.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t{\n\t\t\t\t\tElement element = (Element) child;\n\n\t\t\t\t\t// look for a header\n\t\t\t\t\tif (element.getTagName().equals(\"header\"))\n\t\t\t\t\t{\n\t\t\t\t\t\t// re-create a header\n\t\t\t\t\t\tm_header = newMessageHeader(this, element);\n\t\t\t\t\t}\n\n\t\t\t\t\t// or look for a body (old style of encoding)\n\t\t\t\t\telse if (element.getTagName().equals(\"body\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((element.getChildNodes() != null) && (element.getChildNodes().item(0) != null))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// convert from plaintext messages to formatted text messages\n\t\t\t\t\t\t\tm_body = element.getChildNodes().item(0).getNodeValue();\n\t\t\t\t\t\t\tif (m_body != null) m_body = FormattedText.convertPlaintextToFormattedText(m_body);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m_body == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_body = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// or look for properties\n\t\t\t\t\telse if (element.getTagName().equals(\"properties\"))\n\t\t\t\t\t{\n\t\t\t\t\t\t// re-create properties\n\t\t\t\t\t\tm_properties = new BaseResourcePropertiesEdit(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Process incoming mail.\n\t * \n\t * @param mail\n\t *        ...\n\t */\n\tpublic void service(Mail mail) throws MessagingException\n\t{\n\t\t// get the postmaster user\n\t\tUser postmaster = null;\n\t\ttry\n\t\t{\n\t\t\tpostmaster = UserDirectoryService.getUser(POSTMASTER);\n\t\t}\n\t\tcatch (UserNotDefinedException e)\n\t\t{\n\t\t\tM_log.warn(\"service: no postmaster\");\n\t\t\tmail.setState(Mail.GHOST);\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// set the current user to postmaster\n\t\t\tSession s = SessionManager.getCurrentSession();\n\t\t\tif (s != null)\n\t\t\t{\n\t\t\t\ts.setUserId(postmaster.getId());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tM_log.warn(\"service - no SessionManager.getCurrentSession, cannot set to postmaser user\");\n\t\t\t}\n\n\t\t\tMimeMessage msg = mail.getMessage();\n\t\t\tString id = msg.getMessageID();\n\n\t\t\tAddress[] fromAddresses = msg.getFrom();\n\t\t\tString from = null;\n\t\t\tString fromAddr = null;\n\t\t\tif ((fromAddresses != null) && (fromAddresses.length == 1))\n\t\t\t{\n\t\t\t\tfrom = fromAddresses[0].toString();\n\t\t\t\tif (fromAddresses[0] instanceof InternetAddress)\n\t\t\t\t{\n\t\t\t\t\tfromAddr = ((InternetAddress) (fromAddresses[0])).getAddress();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfrom = mail.getSender().toString();\n\t\t\t\tfromAddr = mail.getSender().toInternetAddress().getAddress();\n\t\t\t\t// mail.getSender().getUser() + \"@\" + mail.getSender().getHost();\n\t\t\t}\n\n\t\t\tCollection to = mail.getRecipients();\n\n\t\t\tDate sent = msg.getSentDate();\n\n\t\t\tString subject = StringUtil.trimToNull(msg.getSubject());\n\t\t\tif (subject == null) subject = \"<no subject>\";\n\n\t\t\tEnumeration headers = msg.getAllHeaderLines();\n\t\t\tList mailHeaders = new Vector();\n\t\t\twhile (headers.hasMoreElements())\n\t\t\t{\n\t\t\t\tString line = (String) headers.nextElement();\n\t\t\t\tif (line.startsWith(\"Content-Type: \"))\n\t\t\t\t\tmailHeaders.add(line.replaceAll(\"Content-Type\", MailArchiveService.HEADER_OUTER_CONTENT_TYPE));\n\t\t\t\tmailHeaders.add(line);\n\t\t\t}\n\n\t\t\t// we will parse the body and attachments later, when we know we need to.\n\t\t\tString body = null;\n\t\t\tList attachments = null;\n\n\t\t\tM_log.info(id + \" : mail: from:\" + from + \" sent: \" + TimeService.newTime(sent.getTime()).toStringLocalFull() + \" subject: \"\n\t\t\t\t\t+ subject);\n\n\t\t\t// process for each recipient\n\t\t\tIterator it = to.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t{\n\t\t\t\tString mailId = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tMailAddress recipient = (MailAddress) it.next();\n\t\t\t\t\tM_log.info(id + \" : checking to: \" + recipient);\n\n\t\t\t\t\t// is the host ok? %%%\n\t\t\t\t\t// String host = recipient.getHost();\n\n\t\t\t\t\t// the recipient's mail id\n\t\t\t\t\tmailId = recipient.getUser();\n\n\t\t\t\t\t// eat the no-reply\n\t\t\t\t\tif (\"no-reply\".equalsIgnoreCase(mailId))\n\t\t\t\t\t{\n\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the channel (mailbox) that this is adressed to\n\t\t\t\t\t// for now, check only for it being a site or alias to a site.\n\t\t\t\t\t// %%% - add user and other later -ggolden\n\t\t\t\t\tMailArchiveChannel channel = null;\n\n\t\t\t\t\t// first, assume the mailId is a site id\n\t\t\t\t\tString channelRef = MailArchiveService.channelReference(mailId, SiteService.MAIN_CONTAINER);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel = MailArchiveService.getMailArchiveChannel(channelRef);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IdUnusedException goOn)\n\t\t\t\t\t{\n\t\t\t\t\t}\n\n\t\t\t\t\t// next, if not a site, see if it's an alias to a site or channel\n\t\t\t\t\tif (channel == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// if not an alias, it will throw the IdUnusedException caught below\n\t\t\t\t\t\tReference ref = EntityManager.newReference(AliasService.getTarget(mailId));\n\n\t\t\t\t\t\t// if ref is a site\n\t\t\t\t\t\tif (ref.getType().equals(SiteService.APPLICATION_ID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// now we have a site reference, try for it's channel\n\t\t\t\t\t\t\tchannelRef = MailArchiveService.channelReference(ref.getId(), SiteService.MAIN_CONTAINER);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if ref is a channel\n\t\t\t\t\t\telse if (ref.getType().equals(MailArchiveService.APPLICATION_ID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ref is a channel\n\t\t\t\t\t\t\tchannelRef = ref.getReference();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ref is something else\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM_log.info(id + \" : mail rejected: unknown address: \" + mailId);\n\n\t\t\t\t\t\t\tthrow new IdUnusedException(mailId);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if there's no channel for this site, it will throw the IdUnusedException caught below\n\t\t\t\t\t\tchannel = MailArchiveService.getMailArchiveChannel(channelRef);\n\t\t\t\t\t}\n\n\t\t\t\t\t// skip disabled channels\n\t\t\t\t\tif (!channel.getEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (from.startsWith(POSTMASTER))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmail.setErrorMessage(errorMsg_I);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tM_log.info(id + \" : mail rejected: channel not enabled: \" + mailId);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// for non-open channels, make sure the from is a member\n\t\t\t\t\tif (!channel.getOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\t// see if our fromAddr is the email address of any of the users who are permitted to add messages to the channel.\n\t\t\t\t\t\tif (!fromValidUser(fromAddr, channel))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM_log.info(id + \" : mail rejected: from: \" + fromAddr + \" not authorized for site: \" + mailId);\n\n\t\t\t\t\t\t\tmail.setErrorMessage(errorMsg_IV);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// prepare the message if it has not yet been prepared - we need it.%%%\n\t\t\t\t\tif (body == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbody = \"\";\n\t\t\t\t\t\tattachments = EntityManager.newReferenceList();\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStringBuilder bodyBuf = new StringBuilder();\n\t\t\t\t\t\t\tStringBuilder bodyContentType = new StringBuilder();\n\t\t\t\t\t\t\tInteger embedCount = parseParts(msg, id, bodyBuf, bodyContentType, attachments, new Integer(-1));\n\t\t\t\t\t\t\tbody = bodyBuf.toString();\n\t\t\t\t\t\t\t// remove extra line breaks added by mac Mail, perhaps others\n\t\t\t\t\t\t\t// characterized by a space followed by a line break\n\t\t\t\t\t\t\tbody = body.replaceAll(\" \\n\", \" \");\n\t\t\t\t\t\t\t// treat the message exactly as-is - as plaintext. Stuff like \"<b>\" will appear\n\t\t\t\t\t\t\t// to the users as \"<b>\", NOT as bolded text. Since the message service\n\t\t\t\t\t\t\t// treats messages as formatted text, plaintext must be converted to formatted text encoding.\n\t\t\t\t\t\t\tbody = FormattedText.convertPlaintextToFormattedText(body);\n\t\t\t\t\t\t\tif (bodyContentType.length() > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// save the content type of the message body - which may be different from the\n\t\t\t\t\t\t\t\t// overall MIME type of the message (multipart, etc)\n\t\t\t\t\t\t\t\tmailHeaders.add(MailArchiveService.HEADER_INNER_CONTENT_TYPE + \": \" + bodyContentType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (MessagingException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM_log.warn(\"service(): msg.getContent() threw: \" + e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM_log.warn(\"service(): msg.getContent() threw: \" + e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// post the message to the group's channel\n\t\t\t\t\tchannel.addMailArchiveMessage(subject, from.toString(), TimeService.newTime(sent.getTime()), mailHeaders,\n\t\t\t\t\t\t\tattachments, body);\n\n\t\t\t\t\tM_log.info(id + \" : delivered to:\" + mailId);\n\n\t\t\t\t\t// all is happy - ghost the message to stop further processing\n\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t}\n\t\t\t\tcatch (IdUnusedException goOn)\n\t\t\t\t{\n\t\t\t\t\t// if this is to the postmaster, and there's no site, channel or alias for the postmaster, then quietly eat the message\n\t\t\t\t\tif (POSTMASTER.equals(mailId))\n\t\t\t\t\t{\n\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (from.startsWith(POSTMASTER + \"@\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tM_log.info(id + \" : mail rejected: \" + goOn.toString());\n\t\t\t\t\tmail.setErrorMessage(errorMsg_III);\n\t\t\t\t}\n\t\t\t\tcatch (PermissionException e)\n\t\t\t\t{\n\t\t\t\t\tM_log.info(id + \" : \" + e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\t// clear out any current current bindings\n\t\t\tThreadLocalManager.clear();\n\t\t}\n\t}","id":583,"modified_method":"/**\n\t * Process incoming mail.\n\t * \n\t * @param mail\n\t *        ...\n\t */\n\tpublic void service(Mail mail) throws MessagingException\n\t{\n\t\t// get the postmaster user\n\t\tUser postmaster = null;\n\t\ttry\n\t\t{\n\t\t\tpostmaster = UserDirectoryService.getUser(POSTMASTER);\n\t\t}\n\t\tcatch (UserNotDefinedException e)\n\t\t{\n\t\t\tM_log.warn(\"service: no postmaster\");\n\t\t\tmail.setState(Mail.GHOST);\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// set the current user to postmaster\n\t\t\tSession s = SessionManager.getCurrentSession();\n\t\t\tif (s != null)\n\t\t\t{\n\t\t\t\ts.setUserId(postmaster.getId());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tM_log.warn(\"service - no SessionManager.getCurrentSession, cannot set to postmaser user\");\n\t\t\t}\n\n\t\t\tMimeMessage msg = mail.getMessage();\n\t\t\tString id = msg.getMessageID();\n\n\t\t\tAddress[] fromAddresses = msg.getFrom();\n\t\t\tString from = null;\n\t\t\tString fromAddr = null;\n\t\t\tif ((fromAddresses != null) && (fromAddresses.length == 1))\n\t\t\t{\n\t\t\t\tfrom = fromAddresses[0].toString();\n\t\t\t\tif (fromAddresses[0] instanceof InternetAddress)\n\t\t\t\t{\n\t\t\t\t\tfromAddr = ((InternetAddress) (fromAddresses[0])).getAddress();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfrom = mail.getSender().toString();\n\t\t\t\tfromAddr = mail.getSender().toInternetAddress().getAddress();\n\t\t\t\t// mail.getSender().getUser() + \"@\" + mail.getSender().getHost();\n\t\t\t}\n\n\t\t\tCollection to = mail.getRecipients();\n\n\t\t\tDate sent = msg.getSentDate();\n\n\t\t\tString subject = StringUtil.trimToNull(msg.getSubject());\n\t\t\tif (subject == null) subject = \"<no subject>\";\n\n\t\t\tEnumeration headers = msg.getAllHeaderLines();\n\t\t\tList mailHeaders = new Vector();\n\t\t\twhile (headers.hasMoreElements())\n\t\t\t{\n\t\t\t\tString line = (String) headers.nextElement();\n\t\t\t\tif (line.startsWith(\"Content-Type: \"))\n\t\t\t\t\tmailHeaders.add(line.replaceAll(\"Content-Type\", MailArchiveService.HEADER_OUTER_CONTENT_TYPE));\n\t\t\t\tmailHeaders.add(line);\n\t\t\t}\n\n\t\t\tM_log.debug(id + \" : mail: from:\" + from + \" sent: \" + TimeService.newTime(sent.getTime()).toStringLocalFull() + \" subject: \"\n\t\t\t\t\t+ subject);\n\n\t\t\t// process for each recipient\n\t\t\tIterator it = to.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t{\n\t\t\t\tString mailId = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tMailAddress recipient = (MailAddress) it.next();\n\t\t\t\t\tM_log.debug(id + \" : checking to: \" + recipient);\n\n\t\t\t\t\t// is the host ok? %%%\n\t\t\t\t\t// String host = recipient.getHost();\n\n\t\t\t\t\t// the recipient's mail id\n\t\t\t\t\tmailId = recipient.getUser();\n\n\t\t\t\t\t// eat the no-reply\n\t\t\t\t\tif (\"no-reply\".equalsIgnoreCase(mailId))\n\t\t\t\t\t{\n\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the channel (mailbox) that this is adressed to\n\t\t\t\t\t// for now, check only for it being a site or alias to a site.\n\t\t\t\t\t// %%% - add user and other later -ggolden\n\t\t\t\t\tMailArchiveChannel channel = null;\n\n\t\t\t\t\t// first, assume the mailId is a site id\n\t\t\t\t\tString channelRef = MailArchiveService.channelReference(mailId, SiteService.MAIN_CONTAINER);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel = MailArchiveService.getMailArchiveChannel(channelRef);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IdUnusedException goOn)\n\t\t\t\t\t{\n\t\t\t\t\t}\n\n\t\t\t\t\t// next, if not a site, see if it's an alias to a site or channel\n\t\t\t\t\tif (channel == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// if not an alias, it will throw the IdUnusedException caught below\n\t\t\t\t\t\tReference ref = EntityManager.newReference(AliasService.getTarget(mailId));\n\n\t\t\t\t\t\t// if ref is a site\n\t\t\t\t\t\tif (ref.getType().equals(SiteService.APPLICATION_ID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// now we have a site reference, try for it's channel\n\t\t\t\t\t\t\tchannelRef = MailArchiveService.channelReference(ref.getId(), SiteService.MAIN_CONTAINER);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if ref is a channel\n\t\t\t\t\t\telse if (ref.getType().equals(MailArchiveService.APPLICATION_ID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ref is a channel\n\t\t\t\t\t\t\tchannelRef = ref.getReference();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ref is something else\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM_log.info(id + \" : mail rejected: unknown address: \" + mailId);\n\n\t\t\t\t\t\t\tthrow new IdUnusedException(mailId);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if there's no channel for this site, it will throw the IdUnusedException caught below\n\t\t\t\t\t\tchannel = MailArchiveService.getMailArchiveChannel(channelRef);\n\t\t\t\t\t}\n\n\t\t\t\t\t// skip disabled channels\n\t\t\t\t\tif (!channel.getEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (from.startsWith(POSTMASTER))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString errMsg = rb.getString(\"err_email_off\") + \"\\n\\n\";\n\t\t\t\t\t\t\tString mailSupport = StringUtil.trimToNull( ServerConfigurationService.getString(\"mail.support\") );\n\t\t\t\t\t\t\tif ( mailSupport != null )\n\t\t\t\t\t\t\t\terrMsg +=(String) rb.getFormattedMessage(\"err_questions\",  new Object[]{mailSupport})+\"\\n\";\n\n\t\t\t\t\t\t\tmail.setErrorMessage(errMsg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tM_log.info(id + \" : mail rejected: channel not enabled: \" + mailId);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// for non-open channels, make sure the from is a member\n\t\t\t\t\tif (!channel.getOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\t// see if our fromAddr is the email address of any of the users who are permitted to add messages to the channel.\n\t\t\t\t\t\tif (!fromValidUser(fromAddr, channel))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM_log.info(id + \" : mail rejected: from: \" + fromAddr + \" not authorized for site: \" + mailId);\n\n\t\t\t\t\t\t\tString errMsg = rb.getString(\"err_not_member\") + \"\\n\\n\";\n\t\t\t\t\t\t\tString mailSupport = StringUtil.trimToNull( ServerConfigurationService.getString(\"mail.support\") );\n\t\t\t\t\t\t\tif ( mailSupport != null )\n\t\t\t\t\t\t\t\terrMsg +=(String) rb.getFormattedMessage(\"err_questions\",  new Object[]{mailSupport})+\"\\n\";\n\t\t\t\t\t\t\tmail.setErrorMessage(errMsg);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// prepare the message \n\t\t\t\t\tStringBuilder bodyBuf[] = new StringBuilder[2];\n\t\t\t\t\tbodyBuf[0] = new StringBuilder();\n\t\t\t\t\tbodyBuf[1] = new StringBuilder();\n\t\t\t\t\tList attachments = attachments = EntityManager.newReferenceList();\n\t\t\t\t\t\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tStringBuilder bodyContentType = new StringBuilder();\n\t\t\t\t\t\tInteger embedCount = parseParts(msg, id, bodyBuf, bodyContentType, attachments, new Integer(-1));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (bodyContentType.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// save the content type of the message body - which may be different from the\n\t\t\t\t\t\t\t// overall MIME type of the message (multipart, etc)\n\t\t\t\t\t\t\tmailHeaders.add(MailArchiveService.HEADER_INNER_CONTENT_TYPE + \": \" + bodyContentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MessagingException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tM_log.warn(\"service(): msg.getContent() threw: \" + e);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tM_log.warn(\"service(): msg.getContent() threw: \" + e);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// post the message to the group's channel\n\t\t\t\t\tString body[] = new String[2];\n\t\t\t\t\tbody[0] = bodyBuf[0].toString(); // plain/text\n\t\t\t\t\tbody[1] = bodyBuf[1].toString(); // html/text\n\t\t\t\t\t\n\t\t\t\t\tchannel.addMailArchiveMessage(subject, from.toString(), TimeService.newTime(sent.getTime()), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmailHeaders, attachments, body);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tM_log.debug(id + \" : delivered to:\" + mailId);\n\n\t\t\t\t\t// all is happy - ghost the message to stop further processing\n\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t}\n\t\t\t\tcatch (IdUnusedException goOn)\n\t\t\t\t{\n\t\t\t\t\t// if this is to the postmaster, and there's no site, channel or alias for the postmaster, then quietly eat the message\n\t\t\t\t\tif (POSTMASTER.equals(mailId))\n\t\t\t\t\t{\n\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (from.startsWith(POSTMASTER + \"@\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tmail.setState(Mail.GHOST);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tM_log.info(id + \" : mail rejected: \" + goOn.toString());\n\t\t\t\t\tString errMsg = rb.getString(\"err_addr_unknown\") + \"\\n\\n\";\n\t\t\t\t\tString mailSupport = StringUtil.trimToNull( ServerConfigurationService.getString(\"mail.support\") );\n\t\t\t\t\tif ( mailSupport != null )\n\t\t\t\t\t\terrMsg +=(String) rb.getFormattedMessage(\"err_questions\",  new Object[]{mailSupport})+\"\\n\";\n\t\t\t\t\tmail.setErrorMessage(errMsg);\n\t\t\t\t}\n\t\t\t\tcatch (PermissionException e)\n\t\t\t\t{\n\t\t\t\t\tM_log.info(id + \" : \" + e);\n\t\t\t\t}\n\t\t\t\tcatch (Exception  ex)\n\t\t\t\t{\n\t\t\t\t\tM_log.info(id + \" : \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\t// clear out any current current bindings\n\t\t\tThreadLocalManager.clear();\n\t\t}\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Create an attachment, adding it to the list of attachments.\n\t */\n\tprotected Reference createAttachment(List attachments, String type, String fileName, byte[] body, String id)\n\t{\n\t\t// we just want the file name part - strip off any drive and path stuff\n\t\tString name = Validator.getFileName(fileName);\n\t\tString resourceName = Validator.escapeResourceName(fileName);\n\n\t\t// make a set of properties to add for the new resource\n\t\tResourcePropertiesEdit props = ContentHostingService.newResourceProperties();\n\t\tprops.addProperty(ResourceProperties.PROP_DISPLAY_NAME, name);\n\t\tprops.addProperty(ResourceProperties.PROP_DESCRIPTION, fileName);\n\n\t\t// make an attachment resource for this URL\n\t\ttry\n\t\t{\n\t\t\tContentResource attachment = ContentHostingService.addAttachmentResource(resourceName, type, body, props);\n\n\t\t\t// add a dereferencer for this to the attachments\n\t\t\tReference ref = EntityManager.newReference(attachment.getReference());\n\t\t\tattachments.add(ref);\n\n\t\t\tM_log.info(id + \" : attachment: \" + ref.getReference() + \" size: \" + body.length);\n\n\t\t\treturn ref;\n\t\t}\n\t\tcatch (Exception any)\n\t\t{\n\t\t\tM_log.warn(id + \" : exception adding attachment resource: \" + name + \" : \" + any.toString());\n\t\t\treturn null;\n\t\t}\n\t}","id":584,"modified_method":"/**\n\t * Create an attachment, adding it to the list of attachments.\n\t */\n\tprotected Reference createAttachment(List attachments, String type, String fileName, byte[] body, String id)\n\t{\n\t\t// we just want the file name part - strip off any drive and path stuff\n\t\tString name = Validator.getFileName(fileName);\n\t\tString resourceName = Validator.escapeResourceName(fileName);\n\n\t\t// make a set of properties to add for the new resource\n\t\tResourcePropertiesEdit props = ContentHostingService.newResourceProperties();\n\t\tprops.addProperty(ResourceProperties.PROP_DISPLAY_NAME, name);\n\t\tprops.addProperty(ResourceProperties.PROP_DESCRIPTION, fileName);\n\n\t\t// make an attachment resource for this URL\n\t\ttry\n\t\t{\n\t\t\tContentResource attachment = ContentHostingService.addAttachmentResource(resourceName, type, body, props);\n\n\t\t\t// add a dereferencer for this to the attachments\n\t\t\tReference ref = EntityManager.newReference(attachment.getReference());\n\t\t\tattachments.add(ref);\n\n\t\t\tM_log.debug(id + \" : attachment: \" + ref.getReference() + \" size: \" + body.length);\n\n\t\t\treturn ref;\n\t\t}\n\t\tcatch (Exception any)\n\t\t{\n\t\t\tM_log.warn(id + \" : exception adding attachment resource: \" + name + \" : \" + any.toString());\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Breaks email messages into parts which can be saved as files (saves as attachments) or viewed as plain text (added to body of message).\n\t * \n\t * @param p\n\t *        The message-part embedded in a message..\n\t * @param id\n\t *        The string containing the message's id.\n\t * @param bodyBuf\n\t *        The string-buffer in which the message body is being built.\n\t * @param bodyContentType\n\t *        The value of the Content-Type header for the mesage body.\n\t * @param attachments\n\t *        The ReferenceVector in which references to attachments are collected.\n\t * @param embedCount\n\t *        An Integer that counts embedded messages (outer message is zero).\n\t * @return Value of embedCount (updated if this call processed any embedded messages).\n\t */\n\tprotected Integer parseParts(Part p, String id, StringBuilder bodyBuf, StringBuilder bodyContentType, List attachments,\n\t\t\tInteger embedCount) throws MessagingException, IOException\n\t{\n\t\tString closing = \"\";\n\t\t// process embedded messages\n\t\tif (p instanceof Message)\n\t\t{\n\t\t\t// increment embedded message counter\n\t\t\tint thisCount = embedCount.intValue() + 1;\n\t\t\tembedCount = new Integer(thisCount);\n\n\t\t\t// process inner messages, inserting start and end labels except for outer message.\n\t\t\tif (thisCount > 0)\n\t\t\t{\n\t\t\t\t// make sure previous message parts ended with newline\n\t\t\t\tif (bodyBuf.length() > 0 && bodyBuf.charAt(bodyBuf.length() - 1) != '\\n')\n\t\t\t\t{\n\t\t\t\t\tbodyBuf.append(\"\\n\");\n\t\t\t\t}\n\t\t\t\tbodyBuf.append(\"\\n========= Begin embedded email message \" + thisCount + \" =========\\n\\n\");\n\t\t\t\tparseEnvelope((Message) p, id, bodyBuf, attachments, embedCount);\n\t\t\t\tclosing = \"\\n========== End embedded email message \" + thisCount + \" ==========\\n\\n\";\n\t\t\t}\n\t\t}\n\n\t\tString type = p.getContentType();\n\n\t\t// discard if content-type is unknown\n\t\tif (type == null || type.equals(\"\"))\n\t\t{\n\t\t\t// do nothing\n\t\t}\n\t\t// add plain text to body\n\t\telse if (p.isMimeType(\"text/plain\") && p.getFileName() == null)\n\t\t{\n\t\t\tObject o = p.getContent();\n\t\t\tString txt = null;\n\t\t\tString innerContentType = p.getContentType();\n\n\t\t\tif (o instanceof String)\n\t\t\t{\n\t\t\t\ttxt = (String) p.getContent();\n\t\t\t\tif (bodyContentType != null && bodyContentType.length() == 0) bodyContentType.append(innerContentType);\n\t\t\t}\n\n\t\t\telse if (o instanceof InputStream)\n\t\t\t{\n\t\t\t\tInputStream in = (InputStream) o;\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\t\tbyte[] buf = new byte[in.available()];\n\t\t\t\tfor (int len = in.read(buf); len != -1; len = in.read(buf))\n\t\t\t\t\tout.write(buf, 0, len);\n\t\t\t\tString charset = (new ContentType(innerContentType)).getParameter(\"charset\");\n\t\t\t\ttxt = out.toString(MimeUtility.javaCharset(charset));\n\t\t\t\tif (bodyContentType != null && bodyContentType.length() == 0) bodyContentType.append(innerContentType);\n\t\t\t}\n\n\t\t\t// make sure previous message parts ended with newline\n\t\t\tif (bodyBuf.length() > 0 && bodyBuf.charAt(bodyBuf.length() - 1) != '\\n')\n\t\t\t{\n\t\t\t\tbodyBuf.append(\"\\n\");\n\t\t\t}\n\t\t\tbodyBuf.append(txt);\n\t\t}\n\t\t// process subparts of multiparts\n\t\telse if (p.isMimeType(\"multipart/*\"))\n\t\t{\n\t\t\tMultipart mp = (Multipart) p.getContent();\n\t\t\tint count = mp.getCount();\n\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t{\n\t\t\t\tembedCount = parseParts(mp.getBodyPart(i), id, bodyBuf, bodyContentType, attachments, embedCount);\n\t\t\t}\n\t\t}\n\t\t// process embedded messages\n\t\telse if (p.isMimeType(\"message/rfc822\"))\n\t\t{\n\t\t\tembedCount = parseParts((Part) p.getContent(), id, bodyBuf, bodyContentType, attachments, embedCount);\n\t\t}\n\t\t// Discard parts with mime-type application/applefile. If an e-mail message contains an attachment is sent from\n\t\t// a macintosh, you may get two parts, one for the data fork and one for the resource fork. The part that\n\t\t// corresponds to the resource fork confuses users, this has mime-type application/applefile. The best thing\n\t\t// is to discard it.\n\t\telse if (p.isMimeType(\"application/applefile\"))\n\t\t{\n\t\t\t// do nothing\n\t\t}\n\t\telse if (p.isMimeType(\"text/enriched\") && p.getFileName() == null)\n\t\t{\n\t\t\t// ignore this - it is a enriched text version of the message.\n\t\t\t// Sakai only uses the plain text version of the message.\n\t\t}\n\t\t// everything else gets treated as an attachment\n\t\telse\n\t\t{\n\t\t\tString name = p.getFileName();\n\t\t\t\n\t\t\t// look for filenames not parsed by getFileName() \n\t\t\tif ( name == null && type.indexOf(NAME_PREFIX) != -1 )\n\t\t\t{\n\t\t\t\tname = type.substring( type.indexOf(NAME_PREFIX)+NAME_PREFIX.length() );\n\t\t\t}\n\t\t\t// ContentType can't handle filenames with spaces or UTF8 characters\n\t\t\tif ( name != null )\n\t\t\t{\n\t\t\t\tString decodedName = MimeUtility.decodeText( name ); // first decode RFC 2047\n\t\t\t\ttype = type.replace( name, URLEncoder.encode(decodedName, \"UTF-8\") );\n\t\t\t\tname = decodedName;\n\t\t\t}\n\t\t\t\n\t\t\tContentType cType = new ContentType(type);\n\t\t\tString disposition = p.getDisposition();\n\t\t\tint approxSize = p.getSize();\n\n\t\t\tif (name == null)\n\t\t\t{\n\t\t\t\tname = \"unknown\";\n\t\t\t\t// if file's parent is multipart/alternative,\n\t\t\t\t// provide a better name for the file\n\t\t\t\tif (p instanceof BodyPart)\n\t\t\t\t{\n\t\t\t\t\tMultipart parent = ((BodyPart) p).getParent();\n\t\t\t\t\tif (parent != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tString pType = parent.getContentType();\n\t\t\t\t\t\tContentType pcType = new ContentType(pType);\n\t\t\t\t\t\tif (pcType.getBaseType().equalsIgnoreCase(\"multipart/alternative\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname = \"message\" + embedCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p.isMimeType(\"text/html\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".html\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/richtext\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".rtx\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/rtf\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".rtf\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/enriched\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".etf\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/plain\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".txt\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/xml\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".xml\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// read the attachments bytes, and create it as an attachment in content hosting\n\t\t\tbyte[] bodyBytes = readBody(approxSize, p.getInputStream());\n\t\t\tif ((bodyBytes != null) && (bodyBytes.length > 0))\n\t\t\t{\n\t\t\t\t// can we ignore the attachment it it's just whitespace chars??\n\t\t\t\tReference attachment = createAttachment(attachments, cType.getBaseType(), name, bodyBytes, id);\n\n\t\t\t\t// attachment reference URL goes here\n\t\t\t\tif (attachment != null)\n\t\t\t\t{\n\t\t\t\t\t// make sure previous message parts ended with newline\n\t\t\t\t\tif (bodyBuf.length() > 0 && bodyBuf.charAt(bodyBuf.length() - 1) != '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tbodyBuf.append(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbodyBuf.append(\"[see attachment: \\\"\" + name + \"\\\", size: \" + bodyBytes.length + \" bytes]\\n\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// make sure previous message parts ended with newline\n\t\tif (bodyBuf.length() > 0 && bodyBuf.charAt(bodyBuf.length() - 1) != '\\n')\n\t\t{\n\t\t\tbodyBuf.append(\"\\n\");\n\t\t}\n\t\tbodyBuf.append(closing);\n\n\t\treturn embedCount;\n\t}","id":585,"modified_method":"/**\n\t * Breaks email messages into parts which can be saved as files (saves as attachments) or viewed as plain text (added to body of message).\n\t * \n\t * @param p\n\t *        The message-part embedded in a message..\n\t * @param id\n\t *        The string containing the message's id.\n\t * @param bodyBuf\n\t *        The string-buffers in which the plain/text and/or html/text message body is being built.\n\t * @param bodyContentType\n\t *        The value of the Content-Type header for the mesage body.\n\t * @param attachments\n\t *        The ReferenceVector in which references to attachments are collected.\n\t * @param embedCount\n\t *        An Integer that counts embedded messages (outer message is zero).\n\t * @return Value of embedCount (updated if this call processed any embedded messages).\n\t */\n\tprotected Integer parseParts(Part p, String id, StringBuilder bodyBuf[], \n\t\t\t\t\t\t\t\t\t\t  StringBuilder bodyContentType, List attachments,\tInteger embedCount) \n\t\t\tthrows MessagingException, IOException\n\t{\n\t\t// increment embedded message counter\n\t\tif (p instanceof Message)\n\t\t{\n\t\t\tembedCount = new Integer( embedCount.intValue() + 1 );\n\t\t}\n\t\t\n\t\tString type = p.getContentType();\n\n\t\t// discard if content-type is unknown\n\t\tif (type == null || type.equals(\"\"))\n\t\t{\n\t\t\tM_log.warn(this+\" message with unknown content-type discarded\");\n\t\t}\n\t\t\n\t\t// add plain text to bodyBuf[0]\n\t\telse if (p.isMimeType(\"text/plain\") && p.getFileName() == null)\n\t\t{\n\t\t\tObject o = p.getContent();\n\t\t\tString txt = null;\n\t\t\tString innerContentType = p.getContentType();\n\n\t\t\tif (o instanceof String)\n\t\t\t{\n\t\t\t\ttxt = (String) p.getContent();\n\t\t\t\tif (bodyContentType != null && bodyContentType.length() == 0) \n\t\t\t\t\tbodyContentType.append(innerContentType);\n\t\t\t}\n\n\t\t\telse if (o instanceof InputStream)\n\t\t\t{\n\t\t\t\tInputStream in = (InputStream) o;\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\t\tbyte[] buf = new byte[in.available()];\n\t\t\t\tfor (int len = in.read(buf); len != -1; len = in.read(buf))\n\t\t\t\t\tout.write(buf, 0, len);\n\t\t\t\tString charset = (new ContentType(innerContentType)).getParameter(\"charset\");\n\t\t\t\ttxt = out.toString(MimeUtility.javaCharset(charset));\n\t\t\t\tif (bodyContentType != null && bodyContentType.length() == 0) \n\t\t\t\t\tbodyContentType.append(innerContentType);\n\t\t\t}\n\t\t\t\n \t\t\t// remove extra line breaks added by mac Mail, perhaps others\n\t\t\t// characterized by a space followed by a line break\n\t\t\ttxt = txt.replaceAll(\" \\n\", \" \");\n\n\t\t\t// make sure previous message parts ended with newline\n\t\t\tif (bodyBuf[0].length() > 0 && bodyBuf[0].charAt(bodyBuf[0].length() - 1) != '\\n')\n\t\t\t\tbodyBuf[0].append(\"\\n\");\n\t\t\t\n\t\t\tbodyBuf[0].append(txt);\n\t\t}\n\n\t\t// add html text to bodyBuf[1]\n\t\telse if (p.isMimeType(\"text/html\") && p.getFileName() == null)\n\t\t{\n\t\t\tObject o = p.getContent();\n\t\t\tString txt = null;\n\t\t\tString innerContentType = p.getContentType();\n\n\t\t\tif (o instanceof String)\n\t\t\t{\n\t\t\t\ttxt = (String) p.getContent();\n\t\t\t\tif (bodyContentType != null && bodyContentType.length() == 0) \n\t\t\t\t\tbodyContentType.append(innerContentType);\n\t\t\t}\n\n\t\t\telse if (o instanceof InputStream)\n\t\t\t{\n\t\t\t\tInputStream in = (InputStream) o;\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\t\t\tbyte[] buf = new byte[in.available()];\n\t\t\t\tfor (int len = in.read(buf); len != -1; len = in.read(buf))\n\t\t\t\t\tout.write(buf, 0, len);\n\t\t\t\tString charset = (new ContentType(innerContentType)).getParameter(\"charset\");\n\t\t\t\ttxt = out.toString(MimeUtility.javaCharset(charset));\n\t\t\t\tif (bodyContentType != null && bodyContentType.length() == 0) \n\t\t\t\t\tbodyContentType.append(innerContentType);\n\t\t\t}\n\n\t\t\t// remove bad image tags and naughty javascript\n\t\t\ttxt = cleanHtml( txt );\n\t\t\t\n\t\t\tbodyBuf[1].append(txt);\n\t\t}\n\t\t\t\t\n\t\t// process subparts of multiparts\n\t\telse if (p.isMimeType(\"multipart/*\"))\n\t\t{\n\t\t\tMultipart mp = (Multipart) p.getContent();\n\t\t\tint count = mp.getCount();\n\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t{\n\t\t\t\tembedCount = parseParts(mp.getBodyPart(i), id, bodyBuf, bodyContentType, attachments, embedCount);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Discard parts with mime-type application/applefile. If an e-mail message contains an attachment is sent from\n\t\t// a macintosh, you may get two parts, one for the data fork and one for the resource fork. The part that\n\t\t// corresponds to the resource fork confuses users, this has mime-type application/applefile. The best thing\n\t\t// is to discard it.\n\t\telse if (p.isMimeType(\"application/applefile\"))\n\t\t{\n\t\t\tM_log.warn(this+\" message with application/applefile discarded\");\n\t\t}\n\t\t\n\t\t// discard enriched text version of the message.\n\t\t// Sakai only uses the plain/text or html/text version of the message.\n\t\telse if (p.isMimeType(\"text/enriched\") && p.getFileName() == null)\n\t\t{\n\t\t\tM_log.warn(this+\" message with text/enriched discarded\");\n\t\t}\n\t\t\n\t\t// everything else gets treated as an attachment\n\t\telse\n\t\t{\n\t\t\tString name = p.getFileName();\n\t\t\t\n\t\t\t// look for filenames not parsed by getFileName() \n\t\t\tif ( name == null && type.indexOf(NAME_PREFIX) != -1 )\n\t\t\t{\n\t\t\t\tname = type.substring( type.indexOf(NAME_PREFIX)+NAME_PREFIX.length() );\n\t\t\t}\n\t\t\t// ContentType can't handle filenames with spaces or UTF8 characters\n\t\t\tif ( name != null )\n\t\t\t{\n\t\t\t\tString decodedName = MimeUtility.decodeText( name ); // first decode RFC 2047\n\t\t\t\ttype = type.replace( name, URLEncoder.encode(decodedName, \"UTF-8\") );\n\t\t\t\tname = decodedName;\n\t\t\t}\n\t\t\t\n\t\t\tContentType cType = new ContentType(type);\n\t\t\tString disposition = p.getDisposition();\n\t\t\tint approxSize = p.getSize();\n\n\t\t\tif (name == null)\n\t\t\t{\n\t\t\t\tname = \"unknown\";\n\t\t\t\t// if file's parent is multipart/alternative,\n\t\t\t\t// provide a better name for the file\n\t\t\t\tif (p instanceof BodyPart)\n\t\t\t\t{\n\t\t\t\t\tMultipart parent = ((BodyPart) p).getParent();\n\t\t\t\t\tif (parent != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tString pType = parent.getContentType();\n\t\t\t\t\t\tContentType pcType = new ContentType(pType);\n\t\t\t\t\t\tif (pcType.getBaseType().equalsIgnoreCase(\"multipart/alternative\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname = \"message\" + embedCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p.isMimeType(\"text/html\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".html\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/richtext\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".rtx\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/rtf\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".rtf\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/enriched\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".etf\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/plain\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".txt\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"text/xml\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".xml\";\n\t\t\t\t}\n\t\t\t\telse if (p.isMimeType(\"message/rfc822\"))\n\t\t\t\t{\n\t\t\t\t\tname += \".txt\"; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// read the attachments bytes, and create it as an attachment in content hosting\n\t\t\tbyte[] bodyBytes = readBody(approxSize, p.getInputStream());\n\t\t\tif ((bodyBytes != null) && (bodyBytes.length > 0))\n\t\t\t{\n\t\t\t\t// can we ignore the attachment it it's just whitespace chars??\n\t\t\t\tReference attachment = createAttachment(attachments, cType.getBaseType(), name, bodyBytes, id);\n\n\t\t\t\t// add plain/text attachment reference (if plain/text message)\n\t\t\t\tif (attachment != null && bodyBuf[0].length() > 0)\n\t\t\t\t\tbodyBuf[0].append(\"[see attachment: \\\"\" + name + \"\\\", size: \" + bodyBytes.length + \" bytes]\\n\\n\");\n\t\t\t\t\t\n\t\t\t\t// add html/text attachment reference (if html/text message)\n\t\t\t\tif (attachment != null && bodyBuf[1].length() > 0)\n\t\t\t\t\tbodyBuf[1].append(\"<p>[see attachment: \\\"\" + name + \"\\\", size: \" + bodyBytes.length + \" bytes]<\/p>\");\n\t\t\t\t\t\n\t\t\t\t// add plain/text attachment reference (if no plain/text and no html/text)\n\t\t\t\tif (attachment != null && bodyBuf[0].length() == 0 && bodyBuf[1].length() == 0)\n\t\t\t\t\tbodyBuf[0].append(\"[see attachment: \\\"\" + name + \"\\\", size: \" + bodyBytes.length + \" bytes]\\n\\n\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn embedCount;\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tprotected String plainTextContent() {\n\t\tStringBuilder buf = new StringBuilder();\n\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tMailArchiveMessage msg = (MailArchiveMessage) ref.getEntity();\n\t\tMailArchiveMessageHeader hdr = (MailArchiveMessageHeader) msg.getMailArchiveHeader();\n\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore)\n\t\t{\n\t\t}\n\n\t\t// use the message's body\n\t\t// %%% JANDERSE convert to plaintext - email is currently sent plaintext only,\n\t\t// so text formatting that may be present in the message should be removed.\n\t\tbuf.append(FormattedText.convertFormattedTextToPlaintext(msg.getBody()));\n\n\t\t// add any attachments\n\t\tList attachments = hdr.getAttachments();\n\t\tif (attachments.size() > 0)\n\t\t{\n\t\t\tbuf.append(\"\\n\" + \"Attachments:\\n\");\n\t\t\tfor (Iterator iAttachments = attachments.iterator(); iAttachments.hasNext();)\n\t\t\t{\n\t\t\t\tReference attachment = (Reference) iAttachments.next();\n\t\t\t\tString attachmentTitle = attachment.getProperties().getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\t\t\t\tbuf.append(\"\\n\" + attachmentTitle);\n\t\t\t\tbuf.append(\"\\n\" + attachment.getUrl() + \"\\n\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf.toString();\n\t}","id":586,"modified_method":"@Override\n\tprotected String plainTextContent() {\n\t\tStringBuilder buf = new StringBuilder();\n\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tMailArchiveMessage msg = (MailArchiveMessage) ref.getEntity();\n\t\tMailArchiveMessageHeader hdr = (MailArchiveMessageHeader) msg.getMailArchiveHeader();\n\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore) {}\n\n\t\t// if plain-text isn't available, convert html into plain text\n\t\tif ( msg.getBody() != null && msg.getBody().length() > 0 )\n\t\t\tbuf.append( msg.getBody() );\n\t\telse\n\t\t\tbuf.append(FormattedText.convertFormattedTextToPlaintext(msg.getHtmlBody()));\n\n\t\t// add any attachments\n\t\tList attachments = hdr.getAttachments();\n\t\tif (attachments.size() > 0)\n\t\t{\n\t\t\tbuf.append(\"\\n\\n\" + \"Attachments:\\n\");\n\t\t\tfor (Iterator iAttachments = attachments.iterator(); iAttachments.hasNext();)\n\t\t\t{\n\t\t\t\tReference attachment = (Reference) iAttachments.next();\n\t\t\t\tString attachmentTitle = attachment.getProperties().getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\t\t\t\tbuf.append(\"\\n\" + attachmentTitle);\n\t\t\t\tbuf.append(\"\\n\" + attachment.getUrl() + \"\\n\");\n\t\t\t}\n\t\t}\n\n\t\treturn buf.toString();\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tprotected String htmlContent() {\n\t\tStringBuilder buf = new StringBuilder();\n\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tMailArchiveMessage msg = (MailArchiveMessage) ref.getEntity();\n\t\tMailArchiveMessageHeader hdr = (MailArchiveMessageHeader) msg.getMailArchiveHeader();\n\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore)\n\t\t{\n\t\t}\n\n\t\t// use the message's body\n\t\tbuf.append(Web.encodeUrlsAsHtml(msg.getBody()));\n\n\t\t// add any attachments\n\t\tList attachments = hdr.getAttachments();\n\t\tif (attachments.size() > 0)\n\t\t{\n\t\t\tbuf.append(\"<br/>\\n\" + \"Attachments:<br/>\\n\");\n\t\t\tfor (Iterator iAttachments = attachments.iterator(); iAttachments.hasNext();)\n\t\t\t{\n\t\t\t\tReference attachment = (Reference) iAttachments.next();\n\t\t\t\tString attachmentTitle = attachment.getProperties().getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\t\t\t\tbuf.append(\"<br/>\\n<a href=\\\"\" + attachment.getUrl() + \"\\\" >\" + attachmentTitle + \"<\/a><br/>\\n\");\n\t\t\t}\n\t\t}\n\n\t\treturn buf.toString();\n\t}","id":587,"modified_method":"@Override\n\tprotected String htmlContent() {\n\t\tStringBuilder buf = new StringBuilder();\n\n\t\t// get the message\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tMailArchiveMessage msg = (MailArchiveMessage) ref.getEntity();\n\t\tMailArchiveMessageHeader hdr = (MailArchiveMessageHeader) msg.getMailArchiveHeader();\n\n\t\t// use either the configured site, or if not configured, the site (context) of the resource\n\t\tString siteId = (getSite() != null) ? getSite() : ref.getContext();\n\n\t\t// get a site title\n\t\tString title = siteId;\n\t\ttry\n\t\t{\n\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\ttitle = site.getTitle();\n\t\t}\n\t\tcatch (Exception ignore) {}\n\n\t\t// if html isn't available, convert plain-text into html\n\t\tbuf.append( msg.getFormattedBody() );\n\n\t\t// add any attachments\n\t\tList attachments = hdr.getAttachments();\n\t\tif (attachments.size() > 0)\n\t\t{\n\t\t\tbuf.append(\"<br/>\" + \"Attachments:<br/>\");\n\t\t\tfor (Iterator iAttachments = attachments.iterator(); iAttachments.hasNext();)\n\t\t\t{\n\t\t\t\tReference attachment = (Reference) iAttachments.next();\n\t\t\t\tString attachmentTitle = attachment.getProperties().getPropertyFormatted(ResourceProperties.PROP_DISPLAY_NAME);\n\t\t\t\tbuf.append(\"<br/><a href=\\\"\" + attachment.getUrl() + \"\\\" >\" + attachmentTitle + \"<\/a><br/>\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf.toString();\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected List getHeaders(Event event)\n\t{\n\t\t// send most of the headers from the original message, removing some\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tMailArchiveMessage msg = (MailArchiveMessage) ref.getEntity();\n\t\tMailArchiveMessageHeader hdr = (MailArchiveMessageHeader) msg.getMailArchiveHeader();\n\t\tList headers = hdr.getMailHeaders();\n\n\t\tList filteredHeaders = super.getHeaders(event);\n\t\tString innerContentType = null;\n\t\tString outerContentType = null;\n\t\tString contentType = null;\n\n\t\tfor (int i = 0; i < headers.size(); i++)\n\t\t{\n\t\t\tString headerStr = (String) headers.get(i);\n\n\t\t\tif (headerStr.startsWith(\"Return-Path\") || headerStr.startsWith(\"Content-Transfer-Encoding\")) continue;\n\n\t\t\tif (headerStr.startsWith(MailArchiveService.HEADER_INNER_CONTENT_TYPE + \": \")) innerContentType = headerStr;\n\t\t\tif (headerStr.startsWith(MailArchiveService.HEADER_OUTER_CONTENT_TYPE + \": \")) outerContentType = headerStr;\n\n\t\t\tif (!headerStr.startsWith(\"Content-Type: \"))\n\t\t\t{\n\t\t\t\tfilteredHeaders.add(headerStr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontentType = headerStr;\n\t\t\t}\n\t\t}\n\n\t\tif (innerContentType != null)\n\t\t{\n\t\t\t// use the content type of the inner email message body\n\t\t\t//filteredHeaders.add(innerContentType.replaceAll(MailArchiveService.HEADER_INNER_CONTENT_TYPE, \"Content-Type\"));\n\t\t}\n\t\telse if (outerContentType != null)\n\t\t{\n\t\t\t// use the content type from the outer message (content type as set in the email originally)\n\t\t\t//filteredHeaders.add(outerContentType.replaceAll(MailArchiveService.HEADER_OUTER_CONTENT_TYPE, \"Content-Type\"));\n\t\t}\n\t\telse if (contentType != null)\n\t\t{\n\t\t\t// Oh well, use the plain old Content-Type header\n\t\t\t//filteredHeaders.add(contentType);\n\t\t}\n\n\t\treturn filteredHeaders;\n\t}","id":588,"modified_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected List getHeaders(Event event)\n\t{\n\t\t// send most of the headers from the original message, removing some\n\t\tReference ref = EntityManager.newReference(event.getResource());\n\t\tMailArchiveMessage msg = (MailArchiveMessage) ref.getEntity();\n\t\tMailArchiveMessageHeader hdr = (MailArchiveMessageHeader) msg.getMailArchiveHeader();\n\t\tList headers = hdr.getMailHeaders();\n\n\t\tList filteredHeaders = super.getHeaders(event);\n\n\t\tfor (int i = 0; i < headers.size(); i++)\n\t\t{\n\t\t\tString headerStr = (String) headers.get(i);\n\n\t\t\tif (headerStr.startsWith(\"Return-Path\") || headerStr.startsWith(\"Content-Transfer-Encoding\")) continue;\n\t\t\tif (headerStr.startsWith(\"Content-Type: \")) continue;\n\t\t\t\n\t\t\tfilteredHeaders.add(headerStr);\n\t\t}\n\n\t\treturn filteredHeaders;\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected String getTag(String title, boolean shouldUseHtml)\n\t{\n\t\t{\n\t\t\tif (shouldUseHtml) {\n\t\t\t\treturn (\"<hr/><br/>\" + rb.getString(\"this\") + \" \"\n\t\t\t\t\t\t+ ServerConfigurationService.getString(\"ui.service\", \"Sakai\") + \" (<a href=\\\"\"\n\t\t\t\t\t\t+ ServerConfigurationService.getPortalUrl() + \"\\\">\" + ServerConfigurationService.getPortalUrl() + \"<\/a>) \"\n\t\t\t\t\t\t+ rb.getString(\"forthe\") + \" \" + title + \" \" + rb.getString(\"site\") + \"<br/>\" + rb.getString(\"youcan\") + \"<br/>\");\n\t\t\t} else {\n\t\t\t\treturn (rb.getString(\"separator\") + \"\\n\" + rb.getString(\"this\") + \" \"\n\t\t\t\t\t\t+ ServerConfigurationService.getString(\"ui.service\", \"Sakai\") + \" (\" + ServerConfigurationService.getPortalUrl()\n\t\t\t\t\t\t+ \") \" + rb.getString(\"forthe\") + \" \" + title + \" \" + rb.getString(\"site\") + \"\\n\" + rb.getString(\"youcan\")\n\t\t\t\t\t\t+ \"\\n\");\n\t\t\t}\n\t\t}\n\t}","id":589,"modified_method":"/**\n\t * @inheritDoc\n\t */\n\tprotected String getTag(String title, boolean shouldUseHtml)\n\t{\n\t\tStringBuilder buf = new StringBuilder();\n\t\t\t\n\t\tif (shouldUseHtml) {\n\t\t\tbuf.append(\"<br/><hr/><br/>\");\n\t\t\tString portalUrl = \"<a href=\\\"\" + ServerConfigurationService.getPortalUrl() + \"\\\" >\" + ServerConfigurationService.getPortalUrl() + \"<a/>\"; \n\t\t\tbuf.append( MessageFormat.format( rb.getString(\"automsg1\"),  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t new Object[]{ServerConfigurationService.getString(\"ui.service\", \"Sakai\"), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  portalUrl, title} ));\n\t\t\tbuf.append( \"<br/>\" + rb.getString(\"automsg2\")+\"<br/>\" );\n\t\t} \n\t\telse {\n\t\t\tbuf.append(\"\\n----------------------\\n\" );\n\t\t\tbuf.append( MessageFormat.format( rb.getString(\"automsg1\"),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t new Object[]{ServerConfigurationService.getString(\"ui.service\", \"Sakai\"), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ServerConfigurationService.getPortalUrl(), title} ));\n\t\t\tbuf.append( \"\\n\" + rb.getString(\"automsg2\") + \"\\n\" );\n\t\t}\n\t\t\n\t\treturn buf.toString();\n\t}","commit_id":"be4fbd3cb2fc235bd2b931175aa3562c351344b8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void addDefaultResources(Map<PathAddress, ModelNode> migrationOperations, final ModelNode legacyModelDescription) {\n        //add the default server\n        PathAddress address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), DEFAULT_SERVER_PATH);\n        ModelNode add = createAddOperation(address);\n\n        ModelNode defaultSessionTimeout = null;\n\n        //static resources\n        ModelNode directoryListing = null;\n        //todo: add support for some of these\n        ModelNode sendfile = null;\n        ModelNode fileEncoding = null;\n        ModelNode readOnly = null;\n        ModelNode webdav = null;\n        ModelNode secret = null;\n        ModelNode maxDepth = null;\n        ModelNode disabled = null;\n\n        for (ModelNode legacyAddOp : legacyModelDescription.get(RESULT).asList()) {\n            final PathAddress la = pathAddress(legacyAddOp.get(ADDRESS));\n            if (la.equals(pathAddress(WebExtension.SUBSYSTEM_PATH))) {\n                ModelNode defaultHost = legacyAddOp.get(WebDefinition.DEFAULT_VIRTUAL_SERVER.getName());\n                if (defaultHost.isDefined()) {\n                    add.get(Constants.DEFAULT_HOST).set(defaultHost.clone());\n                }\n                ModelNode sessionTimeout = legacyAddOp.get(WebDefinition.DEFAULT_SESSION_TIMEOUT.getName());\n                if (sessionTimeout.isDefined()) {\n                    defaultSessionTimeout = sessionTimeout;\n                }\n            } else if (la.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.STATIC_RESOURCES_PATH))) {\n                ModelNode node = legacyAddOp.get(WebStaticResources.LISTINGS.getName());\n                if (node.isDefined()) {\n                    directoryListing = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.SENDFILE.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.SENDFILE.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    sendfile = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.FILE_ENCODING.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.FILE_ENCODING.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    fileEncoding = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.READ_ONLY.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.READ_ONLY.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    readOnly = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.WEBDAV.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.WEBDAV.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    webdav = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.SECRET.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.SECRET.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    secret = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.MAX_DEPTH.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.MAX_DEPTH.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    maxDepth = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.DISABLED.getName());\n                if (node.isDefined()) {\n                    WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.DISABLED.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n                    disabled = node;\n                }\n            }\n        }\n\n        migrationOperations.put(address, add);\n\n        address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), pathElement(Constants.BUFFER_CACHE, \"default\"));\n        add = createAddOperation(address);\n        migrationOperations.put(address, add);\n\n        address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), pathElement(Constants.SERVLET_CONTAINER, \"default\"));\n        add = createAddOperation(address);\n        if (defaultSessionTimeout != null) {\n            add.get(Constants.DEFAULT_SESSION_TIMEOUT).set(defaultSessionTimeout.clone());\n        }\n        if (directoryListing != null) {\n            add.get(Constants.DIRECTORY_LISTING).set(directoryListing);\n        }\n        migrationOperations.put(address, add);\n    }","id":590,"modified_method":"private void addDefaultResources(Map<PathAddress, ModelNode> migrationOperations, final ModelNode legacyModelDescription, List<String> warnings) {\n        //add the default server\n        PathAddress address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), DEFAULT_SERVER_PATH);\n        ModelNode add = createAddOperation(address);\n\n        ModelNode defaultSessionTimeout = null;\n\n        //static resources\n        ModelNode directoryListing = null;\n        //todo: add support for some of these\n        ModelNode sendfile = null;\n        ModelNode fileEncoding = null;\n        ModelNode readOnly = null;\n        ModelNode webdav = null;\n        ModelNode secret = null;\n        ModelNode maxDepth = null;\n        ModelNode disabled = null;\n\n        for (ModelNode legacyAddOp : legacyModelDescription.get(RESULT).asList()) {\n            final PathAddress la = pathAddress(legacyAddOp.get(ADDRESS));\n            if (la.equals(pathAddress(WebExtension.SUBSYSTEM_PATH))) {\n                ModelNode defaultHost = legacyAddOp.get(WebDefinition.DEFAULT_VIRTUAL_SERVER.getName());\n                if (defaultHost.isDefined()) {\n                    add.get(Constants.DEFAULT_HOST).set(defaultHost.clone());\n                }\n                ModelNode sessionTimeout = legacyAddOp.get(WebDefinition.DEFAULT_SESSION_TIMEOUT.getName());\n                if (sessionTimeout.isDefined()) {\n                    defaultSessionTimeout = sessionTimeout;\n                }\n            } else if (la.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.STATIC_RESOURCES_PATH))) {\n                ModelNode node = legacyAddOp.get(WebStaticResources.LISTINGS.getName());\n                if (node.isDefined()) {\n                    directoryListing = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.SENDFILE.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.SENDFILE.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    sendfile = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.FILE_ENCODING.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.FILE_ENCODING.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    fileEncoding = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.READ_ONLY.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.READ_ONLY.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    readOnly = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.WEBDAV.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.WEBDAV.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    webdav = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.SECRET.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.SECRET.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    secret = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.MAX_DEPTH.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.MAX_DEPTH.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    maxDepth = node;\n                }\n                node = legacyAddOp.get(WebStaticResources.DISABLED.getName());\n                if (node.isDefined()) {\n                    warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebStaticResources.DISABLED.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n                    disabled = node;\n                }\n            }\n        }\n\n        migrationOperations.put(address, add);\n\n        address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), pathElement(Constants.BUFFER_CACHE, \"default\"));\n        add = createAddOperation(address);\n        migrationOperations.put(address, add);\n\n        address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), pathElement(Constants.SERVLET_CONTAINER, \"default\"));\n        add = createAddOperation(address);\n        if (defaultSessionTimeout != null) {\n            add.get(Constants.DEFAULT_SESSION_TIMEOUT).set(defaultSessionTimeout.clone());\n        }\n        if (directoryListing != null) {\n            add.get(Constants.DIRECTORY_LISTING).set(directoryListing);\n        }\n        migrationOperations.put(address, add);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates the security realm\n     *\n     * @param context\n     * @param migrationOperations\n     * @return\n     */\n    private SSLInformation createSecurityRealm(OperationContext context, Map<PathAddress, ModelNode> migrationOperations, ModelNode legacyModelAddOps, String connector) {\n        ModelNode legacyAddOp = findResource(pathAddress(WebExtension.SUBSYSTEM_PATH, pathElement(WebExtension.CONNECTOR_PATH.getKey(), connector), pathElement(\"configuration\", \"ssl\")), legacyModelAddOps);\n        if (legacyAddOp == null) {\n            return null;\n        }\n        //we have SSL\n        //now we need to find a unique name\n        //in domain mode different profiles could have different SSL configurations\n        //but the realms are not scoped to a profile\n        //if we hard coded a name migration would fail when migrating domains with multiple profiles\n        int counter = 1;\n        String realmName = REALM_NAME + counter;\n        boolean ok = false;\n        do {\n            Resource root = context.readResourceFromRoot(pathAddress(CORE_SERVICE, MANAGEMENT), false);\n            if (root.getChildrenNames(SECURITY_REALM).contains(realmName)) {\n                counter++;\n                realmName = REALM_NAME + counter;\n            } else {\n                ok = true;\n            }\n        } while (!ok);\n\n        //we have a unique realm name\n        //add the realm\n        PathAddress addres = pathAddress(pathElement(CORE_SERVICE, MANAGEMENT), pathElement(SECURITY_REALM, realmName));\n        migrationOperations.put(addres, createAddOperation(addres));\n\n        //read all the info from the SSL definition\n        ModelNode keyAlias = legacyAddOp.get(WebSSLDefinition.KEY_ALIAS.getName());\n        ModelNode password = legacyAddOp.get(WebSSLDefinition.PASSWORD.getName());\n        ModelNode certificateKeyFile = legacyAddOp.get(WebSSLDefinition.CERTIFICATE_KEY_FILE.getName());\n        ModelNode cipherSuite = legacyAddOp.get(WebSSLDefinition.CIPHER_SUITE.getName());\n        ModelNode protocol = legacyAddOp.get(WebSSLDefinition.PROTOCOL.getName());\n        ModelNode verifyClient = legacyAddOp.get(WebSSLDefinition.VERIFY_CLIENT.getName());\n        ModelNode verifyDepth = legacyAddOp.get(WebSSLDefinition.VERIFY_DEPTH.getName());\n        ModelNode certificateFile = legacyAddOp.get(WebSSLDefinition.CERTIFICATE_FILE.getName());\n        ModelNode caCertificateFile = legacyAddOp.get(WebSSLDefinition.CA_CERTIFICATE_FILE.getName());\n        ModelNode caCertificatePassword = legacyAddOp.get(WebSSLDefinition.CA_CERTIFICATE_PASSWORD.getName());\n        ModelNode csRevocationURL = legacyAddOp.get(WebSSLDefinition.CA_REVOCATION_URL.getName());\n        ModelNode trustStoreType = legacyAddOp.get(WebSSLDefinition.TRUSTSTORE_TYPE.getName());\n        ModelNode keystoreType = legacyAddOp.get(WebSSLDefinition.KEYSTORE_TYPE.getName());\n        ModelNode sessionCacheSize = legacyAddOp.get(WebSSLDefinition.SESSION_CACHE_SIZE.getName());\n        ModelNode sessionTimeout = legacyAddOp.get(WebSSLDefinition.SESSION_TIMEOUT.getName());\n        ModelNode sslProtocol = legacyAddOp.get(WebSSLDefinition.SSL_PROTOCOL.getName());\n\n        //now lets add the trust store\n        addres = pathAddress(pathElement(CORE_SERVICE, MANAGEMENT), pathElement(SECURITY_REALM, realmName), pathElement(AUTHENTICATION, TRUSTSTORE));\n        ModelNode addOp = createAddOperation(addres);\n        addOp.get(KeystoreAttributes.KEYSTORE_PATH.getName()).set(caCertificateFile);\n        addOp.get(KeystoreAttributes.KEYSTORE_PASSWORD.getName()).set(caCertificatePassword);\n        addOp.get(KeystoreAttributes.KEYSTORE_PROVIDER.getName()).set(trustStoreType);\n        migrationOperations.put(addres, addOp);\n\n\n        //now lets add the key store\n        addres = pathAddress(pathElement(CORE_SERVICE, MANAGEMENT), pathElement(SECURITY_REALM, realmName), pathElement(SERVER_IDENTITY, SSL));\n        addOp = createAddOperation(addres);\n        addOp.get(KeystoreAttributes.KEYSTORE_PATH.getName()).set(certificateKeyFile);\n        addOp.get(KeystoreAttributes.KEYSTORE_PASSWORD.getName()).set(password);\n        addOp.get(KeystoreAttributes.KEYSTORE_PROVIDER.getName()).set(keystoreType);\n        addOp.get(KeystoreAttributes.ALIAS.getName()).set(keyAlias);\n        addOp.get(PROTOCOL).set(protocol);\n        //addOp.get(KeystoreAttributes.KEY_PASSWORD.getName()).set(password); //TODO: is this correct? both key and keystore have same password?\n\n        if(verifyDepth.isDefined()) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.VERIFY_DEPTH.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n        }\n        if(certificateFile.isDefined()) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.CERTIFICATE_FILE.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n        }\n\n        if(csRevocationURL.isDefined()) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.CA_REVOCATION_URL.getName(), pathAddress(legacyAddOp.get(ADDRESS)));\n        }\n\n        migrationOperations.put(addres, addOp);\n\n        return new SSLInformation(realmName, verifyClient, sessionCacheSize, sessionTimeout, sslProtocol, cipherSuite);\n    }","id":591,"modified_method":"/**\n     * Creates the security realm\n     *\n     * @param context\n     * @param migrationOperations\n     * @return\n     */\n    private SSLInformation createSecurityRealm(OperationContext context, Map<PathAddress, ModelNode> migrationOperations, ModelNode legacyModelAddOps, String connector, List<String> warnings) {\n        ModelNode legacyAddOp = findResource(pathAddress(WebExtension.SUBSYSTEM_PATH, pathElement(WebExtension.CONNECTOR_PATH.getKey(), connector), pathElement(\"configuration\", \"ssl\")), legacyModelAddOps);\n        if (legacyAddOp == null) {\n            return null;\n        }\n        //we have SSL\n        //now we need to find a unique name\n        //in domain mode different profiles could have different SSL configurations\n        //but the realms are not scoped to a profile\n        //if we hard coded a name migration would fail when migrating domains with multiple profiles\n        int counter = 1;\n        String realmName = REALM_NAME + counter;\n        boolean ok = false;\n        do {\n            Resource root = context.readResourceFromRoot(pathAddress(CORE_SERVICE, MANAGEMENT), false);\n            if (root.getChildrenNames(SECURITY_REALM).contains(realmName)) {\n                counter++;\n                realmName = REALM_NAME + counter;\n            } else {\n                ok = true;\n            }\n        } while (!ok);\n\n        //we have a unique realm name\n        //add the realm\n        PathAddress addres = pathAddress(pathElement(CORE_SERVICE, MANAGEMENT), pathElement(SECURITY_REALM, realmName));\n        migrationOperations.put(addres, createAddOperation(addres));\n\n        //read all the info from the SSL definition\n        ModelNode keyAlias = legacyAddOp.get(WebSSLDefinition.KEY_ALIAS.getName());\n        ModelNode password = legacyAddOp.get(WebSSLDefinition.PASSWORD.getName());\n        ModelNode certificateKeyFile = legacyAddOp.get(WebSSLDefinition.CERTIFICATE_KEY_FILE.getName());\n        ModelNode cipherSuite = legacyAddOp.get(WebSSLDefinition.CIPHER_SUITE.getName());\n        ModelNode protocol = legacyAddOp.get(WebSSLDefinition.PROTOCOL.getName());\n        ModelNode verifyClient = legacyAddOp.get(WebSSLDefinition.VERIFY_CLIENT.getName());\n        ModelNode verifyDepth = legacyAddOp.get(WebSSLDefinition.VERIFY_DEPTH.getName());\n        ModelNode certificateFile = legacyAddOp.get(WebSSLDefinition.CERTIFICATE_FILE.getName());\n        ModelNode caCertificateFile = legacyAddOp.get(WebSSLDefinition.CA_CERTIFICATE_FILE.getName());\n        ModelNode caCertificatePassword = legacyAddOp.get(WebSSLDefinition.CA_CERTIFICATE_PASSWORD.getName());\n        ModelNode csRevocationURL = legacyAddOp.get(WebSSLDefinition.CA_REVOCATION_URL.getName());\n        ModelNode trustStoreType = legacyAddOp.get(WebSSLDefinition.TRUSTSTORE_TYPE.getName());\n        ModelNode keystoreType = legacyAddOp.get(WebSSLDefinition.KEYSTORE_TYPE.getName());\n        ModelNode sessionCacheSize = legacyAddOp.get(WebSSLDefinition.SESSION_CACHE_SIZE.getName());\n        ModelNode sessionTimeout = legacyAddOp.get(WebSSLDefinition.SESSION_TIMEOUT.getName());\n        ModelNode sslProtocol = legacyAddOp.get(WebSSLDefinition.SSL_PROTOCOL.getName());\n\n        //now lets add the trust store\n        addres = pathAddress(pathElement(CORE_SERVICE, MANAGEMENT), pathElement(SECURITY_REALM, realmName), pathElement(AUTHENTICATION, TRUSTSTORE));\n        ModelNode addOp = createAddOperation(addres);\n        addOp.get(KeystoreAttributes.KEYSTORE_PATH.getName()).set(caCertificateFile);\n        addOp.get(KeystoreAttributes.KEYSTORE_PASSWORD.getName()).set(caCertificatePassword);\n        addOp.get(KeystoreAttributes.KEYSTORE_PROVIDER.getName()).set(trustStoreType);\n        migrationOperations.put(addres, addOp);\n\n\n        //now lets add the key store\n        addres = pathAddress(pathElement(CORE_SERVICE, MANAGEMENT), pathElement(SECURITY_REALM, realmName), pathElement(SERVER_IDENTITY, SSL));\n        addOp = createAddOperation(addres);\n        addOp.get(KeystoreAttributes.KEYSTORE_PATH.getName()).set(certificateKeyFile);\n        addOp.get(KeystoreAttributes.KEYSTORE_PASSWORD.getName()).set(password);\n        addOp.get(KeystoreAttributes.KEYSTORE_PROVIDER.getName()).set(keystoreType);\n        addOp.get(KeystoreAttributes.ALIAS.getName()).set(keyAlias);\n        addOp.get(PROTOCOL).set(protocol);\n        //addOp.get(KeystoreAttributes.KEY_PASSWORD.getName()).set(password); //TODO: is this correct? both key and keystore have same password?\n\n        if(verifyDepth.isDefined()) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.VERIFY_DEPTH.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n        }\n        if(certificateFile.isDefined()) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.CERTIFICATE_FILE.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n        }\n\n        if(csRevocationURL.isDefined()) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.CA_REVOCATION_URL.getName(), pathAddress(legacyAddOp.get(ADDRESS))));\n        }\n\n        migrationOperations.put(addres, addOp);\n\n        return new SSLInformation(realmName, verifyClient, sessionCacheSize, sessionTimeout, sslProtocol, cipherSuite);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void transformResources(final OperationContext context, final ModelNode legacyModelDescription, final Map<PathAddress, ModelNode> newAddOperations) throws OperationFailedException {\n        for (ModelNode legacyAddOp : legacyModelDescription.get(RESULT).asList()) {\n            final ModelNode newAddOp = legacyAddOp.clone();\n            PathAddress address = pathAddress(newAddOp.get(ADDRESS));\n\n            if (address.size() == 1) {\n                //subsystem\n                migrateSubsystem(newAddOperations, newAddOp);\n            } else if (address.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.STATIC_RESOURCES_PATH))) {\n                //covered in the servlet container add, so just ignore\n            } else if (address.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.JSP_CONFIGURATION_PATH))) {\n                migrateJSPConfig(newAddOperations, newAddOp);\n            } else if (address.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.CONTAINER_PATH))) {\n                migrateMimeMapping(newAddOperations, newAddOp);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.CONNECTOR_PATH))) {\n                migrateConnector(context, newAddOperations, newAddOp, address, legacyModelDescription);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH))) {\n                migrateVirtualHost(newAddOperations, newAddOp, address);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH, WebExtension.ACCESS_LOG_PATH))) {\n                migrateAccessLog(newAddOperations, newAddOp, address, legacyModelDescription);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH, WebExtension.ACCESS_LOG_PATH, WebExtension.DIRECTORY_PATH))) {\n                //ignore, handled by access-log\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH, WebExtension.SSO_PATH))) {\n                migrateSso(newAddOperations, newAddOp, address);\n            } else {\n                WebLogger.ROOT_LOGGER.couldNotMigrateResource(legacyAddOp);\n            }\n\n        }\n    }","id":592,"modified_method":"private void transformResources(final OperationContext context, final ModelNode legacyModelDescription, final Map<PathAddress, ModelNode> newAddOperations, List<String> warnings) throws OperationFailedException {\n        for (ModelNode legacyAddOp : legacyModelDescription.get(RESULT).asList()) {\n            final ModelNode newAddOp = legacyAddOp.clone();\n            PathAddress address = pathAddress(newAddOp.get(ADDRESS));\n\n            if (address.size() == 1) {\n                //subsystem\n                migrateSubsystem(newAddOperations, newAddOp);\n            } else if (address.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.STATIC_RESOURCES_PATH))) {\n                //covered in the servlet container add, so just ignore\n            } else if (address.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.JSP_CONFIGURATION_PATH))) {\n                migrateJSPConfig(newAddOperations, newAddOp);\n            } else if (address.equals(pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.CONTAINER_PATH))) {\n                migrateMimeMapping(newAddOperations, newAddOp);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.CONNECTOR_PATH))) {\n                migrateConnector(context, newAddOperations, newAddOp, address, legacyModelDescription, warnings);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH))) {\n                migrateVirtualHost(newAddOperations, newAddOp, address);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH, WebExtension.ACCESS_LOG_PATH))) {\n                migrateAccessLog(newAddOperations, newAddOp, address, legacyModelDescription, warnings);\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH, WebExtension.ACCESS_LOG_PATH, WebExtension.DIRECTORY_PATH))) {\n                //ignore, handled by access-log\n            } else if (wildcardEquals(address, pathAddress(WebExtension.SUBSYSTEM_PATH, WebExtension.HOST_PATH, WebExtension.SSO_PATH))) {\n                migrateSso(newAddOperations, newAddOp, address, warnings);\n            } else {\n                warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(legacyAddOp));\n            }\n\n        }\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void migrateSso(Map<PathAddress, ModelNode> newAddOperations, ModelNode newAddOp, PathAddress address) {\n        PathAddress newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HOST, address.getElement(address.size() - 2).getValue()), UndertowExtension.PATH_SSO);\n        ModelNode add = createAddOperation(newAddress);\n\n        add.get(Constants.DOMAIN).set(newAddOp.get(WebSSODefinition.DOMAIN.getName()).clone());\n        add.get(Constants.HTTP_ONLY).set(newAddOp.get(WebSSODefinition.HTTP_ONLY.getName()).clone());\n\n        if (newAddOp.hasDefined(WebSSODefinition.CACHE_CONTAINER.getName())) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSODefinition.CACHE_CONTAINER.getName(), pathAddress(newAddOp.get(ADDRESS)));\n        }\n        if (newAddOp.hasDefined(WebSSODefinition.REAUTHENTICATE.getName())) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSODefinition.REAUTHENTICATE.getName(), pathAddress(newAddOp.get(ADDRESS)));\n        }\n        if (newAddOp.hasDefined(WebSSODefinition.CACHE_NAME.getName())) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSODefinition.CACHE_NAME.getName(), pathAddress(newAddOp.get(ADDRESS)));\n        }\n\n        newAddOperations.put(newAddress, add);\n    }","id":593,"modified_method":"private void migrateSso(Map<PathAddress, ModelNode> newAddOperations, ModelNode newAddOp, PathAddress address, List<String> warnings) {\n        PathAddress newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HOST, address.getElement(address.size() - 2).getValue()), UndertowExtension.PATH_SSO);\n        ModelNode add = createAddOperation(newAddress);\n\n        add.get(Constants.DOMAIN).set(newAddOp.get(WebSSODefinition.DOMAIN.getName()).clone());\n        add.get(Constants.HTTP_ONLY).set(newAddOp.get(WebSSODefinition.HTTP_ONLY.getName()).clone());\n\n        if (newAddOp.hasDefined(WebSSODefinition.CACHE_CONTAINER.getName())) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSODefinition.CACHE_CONTAINER.getName(), pathAddress(newAddOp.get(ADDRESS))));\n        }\n        if (newAddOp.hasDefined(WebSSODefinition.REAUTHENTICATE.getName())) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSODefinition.REAUTHENTICATE.getName(), pathAddress(newAddOp.get(ADDRESS))));\n        }\n        if (newAddOp.hasDefined(WebSSODefinition.CACHE_NAME.getName())) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSODefinition.CACHE_NAME.getName(), pathAddress(newAddOp.get(ADDRESS))));\n        }\n\n        newAddOperations.put(newAddress, add);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void registerOperations(ManagementResourceRegistration registry, ResourceDescriptionResolver resourceDescriptionResolver) {\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(\"migrate\", resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .setAccessConstraints(SensitiveTargetAccessConstraintDefinition.READ_WHOLE_CONFIG)\n                        .build(),\n                WebMigrateOperation.MIGRATE_INSTANCE);\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(\"describe-migration\", resourceDescriptionResolver)\n                        .setReplyType(ModelType.LIST).setReplyValueType(ModelType.OBJECT)\n                        .setRuntimeOnly()\n                        .setAccessConstraints(SensitiveTargetAccessConstraintDefinition.READ_WHOLE_CONFIG)\n                        .build(),\n                WebMigrateOperation.DESCRIBE_MIGRATION_INSTANCE);\n    }","id":594,"modified_method":"static void registerOperations(ManagementResourceRegistration registry, ResourceDescriptionResolver resourceDescriptionResolver) {\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(MIGRATE, resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .setAccessConstraints(SensitiveTargetAccessConstraintDefinition.READ_WHOLE_CONFIG)\n                        .setReplyParameters(MIGRATION_WARNINGS_ATTR, MIGRATION_ERROR_ATTR)\n                        .build(),\n                WebMigrateOperation.MIGRATE_INSTANCE);\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(DESCRIBE_MIGRATION, resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .setAccessConstraints(SensitiveTargetAccessConstraintDefinition.READ_WHOLE_CONFIG)\n                        .setReplyParameters(MIGRATION_WARNINGS_ATTR)\n                        .build(),\n                WebMigrateOperation.DESCRIBE_MIGRATION_INSTANCE);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        if (!describe && context.getRunningMode() != RunningMode.ADMIN_ONLY) {\n            throw WebLogger.ROOT_LOGGER.migrateOperationAllowedOnlyInAdminOnly();\n        }\n\n        // node containing the description (list of add operations) of the legacy subsystem\n        final ModelNode legacyModelAddOps = new ModelNode();\n        //we don't preserve order, instead we sort by address length\n        //TODO: is this ok in every case?\n        final Map<PathAddress, ModelNode> migrationOperations = new TreeMap<>(new Comparator<PathAddress>() {\n            @Override\n            public int compare(PathAddress o1, PathAddress o2) {\n                final int compare = Integer.compare(o1.size(), o2.size());\n                if (compare != 0) {\n                    return compare;\n                }\n                return o1.toString().compareTo(o2.toString());\n            }\n        });\n\n        // invoke an OSH to describe the legacy messaging subsystem\n        describeLegacyWebResources(context, legacyModelAddOps);\n        // invoke an OSH to add the messaging-activemq extension\n        // FIXME: this does not work it the extension :add is added to the migrationOperations directly (https://issues.jboss.org/browse/WFCORE-323)\n        addExtension(context, migrationOperations, describe, UNDERTOW_EXTENSION);\n        addExtension(context, migrationOperations, describe, IO_EXTENSION);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                addDefaultResources(migrationOperations, legacyModelAddOps);\n\n                //create the new IO subsystem\n                createIoSubsystem(context, migrationOperations);\n\n                createWelcomeContentHandler(migrationOperations);\n\n                // transform the legacy add operations and put them in migrationOperations\n                transformResources(context, legacyModelAddOps, migrationOperations);\n\n                // put the /subsystem=messaging:remove operation\n                removeWebSubsystem(migrationOperations);\n\n                fixAddressesForDomainMode(pathAddress(operation.get(ADDRESS)), migrationOperations);\n\n                if (describe) {\n                    // :describe-migration operation\n\n                    // for describe-migration operation, do nothing and return the list of operations that would\n                    // be executed in the composite operation\n                    context.getResult().set(migrationOperations.values());\n                } else {\n                    // :migrate operation\n                    // invoke an OSH on a composite operation with all the migration operations\n                    final Map<PathAddress, ModelNode> migrateOpResponses = migrateSubsystems(context, migrationOperations);\n\n                    context.completeStep(new OperationContext.ResultHandler() {\n                        @Override\n                        public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                            //TODO do something with migrateOpResponses; maybe just if any have outcome=failed\n                        }\n                    });\n                }\n            }\n        }, MODEL);\n    }","id":595,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        if (!describe && context.getRunningMode() != RunningMode.ADMIN_ONLY) {\n            throw WebLogger.ROOT_LOGGER.migrateOperationAllowedOnlyInAdminOnly();\n        }\n\n        final List<String> warnings = new ArrayList<>();\n\n        // node containing the description (list of add operations) of the legacy subsystem\n        final ModelNode legacyModelAddOps = new ModelNode();\n        //we don't preserve order, instead we sort by address length\n        //TODO: is this ok in every case?\n        final Map<PathAddress, ModelNode> migrationOperations = new TreeMap<>(new Comparator<PathAddress>() {\n            @Override\n            public int compare(PathAddress o1, PathAddress o2) {\n                final int compare = Integer.compare(o1.size(), o2.size());\n                if (compare != 0) {\n                    return compare;\n                }\n                return o1.toString().compareTo(o2.toString());\n            }\n        });\n\n        // invoke an OSH to describe the legacy messaging subsystem\n        describeLegacyWebResources(context, legacyModelAddOps);\n        // invoke an OSH to add the messaging-activemq extension\n        // FIXME: this does not work it the extension :add is added to the migrationOperations directly (https://issues.jboss.org/browse/WFCORE-323)\n        addExtension(context, migrationOperations, describe, UNDERTOW_EXTENSION);\n        addExtension(context, migrationOperations, describe, IO_EXTENSION);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                addDefaultResources(migrationOperations, legacyModelAddOps, warnings);\n\n                //create the new IO subsystem\n                createIoSubsystem(context, migrationOperations);\n\n                createWelcomeContentHandler(migrationOperations);\n\n                // transform the legacy add operations and put them in migrationOperations\n                transformResources(context, legacyModelAddOps, migrationOperations, warnings);\n\n                // put the /subsystem=messaging:remove operation\n                removeWebSubsystem(migrationOperations);\n\n                fixAddressesForDomainMode(pathAddress(operation.get(ADDRESS)), migrationOperations);\n\n                if (describe) {\n                    // :describe-migration operation\n\n                    // for describe-migration operation, do nothing and return the list of operations that would\n                    // be executed in the composite operation\n                    final Collection<ModelNode> values = migrationOperations.values();\n                    ModelNode result = new ModelNode();\n                    if(!warnings.isEmpty()) {\n                        ModelNode rw = new ModelNode().setEmptyList();\n                        for (String warning : warnings) {\n                            rw.add(warning);\n                        }\n                        result.get(MIGRATION_WARNINGS).set(rw);\n                    }\n\n                    result.get(MIGRATION_OPERATIONS).set(values);\n\n                    context.getResult().set(result);\n                } else {\n                    // :migrate operation\n                    // invoke an OSH on a composite operation with all the migration operations\n                    final Map<PathAddress, ModelNode> migrateOpResponses = migrateSubsystems(context, migrationOperations);\n\n                    context.completeStep(new OperationContext.ResultHandler() {\n                        @Override\n                        public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                            final ModelNode result = new ModelNode();\n                            ModelNode rw = new ModelNode().setEmptyList();\n                            for (String warning : warnings) {\n                                rw.add(warning);\n                            }\n                            result.get(MIGRATION_WARNINGS).set(rw);\n                            if (resultAction == OperationContext.ResultAction.ROLLBACK) {\n                                for (Map.Entry<PathAddress, ModelNode> entry : migrateOpResponses.entrySet()) {\n                                    if (entry.getValue().hasDefined(FAILURE_DESCRIPTION)) {\n                                        //we check for failure description, as every node has 'failed', but one\n                                        //the real error has a failure description\n                                        //we break when we find the first one, as there will only ever be one failure\n                                        //as the op stops after the first failure\n                                        ModelNode desc = new ModelNode();\n                                        desc.get(OP).set(migrationOperations.get(entry.getKey()));\n                                        desc.get(RESULT).set(entry.getValue());\n                                        result.get(MIGRATION_ERROR).set(desc);\n                                        break;\n                                    }\n                                }\n                                context.getFailureDescription().set(new ModelNode(WebLogger.ROOT_LOGGER.migrationFailed()));\n                            }\n\n                            context.getResult().set(result);\n                        }\n                    });\n                }\n            }\n        }, MODEL);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void migrateConnector(OperationContext context, Map<PathAddress, ModelNode> newAddOperations, ModelNode newAddOp, PathAddress address, ModelNode legacyModelAddOps) throws OperationFailedException {\n        String protocol = newAddOp.get(WebConnectorDefinition.PROTOCOL.getName()).asString();\n        String scheme = null;\n        if (newAddOp.hasDefined(WebConnectorDefinition.SCHEME.getName())) {\n            scheme = newAddOp.get(WebConnectorDefinition.SCHEME.getName()).asString();\n        }\n        final PathAddress newAddress;\n        final ModelNode addConnector;\n        switch (protocol) {\n            case \"HTTP/1.1\":\n                if (scheme == null || scheme.equals(\"http\")) {\n                    newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HTTP_LISTENER, address.getLastElement().getValue()));\n                    addConnector = createAddOperation(newAddress);\n                } else if (scheme.equals(\"https\")) {\n                    newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HTTPS_LISTENER, address.getLastElement().getValue()));\n                    addConnector = createAddOperation(newAddress);\n\n                    SSLInformation sslInfo = createSecurityRealm(context, newAddOperations, legacyModelAddOps, newAddress.getLastElement().getValue());\n                    if (sslInfo == null) {\n                        throw WebLogger.ROOT_LOGGER.noSslConfig();\n                    } else {\n                        addConnector.get(Constants.SECURITY_REALM).set(sslInfo.realmName);\n                        addConnector.get(Constants.VERIFY_CLIENT).set(sslInfo.verifyClient);\n                        addConnector.get(Constants.SSL_SESSION_CACHE_SIZE).set(sslInfo.sessionCacheSize);\n                        addConnector.get(Constants.SSL_SESSION_TIMEOUT).set(sslInfo.sessionTimeout);\n                        addConnector.get(Constants.ENABLED_PROTOCOLS).set(sslInfo.sslProtocol);\n                        addConnector.get(Constants.ENABLED_CIPHER_SUITES).set(sslInfo.cipherSuites);\n                    }\n                } else {\n                    newAddress = null;\n                    addConnector = null;\n                }\n                break;\n            case \"AJP\":\n                newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.AJP_LISTENER, address.getLastElement().getValue()));\n                addConnector = createAddOperation(newAddress);\n                break;\n            default:\n                newAddress = null;\n                addConnector = null;\n        }\n        if (newAddress == null) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(newAddOp);\n            return;\n        }\n        addConnector.get(Constants.SOCKET_BINDING).set(newAddOp.get(SOCKET_BINDING));\n        addConnector.get(Constants.SECURE).set(newAddOp.get(WebConnectorDefinition.SECURE.getName()));\n        addConnector.get(Constants.REDIRECT_SOCKET).set(newAddOp.get(WebConnectorDefinition.REDIRECT_BINDING.getName()));\n        addConnector.get(Constants.ENABLED).set(newAddOp.get(WebConnectorDefinition.ENABLED.getName()));\n        addConnector.get(Constants.RESOLVE_PEER_ADDRESS).set(newAddOp.get(WebConnectorDefinition.ENABLE_LOOKUPS.getName()));\n        addConnector.get(Constants.MAX_POST_SIZE).set(newAddOp.get(WebConnectorDefinition.MAX_POST_SIZE.getName()));\n        addConnector.get(Constants.REDIRECT_SOCKET).set(newAddOp.get(WebConnectorDefinition.REDIRECT_BINDING.getName()));\n        addConnector.get(Constants.MAX_CONNECTIONS).set(newAddOp.get(WebConnectorDefinition.MAX_CONNECTIONS.getName()));\n        //TODO: secure\n        //TODO: max save post size\n        //TODO: proxy binding\n        if (newAddOp.hasDefined(WebConnectorDefinition.EXECUTOR.getName())) {\n            //TODO: migrate executor to worker\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebConnectorDefinition.EXECUTOR.getName(), pathAddress(newAddOp.get(ADDRESS)));\n        }\n\n        newAddOperations.put(pathAddress(newAddOp.get(OP_ADDR)), addConnector);\n    }","id":596,"modified_method":"private void migrateConnector(OperationContext context, Map<PathAddress, ModelNode> newAddOperations, ModelNode newAddOp, PathAddress address, ModelNode legacyModelAddOps, List<String> warnings) throws OperationFailedException {\n        String protocol = newAddOp.get(WebConnectorDefinition.PROTOCOL.getName()).asString();\n        String scheme = null;\n        if (newAddOp.hasDefined(WebConnectorDefinition.SCHEME.getName())) {\n            scheme = newAddOp.get(WebConnectorDefinition.SCHEME.getName()).asString();\n        }\n        final PathAddress newAddress;\n        final ModelNode addConnector;\n        switch (protocol) {\n            case \"HTTP/1.1\":\n                if (scheme == null || scheme.equals(\"http\")) {\n                    newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HTTP_LISTENER, address.getLastElement().getValue()));\n                    addConnector = createAddOperation(newAddress);\n                } else if (scheme.equals(\"https\")) {\n                    newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HTTPS_LISTENER, address.getLastElement().getValue()));\n                    addConnector = createAddOperation(newAddress);\n\n                    SSLInformation sslInfo = createSecurityRealm(context, newAddOperations, legacyModelAddOps, newAddress.getLastElement().getValue(), warnings);\n                    if (sslInfo == null) {\n                        throw WebLogger.ROOT_LOGGER.noSslConfig();\n                    } else {\n                        addConnector.get(Constants.SECURITY_REALM).set(sslInfo.realmName);\n                        addConnector.get(Constants.VERIFY_CLIENT).set(sslInfo.verifyClient);\n                        addConnector.get(Constants.SSL_SESSION_CACHE_SIZE).set(sslInfo.sessionCacheSize);\n                        addConnector.get(Constants.SSL_SESSION_TIMEOUT).set(sslInfo.sessionTimeout);\n                        addConnector.get(Constants.ENABLED_PROTOCOLS).set(sslInfo.sslProtocol);\n                        addConnector.get(Constants.ENABLED_CIPHER_SUITES).set(sslInfo.cipherSuites);\n                    }\n                } else {\n                    newAddress = null;\n                    addConnector = null;\n                }\n                break;\n            case \"AJP/1.3\":\n                newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.AJP_LISTENER, address.getLastElement().getValue()));\n                addConnector = createAddOperation(newAddress);\n                break;\n            default:\n                newAddress = null;\n                addConnector = null;\n        }\n        if (newAddress == null) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(newAddOp));\n            return;\n        }\n        addConnector.get(Constants.SOCKET_BINDING).set(newAddOp.get(SOCKET_BINDING));\n        addConnector.get(Constants.SECURE).set(newAddOp.get(WebConnectorDefinition.SECURE.getName()));\n        addConnector.get(Constants.REDIRECT_SOCKET).set(newAddOp.get(WebConnectorDefinition.REDIRECT_BINDING.getName()));\n        addConnector.get(Constants.ENABLED).set(newAddOp.get(WebConnectorDefinition.ENABLED.getName()));\n        addConnector.get(Constants.RESOLVE_PEER_ADDRESS).set(newAddOp.get(WebConnectorDefinition.ENABLE_LOOKUPS.getName()));\n        addConnector.get(Constants.MAX_POST_SIZE).set(newAddOp.get(WebConnectorDefinition.MAX_POST_SIZE.getName()));\n        addConnector.get(Constants.REDIRECT_SOCKET).set(newAddOp.get(WebConnectorDefinition.REDIRECT_BINDING.getName()));\n        addConnector.get(Constants.MAX_CONNECTIONS).set(newAddOp.get(WebConnectorDefinition.MAX_CONNECTIONS.getName()));\n        //TODO: secure\n        //TODO: max save post size\n        //TODO: proxy binding\n        if (newAddOp.hasDefined(WebConnectorDefinition.EXECUTOR.getName())) {\n            //TODO: migrate executor to worker\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebConnectorDefinition.EXECUTOR.getName(), pathAddress(newAddOp.get(ADDRESS))));\n        }\n\n        newAddOperations.put(pathAddress(newAddOp.get(OP_ADDR)), addConnector);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void migrateAccessLog(Map<PathAddress, ModelNode> newAddOperations, ModelNode newAddOp, PathAddress address, ModelNode legacyAddOps) {\n        PathAddress newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HOST, address.getElement(address.size() - 2).getValue()), UndertowExtension.PATH_ACCESS_LOG);\n        ModelNode add = createAddOperation(newAddress);\n\n        //TODO: parse the pattern and modify to Undertow version\n        add.get(Constants.PATTERN).set(newAddOp.get(WebAccessLogDefinition.PATTERN.getName()).clone());\n        add.get(Constants.PREFIX).set(newAddOp.get(WebAccessLogDefinition.PREFIX.getName()).clone());\n        add.get(Constants.ROTATE).set(newAddOp.get(WebAccessLogDefinition.ROTATE.getName()).clone());\n        if (newAddOp.hasDefined(WebAccessLogDefinition.RESOLVE_HOSTS.getName())) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebAccessLogDefinition.RESOLVE_HOSTS.getName(), pathAddress(newAddOp.get(ADDRESS)));\n        }\n        //TODO: extended access log\n        if (newAddOp.hasDefined(WebAccessLogDefinition.EXTENDED.getName())) {\n            WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebAccessLogDefinition.EXTENDED.getName(), pathAddress(newAddOp.get(ADDRESS)));\n        }\n\n        ModelNode directory = findResource(pathAddress(pathAddress(newAddOp.get(ADDRESS)), WebExtension.DIRECTORY_PATH), legacyAddOps);\n        if(directory != null){\n            newAddOp.get(Constants.DIRECTORY).set(directory.get(PATH));\n            newAddOp.get(Constants.RELATIVE_TO).set(directory.get(RELATIVE_TO));\n        }\n\n        newAddOperations.put(newAddress, add);\n    }","id":597,"modified_method":"private void migrateAccessLog(Map<PathAddress, ModelNode> newAddOperations, ModelNode newAddOp, PathAddress address, ModelNode legacyAddOps, List<String> warnings) {\n        PathAddress newAddress = pathAddress(UndertowExtension.SUBSYSTEM_PATH, DEFAULT_SERVER_PATH, pathElement(Constants.HOST, address.getElement(address.size() - 2).getValue()), UndertowExtension.PATH_ACCESS_LOG);\n        ModelNode add = createAddOperation(newAddress);\n\n        //TODO: parse the pattern and modify to Undertow version\n        add.get(Constants.PATTERN).set(newAddOp.get(WebAccessLogDefinition.PATTERN.getName()).clone());\n        add.get(Constants.PREFIX).set(newAddOp.get(WebAccessLogDefinition.PREFIX.getName()).clone());\n        add.get(Constants.ROTATE).set(newAddOp.get(WebAccessLogDefinition.ROTATE.getName()).clone());\n        if (newAddOp.hasDefined(WebAccessLogDefinition.RESOLVE_HOSTS.getName())) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebAccessLogDefinition.RESOLVE_HOSTS.getName(), pathAddress(newAddOp.get(ADDRESS))));\n        }\n        //TODO: extended access log\n        if (newAddOp.hasDefined(WebAccessLogDefinition.EXTENDED.getName())) {\n            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebAccessLogDefinition.EXTENDED.getName(), pathAddress(newAddOp.get(ADDRESS))));\n        }\n\n        ModelNode directory = findResource(pathAddress(pathAddress(newAddOp.get(ADDRESS)), WebExtension.DIRECTORY_PATH), legacyAddOps);\n        if(directory != null){\n            newAddOp.get(Constants.DIRECTORY).set(directory.get(PATH));\n            newAddOp.get(Constants.RELATIVE_TO).set(directory.get(RELATIVE_TO));\n        }\n\n        newAddOperations.put(newAddress, add);\n    }","commit_id":"b3d6701f70619965d589f017342030e898e8bd6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  public void preAddColumn(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, HColumnDescriptor column) throws IOException {\n    requirePermission(Permission.Action.CREATE);\n  }","id":598,"modified_method":"@Override\n  public void preAddColumn(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, HColumnDescriptor column) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void preModifyTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, HTableDescriptor htd) throws IOException {\n    requirePermission(Permission.Action.CREATE);\n  }","id":599,"modified_method":"@Override\n  public void preModifyTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, HTableDescriptor htd) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void preDisableTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName) throws IOException {\n    if (isActiveUserTableOwner(c.getEnvironment(), tableName)) {\n      requirePermission(Permission.Action.CREATE);\n    } else {\n      requirePermission(Permission.Action.ADMIN);\n    }\n  }","id":600,"modified_method":"@Override\n  public void preDisableTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void preEnableTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName) throws IOException {\n    if (isActiveUserTableOwner(c.getEnvironment(), tableName)) {\n      requirePermission(Permission.Action.CREATE);\n    } else {\n      requirePermission(Permission.Action.ADMIN);\n    }\n  }","id":601,"modified_method":"@Override\n  public void preEnableTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void preDeleteTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName) throws IOException {\n    if (isActiveUserTableOwner(c.getEnvironment(), tableName)) {\n      requirePermission(Permission.Action.CREATE);\n    } else {\n      requirePermission(Permission.Action.ADMIN);\n    }\n  }","id":602,"modified_method":"@Override\n  public void preDeleteTable(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void preDeleteColumn(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, byte[] col) throws IOException {\n    requirePermission(Permission.Action.CREATE);\n  }","id":603,"modified_method":"@Override\n  public void preDeleteColumn(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, byte[] col) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public void preModifyColumn(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, HColumnDescriptor descriptor) throws IOException {\n    requirePermission(Permission.Action.CREATE);\n  }","id":604,"modified_method":"@Override\n  public void preModifyColumn(ObserverContext<MasterCoprocessorEnvironment> c,\n      byte[] tableName, HColumnDescriptor descriptor) throws IOException {\n    requireTableAdminPermission(c.getEnvironment(), tableName);\n  }","commit_id":"6a4496054983d68db1f8b83f6790974e3f055d96","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Build div, optional input, and JavaScript into response.\n     *\n     * @see er.ajax.AjaxDynamicElement#appendToResponse(com.webobjects.appserver.WOResponse, com.webobjects.appserver.WOContext)\n     */\n    @Override\n    public void appendToResponse(WOResponse response, WOContext context) {\n        // We don't contain anything, but we need to call super so it calls addRequiredWebResources(WOResponse, WOContext)\n        super.appendToResponse(response, context);\n\n        // Build div like <div  id=\"e_1_0_0_1_3_7\" class=\"rating_container\"><\/div>\n        String id = id(context);\n        response.appendContentString(\"<div \");\n        appendTagAttributeToResponse(response, \"id\", id);\n        appendTagAttributeToResponse(response, \"class\", \"rating_container\");\n        response.appendContentString(\"><\/div>\");\n\n        // Build optional input like <input  id=\"e_1_0_0_1_3_7_input\" name=\"e_1_0_0_1_3_7_value\" value=\"5\" type=\"hidden\"/>\n        if (actAsInput(context)) {\n            response.appendContentString(\"<input \");\n            appendTagAttributeToResponse(response, \"id\", id + \"_input\");\n            appendTagAttributeToResponse(response, \"name\", formValueName(context));\n            appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", context.component()));\n            appendTagAttributeToResponse(response, \"type\", \"hidden\");\n            response.appendContentString(\"/>\");\n        }\n\n        // Build script like\n        // <script type=\"text/javascript\">\n        //     var e_1_0_0_1_3_7 = new Control.Rating('e_1_0_0_1_3_7',\n        //         {multiple:true, value:5, min:2, max:8, rated:false, input:'e_1_0_0_1_3_7_input', updateParameterName:'e_1_0_0_1_3_7_value'});\n        // <\/script>\n        response.appendContentString(\"<script type=\\\"text/javascript\\\">\");\n        response.appendContentString(\"var \");\n        response.appendContentString(id);\n        response.appendContentString(\" = new Control.Rating('\");\n        response.appendContentString(id);\n        response.appendContentString(\"', \");\n        AjaxOptions.appendToResponse(createOptions(context), response, context);\n        response.appendContentString(\"); <\/script>\");\n    }","id":605,"modified_method":"/**\n     * Build div, optional input, and JavaScript into response.\n     *\n     * @see er.ajax.AjaxDynamicElement#appendToResponse(com.webobjects.appserver.WOResponse, com.webobjects.appserver.WOContext)\n     */\n    @Override\n    public void appendToResponse(WOResponse response, WOContext context) {\n        // We don't contain anything, but we need to call super so it calls addRequiredWebResources(WOResponse, WOContext)\n        super.appendToResponse(response, context);\n\n        // Build container element like <div id=\"e_1_0_0_1_3_7\" class=\"rating_container\"><\/div>\n        \n        String id = id(context);\n        String elementName = (String) valueForBinding(\"elementName\", \"div\", context.component()); \n        response.appendContentString(\"<\");\n        response.appendContentString(elementName);\n        response.appendContentString(\" \");\n        appendTagAttributeToResponse(response, \"id\", id);\n        \n        String className = \"rating_container\";\n        if (hasBinding(\"class\")) {\n            className += \" \" + stringValueForBinding(\"class\", context.component());            \n        }\n        appendTagAttributeToResponse(response, \"class\", className);\n\n        if (hasBinding(\"style\")) {\n            appendTagAttributeToResponse(response, \"style\", stringValueForBinding(\"style\", context.component()));            \n        }\n        response.appendContentString(\"><\/\");\n        response.appendContentString(elementName);\n        response.appendContentString(\">\");\n\n        // Build optional input like <input id=\"e_1_0_0_1_3_7_input\" name=\"e_1_0_0_1_3_7_value\" value=\"5\" type=\"hidden\"/>\n        if (actAsInput(context)) {\n            response.appendContentString(\"<input \");\n            appendTagAttributeToResponse(response, \"id\", id + \"_input\");\n            appendTagAttributeToResponse(response, \"name\", formValueName(context));\n            appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", context.component()));\n            appendTagAttributeToResponse(response, \"type\", \"hidden\");\n            response.appendContentString(\"/>\");\n        }\n\n        // Build script like\n        // <script type=\"text/javascript\">\n        //     var e_1_0_0_1_3_7 = new Control.Rating('e_1_0_0_1_3_7',\n        //         {multiple:true, value:5, min:2, max:8, rated:false, input:'e_1_0_0_1_3_7_input', updateParameterName:'e_1_0_0_1_3_7_value'});\n        // <\/script>\n        response.appendContentString(\"<script type=\\\"text/javascript\\\">\");\n        response.appendContentString(\"var \");\n        response.appendContentString(id);\n        response.appendContentString(\" = new Control.Rating('\");\n        response.appendContentString(id);\n        response.appendContentString(\"', \");\n        AjaxOptions.appendToResponse(createOptions(context), response, context);\n        response.appendContentString(\"); <\/script>\");\n    }","commit_id":"df6cb8f673da9069bc5ef81db463e22d5843cae8","url":"https://github.com/wocommunity/wonder"},{"original_method":"public AjaxTabbedPanel(String name, NSDictionary associations, WOElement template) {\n        super(name, associations, template);\n        content = template;\n        id = (WOAssociation) associations.objectForKey(\"id\");\n        busyDiv = (WOAssociation) associations.objectForKey(\"busyDiv\");\n        onLoad = (WOAssociation) associations.objectForKey(\"onLoad\");\n        findTabs((WODynamicGroup)template);\n\n        if (id == null)\n        {\n        \tthrow new RuntimeException(\"id binding is required\");\n        }\n    }","id":606,"modified_method":"public AjaxTabbedPanel(String name, NSDictionary associations, WOElement template) {\n        super(name, associations, template);\n        content = template;\n        id = (WOAssociation) associations.objectForKey(\"id\");\n        busyDiv = (WOAssociation) associations.objectForKey(\"busyDiv\");\n        onLoad = (WOAssociation) associations.objectForKey(\"onLoad\");\n        onSelect = (WOAssociation) associations.objectForKey(\"onSelect\");\n        findTabs((WODynamicGroup)template);\n\n        if (id == null)\n        {\n        \tthrow new RuntimeException(\"id binding is required\");\n        }\n    }","commit_id":"a1bc7570d92f4359d19a72c2e6900351b15ef209","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Creates the tabs and pane control.\n     */\n    public void appendToResponse(WOResponse response, WOContext context) {\n        WOComponent component = context.component();\n        String idString = (String) id.valueInComponent(component);\n        if (idString == null) {\n        \tthrow new RuntimeException(\"id binding evaluated to null\");\n        }\n\n        // UL for tabs\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanel\\\"\");\n        appendTagAttributeToResponse(response, \"id\", idString);\n        if (onLoad != null) {\n            appendTagAttributeToResponse(response, \"onLoad\", onLoad.valueInComponent(component));\n        }\n        response.appendContentString(\">\\n\");\n\n        String paneControlID = idString + \"_panecontrol\";\n\n        for (int i = 0; i < tabs.count(); i++) {\n            String index = new Integer(i).toString();\n            String tabID = idString + \"_tab_\" + index;\n            AjaxTabbedPanelTab tab = (AjaxTabbedPanelTab)tabs.objectAtIndex(i);\n            if (tab.isVisble(component)) {\n\t            boolean isSelectedTab = tab.isSelected(context.component());\n\t            String panelTabID = (String) tab.id().valueInComponent(component);\n\t            String panelID = panelTabID + \"_panel\";\n\t            response.appendContentString(\"  <li class=\\\"ajaxTabbedPanelTab-\");\n\t            response.appendContentString(isSelectedTab ? \"selected\" : \"unselected\");\n\t            response.appendContentString(\"\\\" \");\n\t            appendTagAttributeToResponse(response, \"id\", tabID);\n\t            response.appendContentString(\">\\n\");\n\t            response.appendContentString(\"<a \");\n\t            appendTagAttributeToResponse(response, \"id\", panelTabID);\n\t            response.appendContentString(\" href=\\\"javascript:void(0)\\\" onclick=\\\"\");\n\t\n\t            response.appendContentString(\"AjaxTabbedPanel.loadPanel('\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString((busyDiv != null) ? (String)busyDiv.valueInComponent(component) : \"\");\n\t            response.appendContentString(\"', \");\n\t            response.appendContentString(tab.refreshesOnSelect(context.component()).toString());\n\t            response.appendContentString(\"); \");\n\t\n\t            response.appendContentString(\"AjaxTabbedPanel.selectTab('\");\n\t            response.appendContentString(idString);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(tabID);\n\t            response.appendContentString(\"'); AjaxTabbedPanel.selectPanel('\");\n\t            response.appendContentString(paneControlID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"');\\\">\");\n\t            response.appendContentString((String) tab.name().valueInComponent(component));\n\t            response.appendContentString(\"<\/a>\\n\");\n\t            response.appendContentString(\"<\/li>\\n\");\n            }\n        }\n\n        response.appendContentString(\"<\/ul>\\n\");\n\n        // UL for panes\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanelPanes\\\" \");\n        appendTagAttributeToResponse(response, \"id\", paneControlID);\n        response.appendContentString(\">\\n\");\n        // The tabs render themselves as panes\n        if (content !=  null) {\n        \tcontent.appendToResponse(response, context);\n        }\n        response.appendContentString(\"<\/ul>\\n\");\n        super.appendToResponse(response, context);\n\n        response.appendContentString(\"<script>AjaxTabbedPanel.onLoad('\");\n        response.appendContentString(idString);\n        response.appendContentString(\"');<\/script>\\n\");\n    }","id":607,"modified_method":"/**\n     * Creates the tabs and pane control.\n     */\n    public void appendToResponse(WOResponse response, WOContext context) {\n        WOComponent component = context.component();\n        String idString = (String) id.valueInComponent(component);\n        if (idString == null) {\n        \tthrow new RuntimeException(\"id binding evaluated to null\");\n        }\n\n        // UL for tabs\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanel\\\"\");\n        appendTagAttributeToResponse(response, \"id\", idString);\n        \n        // Optional JavaScriplets\n        if (onLoad != null) {\n            appendTagAttributeToResponse(response, \"onLoad\", onLoad.valueInComponent(component));\n        }\n        if (onSelect != null) {\n            appendTagAttributeToResponse(response, \"onSelect\", onSelect.valueInComponent(component));\n        }\n        \n        response.appendContentString(\">\\n\");\n\n        String paneControlID = idString + \"_panecontrol\";\n\n        for (int i = 0; i < tabs.count(); i++) {\n            String index = new Integer(i).toString();\n            String tabID = idString + \"_tab_\" + index;\n            AjaxTabbedPanelTab tab = (AjaxTabbedPanelTab)tabs.objectAtIndex(i);\n            if (tab.isVisble(component)) {\n\t            boolean isSelectedTab = tab.isSelected(context.component());\n\t            String panelTabID = (String) tab.id().valueInComponent(component);\n\t            String panelID = panelTabID + \"_panel\";\n\t            response.appendContentString(\"  <li class=\\\"ajaxTabbedPanelTab-\");\n\t            response.appendContentString(isSelectedTab ? \"selected\" : \"unselected\");\n\t            response.appendContentString(\"\\\" \");\n\t            appendTagAttributeToResponse(response, \"id\", tabID);\n\t            response.appendContentString(\">\\n\");\n\t            response.appendContentString(\"<a \");\n\t            appendTagAttributeToResponse(response, \"id\", panelTabID);\n\t            response.appendContentString(\" href=\\\"javascript:void(0)\\\" onclick=\\\"\");\n\t\n\t            // Load the tab contents\n\t            response.appendContentString(\"AjaxTabbedPanel.loadPanel('\");\n\t            response.appendContentString(idString);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString((busyDiv != null) ? (String)busyDiv.valueInComponent(component) : \"\");\n\t            response.appendContentString(\"', \");\n\t            response.appendContentString(tab.refreshesOnSelect(context.component()).toString());\n\t            response.appendContentString(\"); \");\n\t            \n\t            // Select the tab contents\n\t            response.appendContentString(\"AjaxTabbedPanel.selectPanel('\");\n\t            response.appendContentString(paneControlID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"'); \");\n\t            \n\t            // Select the tab control\n\t            response.appendContentString(\"AjaxTabbedPanel.selectTab('\");\n\t            response.appendContentString(idString);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(tabID);\n\t            response.appendContentString(\"'); \");\n\t            \n\t            response.appendContentString(\"\\\">\");\n\t            response.appendContentString((String) tab.name().valueInComponent(component));\n\t            response.appendContentString(\"<\/a>\\n\");\n\t            response.appendContentString(\"<\/li>\\n\");\n            }\n        }\n\n        response.appendContentString(\"<\/ul>\\n\");\n\n        // UL for panes\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanelPanes\\\" \");\n        appendTagAttributeToResponse(response, \"id\", paneControlID);\n        response.appendContentString(\">\\n\");\n        // The tabs render themselves as panes\n        if (content !=  null) {\n        \tcontent.appendToResponse(response, context);\n        }\n        response.appendContentString(\"<\/ul>\\n\");\n        super.appendToResponse(response, context);\n\n        response.appendContentString(\"<script>AjaxTabbedPanel.onLoad('\");\n        response.appendContentString(idString);\n        response.appendContentString(\"');<\/script>\\n\");\n    }","commit_id":"a1bc7570d92f4359d19a72c2e6900351b15ef209","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\t}","id":608,"modified_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.FORMATTED);\n\t\t}\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void partition(final String volumeId, final String device)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\t}","id":609,"modified_method":"@Override\n\tpublic void partition(final String volumeId, final String device)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.PARTITIONED);\n\t\t}\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem, timeoutInMillis);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\n\t}","id":610,"modified_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem, timeoutInMillis);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.FORMATTED);\n\t\t}\n\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\t}","id":611,"modified_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.MOUNTED);\n\t\t}\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path, timeoutInMillis);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\n\t}","id":612,"modified_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path, timeoutInMillis);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.MOUNTED);\n\t\t}\n\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void partition(final String volumeId, final String device, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device, timeoutInMillis);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\n\t}","id":613,"modified_method":"@Override\n\tpublic void partition(final String volumeId, final String device, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device, timeoutInMillis);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.PARTITIONED);\n\t\t}\n\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public static void handleDownload(ToadletContext context, Bucket data, BucketFactory bucketFactory, String mimeType, String requestedMimeType, String forceString, boolean forceDownload, String basePath, FreenetURI key, String extras, String referrer, boolean downloadLink, ToadletContext ctx, NodeClientCore core, boolean dontFreeData) throws ToadletContextClosedException, IOException {\n\t\tToadletContainer container = context.getContainer();\n\t\tif(Logger.shouldLog(Logger.MINOR, FProxyToadlet.class))\n\t\t\tLogger.minor(FProxyToadlet.class, \"handleDownload(data.size=\"+data.size()+\", mimeType=\"+mimeType+\", requestedMimeType=\"+requestedMimeType+\", forceDownload=\"+forceDownload+\", basePath=\"+basePath+\", key=\"+key);\n\t\tString extrasNoMime = extras; // extras will not include MIME type to start with - REDFLAG maybe it should be an array\n\t\tif(requestedMimeType != null) {\n\t\t\tif(mimeType == null || !requestedMimeType.equals(mimeType)) {\n\t\t\t\tif(extras == null) extras = \"\";\n\t\t\t\textras = extras + \"&type=\" + requestedMimeType;\n\t\t\t}\n\t\t\tmimeType = requestedMimeType;\n\t\t}\n\t\tlong size = data.size();\n\t\t\n\t\tlong now = System.currentTimeMillis();\n\t\tboolean force = false;\n\t\tif(forceString != null) {\n\t\t\tif(forceString.equals(getForceValue(key, now)) || \n\t\t\t\t\tforceString.equals(getForceValue(key, now-FORCE_GRAIN_INTERVAL)))\n\t\t\t\tforce = true;\n\t\t}\n\n\t\tBucket toFree = null;\n\t\tBucket tmpRange = null;\n\t\ttry {\n\t\t\tif((!force) && (!forceDownload)) {\n\t\t\t\tFilterOutput fo = ContentFilter.filter(data, bucketFactory, mimeType, key.toURI(basePath), container.enableInlinePrefetch() ? prefetchHook : null);\n\t\t\t\tif(data != fo.data) toFree = fo.data;\n\t\t\t\tdata = fo.data;\n\t\t\t\tmimeType = fo.type;\n\t\t\t\t\n\t\t\t\tif(horribleEvilHack(data) && !(mimeType.startsWith(\"application/rss+xml\"))) {\n\t\t\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousRSSTitle\"), context);\n\t\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\t\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"dangerousRSSSubtitle\"));\n\t\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\tinfoboxContent.addChild(\"#\", L10n.getString(\"FProxyToadlet.dangerousRSS\", new String[] { \"type\" }, new String[] { mimeType }));\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\tHTMLNode option = optionList.addChild(\"li\");\n\t\t\t\t\t\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSAsPlainText\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain&force=\"+getForceValue(key,now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\t// \tFIXME: is this safe? See bug #131\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSForceDisk\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tboolean mimeRSS = mimeType.startsWith(\"application/xml+rss\") || mimeType.startsWith(\"text/xml\"); /* blergh! */\n\t\t\t\t\tif(!(mimeRSS || mimeType.startsWith(\"text/plain\"))) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSForce\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\", \"mime\" },\n\t\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?force=\"+getForceValue(key, now)+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\t\"<\/b>\",\n\t\t\t\t\t\t\t\t\tHTMLEncoder.encode(mimeType) /* these are not encoded because mostly they are tags, so we have to encode it */ });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSAsRSS\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath + key.toString() + \"?type=application/xml+rss&force=\" + getForceValue(key, now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tif(referrer != null) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\t\t\tcontext.writeData(pageBytes);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (forceDownload) {\n\t\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\t\theaders.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + key.getPreferredFilename() + '\"');\n\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", headers, \"application/x-msdownload\", data.size());\n\t\t\t\tcontext.writeData(data);\n\t\t\t} else {\n\t\t\t\t// Send the data, intact\n\t\t\t\tMultiValueTable<String, String> hdr = context.getHeaders();\n\t\t\t\tString rangeStr = hdr.get(\"range\");\n\t\t\t\t// was a range request\n\t\t\t\tif (rangeStr != null) {\n\t\t\t\t\t\n\t\t\t\t\tlong range[] = parseRange(rangeStr);\n\t\t\t\t\tif (range[1] == -1 || range[1] >= data.size()) {\n\t\t\t\t\t\trange[1] = data.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\ttmpRange = bucketFactory.makeBucket(range[1] - range[0]);\n\t\t\t\t\tInputStream is = data.getInputStream();\n\t\t\t\t\tOutputStream os = tmpRange.getOutputStream();\n\t\t\t\t\tif (range[0] > 0)\n\t\t\t\t\t\tis.skip(range[0]);\n\t\t\t\t\tFileUtil.copy(is, os, range[1] - range[0] + 1);\n\t\t\t\t\tos.close();\n\t\t\t\t\tis.close();\n\t\t\t\t\tMultiValueTable<String, String> retHdr = new MultiValueTable<String, String>();\n\t\t\t\t\tretHdr.put(\"Content-Range\", \"bytes \" + range[0] + \"-\" + range[1] + \"/\" + data.size());\n\t\t\t\t\tcontext.sendReplyHeaders(206, \"Partial content\", retHdr, mimeType, tmpRange.size());\n\t\t\t\t\tcontext.writeData(tmpRange);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), mimeType, data.size());\n\t\t\t\t\tcontext.writeData(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (URISyntaxException use1) {\n\t\t\t/* shouldn't happen */\n\t\t\tuse1.printStackTrace();\n\t\t\tLogger.error(FProxyToadlet.class, \"could not create URI\", use1);\n\t\t} catch (UnsafeContentTypeException e) {\n\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousContentTitle\"), context);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", e.getRawTitle());\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode list = infoboxContent.addChild(\"ul\");\n\t\t\twriteSizeAndMIME(list, size, mimeType, true);\n\t\t\t\n\t\t\tHTMLNode option = list.addChild(\"li\");\n\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, mimeType));\n\t\t\t\n\t\t\tinfoboxContent.addChild(\"p\").addChild(e.getHTMLExplanation());\n\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\n\t\t\tif((mimeType.equals(\"application/x-freenet-index\")) && (core.node.pluginManager.isPluginLoaded(\"plugins.ThawIndexBrowser.ThawIndexBrowser\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsThawIndex\", new String[] { \"link\", \"/link\" }, new String[] { \"<b><a href=\\\"\"+basePath + \"plugins/plugins.ThawIndexBrowser.ThawIndexBrowser/?key=\" + key.toString() + \"\\\">\", \"<\/a><\/b>\" });\n\t\t\t}\n\t\t\t\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\t// FIXME: is this safe? See bug #131\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsText\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain\"+extrasNoMime+\"\\\">\", \"<\/a>\" });\n\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForceDisk\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\", \"<\/a>\" });\n\t\t\tif(!(mimeType.equals(\"application/octet-stream\") || mimeType.equals(\"application/x-msdownload\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForce\", new String[] { \"link\", \"/link\", \"mime\" }, new String[] { \"<a href=\\\"\"+basePath + key.toString() + \"?force=\" + getForceValue(key, now)+extras+\"\\\">\", \"<\/a>\", HTMLEncoder.encode(mimeType)});\n\t\t\t}\n\t\t\tif(referrer != null) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t}\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\tif(ctx.isAllowedFullAccess() || !container.publicGatewayMode()) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\n\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\n\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\tcontext.writeData(pageBytes);\n\t\t} catch (HTTPRangeException e) {\n\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t} finally {\n\t\t\tif(toFree != null && !dontFreeData) toFree.free();\n\t\t\tif(tmpRange != null) tmpRange.free();\n\t\t}\n\t}","id":614,"modified_method":"public static void handleDownload(ToadletContext context, Bucket data, BucketFactory bucketFactory, String mimeType, String requestedMimeType, String forceString, boolean forceDownload, String basePath, FreenetURI key, String extras, String referrer, boolean downloadLink, ToadletContext ctx, NodeClientCore core, boolean dontFreeData) throws ToadletContextClosedException, IOException {\n\t\tToadletContainer container = context.getContainer();\n\t\tif(Logger.shouldLog(Logger.MINOR, FProxyToadlet.class))\n\t\t\tLogger.minor(FProxyToadlet.class, \"handleDownload(data.size=\"+data.size()+\", mimeType=\"+mimeType+\", requestedMimeType=\"+requestedMimeType+\", forceDownload=\"+forceDownload+\", basePath=\"+basePath+\", key=\"+key);\n\t\tString extrasNoMime = extras; // extras will not include MIME type to start with - REDFLAG maybe it should be an array\n\t\tif(requestedMimeType != null) {\n\t\t\tif(mimeType == null || !requestedMimeType.equals(mimeType)) {\n\t\t\t\tif(extras == null) extras = \"\";\n\t\t\t\textras = extras + \"&type=\" + requestedMimeType;\n\t\t\t}\n\t\t\tmimeType = requestedMimeType;\n\t\t}\n\t\tlong size = data.size();\n\t\t\n\t\tlong now = System.currentTimeMillis();\n\t\tboolean force = false;\n\t\tif(forceString != null) {\n\t\t\tif(forceString.equals(getForceValue(key, now)) || \n\t\t\t\t\tforceString.equals(getForceValue(key, now-FORCE_GRAIN_INTERVAL)))\n\t\t\t\tforce = true;\n\t\t}\n\n\t\tBucket toFree = null;\n\t\tBucket tmpRange = null;\n\t\ttry {\n\t\t\tif((!force) && (!forceDownload)) {\n\t\t\t\tFilterOutput fo = ContentFilter.filter(data, bucketFactory, mimeType, key.toURI(basePath), container.enableInlinePrefetch() ? prefetchHook : null);\n\t\t\t\tif(data != fo.data) toFree = fo.data;\n\t\t\t\tdata = fo.data;\n\t\t\t\tmimeType = fo.type;\n\t\t\t\t\n\t\t\t\tif(horribleEvilHack(data) && !(mimeType.startsWith(\"application/rss+xml\"))) {\n\t\t\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousRSSTitle\"), context);\n\t\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\t\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"dangerousRSSSubtitle\"));\n\t\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\tinfoboxContent.addChild(\"#\", L10n.getString(\"FProxyToadlet.dangerousRSS\", new String[] { \"type\" }, new String[] { mimeType }));\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\tHTMLNode option = optionList.addChild(\"li\");\n\t\t\t\t\t\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSAsPlainText\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain&force=\"+getForceValue(key,now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\t// \tFIXME: is this safe? See bug #131\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSForceDisk\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tboolean mimeRSS = mimeType.startsWith(\"application/xml+rss\") || mimeType.startsWith(\"text/xml\"); /* blergh! */\n\t\t\t\t\tif(!(mimeRSS || mimeType.startsWith(\"text/plain\"))) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSForce\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\", \"mime\" },\n\t\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?force=\"+getForceValue(key, now)+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\t\"<\/b>\",\n\t\t\t\t\t\t\t\t\tHTMLEncoder.encode(mimeType) /* these are not encoded because mostly they are tags, so we have to encode it */ });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSAsRSS\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath + key.toString() + \"?type=application/xml+rss&force=\" + getForceValue(key, now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tif(referrer != null) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\t\t\tcontext.writeData(pageBytes);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (forceDownload) {\n\t\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\t\theaders.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + key.getPreferredFilename() + '\"');\n\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", headers, \"application/x-msdownload\", data.size());\n\t\t\t\tcontext.writeData(data);\n\t\t\t} else {\n\t\t\t\t// Send the data, intact\n\t\t\t\tMultiValueTable<String, String> hdr = context.getHeaders();\n\t\t\t\tString rangeStr = hdr.get(\"range\");\n\t\t\t\t// was a range request\n\t\t\t\tif (rangeStr != null) {\n\t\t\t\t\t\n\t\t\t\t\tlong range[] = parseRange(rangeStr);\n\t\t\t\t\tif (range[1] == -1 || range[1] >= data.size()) {\n\t\t\t\t\t\trange[1] = data.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\ttmpRange = bucketFactory.makeBucket(range[1] - range[0]);\n\t\t\t\t\tInputStream is = data.getInputStream();\n\t\t\t\t\tOutputStream os = tmpRange.getOutputStream();\n\t\t\t\t\tif (range[0] > 0)\n\t\t\t\t\t\tis.skip(range[0]);\n\t\t\t\t\tFileUtil.copy(is, os, range[1] - range[0] + 1);\n\t\t\t\t\tos.close();\n\t\t\t\t\tis.close();\n\t\t\t\t\tMultiValueTable<String, String> retHdr = new MultiValueTable<String, String>();\n\t\t\t\t\tretHdr.put(\"Content-Range\", \"bytes \" + range[0] + \"-\" + range[1] + \"/\" + data.size());\n\t\t\t\t\tcontext.sendReplyHeaders(206, \"Partial content\", retHdr, mimeType, tmpRange.size());\n\t\t\t\t\tcontext.writeData(tmpRange);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), mimeType, data.size());\n\t\t\t\t\tcontext.writeData(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (URISyntaxException use1) {\n\t\t\t/* shouldn't happen */\n\t\t\tuse1.printStackTrace();\n\t\t\tLogger.error(FProxyToadlet.class, \"could not create URI\", use1);\n\t\t} catch (UnsafeContentTypeException e) {\n\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousContentTitle\"), context);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", e.getRawTitle());\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode list = infoboxContent.addChild(\"ul\");\n\t\t\twriteSizeAndMIME(list, size, mimeType, true);\n\t\t\t\n\t\t\tHTMLNode option = list.addChild(\"li\");\n\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, mimeType));\n\t\t\t\n\t\t\tinfoboxContent.addChild(\"p\").addChild(e.getHTMLExplanation());\n\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\n\t\t\tif((mimeType.equals(\"application/x-freenet-index\")) && (core.node.pluginManager.isPluginLoaded(\"plugins.ThawIndexBrowser.ThawIndexBrowser\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsThawIndex\", new String[] { \"link\", \"/link\" }, new String[] { \"<b><a href=\\\"\"+basePath + \"plugins/plugins.ThawIndexBrowser.ThawIndexBrowser/?key=\" + key.toString() + \"\\\">\", \"<\/a><\/b>\" });\n\t\t\t}\n\t\t\t\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\t// FIXME: is this safe? See bug #131\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsText\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain\"+extrasNoMime+\"\\\">\", \"<\/a>\" });\n\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForceDisk\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\", \"<\/a>\" });\n\t\t\tif(!(mimeType.equals(\"application/octet-stream\") || mimeType.equals(\"application/x-msdownload\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForce\", new String[] { \"link\", \"/link\", \"mime\" }, new String[] { \"<a href=\\\"\"+basePath + key.toString() + \"?force=\" + getForceValue(key, now)+extras+\"\\\">\", \"<\/a>\", HTMLEncoder.encode(mimeType)});\n\t\t\t}\n\t\t\tif(referrer != null) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t}\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\tif(ctx.isAllowedFullAccess() || !container.publicGatewayMode()) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\n\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\tcontext.writeData(pageBytes);\n\t\t} catch (HTTPRangeException e) {\n\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t} finally {\n\t\t\tif(toFree != null && !dontFreeData) toFree.free();\n\t\t\tif(tmpRange != null) tmpRange.free();\n\t\t}\n\t}","commit_id":"da2dd05f88fe1aef52c7e8e0b1514d1420651645","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString requestedMimeType = httprequest.getParam(\"type\");\n\t\t\t\tlong maxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\t\tString location = getLink(newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\tstrm.close();\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/feed/\") || ks.equals(\"/feed\")) {\n\t\t\t//TODO Better way to find the host. Find if https is used?\n\t\t\tString host = ctx.getHeaders().get(\"host\");\n\t\t\tString atom = core.alerts.getAtom(\"http://\" + host);\n\t\t\tbyte[] buf = atom.getBytes(\"UTF-8\");\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"application/atom+xml\", buf.length);\n\t\t\tctx.writeData(buf, 0, buf.length);\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/queue/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/downloads/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/config/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/config/node\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\t//first check of httprange before get\n\t\t// only valid number format is checked here\n\t\tString rangeStr = ctx.getHeaders().get(\"range\");\n\t\tif (rangeStr != null) {\n\t\t\ttry {\n\t\t\t\tparseRange(rangeStr);\n\t\t\t} catch (HTTPRangeException e) {\n\t\t\t\tLogger.normal(this, \"Invalid Range Header: \"+rangeStr, e);\n\t\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\n\t\tBucket data = null;\n\t\tString mimeType = null;\n\t\tString referer = sanitizeReferer(ctx);\n\t\tFetchException fe = null;\n\t\t\n\n\t\tMultiValueTable<String,String> headers = ctx.getHeaders();\n\t\tString ua = headers.get(\"user-agent\");\n\t\tString accept = headers.get(\"accept\");\n\t\tFProxyFetchResult fr = null;\n\t\tif(logMINOR) Logger.minor(this, \"UA = \"+ua+\" accept = \"+accept);\n\t\tif(isBrowser(ua) && !ctx.disableProgressPage() && (accept == null || accept.indexOf(\"text/html\") > -1) && !httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tFProxyFetchWaiter fetch = null;\n\t\t\ttry {\n\t\t\t\tfetch = fetchTracker.makeFetcher(key, maxSize);\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfe = fr.failed;\n\t\t\t}\n\t\t\tif(fetch != null)\n\t\t\twhile(true) {\n\t\t\tfr = fetch.getResult();\n\t\t\tif(fr.hasData()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\t\t\tdata = fr.data;\n\t\t\t\tmimeType = fr.mimeType;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else if(fr.failed != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Request failed\");\n\t\t\t\tfe = fr.failed;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Still in progress\");\n\t\t\t\t// Still in progress\n\t\t\t\tboolean isJsEnabled=ctx.getContainer().isFProxyJavascriptEnabled() && ua != null && !ua.contains(\"AppleWebKit/\");\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fetchingPageTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tString location = getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\tHTMLNode headNode=page.headNode;\n\t\t\t\tif(isJsEnabled){\n\t\t\t\t\t//If the user has enabled javascript, we add a <noscript> http refresh(if he has disabled it in the browser)\n\t\t\t\t\t//And the script file\n\t\t\t\t\theadNode.addChild(\"noscript\").addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t\tHTMLNode scriptNode=headNode.addChild(\"script\",\"//abc\");\n\t\t\t\t\tscriptNode.addAttribute(\"type\", \"text/javascript\");\n\t\t\t\t\tscriptNode.addAttribute(\"src\", \"/static/js/progresspage.js\");\n\t\t\t\t}else{\n\t\t\t\t\t//If he disabled it, we just put the http refresh meta, without the noscript\n\t\t\t\t\theadNode.addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageBox\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addAttribute(\"id\", \"infoContent\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"filenameLabel\")+ \" \");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/\"+key.toString(false, false), key.getPreferredFilename());\n\t\t\t\tif(fr.mimeType != null) infoboxContent.addChild(\"br\", l10n(\"contentTypeLabel\")+\" \"+fr.mimeType);\n\t\t\t\tif(fr.size > 0) infoboxContent.addChild(\"br\", \"Size: \"+SizeUtil.formatSize(fr.size));\n\t\t\t\tif(core.isAdvancedModeEnabled()) {\n\t\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"blocksDetail\", \n\t\t\t\t\t\t\tnew String[] { \"fetched\", \"required\", \"total\", \"failed\", \"fatallyfailed\" },\n\t\t\t\t\t\t\tnew String[] { Integer.toString(fr.fetchedBlocks), Integer.toString(fr.requiredBlocks), Integer.toString(fr.totalBlocks), Integer.toString(fr.failedBlocks), Integer.toString(fr.fatallyFailedBlocks) }));\n\t\t\t\t}\n\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"timeElapsedLabel\")+\" \"+TimeUtil.formatTime(System.currentTimeMillis() - fr.timeStarted));\n\t\t\t\tlong eta = fr.eta;\n\t\t\t\tif(eta > 0)\n\t\t\t\t\tinfoboxContent.addChild(\"br\", \"ETA: \"+TimeUtil.formatTime(eta));\n\t\t\t\tif(fr.goneToNetwork)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressDownloading\"));\n\t\t\t\telse\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressCheckingStore\"));\n\t\t\t\tif(!fr.finalizedBlocks)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressNotFinalized\"));\n\t\t\t\t\n\t\t\t\tHTMLNode table = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tHTMLNode progressCell = table.addChild(\"tr\").addChild(\"td\", \"class\", \"request-progress\");\n\t\t\t\tif(fr.totalBlocks <= 0)\n\t\t\t\t\tprogressCell.addChild(\"#\", L10n.getString(\"QueueToadlet.unknown\"));\n\t\t\t\telse {\n\t\t\t\t\tint total = fr.requiredBlocks;\n\t\t\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\t\t\tHTMLNode progressBar = progressCell.addChild(\"div\", \"class\", \"progressbar\");\n\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\t\t\n\t\t\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageOptions\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\t\tHTMLNode ul = infoboxContent.addChild(\"ul\");\n\t\t\t\tul.addChild(\"li\").addChild(\"p\", l10n(\"progressOptionZero\"));\n\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\n\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\toptionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\n\t\t\t\t}\n\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\tMultiValueTable<String, String> retHeaders = new MultiValueTable<String, String>();\n\t\t\t\t//retHeaders.put(\"Refresh\", \"2; url=\"+location);\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", retHeaders, pageNode.generate());\n\t\t\t\tfr.close();\n\t\t\t\tfetch.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tif(data == null && fe == null) {\n\t\t\tFetchResult result = fetch(key, maxSize, new RequestClient() {\n\t\t\t\tpublic boolean persistent() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic void removeFrom(ObjectContainer container) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t} }); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tmimeType = result.getMimeType();\n\t\t\t} else if(fe != null) throw fe;\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, maxSize != MAX_LENGTH ? \"&max-size=\"+maxSize : \"\", referer, true, ctx, core, fr != null);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg,\n\t\t\t\t\tgetLink(e.newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionTable = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\tHTMLNode optionForm = option.addChild(\"td\").addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] {'/' + key.toString(), \"get\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplayButton\") });\n\t\t\t\t\toption.addChild(\"td\", l10n(\"fetchLargeFileAnywayAndDisplay\"));\n\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\n\t\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\t\t\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\t\tL10n.addL10nSubstitution(option.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\toptionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE || e.mode == FetchException.NOT_ENOUGH_PATH_COMPONENTS) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString() + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\")});\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\t\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\")});\n\t\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(fr == null && data != null) data.free();\n\t\t\tif(fr != null) fr.close();\n\t\t}\n\t}","id":615,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString requestedMimeType = httprequest.getParam(\"type\");\n\t\t\t\tlong maxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\t\tString location = getLink(newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\tstrm.close();\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/feed/\") || ks.equals(\"/feed\")) {\n\t\t\t//TODO Better way to find the host. Find if https is used?\n\t\t\tString host = ctx.getHeaders().get(\"host\");\n\t\t\tString atom = core.alerts.getAtom(\"http://\" + host);\n\t\t\tbyte[] buf = atom.getBytes(\"UTF-8\");\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"application/atom+xml\", buf.length);\n\t\t\tctx.writeData(buf, 0, buf.length);\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/queue/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/downloads/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/config/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/config/node\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\t//first check of httprange before get\n\t\t// only valid number format is checked here\n\t\tString rangeStr = ctx.getHeaders().get(\"range\");\n\t\tif (rangeStr != null) {\n\t\t\ttry {\n\t\t\t\tparseRange(rangeStr);\n\t\t\t} catch (HTTPRangeException e) {\n\t\t\t\tLogger.normal(this, \"Invalid Range Header: \"+rangeStr, e);\n\t\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\n\t\tBucket data = null;\n\t\tString mimeType = null;\n\t\tString referer = sanitizeReferer(ctx);\n\t\tFetchException fe = null;\n\t\t\n\n\t\tMultiValueTable<String,String> headers = ctx.getHeaders();\n\t\tString ua = headers.get(\"user-agent\");\n\t\tString accept = headers.get(\"accept\");\n\t\tFProxyFetchResult fr = null;\n\t\tif(logMINOR) Logger.minor(this, \"UA = \"+ua+\" accept = \"+accept);\n\t\tif(isBrowser(ua) && !ctx.disableProgressPage() && (accept == null || accept.indexOf(\"text/html\") > -1) && !httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tFProxyFetchWaiter fetch = null;\n\t\t\ttry {\n\t\t\t\tfetch = fetchTracker.makeFetcher(key, maxSize);\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfe = fr.failed;\n\t\t\t}\n\t\t\tif(fetch != null)\n\t\t\twhile(true) {\n\t\t\tfr = fetch.getResult();\n\t\t\tif(fr.hasData()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\t\t\tdata = fr.data;\n\t\t\t\tmimeType = fr.mimeType;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else if(fr.failed != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Request failed\");\n\t\t\t\tfe = fr.failed;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Still in progress\");\n\t\t\t\t// Still in progress\n\t\t\t\tboolean isJsEnabled=ctx.getContainer().isFProxyJavascriptEnabled() && ua != null && !ua.contains(\"AppleWebKit/\");\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fetchingPageTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tString location = getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\tHTMLNode headNode=page.headNode;\n\t\t\t\tif(isJsEnabled){\n\t\t\t\t\t//If the user has enabled javascript, we add a <noscript> http refresh(if he has disabled it in the browser)\n\t\t\t\t\t//And the script file\n\t\t\t\t\theadNode.addChild(\"noscript\").addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t\tHTMLNode scriptNode=headNode.addChild(\"script\",\"//abc\");\n\t\t\t\t\tscriptNode.addAttribute(\"type\", \"text/javascript\");\n\t\t\t\t\tscriptNode.addAttribute(\"src\", \"/static/js/progresspage.js\");\n\t\t\t\t}else{\n\t\t\t\t\t//If he disabled it, we just put the http refresh meta, without the noscript\n\t\t\t\t\theadNode.addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageBox\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addAttribute(\"id\", \"infoContent\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"filenameLabel\")+ \" \");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/\"+key.toString(false, false), key.getPreferredFilename());\n\t\t\t\tif(fr.mimeType != null) infoboxContent.addChild(\"br\", l10n(\"contentTypeLabel\")+\" \"+fr.mimeType);\n\t\t\t\tif(fr.size > 0) infoboxContent.addChild(\"br\", \"Size: \"+SizeUtil.formatSize(fr.size));\n\t\t\t\tif(core.isAdvancedModeEnabled()) {\n\t\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"blocksDetail\", \n\t\t\t\t\t\t\tnew String[] { \"fetched\", \"required\", \"total\", \"failed\", \"fatallyfailed\" },\n\t\t\t\t\t\t\tnew String[] { Integer.toString(fr.fetchedBlocks), Integer.toString(fr.requiredBlocks), Integer.toString(fr.totalBlocks), Integer.toString(fr.failedBlocks), Integer.toString(fr.fatallyFailedBlocks) }));\n\t\t\t\t}\n\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"timeElapsedLabel\")+\" \"+TimeUtil.formatTime(System.currentTimeMillis() - fr.timeStarted));\n\t\t\t\tlong eta = fr.eta;\n\t\t\t\tif(eta > 0)\n\t\t\t\t\tinfoboxContent.addChild(\"br\", \"ETA: \"+TimeUtil.formatTime(eta));\n\t\t\t\tif(fr.goneToNetwork)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressDownloading\"));\n\t\t\t\telse\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressCheckingStore\"));\n\t\t\t\tif(!fr.finalizedBlocks)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressNotFinalized\"));\n\t\t\t\t\n\t\t\t\tHTMLNode table = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tHTMLNode progressCell = table.addChild(\"tr\").addChild(\"td\", \"class\", \"request-progress\");\n\t\t\t\tif(fr.totalBlocks <= 0)\n\t\t\t\t\tprogressCell.addChild(\"#\", L10n.getString(\"QueueToadlet.unknown\"));\n\t\t\t\telse {\n\t\t\t\t\tint total = fr.requiredBlocks;\n\t\t\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\t\t\tHTMLNode progressBar = progressCell.addChild(\"div\", \"class\", \"progressbar\");\n\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\t\t\n\t\t\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageOptions\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\t\tHTMLNode ul = infoboxContent.addChild(\"ul\");\n\t\t\t\tul.addChild(\"li\").addChild(\"p\", l10n(\"progressOptionZero\"));\n\t\t\t\t\n\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\t\n\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\n\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\n\t\t\t\t}\n\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\tMultiValueTable<String, String> retHeaders = new MultiValueTable<String, String>();\n\t\t\t\t//retHeaders.put(\"Refresh\", \"2; url=\"+location);\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", retHeaders, pageNode.generate());\n\t\t\t\tfr.close();\n\t\t\t\tfetch.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tif(data == null && fe == null) {\n\t\t\tFetchResult result = fetch(key, maxSize, new RequestClient() {\n\t\t\t\tpublic boolean persistent() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic void removeFrom(ObjectContainer container) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t} }); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tmimeType = result.getMimeType();\n\t\t\t} else if(fe != null) throw fe;\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, maxSize != MAX_LENGTH ? \"&max-size=\"+maxSize : \"\", referer, true, ctx, core, fr != null);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg,\n\t\t\t\t\tgetLink(e.newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionTable = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\tHTMLNode optionForm = option.addChild(\"td\").addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] {'/' + key.toString(), \"get\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplayButton\") });\n\t\t\t\t\toption.addChild(\"td\", l10n(\"fetchLargeFileAnywayAndDisplay\"));\n\t\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\n\t\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\t\t\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\t\tL10n.addL10nSubstitution(option.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\toptionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE || e.mode == FetchException.NOT_ENOUGH_PATH_COMPONENTS) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString() + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\t\t\n\t\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\")});\n\t\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\t\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\")});\n\t\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(fr == null && data != null) data.free();\n\t\t\tif(fr != null) fr.close();\n\t\t}\n\t}","commit_id":"da2dd05f88fe1aef52c7e8e0b1514d1420651645","url":"https://github.com/freenet/fred"},{"original_method":"private HTMLNode createBulkDownloadForm(ToadletContext ctx, PageMaker pageMaker) {\n\t\tInfoboxNode infobox = pageMaker.getInfobox(L10n.getString(\"QueueToadlet.downloadFiles\"));\n\t\tHTMLNode downloadBox = infobox.outer;\n\t\tHTMLNode downloadBoxContent = infobox.content;\n\t\tHTMLNode downloadForm = ctx.addFormChild(downloadBoxContent, path(), \"queueDownloadForm\");\n\t\tdownloadForm.addChild(\"#\", L10n.getString(\"QueueToadlet.downloadFilesInstructions\"));\n\t\tdownloadForm.addChild(\"br\");\n\t\tdownloadForm.addChild(\"textarea\", new String[] { \"id\", \"name\", \"cols\", \"rows\" }, new String[] { \"bulkDownloads\", \"bulkDownloads\", \"120\", \"8\" });\n\t\tdownloadForm.addChild(\"br\");\n\t\tdownloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"insert\", L10n.getString(\"QueueToadlet.download\") });\n\t\tif(core.node.securityLevels.getPhysicalThreatLevel() == PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\tdownloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"target\", \"disk\" });\n\t\t} else {\n\t\t\tHTMLNode select = downloadForm.addChild(\"select\", \"name\", \"target\");\n\t\t\tselect.addChild(\"option\", \"value\", \"disk\", l10n(\"bulkDownloadSelectOptionDisk\"));\n\t\t\tselect.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"direct\", \"true\" }, l10n(\"bulkDownloadSelectOptionDirect\"));\n\t\t}\n\t\treturn downloadBox;\n\t}","id":616,"modified_method":"private HTMLNode createBulkDownloadForm(ToadletContext ctx, PageMaker pageMaker) {\n\t\tInfoboxNode infobox = pageMaker.getInfobox(L10n.getString(\"QueueToadlet.downloadFiles\"));\n\t\tHTMLNode downloadBox = infobox.outer;\n\t\tHTMLNode downloadBoxContent = infobox.content;\n\t\tHTMLNode downloadForm = ctx.addFormChild(downloadBoxContent, path(), \"queueDownloadForm\");\n\t\tdownloadForm.addChild(\"#\", L10n.getString(\"QueueToadlet.downloadFilesInstructions\"));\n\t\tdownloadForm.addChild(\"br\");\n\t\tdownloadForm.addChild(\"textarea\", new String[] { \"id\", \"name\", \"cols\", \"rows\" }, new String[] { \"bulkDownloads\", \"bulkDownloads\", \"120\", \"8\" });\n\t\tdownloadForm.addChild(\"br\");\n\t\tdownloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"insert\", L10n.getString(\"QueueToadlet.download\") });\n\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\tif(threatLevel == PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\tdownloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"target\", \"disk\" });\n\t\t} else if(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM) {\n\t\t\tdownloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"target\", \"direct\" });\n\t\t} else {\n\t\t\tHTMLNode select = downloadForm.addChild(\"select\", \"name\", \"target\");\n\t\t\tselect.addChild(\"option\", \"value\", \"disk\", l10n(\"bulkDownloadSelectOptionDisk\"));\n\t\t\tselect.addChild(\"option\", new String[] { \"value\", \"selected\" }, new String[] { \"direct\", \"true\" }, l10n(\"bulkDownloadSelectOptionDirect\"));\n\t\t}\n\t\treturn downloadBox;\n\t}","commit_id":"da2dd05f88fe1aef52c7e8e0b1514d1420651645","url":"https://github.com/freenet/fred"},{"original_method":"public String toString()\n    {\n        return (schemeMetaInfo == null ? \"\" : schemeMetaInfo + \":\") + uri.toASCIIString();\n    }","id":617,"modified_method":"public String toString()\n    {\n        return uri.toASCIIString();\n        //return (schemeMetaInfo == null ? \"\" : schemeMetaInfo + \":\") + uri.toASCIIString();\n    }","commit_id":"eb2f1613429d928462f4f07f087d0668d8a83d99","url":"https://github.com/mulesoft/mule"},{"original_method":"public String toString()\n    {\n        return uri.toASCIIString();\n    }","id":618,"modified_method":"public String toString()\n    {\n        return (schemeMetaInfo == null ? \"\" : schemeMetaInfo + \":\") + uri.toASCIIString();\n    }","commit_id":"d216f6236f94962b5e3e43b2e106bd0825c740a4","url":"https://github.com/mulesoft/mule"},{"original_method":"public String toString()\n    {\n        return uri.toASCIIString();\n    }","id":619,"modified_method":"public String toString()\n    {\n        return (schemeMetaInfo == null ? \"\" : schemeMetaInfo + \":\") + uri.toASCIIString();\n    }","commit_id":"81d3fa2852ccdbd74960f94b3e158660b75a19eb","url":"https://github.com/mulesoft/mule"},{"original_method":"public String toString()\n    {\n        return (schemeMetaInfo == null ? \"\" : schemeMetaInfo + \":\") + uri.toASCIIString();\n    }","id":620,"modified_method":"public String toString()\n    {\n        return uri.toASCIIString();\n        //return (schemeMetaInfo == null ? \"\" : schemeMetaInfo + \":\") + uri.toASCIIString();\n    }","commit_id":"fc05c6b150d8bfc6f696e1bbd93ce90ca28757cd","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif ((!isChecked(user) &&\n\t\t\t\t!OrganizationMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId(),\n\t\t\t\t\t_role.getRoleId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tOrganizationMembershipPolicyUtil.isRoleProtected(\n\t\t\t\t\tpermissionChecker, user.getUserId(),\n\t\t\t\t\t_organization.getOrganizationId(), _role.getRoleId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tOrganizationMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId(),\n\t\t\t\t\t_role.getRoleId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":621,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif (isChecked(user)) {\n\t\t\t\tif (OrganizationMembershipPolicyUtil.isRoleProtected(\n\t\t\t\t\t\tpermissionChecker, user.getUserId(),\n\t\t\t\t\t\t_organization.getOrganizationId(), _role.getRoleId()) ||\n\t\t\t\t\tOrganizationMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId(),\n\t\t\t\t\t\t_role.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!OrganizationMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId(),\n\t\t\t\t\t\t_role.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif ((!isChecked(user) &&\n\t\t\t\t!SiteMembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\tuser.getUserId(), _group.getGroupId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tSiteMembershipPolicyUtil.isMembershipProtected(\n\t\t\t\t\tpermissionChecker, user.getUserId(),\n\t\t\t\t\t_group.getGroupId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\t\tSiteMembershipPolicyUtil.isMembershipRequired(\n\t\t\t\t\t\tuser.getUserId(), _group.getGroupId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":622,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif (isChecked(user)) {\n\t\t\t\tif (SiteMembershipPolicyUtil.isMembershipProtected(\n\t\t\t\t\t\tpermissionChecker, user.getUserId(),\n\t\t\t\t\t\t_group.getGroupId()) ||\n\t\t\t\t\tSiteMembershipPolicyUtil.isMembershipRequired(\n\t\t\t\t\t\tuser.getUserId(), _group.getGroupId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!SiteMembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\t\tuser.getUserId(), _group.getGroupId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tRole role = (Role)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif ((!isChecked(role) &&\n\t\t\t\t!SiteMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\t_user.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId())) ||\n\t\t\t\t(isChecked(role) &&\n\t\t\t\tSiteMembershipPolicyUtil.isRoleProtected(\n\t\t\t\t\tpermissionChecker, _user.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId())) ||\n\t\t\t\t(isChecked(role) &&\n\t\t\t\tSiteMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\t_user.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":623,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tRole role = (Role)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif (isChecked(role)) {\n\t\t\t\tif (SiteMembershipPolicyUtil.isRoleProtected(\n\t\t\t\t\t\tpermissionChecker, _user.getUserId(),\n\t\t\t\t\t\t_group.getGroupId(), role.getRoleId()) ||\n\t\t\t\t\tSiteMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\t\t_user.getUserId(), _group.getGroupId(),\n\t\t\t\t\t\trole.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!SiteMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\t\t_user.getUserId(), _group.getGroupId(),\n\t\t\t\t\t\trole.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tif ((!isChecked(user) &&\n\t\t\t\t!SiteMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\tuser.getUserId(), _group.getGroupId(),\n\t\t\t\t\t_role.getRoleId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\t\tSiteMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\t\tuser.getUserId(), _group.getGroupId(),\n\t\t\t\t\t\t_role.getRoleId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":624,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tif (isChecked(user)) {\n\t\t\t\tif (SiteMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\t\tuser.getUserId(), _group.getGroupId(),\n\t\t\t\t\t\t_role.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!SiteMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\t\tuser.getUserId(), _group.getGroupId(),\n\t\t\t\t\t\t_role.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tif (!PropsValues.ORGANIZATIONS_ASSIGNMENT_STRICT) {\n\t\t\treturn false;\n\t\t}\n\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif ((!isChecked(user) &&\n\t\t\t\t!OrganizationMembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tOrganizationMembershipPolicyUtil.isMembershipProtected(\n\t\t\t\t\tpermissionChecker, user.getUserId(),\n\t\t\t\t\t_organization.getOrganizationId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tOrganizationMembershipPolicyUtil.isMembershipRequired(\n\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn !UserPermissionUtil.contains(\n\t\t\t\tpermissionChecker, user.getUserId(), ActionKeys.UPDATE);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":625,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tif (!PropsValues.ORGANIZATIONS_ASSIGNMENT_STRICT) {\n\t\t\treturn false;\n\t\t}\n\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\tif (isChecked(user)) {\n\t\t\t\tif (OrganizationMembershipPolicyUtil.isMembershipProtected(\n\t\t\t\t\t\tpermissionChecker, user.getUserId(),\n\t\t\t\t\t\t_organization.getOrganizationId()) ||\n\t\t\t\t\tOrganizationMembershipPolicyUtil.isMembershipRequired(\n\t\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!OrganizationMembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\t\tuser.getUserId(), _organization.getOrganizationId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn !UserPermissionUtil.contains(\n\t\t\t\tpermissionChecker, user.getUserId(), ActionKeys.UPDATE);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tif ((!isChecked(user) &&\n\t\t\t\t!RoleMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\tuser.getUserId(), _role.getRoleId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tRoleMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\tuser.getUserId(), _role.getRoleId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":626,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tif (isChecked(user)) {\n\t\t\t\tif (RoleMembershipPolicyUtil.isRoleRequired(\n\t\t\t\t\t\tuser.getUserId(), _role.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!RoleMembershipPolicyUtil.isRoleAllowed(\n\t\t\t\t\t\tuser.getUserId(), _role.getRoleId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Updates the user with additional parameters.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  oldPassword the user's old password\n\t * @param  newPassword1 the user's new password (optionally\n\t *         <code>null<\/code>)\n\t * @param  newPassword2 the user's new password confirmation (optionally\n\t *         <code>null<\/code>)\n\t * @param  passwordReset whether the user should be asked to reset their\n\t *         password the next time they login\n\t * @param  reminderQueryQuestion the user's new password reset question\n\t * @param  reminderQueryAnswer the user's new password reset answer\n\t * @param  screenName the user's new screen name\n\t * @param  emailAddress the user's new email address\n\t * @param  facebookId the user's new Facebook ID\n\t * @param  openId the user's new OpenID\n\t * @param  languageId the user's new language ID\n\t * @param  timeZoneId the user's new time zone ID\n\t * @param  greeting the user's new greeting\n\t * @param  comments the user's new comments\n\t * @param  firstName the user's new first name\n\t * @param  middleName the user's new middle name\n\t * @param  lastName the user's new last name\n\t * @param  prefixId the user's new name prefix ID\n\t * @param  suffixId the user's new name suffix ID\n\t * @param  male whether user is male\n\t * @param  birthdayMonth the user's new birthday month (0-based, meaning 0\n\t *         for January)\n\t * @param  birthdayDay the user's new birthday day\n\t * @param  birthdayYear the user's birthday year\n\t * @param  smsSn the user's new SMS screen name\n\t * @param  aimSn the user's new AIM screen name\n\t * @param  facebookSn the user's new Facebook screen name\n\t * @param  icqSn the user's new ICQ screen name\n\t * @param  jabberSn the user's new Jabber screen name\n\t * @param  msnSn the user's new MSN screen name\n\t * @param  mySpaceSn the user's new MySpace screen name\n\t * @param  skypeSn the user's new Skype screen name\n\t * @param  twitterSn the user's new Twitter screen name\n\t * @param  ymSn the user's new Yahoo! Messenger screen name\n\t * @param  jobTitle the user's new job title\n\t * @param  groupIds the primary keys of the user's groups\n\t * @param  organizationIds the primary keys of the user's organizations\n\t * @param  roleIds the primary keys of the user's roles\n\t * @param  userGroupRoles the user user's group roles\n\t * @param  userGroupIds the primary keys of the user's user groups\n\t * @param  addresses the user's addresses\n\t * @param  emailAddresses the user's email addresses\n\t * @param  phones the user's phone numbers\n\t * @param  websites the user's websites\n\t * @param  announcementsDelivers the announcements deliveries\n\t * @param  serviceContext the service context to be applied (optionally\n\t *         <code>null<\/code>). Can set the UUID (with the <code>uuid<\/code>\n\t *         attribute), asset category IDs, asset tag names, and expando\n\t *         bridge attributes for the user.\n\t * @return the user\n\t * @throws PortalException if a user with the primary key could not be\n\t *         found, if the new information was invalid, if the current user\n\t *         did not have permission to update the user, or if the operation\n\t *         was not allowed by the membership policy\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic User updateUser(\n\t\t\tlong userId, String oldPassword, String newPassword1,\n\t\t\tString newPassword2, boolean passwordReset,\n\t\t\tString reminderQueryQuestion, String reminderQueryAnswer,\n\t\t\tString screenName, String emailAddress, long facebookId,\n\t\t\tString openId, String languageId, String timeZoneId,\n\t\t\tString greeting, String comments, String firstName,\n\t\t\tString middleName, String lastName, int prefixId, int suffixId,\n\t\t\tboolean male, int birthdayMonth, int birthdayDay, int birthdayYear,\n\t\t\tString smsSn, String aimSn, String facebookSn, String icqSn,\n\t\t\tString jabberSn, String msnSn, String mySpaceSn, String skypeSn,\n\t\t\tString twitterSn, String ymSn, String jobTitle, long[] groupIds,\n\t\t\tlong[] organizationIds, long[] roleIds,\n\t\t\tList<UserGroupRole> userGroupRoles, long[] userGroupIds,\n\t\t\tList<Address> addresses, List<EmailAddress> emailAddresses,\n\t\t\tList<Phone> phones, List<Website> websites,\n\t\t\tList<AnnouncementsDelivery> announcementsDelivers,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUserPermissionUtil.check(\n\t\t\tgetPermissionChecker(), userId, organizationIds, ActionKeys.UPDATE);\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (addresses != null) {\n\t\t\tUsersAdminUtil.updateAddresses(\n\t\t\t\tContact.class.getName(), user.getContactId(), addresses);\n\t\t}\n\n\t\tif (emailAddresses != null) {\n\t\t\tUsersAdminUtil.updateEmailAddresses(\n\t\t\t\tContact.class.getName(), user.getContactId(), emailAddresses);\n\t\t}\n\n\t\tif (phones != null) {\n\t\t\tUsersAdminUtil.updatePhones(\n\t\t\t\tContact.class.getName(), user.getContactId(), phones);\n\t\t}\n\n\t\tif (websites != null) {\n\t\t\tUsersAdminUtil.updateWebsites(\n\t\t\t\tContact.class.getName(), user.getContactId(), websites);\n\t\t}\n\n\t\tif (announcementsDelivers != null) {\n\t\t\tupdateAnnouncementsDeliveries(\n\t\t\t\tuser.getUserId(), announcementsDelivers);\n\t\t}\n\n\t\tlong curUserId = getUserId();\n\n\t\tif (curUserId == userId) {\n\t\t\tscreenName = screenName.trim().toLowerCase();\n\n\t\t\tif (!screenName.equalsIgnoreCase(user.getScreenName())) {\n\t\t\t\tvalidateScreenName(user, screenName);\n\t\t\t}\n\n\t\t\temailAddress = emailAddress.trim().toLowerCase();\n\n\t\t\tif (!emailAddress.equalsIgnoreCase(user.getEmailAddress())) {\n\t\t\t\tvalidateEmailAddress(user, emailAddress);\n\t\t\t}\n\t\t}\n\n\t\t// Groups Membership Policy\n\n\t\tlong[] oldGroupIds = user.getGroupIds();\n\n\t\tList<Long> addGroupIds = new ArrayList<Long>();\n\t\tList<Long> removeGroupIds = ListUtil.toList(oldGroupIds);\n\n\t\tif (groupIds != null) {\n\t\t\tgroupIds = checkGroups(userId, groupIds);\n\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tif (ArrayUtil.contains(oldGroupIds, groupId)) {\n\t\t\t\t\tremoveGroupIds.remove(groupId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddGroupIds.add(groupId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addGroupIds.isEmpty() || !removeGroupIds.isEmpty()) {\n\t\t\t\tSiteMembershipPolicyUtil.checkMembership(\n\t\t\t\t\tnew long[] {userId}, ArrayUtil.toLongArray(addGroupIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeGroupIds));\n\t\t\t}\n\t\t}\n\n\t\t// Organizations Membership Policy\n\n\t\tlong[] oldOrganizationIds = user.getOrganizationIds();\n\n\t\tList<Long> addOrganizationIds = new ArrayList<Long>();\n\t\tList<Long> removeOrganizationIds = ListUtil.toList(oldOrganizationIds);\n\n\t\tif (organizationIds != null) {\n\t\t\torganizationIds = checkOrganizations(userId, organizationIds);\n\n\t\t\tfor (long organizationId : organizationIds) {\n\t\t\t\tif (ArrayUtil.contains(oldOrganizationIds, organizationId)) {\n\t\t\t\t\tremoveOrganizationIds.remove(organizationId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddOrganizationIds.add(organizationId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addOrganizationIds.isEmpty() ||\n\t\t\t\t!removeOrganizationIds.isEmpty()) {\n\n\t\t\t\tOrganizationMembershipPolicyUtil.checkMembership(\n\t\t\t\t\tnew long[] {userId},\n\t\t\t\t\tArrayUtil.toLongArray(addOrganizationIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeOrganizationIds));\n\t\t\t}\n\t\t}\n\n\t\t// Roles Membership Policy\n\n\t\tlong[] oldRoleIds = user.getRoleIds();\n\n\t\tList<Long> addRoleIds = new ArrayList<Long>();\n\t\tList<Long> removeRoleIds = ListUtil.toList(oldRoleIds);\n\n\t\tif (roleIds != null) {\n\t\t\troleIds = checkRoles(userId, roleIds);\n\n\t\t\tfor (long roleId : roleIds) {\n\t\t\t\tif (ArrayUtil.contains(oldRoleIds, roleId)) {\n\t\t\t\t\tremoveRoleIds.remove(roleId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddRoleIds.add(roleId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addRoleIds.isEmpty() || !removeRoleIds.isEmpty()) {\n\t\t\t\tRoleMembershipPolicyUtil.checkRoles(\n\t\t\t\t\tnew long[] {userId}, ArrayUtil.toLongArray(addRoleIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeRoleIds));\n\t\t\t}\n\t\t}\n\n\t\tList<UserGroupRole> oldUserGroupRoles =\n\t\t\tuserGroupRoleLocalService.getUserGroupRoles(userId);\n\n\t\tList<UserGroupRole> oldSiteUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\t\tList<UserGroupRole> oldOrganizationUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\n\t\tfor (UserGroupRole oldUserGroupRole : oldUserGroupRoles) {\n\t\t\tRole role = oldUserGroupRole.getRole();\n\n\t\t\tif (role.getType() == RoleConstants.TYPE_SITE) {\n\t\t\t\toldSiteUserGroupRoles.add(oldUserGroupRole);\n\t\t\t}\n\t\t\telse if (role.getType() == RoleConstants.TYPE_ORGANIZATION) {\n\t\t\t\toldOrganizationUserGroupRoles.add(oldUserGroupRole);\n\t\t\t}\n\t\t}\n\n\t\tList<UserGroupRole> addSiteUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\t\tList<UserGroupRole> removeSiteUserGroupRoles = ListUtil.copy(\n\t\t\toldSiteUserGroupRoles);\n\t\tList<UserGroupRole> addOrganizationUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\t\tList<UserGroupRole> removeOrganizationUserGroupRoles = ListUtil.copy(\n\t\t\toldOrganizationUserGroupRoles);\n\n\t\tif (userGroupRoles != null) {\n\t\t\tuserGroupRoles = checkUserGroupRoles(userId, userGroupRoles);\n\n\t\t\tfor (UserGroupRole userGroupRole : userGroupRoles) {\n\t\t\t\tRole role = userGroupRole.getRole();\n\n\t\t\t\tif (role.getType() == RoleConstants.TYPE_SITE) {\n\t\t\t\t\tif (oldSiteUserGroupRoles.contains(userGroupRole)) {\n\t\t\t\t\t\tremoveSiteUserGroupRoles.remove(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taddSiteUserGroupRoles.add(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (role.getType() == RoleConstants.TYPE_ORGANIZATION) {\n\t\t\t\t\tif (oldOrganizationUserGroupRoles.contains(userGroupRole)) {\n\t\t\t\t\t\tremoveOrganizationUserGroupRoles.remove(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taddOrganizationUserGroupRoles.add(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addSiteUserGroupRoles.isEmpty() ||\n\t\t\t\t!removeSiteUserGroupRoles.isEmpty()) {\n\n\t\t\t\tSiteMembershipPolicyUtil.checkRoles(\n\t\t\t\t\taddSiteUserGroupRoles, removeSiteUserGroupRoles);\n\t\t\t}\n\n\t\t\tif (!addOrganizationUserGroupRoles.isEmpty() ||\n\t\t\t\t!removeOrganizationUserGroupRoles.isEmpty()) {\n\n\t\t\t\tOrganizationMembershipPolicyUtil.checkRoles(\n\t\t\t\t\taddOrganizationUserGroupRoles,\n\t\t\t\t\tremoveOrganizationUserGroupRoles);\n\t\t\t}\n\t\t}\n\n\t\t// User Groups Membership Policy\n\n\t\tlong[] oldUserGroupIds = user.getUserGroupIds();\n\n\t\tList<Long> addUserGroupIds = new ArrayList<Long>();\n\t\tList<Long> removeUserGroupIds = ListUtil.toList(oldUserGroupIds);\n\n\t\tif (userGroupIds != null) {\n\t\t\tuserGroupIds = checkUserGroupIds(userId, userGroupIds);\n\n\t\t\tfor (long userGroupId : userGroupIds) {\n\t\t\t\tif (ArrayUtil.contains(oldUserGroupIds, userGroupId)) {\n\t\t\t\t\tremoveUserGroupIds.remove(userGroupId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddUserGroupIds.add(userGroupId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addUserGroupIds.isEmpty() || !removeUserGroupIds.isEmpty()) {\n\t\t\t\tUserGroupMembershipPolicyUtil.checkMembership(\n\t\t\t\t\tnew long[] {userId}, ArrayUtil.toLongArray(addUserGroupIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeUserGroupIds));\n\t\t\t}\n\t\t}\n\n\t\tuser = userLocalService.updateUser(\n\t\t\tuserId, oldPassword, newPassword1, newPassword2, passwordReset,\n\t\t\treminderQueryQuestion, reminderQueryAnswer, screenName,\n\t\t\temailAddress, facebookId, openId, languageId, timeZoneId, greeting,\n\t\t\tcomments, firstName, middleName, lastName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, smsSn, aimSn, facebookSn,\n\t\t\ticqSn, jabberSn, msnSn, mySpaceSn, skypeSn, twitterSn, ymSn,\n\t\t\tjobTitle, groupIds, organizationIds, roleIds, userGroupRoles,\n\t\t\tuserGroupIds, serviceContext);\n\n\t\tif (!addGroupIds.isEmpty() || !removeGroupIds.isEmpty()) {\n\t\t\tSiteMembershipPolicyUtil.propagateMembership(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addGroupIds),\n\t\t\t\tArrayUtil.toLongArray(removeGroupIds));\n\t\t}\n\n\t\tif (!addOrganizationIds.isEmpty() || !removeOrganizationIds.isEmpty()) {\n\t\t\tOrganizationMembershipPolicyUtil.propagateMembership(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addOrganizationIds),\n\t\t\t\tArrayUtil.toLongArray(removeOrganizationIds));\n\t\t}\n\n\t\tif (!addRoleIds.isEmpty() || !removeRoleIds.isEmpty()) {\n\t\t\tRoleMembershipPolicyUtil.propagateRoles(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addRoleIds),\n\t\t\t\tArrayUtil.toLongArray(removeRoleIds));\n\t\t}\n\n\t\tif (!addSiteUserGroupRoles.isEmpty() ||\n\t\t\t!removeSiteUserGroupRoles.isEmpty()) {\n\n\t\t\tSiteMembershipPolicyUtil.propagateRoles(\n\t\t\t\taddSiteUserGroupRoles, removeSiteUserGroupRoles);\n\t\t}\n\n\t\tif (!addOrganizationUserGroupRoles.isEmpty() ||\n\t\t\t!removeOrganizationUserGroupRoles.isEmpty()) {\n\n\t\t\tOrganizationMembershipPolicyUtil.propagateRoles(\n\t\t\t\taddOrganizationUserGroupRoles,\n\t\t\t\tremoveOrganizationUserGroupRoles);\n\t\t}\n\n\t\tif (!addUserGroupIds.isEmpty() || !removeGroupIds.isEmpty()) {\n\t\t\tUserGroupMembershipPolicyUtil.propagateMembership(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addUserGroupIds),\n\t\t\t\tArrayUtil.toLongArray(removeUserGroupIds));\n\t\t}\n\n\t\treturn user;\n\t}","id":627,"modified_method":"/**\n\t * Updates the user with additional parameters.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  oldPassword the user's old password\n\t * @param  newPassword1 the user's new password (optionally\n\t *         <code>null<\/code>)\n\t * @param  newPassword2 the user's new password confirmation (optionally\n\t *         <code>null<\/code>)\n\t * @param  passwordReset whether the user should be asked to reset their\n\t *         password the next time they login\n\t * @param  reminderQueryQuestion the user's new password reset question\n\t * @param  reminderQueryAnswer the user's new password reset answer\n\t * @param  screenName the user's new screen name\n\t * @param  emailAddress the user's new email address\n\t * @param  facebookId the user's new Facebook ID\n\t * @param  openId the user's new OpenID\n\t * @param  languageId the user's new language ID\n\t * @param  timeZoneId the user's new time zone ID\n\t * @param  greeting the user's new greeting\n\t * @param  comments the user's new comments\n\t * @param  firstName the user's new first name\n\t * @param  middleName the user's new middle name\n\t * @param  lastName the user's new last name\n\t * @param  prefixId the user's new name prefix ID\n\t * @param  suffixId the user's new name suffix ID\n\t * @param  male whether user is male\n\t * @param  birthdayMonth the user's new birthday month (0-based, meaning 0\n\t *         for January)\n\t * @param  birthdayDay the user's new birthday day\n\t * @param  birthdayYear the user's birthday year\n\t * @param  smsSn the user's new SMS screen name\n\t * @param  aimSn the user's new AIM screen name\n\t * @param  facebookSn the user's new Facebook screen name\n\t * @param  icqSn the user's new ICQ screen name\n\t * @param  jabberSn the user's new Jabber screen name\n\t * @param  msnSn the user's new MSN screen name\n\t * @param  mySpaceSn the user's new MySpace screen name\n\t * @param  skypeSn the user's new Skype screen name\n\t * @param  twitterSn the user's new Twitter screen name\n\t * @param  ymSn the user's new Yahoo! Messenger screen name\n\t * @param  jobTitle the user's new job title\n\t * @param  groupIds the primary keys of the user's groups\n\t * @param  organizationIds the primary keys of the user's organizations\n\t * @param  roleIds the primary keys of the user's roles\n\t * @param  userGroupRoles the user user's group roles\n\t * @param  userGroupIds the primary keys of the user's user groups\n\t * @param  addresses the user's addresses\n\t * @param  emailAddresses the user's email addresses\n\t * @param  phones the user's phone numbers\n\t * @param  websites the user's websites\n\t * @param  announcementsDelivers the announcements deliveries\n\t * @param  serviceContext the service context to be applied (optionally\n\t *         <code>null<\/code>). Can set the UUID (with the <code>uuid<\/code>\n\t *         attribute), asset category IDs, asset tag names, and expando\n\t *         bridge attributes for the user.\n\t * @return the user\n\t * @throws PortalException if a user with the primary key could not be\n\t *         found, if the new information was invalid, if the current user\n\t *         did not have permission to update the user, or if the operation\n\t *         was not allowed by the membership policy\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic User updateUser(\n\t\t\tlong userId, String oldPassword, String newPassword1,\n\t\t\tString newPassword2, boolean passwordReset,\n\t\t\tString reminderQueryQuestion, String reminderQueryAnswer,\n\t\t\tString screenName, String emailAddress, long facebookId,\n\t\t\tString openId, String languageId, String timeZoneId,\n\t\t\tString greeting, String comments, String firstName,\n\t\t\tString middleName, String lastName, int prefixId, int suffixId,\n\t\t\tboolean male, int birthdayMonth, int birthdayDay, int birthdayYear,\n\t\t\tString smsSn, String aimSn, String facebookSn, String icqSn,\n\t\t\tString jabberSn, String msnSn, String mySpaceSn, String skypeSn,\n\t\t\tString twitterSn, String ymSn, String jobTitle, long[] groupIds,\n\t\t\tlong[] organizationIds, long[] roleIds,\n\t\t\tList<UserGroupRole> userGroupRoles, long[] userGroupIds,\n\t\t\tList<Address> addresses, List<EmailAddress> emailAddresses,\n\t\t\tList<Phone> phones, List<Website> websites,\n\t\t\tList<AnnouncementsDelivery> announcementsDelivers,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUserPermissionUtil.check(\n\t\t\tgetPermissionChecker(), userId, organizationIds, ActionKeys.UPDATE);\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (addresses != null) {\n\t\t\tUsersAdminUtil.updateAddresses(\n\t\t\t\tContact.class.getName(), user.getContactId(), addresses);\n\t\t}\n\n\t\tif (emailAddresses != null) {\n\t\t\tUsersAdminUtil.updateEmailAddresses(\n\t\t\t\tContact.class.getName(), user.getContactId(), emailAddresses);\n\t\t}\n\n\t\tif (phones != null) {\n\t\t\tUsersAdminUtil.updatePhones(\n\t\t\t\tContact.class.getName(), user.getContactId(), phones);\n\t\t}\n\n\t\tif (websites != null) {\n\t\t\tUsersAdminUtil.updateWebsites(\n\t\t\t\tContact.class.getName(), user.getContactId(), websites);\n\t\t}\n\n\t\tif (announcementsDelivers != null) {\n\t\t\tupdateAnnouncementsDeliveries(\n\t\t\t\tuser.getUserId(), announcementsDelivers);\n\t\t}\n\n\t\tlong curUserId = getUserId();\n\n\t\tif (curUserId == userId) {\n\t\t\tscreenName = screenName.trim().toLowerCase();\n\n\t\t\tif (!screenName.equalsIgnoreCase(user.getScreenName())) {\n\t\t\t\tvalidateScreenName(user, screenName);\n\t\t\t}\n\n\t\t\temailAddress = emailAddress.trim().toLowerCase();\n\n\t\t\tif (!emailAddress.equalsIgnoreCase(user.getEmailAddress())) {\n\t\t\t\tvalidateEmailAddress(user, emailAddress);\n\t\t\t}\n\t\t}\n\n\t\t// Group membership policy\n\n\t\tlong[] oldGroupIds = user.getGroupIds();\n\n\t\tList<Long> addGroupIds = new ArrayList<Long>();\n\t\tList<Long> removeGroupIds = ListUtil.toList(oldGroupIds);\n\n\t\tif (groupIds != null) {\n\t\t\tgroupIds = checkGroups(userId, groupIds);\n\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tif (ArrayUtil.contains(oldGroupIds, groupId)) {\n\t\t\t\t\tremoveGroupIds.remove(groupId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddGroupIds.add(groupId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addGroupIds.isEmpty() || !removeGroupIds.isEmpty()) {\n\t\t\t\tSiteMembershipPolicyUtil.checkMembership(\n\t\t\t\t\tnew long[] {userId}, ArrayUtil.toLongArray(addGroupIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeGroupIds));\n\t\t\t}\n\t\t}\n\n\t\t// Organization membership policy\n\n\t\tlong[] oldOrganizationIds = user.getOrganizationIds();\n\n\t\tList<Long> addOrganizationIds = new ArrayList<Long>();\n\t\tList<Long> removeOrganizationIds = ListUtil.toList(oldOrganizationIds);\n\n\t\tif (organizationIds != null) {\n\t\t\torganizationIds = checkOrganizations(userId, organizationIds);\n\n\t\t\tfor (long organizationId : organizationIds) {\n\t\t\t\tif (ArrayUtil.contains(oldOrganizationIds, organizationId)) {\n\t\t\t\t\tremoveOrganizationIds.remove(organizationId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddOrganizationIds.add(organizationId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addOrganizationIds.isEmpty() ||\n\t\t\t\t!removeOrganizationIds.isEmpty()) {\n\n\t\t\t\tOrganizationMembershipPolicyUtil.checkMembership(\n\t\t\t\t\tnew long[] {userId},\n\t\t\t\t\tArrayUtil.toLongArray(addOrganizationIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeOrganizationIds));\n\t\t\t}\n\t\t}\n\n\t\t// Role membership policy\n\n\t\tlong[] oldRoleIds = user.getRoleIds();\n\n\t\tList<Long> addRoleIds = new ArrayList<Long>();\n\t\tList<Long> removeRoleIds = ListUtil.toList(oldRoleIds);\n\n\t\tif (roleIds != null) {\n\t\t\troleIds = checkRoles(userId, roleIds);\n\n\t\t\tfor (long roleId : roleIds) {\n\t\t\t\tif (ArrayUtil.contains(oldRoleIds, roleId)) {\n\t\t\t\t\tremoveRoleIds.remove(roleId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddRoleIds.add(roleId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addRoleIds.isEmpty() || !removeRoleIds.isEmpty()) {\n\t\t\t\tRoleMembershipPolicyUtil.checkRoles(\n\t\t\t\t\tnew long[] {userId}, ArrayUtil.toLongArray(addRoleIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeRoleIds));\n\t\t\t}\n\t\t}\n\n\t\tList<UserGroupRole> oldOrganizationUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\t\tList<UserGroupRole> oldSiteUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\n\t\tList<UserGroupRole> oldUserGroupRoles =\n\t\t\tuserGroupRolePersistence.findByUserId(userId);\n\n\t\tfor (UserGroupRole oldUserGroupRole : oldUserGroupRoles) {\n\t\t\tRole role = oldUserGroupRole.getRole();\n\n\t\t\tif (role.getType() == RoleConstants.TYPE_ORGANIZATION) {\n\t\t\t\toldOrganizationUserGroupRoles.add(oldUserGroupRole);\n\t\t\t}\n\t\t\telse if (role.getType() == RoleConstants.TYPE_SITE) {\n\t\t\t\toldSiteUserGroupRoles.add(oldUserGroupRole);\n\t\t\t}\n\t\t}\n\n\t\tList<UserGroupRole> addOrganizationUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\t\tList<UserGroupRole> removeOrganizationUserGroupRoles = ListUtil.copy(\n\t\t\toldOrganizationUserGroupRoles);\n\t\tList<UserGroupRole> addSiteUserGroupRoles =\n\t\t\tnew ArrayList<UserGroupRole>();\n\t\tList<UserGroupRole> removeSiteUserGroupRoles = ListUtil.copy(\n\t\t\toldSiteUserGroupRoles);\n\n\t\tif (userGroupRoles != null) {\n\t\t\tuserGroupRoles = checkUserGroupRoles(userId, userGroupRoles);\n\n\t\t\tfor (UserGroupRole userGroupRole : userGroupRoles) {\n\t\t\t\tRole role = userGroupRole.getRole();\n\n\t\t\t\tif (role.getType() == RoleConstants.TYPE_ORGANIZATION) {\n\t\t\t\t\tif (oldOrganizationUserGroupRoles.contains(userGroupRole)) {\n\t\t\t\t\t\tremoveOrganizationUserGroupRoles.remove(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taddOrganizationUserGroupRoles.add(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (role.getType() == RoleConstants.TYPE_SITE) {\n\t\t\t\t\tif (oldSiteUserGroupRoles.contains(userGroupRole)) {\n\t\t\t\t\t\tremoveSiteUserGroupRoles.remove(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taddSiteUserGroupRoles.add(userGroupRole);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addOrganizationUserGroupRoles.isEmpty() ||\n\t\t\t\t!removeOrganizationUserGroupRoles.isEmpty()) {\n\n\t\t\t\tOrganizationMembershipPolicyUtil.checkRoles(\n\t\t\t\t\taddOrganizationUserGroupRoles,\n\t\t\t\t\tremoveOrganizationUserGroupRoles);\n\t\t\t}\n\n\t\t\tif (!addSiteUserGroupRoles.isEmpty() ||\n\t\t\t\t!removeSiteUserGroupRoles.isEmpty()) {\n\n\t\t\t\tSiteMembershipPolicyUtil.checkRoles(\n\t\t\t\t\taddSiteUserGroupRoles, removeSiteUserGroupRoles);\n\t\t\t}\n\t\t}\n\n\t\t// User group membership policy\n\n\t\tlong[] oldUserGroupIds = user.getUserGroupIds();\n\n\t\tList<Long> addUserGroupIds = new ArrayList<Long>();\n\t\tList<Long> removeUserGroupIds = ListUtil.toList(oldUserGroupIds);\n\n\t\tif (userGroupIds != null) {\n\t\t\tuserGroupIds = checkUserGroupIds(userId, userGroupIds);\n\n\t\t\tfor (long userGroupId : userGroupIds) {\n\t\t\t\tif (ArrayUtil.contains(oldUserGroupIds, userGroupId)) {\n\t\t\t\t\tremoveUserGroupIds.remove(userGroupId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddUserGroupIds.add(userGroupId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!addUserGroupIds.isEmpty() || !removeUserGroupIds.isEmpty()) {\n\t\t\t\tUserGroupMembershipPolicyUtil.checkMembership(\n\t\t\t\t\tnew long[] {userId}, ArrayUtil.toLongArray(addUserGroupIds),\n\t\t\t\t\tArrayUtil.toLongArray(removeUserGroupIds));\n\t\t\t}\n\t\t}\n\n\t\tuser = userLocalService.updateUser(\n\t\t\tuserId, oldPassword, newPassword1, newPassword2, passwordReset,\n\t\t\treminderQueryQuestion, reminderQueryAnswer, screenName,\n\t\t\temailAddress, facebookId, openId, languageId, timeZoneId, greeting,\n\t\t\tcomments, firstName, middleName, lastName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, smsSn, aimSn, facebookSn,\n\t\t\ticqSn, jabberSn, msnSn, mySpaceSn, skypeSn, twitterSn, ymSn,\n\t\t\tjobTitle, groupIds, organizationIds, roleIds, userGroupRoles,\n\t\t\tuserGroupIds, serviceContext);\n\n\t\tif (!addGroupIds.isEmpty() || !removeGroupIds.isEmpty()) {\n\t\t\tSiteMembershipPolicyUtil.propagateMembership(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addGroupIds),\n\t\t\t\tArrayUtil.toLongArray(removeGroupIds));\n\t\t}\n\n\t\tif (!addOrganizationIds.isEmpty() || !removeOrganizationIds.isEmpty()) {\n\t\t\tOrganizationMembershipPolicyUtil.propagateMembership(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addOrganizationIds),\n\t\t\t\tArrayUtil.toLongArray(removeOrganizationIds));\n\t\t}\n\n\t\tif (!addRoleIds.isEmpty() || !removeRoleIds.isEmpty()) {\n\t\t\tRoleMembershipPolicyUtil.propagateRoles(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addRoleIds),\n\t\t\t\tArrayUtil.toLongArray(removeRoleIds));\n\t\t}\n\n\t\tif (!addSiteUserGroupRoles.isEmpty() ||\n\t\t\t!removeSiteUserGroupRoles.isEmpty()) {\n\n\t\t\tSiteMembershipPolicyUtil.propagateRoles(\n\t\t\t\taddSiteUserGroupRoles, removeSiteUserGroupRoles);\n\t\t}\n\n\t\tif (!addOrganizationUserGroupRoles.isEmpty() ||\n\t\t\t!removeOrganizationUserGroupRoles.isEmpty()) {\n\n\t\t\tOrganizationMembershipPolicyUtil.propagateRoles(\n\t\t\t\taddOrganizationUserGroupRoles,\n\t\t\t\tremoveOrganizationUserGroupRoles);\n\t\t}\n\n\t\tif (!addUserGroupIds.isEmpty() || !removeGroupIds.isEmpty()) {\n\t\t\tUserGroupMembershipPolicyUtil.propagateMembership(\n\t\t\t\tnew long[] {user.getUserId()},\n\t\t\t\tArrayUtil.toLongArray(addUserGroupIds),\n\t\t\t\tArrayUtil.toLongArray(removeUserGroupIds));\n\t\t}\n\n\t\treturn user;\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tif ((!isChecked(user) &&\n\t\t\t\t!UserGroupMembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\tuser.getUserId(), _userGroup.getUserGroupId())) ||\n\t\t\t\t(isChecked(user) &&\n\t\t\t\tUserGroupMembershipPolicyUtil.isMembershipRequired(\n\t\t\t\t\tuser.getUserId(), _userGroup.getUserGroupId()))) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","id":628,"modified_method":"@Override\n\tpublic boolean isDisabled(Object obj) {\n\t\tUser user = (User)obj;\n\n\t\ttry {\n\t\t\tif (isChecked(user)) {\n\t\t\t\tif (UserGroupMembershipPolicyUtil.isMembershipRequired(\n\t\t\t\t\t\tuser.getUserId(), _userGroup.getUserGroupId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!UserGroupMembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\t\tuser.getUserId(), _userGroup.getUserGroupId())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treturn super.isDisabled(obj);\n\t\t}\n\t}","commit_id":"66c4d6a989d433ad43ee221b4b543064ce7c0537","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean login(ModalityContext executor) throws CannotFindCvsRootException {\n    for (Iterator iterator = mySubstitutionToOperation.keySet().iterator(); iterator.hasNext();) {\n      KeywordSubstitution keywordSubstitution = (KeywordSubstitution)iterator.next();\n      addOperation(mySubstitutionToOperation.get(keywordSubstitution));\n    }\n    return super.login(executor);\n  }","id":629,"modified_method":"public boolean login(ModalityContext executor) throws CannotFindCvsRootException {\n    for (final KeywordSubstitution keywordSubstitution : mySubstitutionToOperation.keySet()) {\n      addOperation(mySubstitutionToOperation.get(keywordSubstitution));\n    }\n    return super.login(executor);\n  }","commit_id":"2c97196c70722967d2ea4304b6e2d5a189082186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int calculateAllFilesCount() {\n    int result = 0;\n    for (Iterator iterator = getSubOperations().iterator(); iterator.hasNext();) {\n      AddFileOperation addFileOprtation = (AddFileOperation)iterator.next();\n      result += addFileOprtation.getFilesCount();\n    }\n    return result;\n  }","id":630,"modified_method":"private int calculateAllFilesCount() {\n    int result = 0;\n    for (final CvsOperation cvsOperation : getSubOperations()) {\n      AddFileOperation addFileOperation = (AddFileOperation)cvsOperation;\n      result += addFileOperation.getFilesCount();\n    }\n    return result;\n  }","commit_id":"2c97196c70722967d2ea4304b6e2d5a189082186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean login(Collection<CvsRootProvider> processedCvsRoots, ModalityContext executor) throws CannotFindCvsRootException {\n    for (Iterator each = getSubOperations().iterator(); each.hasNext();) {\n      CvsOperation operation = (CvsOperation) each.next();\n      if (!operation.login(processedCvsRoots, executor)) return false;\n    }\n    return true;\n  }","id":631,"modified_method":"protected boolean login(Collection<CvsRootProvider> processedCvsRoots, ModalityContext executor) throws CannotFindCvsRootException {\n    for (final CvsOperation operation : getSubOperations()) {\n      if (!operation.login(processedCvsRoots, executor)) return false;\n    }\n    return true;\n  }","commit_id":"2c97196c70722967d2ea4304b6e2d5a189082186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void executeFinishActions() {\n    super.executeFinishActions();\n    for (Iterator each = getSubOperations().iterator(); each.hasNext();) {\n      ((CvsOperation) each.next()).executeFinishActions();\n    }\n\n  }","id":632,"modified_method":"public void executeFinishActions() {\n    super.executeFinishActions();\n    for (final CvsOperation cvsOperation : getSubOperations()) {\n      cvsOperation.executeFinishActions();\n    }\n\n  }","commit_id":"2c97196c70722967d2ea4304b6e2d5a189082186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(CvsExecutionEnvironment executionEnvironment) throws VcsException, CommandAbortedException {\n    CvsEntriesManager.getInstance().lockSynchronizationActions();\n    try{\n    for (Iterator each = getSubOperations().iterator(); each.hasNext();) {\n      myCurrentOperation = (CvsOperation) each.next();\n      myCurrentOperation.execute(executionEnvironment);\n    }\n    } finally {\n      CvsEntriesManager.getInstance().unlockSynchronizationActions();\n    }\n  }","id":633,"modified_method":"public void execute(CvsExecutionEnvironment executionEnvironment) throws VcsException, CommandAbortedException {\n    CvsEntriesManager.getInstance().lockSynchronizationActions();\n    try{\n      for (final CvsOperation cvsOperation : getSubOperations()) {\n        myCurrentOperation = cvsOperation;\n        myCurrentOperation.execute(executionEnvironment);\n      }\n    } finally {\n      CvsEntriesManager.getInstance().unlockSynchronizationActions();\n    }\n  }","commit_id":"2c97196c70722967d2ea4304b6e2d5a189082186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected List getSubOperations() {\n    ArrayList result = new ArrayList(super.getSubOperations());\n    result.add(myCommitRequests);\n    return result;\n  }","id":634,"modified_method":"protected List<CvsOperation> getSubOperations() {\n    ArrayList<CvsOperation> result = new ArrayList<CvsOperation>(super.getSubOperations());\n    result.add(myCommitRequests);\n    return result;\n  }","commit_id":"2c97196c70722967d2ea4304b6e2d5a189082186","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void build(final RuleBuildContext context,\r\n                      final RuleDescr ruleDescr) {\r\n        // pushing consequence LHS into the stack for variable resolution\r\n        context.getBuildStack().push( context.getRule().getLhs() );\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n        factory.setPreviousDeclarationMap( context.getDeclarationResolver().getDeclarations() );\r\n        factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) ruleDescr.getConsequence() );\r\n\r\n        context.getRule().setConsequence( new MVELConsequence( expr,\r\n                                                               factory ) );\r\n    }","id":635,"modified_method":"public void build(final RuleBuildContext context,\r\n                      final RuleDescr ruleDescr) {\r\n        // pushing consequence LHS into the stack for variable resolution\r\n        context.getBuildStack().push( context.getRule().getLhs() );\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(), null,  context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) ruleDescr.getConsequence() );\r\n\r\n        context.getRule().setConsequence( new MVELConsequence( expr,\r\n                                                               factory ) );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Builds and returns an Eval Conditional Element\r\n     * \r\n     * @param context The current build context\r\n     * @param utils The current build utils instance\r\n     * @param patternBuilder not used by EvalBuilder\r\n     * @param descr The Eval Descriptor to build the eval conditional element from\r\n     * \r\n     * @return the Eval Conditional Element\r\n     */\r\n    public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        // it must be an EvalDescr\r\n        final EvalDescr evalDescr = (EvalDescr) descr;\r\n\r\n        final Declaration[] declarations = new Declaration[0];\r\n        //        final List[] usedIdentifiers = utils.getUsedIdentifiers( context,\r\n        //                                                                 evalDescr,\r\n        //                                                                 evalDescr.getText() );\r\n        //\r\n        //        final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n        //        for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n        //            declarations[i] = (Declaration) context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n        //        }\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n        factory.setPreviousDeclarationMap( context.getDeclarationResolver().getDeclarations() );\r\n        factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) evalDescr.getContent() );\r\n        final EvalCondition eval = new EvalCondition( declarations );\r\n        eval.setEvalExpression( new MVELEvalExpression( expr,\r\n                                                        factory ) );\r\n\r\n        return eval;\r\n    }","id":636,"modified_method":"/**\r\n     * Builds and returns an Eval Conditional Element\r\n     * \r\n     * @param context The current build context\r\n     * @param utils The current build utils instance\r\n     * @param patternBuilder not used by EvalBuilder\r\n     * @param descr The Eval Descriptor to build the eval conditional element from\r\n     * \r\n     * @return the Eval Conditional Element\r\n     */\r\n    public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        // it must be an EvalDescr\r\n        final EvalDescr evalDescr = (EvalDescr) descr;\r\n\r\n        final Declaration[] declarations = new Declaration[0];\r\n        //        final List[] usedIdentifiers = utils.getUsedIdentifiers( context,\r\n        //                                                                 evalDescr,\r\n        //                                                                 evalDescr.getText() );\r\n        //\r\n        //        final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n        //        for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n        //            declarations[i] = (Declaration) context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n        //        }\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(), null,  context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) evalDescr.getContent() );\r\n        final EvalCondition eval = new EvalCondition( declarations );\r\n        eval.setEvalExpression( new MVELEvalExpression( expr,\r\n                                                        factory ) );\r\n\r\n        return eval;\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        final FromDescr fromDescr = (FromDescr) descr;\r\n\r\n        final PatternBuilder patternBuilder = (PatternBuilder) context.getDialect().getBuilder( PatternDescr.class );\r\n        \r\n        final Pattern pattern = patternBuilder.build( context,\r\n                                                      fromDescr.getReturnedPattern() );\r\n\r\n        if ( pattern == null ) {\r\n            return null;\r\n        }\r\n\r\n        final AccessorDescr accessor = (AccessorDescr) fromDescr.getDataSource();\r\n        DataProvider dataProvider = null;\r\n        try {\r\n            //            JFDIParser parser = createParser( utils,\r\n            //                                              accessor.toString() );\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n            factory.setPreviousDeclarationMap( context.getDeclarationResolver().getDeclarations() );\r\n            factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n            //parser.setValueHandlerFactory( factory );\r\n            final Serializable compiled = MVEL.compileExpression( accessor.toString() );\r\n\r\n            dataProvider = new MVELDataProvider( compiled,\r\n                                                 factory );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    fromDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'from' node '\" + accessor.toString() + \"'\" ) );\r\n            return null;\r\n        }\r\n\r\n        return new From( pattern,\r\n                         dataProvider );\r\n    }","id":637,"modified_method":"public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        final FromDescr fromDescr = (FromDescr) descr;\r\n\r\n        final PatternBuilder patternBuilder = (PatternBuilder) context.getDialect().getBuilder( PatternDescr.class );\r\n        \r\n        final Pattern pattern = patternBuilder.build( context,\r\n                                                      fromDescr.getReturnedPattern() );\r\n\r\n        if ( pattern == null ) {\r\n            return null;\r\n        }\r\n\r\n        final AccessorDescr accessor = (AccessorDescr) fromDescr.getDataSource();\r\n        DataProvider dataProvider = null;\r\n        try {\r\n            //            JFDIParser parser = createParser( utils,\r\n            //                                              accessor.toString() );\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(), null,  context.getPkg().getGlobals() );\r\n\r\n            //parser.setValueHandlerFactory( factory );\r\n            final Serializable compiled = MVEL.compileExpression( accessor.toString() );\r\n\r\n            dataProvider = new MVELDataProvider( compiled,\r\n                                                 factory );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    fromDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'from' node '\" + accessor.toString() + \"'\" ) );\r\n            return null;\r\n        }\r\n\r\n        return new From( pattern,\r\n                         dataProvider );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final PredicateConstraint predicate,\r\n                      final PredicateDescr predicateDescr) {\r\n\r\n        //final Declaration[] declarations = new Declaration[0];\r\n        //        final List[] usedIdentifiers = utils.getUsedIdentifiers( context,\r\n        //                                                                 evalDescr,\r\n        //                                                                 evalDescr.getText() );\r\n        //\r\n        //        final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n        //        for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n        //            declarations[i] = (Declaration) context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n        //        }\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n\r\n        Map map = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            map.put( previousDeclarations[i].getIdentifier(),\r\n                     previousDeclarations[i] );\r\n        }\r\n        factory.setPreviousDeclarationMap( map );\r\n\r\n        map = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            map.put( localDeclarations[i].getIdentifier(),\r\n                     localDeclarations[i] );\r\n        }\r\n        factory.setLocalDeclarationMap( map );\r\n\r\n        factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) predicateDescr.getContent() );\r\n        predicate.setPredicateExpression( new MVELPredicateExpression( expr,\r\n                                                                       factory ) );\r\n    }","id":638,"modified_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final PredicateConstraint predicate,\r\n                      final PredicateDescr predicateDescr) {\r\n\r\n        //final Declaration[] declarations = new Declaration[0];\r\n        //        final List[] usedIdentifiers = utils.getUsedIdentifiers( context,\r\n        //                                                                 evalDescr,\r\n        //                                                                 evalDescr.getText() );\r\n        //\r\n        //        final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n        //        for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n        //            declarations[i] = (Declaration) context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n        //        }\r\n\r\n        //final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n\r\n        Map previousMap = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            previousMap.put( previousDeclarations[i].getIdentifier(),\r\n                     previousDeclarations[i] );\r\n        }\r\n\r\n        Map localMap = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            localMap.put( localDeclarations[i].getIdentifier(),\r\n                     localDeclarations[i] );\r\n        }\r\n        \r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(previousMap, localMap,  context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) predicateDescr.getContent() );\r\n        predicate.setPredicateExpression( new MVELPredicateExpression( expr,\r\n                                                                       factory ) );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final ReturnValueRestriction returnValueRestriction,\r\n                      final ReturnValueRestrictionDescr returnValueRestrictionDescr) {\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n\r\n        Map map = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            map.put( previousDeclarations[i].getIdentifier(),\r\n                     previousDeclarations[i] );\r\n        }\r\n        factory.setPreviousDeclarationMap( map );\r\n\r\n        map = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            map.put( localDeclarations[i].getIdentifier(),\r\n                     localDeclarations[i] );\r\n        }\r\n        factory.setLocalDeclarationMap( map );\r\n\r\n        factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) returnValueRestrictionDescr.getContent() );\r\n        returnValueRestriction.setReturnValueExpression( new MVELReturnValueExpression( expr,\r\n                                                                                        factory ) );\r\n    }","id":639,"modified_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final ReturnValueRestriction returnValueRestriction,\r\n                      final ReturnValueRestrictionDescr returnValueRestrictionDescr) {\r\n\r\n        Map previousMap = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            previousMap.put( previousDeclarations[i].getIdentifier(),\r\n                     previousDeclarations[i] );\r\n        }\r\n\r\n        Map localMap = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            localMap.put( localDeclarations[i].getIdentifier(),\r\n                     localDeclarations[i] );\r\n        }\r\n        \r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(previousMap, localMap,  context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) returnValueRestrictionDescr.getContent() );\r\n        returnValueRestriction.setReturnValueExpression( new MVELReturnValueExpression( expr,\r\n                                                                                        factory ) );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * This allows you to pass in a pre existing package, and a configuration\r\n     * (for instance to set the classloader).\r\n     * \r\n     * @param pkg\r\n     *            A pre existing package (can be null if none exists)\r\n     * @param configuration\r\n     *            Optional configuration for this builder.\r\n     */\r\n    public PackageBuilder(final Package pkg,\r\n                          PackageBuilderConfiguration configuration) {\r\n        if ( configuration == null ) {\r\n            configuration = new PackageBuilderConfiguration();\r\n        }\r\n\r\n        this.configuration = configuration;\r\n        this.results = new ArrayList();\r\n        this.pkg = pkg;\r\n        this.classFieldExtractorCache = new ClassFieldExtractorCache();\r\n        \r\n        this.dialects = new DialectRegistry();           \r\n        \r\n        if ( this.pkg != null ) {\r\n            this.typeResolver = new ClassTypeResolver( this.pkg.getImports(),\r\n                                                       this.pkg.getPackageCompilationData().getClassLoader() );\r\n            // make an automatic import for the current package\r\n            this.typeResolver.addImport( this.pkg.getName() + \".*\" );\r\n            this.dialects.addDialect( \"java\",\r\n                                      new JavaDialect( pkg,\r\n                                                       configuration,\r\n                                                       getTypeResolver(),\r\n                                                       this.classFieldExtractorCache ) );            \r\n            this.dialect = this.dialects.getDialect( \"java\" ); // TODO this should from the package\r\n            \r\n        } else {\r\n            this.typeResolver = new ClassTypeResolver( new ArrayList(), configuration.getClassLoader() );\r\n            this.dialects.addDialect( \"java\",\r\n                                      new JavaDialect( pkg,\r\n                                                       configuration,\r\n                                                       getTypeResolver(),\r\n                                                       this.classFieldExtractorCache ) ); \r\n            this.dialects.addDialect( \"default\", this.dialects.getDialect( configuration.getDialect() ) );     \r\n            this.dialect = this.dialects.getDialect( configuration.getDialect() );\r\n        }\r\n\r\n        //this.dialect = this.dialects.getDialect( \"java\" );\r\n    }","id":640,"modified_method":"/**\r\n     * This allows you to pass in a pre existing package, and a configuration\r\n     * (for instance to set the classloader).\r\n     * \r\n     * @param pkg\r\n     *            A pre existing package (can be null if none exists)\r\n     * @param configuration\r\n     *            Optional configuration for this builder.\r\n     */\r\n    public PackageBuilder(final Package pkg,\r\n                          PackageBuilderConfiguration configuration) {\r\n        if ( configuration == null ) {\r\n            configuration = new PackageBuilderConfiguration();\r\n        }\r\n\r\n        this.configuration = configuration;\r\n        this.results = new ArrayList();\r\n        this.pkg = pkg;\r\n        this.classFieldExtractorCache = new ClassFieldExtractorCache();\r\n        \r\n        this.dialects = new DialectRegistry();           \r\n        \r\n        if ( this.pkg != null ) {\r\n            this.typeResolver = new ClassTypeResolver( this.pkg.getImports(),\r\n                                                       this.pkg.getPackageCompilationData().getClassLoader() );\r\n            // make an automatic import for the current package\r\n            this.typeResolver.addImport( this.pkg.getName() + \".*\" );\r\n            this.dialects.addDialect( \"java\",\r\n                                      new JavaDialect( pkg,\r\n                                                       configuration,\r\n                                                       getTypeResolver(),\r\n                                                       this.classFieldExtractorCache ) );    \r\n            this.dialects.addDialect( \"mvel\",\r\n                                      new MVELDialect( pkg,\r\n                                                       configuration,\r\n                                                       getTypeResolver(),\r\n                                                       this.classFieldExtractorCache ) );             \r\n            this.dialect = this.dialects.getDialect( \"java\" ); // TODO this should from the package\r\n            \r\n        } else {\r\n            this.typeResolver = new ClassTypeResolver( new ArrayList(), configuration.getClassLoader() );\r\n            this.dialects.addDialect( \"java\",\r\n                                      new JavaDialect( pkg,\r\n                                                       configuration,\r\n                                                       getTypeResolver(),\r\n                                                       this.classFieldExtractorCache ) ); \r\n            this.dialects.addDialect( \"mvel\",\r\n                                      new MVELDialect( pkg,\r\n                                                       configuration,\r\n                                                       getTypeResolver(),\r\n                                                       this.classFieldExtractorCache ) );             \r\n            this.dialects.addDialect( \"default\", this.dialects.getDialect( configuration.getDialect() ) );     \r\n            this.dialect = this.dialects.getDialect( configuration.getDialect() );\r\n        }\r\n\r\n        //this.dialect = this.dialects.getDialect( \"java\" );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Build the give rule into the \r\n     * @param pkg\r\n     * @param ruleDescr\r\n     * @return\r\n     */\r\n    public void build(final RuleBuildContext context) {\r\n        RuleDescr ruleDescr = context.getRuleDescr();\r\n\r\n        final ConditionalElementBuilder builder = (ConditionalElementBuilder) context.getDialect().getBuilder( ruleDescr.getLhs().getClass() );\r\n        if ( builder != null ) {\r\n            final GroupElement ce = (GroupElement) builder.build( context,\r\n                                                                  ruleDescr.getLhs() );\r\n            context.getRule().setLhs( ce );\r\n        } else {\r\n            throw new RuntimeDroolsException( \"BUG: builder not found for descriptor class \" + ruleDescr.getLhs().getClass() );\r\n        }\r\n\r\n        // Build the consequence and generate it's invoker/s\r\n        // generate the main rule from the previously generated s.\r\n        if ( !(ruleDescr instanceof QueryDescr) ) {\r\n            // do not build the consequence if we have a query\r\n\r\n            context.getDialect().getConsequenceBuilder().build( context,\r\n                                                                ruleDescr );\r\n        }\r\n        context.getDialect().getRuleClassBuilder().buildRule( context,\r\n                                                              ruleDescr );\r\n    }","id":641,"modified_method":"/**\r\n     * Build the give rule into the \r\n     * @param pkg\r\n     * @param ruleDescr\r\n     * @return\r\n     */\r\n    public void build(final RuleBuildContext context) {\r\n        RuleDescr ruleDescr = context.getRuleDescr();\r\n\r\n        final ConditionalElementBuilder builder = (ConditionalElementBuilder) context.getDialect().getBuilder( ruleDescr.getLhs().getClass() );\r\n        if ( builder != null ) {\r\n            final GroupElement ce = (GroupElement) builder.build( context,\r\n                                                                  ruleDescr.getLhs() );\r\n            context.getRule().setLhs( ce );\r\n        } else {\r\n            throw new RuntimeDroolsException( \"BUG: builder not found for descriptor class \" + ruleDescr.getLhs().getClass() );\r\n        }\r\n\r\n        // Build the consequence and generate it's invoker/s\r\n        // generate the main rule from the previously generated s.\r\n        if ( !(ruleDescr instanceof QueryDescr) ) {\r\n            // do not build the consequence if we have a query\r\n\r\n            context.getDialect().getConsequenceBuilder().build( context,\r\n                                                                ruleDescr );\r\n        }\r\n        RuleClassBuilder classBuilder = context.getDialect().getRuleClassBuilder();\r\n        if ( classBuilder != null ) {\r\n            classBuilder.buildRule( context,\r\n                                    ruleDescr );\r\n        }\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Creates the HttpClientConfigurer based on the given parameters\n     * \n     * @param parameters the map of parameters \n     * @return the configurer\n     */\n    protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, Set<AuthMethod> authMethods) {\n        // prefer to use endpoint configured over component configured\n        // TODO cmueller: remove the \"httpClientConfigurerRef\" look up in Camel 3.0\n        HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurerRef\", HttpClientConfigurer.class);\n        if (configurer == null) {\n            // try without ref\n            configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurer\", HttpClientConfigurer.class);\n        }\n        if (configurer == null) {\n            // fallback to component configured\n            configurer = getHttpClientConfigurer();\n        }\n\n        // authentication can be endpoint configured\n        String authUsername = getAndRemoveParameter(parameters, \"authUsername\", String.class);\n        String authMethod = getAndRemoveParameter(parameters, \"authMethod\", String.class);\n        // validate that if auth username is given then the auth method is also provided\n        if (authUsername != null && authMethod == null) {\n            throw new IllegalArgumentException(\"Option authMethod must be provided to use authentication\");\n        }\n        if (authMethod != null) {\n            String authPassword = getAndRemoveParameter(parameters, \"authPassword\", String.class);\n            String authDomain = getAndRemoveParameter(parameters, \"authDomain\", String.class);\n            String authHost = getAndRemoveParameter(parameters, \"authHost\", String.class);\n            configurer = configureAuth(configurer, authMethod, authUsername, authPassword, authDomain, authHost, authMethods);\n        } else if (httpConfiguration != null) {\n            // or fallback to use component configuration\n            configurer = configureAuth(configurer, httpConfiguration.getAuthMethod(), httpConfiguration.getAuthUsername(),\n                    httpConfiguration.getAuthPassword(), httpConfiguration.getAuthDomain(), httpConfiguration.getAuthHost(), authMethods);\n        }\n\n        // proxy authentication can be endpoint configured\n        String proxyAuthUsername = getAndRemoveParameter(parameters, \"proxyAuthUsername\", String.class);\n        String proxyAuthMethod = getAndRemoveParameter(parameters, \"proxyAuthMethod\", String.class);\n        // validate that if proxy auth username is given then the proxy auth method is also provided\n        if (proxyAuthUsername != null && proxyAuthMethod == null) {\n            throw new IllegalArgumentException(\"Option proxyAuthMethod must be provided to use proxy authentication\");\n        }\n        if (proxyAuthMethod != null) {\n            String proxyAuthPassword = getAndRemoveParameter(parameters, \"proxyAuthPassword\", String.class);\n            String proxyAuthDomain = getAndRemoveParameter(parameters, \"proxyAuthDomain\", String.class);\n            String proxyAuthHost = getAndRemoveParameter(parameters, \"proxyAuthHost\", String.class);\n            configurer = configureProxyAuth(configurer, proxyAuthMethod, proxyAuthUsername, proxyAuthPassword, proxyAuthDomain, proxyAuthHost, authMethods);\n        } else if (httpConfiguration != null) {\n            // or fallback to use component configuration\n            configurer = configureProxyAuth(configurer, httpConfiguration.getProxyAuthMethod(), httpConfiguration.getProxyAuthUsername(),\n                    httpConfiguration.getProxyAuthPassword(), httpConfiguration.getProxyAuthDomain(), httpConfiguration.getProxyAuthHost(), authMethods);\n        }\n\n        return configurer;\n    }","id":642,"modified_method":"/**\n     * Creates the HttpClientConfigurer based on the given parameters\n     * \n     * @param parameters the map of parameters \n     * @return the configurer\n     */\n    protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, Set<AuthMethod> authMethods) {\n        // prefer to use endpoint configured over component configured\n        HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurer\", HttpClientConfigurer.class);\n        if (configurer == null) {\n            // fallback to component configured\n            configurer = getHttpClientConfigurer();\n        }\n\n        // authentication can be endpoint configured\n        String authUsername = getAndRemoveParameter(parameters, \"authUsername\", String.class);\n        String authMethod = getAndRemoveParameter(parameters, \"authMethod\", String.class);\n        // validate that if auth username is given then the auth method is also provided\n        if (authUsername != null && authMethod == null) {\n            throw new IllegalArgumentException(\"Option authMethod must be provided to use authentication\");\n        }\n        if (authMethod != null) {\n            String authPassword = getAndRemoveParameter(parameters, \"authPassword\", String.class);\n            String authDomain = getAndRemoveParameter(parameters, \"authDomain\", String.class);\n            String authHost = getAndRemoveParameter(parameters, \"authHost\", String.class);\n            configurer = configureAuth(configurer, authMethod, authUsername, authPassword, authDomain, authHost, authMethods);\n        } else if (httpConfiguration != null) {\n            // or fallback to use component configuration\n            configurer = configureAuth(configurer, httpConfiguration.getAuthMethod(), httpConfiguration.getAuthUsername(),\n                    httpConfiguration.getAuthPassword(), httpConfiguration.getAuthDomain(), httpConfiguration.getAuthHost(), authMethods);\n        }\n\n        // proxy authentication can be endpoint configured\n        String proxyAuthUsername = getAndRemoveParameter(parameters, \"proxyAuthUsername\", String.class);\n        String proxyAuthMethod = getAndRemoveParameter(parameters, \"proxyAuthMethod\", String.class);\n        // validate that if proxy auth username is given then the proxy auth method is also provided\n        if (proxyAuthUsername != null && proxyAuthMethod == null) {\n            throw new IllegalArgumentException(\"Option proxyAuthMethod must be provided to use proxy authentication\");\n        }\n        if (proxyAuthMethod != null) {\n            String proxyAuthPassword = getAndRemoveParameter(parameters, \"proxyAuthPassword\", String.class);\n            String proxyAuthDomain = getAndRemoveParameter(parameters, \"proxyAuthDomain\", String.class);\n            String proxyAuthHost = getAndRemoveParameter(parameters, \"proxyAuthHost\", String.class);\n            configurer = configureProxyAuth(configurer, proxyAuthMethod, proxyAuthUsername, proxyAuthPassword, proxyAuthDomain, proxyAuthHost, authMethods);\n        } else if (httpConfiguration != null) {\n            // or fallback to use component configuration\n            configurer = configureProxyAuth(configurer, httpConfiguration.getProxyAuthMethod(), httpConfiguration.getProxyAuthUsername(),\n                    httpConfiguration.getProxyAuthPassword(), httpConfiguration.getProxyAuthDomain(), httpConfiguration.getProxyAuthHost(), authMethods);\n        }\n\n        return configurer;\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = \"http://\" + remaining;\n        if (uri.startsWith(\"https:\")) {\n            addressUri = \"https://\" + remaining;\n        }\n        Map<String, Object> httpClientParameters = new HashMap<String, Object>(parameters);\n        // must extract well known parameters before we create the endpoint\n        // TODO cmueller: remove the \"httpBindingRef\" look up in Camel 3.0\n        HttpBinding binding = resolveAndRemoveReferenceParameter(parameters, \"httpBindingRef\", HttpBinding.class);\n        if (binding == null) {\n            // try without ref\n            binding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        }\n        String proxyHost = getAndRemoveParameter(parameters, \"proxyHost\", String.class);\n        Integer proxyPort = getAndRemoveParameter(parameters, \"proxyPort\", Integer.class);\n        String authMethodPriority = getAndRemoveParameter(parameters, \"authMethodPriority\", String.class);\n        HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, \"headerFilterStrategy\", HeaderFilterStrategy.class);\n        UrlRewrite urlRewrite = resolveAndRemoveReferenceParameter(parameters, \"urlRewrite\", UrlRewrite.class);\n        // http client can be configured from URI options\n        HttpClientParams clientParams = new HttpClientParams();\n        IntrospectionSupport.setProperties(clientParams, parameters, \"httpClient.\");\n        // validate that we could resolve all httpClient. parameters as this component is lenient\n        validateParameters(uri, parameters, \"httpClient.\");       \n        // http client can be configured from URI options\n        HttpConnectionManagerParams connectionManagerParams = new HttpConnectionManagerParams();\n        // setup the httpConnectionManagerParams\n        IntrospectionSupport.setProperties(connectionManagerParams, parameters, \"httpConnectionManager.\");\n        validateParameters(uri, parameters, \"httpConnectionManager.\");\n        // make sure the component httpConnectionManager is take effect\n        HttpConnectionManager thisHttpConnectionManager = httpConnectionManager;\n        if (thisHttpConnectionManager == null) {\n            // only set the params on the new created http connection manager\n            thisHttpConnectionManager = new MultiThreadedHttpConnectionManager();\n            thisHttpConnectionManager.setParams(connectionManagerParams);\n        }\n        // create the configurer to use for this endpoint (authMethods contains the used methods created by the configurer)\n        final Set<AuthMethod> authMethods = new LinkedHashSet<AuthMethod>();\n        HttpClientConfigurer configurer = createHttpClientConfigurer(parameters, authMethods);\n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI endpointUri = URISupport.createRemainingURI(new URI(addressUri), httpClientParameters);\n       \n        // create the endpoint and connectionManagerParams already be set\n        HttpEndpoint endpoint = createHttpEndpoint(endpointUri.toString(), this, clientParams, thisHttpConnectionManager, configurer);\n        \n        if (headerFilterStrategy != null) {\n            endpoint.setHeaderFilterStrategy(headerFilterStrategy);\n        } else {\n            setEndpointHeaderFilterStrategy(endpoint);\n        }\n        if (urlRewrite != null) {\n            // let CamelContext deal with the lifecycle of the url rewrite\n            // this ensures its being shutdown when Camel shutdown etc.\n            getCamelContext().addService(urlRewrite);\n            endpoint.setUrlRewrite(urlRewrite);\n        }\n\n        // prefer to use endpoint configured over component configured\n        if (binding == null) {\n            // fallback to component configured\n            binding = getHttpBinding();\n        }\n        if (binding != null) {\n            endpoint.setBinding(binding);\n        }\n        if (proxyHost != null) {\n            endpoint.setProxyHost(proxyHost);\n            endpoint.setProxyPort(proxyPort);\n        } else if (httpConfiguration != null) {\n            endpoint.setProxyHost(httpConfiguration.getProxyHost());\n            endpoint.setProxyPort(httpConfiguration.getProxyPort());\n        }\n        if (authMethodPriority != null) {\n            endpoint.setAuthMethodPriority(authMethodPriority);\n        } else if (httpConfiguration != null && httpConfiguration.getAuthMethodPriority() != null) {\n            endpoint.setAuthMethodPriority(httpConfiguration.getAuthMethodPriority());\n        } else {\n            // no explicit auth method priority configured, so use convention over configuration\n            // and set priority based on auth method\n            if (!authMethods.isEmpty()) {\n                authMethodPriority = CollectionHelper.collectionAsCommaDelimitedString(authMethods);\n                endpoint.setAuthMethodPriority(authMethodPriority);\n            }\n        }\n        setProperties(endpoint, parameters);\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), parameters);\n        \n        // validate http uri that end-user did not duplicate the http part that can be a common error\n        String part = httpUri.getSchemeSpecificPart();\n        if (part != null) {\n            part = part.toLowerCase();\n            if (part.startsWith(\"//http//\") || part.startsWith(\"//https//\") || part.startsWith(\"//http://\") || part.startsWith(\"//https://\")) {\n                throw new ResolveEndpointFailedException(uri,\n                        \"The uri part is not configured correctly. You have duplicated the http(s) protocol.\");\n            }\n        }\n        endpoint.setHttpUri(httpUri);\n        return endpoint;\n    }","id":643,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = \"http://\" + remaining;\n        if (uri.startsWith(\"https:\")) {\n            addressUri = \"https://\" + remaining;\n        }\n        Map<String, Object> httpClientParameters = new HashMap<String, Object>(parameters);\n        // must extract well known parameters before we create the endpoint\n        HttpBinding binding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        String proxyHost = getAndRemoveParameter(parameters, \"proxyHost\", String.class);\n        Integer proxyPort = getAndRemoveParameter(parameters, \"proxyPort\", Integer.class);\n        String authMethodPriority = getAndRemoveParameter(parameters, \"authMethodPriority\", String.class);\n        HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, \"headerFilterStrategy\", HeaderFilterStrategy.class);\n        UrlRewrite urlRewrite = resolveAndRemoveReferenceParameter(parameters, \"urlRewrite\", UrlRewrite.class);\n        // http client can be configured from URI options\n        HttpClientParams clientParams = new HttpClientParams();\n        IntrospectionSupport.setProperties(clientParams, parameters, \"httpClient.\");\n        // validate that we could resolve all httpClient. parameters as this component is lenient\n        validateParameters(uri, parameters, \"httpClient.\");       \n        // http client can be configured from URI options\n        HttpConnectionManagerParams connectionManagerParams = new HttpConnectionManagerParams();\n        // setup the httpConnectionManagerParams\n        IntrospectionSupport.setProperties(connectionManagerParams, parameters, \"httpConnectionManager.\");\n        validateParameters(uri, parameters, \"httpConnectionManager.\");\n        // make sure the component httpConnectionManager is take effect\n        HttpConnectionManager thisHttpConnectionManager = httpConnectionManager;\n        if (thisHttpConnectionManager == null) {\n            // only set the params on the new created http connection manager\n            thisHttpConnectionManager = new MultiThreadedHttpConnectionManager();\n            thisHttpConnectionManager.setParams(connectionManagerParams);\n        }\n        // create the configurer to use for this endpoint (authMethods contains the used methods created by the configurer)\n        final Set<AuthMethod> authMethods = new LinkedHashSet<AuthMethod>();\n        HttpClientConfigurer configurer = createHttpClientConfigurer(parameters, authMethods);\n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI endpointUri = URISupport.createRemainingURI(new URI(addressUri), httpClientParameters);\n       \n        // create the endpoint and connectionManagerParams already be set\n        HttpEndpoint endpoint = createHttpEndpoint(endpointUri.toString(), this, clientParams, thisHttpConnectionManager, configurer);\n        \n        if (headerFilterStrategy != null) {\n            endpoint.setHeaderFilterStrategy(headerFilterStrategy);\n        } else {\n            setEndpointHeaderFilterStrategy(endpoint);\n        }\n        if (urlRewrite != null) {\n            // let CamelContext deal with the lifecycle of the url rewrite\n            // this ensures its being shutdown when Camel shutdown etc.\n            getCamelContext().addService(urlRewrite);\n            endpoint.setUrlRewrite(urlRewrite);\n        }\n\n        // prefer to use endpoint configured over component configured\n        if (binding == null) {\n            // fallback to component configured\n            binding = getHttpBinding();\n        }\n        if (binding != null) {\n            endpoint.setBinding(binding);\n        }\n        if (proxyHost != null) {\n            endpoint.setProxyHost(proxyHost);\n            endpoint.setProxyPort(proxyPort);\n        } else if (httpConfiguration != null) {\n            endpoint.setProxyHost(httpConfiguration.getProxyHost());\n            endpoint.setProxyPort(httpConfiguration.getProxyPort());\n        }\n        if (authMethodPriority != null) {\n            endpoint.setAuthMethodPriority(authMethodPriority);\n        } else if (httpConfiguration != null && httpConfiguration.getAuthMethodPriority() != null) {\n            endpoint.setAuthMethodPriority(httpConfiguration.getAuthMethodPriority());\n        } else {\n            // no explicit auth method priority configured, so use convention over configuration\n            // and set priority based on auth method\n            if (!authMethods.isEmpty()) {\n                authMethodPriority = CollectionHelper.collectionAsCommaDelimitedString(authMethods);\n                endpoint.setAuthMethodPriority(authMethodPriority);\n            }\n        }\n        setProperties(endpoint, parameters);\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), parameters);\n        \n        // validate http uri that end-user did not duplicate the http part that can be a common error\n        String part = httpUri.getSchemeSpecificPart();\n        if (part != null) {\n            part = part.toLowerCase();\n            if (part.startsWith(\"//http//\") || part.startsWith(\"//https//\") || part.startsWith(\"//http://\") || part.startsWith(\"//https://\")) {\n                throw new ResolveEndpointFailedException(uri,\n                        \"The uri part is not configured correctly. You have duplicated the http(s) protocol.\");\n            }\n        }\n        endpoint.setHttpUri(httpUri);\n        return endpoint;\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        Map<String, Object> httpClientParameters = new HashMap<String, Object>(parameters);\n        // http client can be configured from URI options\n        HttpClientBuilder clientBuilder = HttpClientBuilder.create();\n        // allow the builder pattern\n        IntrospectionSupport.setProperties(clientBuilder, parameters, \"httpClient.\", true);\n        // set the Request configure this way and allow the builder pattern\n        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom();\n        IntrospectionSupport.setProperties(requestConfigBuilder, parameters, \"httpClient.\", true);\n        clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\n        \n        // validate that we could resolve all httpClient. parameters as this component is lenient\n        validateParameters(uri, parameters, \"httpClient.\");\n        \n        // TODO cmueller: remove the \"httpBindingRef\" look up in Camel 3.0\n        HttpBinding httpBinding = resolveAndRemoveReferenceParameter(parameters, \"httpBindingRef\", HttpBinding.class);\n        if (httpBinding == null) {\n            httpBinding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        }\n\n        // TODO cmueller: remove the \"httpContextRef\" look up in Camel 3.0\n        HttpContext httpContext = resolveAndRemoveReferenceParameter(parameters, \"httpContextRef\", HttpContext.class);\n        if (httpContext == null) {\n            httpContext = resolveAndRemoveReferenceParameter(parameters, \"httpContext\", HttpContext.class);\n        }\n\n        X509HostnameVerifier x509HostnameVerifier = resolveAndRemoveReferenceParameter(parameters, \"x509HostnameVerifier\", X509HostnameVerifier.class);\n        if (x509HostnameVerifier == null) {\n            x509HostnameVerifier = getX509HostnameVerifier();\n        }\n        \n\n        // TODO cmueller: remove the \"sslContextParametersRef\" look up in Camel 3.0\n        SSLContextParameters sslContextParameters = resolveAndRemoveReferenceParameter(parameters, \"sslContextParametersRef\", SSLContextParameters.class);\n        if (sslContextParameters == null) {\n            sslContextParameters = resolveAndRemoveReferenceParameter(parameters, \"sslContextParameters\", SSLContextParameters.class);\n        }\n        if (sslContextParameters == null) {\n            sslContextParameters = getSslContextParameters();\n        }\n        \n        String httpMethodRestrict = getAndRemoveParameter(parameters, \"httpMethodRestrict\", String.class);\n        \n        HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, \"headerFilterStrategy\", HeaderFilterStrategy.class);\n        UrlRewrite urlRewrite = resolveAndRemoveReferenceParameter(parameters, \"urlRewrite\", UrlRewrite.class);\n\n        boolean secure = HttpHelper.isSecureConnection(uri) || sslContextParameters != null;\n\n        // need to set scheme on address uri depending on if its secure or not\n        String addressUri = (secure ? \"https://\" : \"http://\") + remaining;\n        \n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI uriHttpUriAddress = new URI(addressUri);\n\n        // validate http uri that end-user did not duplicate the http part that can be a common error\n        int pos = uri.indexOf(\"//\");\n        if (pos != -1) {\n            String part = uri.substring(pos + 2);\n            if (part.startsWith(\"http:\") || part.startsWith(\"https:\")) {\n                throw new ResolveEndpointFailedException(uri,\n                        \"The uri part is not configured correctly. You have duplicated the http(s) protocol.\");\n            }\n        }\n\n        // create the configurer to use for this endpoint\n        HttpClientConfigurer configurer = createHttpClientConfigurer(parameters, secure);\n        URI endpointUri = URISupport.createRemainingURI(uriHttpUriAddress, httpClientParameters);\n\n\n        // the endpoint uri should use the component name as scheme, so we need to re-create it once more\n        String scheme = ObjectHelper.before(uri, \"://\");\n        endpointUri = URISupport.createRemainingURI(\n                new URI(scheme,\n                        endpointUri.getUserInfo(),\n                        endpointUri.getHost(),\n                        endpointUri.getPort(),\n                        endpointUri.getPath(),\n                        endpointUri.getQuery(),\n                        endpointUri.getFragment()),\n                httpClientParameters);\n\n        // create the endpoint and set the http uri to be null\n        String endpointUriString = endpointUri.toString();\n\n        LOG.debug(\"Creating endpoint uri {}\", endpointUriString);\n        HttpClientConnectionManager localConnectionManager = clientConnectionManager;\n        if (localConnectionManager == null) {\n            // need to check the parameters of maxTotalConnections and connectionsPerRoute\n            int maxTotalConnections = getAndRemoveParameter(parameters, \"maxTotalConnections\", int.class, 0);\n            int connectionsPerRoute = getAndRemoveParameter(parameters, \"connectionsPerRoute\", int.class, 0);\n            localConnectionManager = createConnectionManager(createConnectionRegistry(x509HostnameVerifier, sslContextParameters), maxTotalConnections, connectionsPerRoute);\n        }\n        HttpEndpoint endpoint = new HttpEndpoint(endpointUriString, this, clientBuilder, localConnectionManager, configurer);\n        if (urlRewrite != null) {\n            // let CamelContext deal with the lifecycle of the url rewrite\n            // this ensures its being shutdown when Camel shutdown etc.\n            getCamelContext().addService(urlRewrite);\n            endpoint.setUrlRewrite(urlRewrite);\n        }\n        // configure the endpoint\n        setProperties(endpoint, parameters);\n\n        // determine the portnumber (special case: default portnumber)\n        //int port = getPort(uriHttpUriAddress);\n\n        // we can not change the port of an URI, we must create a new one with an explicit port value\n        URI httpUri = URISupport.createRemainingURI(\n                new URI(uriHttpUriAddress.getScheme(),\n                        uriHttpUriAddress.getUserInfo(),\n                        uriHttpUriAddress.getHost(),\n                        uriHttpUriAddress.getPort(),\n                        uriHttpUriAddress.getPath(),\n                        uriHttpUriAddress.getQuery(),\n                        uriHttpUriAddress.getFragment()),\n                        parameters);\n\n        endpoint.setHttpUri(httpUri);\n        if (headerFilterStrategy != null) {\n            endpoint.setHeaderFilterStrategy(headerFilterStrategy);\n        } else {\n            setEndpointHeaderFilterStrategy(endpoint);\n        }\n        endpoint.setBinding(getHttpBinding());\n        if (httpBinding != null) {\n            endpoint.setBinding(httpBinding);\n        }\n        if (httpMethodRestrict != null) {\n            endpoint.setHttpMethodRestrict(httpMethodRestrict);\n        }\n        endpoint.setHttpContext(getHttpContext());\n        if (httpContext != null) {\n            endpoint.setHttpContext(httpContext);\n        }\n        if (endpoint.getCookieStore() == null) {\n            endpoint.setCookieStore(getCookieStore());\n        }\n        \n        return endpoint;\n    }","id":644,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        Map<String, Object> httpClientParameters = new HashMap<String, Object>(parameters);\n        // http client can be configured from URI options\n        HttpClientBuilder clientBuilder = HttpClientBuilder.create();\n        // allow the builder pattern\n        IntrospectionSupport.setProperties(clientBuilder, parameters, \"httpClient.\", true);\n        // set the Request configure this way and allow the builder pattern\n        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom();\n        IntrospectionSupport.setProperties(requestConfigBuilder, parameters, \"httpClient.\", true);\n        clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\n        \n        // validate that we could resolve all httpClient. parameters as this component is lenient\n        validateParameters(uri, parameters, \"httpClient.\");\n        \n        HttpBinding httpBinding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        HttpContext httpContext = resolveAndRemoveReferenceParameter(parameters, \"httpContext\", HttpContext.class);\n\n        X509HostnameVerifier x509HostnameVerifier = resolveAndRemoveReferenceParameter(parameters, \"x509HostnameVerifier\", X509HostnameVerifier.class);\n        if (x509HostnameVerifier == null) {\n            x509HostnameVerifier = getX509HostnameVerifier();\n        }\n\n        SSLContextParameters sslContextParameters = resolveAndRemoveReferenceParameter(parameters, \"sslContextParameters\", SSLContextParameters.class);\n        if (sslContextParameters == null) {\n            sslContextParameters = getSslContextParameters();\n        }\n        \n        String httpMethodRestrict = getAndRemoveParameter(parameters, \"httpMethodRestrict\", String.class);\n        \n        HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, \"headerFilterStrategy\", HeaderFilterStrategy.class);\n        UrlRewrite urlRewrite = resolveAndRemoveReferenceParameter(parameters, \"urlRewrite\", UrlRewrite.class);\n\n        boolean secure = HttpHelper.isSecureConnection(uri) || sslContextParameters != null;\n\n        // need to set scheme on address uri depending on if its secure or not\n        String addressUri = (secure ? \"https://\" : \"http://\") + remaining;\n        \n        addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri);\n        URI uriHttpUriAddress = new URI(addressUri);\n\n        // validate http uri that end-user did not duplicate the http part that can be a common error\n        int pos = uri.indexOf(\"//\");\n        if (pos != -1) {\n            String part = uri.substring(pos + 2);\n            if (part.startsWith(\"http:\") || part.startsWith(\"https:\")) {\n                throw new ResolveEndpointFailedException(uri,\n                        \"The uri part is not configured correctly. You have duplicated the http(s) protocol.\");\n            }\n        }\n\n        // create the configurer to use for this endpoint\n        HttpClientConfigurer configurer = createHttpClientConfigurer(parameters, secure);\n        URI endpointUri = URISupport.createRemainingURI(uriHttpUriAddress, httpClientParameters);\n\n\n        // the endpoint uri should use the component name as scheme, so we need to re-create it once more\n        String scheme = ObjectHelper.before(uri, \"://\");\n        endpointUri = URISupport.createRemainingURI(\n                new URI(scheme,\n                        endpointUri.getUserInfo(),\n                        endpointUri.getHost(),\n                        endpointUri.getPort(),\n                        endpointUri.getPath(),\n                        endpointUri.getQuery(),\n                        endpointUri.getFragment()),\n                httpClientParameters);\n\n        // create the endpoint and set the http uri to be null\n        String endpointUriString = endpointUri.toString();\n\n        LOG.debug(\"Creating endpoint uri {}\", endpointUriString);\n        HttpClientConnectionManager localConnectionManager = clientConnectionManager;\n        if (localConnectionManager == null) {\n            // need to check the parameters of maxTotalConnections and connectionsPerRoute\n            int maxTotalConnections = getAndRemoveParameter(parameters, \"maxTotalConnections\", int.class, 0);\n            int connectionsPerRoute = getAndRemoveParameter(parameters, \"connectionsPerRoute\", int.class, 0);\n            localConnectionManager = createConnectionManager(createConnectionRegistry(x509HostnameVerifier, sslContextParameters), maxTotalConnections, connectionsPerRoute);\n        }\n        HttpEndpoint endpoint = new HttpEndpoint(endpointUriString, this, clientBuilder, localConnectionManager, configurer);\n        if (urlRewrite != null) {\n            // let CamelContext deal with the lifecycle of the url rewrite\n            // this ensures its being shutdown when Camel shutdown etc.\n            getCamelContext().addService(urlRewrite);\n            endpoint.setUrlRewrite(urlRewrite);\n        }\n        // configure the endpoint\n        setProperties(endpoint, parameters);\n\n        // determine the portnumber (special case: default portnumber)\n        //int port = getPort(uriHttpUriAddress);\n\n        // we can not change the port of an URI, we must create a new one with an explicit port value\n        URI httpUri = URISupport.createRemainingURI(\n                new URI(uriHttpUriAddress.getScheme(),\n                        uriHttpUriAddress.getUserInfo(),\n                        uriHttpUriAddress.getHost(),\n                        uriHttpUriAddress.getPort(),\n                        uriHttpUriAddress.getPath(),\n                        uriHttpUriAddress.getQuery(),\n                        uriHttpUriAddress.getFragment()),\n                        parameters);\n\n        endpoint.setHttpUri(httpUri);\n        if (headerFilterStrategy != null) {\n            endpoint.setHeaderFilterStrategy(headerFilterStrategy);\n        } else {\n            setEndpointHeaderFilterStrategy(endpoint);\n        }\n        endpoint.setBinding(getHttpBinding());\n        if (httpBinding != null) {\n            endpoint.setBinding(httpBinding);\n        }\n        if (httpMethodRestrict != null) {\n            endpoint.setHttpMethodRestrict(httpMethodRestrict);\n        }\n        endpoint.setHttpContext(getHttpContext());\n        if (httpContext != null) {\n            endpoint.setHttpContext(httpContext);\n        }\n        if (endpoint.getCookieStore() == null) {\n            endpoint.setCookieStore(getCookieStore());\n        }\n        \n        return endpoint;\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates the HttpClientConfigurer based on the given parameters\n     *\n     * @param parameters the map of parameters\n     * @param secure whether the endpoint is secure (eg https4)\n     * @return the configurer\n     * @throws Exception is thrown if error creating configurer\n     */\n    protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, boolean secure) throws Exception {\n        // prefer to use endpoint configured over component configured\n        // TODO cmueller: remove the \"httpClientConfigurerRef\" look up in Camel 3.0\n        HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurerRef\", HttpClientConfigurer.class);\n        if (configurer == null) {\n            // try without ref\n            configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurer\", HttpClientConfigurer.class);\n            \n            if (configurer == null) {\n                // fallback to component configured\n                configurer = getHttpClientConfigurer();\n            }\n        }\n\n        configurer = configureBasicAuthentication(parameters, configurer);\n        configurer = configureHttpProxy(parameters, configurer, secure);\n\n        return configurer;\n    }","id":645,"modified_method":"/**\n     * Creates the HttpClientConfigurer based on the given parameters\n     *\n     * @param parameters the map of parameters\n     * @param secure whether the endpoint is secure (eg https4)\n     * @return the configurer\n     * @throws Exception is thrown if error creating configurer\n     */\n    protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, boolean secure) throws Exception {\n        // prefer to use endpoint configured over component configured\n        HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, \"httpClientConfigurer\", HttpClientConfigurer.class);\n        if (configurer == null) {\n            // fallback to component configured\n            configurer = getHttpClientConfigurer();\n        }\n\n        configurer = configureBasicAuthentication(parameters, configurer);\n        configurer = configureHttpProxy(parameters, configurer, secure);\n\n        return configurer;\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHttpBindingRef() {\n        assertSame(testBinding, endpoint1.getBinding());\n        assertSame(testBinding, endpoint2.getBinding());\n    }","id":646,"modified_method":"@Test\n    public void testHttpBinding() {\n        assertSame(testBinding, endpoint1.getBinding());\n        assertSame(testBinding, endpoint2.getBinding());\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHttpClientConfigurerRef() {\n        assertSame(testConfigurer, endpoint1.getHttpClientConfigurer());\n        assertSame(testConfigurer, endpoint2.getHttpClientConfigurer());\n    }","id":647,"modified_method":"@Test\n    public void testHttpClientConfigurer() {\n        assertSame(testConfigurer, endpoint1.getHttpClientConfigurer());\n        assertSame(testConfigurer, endpoint2.getHttpClientConfigurer());\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHttpBindingRef() {\n        assertSame(testBinding, endpoint1.getBinding());\n        assertSame(testBinding, endpoint2.getBinding());\n    }","id":648,"modified_method":"@Test\n    public void testHttpBinding() {\n        assertSame(testBinding, endpoint1.getBinding());\n        assertSame(testBinding, endpoint2.getBinding());\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHttpContextRef() {\n        assertSame(testHttpContext, endpoint1.getHttpContext());\n        assertSame(testHttpContext, endpoint2.getHttpContext());\n    }","id":649,"modified_method":"@Test\n    public void testHttpContext() {\n        assertSame(testHttpContext, endpoint1.getHttpContext());\n        assertSame(testHttpContext, endpoint2.getHttpContext());\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // configure to use servlet on localhost\n                restConfiguration().component(\"servlet\").host(\"localhost\").endpointProperty(\"httpBindingRef\", \"#myBinding\");\n                \n                // use the rest DSL to define the rest services\n                rest(\"/users/\")\n                    .get(\"{id}/basic\")\n                        .route()\n                        .to(\"mock:input\")\n                        .process(new Processor() {\n                            public void process(Exchange exchange) throws Exception {\n                                String id = exchange.getIn().getHeader(\"id\", String.class);\n                                exchange.getOut().setBody(id + \";Donald Duck\");\n                            }\n                        });\n            }\n        };\n    }","id":650,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // configure to use servlet on localhost\n                restConfiguration().component(\"servlet\").host(\"localhost\").endpointProperty(\"httpBinding\", \"#myBinding\");\n                \n                // use the rest DSL to define the rest services\n                rest(\"/users/\")\n                    .get(\"{id}/basic\")\n                        .route()\n                        .to(\"mock:input\")\n                        .process(new Processor() {\n                            public void process(Exchange exchange) throws Exception {\n                                String id = exchange.getIn().getHeader(\"id\", String.class);\n                                exchange.getOut().setBody(id + \";Donald Duck\");\n                            }\n                        });\n            }\n        };\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // configure to use servlet on localhost\n                restConfiguration().component(\"servlet\").host(\"localhost\").endpointProperty(\"httpBindingRef\", \"#myBinding\");\n                \n                // use the rest DSL to define the rest services\n                rest(\"/users/\")\n                    .get(\"{id}/basic\")\n                        .route()\n                        .to(\"mock:input\")\n                        .process(new Processor() {\n                            public void process(Exchange exchange) throws Exception {\n                                String id = exchange.getIn().getHeader(\"id\", String.class);\n                                exchange.getOut().setBody(id + \";Donald Duck\");\n                            }\n                        }).endRest()\n                    .get(\"{id}/{query}\")\n                        .route()\n                        .to(\"mock:query\")\n                        .process(new Processor() {\n                            public void process(Exchange exchange) throws Exception {\n                                String id = exchange.getIn().getHeader(\"id\", String.class);\n                                exchange.getOut().setBody(id + \";Goofy\");\n                            }\n                        }).endRest();\n            }\n        };\n    }","id":651,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // configure to use servlet on localhost\n                restConfiguration().component(\"servlet\").host(\"localhost\").endpointProperty(\"httpBinding\", \"#myBinding\");\n                \n                // use the rest DSL to define the rest services\n                rest(\"/users/\")\n                    .get(\"{id}/basic\")\n                        .route()\n                        .to(\"mock:input\")\n                        .process(new Processor() {\n                            public void process(Exchange exchange) throws Exception {\n                                String id = exchange.getIn().getHeader(\"id\", String.class);\n                                exchange.getOut().setBody(id + \";Donald Duck\");\n                            }\n                        }).endRest()\n                    .get(\"{id}/{query}\")\n                        .route()\n                        .to(\"mock:query\")\n                        .process(new Processor() {\n                            public void process(Exchange exchange) throws Exception {\n                                String id = exchange.getIn().getHeader(\"id\", String.class);\n                                exchange.getOut().setBody(id + \";Goofy\");\n                            }\n                        }).endRest();\n            }\n        };\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        // must extract well known parameters before we create the endpoint\n        Boolean throwExceptionOnFailure = getAndRemoveParameter(parameters, \"throwExceptionOnFailure\", Boolean.class);\n        Boolean transferException = getAndRemoveParameter(parameters, \"transferException\", Boolean.class);\n        Boolean bridgeEndpoint = getAndRemoveParameter(parameters, \"bridgeEndpoint\", Boolean.class);\n        // TODO we need to remove the Ref in Camel 3.0\n        HttpBinding binding = resolveAndRemoveReferenceParameter(parameters, \"httpBindingRef\", HttpBinding.class);\n        if (binding == null) {\n            // just check the httpBinding parameter\n            binding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        }\n        Boolean matchOnUriPrefix = getAndRemoveParameter(parameters, \"matchOnUriPrefix\", Boolean.class);\n        String servletName = getAndRemoveParameter(parameters, \"servletName\", String.class, getServletName());\n        String httpMethodRestrict = getAndRemoveParameter(parameters, \"httpMethodRestrict\", String.class);\n        HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, \"headerFilterStrategy\", HeaderFilterStrategy.class);\n\n        if (lenientContextPath()) {\n            // the uri must have a leading slash for the context-path matching to work with servlet, and it can be something people\n            // forget to add and then the servlet consumer cannot match the context-path as would have been expected\n            String scheme = ObjectHelper.before(uri, \":\");\n            String after = ObjectHelper.after(uri, \":\");\n            // rebuild uri to have exactly one leading slash\n            while (after.startsWith(\"/\")) {\n                after = after.substring(1);\n            }\n            after = \"/\" + after;\n            uri = scheme + \":\" + after;\n        }\n\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        URI httpUri = URISupport.createRemainingURI(new URI(UnsafeUriCharactersEncoder.encodeHttpURI(uri)), parameters);\n\n        ServletEndpoint endpoint = createServletEndpoint(uri, this, httpUri);\n        endpoint.setServletName(servletName);\n        if (headerFilterStrategy != null) {\n            endpoint.setHeaderFilterStrategy(headerFilterStrategy);\n        } else {\n            setEndpointHeaderFilterStrategy(endpoint);\n        }\n\n        // prefer to use endpoint configured over component configured\n        if (binding == null) {\n            // fallback to component configured\n            binding = getHttpBinding();\n        }\n        if (binding != null) {\n            endpoint.setBinding(binding);\n        }\n        // should we use an exception for failed error codes?\n        if (throwExceptionOnFailure != null) {\n            endpoint.setThrowExceptionOnFailure(throwExceptionOnFailure);\n        }\n        // should we transfer exception as serialized object\n        if (transferException != null) {\n            endpoint.setTransferException(transferException);\n        }\n        if (bridgeEndpoint != null) {\n            endpoint.setBridgeEndpoint(bridgeEndpoint);\n        }\n        if (matchOnUriPrefix != null) {\n            endpoint.setMatchOnUriPrefix(matchOnUriPrefix);\n        }\n        if (httpMethodRestrict != null) {\n            endpoint.setHttpMethodRestrict(httpMethodRestrict);\n        }\n\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","id":652,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        // must extract well known parameters before we create the endpoint\n        Boolean throwExceptionOnFailure = getAndRemoveParameter(parameters, \"throwExceptionOnFailure\", Boolean.class);\n        Boolean transferException = getAndRemoveParameter(parameters, \"transferException\", Boolean.class);\n        Boolean bridgeEndpoint = getAndRemoveParameter(parameters, \"bridgeEndpoint\", Boolean.class);\n        HttpBinding binding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        Boolean matchOnUriPrefix = getAndRemoveParameter(parameters, \"matchOnUriPrefix\", Boolean.class);\n        String servletName = getAndRemoveParameter(parameters, \"servletName\", String.class, getServletName());\n        String httpMethodRestrict = getAndRemoveParameter(parameters, \"httpMethodRestrict\", String.class);\n        HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, \"headerFilterStrategy\", HeaderFilterStrategy.class);\n\n        if (lenientContextPath()) {\n            // the uri must have a leading slash for the context-path matching to work with servlet, and it can be something people\n            // forget to add and then the servlet consumer cannot match the context-path as would have been expected\n            String scheme = ObjectHelper.before(uri, \":\");\n            String after = ObjectHelper.after(uri, \":\");\n            // rebuild uri to have exactly one leading slash\n            while (after.startsWith(\"/\")) {\n                after = after.substring(1);\n            }\n            after = \"/\" + after;\n            uri = scheme + \":\" + after;\n        }\n\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        URI httpUri = URISupport.createRemainingURI(new URI(UnsafeUriCharactersEncoder.encodeHttpURI(uri)), parameters);\n\n        ServletEndpoint endpoint = createServletEndpoint(uri, this, httpUri);\n        endpoint.setServletName(servletName);\n        if (headerFilterStrategy != null) {\n            endpoint.setHeaderFilterStrategy(headerFilterStrategy);\n        } else {\n            setEndpointHeaderFilterStrategy(endpoint);\n        }\n\n        // prefer to use endpoint configured over component configured\n        if (binding == null) {\n            // fallback to component configured\n            binding = getHttpBinding();\n        }\n        if (binding != null) {\n            endpoint.setBinding(binding);\n        }\n        // should we use an exception for failed error codes?\n        if (throwExceptionOnFailure != null) {\n            endpoint.setThrowExceptionOnFailure(throwExceptionOnFailure);\n        }\n        // should we transfer exception as serialized object\n        if (transferException != null) {\n            endpoint.setTransferException(transferException);\n        }\n        if (bridgeEndpoint != null) {\n            endpoint.setBridgeEndpoint(bridgeEndpoint);\n        }\n        if (matchOnUriPrefix != null) {\n            endpoint.setMatchOnUriPrefix(matchOnUriPrefix);\n        }\n        if (httpMethodRestrict != null) {\n            endpoint.setHttpMethodRestrict(httpMethodRestrict);\n        }\n\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","commit_id":"df701cc3776833c98a3e2b53f86dfd8f01eabe4b","url":"https://github.com/apache/camel"},{"original_method":"/**\r\n\t * Construct a MethodDescriptor from JavaClass and method.\r\n\t * \r\n\t * @param jclass a JavaClass\r\n\t * @param method a Method belonging to the JavaClass\r\n\t * @return a MethodDescriptor identifying the method\r\n\t */\r\n\tpublic static MethodDescriptor getMethodDescriptor(JavaClass jclass, Method method) {\r\n\t\treturn new MethodDescriptor(\r\n\t\t\t\tjclass.getClassName().replace('.', '/'), method.getName(), method.getSignature(), method.isStatic());\r\n\t}","id":653,"modified_method":"/**\r\n\t * Construct a MethodDescriptor from JavaClass and method.\r\n\t * \r\n\t * @param jclass a JavaClass\r\n\t * @param method a Method belonging to the JavaClass\r\n\t * @return a MethodDescriptor identifying the method\r\n\t */\r\n\tpublic static MethodDescriptor getMethodDescriptor(JavaClass jclass, Method method) {\r\n\t\treturn DescriptorFactory.instance().getMethodDescriptor(\r\n\t\t\t\tjclass.getClassName().replace('.', '/'), method.getName(), method.getSignature(), method.isStatic());\r\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\r\n\t * Get a MethodDescriptor describing the method called by\r\n\t * given InvokeInstruction.\r\n\t * \r\n\t * @param inv the InvokeInstruction\r\n\t * @param cpg ConstantPoolGen of class containing instruction\r\n\t * @return MethodDescriptor describing the called method\r\n\t */\r\n\tpublic static MethodDescriptor getCalledMethodDescriptor(InvokeInstruction inv, ConstantPoolGen cpg) {\r\n\t\tString calledClassName = inv.getClassName(cpg).replace('.', '/');\r\n\t\tString calledMethodName = inv.getMethodName(cpg);\r\n\t\tString calledMethodSig = inv.getSignature(cpg);\r\n\t\tboolean isStatic = inv.getOpcode() == Constants.INVOKESTATIC;\r\n\t\t\r\n\t\treturn new MethodDescriptor(calledClassName, calledMethodName, calledMethodSig, isStatic);\r\n\t}","id":654,"modified_method":"/**\r\n\t * Get a MethodDescriptor describing the method called by\r\n\t * given InvokeInstruction.\r\n\t * \r\n\t * @param inv the InvokeInstruction\r\n\t * @param cpg ConstantPoolGen of class containing instruction\r\n\t * @return MethodDescriptor describing the called method\r\n\t */\r\n\tpublic static MethodDescriptor getCalledMethodDescriptor(InvokeInstruction inv, ConstantPoolGen cpg) {\r\n\t\tString calledClassName = inv.getClassName(cpg).replace('.', '/');\r\n\t\tString calledMethodName = inv.getMethodName(cpg);\r\n\t\tString calledMethodSig = inv.getSignature(cpg);\r\n\t\tboolean isStatic = inv.getOpcode() == Constants.INVOKESTATIC;\r\n\t\t\r\n\t\treturn DescriptorFactory.instance().getMethodDescriptor(calledClassName, calledMethodName, calledMethodSig, isStatic);\r\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Read field_info, return FieldDescriptor.\n\t * \n\t * @param thisClassDescriptor the ClassDescriptor of this class (being parsed) \n\t * @return the FieldDescriptor\n\t * @throws IOException \n\t * @throws InvalidClassFileFormatException \n\t */\n\tprivate FieldDescriptor readField(ClassDescriptor thisClassDescriptor)\n\t\t\tthrows IOException, InvalidClassFileFormatException {\n\t\treturn readFieldOrMethod(thisClassDescriptor, new FieldOrMethodDescriptorCreator<FieldDescriptor>() {\n\t\t\t/* (non-Javadoc)\n\t\t\t * @see edu.umd.cs.findbugs.classfile.engine.ClassParser.FieldOrMethodDescriptorCreator#create(java.lang.String, java.lang.String, java.lang.String, int)\n\t\t\t */\n\t\t\tpublic FieldDescriptor create(String className, String name, String signature, int accessFlags) {\n\t\t\t\treturn new FieldDescriptor(className, name, signature, (accessFlags & IClassConstants.ACC_STATIC) != 0);\n\t\t\t}\n\t\t});\n\t}","id":655,"modified_method":"/**\n\t * Read field_info, return FieldDescriptor.\n\t * \n\t * @param thisClassDescriptor the ClassDescriptor of this class (being parsed) \n\t * @return the FieldDescriptor\n\t * @throws IOException \n\t * @throws InvalidClassFileFormatException \n\t */\n\tprivate FieldDescriptor readField(ClassDescriptor thisClassDescriptor)\n\t\t\tthrows IOException, InvalidClassFileFormatException {\n\t\treturn readFieldOrMethod(thisClassDescriptor, new FieldOrMethodDescriptorCreator<FieldDescriptor>() {\n\t\t\t/* (non-Javadoc)\n\t\t\t * @see edu.umd.cs.findbugs.classfile.engine.ClassParser.FieldOrMethodDescriptorCreator#create(java.lang.String, java.lang.String, java.lang.String, int)\n\t\t\t */\n\t\t\tpublic FieldDescriptor create(String className, String name, String signature, int accessFlags) {\n\t\t\t\treturn DescriptorFactory.instance().getFieldDescriptor(className, name, signature, (accessFlags & IClassConstants.ACC_STATIC) != 0);\n\t\t\t}\n\t\t});\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Read method_info, read method descriptor.\n\t * \n\t * @param thisClassDescriptor\n\t * @return\n\t * @throws IOException \n\t * @throws InvalidClassFileFormatException \n\t */\n\tprivate MethodDescriptor readMethod(ClassDescriptor thisClassDescriptor)\n\t\t\tthrows InvalidClassFileFormatException, IOException {\n\t\treturn readFieldOrMethod(thisClassDescriptor, new FieldOrMethodDescriptorCreator<MethodDescriptor>(){\n\t\t\t/* (non-Javadoc)\n\t\t\t * @see edu.umd.cs.findbugs.classfile.engine.ClassParser.FieldOrMethodDescriptorCreator#create(java.lang.String, java.lang.String, java.lang.String, int)\n\t\t\t */\n\t\t\tpublic MethodDescriptor create(String className, String name, String signature, int accessFlags) {\n\t\t\t\treturn new MethodDescriptor(className, name, signature, (accessFlags & IClassConstants.ACC_STATIC) != 0);\n\t\t\t}\n\t\t});\n\t}","id":656,"modified_method":"/**\n\t * Read method_info, read method descriptor.\n\t * \n\t * @param thisClassDescriptor\n\t * @return\n\t * @throws IOException \n\t * @throws InvalidClassFileFormatException \n\t */\n\tprivate MethodDescriptor readMethod(ClassDescriptor thisClassDescriptor)\n\t\t\tthrows InvalidClassFileFormatException, IOException {\n\t\treturn readFieldOrMethod(thisClassDescriptor, new FieldOrMethodDescriptorCreator<MethodDescriptor>(){\n\t\t\t/* (non-Javadoc)\n\t\t\t * @see edu.umd.cs.findbugs.classfile.engine.ClassParser.FieldOrMethodDescriptorCreator#create(java.lang.String, java.lang.String, java.lang.String, int)\n\t\t\t */\n\t\t\tpublic MethodDescriptor create(String className, String name, String signature, int accessFlags) {\n\t\t\t\treturn DescriptorFactory.instance().getMethodDescriptor(className, name, signature, (accessFlags & IClassConstants.ACC_STATIC) != 0);\n\t\t\t}\n\t\t});\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private DescriptorFactory() {\n\t\tthis.classDescriptorMap = new HashMap<String, ClassDescriptor>();\n\t}","id":657,"modified_method":"private DescriptorFactory() {\n\t\tthis.classDescriptorMap = new HashMap<String, ClassDescriptor>();\n\t\tthis.methodDescriptorMap = new HashMap<MethodDescriptor, MethodDescriptor>();\n\t\tthis.fieldDescriptorMap = new HashMap<FieldDescriptor, FieldDescriptor>();\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the MethodDescriptor that (hopefully) uniqely names\n\t * this method.\n\t * \n\t * @return the MethodDescriptor uniquely naming this method\n\t */\n\tpublic MethodDescriptor toMethodDescriptor() {\n\t\treturn new MethodDescriptor(\n\t\t\t\tgetSlashedClassName(),\n\t\t\t\tmethod.getName(),\n\t\t\t\tmethod.getSignature(),\n\t\t\t\tmethod.isStatic());\n\t}","id":658,"modified_method":"/**\n\t * Get the MethodDescriptor that (hopefully) uniqely names\n\t * this method.\n\t * \n\t * @return the MethodDescriptor uniquely naming this method\n\t */\n\tpublic MethodDescriptor toMethodDescriptor() {\n\t\treturn DescriptorFactory.instance().getMethodDescriptor(\n\t\t\t\tgetSlashedClassName(),\n\t\t\t\tmethod.getName(),\n\t\t\t\tmethod.getSignature(),\n\t\t\t\tmethod.isStatic());\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Object analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor) throws CheckedAnalysisException {\n\t\tJavaClass jclass = analysisCache.getClassAnalysis(JavaClass.class, descriptor.getClassDescriptor());\n\t\tMethod[] methodList = jclass.getMethods();\n\t\t\n\t\tMethod result = null;\n\t\t\n\t\t// As a side-effect, cache all of the Methods for this JavaClass\n\t\tfor (Method method : methodList) {\n\t\t\tMethodDescriptor methodDescriptor =\n\t\t\t\tnew MethodDescriptor(descriptor.getSlashedClassName(), method.getName(), method.getSignature(), method.isStatic());\n\t\t\t\n\t\t\t// Put in cache eagerly\n\t\t\tanalysisCache.eagerlyPutMethodAnalysis(Method.class, methodDescriptor, method);\n\t\t\t\n\t\t\tif (methodDescriptor.equals(descriptor)) {\n\t\t\t\tresult = method;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}","id":659,"modified_method":"public Object analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor) throws CheckedAnalysisException {\n\t\tJavaClass jclass = analysisCache.getClassAnalysis(JavaClass.class, descriptor.getClassDescriptor());\n\t\tMethod[] methodList = jclass.getMethods();\n\t\t\n\t\tMethod result = null;\n\t\t\n\t\t// As a side-effect, cache all of the Methods for this JavaClass\n\t\tfor (Method method : methodList) {\n\t\t\tMethodDescriptor methodDescriptor =\n\t\t\t\tDescriptorFactory.instance().getMethodDescriptor(descriptor.getSlashedClassName(), method.getName(), method.getSignature(), method.isStatic());\n\t\t\t\n\t\t\t// Put in cache eagerly\n\t\t\tanalysisCache.eagerlyPutMethodAnalysis(Method.class, methodDescriptor, method);\n\t\t\t\n\t\t\tif (methodDescriptor.equals(descriptor)) {\n\t\t\t\tresult = method;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void visit(CodeException obj) {\n\t\tsuper.visit(obj);\n\t\tint type = obj.getCatchType();\n\t\tif (type == 0) return;\n\t\tString name = getConstantPool().constantToString(getConstantPool().getConstant(type));\n\n\t\tExceptionCaught caughtException =\n\t\t\tnew ExceptionCaught(name, obj.getStartPC(), obj.getEndPC(), obj.getHandlerPC());\n\t\tcatchList.add(caughtException);\n\n\t\ttry {\n\t\t\t// See if the store that saves the exception object\n\t\t\t// is alive or dead.  We rely on the fact that javac\n\t\t\t// always (?) emits an ASTORE instruction to save\n\t\t\t// the caught exception.\n\t\t\tLiveLocalStoreDataflow dataflow = getClassContext().getLiveLocalStoreDataflow(this.method);\n\t\t\tCFG cfg = getClassContext().getCFG(method);\n\t\t\tCollection<BasicBlock> blockList = cfg.getBlocksContainingInstructionWithOffset(obj.getHandlerPC());\n\t\t\tfor (BasicBlock block : blockList) {\n\t\t\t\tInstructionHandle first = block.getFirstInstruction();\n\t\t\t\tif (first != null\n\t\t\t\t\t\t&& first.getPosition() == obj.getHandlerPC()\n\t\t\t\t\t\t&& first.getInstruction() instanceof ASTORE) {\n\t\t\t\t\tASTORE astore = (ASTORE) first.getInstruction();\n\t\t\t\t\tBitSet liveStoreSet = dataflow.getFactAtLocation(new Location(first, block));\n\t\t\t\t\tif (!liveStoreSet.get(astore.getIndex())) {\n\t\t\t\t\t\t// The ASTORE storing the exception object is dead\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Dead exception store at \" + first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcaughtException.dead = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (MethodUnprofitableException e) {\n\t\t\tMethod m = getMethod();\n\t\t\tbugReporter.reportSkippedAnalysis(new MethodDescriptor(getClassName(), getMethodName(), getMethodSig(), m.isStatic()));\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error checking for dead exception store\", e);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error checking for dead exception store\", e);\n\t\t}\n\t}","id":660,"modified_method":"@Override\n\t\t public void visit(CodeException obj) {\n\t\tsuper.visit(obj);\n\t\tint type = obj.getCatchType();\n\t\tif (type == 0) return;\n\t\tString name = getConstantPool().constantToString(getConstantPool().getConstant(type));\n\n\t\tExceptionCaught caughtException =\n\t\t\tnew ExceptionCaught(name, obj.getStartPC(), obj.getEndPC(), obj.getHandlerPC());\n\t\tcatchList.add(caughtException);\n\n\t\ttry {\n\t\t\t// See if the store that saves the exception object\n\t\t\t// is alive or dead.  We rely on the fact that javac\n\t\t\t// always (?) emits an ASTORE instruction to save\n\t\t\t// the caught exception.\n\t\t\tLiveLocalStoreDataflow dataflow = getClassContext().getLiveLocalStoreDataflow(this.method);\n\t\t\tCFG cfg = getClassContext().getCFG(method);\n\t\t\tCollection<BasicBlock> blockList = cfg.getBlocksContainingInstructionWithOffset(obj.getHandlerPC());\n\t\t\tfor (BasicBlock block : blockList) {\n\t\t\t\tInstructionHandle first = block.getFirstInstruction();\n\t\t\t\tif (first != null\n\t\t\t\t\t\t&& first.getPosition() == obj.getHandlerPC()\n\t\t\t\t\t\t&& first.getInstruction() instanceof ASTORE) {\n\t\t\t\t\tASTORE astore = (ASTORE) first.getInstruction();\n\t\t\t\t\tBitSet liveStoreSet = dataflow.getFactAtLocation(new Location(first, block));\n\t\t\t\t\tif (!liveStoreSet.get(astore.getIndex())) {\n\t\t\t\t\t\t// The ASTORE storing the exception object is dead\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Dead exception store at \" + first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcaughtException.dead = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (MethodUnprofitableException e) {\n\t\t\tMethod m = getMethod();\n\t\t\tbugReporter.reportSkippedAnalysis(DescriptorFactory.instance().getMethodDescriptor(getClassName(), getMethodName(), getMethodSig(), m.isStatic()));\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error checking for dead exception store\", e);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error checking for dead exception store\", e);\n\t\t}\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent, int ifType) {\n        String sysObjectId = agent.getSysObjectId();\n        String hostAddress = agent.getHostAddress();\n        List<MibObject> oidList = DataCollectionConfigFactory.getInstance().getMibObjectList(getName(), sysObjectId, hostAddress, ifType);\n\n        Map groupTypes = new HashMap();\n\n        List<AttributeType> typeList = new LinkedList<AttributeType>();\n        for (MibObject mibObject : oidList) {\n            String instanceName = mibObject.getInstance();\n            AttributeGroupType groupType = getGroup(groupTypes, mibObject);\n            AttributeType attrType = AttributeType.create(getResourceType(agent, instanceName), getName(), mibObject, groupType);\n            groupType.addAttributeType(attrType);\n            typeList.add(attrType);\n        }\n        log().debug(\"getAttributeTypes(\" + agent + \", \" + ifType + \"): \" + typeList);\n        return typeList;\n    }","id":661,"modified_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent, int ifType) {\n        String sysObjectId = agent.getSysObjectId();\n        String hostAddress = agent.getHostAddress();\n        List<MibObject> oidList = getDataCollectionConfig().getMibObjectList(getName(), sysObjectId, hostAddress, ifType);\n\n        Map<String, AttributeGroupType> groupTypes = new HashMap<String, AttributeGroupType>();\n\n        List<AttributeType> typeList = new LinkedList<AttributeType>();\n        for (MibObject mibObject : oidList) {\n            String instanceName = mibObject.getInstance();\n            AttributeGroupType groupType = getGroup(groupTypes, mibObject);\n            AttributeType attrType = AttributeType.create(getResourceType(agent, instanceName), getName(), mibObject, groupType);\n            groupType.addAttributeType(attrType);\n            typeList.add(attrType);\n        }\n        log().debug(\"getAttributeTypes(\" + agent + \", \" + ifType + \"): \" + typeList);\n        return typeList;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Collection getResourceTypes(CollectionAgent agent) {\n        HashSet set = new HashSet(3);\n        set.add(getNodeResourceType(agent));\n        set.add(getIfResourceType(agent));\n        set.add(getIfAliasResourceType(agent));\n        set.addAll(getGenericIndexResourceTypes(agent).values());\n        return set;\n    }","id":662,"modified_method":"private Collection<ResourceType> getResourceTypes(CollectionAgent agent) {\n        HashSet<ResourceType> set = new HashSet<ResourceType>(3);\n        set.add(getNodeResourceType(agent));\n        set.add(getIfResourceType(agent));\n        set.add(getIfAliasResourceType(agent));\n        set.addAll(getGenericIndexResourceTypes(agent).values());\n        return set;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getResources(CollectionAgent agent) {\n        LinkedList resources = new LinkedList();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","id":663,"modified_method":"public Collection<? extends CollectionResource> getResources(CollectionAgent agent) {\n        LinkedList<CollectionResource> resources = new LinkedList<CollectionResource>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsSnmpCollection(CollectionAgent agent, ServiceParameters params) {\n        m_params = params;\n        m_maxVarsPerPdu = determineMaxVarsPerPdu(agent);\n    }","id":664,"modified_method":"public OnmsSnmpCollection(CollectionAgent agent, ServiceParameters params) {\n        this(agent, params, null);\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, ResourceType> getGenericIndexResourceTypes(CollectionAgent agent) {\n        if (m_genericIndexResourceTypes == null) {\n            Collection<org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n                DataCollectionConfigFactory.getInstance().getConfiguredResourceTypes().values();\n            Map<String,ResourceType> resourceTypes = new HashMap<String,ResourceType>();\n            for (org.opennms.netmgt.config.datacollection.ResourceType configuredResourceType : configuredResourceTypes) {\n                resourceTypes.put(configuredResourceType.getName(), new GenericIndexResourceType(agent, this, configuredResourceType));\n            }\n            m_genericIndexResourceTypes = resourceTypes;\n        }\n        return m_genericIndexResourceTypes;\n    }","id":665,"modified_method":"private Map<String, ResourceType> getGenericIndexResourceTypes(CollectionAgent agent) {\n        if (m_genericIndexResourceTypes == null) {\n            Collection<org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n                getDataCollectionConfig().getConfiguredResourceTypes().values();\n            Map<String,ResourceType> resourceTypes = new HashMap<String,ResourceType>();\n            for (org.opennms.netmgt.config.datacollection.ResourceType configuredResourceType : configuredResourceTypes) {\n                resourceTypes.put(configuredResourceType.getName(), new GenericIndexResourceType(agent, this, configuredResourceType));\n            }\n            m_genericIndexResourceTypes = resourceTypes;\n        }\n        return m_genericIndexResourceTypes;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getStorageFlag() {\n        String collectionName = getName();\n        String storageFlag = DataCollectionConfigFactory.getInstance().getSnmpStorageFlag(collectionName);\n        if (storageFlag == null) {\n            if (log().isEnabledFor(Priority.WARN)) {\n                log().warn(\"getStorageFlag: Configuration error, failed to \"\n                           + \"retrieve SNMP storage flag for collection: \"\n                           + collectionName);\n            }\n            storageFlag = SnmpCollector.SNMP_STORAGE_PRIMARY;\n        }\n        return storageFlag;\n    }","id":666,"modified_method":"public String getStorageFlag() {\n        String collectionName = getName();\n        String storageFlag = getDataCollectionConfig().getSnmpStorageFlag(collectionName);\n        if (storageFlag == null) {\n            log().warn(\"getStorageFlag: Configuration error, failed to \"\n                    + \"retrieve SNMP storage flag for collection: \"\n                    + collectionName);\n            storageFlag = SnmpCollector.SNMP_STORAGE_PRIMARY;\n        }\n        return storageFlag;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AttributeGroupType getGroup(Map groupTypes, MibObject mibObject) {\n        AttributeGroupType groupType = (AttributeGroupType) groupTypes.get(mibObject.getGroupName());\n        if (groupType == null) {\n            groupType = new AttributeGroupType(mibObject.getGroupName(), mibObject.getGroupIfType());\n            groupTypes.put(mibObject.getGroupName(), groupType);\n        }\n        return groupType;\n    }","id":667,"modified_method":"private AttributeGroupType getGroup(Map<String, AttributeGroupType> groupTypes, MibObject mibObject) {\n        AttributeGroupType groupType = groupTypes.get(mibObject.getGroupName());\n        if (groupType == null) {\n            groupType = new AttributeGroupType(mibObject.getGroupName(), mibObject.getGroupIfType());\n            groupTypes.put(mibObject.getGroupName(), groupType);\n        }\n        return groupType;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private int determineMaxVarsPerPdu(CollectionAgent agent) {\n        // Retrieve configured value for max number of vars per PDU\n        int maxVarsPerPdu = DataCollectionConfigFactory.getInstance().getMaxVarsPerPdu(getName());\n        if (maxVarsPerPdu == -1) {\n            log().info(\"determineMaxVarsPerPdu: using agent's configured value: \"\n                       + agent.getMaxVarsPerPdu());\n            maxVarsPerPdu = agent.getMaxVarsPerPdu();\n        } else {\n            log().info(\"determineMaxVarsPerPdu: using data collection configured value: \"\n                       + maxVarsPerPdu);\n        }\n        return maxVarsPerPdu;\n    }","id":668,"modified_method":"private int determineMaxVarsPerPdu(CollectionAgent agent) {\n        // Retrieve configured value for max number of vars per PDU\n        int maxVarsPerPdu = getDataCollectionConfig().getMaxVarsPerPdu(getName());\n        if (maxVarsPerPdu == -1) {\n            log().info(\"determineMaxVarsPerPdu: using agent's configured value: \"\n                       + agent.getMaxVarsPerPdu());\n            maxVarsPerPdu = agent.getMaxVarsPerPdu();\n        } else {\n            log().info(\"determineMaxVarsPerPdu: using data collection configured value: \"\n                       + maxVarsPerPdu);\n        }\n        return maxVarsPerPdu;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getAttributeTypes(CollectionAgent agent) {\n        HashSet set = new HashSet();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","id":669,"modified_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent) {\n        HashSet<AttributeType> set = new HashSet<AttributeType>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsSnmpCollection(CollectionAgent agent, ServiceParameters params) {\n        m_params = params;\n        m_maxVarsPerPdu = determineMaxVarsPerPdu(agent);\n    }","id":670,"modified_method":"public OnmsSnmpCollection(CollectionAgent agent, ServiceParameters params) {\n        this(agent, params, null);\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent, int ifType) {\n        String sysObjectId = agent.getSysObjectId();\n        String hostAddress = agent.getHostAddress();\n        List<MibObject> oidList = DataCollectionConfigFactory.getInstance().getMibObjectList(getName(), sysObjectId, hostAddress, ifType);\n\n        Map groupTypes = new HashMap();\n\n        List<AttributeType> typeList = new LinkedList<AttributeType>();\n        for (MibObject mibObject : oidList) {\n            String instanceName = mibObject.getInstance();\n            AttributeGroupType groupType = getGroup(groupTypes, mibObject);\n            AttributeType attrType = AttributeType.create(getResourceType(agent, instanceName), getName(), mibObject, groupType);\n            groupType.addAttributeType(attrType);\n            typeList.add(attrType);\n        }\n        log().debug(\"getAttributeTypes(\" + agent + \", \" + ifType + \"): \" + typeList);\n        return typeList;\n    }","id":671,"modified_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent, int ifType) {\n        String sysObjectId = agent.getSysObjectId();\n        String hostAddress = agent.getHostAddress();\n        List<MibObject> oidList = getDataCollectionConfig().getMibObjectList(getName(), sysObjectId, hostAddress, ifType);\n\n        Map<String, AttributeGroupType> groupTypes = new HashMap<String, AttributeGroupType>();\n\n        List<AttributeType> typeList = new LinkedList<AttributeType>();\n        for (MibObject mibObject : oidList) {\n            String instanceName = mibObject.getInstance();\n            AttributeGroupType groupType = getGroup(groupTypes, mibObject);\n            AttributeType attrType = AttributeType.create(getResourceType(agent, instanceName), getName(), mibObject, groupType);\n            groupType.addAttributeType(attrType);\n            typeList.add(attrType);\n        }\n        log().debug(\"getAttributeTypes(\" + agent + \", \" + ifType + \"): \" + typeList);\n        return typeList;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getAttributeTypes(CollectionAgent agent) {\n        HashSet set = new HashSet();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","id":672,"modified_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent) {\n        HashSet<AttributeType> set = new HashSet<AttributeType>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getResources(CollectionAgent agent) {\n        LinkedList resources = new LinkedList();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","id":673,"modified_method":"public Collection<? extends CollectionResource> getResources(CollectionAgent agent) {\n        LinkedList<CollectionResource> resources = new LinkedList<CollectionResource>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private int determineMaxVarsPerPdu(CollectionAgent agent) {\n        // Retrieve configured value for max number of vars per PDU\n        int maxVarsPerPdu = DataCollectionConfigFactory.getInstance().getMaxVarsPerPdu(getName());\n        if (maxVarsPerPdu == -1) {\n            log().info(\"determineMaxVarsPerPdu: using agent's configured value: \"\n                       + agent.getMaxVarsPerPdu());\n            maxVarsPerPdu = agent.getMaxVarsPerPdu();\n        } else {\n            log().info(\"determineMaxVarsPerPdu: using data collection configured value: \"\n                       + maxVarsPerPdu);\n        }\n        return maxVarsPerPdu;\n    }","id":674,"modified_method":"private int determineMaxVarsPerPdu(CollectionAgent agent) {\n        // Retrieve configured value for max number of vars per PDU\n        int maxVarsPerPdu = getDataCollectionConfig().getMaxVarsPerPdu(getName());\n        if (maxVarsPerPdu == -1) {\n            log().info(\"determineMaxVarsPerPdu: using agent's configured value: \"\n                       + agent.getMaxVarsPerPdu());\n            maxVarsPerPdu = agent.getMaxVarsPerPdu();\n        } else {\n            log().info(\"determineMaxVarsPerPdu: using data collection configured value: \"\n                       + maxVarsPerPdu);\n        }\n        return maxVarsPerPdu;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Collection getResourceTypes(CollectionAgent agent) {\n        HashSet set = new HashSet(3);\n        set.add(getNodeResourceType(agent));\n        set.add(getIfResourceType(agent));\n        set.add(getIfAliasResourceType(agent));\n        set.addAll(getGenericIndexResourceTypes(agent).values());\n        return set;\n    }","id":675,"modified_method":"private Collection<ResourceType> getResourceTypes(CollectionAgent agent) {\n        HashSet<ResourceType> set = new HashSet<ResourceType>(3);\n        set.add(getNodeResourceType(agent));\n        set.add(getIfResourceType(agent));\n        set.add(getIfAliasResourceType(agent));\n        set.addAll(getGenericIndexResourceTypes(agent).values());\n        return set;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, ResourceType> getGenericIndexResourceTypes(CollectionAgent agent) {\n        if (m_genericIndexResourceTypes == null) {\n            Collection<org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n                DataCollectionConfigFactory.getInstance().getConfiguredResourceTypes().values();\n            Map<String,ResourceType> resourceTypes = new HashMap<String,ResourceType>();\n            for (org.opennms.netmgt.config.datacollection.ResourceType configuredResourceType : configuredResourceTypes) {\n                resourceTypes.put(configuredResourceType.getName(), new GenericIndexResourceType(agent, this, configuredResourceType));\n            }\n            m_genericIndexResourceTypes = resourceTypes;\n        }\n        return m_genericIndexResourceTypes;\n    }","id":676,"modified_method":"private Map<String, ResourceType> getGenericIndexResourceTypes(CollectionAgent agent) {\n        if (m_genericIndexResourceTypes == null) {\n            Collection<org.opennms.netmgt.config.datacollection.ResourceType> configuredResourceTypes =\n                getDataCollectionConfig().getConfiguredResourceTypes().values();\n            Map<String,ResourceType> resourceTypes = new HashMap<String,ResourceType>();\n            for (org.opennms.netmgt.config.datacollection.ResourceType configuredResourceType : configuredResourceTypes) {\n                resourceTypes.put(configuredResourceType.getName(), new GenericIndexResourceType(agent, this, configuredResourceType));\n            }\n            m_genericIndexResourceTypes = resourceTypes;\n        }\n        return m_genericIndexResourceTypes;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private AttributeGroupType getGroup(Map groupTypes, MibObject mibObject) {\n        AttributeGroupType groupType = (AttributeGroupType) groupTypes.get(mibObject.getGroupName());\n        if (groupType == null) {\n            groupType = new AttributeGroupType(mibObject.getGroupName(), mibObject.getGroupIfType());\n            groupTypes.put(mibObject.getGroupName(), groupType);\n        }\n        return groupType;\n    }","id":677,"modified_method":"private AttributeGroupType getGroup(Map<String, AttributeGroupType> groupTypes, MibObject mibObject) {\n        AttributeGroupType groupType = groupTypes.get(mibObject.getGroupName());\n        if (groupType == null) {\n            groupType = new AttributeGroupType(mibObject.getGroupName(), mibObject.getGroupIfType());\n            groupTypes.put(mibObject.getGroupName(), groupType);\n        }\n        return groupType;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getStorageFlag() {\n        String collectionName = getName();\n        String storageFlag = DataCollectionConfigFactory.getInstance().getSnmpStorageFlag(collectionName);\n        if (storageFlag == null) {\n            if (log().isEnabledFor(Priority.WARN)) {\n                log().warn(\"getStorageFlag: Configuration error, failed to \"\n                           + \"retrieve SNMP storage flag for collection: \"\n                           + collectionName);\n            }\n            storageFlag = SnmpCollector.SNMP_STORAGE_PRIMARY;\n        }\n        return storageFlag;\n    }","id":678,"modified_method":"public String getStorageFlag() {\n        String collectionName = getName();\n        String storageFlag = getDataCollectionConfig().getSnmpStorageFlag(collectionName);\n        if (storageFlag == null) {\n            log().warn(\"getStorageFlag: Configuration error, failed to \"\n                    + \"retrieve SNMP storage flag for collection: \"\n                    + collectionName);\n            storageFlag = SnmpCollector.SNMP_STORAGE_PRIMARY;\n        }\n        return storageFlag;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static ASTNode findClosestParentNode(int lineNumber, ASTNode node) {\n    Iterator<StructuralPropertyDescriptor> it = node\n        .structuralPropertiesForType().iterator();\n    // Base.loge(\"Props of \" + node.getClass().getName());\n    while (it.hasNext()) {\n      StructuralPropertyDescriptor prop = it.next();\n\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n//            log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n            int cLineNum = ((CompilationUnit) cnode.getRoot())\n                .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n            if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n              return findClosestParentNode(lineNumber, cnode);\n            }\n          }\n        }\n      }\n\n      else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          int cLineNum = ((CompilationUnit) cnode.getRoot())\n              .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n//          log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n          if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n            return findClosestParentNode(lineNumber, cnode);\n          }\n        }\n      }\n    }\n    return node;\n  }","id":679,"modified_method":"protected static ASTNode findClosestParentNode(int lineNumber, ASTNode node) {\n    // Base.loge(\"Props of \" + node.getClass().getName());\n    for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node\n        .structuralPropertiesForType()) {\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n//            log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n            int cLineNum = ((CompilationUnit) cnode.getRoot())\n                .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n            if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n              return findClosestParentNode(lineNumber, cnode);\n            }\n          }\n        }\n      } else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          int cLineNum = ((CompilationUnit) cnode.getRoot())\n              .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n//          log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n          if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n            return findClosestParentNode(lineNumber, cnode);\n          }\n        }\n      }\n    }\n    return node;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Loads classes from .jar files in sketch classpath\n   *\n   * @param typeName\n   * @param child\n   * @param noCompare\n   * @return\n   */\n  public ArrayList<CompletionCandidate> getMembersForType(String typeName,\n                                                          String child,\n                                                          boolean noCompare,\n                                                          boolean staticOnly) {\n\n    ArrayList<CompletionCandidate> candidates = new ArrayList<CompletionCandidate>();\n    log(\"In GMFT(), Looking for match \" + child.toString()\n        + \" in class \" + typeName + \" noCompare \" + noCompare + \" staticOnly \"\n        + staticOnly);\n    Class<?> probableClass = findClassIfExists(typeName);\n    if(probableClass == null){\n      log(\"In GMFT(), class not found.\");\n      return candidates;\n    }\n   return getMembersForType(new ClassMember(probableClass), child, noCompare, staticOnly);\n\n  }","id":680,"modified_method":"/**\n   * Loads classes from .jar files in sketch classpath\n   *\n   * @param typeName\n   * @param child\n   * @param noCompare\n   * @return\n   */\n  public ArrayList<CompletionCandidate> getMembersForType(String typeName,\n                                                          String child,\n                                                          boolean noCompare,\n                                                          boolean staticOnly) {\n\n    ArrayList<CompletionCandidate> candidates = new ArrayList<>();\n    log(\"In GMFT(), Looking for match \" + child\n        + \" in class \" + typeName + \" noCompare \" + noCompare + \" staticOnly \"\n        + staticOnly);\n    Class<?> probableClass = findClassIfExists(typeName);\n    if(probableClass == null){\n      log(\"In GMFT(), class not found.\");\n      return candidates;\n    }\n   return getMembersForType(new ClassMember(probableClass), child, noCompare, staticOnly);\n\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public ASTNode dfsLookForASTNode(ASTNode root, String name, int startOffset,\n                                   int endOffset) {\n//    log(\"dfsLookForASTNode() lookin for \" + name + \" Offsets: \" + startOffset\n//        + \",\" + endOffset);\n    Stack<ASTNode> stack = new Stack<ASTNode>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n      ASTNode node = stack.pop();\n      //log(\"Popped from stack: \" + getNodeAsString(node));\n      Iterator<StructuralPropertyDescriptor> it =\n          node.structuralPropertiesForType().iterator();\n      while (it.hasNext()) {\n        StructuralPropertyDescriptor prop = it.next();\n\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode temp = (ASTNode) node.getStructuralProperty(prop);\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n              if(temp instanceof SimpleName){\n                if(name.equals(temp.toString())){\n//                  log(\"Found simplename: \" + getNodeAsString(temp));\n                  return temp;\n                }\n//                log(\"Bummer, didn't match\");\n              }\n              else\n                stack.push(temp);\n                //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        }\n        else if (prop.isChildListProperty()) {\n          List<ASTNode> nodelist =\n            (List<ASTNode>) node.getStructuralProperty(prop);\n          for (ASTNode temp : nodelist) {\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n                stack.push(temp);\n//                log(\"Pushed onto stack: \" + getNodeAsString(temp));\n                if(temp instanceof SimpleName){\n                  if(name.equals(temp.toString())){\n//                    log(\"Found simplename: \" + getNodeAsString(temp));\n                    return temp;\n                  }\n//                  log(\"Bummer, didn't match\");\n                }\n                else\n                  stack.push(temp);\n                  //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        }\n      }\n    }\n//    log(\"dfsLookForASTNode() not found \" + name);\n    return null;\n  }","id":681,"modified_method":"public ASTNode dfsLookForASTNode(ASTNode root, String name, int startOffset,\n                                   int endOffset) {\n//    log(\"dfsLookForASTNode() lookin for \" + name + \" Offsets: \" + startOffset\n//        + \",\" + endOffset);\n    Stack<ASTNode> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n      ASTNode node = stack.pop();\n      //log(\"Popped from stack: \" + getNodeAsString(node));\n      for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node.structuralPropertiesForType()) {\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode temp = (ASTNode) node.getStructuralProperty(prop);\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n              if (temp instanceof SimpleName) {\n                if (name.equals(temp.toString())) {\n//                  log(\"Found simplename: \" + getNodeAsString(temp));\n                  return temp;\n                }\n//                log(\"Bummer, didn't match\");\n              } else\n                stack.push(temp);\n              //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        } else if (prop.isChildListProperty()) {\n          List<ASTNode> nodelist =\n              (List<ASTNode>) node.getStructuralProperty(prop);\n          for (ASTNode temp : nodelist) {\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n              stack.push(temp);\n//                log(\"Pushed onto stack: \" + getNodeAsString(temp));\n              if (temp instanceof SimpleName) {\n                if (name.equals(temp.toString())) {\n//                    log(\"Found simplename: \" + getNodeAsString(temp));\n                  return temp;\n                }\n//                  log(\"Bummer, didn't match\");\n              } else\n                stack.push(temp);\n              //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        }\n      }\n    }\n//    log(\"dfsLookForASTNode() not found \" + name);\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected static DefaultListModel<CompletionCandidate> filterPredictions(List<CompletionCandidate> candidates){\n    DefaultListModel<CompletionCandidate> defListModel = new DefaultListModel<>();\n    if (candidates.isEmpty())\n      return defListModel;\n    // check if first & last CompCandidate are the same methods, only then show all overloaded methods\n    if (candidates.get(0).getElementName()\n        .equals(candidates.get(candidates.size() - 1).getElementName())) {\n      log(\"All CC are methods only: \" + candidates.get(0).getElementName());\n      for (int i = 0; i < candidates.size(); i++) {\n        candidates.get(i).regenerateCompletionString();\n        defListModel.addElement(candidates.get(i));\n      }\n    }\n    else {\n      boolean ignoredSome = false;\n      for (int i = 0; i < candidates.size(); i++) {\n        if(i > 0 && (candidates.get(i).getElementName()\n            .equals(candidates.get(i - 1).getElementName()))){\n          if (candidates.get(i).getType() == CompletionCandidate.LOCAL_METHOD\n              || candidates.get(i).getType() == CompletionCandidate.PREDEF_METHOD) {\n            CompletionCandidate cc = candidates.get(i - 1);\n            String label = cc.getLabel();\n            int x = label.lastIndexOf(')');\n            if(candidates.get(i).getType() == CompletionCandidate.PREDEF_METHOD) {\n              cc.setLabel((cc.getLabel().contains(\"<html>\") ? \"<html>\" : \"\")\n                          + cc.getElementName() + \"(...)\" + label.substring(x + 1));\n            }\n            else {\n              cc.setLabel(cc.getElementName() + \"(...)\" + label.substring(x + 1));\n            }\n            cc.setCompletionString(cc.getElementName() + \"(\");\n            ignoredSome = true;\n            continue;\n          }\n        }\n        defListModel.addElement(candidates.get(i));\n      }\n      if (ignoredSome) {\n        log(\"Some suggestions hidden\");\n      }\n    }\n    return defListModel;\n  }","id":682,"modified_method":"protected static DefaultListModel<CompletionCandidate> filterPredictions(List<CompletionCandidate> candidates){\n    DefaultListModel<CompletionCandidate> defListModel = new DefaultListModel<>();\n    if (candidates.isEmpty())\n      return defListModel;\n    // check if first & last CompCandidate are the same methods, only then show all overloaded methods\n    if (candidates.get(0).getElementName()\n        .equals(candidates.get(candidates.size() - 1).getElementName())) {\n      log(\"All CC are methods only: \" + candidates.get(0).getElementName());\n      for (CompletionCandidate candidate : candidates) {\n        candidate.regenerateCompletionString();\n        defListModel.addElement(candidate);\n      }\n    }\n    else {\n      boolean ignoredSome = false;\n      for (int i = 0; i < candidates.size(); i++) {\n        if(i > 0 && (candidates.get(i).getElementName()\n            .equals(candidates.get(i - 1).getElementName()))){\n          if (candidates.get(i).getType() == CompletionCandidate.LOCAL_METHOD\n              || candidates.get(i).getType() == CompletionCandidate.PREDEF_METHOD) {\n            CompletionCandidate cc = candidates.get(i - 1);\n            String label = cc.getLabel();\n            int x = label.lastIndexOf(')');\n            if(candidates.get(i).getType() == CompletionCandidate.PREDEF_METHOD) {\n              cc.setLabel((cc.getLabel().contains(\"<html>\") ? \"<html>\" : \"\")\n                          + cc.getElementName() + \"(...)\" + label.substring(x + 1));\n            }\n            else {\n              cc.setLabel(cc.getElementName() + \"(...)\" + label.substring(x + 1));\n            }\n            cc.setCompletionString(cc.getElementName() + \"(\");\n            ignoredSome = true;\n            continue;\n          }\n        }\n        defListModel.addElement(candidates.get(i));\n      }\n      if (ignoredSome) {\n        log(\"Some suggestions hidden\");\n      }\n    }\n    return defListModel;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Give this thing a {@link Name} instance - a {@link SimpleName} from the\n   * ASTNode for ex, and it tries its level best to locate its declaration in\n   * the AST. It really does.\n   *\n   * @param findMe\n   * @return\n   */\n  protected static ASTNode findDeclaration(Name findMe) {\n\n    // WARNING: You're entering the Rube Goldberg territory of Experimental Mode.\n    // To debug this code, thou must take the Recursive Leap of Faith.\n\n    // log(\"entering --findDeclaration1 -- \" + findMe.toString());\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration((qn.getQualifier())));\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n        if (stp == null) {\n          return null;\n        }\n\n        declaringClass = findDeclaration(stp.getName());\n\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration((qnn.getQualifier())));\n          if (stp == null) {\n            return null;\n          }\n          declaringClass = findDeclaration(stp.getName());\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(),\n                           constrains, null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) {\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n      }\n    } else if (parent.getNodeType() == ASTNode.TYPE_DECLARATION) {\n      // The condition where we look up the name of a class decl\n      TypeDeclaration td = (TypeDeclaration) parent;\n      if (findMe.equals(td.getName())) {\n        return parent;\n      }\n\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    }\n//    else if(findMe instanceof QualifiedName){\n//      QualifiedName qn = (QualifiedName) findMe;\n//      System.out\n//          .println(\"findMe is a QN, \"\n//              + (qn.getQualifier().toString() + \" other \" + qn.getName()\n//                  .toString()));\n//    }\n    while (parent != null) {\n//      log(\"findDeclaration1 -> \" + getNodeAsString(parent));\n      for (Object oprop : parent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (parent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(parent));\n            ret = definedIn((ASTNode) parent.getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(parent));\n          List<ASTNode> nodelist = (List<ASTNode>) parent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      parent = parent.getParent();\n    }\n    return null;\n  }","id":683,"modified_method":"/**\n   * Give this thing a {@link Name} instance - a {@link SimpleName} from the\n   * ASTNode for ex, and it tries its level best to locate its declaration in\n   * the AST. It really does.\n   *\n   * @param findMe\n   * @return\n   */\n  protected static ASTNode findDeclaration(Name findMe) {\n\n    // WARNING: You're entering the Rube Goldberg territory of Experimental Mode.\n    // To debug this code, thou must take the Recursive Leap of Faith.\n\n    // log(\"entering --findDeclaration1 -- \" + findMe.toString());\n    ASTNode declaringClass;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret;\n    ArrayList<Integer> constrains = new ArrayList<>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) parent.getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp)\n                .getName()));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration((stp.getName()));\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp)));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration(stp.getName());\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration((qn.getQualifier())));\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n        if (stp == null) {\n          return null;\n        }\n\n        declaringClass = findDeclaration(stp.getName());\n\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration((qnn.getQualifier())));\n          if (stp == null) {\n            return null;\n          }\n          declaringClass = findDeclaration(stp.getName());\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(),\n                           constrains);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) {\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n      }\n    } else if (parent.getNodeType() == ASTNode.TYPE_DECLARATION) {\n      // The condition where we look up the name of a class decl\n      TypeDeclaration td = (TypeDeclaration) parent;\n      if (findMe.equals(td.getName())) {\n        return parent;\n      }\n\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    }\n//    else if(findMe instanceof QualifiedName){\n//      QualifiedName qn = (QualifiedName) findMe;\n//      System.out\n//          .println(\"findMe is a QN, \"\n//              + (qn.getQualifier().toString() + \" other \" + qn.getName()\n//                  .toString()));\n//    }\n    while (parent != null) {\n//      log(\"findDeclaration1 -> \" + getNodeAsString(parent));\n      for (Object oprop : parent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (parent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(parent));\n            ret = definedIn((ASTNode) parent.getStructuralProperty(prop),\n                            findMe.toString(), constrains);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(parent));\n          List<ASTNode> nodelist = (List<ASTNode>) parent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      parent = parent.getParent();\n    }\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public int javaCodeOffsetToLineStartOffset(int line, int jOffset){\n    // Find the first node with this line number, return its offset - jOffset\n    line = pdeLineNumToJavaLineNum(line);\n    log(\"Looking for line: \" + line + \", jOff \" + jOffset);\n    Stack<DefaultMutableTreeNode> temp = new Stack<DefaultMutableTreeNode>();\n    temp.push(codeTree);\n\n    while (!temp.isEmpty()) {\n      DefaultMutableTreeNode cnode = temp.pop();\n      for (int i = 0; i < cnode.getChildCount(); i++) {\n        temp.push((DefaultMutableTreeNode) cnode.getChildAt(i));\n      }\n\n      if (!(cnode.getUserObject() instanceof ASTNodeWrapper))\n        continue;\n      ASTNodeWrapper awnode = (ASTNodeWrapper) cnode.getUserObject();\n//      log(\"Visiting: \" + getNodeAsString(awnode.getNode()));\n      if (awnode.getLineNumber() == line) {\n        log(\"First element with this line no is: \" + awnode\n            + \"LSO: \" + (jOffset - awnode.getNode().getStartPosition()));\n        return (jOffset - awnode.getNode().getStartPosition());\n      }\n    }\n    return -1;\n  }","id":684,"modified_method":"public int javaCodeOffsetToLineStartOffset(int line, int jOffset){\n    // Find the first node with this line number, return its offset - jOffset\n    line = pdeLineNumToJavaLineNum(line);\n    log(\"Looking for line: \" + line + \", jOff \" + jOffset);\n    Stack<DefaultMutableTreeNode> temp = new Stack<>();\n    temp.push(codeTree);\n\n    while (!temp.isEmpty()) {\n      DefaultMutableTreeNode cnode = temp.pop();\n      for (int i = 0; i < cnode.getChildCount(); i++) {\n        temp.push((DefaultMutableTreeNode) cnode.getChildAt(i));\n      }\n\n      if (!(cnode.getUserObject() instanceof ASTNodeWrapper))\n        continue;\n      ASTNodeWrapper awnode = (ASTNodeWrapper) cnode.getUserObject();\n//      log(\"Visiting: \" + getNodeAsString(awnode.getNode()));\n      if (awnode.getLineNumber() == line) {\n        log(\"First element with this line no is: \" + awnode\n            + \"LSO: \" + (jOffset - awnode.getNode().getStartPosition()));\n        return (jOffset - awnode.getNode().getStartPosition());\n      }\n    }\n    return -1;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"static void loadJavaDoc(TreeMap<String, String> jdocMap,\n                          File referenceFolder) throws IOException, MalformedURLException {\n    Document doc;\n\n    FileFilter fileFilter = new FileFilter() {\n      public boolean accept(File file) {\n        if(!file.getName().endsWith(\"_.html\"))\n          return false;\n        int k = 0;\n        for (int i = 0; i < file.getName().length(); i++) {\n          if(file.getName().charAt(i)== '_')\n            k++;\n          if(k > 1)\n            return false;\n        }\n        return true;\n      }\n    };\n\n    for (File docFile : referenceFolder.listFiles(fileFilter)) {\n      doc = Jsoup.parse(docFile, null);\n      Elements elm = doc.getElementsByClass(\"ref-item\");\n      String msg = \"\";\n      String methodName = docFile.getName().substring(0, docFile.getName().indexOf('_'));\n      //System.out.println(methodName);\n      for (Iterator<org.jsoup.nodes.Element> it = elm.iterator(); it.hasNext();) {\n        org.jsoup.nodes.Element ele = it.next();\n        msg = \"<html><body> <strong><div style=\\\"width: 300px; text-justification: justify;\\\"><\/strong><table cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" border=\\\"0\\\" class=\\\"ref-item\\\">\"\n            + ele.html() + \"<\/table><\/div><\/html><\/body><\/html>\";\n        //mat.replaceAll(\"\");\n        msg = msg.replaceAll(\"img src=\\\"\", \"img src=\\\"\"\n            + referenceFolder.toURI().toURL().toString() + \"/\");\n        //System.out.println(ele.text());\n      }\n      jdocMap.put(methodName, msg);\n    }\n    System.out.println(\"JDoc loaded \" + jdocMap.size());\n  }","id":685,"modified_method":"static void loadJavaDoc(TreeMap<String, String> jdocMap,\n                          File referenceFolder) throws IOException {\n    Document doc;\n\n    FileFilter fileFilter = new FileFilter() {\n      @Override\n      public boolean accept(File file) {\n        if(!file.getName().endsWith(\"_.html\"))\n          return false;\n        int k = 0;\n        for (int i = 0; i < file.getName().length(); i++) {\n          if(file.getName().charAt(i)== '_')\n            k++;\n          if(k > 1)\n            return false;\n        }\n        return true;\n      }\n    };\n\n    for (File docFile : referenceFolder.listFiles(fileFilter)) {\n      doc = Jsoup.parse(docFile, null);\n      Elements elm = doc.getElementsByClass(\"ref-item\");\n      String msg = \"\";\n      String methodName = docFile.getName().substring(0, docFile.getName().indexOf('_'));\n      //System.out.println(methodName);\n      for (org.jsoup.nodes.Element ele : elm) {\n        msg = \"<html><body> <strong><div style=\\\"width: 300px; text-justification: justify;\\\"><\/strong><table cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" border=\\\"0\\\" class=\\\"ref-item\\\">\"\n            + ele.html() + \"<\/table><\/div><\/html><\/body><\/html>\";\n        //mat.replaceAll(\"\");\n        msg = msg.replaceAll(\"img src=\\\"\", \"img src=\\\"\"\n            + referenceFolder.toURI().toURL().toString() + \"/\");\n        //System.out.println(ele.text());\n      }\n      jdocMap.put(methodName, msg);\n    }\n    System.out.println(\"JDoc loaded \" + jdocMap.size());\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected DefaultMutableTreeNode findAllOccurrences(){\n    final JEditTextArea ta = editor.getTextArea();\n\n    log(\"Last clicked word:\" + lastClickedWord);\n    String selText = lastClickedWord == null ? ta.getSelectedText() :\n        lastClickedWord;\n    int line = ta.getSelectionStartLine();\n    log(selText\n        + \"<- offsets \"\n        + (line)\n        + \", \"\n        + (ta.getSelectionStart() - ta.getLineStartOffset(line))\n        + \", \"\n        + (ta.getSelectionStop() - ta.getLineStartOffset(line)));\n    int offwhitespace = ta.getLineStartNonWhiteSpaceOffset(line);\n    ASTNodeWrapper wnode;\n    if (lastClickedWord == null || lastClickedWordNode.getNode() == null) {\n      wnode = getASTNodeAt(line + errorCheckerService.mainClassOffset, selText,\n                           ta.getSelectionStart() - offwhitespace, false);\n    }\n    else{\n      wnode = lastClickedWordNode;\n    }\n    if(wnode.getNode() == null){\n      return null;\n    }\n    Messages.loge(\"Gonna find all occurrences of \" + getNodeAsString(wnode.getNode()));\n\n    //If wnode is a constructor, find the TD instead.\n    if (wnode.getNodeType() == ASTNode.METHOD_DECLARATION) {\n      MethodDeclaration md = (MethodDeclaration) wnode.getNode();\n      ASTNode node = md.getParent();\n      while (node != null) {\n        if (node instanceof TypeDeclaration) {\n          // log(\"Parent class \" + getNodeAsString(node));\n          break;\n        }\n        node = node.getParent();\n      }\n      if(node != null && node instanceof TypeDeclaration){\n        TypeDeclaration td = (TypeDeclaration) node;\n        if(td.getName().toString().equals(md.getName().toString())){\n          Messages.loge(\"Renaming constructor of \" + getNodeAsString(td));\n          wnode = new ASTNodeWrapper(td);\n        }\n      }\n    }\n\n    DefaultMutableTreeNode defCU =\n      new DefaultMutableTreeNode(new ASTNodeWrapper(wnode.getNode(), selText));\n    dfsNameOnly(defCU, wnode.getNode(), selText);\n\n    // Reverse the list obtained via dfs\n    Stack<Object> tempS = new Stack<Object>();\n    for (int i = 0; i < defCU.getChildCount(); i++) {\n      tempS.push(defCU.getChildAt(i));\n    }\n    defCU.removeAllChildren();\n    while (!tempS.isEmpty()) {\n      defCU.add((MutableTreeNode) tempS.pop());\n    }\n    log(wnode);\n\n    return defCU;\n  }","id":686,"modified_method":"protected DefaultMutableTreeNode findAllOccurrences(){\n    final JEditTextArea ta = editor.getTextArea();\n\n    log(\"Last clicked word:\" + lastClickedWord);\n    String selText = lastClickedWord == null ? ta.getSelectedText() :\n        lastClickedWord;\n    int line = ta.getSelectionStartLine();\n    log(selText\n        + \"<- offsets \"\n        + (line)\n        + \", \"\n        + (ta.getSelectionStart() - ta.getLineStartOffset(line))\n        + \", \"\n        + (ta.getSelectionStop() - ta.getLineStartOffset(line)));\n    int offwhitespace = ta.getLineStartNonWhiteSpaceOffset(line);\n    ASTNodeWrapper wnode;\n    if (lastClickedWord == null || lastClickedWordNode.getNode() == null) {\n      wnode = getASTNodeAt(line + errorCheckerService.mainClassOffset, selText,\n                           ta.getSelectionStart() - offwhitespace, false);\n    }\n    else{\n      wnode = lastClickedWordNode;\n    }\n    if(wnode.getNode() == null){\n      return null;\n    }\n    Messages.loge(\"Gonna find all occurrences of \" + getNodeAsString(wnode.getNode()));\n\n    //If wnode is a constructor, find the TD instead.\n    if (wnode.getNodeType() == ASTNode.METHOD_DECLARATION) {\n      MethodDeclaration md = (MethodDeclaration) wnode.getNode();\n      ASTNode node = md.getParent();\n      while (node != null) {\n        if (node instanceof TypeDeclaration) {\n          // log(\"Parent class \" + getNodeAsString(node));\n          break;\n        }\n        node = node.getParent();\n      }\n      if(node != null && node instanceof TypeDeclaration){\n        TypeDeclaration td = (TypeDeclaration) node;\n        if(td.getName().toString().equals(md.getName().toString())){\n          Messages.loge(\"Renaming constructor of \" + getNodeAsString(td));\n          wnode = new ASTNodeWrapper(td);\n        }\n      }\n    }\n\n    DefaultMutableTreeNode defCU =\n      new DefaultMutableTreeNode(new ASTNodeWrapper(wnode.getNode(), selText));\n    dfsNameOnly(defCU, wnode.getNode(), selText);\n\n    // Reverse the list obtained via dfs\n    Stack<Object> tempS = new Stack<>();\n    for (int i = 0; i < defCU.getChildCount(); i++) {\n      tempS.push(defCU.getChildAt(i));\n    }\n    defCU.removeAllChildren();\n    while (!tempS.isEmpty()) {\n      defCU.add((MutableTreeNode) tempS.pop());\n    }\n    log(wnode);\n\n    return defCU;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Given a word(identifier) in pde code, finds its location in the ASTNode\n   * @param lineNumber\n   * @param name\n   * @param offset - line start nonwhitespace offset\n   * @param scrollOnly\n   * @return\n   */\n  public ASTNodeWrapper getASTNodeAt(int lineNumber, String name, int offset,\n                                     boolean scrollOnly) {\n\n    // Convert tab based pde line number to actual line number\n    int pdeLineNumber = lineNumber + errorCheckerService.mainClassOffset;\n//    log(\"----getASTNodeAt---- CU State: \"\n//        + errorCheckerService.compilationUnitState);\n    if (errorCheckerService != null) {\n      editor = errorCheckerService.getEditor();\n      int codeIndex = editor.getSketch().getCodeIndex(editor.getCurrentTab());\n      if (codeIndex > 0) {\n        for (int i = 0; i < codeIndex; i++) {\n          SketchCode sc = editor.getSketch().getCode(i);\n          int len = Util.countLines(sc.getProgram()) + 1;\n          pdeLineNumber += len;\n        }\n      }\n\n    }\n\n    // Find closest ASTNode to the linenumber\n//    log(\"getASTNodeAt: Node line number \" + pdeLineNumber);\n    ASTNode lineNode = findLineOfNode(compilationUnit, pdeLineNumber, offset,\n                                      name);\n\n//    log(\"Node text +> \" + lineNode);\n    ASTNode decl = null;\n    String nodeLabel = null;\n    String nameOfNode = null; // The node name which is to be scrolled to\n\n    // Obtain correspondin java code at that line, match offsets\n    if (lineNode != null) {\n      String pdeCodeLine = errorCheckerService.getPdeCodeAtLine(editor\n          .getSketch().getCurrentCodeIndex(), lineNumber);\n      String javaCodeLine = getJavaSourceCodeLine(pdeLineNumber);\n\n//      log(lineNumber + \" Original Line num.\\nPDE :\" + pdeCodeLine);\n//      log(\"JAVA:\" + javaCodeLine);\n//      log(\"Clicked on: \" + name + \" start offset: \" + offset);\n      // Calculate expected java offset based on the pde line\n      OffsetMatcher ofm = new OffsetMatcher(pdeCodeLine, javaCodeLine);\n      int javaOffset = ofm.getJavaOffForPdeOff(offset, name.length())\n          + lineNode.getStartPosition();\n//      log(\"JAVA ast offset: \" + (javaOffset));\n\n      // Find the corresponding node in the AST\n      ASTNode simpName = dfsLookForASTNode(errorCheckerService.getLatestCU(),\n                                           name, javaOffset,\n                                           javaOffset + name.length());\n\n      // If node wasn't found in the AST, lineNode may contain something\n      if (simpName == null && lineNode instanceof SimpleName) {\n        switch (lineNode.getParent().getNodeType()) {\n        case ASTNode.TYPE_DECLARATION:\n\n        case ASTNode.METHOD_DECLARATION:\n\n        case ASTNode.FIELD_DECLARATION:\n\n        case ASTNode.VARIABLE_DECLARATION_FRAGMENT:\n          decl = lineNode.getParent();\n          return new ASTNodeWrapper(decl, \"\");\n        default:\n          break;\n        }\n      }\n\n      // SimpleName instance found, now find its declaration in code\n      if (simpName instanceof SimpleName) {\n        nameOfNode = simpName.toString();\n        // log(getNodeAsString(simpName));\n        decl = findDeclaration((SimpleName) simpName);\n        if (decl != null) {\n//          Base.loge(\"DECLA: \" + decl.getClass().getName());\n          nodeLabel = getLabelIfType(new ASTNodeWrapper(decl),\n                                     (SimpleName) simpName);\n          //retLabelString = getNodeAsString(decl);\n        } else {\n          if (scrollOnly) {\n            editor.statusMessage(simpName + \" is not defined in this sketch\",\n                                 EditorStatus.ERROR);\n          }\n        }\n\n//        log(getNodeAsString(decl));\n\n        /*\n        // - findDecl3 testing\n\n        ASTNode nearestNode = findClosestNode(lineNumber,\n                                              (ASTNode) compilationUnit.types()\n                                                  .get(0));\n        ClassMember cmem = resolveExpression3rdParty(nearestNode,\n                                                     (SimpleName) simpName,\n                                                     false);\n        if (cmem != null) {\n          log(\"CMEM-> \" + cmem);\n        } else\n          log(\"CMEM-> null\");\n        */\n      }\n    }\n\n    if (decl != null && scrollOnly) {\n      /*\n       * For scrolling, we highlight just the name of the node, i.e., a\n       * SimpleName instance. But the declared node always points to the\n       * declared node itself, like TypeDecl, MethodDecl, etc. This is important\n       * since it contains all the properties.\n       */\n      ASTNode simpName2 = getNodeName(decl, nameOfNode);\n//      Base.loge(\"FINAL String decl: \" + getNodeAsString(decl));\n//      Base.loge(\"FINAL String label: \" + getNodeAsString(simpName2));\n      //errorCheckerService.highlightNode(simpName2);\n      ASTNodeWrapper declWrap = new ASTNodeWrapper(simpName2, nodeLabel);\n      //errorCheckerService.highlightNode(declWrap);\n      if (!declWrap.highlightNode(editor)) {\n        Messages.loge(\"Highlighting failed.\");\n      }\n    }\n\n    // Return the declaration wrapped as ASTNodeWrapper\n    return new ASTNodeWrapper(decl, nodeLabel);\n  }","id":687,"modified_method":"/**\n   * Given a word(identifier) in pde code, finds its location in the ASTNode\n   * @param lineNumber\n   * @param name\n   * @param offset - line start nonwhitespace offset\n   * @param scrollOnly\n   * @return\n   */\n  public ASTNodeWrapper getASTNodeAt(int lineNumber, String name, int offset,\n                                     boolean scrollOnly) {\n\n    // Convert tab based pde line number to actual line number\n    int pdeLineNumber = lineNumber + errorCheckerService.mainClassOffset;\n//    log(\"----getASTNodeAt---- CU State: \"\n//        + errorCheckerService.compilationUnitState);\n    editor = errorCheckerService.getEditor();\n    int codeIndex = editor.getSketch().getCodeIndex(editor.getCurrentTab());\n    if (codeIndex > 0) {\n      for (int i = 0; i < codeIndex; i++) {\n        SketchCode sc = editor.getSketch().getCode(i);\n        int len = Util.countLines(sc.getProgram()) + 1;\n        pdeLineNumber += len;\n      }\n    }\n\n    // Find closest ASTNode to the linenumber\n//    log(\"getASTNodeAt: Node line number \" + pdeLineNumber);\n    ASTNode lineNode = findLineOfNode(compilationUnit, pdeLineNumber, offset,\n                                      name);\n\n//    log(\"Node text +> \" + lineNode);\n    ASTNode decl = null;\n    String nodeLabel = null;\n    String nameOfNode = null; // The node name which is to be scrolled to\n\n    // Obtain correspondin java code at that line, match offsets\n    if (lineNode != null) {\n      String pdeCodeLine = errorCheckerService.getPdeCodeAtLine(editor\n          .getSketch().getCurrentCodeIndex(), lineNumber);\n      String javaCodeLine = getJavaSourceCodeLine(pdeLineNumber);\n\n//      log(lineNumber + \" Original Line num.\\nPDE :\" + pdeCodeLine);\n//      log(\"JAVA:\" + javaCodeLine);\n//      log(\"Clicked on: \" + name + \" start offset: \" + offset);\n      // Calculate expected java offset based on the pde line\n      OffsetMatcher ofm = new OffsetMatcher(pdeCodeLine, javaCodeLine);\n      int javaOffset = ofm.getJavaOffForPdeOff(offset, name.length())\n          + lineNode.getStartPosition();\n//      log(\"JAVA ast offset: \" + (javaOffset));\n\n      // Find the corresponding node in the AST\n      ASTNode simpName = dfsLookForASTNode(errorCheckerService.getLatestCU(),\n                                           name, javaOffset,\n                                           javaOffset + name.length());\n\n      // If node wasn't found in the AST, lineNode may contain something\n      if (simpName == null && lineNode instanceof SimpleName) {\n        switch (lineNode.getParent().getNodeType()) {\n        case ASTNode.TYPE_DECLARATION:\n\n        case ASTNode.METHOD_DECLARATION:\n\n        case ASTNode.FIELD_DECLARATION:\n\n        case ASTNode.VARIABLE_DECLARATION_FRAGMENT:\n          decl = lineNode.getParent();\n          return new ASTNodeWrapper(decl, \"\");\n        default:\n          break;\n        }\n      }\n\n      // SimpleName instance found, now find its declaration in code\n      if (simpName instanceof SimpleName) {\n        nameOfNode = simpName.toString();\n        // log(getNodeAsString(simpName));\n        decl = findDeclaration((SimpleName) simpName);\n        if (decl != null) {\n//          Base.loge(\"DECLA: \" + decl.getClass().getName());\n          nodeLabel = getLabelIfType(new ASTNodeWrapper(decl),\n                                     (SimpleName) simpName);\n          //retLabelString = getNodeAsString(decl);\n        } else {\n          if (scrollOnly) {\n            editor.statusMessage(simpName + \" is not defined in this sketch\",\n                                 EditorStatus.ERROR);\n          }\n        }\n\n//        log(getNodeAsString(decl));\n\n        /*\n        // - findDecl3 testing\n\n        ASTNode nearestNode = findClosestNode(lineNumber,\n                                              (ASTNode) compilationUnit.types()\n                                                  .get(0));\n        ClassMember cmem = resolveExpression3rdParty(nearestNode,\n                                                     (SimpleName) simpName,\n                                                     false);\n        if (cmem != null) {\n          log(\"CMEM-> \" + cmem);\n        } else\n          log(\"CMEM-> null\");\n        */\n      }\n    }\n\n    if (decl != null && scrollOnly) {\n      /*\n       * For scrolling, we highlight just the name of the node, i.e., a\n       * SimpleName instance. But the declared node always points to the\n       * declared node itself, like TypeDecl, MethodDecl, etc. This is important\n       * since it contains all the properties.\n       */\n      ASTNode simpName2 = getNodeName(decl, nameOfNode);\n//      Base.loge(\"FINAL String decl: \" + getNodeAsString(decl));\n//      Base.loge(\"FINAL String label: \" + getNodeAsString(simpName2));\n      //errorCheckerService.highlightNode(simpName2);\n      ASTNodeWrapper declWrap = new ASTNodeWrapper(simpName2, nodeLabel);\n      //errorCheckerService.highlightNode(declWrap);\n      if (!declWrap.highlightNode(editor)) {\n        Messages.loge(\"Highlighting failed.\");\n      }\n    }\n\n    // Return the declaration wrapped as ASTNodeWrapper\n    return new ASTNodeWrapper(decl, nodeLabel);\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected void refactorIt(){\n    String newName = txtRenameField.getText().trim();\n    String selText = lastClickedWord == null ? getSelectedText()\n        : lastClickedWord;\n    // Find all occurrences of last clicked word\n    DefaultMutableTreeNode defCU = findAllOccurrences(); //TODO: Repetition here\n    if(defCU == null){\n      editor.statusMessage(\"Can't locate definition of \" + selText,\n                           EditorStatus.ERROR);\n      return;\n    }\n\n    // Verify if the new name is a valid java identifier\n    if(!newName.matches(\"([a-zA-Z][a-zA-Z0-9_]*)|([_][a-zA-Z0-9_]+)\"))\n    {\n      JOptionPane.showConfirmDialog(new JFrame(), newName\n          + \" isn't a valid name.\", \"Uh oh..\", JOptionPane.PLAIN_MESSAGE);\n      return;\n    }\n    //else log(\"New name looks K.\");\n\n    errorCheckerService.cancel();\n    if(refactorTree.isVisible()){\n      refactorTree.setModel(new DefaultTreeModel(defCU));\n      ((DefaultTreeModel) refactorTree.getModel()).reload();\n    }\n//    frmOccurenceList.setTitle(\"Usage of \\\"\" + selText + \"\\\" : \"\n//        + defCU.getChildCount() + \" time(s)\");\n//    frmOccurenceList.setLocation(editor.getX() + editor.getWidth(),editor.getY());\n//    frmOccurenceList.setVisible(true);\n    int lineOffsetDisplacementConst = newName.length()\n        - selText.length();\n    HashMap<Integer, Integer> lineOffsetDisplacement = new HashMap<Integer, Integer>();\n\n    // I need to store the pde and java offsets beforehand because once\n    // the replace starts, all offsets returned are affected\n    //int offsetsMap[][][] = new int[defCU.getChildCount()][2][];\n    int pdeOffsets[][] = new int[defCU.getChildCount()][3];\n    for (int i = 0; i < defCU.getChildCount(); i++) {\n      ASTNodeWrapper awrap = (ASTNodeWrapper) ((DefaultMutableTreeNode) (defCU\n          .getChildAt(i))).getUserObject();\n      int ans[] = errorCheckerService.calculateTabIndexAndLineNumber(awrap\n          .getLineNumber());\n      pdeOffsets[i][0] = ans[0];\n      pdeOffsets[i][1] = ans[1];\n      pdeOffsets[i][2] = awrap.getPDECodeOffsetForSN(this);\n    }\n\n    editor.startCompoundEdit();\n    for (int i = 0; i < defCU.getChildCount(); i++) {\n      ASTNodeWrapper awrap = (ASTNodeWrapper) ((DefaultMutableTreeNode) (defCU\n          .getChildAt(i))).getUserObject();\n      // correction for pde enhancements related displacement on a line\n      int off = 0;\n      if (lineOffsetDisplacement.get(awrap.getLineNumber()) != null) {\n        off = lineOffsetDisplacement.get(awrap.getLineNumber());\n\n        lineOffsetDisplacement.put(awrap.getLineNumber(),\n                                   lineOffsetDisplacementConst + off);\n      } else {\n        lineOffsetDisplacement.put(awrap.getLineNumber(),\n                                   lineOffsetDisplacementConst);\n      }\n//      Base.loge(getNodeAsString(awrap.getNode()) + \", T:\" + pdeOffsets[i][0]\n//          + \", L:\" + pdeOffsets[i][1] + \", O:\" + pdeOffsets[i][2]);\n      highlightPDECode(pdeOffsets[i][0],\n                       pdeOffsets[i][1], pdeOffsets[i][2]\n                           + off, awrap.getNode()\n                           .toString().length());\n      //int k = JOptionPane.showConfirmDialog(new JFrame(), \"Rename?\",\"\", JOptionPane.INFORMATION_MESSAGE);\n      editor.getTextArea().setSelectedText(newName);\n    }\n    editor.stopCompoundEdit();\n    errorCheckerService.request();\n    editor.getSketch().setModified(true);\n    errorCheckerService.request();\n//    frmOccurenceList.setVisible(false);\n    frmRename.setVisible(false);\n    lastClickedWord = null;\n    lastClickedWordNode = null;\n  }","id":688,"modified_method":"protected void refactorIt(){\n    String newName = txtRenameField.getText().trim();\n    String selText = lastClickedWord == null ? getSelectedText()\n        : lastClickedWord;\n    // Find all occurrences of last clicked word\n    DefaultMutableTreeNode defCU = findAllOccurrences(); //TODO: Repetition here\n    if(defCU == null){\n      editor.statusMessage(\"Can't locate definition of \" + selText,\n                           EditorStatus.ERROR);\n      return;\n    }\n\n    // Verify if the new name is a valid java identifier\n    if(!newName.matches(\"([a-zA-Z][a-zA-Z0-9_]*)|([_][a-zA-Z0-9_]+)\"))\n    {\n      JOptionPane.showConfirmDialog(new JFrame(), newName\n          + \" isn't a valid name.\", \"Uh oh..\", JOptionPane.PLAIN_MESSAGE);\n      return;\n    }\n    //else log(\"New name looks K.\");\n\n    errorCheckerService.cancel();\n    if(refactorTree.isVisible()){\n      refactorTree.setModel(new DefaultTreeModel(defCU));\n      ((DefaultTreeModel) refactorTree.getModel()).reload();\n    }\n//    frmOccurenceList.setTitle(\"Usage of \\\"\" + selText + \"\\\" : \"\n//        + defCU.getChildCount() + \" time(s)\");\n//    frmOccurenceList.setLocation(editor.getX() + editor.getWidth(),editor.getY());\n//    frmOccurenceList.setVisible(true);\n    int lineOffsetDisplacementConst = newName.length()\n        - selText.length();\n    HashMap<Integer, Integer> lineOffsetDisplacement = new HashMap<>();\n\n    // I need to store the pde and java offsets beforehand because once\n    // the replace starts, all offsets returned are affected\n    //int offsetsMap[][][] = new int[defCU.getChildCount()][2][];\n    int pdeOffsets[][] = new int[defCU.getChildCount()][3];\n    for (int i = 0; i < defCU.getChildCount(); i++) {\n      ASTNodeWrapper awrap = (ASTNodeWrapper) ((DefaultMutableTreeNode) (defCU\n          .getChildAt(i))).getUserObject();\n      int ans[] = errorCheckerService.calculateTabIndexAndLineNumber(awrap\n          .getLineNumber());\n      pdeOffsets[i][0] = ans[0];\n      pdeOffsets[i][1] = ans[1];\n      pdeOffsets[i][2] = awrap.getPDECodeOffsetForSN(this);\n    }\n\n    editor.startCompoundEdit();\n    for (int i = 0; i < defCU.getChildCount(); i++) {\n      ASTNodeWrapper awrap = (ASTNodeWrapper) ((DefaultMutableTreeNode) (defCU\n          .getChildAt(i))).getUserObject();\n      // correction for pde enhancements related displacement on a line\n      int off = 0;\n      if (lineOffsetDisplacement.get(awrap.getLineNumber()) != null) {\n        off = lineOffsetDisplacement.get(awrap.getLineNumber());\n\n        lineOffsetDisplacement.put(awrap.getLineNumber(),\n                                   lineOffsetDisplacementConst + off);\n      } else {\n        lineOffsetDisplacement.put(awrap.getLineNumber(),\n                                   lineOffsetDisplacementConst);\n      }\n//      Base.loge(getNodeAsString(awrap.getNode()) + \", T:\" + pdeOffsets[i][0]\n//          + \", L:\" + pdeOffsets[i][1] + \", O:\" + pdeOffsets[i][2]);\n      highlightPDECode(pdeOffsets[i][0],\n                       pdeOffsets[i][1], pdeOffsets[i][2]\n                           + off, awrap.getNode()\n                           .toString().length());\n      //int k = JOptionPane.showConfirmDialog(new JFrame(), \"Rename?\",\"\", JOptionPane.INFORMATION_MESSAGE);\n      editor.getTextArea().setSelectedText(newName);\n    }\n    editor.stopCompoundEdit();\n    errorCheckerService.request();\n    editor.getSketch().setModified(true);\n    errorCheckerService.request();\n//    frmOccurenceList.setVisible(false);\n    frmRename.setVisible(false);\n    lastClickedWord = null;\n    lastClickedWordNode = null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public void disposeAllWindows() {\n    disposeWindow(frmASTView, frameAutoComp, frmImportSuggest,\n                  frmOccurenceList, frmRename);\n  }","id":689,"modified_method":"public void disposeAllWindows() {\n    disposeWindow(frmASTView, frmImportSuggest,\n                  frmOccurenceList, frmRename);\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * A variation of findDeclaration() but accepts an alternate parent ASTNode\n   * @param findMe\n   * @param alternateParent\n   * @return\n   */\n  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n\n          if (stp == null) {\n            return null;\n          }\n\n//          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n//          log(\"QN decl class: \"\n//              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains,\n                           null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    } // TODO: in findDec, we also have a case where parent of type TD is handled.\n      // Figure out if needed here as well.\n//    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n//      log(\"findDeclaration2 -> \"\n//          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }","id":690,"modified_method":"/**\n   * A variation of findDeclaration() but accepts an alternate parent ASTNode\n   * @param findMe\n   * @param alternateParent\n   * @return\n   */\n  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret;\n    ArrayList<Integer> constrains = new ArrayList<>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) parent.getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      // Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"MI EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n//          log(\"FA EXP: \" + exp.toString() + \" of type \"\n//              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); // Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n//        log(qn.getQualifier() + \"->\" + qn.getName());\n//        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n//          log(\"findMe is a QN, \"\n//              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n//                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n\n          if (stp == null) {\n            return null;\n          }\n\n//          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n//          log(\"QN decl class: \"\n//              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n//      constrains.add(ASTNode.TYPE_DECLARATION);\n//      constrains.add(ASTNode.METHOD_DECLARATION);\n//      constrains.add(ASTNode.FIELD_DECLARATION);\n    } // TODO: in findDec, we also have a case where parent of type TD is handled.\n      // Figure out if needed here as well.\n//    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n//      log(\"findDeclaration2 -> \"\n//          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n//            log(prop + \" C/S Prop of -> \"\n//                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n//          log((prop) + \" ChildList props of \"\n//              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public ClassMember definedIn3rdPartyClass(ClassMember tehClass,String memberName){\n    if(tehClass == null)\n      return null;\n    log(\"definedIn3rdPartyClass-> Looking for \" + memberName\n        + \" in \" + tehClass);\n    String memberNameL = memberName.toLowerCase();\n    if (tehClass.getDeclaringNode() instanceof TypeDeclaration) {\n\n      TypeDeclaration td = (TypeDeclaration) tehClass.getDeclaringNode();\n      for (int i = 0; i < td.getFields().length; i++) {\n        List<VariableDeclarationFragment> vdfs =\n          td.getFields()[i].fragments();\n        for (VariableDeclarationFragment vdf : vdfs) {\n          if (vdf.getName().toString().toLowerCase()\n              .startsWith(memberNameL))\n            return new ClassMember(vdf);\n        }\n\n      }\n      for (int i = 0; i < td.getMethods().length; i++) {\n       if (td.getMethods()[i].getName().toString().toLowerCase()\n            .startsWith(memberNameL))\n         return new ClassMember(td.getMethods()[i]);\n      }\n      if (td.getSuperclassType() != null) {\n        log(getNodeAsString(td.getSuperclassType()) + \" <-Looking into superclass of \" + tehClass);\n        return definedIn3rdPartyClass(new ClassMember(td\n                                                     .getSuperclassType()),memberName);\n      } else {\n        return definedIn3rdPartyClass(new ClassMember(Object.class),memberName);\n      }\n    }\n\n    Class<?> probableClass = null;\n    if (tehClass.getClass_() != null) {\n      probableClass = tehClass.getClass_();\n    } else {\n      probableClass = findClassIfExists(tehClass.getTypeAsString());\n      log(\"Loaded \" + probableClass.toString());\n    }\n    for (Method method : probableClass.getMethods()) {\n      if (method.getName().equalsIgnoreCase(memberName)) {\n        return new ClassMember(method);\n      }\n    }\n    for (Field field : probableClass.getFields()) {\n      if (field.getName().equalsIgnoreCase(memberName)) {\n        return new ClassMember(field);\n      }\n    }\n    return null;\n  }","id":691,"modified_method":"public ClassMember definedIn3rdPartyClass(ClassMember tehClass,String memberName){\n    if(tehClass == null)\n      return null;\n    log(\"definedIn3rdPartyClass-> Looking for \" + memberName\n        + \" in \" + tehClass);\n    String memberNameL = memberName.toLowerCase();\n    if (tehClass.getDeclaringNode() instanceof TypeDeclaration) {\n\n      TypeDeclaration td = (TypeDeclaration) tehClass.getDeclaringNode();\n      for (int i = 0; i < td.getFields().length; i++) {\n        List<VariableDeclarationFragment> vdfs =\n          td.getFields()[i].fragments();\n        for (VariableDeclarationFragment vdf : vdfs) {\n          if (vdf.getName().toString().toLowerCase()\n              .startsWith(memberNameL))\n            return new ClassMember(vdf);\n        }\n\n      }\n      for (int i = 0; i < td.getMethods().length; i++) {\n       if (td.getMethods()[i].getName().toString().toLowerCase()\n            .startsWith(memberNameL))\n         return new ClassMember(td.getMethods()[i]);\n      }\n      if (td.getSuperclassType() != null) {\n        log(getNodeAsString(td.getSuperclassType()) + \" <-Looking into superclass of \" + tehClass);\n        return definedIn3rdPartyClass(new ClassMember(td\n                                                     .getSuperclassType()),memberName);\n      } else {\n        return definedIn3rdPartyClass(new ClassMember(Object.class),memberName);\n      }\n    }\n\n    Class<?> probableClass;\n    if (tehClass.getClass_() != null) {\n      probableClass = tehClass.getClass_();\n    } else {\n      probableClass = findClassIfExists(tehClass.getTypeAsString());\n      log(\"Loaded \" + probableClass.toString());\n    }\n    for (Method method : probableClass.getMethods()) {\n      if (method.getName().equalsIgnoreCase(memberName)) {\n        return new ClassMember(method);\n      }\n    }\n    for (Field field : probableClass.getFields()) {\n      if (field.getName().equalsIgnoreCase(memberName)) {\n        return new ClassMember(field);\n      }\n    }\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected DefaultMutableTreeNode buildAST(String source, CompilationUnit cu) {\n    if (cu == null) {\n      ASTParser parser = ASTParser.newParser(AST.JLS8);\n      parser.setSource(source.toCharArray());\n      parser.setKind(ASTParser.K_COMPILATION_UNIT);\n\n      Map<String, String> options = JavaCore.getOptions();\n\n      JavaCore.setComplianceOptions(JavaCore.VERSION_1_8, options);\n      options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_8);\n      parser.setCompilerOptions(options);\n      compilationUnit = (CompilationUnit) parser.createAST(null);\n    } else {\n      compilationUnit = cu;\n      //log(\"Other cu\");\n    }\n//    OutlineVisitor visitor = new OutlineVisitor();\n//    compilationUnit.accept(visitor);\n    getCodeComments();\n    codeTree = new DefaultMutableTreeNode(new ASTNodeWrapper((ASTNode) compilationUnit\n                                              .types().get(0)));\n    //log(\"Total CU \" + compilationUnit.types().size());\n    if(compilationUnit.types() == null || compilationUnit.types().isEmpty()){\n      Messages.loge(\"No CU found!\");\n    }\n    visitRecur((ASTNode) compilationUnit.types().get(0), codeTree);\n    SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n      @Override\n      protected Object doInBackground() throws Exception {\n        return null;\n      }\n\n      protected void done() {\n        if (codeTree != null) {\n          if(SHOW_AST){\n  \t\t\t\t\tif (jtree.hasFocus() || frmASTView.hasFocus())\n  \t\t\t\t\t\treturn;\n            jtree.setModel(new DefaultTreeModel(codeTree));\n            ((DefaultTreeModel) jtree.getModel()).reload();\n            jtree.validate();\n            if (!frmASTView.isVisible()) {\n              frmASTView.setVisible(true);\n            }\n          }\n//          if (!frameAutoComp.isVisible()) {\n//\n//            frameAutoComp.setVisible(true);\n//\n//          }\n//          if (!frmJavaDoc.isVisible()) {\n//            long t = System.currentTimeMillis();\n//            loadJavaDoc();\n//            log(\"Time taken: \"\n//                + (System.currentTimeMillis() - t));\n//            frmJavaDoc.setBounds(new Rectangle(errorCheckerService.getEditor()\n//                .getX() + errorCheckerService.getEditor().getWidth(),\n//                                               errorCheckerService.getEditor()\n//                                                   .getY(), 450, 600));\n//            frmJavaDoc.setVisible(true);\n//          }\n        }\n      }\n    };\n    worker.execute();\n//    Base.loge(\"++>\" + System.getProperty(\"java.class.path\"));\n//    log(System.getProperty(\"java.class.path\"));\n//    log(\"-------------------------------\");\n    return codeTree;\n  }","id":692,"modified_method":"protected DefaultMutableTreeNode buildAST(String source, CompilationUnit cu) {\n    if (cu == null) {\n      ASTParser parser = ASTParser.newParser(AST.JLS8);\n      parser.setSource(source.toCharArray());\n      parser.setKind(ASTParser.K_COMPILATION_UNIT);\n\n      Map<String, String> options = JavaCore.getOptions();\n\n      JavaCore.setComplianceOptions(JavaCore.VERSION_1_8, options);\n      options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_8);\n      parser.setCompilerOptions(options);\n      compilationUnit = (CompilationUnit) parser.createAST(null);\n    } else {\n      compilationUnit = cu;\n      //log(\"Other cu\");\n    }\n//    OutlineVisitor visitor = new OutlineVisitor();\n//    compilationUnit.accept(visitor);\n    getCodeComments();\n    codeTree = new DefaultMutableTreeNode(new ASTNodeWrapper((ASTNode) compilationUnit\n                                              .types().get(0)));\n    //log(\"Total CU \" + compilationUnit.types().size());\n    if(compilationUnit.types() == null || compilationUnit.types().isEmpty()){\n      Messages.loge(\"No CU found!\");\n    }\n    visitRecur((ASTNode) compilationUnit.types().get(0), codeTree);\n    SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n      @Override\n      protected Object doInBackground() throws Exception {\n        return null;\n      }\n\n      @Override\n      protected void done() {\n        if (codeTree != null) {\n          if(SHOW_AST){\n  \t\t\t\t\tif (jtree.hasFocus() || frmASTView.hasFocus())\n  \t\t\t\t\t\treturn;\n            jtree.setModel(new DefaultTreeModel(codeTree));\n            ((DefaultTreeModel) jtree.getModel()).reload();\n            jtree.validate();\n            if (!frmASTView.isVisible()) {\n              frmASTView.setVisible(true);\n            }\n          }\n//          if (!frameAutoComp.isVisible()) {\n//\n//            frameAutoComp.setVisible(true);\n//\n//          }\n//          if (!frmJavaDoc.isVisible()) {\n//            long t = System.currentTimeMillis();\n//            loadJavaDoc();\n//            log(\"Time taken: \"\n//                + (System.currentTimeMillis() - t));\n//            frmJavaDoc.setBounds(new Rectangle(errorCheckerService.getEditor()\n//                .getX() + errorCheckerService.getEditor().getWidth(),\n//                                               errorCheckerService.getEditor()\n//                                                   .getY(), 450, 600));\n//            frmJavaDoc.setVisible(true);\n//          }\n        }\n      }\n    };\n    worker.execute();\n//    Base.loge(\"++>\" + System.getProperty(\"java.class.path\"));\n//    log(System.getProperty(\"java.class.path\"));\n//    log(\"-------------------------------\");\n    return codeTree;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public static void printRecur(ASTNode node) {\n    Iterator<StructuralPropertyDescriptor> it = node\n        .structuralPropertiesForType().iterator();\n    //Base.loge(\"Props of \" + node.getClass().getName());\n    while (it.hasNext()) {\n      StructuralPropertyDescriptor prop = it.next();\n\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n            log(getNodeAsString(cnode));\n            printRecur(cnode);\n          }\n        }\n      }\n\n      else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          log(getNodeAsString(cnode));\n          printRecur(cnode);\n        }\n      }\n    }\n  }","id":693,"modified_method":"public static void printRecur(ASTNode node) {\n    //Base.loge(\"Props of \" + node.getClass().getName());\n    for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node\n        .structuralPropertiesForType()) {\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n            log(getNodeAsString(cnode));\n            printRecur(cnode);\n          }\n        }\n      } else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          log(getNodeAsString(cnode));\n          printRecur(cnode);\n        }\n      }\n    }\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"static protected ASTNode definedIn(ASTNode node, String name,\n                                   ArrayList<Integer> constrains,\n                                   ASTNode declaringClass) {\n    if (node == null)\n      return null;\n    if (constrains != null) {\n//      log(\"Looking at \" + getNodeAsString(node) + \" for \" + name\n//          + \" in definedIn\");\n      if (!constrains.contains(node.getNodeType()) && constrains.size() > 0) {\n//        System.err.print(\"definedIn -1 \" + \" But constrain was \");\n//        for (Integer integer : constrains) {\n//          System.out.print(ASTNode.nodeClassForType(integer) + \",\");\n//        }\n//        log();\n        return null;\n      }\n    }\n\n    List<VariableDeclarationFragment> vdfList = null;\n    switch (node.getNodeType()) {\n\n    case ASTNode.TYPE_DECLARATION:\n      //Base.loge(getNodeAsString(node));\n      TypeDeclaration td = (TypeDeclaration) node;\n      if (td.getName().toString().equals(name)) {\n        if (constrains.contains(ASTNode.CLASS_INSTANCE_CREATION)) {\n          // look for constructor;\n          MethodDeclaration[] methods = td.getMethods();\n          for (MethodDeclaration md : methods) {\n            if (md.getName().toString().equalsIgnoreCase(name)) {\n              log(\"Found a constructor.\");\n              return md;\n            }\n          }\n        } else {\n          // it's just the TD we're lookin for\n          return node;\n        }\n      } else {\n        if (constrains.contains(ASTNode.FIELD_DECLARATION)) {\n          // look for fields\n          FieldDeclaration[] fields = td.getFields();\n          for (FieldDeclaration fd : fields) {\n            List<VariableDeclarationFragment> fragments = fd.fragments();\n            for (VariableDeclarationFragment vdf : fragments) {\n              if (vdf.getName().toString().equalsIgnoreCase(name))\n                return fd;\n            }\n          }\n        } else if (constrains.contains(ASTNode.METHOD_DECLARATION)) {\n          // look for methods\n          MethodDeclaration[] methods = td.getMethods();\n          for (MethodDeclaration md : methods) {\n            if (md.getName().toString().equalsIgnoreCase(name)) {\n              return md;\n            }\n          }\n        }\n      }\n      break;\n    case ASTNode.METHOD_DECLARATION:\n      //Base.loge(getNodeAsString(node));\n      if (((MethodDeclaration) node).getName().toString().equalsIgnoreCase(name))\n        return node;\n      break;\n    case ASTNode.SINGLE_VARIABLE_DECLARATION:\n      //Base.loge(getNodeAsString(node));\n      if (((SingleVariableDeclaration) node).getName().toString().equalsIgnoreCase(name))\n        return node;\n      break;\n    case ASTNode.FIELD_DECLARATION:\n      //Base.loge(\"FD\" + node);\n      vdfList = ((FieldDeclaration) node).fragments();\n      break;\n    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:\n      //Base.loge(\"VDE\" + node);\n      vdfList = ((VariableDeclarationExpression) node).fragments();\n      break;\n    case ASTNode.VARIABLE_DECLARATION_STATEMENT:\n      //Base.loge(\"VDS\" + node);\n      vdfList = ((VariableDeclarationStatement) node).fragments();\n      break;\n\n    default:\n\n    }\n    if (vdfList != null) {\n      for (VariableDeclarationFragment vdf : vdfList) {\n        if (vdf.getName().toString().equalsIgnoreCase(name))\n          return node;\n      }\n    }\n    return null;\n  }","id":694,"modified_method":"static protected ASTNode definedIn(ASTNode node, String name,\n                                   ArrayList<Integer> constrains) {\n    if (node == null)\n      return null;\n    if (constrains != null) {\n//      log(\"Looking at \" + getNodeAsString(node) + \" for \" + name\n//          + \" in definedIn\");\n      if (!constrains.contains(node.getNodeType()) && constrains.size() > 0) {\n//        System.err.print(\"definedIn -1 \" + \" But constrain was \");\n//        for (Integer integer : constrains) {\n//          System.out.print(ASTNode.nodeClassForType(integer) + \",\");\n//        }\n//        log();\n        return null;\n      }\n    }\n\n    List<VariableDeclarationFragment> vdfList = null;\n    switch (node.getNodeType()) {\n\n    case ASTNode.TYPE_DECLARATION:\n      //Base.loge(getNodeAsString(node));\n      TypeDeclaration td = (TypeDeclaration) node;\n      if (td.getName().toString().equals(name)) {\n        if (constrains.contains(ASTNode.CLASS_INSTANCE_CREATION)) {\n          // look for constructor;\n          MethodDeclaration[] methods = td.getMethods();\n          for (MethodDeclaration md : methods) {\n            if (md.getName().toString().equalsIgnoreCase(name)) {\n              log(\"Found a constructor.\");\n              return md;\n            }\n          }\n        } else {\n          // it's just the TD we're lookin for\n          return node;\n        }\n      } else {\n        if (constrains.contains(ASTNode.FIELD_DECLARATION)) {\n          // look for fields\n          FieldDeclaration[] fields = td.getFields();\n          for (FieldDeclaration fd : fields) {\n            List<VariableDeclarationFragment> fragments = fd.fragments();\n            for (VariableDeclarationFragment vdf : fragments) {\n              if (vdf.getName().toString().equalsIgnoreCase(name))\n                return fd;\n            }\n          }\n        } else if (constrains.contains(ASTNode.METHOD_DECLARATION)) {\n          // look for methods\n          MethodDeclaration[] methods = td.getMethods();\n          for (MethodDeclaration md : methods) {\n            if (md.getName().toString().equalsIgnoreCase(name)) {\n              return md;\n            }\n          }\n        }\n      }\n      break;\n    case ASTNode.METHOD_DECLARATION:\n      //Base.loge(getNodeAsString(node));\n      if (((MethodDeclaration) node).getName().toString().equalsIgnoreCase(name))\n        return node;\n      break;\n    case ASTNode.SINGLE_VARIABLE_DECLARATION:\n      //Base.loge(getNodeAsString(node));\n      if (((SingleVariableDeclaration) node).getName().toString().equalsIgnoreCase(name))\n        return node;\n      break;\n    case ASTNode.FIELD_DECLARATION:\n      //Base.loge(\"FD\" + node);\n      vdfList = ((FieldDeclaration) node).fragments();\n      break;\n    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:\n      //Base.loge(\"VDE\" + node);\n      vdfList = ((VariableDeclarationExpression) node).fragments();\n      break;\n    case ASTNode.VARIABLE_DECLARATION_STATEMENT:\n      //Base.loge(\"VDS\" + node);\n      vdfList = ((VariableDeclarationStatement) node).fragments();\n      break;\n\n    default:\n\n    }\n    if (vdfList != null) {\n      for (VariableDeclarationFragment vdf : vdfList) {\n        if (vdf.getName().toString().equalsIgnoreCase(name))\n          return node;\n      }\n    }\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public ArrayList<CompletionCandidate> getMembersForType(ClassMember tehClass,\n                                                          String childToLookFor,\n                                                          boolean noCompare,\n                                                          boolean staticOnly) {\n    String child = childToLookFor.toLowerCase();\n    ArrayList<CompletionCandidate> candidates = new ArrayList<>();\n    log(\"getMemFoType-> Looking for match \" + child.toString()\n        + \" inside \" + tehClass + \" noCompare \" + noCompare + \" staticOnly \"\n        + staticOnly);\n    if(tehClass == null){\n      return candidates;\n    }\n    // tehClass will either be a TypeDecl defined locally\n    if(tehClass.getDeclaringNode() instanceof TypeDeclaration){\n      TypeDeclaration td = (TypeDeclaration) tehClass.getDeclaringNode();\n      {\n        FieldDeclaration[] fields = td.getFields();\n        for (int i = 0; i < fields.length; i++) {\n          if (staticOnly && !isStatic(fields[i].modifiers())) {\n            continue;\n          }\n          List<VariableDeclarationFragment> vdfs = fields[i].fragments();\n          for (VariableDeclarationFragment vdf : vdfs) {\n            if (noCompare) {\n              candidates.add(new CompletionCandidate(vdf));\n            } else if (vdf.getName().toString().toLowerCase().startsWith(child))\n              candidates.add(new CompletionCandidate(vdf));\n          }\n        }\n      }\n      {\n        MethodDeclaration[] methods = td.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n          if (staticOnly && !isStatic(methods[i].modifiers())) {\n            continue;\n          }\n          if (noCompare) {\n            candidates.add(new CompletionCandidate(methods[i]));\n          } else if (methods[i].getName().toString().toLowerCase()\n              .startsWith(child))\n            candidates.add(new CompletionCandidate(methods[i]));\n        }\n      }\n\n      ArrayList<CompletionCandidate> superClassCandidates = new ArrayList<CompletionCandidate>();\n      if(td.getSuperclassType() != null){\n        log(getNodeAsString(td.getSuperclassType()) + \" <-Looking into superclass of \" + tehClass);\n        superClassCandidates = getMembersForType(new ClassMember(td\n                                                     .getSuperclassType()),\n                                                 childToLookFor, noCompare, staticOnly);\n      }\n      else\n      {\n        superClassCandidates = getMembersForType(new ClassMember(Object.class),\n                                                 childToLookFor, noCompare, staticOnly);\n      }\n      for (CompletionCandidate cc : superClassCandidates) {\n        candidates.add(cc);\n      }\n      return candidates;\n    }\n\n    // Or tehClass will be a predefined class\n\n    Class<?> probableClass;\n    if (tehClass.getClass_() != null) {\n      probableClass = tehClass.getClass_();\n    } else {\n      probableClass = findClassIfExists(tehClass.getTypeAsString());\n      if (probableClass == null) {\n        log(\"Couldn't find class \" + tehClass.getTypeAsString());\n        return candidates;\n      }\n      log(\"Loaded \" + probableClass.toString());\n    }\n    for (Method method : probableClass.getMethods()) {\n      if (!Modifier.isStatic(method.getModifiers()) && staticOnly) {\n        continue;\n      }\n\n      StringBuilder label = new StringBuilder(method.getName() + \"(\");\n      for (int i = 0; i < method.getParameterTypes().length; i++) {\n        label.append(method.getParameterTypes()[i].getSimpleName());\n        if (i < method.getParameterTypes().length - 1)\n          label.append(\",\");\n      }\n      label.append(\")\");\n      if (noCompare) {\n        candidates.add(new CompletionCandidate(method));\n      } else if (label.toString().toLowerCase().startsWith(child)) {\n        candidates.add(new CompletionCandidate(method));\n      }\n    }\n    for (Field field : probableClass.getFields()) {\n      if (!Modifier.isStatic(field.getModifiers()) && staticOnly) {\n        continue;\n      }\n      if (noCompare) {\n        candidates.add(new CompletionCandidate(field));\n      } else if (field.getName().toLowerCase().startsWith(child)) {\n        candidates.add(new CompletionCandidate(field));\n      }\n    }\n    if (probableClass.isArray() && !staticOnly) {\n      // add array members manually, they can't be fetched through code\n\n      String className = probableClass.getSimpleName();\n\n      if (noCompare || \"clone()\".startsWith(child)) {\n        String methodLabel = \"<html>clone() : \" + className +\n            \" - <font color=#777777>\" + className + \"<\/font><\/html>\";\n        candidates.add(new CompletionCandidate(\"clone()\", methodLabel, \"clone()\",\n                                               CompletionCandidate.PREDEF_METHOD));\n      }\n\n      if (\"length\".startsWith(child)) {\n        String fieldLabel = \"<html>length : int - <font color=#777777>\" +\n            className + \"<\/font><\/html>\";\n        candidates.add(new CompletionCandidate(\"length\", fieldLabel, \"length\",\n                                               CompletionCandidate.PREDEF_FIELD));\n      }\n    }\n    return candidates;\n  }","id":695,"modified_method":"public ArrayList<CompletionCandidate> getMembersForType(ClassMember tehClass,\n                                                          String childToLookFor,\n                                                          boolean noCompare,\n                                                          boolean staticOnly) {\n    String child = childToLookFor.toLowerCase();\n    ArrayList<CompletionCandidate> candidates = new ArrayList<>();\n    log(\"getMemFoType-> Looking for match \" + child\n        + \" inside \" + tehClass + \" noCompare \" + noCompare + \" staticOnly \"\n        + staticOnly);\n    if(tehClass == null){\n      return candidates;\n    }\n    // tehClass will either be a TypeDecl defined locally\n    if(tehClass.getDeclaringNode() instanceof TypeDeclaration){\n      TypeDeclaration td = (TypeDeclaration) tehClass.getDeclaringNode();\n      {\n        FieldDeclaration[] fields = td.getFields();\n        for (FieldDeclaration field : fields) {\n          if (staticOnly && !isStatic(field.modifiers())) {\n            continue;\n          }\n          List<VariableDeclarationFragment> vdfs = field.fragments();\n          for (VariableDeclarationFragment vdf : vdfs) {\n            if (noCompare) {\n              candidates.add(new CompletionCandidate(vdf));\n            } else if (vdf.getName().toString().toLowerCase().startsWith(child))\n              candidates.add(new CompletionCandidate(vdf));\n          }\n        }\n      }\n      {\n        MethodDeclaration[] methods = td.getMethods();\n        for (MethodDeclaration method : methods) {\n          if (staticOnly && !isStatic(method.modifiers())) {\n            continue;\n          }\n          if (noCompare) {\n            candidates.add(new CompletionCandidate(method));\n          } else if (method.getName().toString().toLowerCase()\n              .startsWith(child))\n            candidates.add(new CompletionCandidate(method));\n        }\n      }\n\n      ArrayList<CompletionCandidate> superClassCandidates;\n      if(td.getSuperclassType() != null){\n        log(getNodeAsString(td.getSuperclassType()) + \" <-Looking into superclass of \" + tehClass);\n        superClassCandidates = getMembersForType(new ClassMember(td\n                                                     .getSuperclassType()),\n                                                 childToLookFor, noCompare, staticOnly);\n      }\n      else\n      {\n        superClassCandidates = getMembersForType(new ClassMember(Object.class),\n                                                 childToLookFor, noCompare, staticOnly);\n      }\n      for (CompletionCandidate cc : superClassCandidates) {\n        candidates.add(cc);\n      }\n      return candidates;\n    }\n\n    // Or tehClass will be a predefined class\n\n    Class<?> probableClass;\n    if (tehClass.getClass_() != null) {\n      probableClass = tehClass.getClass_();\n    } else {\n      probableClass = findClassIfExists(tehClass.getTypeAsString());\n      if (probableClass == null) {\n        log(\"Couldn't find class \" + tehClass.getTypeAsString());\n        return candidates;\n      }\n      log(\"Loaded \" + probableClass.toString());\n    }\n    for (Method method : probableClass.getMethods()) {\n      if (!Modifier.isStatic(method.getModifiers()) && staticOnly) {\n        continue;\n      }\n\n      StringBuilder label = new StringBuilder(method.getName() + \"(\");\n      for (int i = 0; i < method.getParameterTypes().length; i++) {\n        label.append(method.getParameterTypes()[i].getSimpleName());\n        if (i < method.getParameterTypes().length - 1)\n          label.append(\",\");\n      }\n      label.append(\")\");\n      if (noCompare) {\n        candidates.add(new CompletionCandidate(method));\n      } else if (label.toString().toLowerCase().startsWith(child)) {\n        candidates.add(new CompletionCandidate(method));\n      }\n    }\n    for (Field field : probableClass.getFields()) {\n      if (!Modifier.isStatic(field.getModifiers()) && staticOnly) {\n        continue;\n      }\n      if (noCompare) {\n        candidates.add(new CompletionCandidate(field));\n      } else if (field.getName().toLowerCase().startsWith(child)) {\n        candidates.add(new CompletionCandidate(field));\n      }\n    }\n    if (probableClass.isArray() && !staticOnly) {\n      // add array members manually, they can't be fetched through code\n\n      String className = probableClass.getSimpleName();\n\n      if (noCompare || \"clone()\".startsWith(child)) {\n        String methodLabel = \"<html>clone() : \" + className +\n            \" - <font color=#777777>\" + className + \"<\/font><\/html>\";\n        candidates.add(new CompletionCandidate(\"clone()\", methodLabel, \"clone()\",\n                                               CompletionCandidate.PREDEF_METHOD));\n      }\n\n      if (\"length\".startsWith(child)) {\n        String fieldLabel = \"<html>length : int - <font color=#777777>\" +\n            className + \"<\/font><\/html>\";\n        candidates.add(new CompletionCandidate(\"length\", fieldLabel, \"length\",\n                                               CompletionCandidate.PREDEF_FIELD));\n      }\n    }\n    return candidates;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public void suggestImports(final String className){\n    if (ignoredImportSuggestions == null) {\n      ignoredImportSuggestions = new TreeSet<String>();\n    } else {\n      if(ignoredImportSuggestions.contains(className)) {\n        log(\"Ignoring import suggestions for \" + className);\n        return;\n      }\n    }\n    if (frmImportSuggest != null) {\n      if (frmImportSuggest.isVisible()) {\n        return;\n      }\n    }\n    log(\"Looking for class \" + className);\n    RegExpResourceFilter regf =\n      new RegExpResourceFilter(Pattern.compile(\".*\"),\n                               Pattern.compile(className + \".class\",\n                                               Pattern.CASE_INSENSITIVE));\n    String[] resources = classPath.findResources(\"\", regf);\n    ArrayList<String> candidates = new ArrayList<String>();\n    for (String res : resources) {\n      candidates.add(res);\n    }\n\n    // log(\"Couldn't find import for class \" + className);\n\n    for (Library lib : editor.getMode().contribLibraries) {\n      ClassPath cp = factory.createFromPath(lib.getClassPath());\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    if (editor.getSketch().hasCodeFolder()) {\n      File codeFolder = editor.getSketch().getCodeFolder();\n      // get a list of .jar files in the \"code\" folder\n      // (class files in subfolders should also be picked up)\n      ClassPath cp =\n        factory.createFromPath(Util.contentsToClassPath(codeFolder));\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    resources = new String[candidates.size()];\n    for (int i = 0; i < resources.length; i++) {\n      resources[i] = candidates.get(i).replace('/', '.')\n          .substring(0, candidates.get(i).length() - 6);\n    }\n    if (resources.length >= 1) {\n      final JList<String> classList = new JList<String>(resources);\n      classList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n      frmImportSuggest = new JFrame();\n      frmImportSuggest.setSize(350, 200);\n      Toolkit.setIcon(frmImportSuggest);\n      frmImportSuggest.setLayout(new BoxLayout(frmImportSuggest\n          .getContentPane(), BoxLayout.Y_AXIS));\n      ((JComponent) frmImportSuggest.getContentPane()).setBorder(BorderFactory\n          .createEmptyBorder(5, 5, 5, 5));\n      JLabel lbl = new JLabel(\"<html>The class \\\"\" + className\n          + \"\\\" couldn't be determined. You are probably missing one of the following imports:<\/html>\");\n      JScrollPane jsp = new JScrollPane();\n      jsp.setViewportView(classList);\n      JButton btnInsertImport = new JButton(\"Insert import\");\n      btnInsertImport.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent evt) {\n          if (classList.getSelectedValue() != null) {\n            try {\n              String impString = \"import \" + classList.getSelectedValue()\n                  + \";\\n\";\n              int ct = editor.getSketch().getCurrentCodeIndex();\n              editor.getSketch().setCurrentCode(0);\n              editor.getTextArea().getDocument().insertString(0, impString, null);\n              editor.getSketch().setCurrentCode(ct);\n              errorCheckerService.request();\n              frmImportSuggest.setVisible(false);\n              frmImportSuggest = null;\n            } catch (BadLocationException e) {\n              log(\"Failed to insert import for \" + className);\n              e.printStackTrace();\n            }\n          }\n        }\n      });\n\n      JButton btnCancel = new JButton(\"Cancel\");\n      btnCancel.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          frmImportSuggest.setVisible(false);\n        }\n      });\n\n      JPanel panelTop = new JPanel(), panelBottom = new JPanel(), panelLabel = new JPanel();\n      panelTop.setLayout(new BoxLayout(panelTop, BoxLayout.Y_AXIS));\n      panelTop.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n      panelLabel.setLayout(new BorderLayout());\n      panelLabel.add(lbl,BorderLayout.CENTER);\n      panelTop.add(panelLabel);\n      panelTop.add(Box.createRigidArea(new Dimension(1, 5)));\n      panelTop.add(jsp);\n      panelBottom.setLayout(new BoxLayout(panelBottom, BoxLayout.X_AXIS));\n      panelBottom.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n      panelBottom .setLayout(new BoxLayout(panelBottom, BoxLayout.X_AXIS));\n      panelBottom.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n      panelBottom.add(Box.createHorizontalGlue());\n      panelBottom.add(btnInsertImport);\n      panelBottom.add(Box.createRigidArea(new Dimension(15, 0)));\n      panelBottom.add(btnCancel);\n      JButton btnIgnore = new JButton(\"Ignore \\\"\" + className + \"\\\"\");\n      btnIgnore.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          ignoredImportSuggestions.add(className);\n          frmImportSuggest.setVisible(false);\n        }\n      });\n      panelBottom.add(Box.createRigidArea(new Dimension(15, 0)));\n      panelBottom.add(btnIgnore);\n\n//      frmImportSuggest.add(lbl);\n//      frmImportSuggest.add(jsp);\n//      frmImportSuggest.add(btnInsertImport);\n      frmImportSuggest.add(panelTop);\n      frmImportSuggest.add(panelBottom);\n      frmImportSuggest.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);\n      frmImportSuggest.setTitle(\"Import Suggestion\");\n      frmImportSuggest.setLocation(editor.getX()\n                            + (editor.getWidth() - frmImportSuggest.getWidth()) / 2,\n                        editor.getY()\n                            + (editor.getHeight() - frmImportSuggest.getHeight())\n                            / 2);\n      hideSuggestion();\n      classList.setSelectedIndex(0);\n      frmImportSuggest.setVisible(true);\n    }\n  }","id":696,"modified_method":"public void suggestImports(final String className){\n    if (ignoredImportSuggestions == null) {\n      ignoredImportSuggestions = new TreeSet<>();\n    } else {\n      if(ignoredImportSuggestions.contains(className)) {\n        log(\"Ignoring import suggestions for \" + className);\n        return;\n      }\n    }\n    if (frmImportSuggest != null) {\n      if (frmImportSuggest.isVisible()) {\n        return;\n      }\n    }\n    log(\"Looking for class \" + className);\n    RegExpResourceFilter regf =\n      new RegExpResourceFilter(Pattern.compile(\".*\"),\n                               Pattern.compile(className + \".class\",\n                                               Pattern.CASE_INSENSITIVE));\n    String[] resources = classPath.findResources(\"\", regf);\n    ArrayList<String> candidates = new ArrayList<>();\n    Collections.addAll(candidates, resources);\n\n    // log(\"Couldn't find import for class \" + className);\n\n    for (Library lib : editor.getMode().contribLibraries) {\n      ClassPath cp = factory.createFromPath(lib.getClassPath());\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    if (editor.getSketch().hasCodeFolder()) {\n      File codeFolder = editor.getSketch().getCodeFolder();\n      // get a list of .jar files in the \"code\" folder\n      // (class files in subfolders should also be picked up)\n      ClassPath cp =\n        factory.createFromPath(Util.contentsToClassPath(codeFolder));\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    resources = new String[candidates.size()];\n    for (int i = 0; i < resources.length; i++) {\n      resources[i] = candidates.get(i).replace('/', '.')\n          .substring(0, candidates.get(i).length() - 6);\n    }\n    if (resources.length >= 1) {\n      final JList<String> classList = new JList<>(resources);\n      classList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n      frmImportSuggest = new JFrame();\n      frmImportSuggest.setSize(350, 200);\n      Toolkit.setIcon(frmImportSuggest);\n      frmImportSuggest.setLayout(new BoxLayout(frmImportSuggest\n          .getContentPane(), BoxLayout.Y_AXIS));\n      ((JComponent) frmImportSuggest.getContentPane()).setBorder(BorderFactory\n          .createEmptyBorder(5, 5, 5, 5));\n      JLabel lbl = new JLabel(\"<html>The class \\\"\" + className\n          + \"\\\" couldn't be determined. You are probably missing one of the following imports:<\/html>\");\n      JScrollPane jsp = new JScrollPane();\n      jsp.setViewportView(classList);\n      JButton btnInsertImport = new JButton(\"Insert import\");\n      btnInsertImport.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent evt) {\n          if (classList.getSelectedValue() != null) {\n            try {\n              String impString = \"import \" + classList.getSelectedValue()\n                  + \";\\n\";\n              int ct = editor.getSketch().getCurrentCodeIndex();\n              editor.getSketch().setCurrentCode(0);\n              editor.getTextArea().getDocument().insertString(0, impString, null);\n              editor.getSketch().setCurrentCode(ct);\n              errorCheckerService.request();\n              frmImportSuggest.setVisible(false);\n              frmImportSuggest = null;\n            } catch (BadLocationException e) {\n              log(\"Failed to insert import for \" + className);\n              e.printStackTrace();\n            }\n          }\n        }\n      });\n\n      JButton btnCancel = new JButton(\"Cancel\");\n      btnCancel.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          frmImportSuggest.setVisible(false);\n        }\n      });\n\n      JPanel panelTop = new JPanel(), panelBottom = new JPanel(), panelLabel = new JPanel();\n      panelTop.setLayout(new BoxLayout(panelTop, BoxLayout.Y_AXIS));\n      panelTop.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n      panelLabel.setLayout(new BorderLayout());\n      panelLabel.add(lbl,BorderLayout.CENTER);\n      panelTop.add(panelLabel);\n      panelTop.add(Box.createRigidArea(new Dimension(1, 5)));\n      panelTop.add(jsp);\n      panelBottom.setLayout(new BoxLayout(panelBottom, BoxLayout.X_AXIS));\n      panelBottom.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n      panelBottom .setLayout(new BoxLayout(panelBottom, BoxLayout.X_AXIS));\n      panelBottom.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n      panelBottom.add(Box.createHorizontalGlue());\n      panelBottom.add(btnInsertImport);\n      panelBottom.add(Box.createRigidArea(new Dimension(15, 0)));\n      panelBottom.add(btnCancel);\n      JButton btnIgnore = new JButton(\"Ignore \\\"\" + className + \"\\\"\");\n      btnIgnore.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          ignoredImportSuggestions.add(className);\n          frmImportSuggest.setVisible(false);\n        }\n      });\n      panelBottom.add(Box.createRigidArea(new Dimension(15, 0)));\n      panelBottom.add(btnIgnore);\n\n//      frmImportSuggest.add(lbl);\n//      frmImportSuggest.add(jsp);\n//      frmImportSuggest.add(btnInsertImport);\n      frmImportSuggest.add(panelTop);\n      frmImportSuggest.add(panelBottom);\n      frmImportSuggest.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);\n      frmImportSuggest.setTitle(\"Import Suggestion\");\n      frmImportSuggest.setLocation(editor.getX()\n                            + (editor.getWidth() - frmImportSuggest.getWidth()) / 2,\n                        editor.getY()\n                            + (editor.getHeight() - frmImportSuggest.getHeight())\n                            / 2);\n      hideSuggestion();\n      classList.setSelectedIndex(0);\n      frmImportSuggest.setVisible(true);\n    }\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected boolean isInstanceOfType(ASTNode node,ASTNode decl, String name){\n    if(node instanceof SimpleName){\n      SimpleName sn = (SimpleName) node;\n\n      if (sn.toString().equals(name)) {\n        ArrayList<ASTNode> nodesToBeMatched = new ArrayList<ASTNode>();\n        nodesToBeMatched.add(decl);\n        if(decl instanceof TypeDeclaration){\n          log(\"decl is a TD\");\n          TypeDeclaration td = (TypeDeclaration)decl;\n          MethodDeclaration[] mlist = td.getMethods();\n          for (MethodDeclaration md : mlist) {\n            if(md.getName().toString().equals(name)){\n              nodesToBeMatched.add(md);\n            }\n          }\n        }\n        log(\"Visiting: \" + getNodeAsString(node));\n        ASTNode decl2 = findDeclaration(sn);\n        Messages.loge(\"It's decl: \" + getNodeAsString(decl2));\n        log(\"But we need: \"+getNodeAsString(decl));\n        for (ASTNode astNode : nodesToBeMatched) {\n          if(astNode.equals(decl2)){\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","id":697,"modified_method":"protected boolean isInstanceOfType(ASTNode node,ASTNode decl, String name){\n    if(node instanceof SimpleName){\n      SimpleName sn = (SimpleName) node;\n\n      if (sn.toString().equals(name)) {\n        ArrayList<ASTNode> nodesToBeMatched = new ArrayList<>();\n        nodesToBeMatched.add(decl);\n        if(decl instanceof TypeDeclaration){\n          log(\"decl is a TD\");\n          TypeDeclaration td = (TypeDeclaration)decl;\n          MethodDeclaration[] mlist = td.getMethods();\n          for (MethodDeclaration md : mlist) {\n            if(md.getName().toString().equals(name)){\n              nodesToBeMatched.add(md);\n            }\n          }\n        }\n        log(\"Visiting: \" + getNodeAsString(node));\n        ASTNode decl2 = findDeclaration(sn);\n        Messages.loge(\"It's decl: \" + getNodeAsString(decl2));\n        log(\"But we need: \"+getNodeAsString(decl));\n        for (ASTNode astNode : nodesToBeMatched) {\n          if(astNode.equals(decl2)){\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * The main function that calculates possible code completion candidates\n   *\n   * @param pdePhrase\n   * @param line\n   * @param lineStartNonWSOffset\n   */\n  public List<CompletionCandidate> preparePredictions(final String pdePhrase,\n                                                      final int line) {\n    ErrorCheckerService errorCheckerService = editor.getErrorChecker();\n    ASTNode astRootNode = (ASTNode) errorCheckerService.getLatestCU().types().get(0);\n\n    // If the parsed code contains pde enhancements, take 'em out.\n    String phrase = ASTNodeWrapper.getJavaCode(pdePhrase);\n\n    //After typing 'arg.' all members of arg type are to be listed. This one is a flag for it\n    boolean noCompare = phrase.endsWith(\".\");\n\n    if (noCompare) {\n      phrase = phrase.substring(0, phrase.length() - 1);\n    }\n\n    boolean incremental = !noCompare &&\n        phrase.length() > lastPredictedPhrase.length() &&\n        phrase.startsWith(lastPredictedPhrase);\n\n\n    if (incremental) {\n      log(pdePhrase + \" starts with \" + lastPredictedPhrase);\n      log(\"Don't recalc\");\n\n      if (phrase.contains(\".\")) {\n        int x = phrase.lastIndexOf('.');\n        candidates = trimCandidates(phrase.substring(x + 1), candidates);\n      } else {\n        candidates = trimCandidates(phrase, candidates);\n      }\n      lastPredictedPhrase = phrase;\n      return candidates;\n    }\n\n    int lineNumber = line;\n    // Adjust line number for tabbed sketches\n    int codeIndex = editor.getSketch().getCodeIndex(editor.getCurrentTab());\n    if (codeIndex > 0) {\n      for (int i = 0; i < codeIndex; i++) {\n        SketchCode sc = editor.getSketch().getCode(i);\n        int len = Util.countLines(sc.getProgram()) + 1;\n        lineNumber += len;\n      }\n    }\n\n    // Ensure that we're not inside a comment. TODO: Binary search\n\n    /*for (Comment comm : getCodeComments()) {\n      int commLineNo = PdeToJavaLineNumber(compilationUnit\n          .getLineNumber(comm.getStartPosition()));\n      if(commLineNo == lineNumber){\n        log(\"Found a comment line \" + comm);\n        log(\"Comment LSO \"\n            + javaCodeOffsetToLineStartOffset(compilationUnit\n          .getLineNumber(comm.getStartPosition()),\n                                              comm.getStartPosition()));\n        break;\n      }\n    }*/\n\n    // Now parse the expression into an ASTNode object\n    ASTNode nearestNode = null;\n    ASTParser parser = ASTParser.newParser(AST.JLS8);\n    parser.setKind(ASTParser.K_EXPRESSION);\n    parser.setSource(phrase.toCharArray());\n    ASTNode testnode = parser.createAST(null);\n    //Base.loge(\"PREDICTION PARSER PROBLEMS: \" + parser);\n    // Find closest ASTNode of the document to this word\n    Messages.loge(\"Typed: \" + phrase + \"|\" + \" temp Node type: \" + testnode.getClass().getSimpleName());\n    if(testnode instanceof MethodInvocation){\n      MethodInvocation mi = (MethodInvocation)testnode;\n      log(mi.getName() + \",\" + mi.getExpression() + \",\" + mi.typeArguments().size());\n    }\n\n    // find nearest ASTNode\n    nearestNode = findClosestNode(lineNumber, astRootNode);\n    if (nearestNode == null) {\n      // Make sure nearestNode is not NULL if couldn't find a closest node\n      nearestNode = astRootNode;\n    }\n    Messages.loge(lineNumber + \" Nearest ASTNode to PRED \"\n        + getNodeAsString(nearestNode));\n\n    candidates = new ArrayList<>();\n    lastPredictedPhrase = phrase;\n    // Determine the expression typed\n\n    if (testnode instanceof SimpleName && !noCompare) {\n      Messages.loge(\"One word expression \" + getNodeAsString(testnode));\n      //==> Simple one word exprssion - so is just an identifier\n\n      // Bottom up traversal of the AST to look for possible definitions at\n      // higher levels.\n      //nearestNode = nearestNode.getParent();\n      while (nearestNode != null) {\n        // If the current class has a super class, look inside it for\n        // definitions.\n        if (nearestNode instanceof TypeDeclaration) {\n          TypeDeclaration td = (TypeDeclaration) nearestNode;\n          if (td.getStructuralProperty(TypeDeclaration.SUPERCLASS_TYPE_PROPERTY) != null) {\n            SimpleType st = (SimpleType) td.getStructuralProperty(TypeDeclaration.SUPERCLASS_TYPE_PROPERTY);\n            log(\"Superclass \" + st.getName());\n            ArrayList<CompletionCandidate> tempCandidates =\n                getMembersForType(st.getName().toString(), phrase, noCompare, false);\n            for (CompletionCandidate can : tempCandidates) {\n              candidates.add(can);\n            }\n            //findDeclaration(st.getName())\n          }\n        }\n        List<StructuralPropertyDescriptor> sprops =\n            nearestNode.structuralPropertiesForType();\n        for (StructuralPropertyDescriptor sprop : sprops) {\n          ASTNode cnode = null;\n          if (!sprop.isChildListProperty()) {\n            if (nearestNode.getStructuralProperty(sprop) instanceof ASTNode) {\n              cnode = (ASTNode) nearestNode.getStructuralProperty(sprop);\n              CompletionCandidate[] types = checkForTypes(cnode);\n              if (types != null) {\n                for (int i = 0; i < types.length; i++) {\n                  if (types[i].getElementName().toLowerCase().startsWith(phrase.toLowerCase()))\n                    candidates.add(types[i]);\n                }\n              }\n            }\n          } else {\n            // Childlist prop\n            List<ASTNode> nodelist =\n              (List<ASTNode>) nearestNode.getStructuralProperty(sprop);\n            for (ASTNode clnode : nodelist) {\n              CompletionCandidate[] types = checkForTypes(clnode);\n              if (types != null) {\n                for (int i = 0; i < types.length; i++) {\n                  if (types[i].getElementName().toLowerCase().startsWith(phrase.toLowerCase()))\n                    candidates.add(types[i]);\n                }\n              }\n            }\n          }\n        }\n        nearestNode = nearestNode.getParent();\n      }\n      // We're seeing a simple name that's not defined locally or in\n      // the parent class. So most probably a pre-defined type.\n      log(\"Empty can. \" + phrase);\n      if (classPath != null) {\n        RegExpResourceFilter regExpResourceFilter =\n          new RegExpResourceFilter(Pattern.compile(\".*\"),\n                                   Pattern.compile(phrase + \"[a-zA-Z_0-9]*.class\",\n                                                   Pattern.CASE_INSENSITIVE));\n        String[] resources = classPath.findResources(\"\", regExpResourceFilter);\n\n        for (String matchedClass2 : resources) {\n          matchedClass2 = matchedClass2.replace('/', '.'); //package name\n          String matchedClass = matchedClass2.substring(0, matchedClass2.length() - 6);\n          int d = matchedClass.lastIndexOf('.');\n          if (!errorCheckerService.ignorableSuggestionImport(matchedClass)) {\n            matchedClass = matchedClass.substring(d + 1); //class name\n            // display package name in grey\n            String html = \"<html>\" + matchedClass + \" : <font color=#777777>\" +\n              matchedClass2.substring(0, d) + \"<\/font><\/html>\";\n            candidates.add(new CompletionCandidate(matchedClass, html,\n                                                   matchedClass,\n                                                   CompletionCandidate.PREDEF_CLASS));\n          }\n        }\n      }\n    } else {\n      // ==> Complex expression of type blah.blah2().doIt,etc\n      // Have to resolve it by carefully traversing AST of testNode\n      Messages.loge(\"Complex expression \" + getNodeAsString(testnode));\n      log(\"candidates empty\");\n      ASTNode childExpr = getChildExpression(testnode);\n      log(\"Parent expression : \" + getParentExpression(testnode));\n      log(\"Child expression : \" + childExpr);\n      if (!noCompare) {\n        log(\"Original testnode \" + getNodeAsString(testnode));\n        testnode = getParentExpression(testnode);\n        log(\"Corrected testnode \" + getNodeAsString(testnode));\n      }\n      ClassMember expr =\n          resolveExpression3rdParty(nearestNode, testnode, noCompare);\n      if (expr == null) {\n        log(\"Expr is null\");\n      } else {\n        boolean isArray = expr.thisclass != null && expr.thisclass.isArray();\n        boolean isSimpleType = (expr.astNode != null) &&\n            expr.astNode.getNodeType() == ASTNode.SIMPLE_TYPE;\n        boolean isMethod = expr.method != null;\n        boolean staticOnly = !isMethod && !isArray && !isSimpleType;\n        log(\"Expr is \" + expr.toString());\n        String lookFor = (noCompare || (childExpr == null)) ?\n            \"\" : childExpr.toString();\n        candidates = getMembersForType(expr, lookFor, noCompare, staticOnly);\n      }\n    }\n    return candidates;\n  }","id":698,"modified_method":"/**\n   * The main function that calculates possible code completion candidates\n   *\n   * @param pdePhrase\n   * @param line\n   * @param lineStartNonWSOffset\n   */\n  public List<CompletionCandidate> preparePredictions(final String pdePhrase,\n                                                      final int line) {\n    ErrorCheckerService errorCheckerService = editor.getErrorChecker();\n    ASTNode astRootNode = (ASTNode) errorCheckerService.getLatestCU().types().get(0);\n\n    // If the parsed code contains pde enhancements, take 'em out.\n    String phrase = ASTNodeWrapper.getJavaCode(pdePhrase);\n\n    //After typing 'arg.' all members of arg type are to be listed. This one is a flag for it\n    boolean noCompare = phrase.endsWith(\".\");\n\n    if (noCompare) {\n      phrase = phrase.substring(0, phrase.length() - 1);\n    }\n\n    boolean incremental = !noCompare &&\n        phrase.length() > lastPredictedPhrase.length() &&\n        phrase.startsWith(lastPredictedPhrase);\n\n\n    if (incremental) {\n      log(pdePhrase + \" starts with \" + lastPredictedPhrase);\n      log(\"Don't recalc\");\n\n      if (phrase.contains(\".\")) {\n        int x = phrase.lastIndexOf('.');\n        candidates = trimCandidates(phrase.substring(x + 1), candidates);\n      } else {\n        candidates = trimCandidates(phrase, candidates);\n      }\n      lastPredictedPhrase = phrase;\n      return candidates;\n    }\n\n    int lineNumber = line;\n    // Adjust line number for tabbed sketches\n    int codeIndex = editor.getSketch().getCodeIndex(editor.getCurrentTab());\n    if (codeIndex > 0) {\n      for (int i = 0; i < codeIndex; i++) {\n        SketchCode sc = editor.getSketch().getCode(i);\n        int len = Util.countLines(sc.getProgram()) + 1;\n        lineNumber += len;\n      }\n    }\n\n    // Ensure that we're not inside a comment. TODO: Binary search\n\n    /*for (Comment comm : getCodeComments()) {\n      int commLineNo = PdeToJavaLineNumber(compilationUnit\n          .getLineNumber(comm.getStartPosition()));\n      if(commLineNo == lineNumber){\n        log(\"Found a comment line \" + comm);\n        log(\"Comment LSO \"\n            + javaCodeOffsetToLineStartOffset(compilationUnit\n          .getLineNumber(comm.getStartPosition()),\n                                              comm.getStartPosition()));\n        break;\n      }\n    }*/\n\n    // Now parse the expression into an ASTNode object\n    ASTNode nearestNode;\n    ASTParser parser = ASTParser.newParser(AST.JLS8);\n    parser.setKind(ASTParser.K_EXPRESSION);\n    parser.setSource(phrase.toCharArray());\n    ASTNode testnode = parser.createAST(null);\n    //Base.loge(\"PREDICTION PARSER PROBLEMS: \" + parser);\n    // Find closest ASTNode of the document to this word\n    Messages.loge(\"Typed: \" + phrase + \"|\" + \" temp Node type: \" + testnode.getClass().getSimpleName());\n    if(testnode instanceof MethodInvocation){\n      MethodInvocation mi = (MethodInvocation)testnode;\n      log(mi.getName() + \",\" + mi.getExpression() + \",\" + mi.typeArguments().size());\n    }\n\n    // find nearest ASTNode\n    nearestNode = findClosestNode(lineNumber, astRootNode);\n    if (nearestNode == null) {\n      // Make sure nearestNode is not NULL if couldn't find a closest node\n      nearestNode = astRootNode;\n    }\n    Messages.loge(lineNumber + \" Nearest ASTNode to PRED \"\n        + getNodeAsString(nearestNode));\n\n    candidates = new ArrayList<>();\n    lastPredictedPhrase = phrase;\n    // Determine the expression typed\n\n    if (testnode instanceof SimpleName && !noCompare) {\n      Messages.loge(\"One word expression \" + getNodeAsString(testnode));\n      //==> Simple one word exprssion - so is just an identifier\n\n      // Bottom up traversal of the AST to look for possible definitions at\n      // higher levels.\n      //nearestNode = nearestNode.getParent();\n      while (nearestNode != null) {\n        // If the current class has a super class, look inside it for\n        // definitions.\n        if (nearestNode instanceof TypeDeclaration) {\n          TypeDeclaration td = (TypeDeclaration) nearestNode;\n          if (td.getStructuralProperty(TypeDeclaration.SUPERCLASS_TYPE_PROPERTY) != null) {\n            SimpleType st = (SimpleType) td.getStructuralProperty(TypeDeclaration.SUPERCLASS_TYPE_PROPERTY);\n            log(\"Superclass \" + st.getName());\n            ArrayList<CompletionCandidate> tempCandidates =\n                getMembersForType(st.getName().toString(), phrase, false, false);\n            for (CompletionCandidate can : tempCandidates) {\n              candidates.add(can);\n            }\n            //findDeclaration(st.getName())\n          }\n        }\n        List<StructuralPropertyDescriptor> sprops =\n            nearestNode.structuralPropertiesForType();\n        for (StructuralPropertyDescriptor sprop : sprops) {\n          ASTNode cnode;\n          if (!sprop.isChildListProperty()) {\n            if (nearestNode.getStructuralProperty(sprop) instanceof ASTNode) {\n              cnode = (ASTNode) nearestNode.getStructuralProperty(sprop);\n              CompletionCandidate[] types = checkForTypes(cnode);\n              if (types != null) {\n                for (CompletionCandidate type : types) {\n                  if (type.getElementName().toLowerCase().startsWith(phrase.toLowerCase()))\n                    candidates.add(type);\n                }\n              }\n            }\n          } else {\n            // Childlist prop\n            List<ASTNode> nodelist =\n              (List<ASTNode>) nearestNode.getStructuralProperty(sprop);\n            for (ASTNode clnode : nodelist) {\n              CompletionCandidate[] types = checkForTypes(clnode);\n              if (types != null) {\n                for (CompletionCandidate type : types) {\n                  if (type.getElementName().toLowerCase().startsWith(phrase.toLowerCase()))\n                    candidates.add(type);\n                }\n              }\n            }\n          }\n        }\n        nearestNode = nearestNode.getParent();\n      }\n      // We're seeing a simple name that's not defined locally or in\n      // the parent class. So most probably a pre-defined type.\n      log(\"Empty can. \" + phrase);\n      if (classPath != null) {\n        RegExpResourceFilter regExpResourceFilter =\n          new RegExpResourceFilter(Pattern.compile(\".*\"),\n                                   Pattern.compile(phrase + \"[a-zA-Z_0-9]*.class\",\n                                                   Pattern.CASE_INSENSITIVE));\n        String[] resources = classPath.findResources(\"\", regExpResourceFilter);\n\n        for (String matchedClass2 : resources) {\n          matchedClass2 = matchedClass2.replace('/', '.'); //package name\n          String matchedClass = matchedClass2.substring(0, matchedClass2.length() - 6);\n          int d = matchedClass.lastIndexOf('.');\n          if (!errorCheckerService.ignorableSuggestionImport(matchedClass)) {\n            matchedClass = matchedClass.substring(d + 1); //class name\n            // display package name in grey\n            String html = \"<html>\" + matchedClass + \" : <font color=#777777>\" +\n              matchedClass2.substring(0, d) + \"<\/font><\/html>\";\n            candidates.add(new CompletionCandidate(matchedClass, html,\n                                                   matchedClass,\n                                                   CompletionCandidate.PREDEF_CLASS));\n          }\n        }\n      }\n    } else {\n      // ==> Complex expression of type blah.blah2().doIt,etc\n      // Have to resolve it by carefully traversing AST of testNode\n      Messages.loge(\"Complex expression \" + getNodeAsString(testnode));\n      log(\"candidates empty\");\n      ASTNode childExpr = getChildExpression(testnode);\n      log(\"Parent expression : \" + getParentExpression(testnode));\n      log(\"Child expression : \" + childExpr);\n      if (!noCompare) {\n        log(\"Original testnode \" + getNodeAsString(testnode));\n        testnode = getParentExpression(testnode);\n        log(\"Corrected testnode \" + getNodeAsString(testnode));\n      }\n      ClassMember expr =\n          resolveExpression3rdParty(nearestNode, testnode, noCompare);\n      if (expr == null) {\n        log(\"Expr is null\");\n      } else {\n        boolean isArray = expr.thisclass != null && expr.thisclass.isArray();\n        boolean isSimpleType = (expr.astNode != null) &&\n            expr.astNode.getNodeType() == ASTNode.SIMPLE_TYPE;\n        boolean isMethod = expr.method != null;\n        boolean staticOnly = !isMethod && !isArray && !isSimpleType;\n        log(\"Expr is \" + expr.toString());\n        String lookFor = (noCompare || (childExpr == null)) ?\n            \"\" : childExpr.toString();\n        candidates = getMembersForType(expr, lookFor, noCompare, staticOnly);\n      }\n    }\n    return candidates;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected String getLabelIfType(ASTNodeWrapper node, SimpleName sn){\n    ASTNode current = node.getNode().getParent();\n    String type = \"\";\n    StringBuilder fullName = new StringBuilder();\n    Stack<String> parents = new Stack<String>();\n    String simpleName = (sn == null) ? node.getNode().toString() : sn.toString();\n    switch (node.getNodeType()) {\n    case ASTNode.TYPE_DECLARATION:\n    case ASTNode.METHOD_DECLARATION:\n    case ASTNode.FIELD_DECLARATION:\n      while (current != null) {\n        if (current instanceof TypeDeclaration) {\n          parents.push(((TypeDeclaration) current).getName().toString());\n        }\n        current = current.getParent();\n      }\n      while (parents.size() > 0) {\n        fullName.append(parents.pop() + \".\");\n      }\n      fullName.append(simpleName);\n      if (node.getNode() instanceof MethodDeclaration) {\n        MethodDeclaration md = (MethodDeclaration) node.getNode();\n        if (!md.isConstructor())\n          type = md.getReturnType2().toString();\n        fullName.append('(');\n        if (!md.parameters().isEmpty()) {\n          List<ASTNode> params = md.parameters();\n          for (ASTNode par : params) {\n            if (par instanceof SingleVariableDeclaration) {\n              SingleVariableDeclaration svd = (SingleVariableDeclaration) par;\n              fullName.append(svd.getType() + \" \" + svd.getName() + \",\");\n            }\n          }\n        }\n        if(fullName.charAt(fullName.length() - 1) == ',')\n          fullName.deleteCharAt(fullName.length() - 1);\n        fullName.append(')');\n      }\n      else if(node.getNode() instanceof FieldDeclaration){\n        type = ((FieldDeclaration) node.getNode()).getType().toString();\n      }\n      int x = fullName.indexOf(\".\");\n      fullName.delete(0, x + 1);\n      return type + \" \" + fullName;\n\n    case ASTNode.SINGLE_VARIABLE_DECLARATION:\n      SingleVariableDeclaration svd = (SingleVariableDeclaration)node.getNode();\n      return svd.getType() + \" \" + svd.getName();\n\n    case ASTNode.VARIABLE_DECLARATION_STATEMENT:\n      return ((VariableDeclarationStatement) node.getNode()).getType() + \" \"\n          + simpleName;\n    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:\n      return ((VariableDeclarationExpression) node.getNode()).getType() + \" \"\n          + simpleName;\n    default:\n      break;\n    }\n\n\n    return \"\";\n  }","id":699,"modified_method":"protected String getLabelIfType(ASTNodeWrapper node, SimpleName sn){\n    ASTNode current = node.getNode().getParent();\n    String type = \"\";\n    StringBuilder fullName = new StringBuilder();\n    Stack<String> parents = new Stack<>();\n    String simpleName = (sn == null) ? node.getNode().toString() : sn.toString();\n    switch (node.getNodeType()) {\n    case ASTNode.TYPE_DECLARATION:\n    case ASTNode.METHOD_DECLARATION:\n    case ASTNode.FIELD_DECLARATION:\n      while (current != null) {\n        if (current instanceof TypeDeclaration) {\n          parents.push(((TypeDeclaration) current).getName().toString());\n        }\n        current = current.getParent();\n      }\n      while (parents.size() > 0) {\n        fullName.append(parents.pop()).append(\".\");\n      }\n      fullName.append(simpleName);\n      if (node.getNode() instanceof MethodDeclaration) {\n        MethodDeclaration md = (MethodDeclaration) node.getNode();\n        if (!md.isConstructor())\n          type = md.getReturnType2().toString();\n        fullName.append('(');\n        if (!md.parameters().isEmpty()) {\n          List<ASTNode> params = md.parameters();\n          for (ASTNode par : params) {\n            if (par instanceof SingleVariableDeclaration) {\n              SingleVariableDeclaration svd = (SingleVariableDeclaration) par;\n              fullName.append(svd.getType()).append(\" \").append(svd.getName()).append(\",\");\n            }\n          }\n        }\n        if(fullName.charAt(fullName.length() - 1) == ',')\n          fullName.deleteCharAt(fullName.length() - 1);\n        fullName.append(')');\n      }\n      else if(node.getNode() instanceof FieldDeclaration){\n        type = ((FieldDeclaration) node.getNode()).getType().toString();\n      }\n      int x = fullName.indexOf(\".\");\n      fullName.delete(0, x + 1);\n      return type + \" \" + fullName;\n\n    case ASTNode.SINGLE_VARIABLE_DECLARATION:\n      SingleVariableDeclaration svd = (SingleVariableDeclaration)node.getNode();\n      return svd.getType() + \" \" + svd.getName();\n\n    case ASTNode.VARIABLE_DECLARATION_STATEMENT:\n      return ((VariableDeclarationStatement) node.getNode()).getType() + \" \"\n          + simpleName;\n    case ASTNode.VARIABLE_DECLARATION_EXPRESSION:\n      return ((VariableDeclarationExpression) node.getNode()).getType() + \" \"\n          + simpleName;\n    default:\n      break;\n    }\n\n\n    return \"\";\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected void loadJavaDoc() {\n    jdocMap = new TreeMap<String, String>();\n\n    // presently loading only p5 reference for PApplet\n    new Thread(new Runnable() {\n      public void run() {\n        try {\n          loadJavaDoc(jdocMap, editor.getMode().getReferenceFolder());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }).start();\n  }","id":700,"modified_method":"protected void loadJavaDoc() {\n    jdocMap = new TreeMap<>();\n\n    // presently loading only p5 reference for PApplet\n    new Thread(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          loadJavaDoc(jdocMap, editor.getMode().getReferenceFolder());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }).start();\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Searches for the particular class in the default list of imports as well as\n   * the Sketch classpath\n   * @param className\n   * @return\n   */\n  protected Class<?> findClassIfExists(String className){\n    if(className == null){\n      return null;\n    }\n    Class<?> tehClass = null;\n    // First, see if the classname is a fully qualified name and loads straightaway\n    tehClass = loadClass(className);\n\n    if (tehClass != null) {\n      //log(tehClass.getName() + \" located straightaway\");\n      return tehClass;\n    }\n\n    log(\"Looking in the classloader for \" + className);\n    ArrayList<ImportStatement> imports = errorCheckerService\n        .getProgramImports();\n\n    for (ImportStatement impS : imports) {\n      String temp = impS.getPackageName();\n      if (impS.isStarredImport() && className.indexOf('.') == -1) {\n        temp = impS.getPackageName() + \".\" + className;\n      }\n      tehClass = loadClass(temp);\n      if (tehClass != null) {\n        log(tehClass.getName() + \" located.\");\n        return tehClass;\n      }\n      //log(\"Doesn't exist in imp package: \" + impS.getImportName());\n    }\n\n    for (ImportStatement impS : errorCheckerService.codeFolderImports) {\n      String temp = impS.getPackageName();\n      if (impS.isStarredImport() && className.indexOf('.') == -1) {\n        temp = impS.getPackageName() + \".\" + className;\n      }\n      tehClass = loadClass(temp);\n      if (tehClass != null) {\n        log(tehClass.getName() + \" located.\");\n        return tehClass;\n      }\n      //log(\"Doesn't exist in (code folder) imp package: \" + impS.getImportName());\n    }\n\n    PdePreprocessor p = new PdePreprocessor(null);\n    for (String impS : p.getCoreImports()) {\n      tehClass = loadClass(impS.substring(0,impS.length()-1) + className);\n      if (tehClass != null) {\n        log(tehClass.getName() + \" located.\");\n        return tehClass;\n      }\n      //log(\"Doesn't exist in package: \" + impS);\n    }\n\n    for (String impS : p.getDefaultImports()) {\n      if(className.equals(impS) || impS.endsWith(className)){\n        tehClass = loadClass(impS);\n        if (tehClass != null) {\n          log(tehClass.getName() + \" located.\");\n          return tehClass;\n        }\n       // log(\"Doesn't exist in package: \" + impS);\n      }\n    }\n\n    // And finally, the daddy\n    String daddy = \"java.lang.\" + className;\n    tehClass = loadClass(daddy);\n    if (tehClass != null) {\n      log(tehClass.getName() + \" located.\");\n      return tehClass;\n    }\n    //log(\"Doesn't exist in java.lang\");\n\n    return tehClass;\n  }","id":701,"modified_method":"/**\n   * Searches for the particular class in the default list of imports as well as\n   * the Sketch classpath\n   * @param className\n   * @return\n   */\n  protected Class<?> findClassIfExists(String className){\n    if(className == null){\n      return null;\n    }\n    // First, see if the classname is a fully qualified name and loads straightaway\n    Class<?> tehClass = loadClass(className);\n\n    if (tehClass != null) {\n      //log(tehClass.getName() + \" located straightaway\");\n      return tehClass;\n    }\n\n    log(\"Looking in the classloader for \" + className);\n    ArrayList<ImportStatement> imports = errorCheckerService\n        .getProgramImports();\n\n    for (ImportStatement impS : imports) {\n      String temp = impS.getPackageName();\n      if (impS.isStarredImport() && className.indexOf('.') == -1) {\n        temp = impS.getPackageName() + \".\" + className;\n      }\n      tehClass = loadClass(temp);\n      if (tehClass != null) {\n        log(tehClass.getName() + \" located.\");\n        return tehClass;\n      }\n      //log(\"Doesn't exist in imp package: \" + impS.getImportName());\n    }\n\n    for (ImportStatement impS : errorCheckerService.codeFolderImports) {\n      String temp = impS.getPackageName();\n      if (impS.isStarredImport() && className.indexOf('.') == -1) {\n        temp = impS.getPackageName() + \".\" + className;\n      }\n      tehClass = loadClass(temp);\n      if (tehClass != null) {\n        log(tehClass.getName() + \" located.\");\n        return tehClass;\n      }\n      //log(\"Doesn't exist in (code folder) imp package: \" + impS.getImportName());\n    }\n\n    PdePreprocessor p = new PdePreprocessor(null);\n    for (String impS : p.getCoreImports()) {\n      tehClass = loadClass(impS.substring(0,impS.length()-1) + className);\n      if (tehClass != null) {\n        log(tehClass.getName() + \" located.\");\n        return tehClass;\n      }\n      //log(\"Doesn't exist in package: \" + impS);\n    }\n\n    for (String impS : p.getDefaultImports()) {\n      if(className.equals(impS) || impS.endsWith(className)){\n        tehClass = loadClass(impS);\n        if (tehClass != null) {\n          log(tehClass.getName() + \" located.\");\n          return tehClass;\n        }\n       // log(\"Doesn't exist in package: \" + impS);\n      }\n    }\n\n    // And finally, the daddy\n    String daddy = \"java.lang.\" + className;\n    tehClass = loadClass(daddy);\n    if (tehClass != null) {\n      log(tehClass.getName() + \" located.\");\n      return tehClass;\n    }\n    //log(\"Doesn't exist in java.lang\");\n\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Find the parent of the expression in a().b, this would give me the return\n   * type of a(), so that we can find all children of a() begininng with b\n   *\n   * @param nearestNode\n   * @param expression\n   * @return\n   */\n  public static ASTNode resolveExpression(ASTNode nearestNode,\n                                          ASTNode expression, boolean noCompare) {\n    log(\"Resolving \" + getNodeAsString(expression) + \" noComp \"\n        + noCompare);\n    if (expression instanceof SimpleName) {\n      return findDeclaration2(((SimpleName) expression), nearestNode);\n    } else if (expression instanceof MethodInvocation) {\n      log(\"3. Method Invo \"\n          + ((MethodInvocation) expression).getName());\n      return findDeclaration2(((MethodInvocation) expression).getName(),\n                              nearestNode);\n    } else if (expression instanceof FieldAccess) {\n      log(\"2. Field access \"\n          + getNodeAsString(((FieldAccess) expression).getExpression()) + \"|||\"\n          + getNodeAsString(((FieldAccess) expression).getName()));\n      if (noCompare) {\n        /*\n         * ASTNode ret = findDeclaration2(((FieldAccess) expression).getName(),\n         * nearestNode); log(\"Found as ->\"+getNodeAsString(ret));\n         * return ret;\n         */\n        return findDeclaration2(((FieldAccess) expression).getName(),\n                                nearestNode);\n      } else {\n\n        /*\n         * Note how for the next recursion, noCompare is reversed. Let's say\n         * I've typed getABC().quark.nin where nin is incomplete(ninja being the\n         * field), when execution first enters here, it calls resolveExpr again\n         * for \"getABC().quark\" where we know that quark field must be complete,\n         * so we toggle noCompare. And kaboom.\n         */\n        return resolveExpression(nearestNode,\n                                 ((FieldAccess) expression).getExpression(),\n                                 !noCompare);\n      }\n      //return findDeclaration2(((FieldAccess) expression).getExpression(), nearestNode);\n    } else if (expression instanceof QualifiedName) {\n      log(\"1. Resolving \"\n          + ((QualifiedName) expression).getQualifier() + \" ||| \"\n          + ((QualifiedName) expression).getName());\n      if (noCompare) { // no compare, as in \"abc.hello.\" need to resolve hello here\n        return findDeclaration2(((QualifiedName) expression).getName(),\n                                nearestNode);\n      } else {\n        //User typed \"abc.hello.by\" (bye being complete), so need to resolve \"abc.hello.\" only\n        return findDeclaration2(((QualifiedName) expression).getQualifier(),\n                          nearestNode);\n      }\n    }\n\n    return null;\n  }","id":702,"modified_method":"/**\n   * Find the parent of the expression in a().b, this would give me the return\n   * type of a(), so that we can find all children of a() begininng with b\n   *\n   * @param nearestNode\n   * @param expression\n   * @return\n   */\n  public static ASTNode resolveExpression(ASTNode nearestNode,\n                                          ASTNode expression, boolean noCompare) {\n    log(\"Resolving \" + getNodeAsString(expression) + \" noComp \"\n        + noCompare);\n    if (expression instanceof SimpleName) {\n      return findDeclaration2(((SimpleName) expression), nearestNode);\n    } else if (expression instanceof MethodInvocation) {\n      log(\"3. Method Invo \"\n          + ((MethodInvocation) expression).getName());\n      return findDeclaration2(((MethodInvocation) expression).getName(),\n                              nearestNode);\n    } else if (expression instanceof FieldAccess) {\n      log(\"2. Field access \"\n          + getNodeAsString(((FieldAccess) expression).getExpression()) + \"|||\"\n          + getNodeAsString(((FieldAccess) expression).getName()));\n      if (noCompare) {\n        /*\n         * ASTNode ret = findDeclaration2(((FieldAccess) expression).getName(),\n         * nearestNode); log(\"Found as ->\"+getNodeAsString(ret));\n         * return ret;\n         */\n        return findDeclaration2(((FieldAccess) expression).getName(),\n                                nearestNode);\n      } else {\n\n        /*\n         * Note how for the next recursion, noCompare is reversed. Let's say\n         * I've typed getABC().quark.nin where nin is incomplete(ninja being the\n         * field), when execution first enters here, it calls resolveExpr again\n         * for \"getABC().quark\" where we know that quark field must be complete,\n         * so we toggle noCompare. And kaboom.\n         */\n        return resolveExpression(nearestNode,\n                                 ((FieldAccess) expression).getExpression(),\n                                 true);\n      }\n      //return findDeclaration2(((FieldAccess) expression).getExpression(), nearestNode);\n    } else if (expression instanceof QualifiedName) {\n      log(\"1. Resolving \"\n          + ((QualifiedName) expression).getQualifier() + \" ||| \"\n          + ((QualifiedName) expression).getName());\n      if (noCompare) { // no compare, as in \"abc.hello.\" need to resolve hello here\n        return findDeclaration2(((QualifiedName) expression).getName(),\n                                nearestNode);\n      } else {\n        //User typed \"abc.hello.by\" (bye being complete), so need to resolve \"abc.hello.\" only\n        return findDeclaration2(((QualifiedName) expression).getQualifier(),\n                          nearestNode);\n      }\n    }\n\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Generates AST Swing component\n   * @param node\n   * @param tnode\n   */\n  public static void visitRecur(ASTNode node, DefaultMutableTreeNode tnode) {\n    Iterator<StructuralPropertyDescriptor> it =\n        node.structuralPropertiesForType().iterator();\n    //Base.loge(\"Props of \" + node.getClass().getName());\n    DefaultMutableTreeNode ctnode = null;\n    while (it.hasNext()) {\n      StructuralPropertyDescriptor prop = it.next();\n\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n            if (isAddableASTNode(cnode)) {\n              ctnode = new DefaultMutableTreeNode(\n                                                  new ASTNodeWrapper((ASTNode) node\n                                                      .getStructuralProperty(prop)));\n              tnode.add(ctnode);\n              visitRecur(cnode, ctnode);\n            }\n          } else {\n            tnode.add(new DefaultMutableTreeNode(node\n                .getStructuralProperty(prop)));\n          }\n        }\n      } else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>)\n          node.getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          if (isAddableASTNode(cnode)) {\n            ctnode = new DefaultMutableTreeNode(new ASTNodeWrapper(cnode));\n            tnode.add(ctnode);\n            visitRecur(cnode, ctnode);\n          } else {\n            visitRecur(cnode, tnode);\n          }\n        }\n      }\n    }\n  }","id":703,"modified_method":"/**\n   * Generates AST Swing component\n   * @param node\n   * @param tnode\n   */\n  public static void visitRecur(ASTNode node, DefaultMutableTreeNode tnode) {\n    Iterator<StructuralPropertyDescriptor> it =\n        node.structuralPropertiesForType().iterator();\n    //Base.loge(\"Props of \" + node.getClass().getName());\n    DefaultMutableTreeNode ctnode;\n    while (it.hasNext()) {\n      StructuralPropertyDescriptor prop = it.next();\n\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n            if (isAddableASTNode(cnode)) {\n              ctnode = new DefaultMutableTreeNode(\n                                                  new ASTNodeWrapper((ASTNode) node\n                                                      .getStructuralProperty(prop)));\n              tnode.add(ctnode);\n              visitRecur(cnode, ctnode);\n            }\n          } else {\n            tnode.add(new DefaultMutableTreeNode(node\n                .getStructuralProperty(prop)));\n          }\n        }\n      } else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>)\n          node.getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          if (isAddableASTNode(cnode)) {\n            ctnode = new DefaultMutableTreeNode(new ASTNodeWrapper(cnode));\n            tnode.add(ctnode);\n            visitRecur(cnode, ctnode);\n          } else {\n            visitRecur(cnode, tnode);\n          }\n        }\n      }\n    }\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected void addListeners(){\n    jtree.addTreeSelectionListener(new TreeSelectionListener() {\n\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        Messages.log(e.toString());\n\n        // TODO: this should already run on EDT so why the SwingWorker?\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          protected void done() {\n            if(jtree\n                .getLastSelectedPathComponent() == null){\n              return;\n            }\n            DefaultMutableTreeNode tnode = (DefaultMutableTreeNode) jtree\n                .getLastSelectedPathComponent();\n            if (tnode.getUserObject() instanceof ASTNodeWrapper) {\n              ASTNodeWrapper awrap = (ASTNodeWrapper) tnode.getUserObject();\n              awrap.highlightNode(editor);\n              // errorCheckerService.highlightNode(awrap);\n\n              //--\n              try {\n                int javaLineNumber = getLineNumber(awrap.getNode());\n                int pdeOffs[] = errorCheckerService\n                    .calculateTabIndexAndLineNumber(javaLineNumber);\n                PlainDocument javaSource = new PlainDocument();\n                javaSource.insertString(0, errorCheckerService.lastCodeCheckResult.sourceCode, null);\n                Element lineElement = javaSource.getDefaultRootElement()\n                    .getElement(javaLineNumber-1);\n                if(lineElement == null) {\n                  return;\n                }\n\n                String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                                     lineElement.getEndOffset()\n                                                         - lineElement.getStartOffset());\n                editor.getSketch().setCurrentCode(pdeOffs[0]);\n                String pdeLine = editor.getLineText(pdeOffs[1]);\n                //String lookingFor = nodeName.toString();\n                //log(lookingFor + \", \" + nodeName.getStartPosition());\n                log(\"JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n                    + lineElement.getEndOffset());\n                log(\"PL \" + pdeLine);\n              } catch (BadLocationException e) {\n                e.printStackTrace();\n              }\n            }\n          }\n        };\n        worker.execute();\n      }\n    });\n\n    btnRename.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if(txtRenameField.getText().length() == 0)\n          return;\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          protected void done() {\n           refactorIt();\n          }\n        };\n        worker.execute();\n      }\n    });\n\n    btnListOccurrence.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          protected void done() {\n            handleShowUsage();\n          }\n        };\n        worker.execute();\n      }\n    });\n\n    refactorTree.addTreeSelectionListener(new TreeSelectionListener() {\n\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        log(e);\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          protected void done() {\n            if(refactorTree\n                .getLastSelectedPathComponent() == null){\n              return;\n            }\n            DefaultMutableTreeNode tnode = (DefaultMutableTreeNode) refactorTree\n                .getLastSelectedPathComponent();\n\n            if (tnode.getUserObject() instanceof ASTNodeWrapper) {\n              ASTNodeWrapper awrap = (ASTNodeWrapper) tnode.getUserObject();\n              //errorCheckerService.highlightNode(awrap);\n              awrap.highlightNode(editor);\n            }\n          }\n        };\n        worker.execute();\n      }\n    });\n  }","id":704,"modified_method":"protected void addListeners(){\n    jtree.addTreeSelectionListener(new TreeSelectionListener() {\n\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        Messages.log(e.toString());\n\n        // TODO: this should already run on EDT so why the SwingWorker?\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          @Override\n          protected void done() {\n            if(jtree\n                .getLastSelectedPathComponent() == null){\n              return;\n            }\n            DefaultMutableTreeNode tnode = (DefaultMutableTreeNode) jtree\n                .getLastSelectedPathComponent();\n            if (tnode.getUserObject() instanceof ASTNodeWrapper) {\n              ASTNodeWrapper awrap = (ASTNodeWrapper) tnode.getUserObject();\n              awrap.highlightNode(editor);\n              // errorCheckerService.highlightNode(awrap);\n\n              //--\n              try {\n                int javaLineNumber = getLineNumber(awrap.getNode());\n                int pdeOffs[] = errorCheckerService\n                    .calculateTabIndexAndLineNumber(javaLineNumber);\n                PlainDocument javaSource = new PlainDocument();\n                javaSource.insertString(0, errorCheckerService.lastCodeCheckResult.sourceCode, null);\n                Element lineElement = javaSource.getDefaultRootElement()\n                    .getElement(javaLineNumber-1);\n                if(lineElement == null) {\n                  return;\n                }\n\n                String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                                     lineElement.getEndOffset()\n                                                         - lineElement.getStartOffset());\n                editor.getSketch().setCurrentCode(pdeOffs[0]);\n                String pdeLine = editor.getLineText(pdeOffs[1]);\n                //String lookingFor = nodeName.toString();\n                //log(lookingFor + \", \" + nodeName.getStartPosition());\n                log(\"JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n                    + lineElement.getEndOffset());\n                log(\"PL \" + pdeLine);\n              } catch (BadLocationException e) {\n                e.printStackTrace();\n              }\n            }\n          }\n        };\n        worker.execute();\n      }\n    });\n\n    btnRename.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if(txtRenameField.getText().length() == 0)\n          return;\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          @Override\n          protected void done() {\n           refactorIt();\n          }\n        };\n        worker.execute();\n      }\n    });\n\n    btnListOccurrence.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          @Override\n          protected void done() {\n            handleShowUsage();\n          }\n        };\n        worker.execute();\n      }\n    });\n\n    refactorTree.addTreeSelectionListener(new TreeSelectionListener() {\n\n      @Override\n      public void valueChanged(TreeSelectionEvent e) {\n        log(e);\n        SwingWorker<Object, Object> worker = new SwingWorker<Object, Object>() {\n\n          @Override\n          protected Object doInBackground() throws Exception {\n            return null;\n          }\n\n          @Override\n          protected void done() {\n            if(refactorTree\n                .getLastSelectedPathComponent() == null){\n              return;\n            }\n            DefaultMutableTreeNode tnode = (DefaultMutableTreeNode) refactorTree\n                .getLastSelectedPathComponent();\n\n            if (tnode.getUserObject() instanceof ASTNodeWrapper) {\n              ASTNodeWrapper awrap = (ASTNodeWrapper) tnode.getUserObject();\n              //errorCheckerService.highlightNode(awrap);\n              awrap.highlightNode(editor);\n            }\n          }\n        };\n        worker.execute();\n      }\n    });\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public void dfsNameOnly(DefaultMutableTreeNode tnode,ASTNode decl, String name) {\n    Stack<DefaultMutableTreeNode> temp = new Stack<DefaultMutableTreeNode>();\n    temp.push(codeTree);\n\n    while(!temp.isEmpty()){\n      DefaultMutableTreeNode cnode = temp.pop();\n      for (int i = 0; i < cnode.getChildCount(); i++) {\n        temp.push((DefaultMutableTreeNode) cnode.getChildAt(i));\n      }\n\n      if(!(cnode.getUserObject() instanceof ASTNodeWrapper))\n        continue;\n      ASTNodeWrapper awnode = (ASTNodeWrapper) cnode.getUserObject();\n//      log(\"Visiting: \" + getNodeAsString(awnode.getNode()));\n      if(isInstanceOfType(awnode.getNode(), decl, name)){\n        int val[] = errorCheckerService\n            .JavaToPdeOffsets(awnode.getLineNumber(), 0);\n        tnode.add(new DefaultMutableTreeNode(new ASTNodeWrapper(awnode\n            .getNode(), \"Line \" + (val[1] + 1) + \" | Tab: \"\n            + editor.getSketch().getCode(val[0]).getPrettyName())));\n      }\n\n    }\n  }","id":705,"modified_method":"public void dfsNameOnly(DefaultMutableTreeNode tnode,ASTNode decl, String name) {\n    Stack<DefaultMutableTreeNode> temp = new Stack<>();\n    temp.push(codeTree);\n\n    while(!temp.isEmpty()){\n      DefaultMutableTreeNode cnode = temp.pop();\n      for (int i = 0; i < cnode.getChildCount(); i++) {\n        temp.push((DefaultMutableTreeNode) cnode.getChildAt(i));\n      }\n\n      if(!(cnode.getUserObject() instanceof ASTNodeWrapper))\n        continue;\n      ASTNodeWrapper awnode = (ASTNodeWrapper) cnode.getUserObject();\n//      log(\"Visiting: \" + getNodeAsString(awnode.getNode()));\n      if(isInstanceOfType(awnode.getNode(), decl, name)){\n        int val[] = errorCheckerService\n            .JavaToPdeOffsets(awnode.getLineNumber(), 0);\n        tnode.add(new DefaultMutableTreeNode(new ASTNodeWrapper(awnode\n            .getNode(), \"Line \" + (val[1] + 1) + \" | Tab: \"\n            + editor.getSketch().getCode(val[0]).getPrettyName())));\n      }\n\n    }\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public String[] getSuggestImports(final String className) {\n    if (classPath == null) {\n      return null;\n    }\n\n    if (ignoredImportSuggestions == null) {\n      ignoredImportSuggestions = new TreeSet<String>();\n    } else {\n      if (ignoredImportSuggestions.contains(className)) {\n        log(\"Ignoring import suggestions for \" + className);\n        return null;\n      }\n    }\n\n    log(\"Looking for class \" + className);\n    RegExpResourceFilter regf = new RegExpResourceFilter(Pattern.compile(\".*\"),\n                                                         Pattern.compile(className + \".class\",\n                                                                      Pattern.CASE_INSENSITIVE));\n    // TODO once saw NPE here...possible for classPath to be null? [fry 150808]\n    String[] resources = classPath.findResources(\"\", regf);\n    List<String> candidates = new ArrayList<String>();\n    for (String res : resources) {\n      candidates.add(res);\n    }\n\n    // log(\"Couldn't find import for class \" + className);\n\n    for (Library lib : editor.getMode().contribLibraries) {\n      ClassPath cp = factory.createFromPath(lib.getClassPath());\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    if (editor.getSketch().hasCodeFolder()) {\n      File codeFolder = editor.getSketch().getCodeFolder();\n      // get a list of .jar files in the \"code\" folder\n      // (class files in subfolders should also be picked up)\n      ClassPath cp = factory.createFromPath(Util.contentsToClassPath(codeFolder));\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    resources = new String[candidates.size()];\n    for (int i = 0; i < resources.length; i++) {\n      resources[i] = candidates.get(i).replace('/', '.')\n          .substring(0, candidates.get(i).length() - 6);\n    }\n\n//    ArrayList<String> ans = new ArrayList<String>();\n//    for (int i = 0; i < resources.length; i++) {\n//      ans.add(resources[i]);\n//    }\n\n    return resources;\n  }","id":706,"modified_method":"public String[] getSuggestImports(final String className) {\n    if (classPath == null) {\n      return null;\n    }\n\n    if (ignoredImportSuggestions == null) {\n      ignoredImportSuggestions = new TreeSet<>();\n    } else {\n      if (ignoredImportSuggestions.contains(className)) {\n        log(\"Ignoring import suggestions for \" + className);\n        return null;\n      }\n    }\n\n    log(\"Looking for class \" + className);\n    RegExpResourceFilter regf = new RegExpResourceFilter(Pattern.compile(\".*\"),\n                                                         Pattern.compile(className + \".class\",\n                                                                      Pattern.CASE_INSENSITIVE));\n    // TODO once saw NPE here...possible for classPath to be null? [fry 150808]\n    String[] resources = classPath.findResources(\"\", regf);\n    List<String> candidates = new ArrayList<>();\n    Collections.addAll(candidates, resources);\n\n    // log(\"Couldn't find import for class \" + className);\n\n    for (Library lib : editor.getMode().contribLibraries) {\n      ClassPath cp = factory.createFromPath(lib.getClassPath());\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    if (editor.getSketch().hasCodeFolder()) {\n      File codeFolder = editor.getSketch().getCodeFolder();\n      // get a list of .jar files in the \"code\" folder\n      // (class files in subfolders should also be picked up)\n      ClassPath cp = factory.createFromPath(Util.contentsToClassPath(codeFolder));\n      resources = cp.findResources(\"\", regf);\n      for (String res : resources) {\n        candidates.add(res);\n        log(\"Res: \" + res);\n      }\n    }\n\n    resources = new String[candidates.size()];\n    for (int i = 0; i < resources.length; i++) {\n      resources[i] = candidates.get(i).replace('/', '.')\n          .substring(0, candidates.get(i).length() - 6);\n    }\n\n//    ArrayList<String> ans = new ArrayList<String>();\n//    for (int i = 0; i < resources.length; i++) {\n//      ans.add(resources[i]);\n//    }\n\n    return resources;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Finds the type of the expression in foo.bar().a().b, this would give me the\n   * type of b if it exists in return type of a(). If noCompare is true,\n   * it'll return type of a()\n   * @param nearestNode\n   * @param astNode\n   * @return\n   */\n  public ClassMember resolveExpression3rdParty(ASTNode nearestNode,\n                                          ASTNode astNode, boolean noCompare) {\n    log(\"Resolve 3rdParty expr-- \" + getNodeAsString(astNode)\n        + \" nearest node \" + getNodeAsString(nearestNode));\n    if(astNode == null) return null;\n    ClassMember scopeParent = null;\n    SimpleType stp = null;\n    if(astNode instanceof SimpleName){\n      ASTNode decl = findDeclaration2(((SimpleName)astNode),nearestNode);\n      if(decl != null){\n        // see if locally defined\n        log(getNodeAsString(astNode)+\" found decl -> \" + getNodeAsString(decl));\n\n        {\n          if (decl.getNodeType() == ASTNode.TYPE_DECLARATION) {\n            TypeDeclaration td = (TypeDeclaration) decl;\n            return new ClassMember(td);\n          }\n        }\n\n        { // Handle \"array.\" x \"array[1].\"\n          Type type = extracTypeInfo2(decl);\n          if (type != null && type.isArrayType() &&\n              astNode.getParent().getNodeType() != ASTNode.ARRAY_ACCESS) {\n            // No array access, we want members of the array itself\n            Type elementType = ((ArrayType) type).getElementType();\n\n            // Get name of the element class\n            String name = \"\";\n            if (elementType.isSimpleType()) {\n              Class<?> c = findClassIfExists(elementType.toString());\n              if (c != null) name = c.getName();\n            } else if (elementType.isPrimitiveType()) {\n              name = ((PrimitiveType) elementType).getPrimitiveTypeCode().toString();\n            }\n\n            // Convert element class to array class\n            Class<?> arrayClass = getArrayClass(name);\n\n            return arrayClass == null ? null : new ClassMember(arrayClass);\n          }\n        }\n\n        return new ClassMember(extracTypeInfo(decl));\n      }\n      else {\n        // or in a predefined class?\n        Class<?> tehClass = findClassIfExists(astNode.toString());\n        if (tehClass != null) {\n          return new ClassMember(tehClass);\n        }\n      }\n      astNode = astNode.getParent();\n    }\n    switch (astNode.getNodeType()) {\n    //TODO: Notice the redundancy in the 3 cases, you can simplify things even more.\n    case ASTNode.FIELD_ACCESS:\n      FieldAccess fa = (FieldAccess) astNode;\n      if (fa.getExpression() == null) {\n\n        // TODO: Check for existence of 'new' keyword. Could be a ClassInstanceCreation\n\n        // Local code or belongs to super class\n        log(\"FA,Not implemented.\");\n        return null;\n      } else {\n        if (fa.getExpression() instanceof SimpleName) {\n          stp = extracTypeInfo(findDeclaration2((SimpleName) fa.getExpression(),\n                                                nearestNode));\n          if(stp == null){\n            /*The type wasn't found in local code, so it might be something like\n             * log(), or maybe belonging to super class, etc.\n             */\n            Class<?> tehClass = findClassIfExists(((SimpleName)fa.getExpression()).toString());\n            if (tehClass != null) {\n              // Method Expression is a simple name and wasn't located locally, but found in a class\n              // so look for method in this class.\n              return definedIn3rdPartyClass(new ClassMember(tehClass), fa\n                  .getName().toString());\n            }\n            log(\"FA resolve 3rd par, Can't resolve \" + fa.getExpression());\n\n            return null;\n          }\n          log(\"FA, SN Type \" + getNodeAsString(stp));\n          scopeParent = definedIn3rdPartyClass(stp.getName().toString(), \"THIS\");\n\n        } else {\n          scopeParent = resolveExpression3rdParty(nearestNode,\n                                                  fa.getExpression(), noCompare);\n        }\n        log(\"FA, ScopeParent \" + scopeParent);\n        return definedIn3rdPartyClass(scopeParent, fa.getName().toString());\n      }\n    case ASTNode.METHOD_INVOCATION:\n      MethodInvocation mi = (MethodInvocation) astNode;\n      ASTNode temp = findDeclaration2(mi.getName(), nearestNode);\n      if(temp instanceof MethodDeclaration){\n        // method is locally defined\n        log(mi.getName() + \" was found locally,\" + getNodeAsString(extracTypeInfo(temp)));\n\n        { // Handle \"array.\" x \"array[1].\"\n          Type type = extracTypeInfo2(temp);\n          if (type != null && type.isArrayType() &&\n              astNode.getParent().getNodeType() != ASTNode.ARRAY_ACCESS) {\n            // No array access, we want members of the array itself\n            Type elementType = ((ArrayType) type).getElementType();\n\n            // Get name of the element class\n            String name = \"\";\n            if (elementType.isSimpleType()) {\n              Class<?> c = findClassIfExists(elementType.toString());\n              if (c != null) name = c.getName();\n            } else if (elementType.isPrimitiveType()) {\n              name = ((PrimitiveType) elementType).getPrimitiveTypeCode().toString();\n            }\n\n            // Convert element class to array class\n            Class<?> arrayClass = getArrayClass(name);\n\n            return arrayClass == null ? null : new ClassMember(arrayClass);\n          }\n        }\n\n        return new ClassMember(extracTypeInfo(temp));\n      }\n      if (mi.getExpression() == null) {\n//        if()\n        //Local code or belongs to super class\n        log(\"MI,Not implemented.\");\n        return null;\n      } else {\n        if (mi.getExpression() instanceof SimpleName) {\n          ASTNode decl = findDeclaration2((SimpleName) mi.getExpression(),\n                                          nearestNode);\n          if (decl != null) {\n            if (decl.getNodeType() == ASTNode.TYPE_DECLARATION) {\n              TypeDeclaration td = (TypeDeclaration) decl;\n              return new ClassMember(td);\n            }\n\n            stp = extracTypeInfo(decl);\n            if(stp == null){\n            /*The type wasn't found in local code, so it might be something like\n             * System.console()., or maybe belonging to super class, etc.\n             */\n              Class<?> tehClass = findClassIfExists(((SimpleName)mi.getExpression()).toString());\n              if (tehClass != null) {\n                // Method Expression is a simple name and wasn't located locally, but found in a class\n                // so look for method in this class.\n                return definedIn3rdPartyClass(new ClassMember(tehClass), mi\n                    .getName().toString());\n              }\n              log(\"MI resolve 3rd par, Can't resolve \" + mi.getExpression());\n              return null;\n            }\n            log(\"MI, SN Type \" + getNodeAsString(stp));\n            ASTNode typeDec = findDeclaration2(stp.getName(),nearestNode);\n            if(typeDec == null){\n              log(stp.getName() + \" couldn't be found locally..\");\n              Class<?> tehClass = findClassIfExists(stp.getName().toString());\n              if (tehClass != null) {\n                // Method Expression is a simple name and wasn't located locally, but found in a class\n                // so look for method in this class.\n                return definedIn3rdPartyClass(new ClassMember(tehClass), mi\n                    .getName().toString());\n              }\n              //return new ClassMember(findClassIfExists(stp.getName().toString()));\n            }\n            //scopeParent = definedIn3rdPartyClass(stp.getName().toString(), \"THIS\");\n            return definedIn3rdPartyClass(new ClassMember(typeDec), mi\n                .getName().toString());\n          }\n        } else {\n          log(\"MI EXP..\"+getNodeAsString(mi.getExpression()));\n//          return null;\n          scopeParent = resolveExpression3rdParty(nearestNode,\n                                                  mi.getExpression(), noCompare);\n          log(\"MI, ScopeParent \" + scopeParent);\n          return definedIn3rdPartyClass(scopeParent, mi.getName().toString());\n        }\n\n      }\n    case ASTNode.QUALIFIED_NAME:\n      QualifiedName qn = (QualifiedName) astNode;\n      ASTNode temp2 = findDeclaration2(qn.getName(), nearestNode);\n      if(temp2 instanceof FieldDeclaration){\n        // field is locally defined\n        log(qn.getName() + \" was found locally,\" + getNodeAsString(extracTypeInfo(temp2)));\n        return new ClassMember(extracTypeInfo(temp2));\n      }\n      if (qn.getQualifier() == null) {\n        log(\"QN,Not implemented.\");\n        return null;\n      } else  {\n\n        if (qn.getQualifier() instanceof SimpleName) {\n          stp = extracTypeInfo(findDeclaration2(qn.getQualifier(), nearestNode));\n          if(stp == null){\n            /*The type wasn't found in local code, so it might be something like\n             * log(), or maybe belonging to super class, etc.\n             */\n            Class<?> tehClass = findClassIfExists(qn.getQualifier().toString());\n            if (tehClass != null) {\n              // note how similar thing is called on line 690. Check check.\n              return definedIn3rdPartyClass(new ClassMember(tehClass), qn\n                  .getName().toString());\n            }\n            log(\"QN resolve 3rd par, Can't resolve \" + qn.getQualifier());\n            return null;\n          }\n          log(\"QN, SN Local Type \" + getNodeAsString(stp));\n          //scopeParent = definedIn3rdPartyClass(stp.getName().toString(), \"THIS\");\n          ASTNode typeDec = findDeclaration2(stp.getName(),nearestNode);\n          if(typeDec == null){\n            log(stp.getName() + \" couldn't be found locally..\");\n\n            Class<?> tehClass = findClassIfExists(stp.getName().toString());\n            if (tehClass != null) {\n              // note how similar thing is called on line 690. Check check.\n              return definedIn3rdPartyClass(new ClassMember(tehClass), qn\n                  .getName().toString());\n            }\n            log(\"QN resolve 3rd par, Can't resolve \" + qn.getQualifier());\n            return null;\n          }\n          return definedIn3rdPartyClass(new ClassMember(typeDec), qn\n                                        .getName().toString());\n        } else {\n          scopeParent = resolveExpression3rdParty(nearestNode,\n                                                  qn.getQualifier(), noCompare);\n          log(\"QN, ScopeParent \" + scopeParent);\n          return definedIn3rdPartyClass(scopeParent, qn.getName().toString());\n        }\n\n      }\n    case ASTNode.ARRAY_ACCESS:\n      ArrayAccess arac = (ArrayAccess)astNode;\n      return resolveExpression3rdParty(nearestNode, arac.getArray(), noCompare);\n    default:\n      log(\"Unaccounted type \" + getNodeAsString(astNode));\n      break;\n    }\n\n    return null;\n  }","id":707,"modified_method":"/**\n   * Finds the type of the expression in foo.bar().a().b, this would give me the\n   * type of b if it exists in return type of a(). If noCompare is true,\n   * it'll return type of a()\n   * @param nearestNode\n   * @param astNode\n   * @return\n   */\n  public ClassMember resolveExpression3rdParty(ASTNode nearestNode,\n                                          ASTNode astNode, boolean noCompare) {\n    log(\"Resolve 3rdParty expr-- \" + getNodeAsString(astNode)\n        + \" nearest node \" + getNodeAsString(nearestNode));\n    if(astNode == null) return null;\n    ClassMember scopeParent;\n    SimpleType stp;\n    if(astNode instanceof SimpleName){\n      ASTNode decl = findDeclaration2(((SimpleName)astNode),nearestNode);\n      if(decl != null){\n        // see if locally defined\n        log(getNodeAsString(astNode)+\" found decl -> \" + getNodeAsString(decl));\n\n        {\n          if (decl.getNodeType() == ASTNode.TYPE_DECLARATION) {\n            TypeDeclaration td = (TypeDeclaration) decl;\n            return new ClassMember(td);\n          }\n        }\n\n        { // Handle \"array.\" x \"array[1].\"\n          Type type = extracTypeInfo2(decl);\n          if (type != null && type.isArrayType() &&\n              astNode.getParent().getNodeType() != ASTNode.ARRAY_ACCESS) {\n            // No array access, we want members of the array itself\n            Type elementType = ((ArrayType) type).getElementType();\n\n            // Get name of the element class\n            String name = \"\";\n            if (elementType.isSimpleType()) {\n              Class<?> c = findClassIfExists(elementType.toString());\n              if (c != null) name = c.getName();\n            } else if (elementType.isPrimitiveType()) {\n              name = ((PrimitiveType) elementType).getPrimitiveTypeCode().toString();\n            }\n\n            // Convert element class to array class\n            Class<?> arrayClass = getArrayClass(name);\n\n            return arrayClass == null ? null : new ClassMember(arrayClass);\n          }\n        }\n\n        return new ClassMember(extracTypeInfo(decl));\n      }\n      else {\n        // or in a predefined class?\n        Class<?> tehClass = findClassIfExists(astNode.toString());\n        if (tehClass != null) {\n          return new ClassMember(tehClass);\n        }\n      }\n      astNode = astNode.getParent();\n    }\n    switch (astNode.getNodeType()) {\n    //TODO: Notice the redundancy in the 3 cases, you can simplify things even more.\n    case ASTNode.FIELD_ACCESS:\n      FieldAccess fa = (FieldAccess) astNode;\n      if (fa.getExpression() == null) {\n\n        // TODO: Check for existence of 'new' keyword. Could be a ClassInstanceCreation\n\n        // Local code or belongs to super class\n        log(\"FA,Not implemented.\");\n        return null;\n      } else {\n        if (fa.getExpression() instanceof SimpleName) {\n          stp = extracTypeInfo(findDeclaration2((SimpleName) fa.getExpression(),\n                                                nearestNode));\n          if(stp == null){\n            /*The type wasn't found in local code, so it might be something like\n             * log(), or maybe belonging to super class, etc.\n             */\n            Class<?> tehClass = findClassIfExists(fa.getExpression().toString());\n            if (tehClass != null) {\n              // Method Expression is a simple name and wasn't located locally, but found in a class\n              // so look for method in this class.\n              return definedIn3rdPartyClass(new ClassMember(tehClass), fa\n                  .getName().toString());\n            }\n            log(\"FA resolve 3rd par, Can't resolve \" + fa.getExpression());\n\n            return null;\n          }\n          log(\"FA, SN Type \" + getNodeAsString(stp));\n          scopeParent = definedIn3rdPartyClass(stp.getName().toString(), \"THIS\");\n\n        } else {\n          scopeParent = resolveExpression3rdParty(nearestNode,\n                                                  fa.getExpression(), noCompare);\n        }\n        log(\"FA, ScopeParent \" + scopeParent);\n        return definedIn3rdPartyClass(scopeParent, fa.getName().toString());\n      }\n    case ASTNode.METHOD_INVOCATION:\n      MethodInvocation mi = (MethodInvocation) astNode;\n      ASTNode temp = findDeclaration2(mi.getName(), nearestNode);\n      if(temp instanceof MethodDeclaration){\n        // method is locally defined\n        log(mi.getName() + \" was found locally,\" + getNodeAsString(extracTypeInfo(temp)));\n\n        { // Handle \"array.\" x \"array[1].\"\n          Type type = extracTypeInfo2(temp);\n          if (type != null && type.isArrayType() &&\n              astNode.getParent().getNodeType() != ASTNode.ARRAY_ACCESS) {\n            // No array access, we want members of the array itself\n            Type elementType = ((ArrayType) type).getElementType();\n\n            // Get name of the element class\n            String name = \"\";\n            if (elementType.isSimpleType()) {\n              Class<?> c = findClassIfExists(elementType.toString());\n              if (c != null) name = c.getName();\n            } else if (elementType.isPrimitiveType()) {\n              name = ((PrimitiveType) elementType).getPrimitiveTypeCode().toString();\n            }\n\n            // Convert element class to array class\n            Class<?> arrayClass = getArrayClass(name);\n\n            return arrayClass == null ? null : new ClassMember(arrayClass);\n          }\n        }\n\n        return new ClassMember(extracTypeInfo(temp));\n      }\n      if (mi.getExpression() == null) {\n//        if()\n        //Local code or belongs to super class\n        log(\"MI,Not implemented.\");\n        return null;\n      } else {\n        if (mi.getExpression() instanceof SimpleName) {\n          ASTNode decl = findDeclaration2((SimpleName) mi.getExpression(),\n                                          nearestNode);\n          if (decl != null) {\n            if (decl.getNodeType() == ASTNode.TYPE_DECLARATION) {\n              TypeDeclaration td = (TypeDeclaration) decl;\n              return new ClassMember(td);\n            }\n\n            stp = extracTypeInfo(decl);\n            if(stp == null){\n            /*The type wasn't found in local code, so it might be something like\n             * System.console()., or maybe belonging to super class, etc.\n             */\n              Class<?> tehClass = findClassIfExists(mi.getExpression().toString());\n              if (tehClass != null) {\n                // Method Expression is a simple name and wasn't located locally, but found in a class\n                // so look for method in this class.\n                return definedIn3rdPartyClass(new ClassMember(tehClass), mi\n                    .getName().toString());\n              }\n              log(\"MI resolve 3rd par, Can't resolve \" + mi.getExpression());\n              return null;\n            }\n            log(\"MI, SN Type \" + getNodeAsString(stp));\n            ASTNode typeDec = findDeclaration2(stp.getName(),nearestNode);\n            if(typeDec == null){\n              log(stp.getName() + \" couldn't be found locally..\");\n              Class<?> tehClass = findClassIfExists(stp.getName().toString());\n              if (tehClass != null) {\n                // Method Expression is a simple name and wasn't located locally, but found in a class\n                // so look for method in this class.\n                return definedIn3rdPartyClass(new ClassMember(tehClass), mi\n                    .getName().toString());\n              }\n              //return new ClassMember(findClassIfExists(stp.getName().toString()));\n            }\n            //scopeParent = definedIn3rdPartyClass(stp.getName().toString(), \"THIS\");\n            return definedIn3rdPartyClass(new ClassMember(typeDec), mi\n                .getName().toString());\n          }\n        } else {\n          log(\"MI EXP..\"+getNodeAsString(mi.getExpression()));\n//          return null;\n          scopeParent = resolveExpression3rdParty(nearestNode,\n                                                  mi.getExpression(), noCompare);\n          log(\"MI, ScopeParent \" + scopeParent);\n          return definedIn3rdPartyClass(scopeParent, mi.getName().toString());\n        }\n\n      }\n    case ASTNode.QUALIFIED_NAME:\n      QualifiedName qn = (QualifiedName) astNode;\n      ASTNode temp2 = findDeclaration2(qn.getName(), nearestNode);\n      if(temp2 instanceof FieldDeclaration){\n        // field is locally defined\n        log(qn.getName() + \" was found locally,\" + getNodeAsString(extracTypeInfo(temp2)));\n        return new ClassMember(extracTypeInfo(temp2));\n      }\n      if (qn.getQualifier() == null) {\n        log(\"QN,Not implemented.\");\n        return null;\n      } else  {\n\n        if (qn.getQualifier() instanceof SimpleName) {\n          stp = extracTypeInfo(findDeclaration2(qn.getQualifier(), nearestNode));\n          if(stp == null){\n            /*The type wasn't found in local code, so it might be something like\n             * log(), or maybe belonging to super class, etc.\n             */\n            Class<?> tehClass = findClassIfExists(qn.getQualifier().toString());\n            if (tehClass != null) {\n              // note how similar thing is called on line 690. Check check.\n              return definedIn3rdPartyClass(new ClassMember(tehClass), qn\n                  .getName().toString());\n            }\n            log(\"QN resolve 3rd par, Can't resolve \" + qn.getQualifier());\n            return null;\n          }\n          log(\"QN, SN Local Type \" + getNodeAsString(stp));\n          //scopeParent = definedIn3rdPartyClass(stp.getName().toString(), \"THIS\");\n          ASTNode typeDec = findDeclaration2(stp.getName(),nearestNode);\n          if(typeDec == null){\n            log(stp.getName() + \" couldn't be found locally..\");\n\n            Class<?> tehClass = findClassIfExists(stp.getName().toString());\n            if (tehClass != null) {\n              // note how similar thing is called on line 690. Check check.\n              return definedIn3rdPartyClass(new ClassMember(tehClass), qn\n                  .getName().toString());\n            }\n            log(\"QN resolve 3rd par, Can't resolve \" + qn.getQualifier());\n            return null;\n          }\n          return definedIn3rdPartyClass(new ClassMember(typeDec), qn\n                                        .getName().toString());\n        } else {\n          scopeParent = resolveExpression3rdParty(nearestNode,\n                                                  qn.getQualifier(), noCompare);\n          log(\"QN, ScopeParent \" + scopeParent);\n          return definedIn3rdPartyClass(scopeParent, qn.getName().toString());\n        }\n\n      }\n    case ASTNode.ARRAY_ACCESS:\n      ArrayAccess arac = (ArrayAccess)astNode;\n      return resolveExpression3rdParty(nearestNode, arac.getArray(), noCompare);\n    default:\n      log(\"Unaccounted type \" + getNodeAsString(astNode));\n      break;\n    }\n\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public ClassMember(ASTNode node){\n      astNode = node;\n      stringVal = getNodeAsString(node);\n      if(node instanceof TypeDeclaration){\n        declaringNode = node;\n      }\n      if(node instanceof SimpleType){\n        classType = ((SimpleType)node).getName().toString();\n      }\n      SimpleType stp = (node instanceof SimpleType) ? (SimpleType) node\n          : extracTypeInfo(node);\n      if(stp != null){\n        ASTNode decl =findDeclaration(stp.getName());\n        // Czech out teh mutation\n        if(decl == null){\n          // a predefined type\n          classType = stp.getName().toString();\n          Class<?> probableClass = findClassIfExists(classType);\n          thisclass = probableClass;\n        }\n        else{\n          // a local type\n          declaringNode = decl;\n        }\n      }\n    }","id":708,"modified_method":"public ClassMember(ASTNode node){\n      astNode = node;\n      stringVal = getNodeAsString(node);\n      if(node instanceof TypeDeclaration){\n        declaringNode = node;\n      }\n      if(node instanceof SimpleType){\n        classType = ((SimpleType)node).getName().toString();\n      }\n      SimpleType stp = (node instanceof SimpleType) ? (SimpleType) node\n          : extracTypeInfo(node);\n      if(stp != null){\n        ASTNode decl =findDeclaration(stp.getName());\n        // Czech out teh mutation\n        if(decl == null){\n          // a predefined type\n          classType = stp.getName().toString();\n          thisclass = findClassIfExists(classType);\n        }\n        else{\n          // a local type\n          declaringNode = decl;\n        }\n      }\n    }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * CompletionPanel name\n   *\n   * @param node\n   * @return\n   */\n  static protected String getNodeAsString2(ASTNode node) {\n    if (node == null)\n      return \"NULL\";\n    String className = node.getClass().getName();\n    int index = className.lastIndexOf(\".\");\n    if (index > 0)\n      className = className.substring(index + 1);\n\n    // if(node instanceof BodyDeclaration)\n    // return className;\n\n    String value = className;\n\n    if (node instanceof TypeDeclaration)\n      value = ((TypeDeclaration) node).getName().toString();\n    else if (node instanceof MethodDeclaration)\n      value = ((MethodDeclaration) node).getName().toString();\n    else if (node instanceof MethodInvocation)\n      value = ((MethodInvocation) node).getName().toString() + \" | \"\n          + className;\n    else if (node instanceof FieldDeclaration)\n      value = ((FieldDeclaration) node).toString();\n    else if (node instanceof SingleVariableDeclaration)\n      value = ((SingleVariableDeclaration) node).getName().toString();\n    else if (node instanceof ExpressionStatement)\n      value = node.toString() + className;\n    else if (node instanceof SimpleName)\n      value = ((SimpleName) node).getFullyQualifiedName() + \" | \" + className;\n    else if (node instanceof QualifiedName)\n      value = node.toString();\n    else if (node instanceof VariableDeclarationFragment)\n      value = ((VariableDeclarationFragment) node).getName().toString();\n    else if (className.startsWith(\"Variable\"))\n      value = node.toString();\n    else if (node instanceof VariableDeclarationStatement)\n      value = ((VariableDeclarationStatement) node).toString();\n    else if (className.endsWith(\"Type\"))\n      value = node.toString();\n//    value += \" [\" + node.getStartPosition() + \",\"\n//        + (node.getStartPosition() + node.getLength()) + \"]\";\n//    value += \" Line: \"\n//        + ((CompilationUnit) node.getRoot()).getLineNumber(node\n//            .getStartPosition());\n    return value;\n  }","id":709,"modified_method":"/**\n   * CompletionPanel name\n   *\n   * @param node\n   * @return\n   */\n  static protected String getNodeAsString2(ASTNode node) {\n    if (node == null)\n      return \"NULL\";\n    String className = node.getClass().getName();\n    int index = className.lastIndexOf(\".\");\n    if (index > 0)\n      className = className.substring(index + 1);\n\n    // if(node instanceof BodyDeclaration)\n    // return className;\n\n    String value = className;\n\n    if (node instanceof TypeDeclaration)\n      value = ((TypeDeclaration) node).getName().toString();\n    else if (node instanceof MethodDeclaration)\n      value = ((MethodDeclaration) node).getName().toString();\n    else if (node instanceof MethodInvocation)\n      value = ((MethodInvocation) node).getName().toString() + \" | \"\n          + className;\n    else if (node instanceof FieldDeclaration)\n      value = node.toString();\n    else if (node instanceof SingleVariableDeclaration)\n      value = ((SingleVariableDeclaration) node).getName().toString();\n    else if (node instanceof ExpressionStatement)\n      value = node.toString() + className;\n    else if (node instanceof SimpleName)\n      value = ((SimpleName) node).getFullyQualifiedName() + \" | \" + className;\n    else if (node instanceof QualifiedName)\n      value = node.toString();\n    else if (node instanceof VariableDeclarationFragment)\n      value = ((VariableDeclarationFragment) node).getName().toString();\n    else if (className.startsWith(\"Variable\"))\n      value = node.toString();\n    else if (node instanceof VariableDeclarationStatement)\n      value = node.toString();\n    else if (className.endsWith(\"Type\"))\n      value = node.toString();\n//    value += \" [\" + node.getStartPosition() + \",\"\n//        + (node.getStartPosition() + node.getLength()) + \"]\";\n//    value += \" Line: \"\n//        + ((CompilationUnit) node.getRoot()).getLineNumber(node\n//            .getStartPosition());\n    return value;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"static protected String getNodeAsString(ASTNode node) {\n    if (node == null)\n      return \"NULL\";\n    String className = node.getClass().getName();\n    int index = className.lastIndexOf(\".\");\n    if (index > 0)\n      className = className.substring(index + 1);\n\n    // if(node instanceof BodyDeclaration)\n    // return className;\n\n    String value = className;\n\n    if (node instanceof TypeDeclaration)\n      value = ((TypeDeclaration) node).getName().toString() + \" | \" + className;\n    else if (node instanceof MethodDeclaration)\n      value = ((MethodDeclaration) node).getName().toString() + \" | \"\n          + className;\n    else if (node instanceof MethodInvocation)\n      value = ((MethodInvocation) node).getName().toString() + \" | \"\n          + className;\n    else if (node instanceof FieldDeclaration)\n      value = ((FieldDeclaration) node).toString() + \" FldDecl| \";\n    else if (node instanceof SingleVariableDeclaration)\n      value = ((SingleVariableDeclaration) node).getName() + \" - \"\n          + ((SingleVariableDeclaration) node).getType() + \" | SVD \";\n    else if (node instanceof ExpressionStatement)\n      value = node.toString() + className;\n    else if (node instanceof SimpleName)\n      value = ((SimpleName) node).getFullyQualifiedName() + \" | \" + className;\n    else if (node instanceof QualifiedName)\n      value = node.toString() + \" | \" + className;\n    else if(node instanceof FieldAccess)\n      value = node.toString() + \" | \";\n    else if (className.startsWith(\"Variable\"))\n      value = node.toString() + \" | \" + className;\n    else if (className.endsWith(\"Type\"))\n      value = node.toString() + \" |\" + className;\n    value += \" [\" + node.getStartPosition() + \",\"\n        + (node.getStartPosition() + node.getLength()) + \"]\";\n    value += \" Line: \"\n        + ((CompilationUnit) node.getRoot()).getLineNumber(node\n            .getStartPosition());\n    return value;\n  }","id":710,"modified_method":"static protected String getNodeAsString(ASTNode node) {\n    if (node == null)\n      return \"NULL\";\n    String className = node.getClass().getName();\n    int index = className.lastIndexOf(\".\");\n    if (index > 0)\n      className = className.substring(index + 1);\n\n    // if(node instanceof BodyDeclaration)\n    // return className;\n\n    String value = className;\n\n    if (node instanceof TypeDeclaration)\n      value = ((TypeDeclaration) node).getName().toString() + \" | \" + className;\n    else if (node instanceof MethodDeclaration)\n      value = ((MethodDeclaration) node).getName().toString() + \" | \"\n          + className;\n    else if (node instanceof MethodInvocation)\n      value = ((MethodInvocation) node).getName().toString() + \" | \"\n          + className;\n    else if (node instanceof FieldDeclaration)\n      value = node.toString() + \" FldDecl| \";\n    else if (node instanceof SingleVariableDeclaration)\n      value = ((SingleVariableDeclaration) node).getName() + \" - \"\n          + ((SingleVariableDeclaration) node).getType() + \" | SVD \";\n    else if (node instanceof ExpressionStatement)\n      value = node.toString() + className;\n    else if (node instanceof SimpleName)\n      value = ((SimpleName) node).getFullyQualifiedName() + \" | \" + className;\n    else if (node instanceof QualifiedName)\n      value = node.toString() + \" | \" + className;\n    else if(node instanceof FieldAccess)\n      value = node.toString() + \" | \";\n    else if (className.startsWith(\"Variable\"))\n      value = node.toString() + \" | \" + className;\n    else if (className.endsWith(\"Type\"))\n      value = node.toString() + \" |\" + className;\n    value += \" [\" + node.getStartPosition() + \",\"\n        + (node.getStartPosition() + node.getLength()) + \"]\";\n    value += \" Line: \"\n        + ((CompilationUnit) node.getRoot()).getLineNumber(node\n            .getStartPosition());\n    return value;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"protected static ASTNode findClosestNode(int lineNumber, ASTNode node) {\n    log(\"findClosestNode to line \" + lineNumber);\n    ASTNode parent = findClosestParentNode(lineNumber, node);\n    log(\"findClosestParentNode returned \" + getNodeAsString(parent));\n    if (parent == null)\n      return null;\n    if (getLineNumber(parent) == lineNumber){\n      log(parent + \"|PNode \" + getLineNumber(parent) + \", lfor \" + lineNumber );\n      return parent;\n    }\n    List<ASTNode> nodes = null;\n    if (parent instanceof TypeDeclaration) {\n      nodes = ((TypeDeclaration) parent).bodyDeclarations();\n    } else if (parent instanceof Block) {\n      nodes = ((Block) parent).statements();\n    } else {\n      System.err.println(\"findClosestNode() found \" + getNodeAsString(parent));\n      return null;\n    }\n\n    if (nodes.size() > 0) {\n      ASTNode retNode = parent;\n      for (int i = 0; i < nodes.size(); i++) {\n        ASTNode cNode = nodes.get(i);\n        log(cNode + \"|cNode \" + getLineNumber(cNode) + \", lfor \" + lineNumber );\n        if (getLineNumber(cNode) <= lineNumber)\n          retNode = cNode;\n      }\n\n      return retNode;\n    }\n    return parent;\n  }","id":711,"modified_method":"protected static ASTNode findClosestNode(int lineNumber, ASTNode node) {\n    log(\"findClosestNode to line \" + lineNumber);\n    ASTNode parent = findClosestParentNode(lineNumber, node);\n    log(\"findClosestParentNode returned \" + getNodeAsString(parent));\n    if (parent == null)\n      return null;\n    if (getLineNumber(parent) == lineNumber){\n      log(parent + \"|PNode \" + getLineNumber(parent) + \", lfor \" + lineNumber );\n      return parent;\n    }\n    List<ASTNode> nodes;\n    if (parent instanceof TypeDeclaration) {\n      nodes = ((TypeDeclaration) parent).bodyDeclarations();\n    } else if (parent instanceof Block) {\n      nodes = ((Block) parent).statements();\n    } else {\n      System.err.println(\"findClosestNode() found \" + getNodeAsString(parent));\n      return null;\n    }\n\n    if (nodes.size() > 0) {\n      ASTNode retNode = parent;\n      for (ASTNode cNode : nodes) {\n        log(cNode + \"|cNode \" + getLineNumber(cNode) + \", lfor \" + lineNumber);\n        if (getLineNumber(cNode) <= lineNumber)\n          retNode = cNode;\n      }\n\n      return retNode;\n    }\n    return parent;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tfinal HTTPRequest request = new HTTPRequest(uri);\n\t\t\n\t\tString path = uri.getPath();\n\t\tif(path.endsWith(\"myref.fref\")) {\n\t\t\tSimpleFieldSet fs = node.exportPublicFieldSet();\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tfs.writeTo(sw);\n\t\t\tthis.writeReply(ctx, 200, \"text/plain\", \"OK\", sw.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\tfinal boolean fProxyJavascriptEnabled = node.isFProxyJavascriptEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\t\n\t\t\t\tif(request.isParameterSet(\"sortBy\")){\n\t\t\t\t\tfinal String sortBy = request.getParam(\"sortBy\"); \n\t\t\t\t\tif(sortBy.equals(\"name\")){\n\t\t\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t\t\t}else if(sortBy.equals(\"address\")){\n\t\t\t\t\t\treturn firstNode.getPeerAddress().compareToIgnoreCase(secondNode.getPeerAddress());\n\t\t\t\t\t}else if(sortBy.equals(\"location\")){\n\t\t\t\t\t\tdouble diff = firstNode.getLocation() - secondNode.getLocation();\n\t\t\t\t\t\treturn diff > 0 ? -1 : 1; // It shouldn't ever be equal anyway\n\t\t\t\t\t}else if(sortBy.equals(\"version\")){\n\t\t\t\t\t\treturn firstNode.getVersion().compareTo(secondNode.getVersion());\n\t\t\t\t\t}else if(sortBy.equals(\"privnote\")){\n\t\t\t\t\t\treturn firstNode.getPrivateDarknetCommentNote().compareTo(secondNode.getPrivateDarknetCommentNote());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tint numberOfSimpleConnected = numberOfConnected + numberOfRoutingBackedOff;\n\t\tint numberOfNotConnected = numberOfTooNew + numberOfTooOld + numberOfDisconnected + numberOfNeverConnected + numberOfDisabled + numberOfBursting + numberOfListening + numberOfListenOnly;\n\t\tString titleCountString = null;\n\t\tif(advancedEnabled) {\n\t\t\ttitleCountString = \"(\" + numberOfConnected + '/' + numberOfRoutingBackedOff + '/' + numberOfTooNew + '/' + numberOfTooOld + '/' + numberOfNotConnected + ')';\n\t\t} else {\n\t\t\ttitleCountString = (numberOfNotConnected + numberOfSimpleConnected)>0 ? String.valueOf(numberOfSimpleConnected) : \"\";\n\t\t}\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(titleCountString + \" Darknet Peers of \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimateRecent = 0;\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimateRecent = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix4 = new DecimalFormat(\"0.0000\");\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tDecimalFormat fix1 = new DecimalFormat(\"##0.0%\");\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\t// BEGIN OVERVIEW TABLE\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateRecent:\\u00a0\" + networkSizeEstimateRecent + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix1.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix1.format(node.pRejectIncomingInstantly()));\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0]) + \"\\u00a0(\" + SizeUtil.formatSize(total_output_rate) + \"ps)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload) + \"\\u00a0(\" + SizeUtil.formatSize(total_payload_rate) + \"ps) (\"+percent+\"%)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1]) + \"\\u00a0(\" + SizeUtil.formatSize(total_input_rate) + \"ps)\");\n\t\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\t\tactivityList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate) + \"ps\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate) + \"ps\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// END OVERVIEW TABLE\n\n\t\t\t// BEGIN PEER TABLE\n\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\tStringBuffer jsBuf = new StringBuffer();\n\t\t\t\t// FIXME: There's probably some icky Javascript in here (this is the first thing that worked for me); feel free to fix up to Javascript guru standards\n\t\t\t\tjsBuf.append( \"  function peerNoteChange() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\t//jsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).submit();\\n\" );\n\t\t\t\tjsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).doAction.click();\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tjsBuf.append( \"  function peerNoteBlur() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tcontentNode.addChild(\"script\", \"type\", \"text/javascript\").addChild(\"%\", jsBuf.toString());\n\t\t\t}\n\t\t\tHTMLNode peerTableInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode peerTableInfoboxHeader = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \"My peers\");\n\t\t\tif (advancedEnabled) {\n\t\t\t\tif (!path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \" \");\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"a\", \"href\", \"displaymessagetypes.html\", \"(more detailed)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tHTMLNode peerTableInfoboxContent = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tif (peerNodeStatuses.length == 0) {\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \"Freenet can not work as you have not added any peers so far. Please go to the \");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"a\", \"href\", \"/\", \"node homepage\");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \" and read the top infobox to see how it is done.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode peerForm = peerTableInfoboxContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\", \"id\", \"name\" }, new String[] { \".\", \"post\", \"multipart/form-data\", \"peersForm\", \"peersForm\" });\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\t\tHTMLNode peerTable = peerForm.addChild(\"table\", \"class\", \"darknet_connections\");\n\t\t\t\tHTMLNode peerTableHeaderRow = peerTable.addChild(\"tr\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=status\").addChild(\"#\", \"Status\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=name\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's name. Click on the name link to send the node a N2NTM (Node To Node Text Message)\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Name\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=address\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's network address as IP:Port\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Address\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=version\").addChild(\"#\", \"Version\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=location\").addChild(\"#\", \"Location\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Other node busy? Display: Percentage of time the node is overloaded, Current wait time remaining (0=not overloaded)/total/last overload reason\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Backoff\");\n\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Probability of the node rejecting a request due to overload or causing a timeout.\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Overload Probability\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"How long since the node was connected or last seen\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\\u00a0/\\u00a0Idle\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=privnote\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"A private note concerning this peer\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Private Note\");\n\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"%\\u00a0Time Routable\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"Total\\u00a0Traffic\\u00a0(in/out)\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int peerIndex = 0, peerCount = peerNodeStatuses.length; peerIndex < peerCount; peerIndex++) {\n\t\t\t\t\tPeerNodeStatus peerNodeStatus = peerNodeStatuses[peerIndex];\n\t\t\t\t\tHTMLNode peerRow = peerTable.addChild(\"tr\");\n\n\t\t\t\t\t// check box column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-marker\").addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"node_\" + peerNodeStatus.hashCode() });\n\n\t\t\t\t\t// status column\n\t\t\t\t\tString statusString = peerNodeStatus.getStatusName();\n\t\t\t\t\tif (!advancedEnabled && (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF)) {\n\t\t\t\t\t\tstatusString = \"BUSY\";\n\t\t\t\t\t}\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-status\").addChild(\"span\", \"class\", peerNodeStatus.getStatusCSSName(), statusString + (peerNodeStatus.isFetchingARK() ? \"*\" : \"\"));\n\n\t\t\t\t\t// name column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-name\").addChild(\"a\", \"href\", \"/send_n2ntm/?peernode_hashcode=\" + peerNodeStatus.hashCode(), peerNodeStatus.getName());\n\n\t\t\t\t\t// address column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tString pingTime = \"\";\n\t\t\t\t\t\tif (peerNodeStatus.isConnected()) {\n\t\t\t\t\t\t\tpingTime = \" (\" + (int) peerNodeStatus.getAveragePingTime() + \"ms)\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-address\").addChild(\"#\", ((peerNodeStatus.getPeerAddress() != null) ? (peerNodeStatus.getPeerAddress() + ':' + peerNodeStatus.getPeerPort()) : (\"(unknown address)\")) + pingTime);\n\t\t\t\t\t}\n\n\t\t\t\t\t// version column\n\t\t\t\t\tif (peerNodeStatus.getStatusValue() != Node.PEER_NODE_STATUS_NEVER_CONNECTED && (peerNodeStatus.isPublicInvalidVersion() || peerNodeStatus.isPublicReverseInvalidVersion())) {  // Don't draw attention to a version problem if NEVER CONNECTED\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"span\", \"class\", \"peer_version_problem\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"#\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t}\n\n\t\t\t\t\t// location column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-location\", String.valueOf(peerNodeStatus.getLocation()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\t// backoff column\n\t\t\t\t\t\tHTMLNode backoffCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\");\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", fix1.format(peerNodeStatus.getBackedOffPercent()));\n\t\t\t\t\t\tint backoff = (int) (Math.max(peerNodeStatus.getRoutingBackedOffUntil() - now, 0));\n\t\t\t\t\t\t// Don't list the backoff as zero before it's actually zero\n\t\t\t\t\t\tif ((backoff > 0) && (backoff < 1000)) {\n\t\t\t\t\t\t\tbackoff = 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", ' ' + String.valueOf(backoff / 1000) + '/' + String.valueOf(peerNodeStatus.getRoutingBackoffLength() / 1000));\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", (peerNodeStatus.getLastBackoffReason() == null) ? \"\" : ('/' + (peerNodeStatus.getLastBackoffReason())));\n\n\t\t\t\t\t\t// overload probability column\n\t\t\t\t\t\tHTMLNode pRejectCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\"); // FIXME\n\t\t\t\t\t\tpRejectCell.addChild(\"#\", fix1.format(peerNodeStatus.getPReject()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// idle column\n\t\t\t\t\tlong idle = peerNodeStatus.getTimeLastRoutable();\n\t\t\t\t\tif (peerNodeStatus.isRoutable()) {\n\t\t\t\t\t\tidle = peerNodeStatus.getTimeLastConnectionCompleted();\n\t\t\t\t\t} else if (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_NEVER_CONNECTED) {\n\t\t\t\t\t\tidle = peerNodeStatus.getPeerAddedTime();\n\t\t\t\t\t}\n\t\t\t\t\tif(!peerNodeStatus.isConnected() && (now - idle) > (2 * 7 * 24 * 60 * 60 * (long) 1000)) { // 2 weeks\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\").addChild(\"span\", \"class\", \"peer_idle_old\", idleToString(now, idle));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\", idleToString(now, idle));\n\t\t\t\t\t}\n\n\t\t\t\t\t// private darknet node comment note column\n\t\t\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"onBlur\", \"onChange\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", \"peerNoteBlur();\", \"peerNoteChange();\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t}\n\n\t\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\t\t// percent of time connected column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", fix1.format(peerNodeStatus.getPercentTimeRoutableConnection()));\n\t\t\t\t\t\t// total traffic column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", SizeUtil.formatSize(peerNodeStatus.getTotalInputBytes())+\" / \"+SizeUtil.formatSize(peerNodeStatus.getTotalOutputBytes()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\t\tHTMLNode messageCountRow = peerTable.addChild(\"tr\", \"class\", \"message-status\");\n\t\t\t\t\t\tmessageCountRow.addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\t\t\tHTMLNode messageCountCell = messageCountRow.addChild(\"td\", \"colspan\", String.valueOf(advancedEnabled ? 9 : 5));  // = total table row width - 2 from above colspan\n\t\t\t\t\t\tHTMLNode messageCountTable = messageCountCell.addChild(\"table\", \"class\", \"message-count\");\n\t\t\t\t\t\tHTMLNode countHeaderRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Message\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Incoming\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Outgoing\");\n\t\t\t\t\t\tList messageNames = new ArrayList();\n\t\t\t\t\t\tMap messageCounts = new HashMap();\n\t\t\t\t\t\tfor (Iterator incomingMessages = peerNodeStatus.getLocalMessagesReceived().keySet().iterator(); incomingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) incomingMessages.next();\n\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesReceived().get(messageName);\n\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { messageCount, new Long(0) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Iterator outgoingMessages = peerNodeStatus.getLocalMessagesSent().keySet().iterator(); outgoingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) outgoingMessages.next();\n\t\t\t\t\t\t\tif (!messageNames.contains(messageName)) {\n\t\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesSent().get(messageName);\n\t\t\t\t\t\t\tLong[] existingCounts = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tif (existingCounts == null) {\n\t\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { new Long(0), messageCount });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texistingCounts[1] = messageCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(messageNames, new Comparator() {\n\t\t\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\t\t\treturn ((String) first).compareToIgnoreCase((String) second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (Iterator messageNamesIterator = messageNames.iterator(); messageNamesIterator.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) messageNamesIterator.next();\n\t\t\t\t\t\t\tLong[] messageCount = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tHTMLNode messageRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", messageName);\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[0]));\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tHTMLNode actionSelect = peerForm.addChild(\"select\", new String[] { \"id\", \"name\" }, new String[] { \"action\", \"action\" });\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- Select action --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"send_n2ntm\", \"Send N2NTM to selected peers\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"update_notes\", \"Update changed private notes\");\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"enable\", \"Enable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"disable\", \"Disable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_burst_only\", \"On selected peers, set BurstOnly (only set this if you have a static IP and are not NATed and neither is the peer)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_burst_only\", \"On selected peers, clear BurstOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_listen_only\", \"On selected peers, set ListenOnly (not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_listen_only\", \"On selected peers, clear ListenOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_allow_local\", \"On selected peers, set allowLocalAddresses (useful if you are connecting to another node on the same LAN)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_allow_local\", \"On selected peers, clear allowLocalAddresses\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_ignore_source_port\", \"On selected peers, set ignoreSourcePort (try this if behind an evil corporate firewall; otherwise not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_ignore_source_port\", \"On selected peers, clear ignoreSourcePort\");\n\t\t\t\t}\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- -- --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"remove\", \"Remove selected peers\");\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"doAction\", \"Go\" });\n\t\t\t}\n\t\t\t// END PEER TABLE\n\n\t\t}\n\t\t\n\t\t// BEGIN PEER ADDITION BOX\n\t\tHTMLNode peerAdditionInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tpeerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Add another peer\");\n\t\tHTMLNode peerAdditionContent = peerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode peerAdditionForm = peerAdditionContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\" }, new String[] { \".\", \"post\", \"multipart/form-data\" });\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\tpeerAdditionForm.addChild(\"#\", \"Paste the reference here:\");\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"textarea\", new String[] { \"id\", \"name\", \"rows\", \"cols\" }, new String[] { \"reftext\", \"ref\", \"8\", \"74\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter the URL of the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"refurl\", \"text\", \"url\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Choose the file containing the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"reffile\", \"file\", \"reffile\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter a node description: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"peerPrivateNote\", \"text\", \"peerPrivateNote\", \"16\", \"250\", \"\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"add\", \"Add\" });\n\t\t\n\t\t// our reference\n\t\tHTMLNode referenceInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-header\").addChild(\"a\", \"href\", \"myref.fref\", \"My reference\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-content\").addChild(\"pre\", \"id\", \"reference\", node.exportPublicFieldSet().toString());\n\t\t\n\t\t// our ports\n\t\tHTMLNode portInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tportInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node's Ports\");\n\t\tHTMLNode portInfoboxContent = portInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode portInfoList = portInfoboxContent.addChild(\"ul\");\n\t\tSimpleFieldSet fproxyConfig = node.config.get(\"fproxy\").exportFieldSet(true);\n\t\tSimpleFieldSet fcpConfig = node.config.get(\"fcp\").exportFieldSet(true);\n\t\tSimpleFieldSet tmciConfig = node.config.get(\"console\").exportFieldSet(true);\n\t\tportInfoList.addChild(\"li\", \"FNP:\\u00a0\" + node.getFNPPort() + \"/udp\\u00a0\\u00a0\\u00a0(between nodes; this is usually the only port that you might want to port forward)\");\n\t\ttry {\n\t\t\tif(fproxyConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0\" + fproxyConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t}\n\t\t\tif(fcpConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0\" + fcpConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t}\n\t\t\tif(tmciConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0\" + tmciConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\tStringBuffer pageBuffer = new StringBuffer();\n\t\tpageNode.generate(pageBuffer);\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageBuffer.toString());\n\t}","id":712,"modified_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tfinal HTTPRequest request = new HTTPRequest(uri);\n\t\t\n\t\tString path = uri.getPath();\n\t\tif(path.endsWith(\"myref.fref\")) {\n\t\t\tSimpleFieldSet fs = node.exportPublicFieldSet();\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tfs.writeTo(sw);\n\t\t\tthis.writeReply(ctx, 200, \"text/plain\", \"OK\", sw.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\tfinal boolean fProxyJavascriptEnabled = node.isFProxyJavascriptEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\t\n\t\t\t\tif(request.isParameterSet(\"sortBy\")){\n\t\t\t\t\tfinal String sortBy = request.getParam(\"sortBy\"); \n\t\t\t\t\tif(sortBy.equals(\"name\")){\n\t\t\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t\t\t}else if(sortBy.equals(\"address\")){\n\t\t\t\t\t\treturn firstNode.getPeerAddress().compareToIgnoreCase(secondNode.getPeerAddress());\n\t\t\t\t\t}else if(sortBy.equals(\"location\")){\n\t\t\t\t\t\tdouble diff = firstNode.getLocation() - secondNode.getLocation();\n\t\t\t\t\t\treturn diff > 0 ? -1 : 1; // It shouldn't ever be equal anyway\n\t\t\t\t\t}else if(sortBy.equals(\"version\")){\n\t\t\t\t\t\treturn firstNode.getVersion().compareTo(secondNode.getVersion());\n\t\t\t\t\t}else if(sortBy.equals(\"privnote\")){\n\t\t\t\t\t\treturn firstNode.getPrivateDarknetCommentNote().compareTo(secondNode.getPrivateDarknetCommentNote());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tint numberOfSimpleConnected = numberOfConnected + numberOfRoutingBackedOff;\n\t\tint numberOfNotConnected = numberOfTooNew + numberOfTooOld + numberOfDisconnected + numberOfNeverConnected + numberOfDisabled + numberOfBursting + numberOfListening + numberOfListenOnly;\n\t\tString titleCountString = null;\n\t\tif(advancedEnabled) {\n\t\t\ttitleCountString = \"(\" + numberOfConnected + '/' + numberOfRoutingBackedOff + '/' + numberOfTooNew + '/' + numberOfTooOld + '/' + numberOfNotConnected + ')';\n\t\t} else {\n\t\t\ttitleCountString = (numberOfNotConnected + numberOfSimpleConnected)>0 ? String.valueOf(numberOfSimpleConnected) : \"\";\n\t\t}\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(titleCountString + \" Darknet Peers of \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimateRecent = 0;\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimateRecent = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix4 = new DecimalFormat(\"0.0000\");\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tDecimalFormat fix1 = new DecimalFormat(\"##0.0%\");\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\t// BEGIN OVERVIEW TABLE\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateRecent:\\u00a0\" + networkSizeEstimateRecent + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix1.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix1.format(node.pRejectIncomingInstantly()));\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0], true) + \"\\u00a0(\" + SizeUtil.formatSize(total_output_rate, true) + \"ps)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload, true) + \"\\u00a0(\" + SizeUtil.formatSize(total_payload_rate, true) + \"ps) (\"+percent+\"%)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1], true) + \"\\u00a0(\" + SizeUtil.formatSize(total_input_rate, true) + \"ps)\");\n\t\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\t\tSubConfig nodeConfig = node.config.get(\"node\");\n\t\t\t\t\tint outputBandwidthLimit = nodeConfig.getInt(\"outputBandwidthLimit\");\n\t\t\t\t\tint inputBandwidthLimit = nodeConfig.getInt(\"inputBandwidthLimit\");\n\t\t\t\t\tif(inputBandwidthLimit == -1) {\n\t\t\t\t\t\tinputBandwidthLimit = outputBandwidthLimit * 4;\n\t\t\t\t\t}\n\t\t\t\t\tactivityList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(outputBandwidthLimit, true)+\"ps)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(inputBandwidthLimit, true)+\"ps)\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// END OVERVIEW TABLE\n\n\t\t\t// BEGIN PEER TABLE\n\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\tStringBuffer jsBuf = new StringBuffer();\n\t\t\t\t// FIXME: There's probably some icky Javascript in here (this is the first thing that worked for me); feel free to fix up to Javascript guru standards\n\t\t\t\tjsBuf.append( \"  function peerNoteChange() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\t//jsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).submit();\\n\" );\n\t\t\t\tjsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).doAction.click();\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tjsBuf.append( \"  function peerNoteBlur() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tcontentNode.addChild(\"script\", \"type\", \"text/javascript\").addChild(\"%\", jsBuf.toString());\n\t\t\t}\n\t\t\tHTMLNode peerTableInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode peerTableInfoboxHeader = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \"My peers\");\n\t\t\tif (advancedEnabled) {\n\t\t\t\tif (!path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \" \");\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"a\", \"href\", \"displaymessagetypes.html\", \"(more detailed)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tHTMLNode peerTableInfoboxContent = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tif (peerNodeStatuses.length == 0) {\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \"Freenet can not work as you have not added any peers so far. Please go to the \");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"a\", \"href\", \"/\", \"node homepage\");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \" and read the top infobox to see how it is done.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode peerForm = peerTableInfoboxContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\", \"id\", \"name\" }, new String[] { \".\", \"post\", \"multipart/form-data\", \"peersForm\", \"peersForm\" });\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\t\tHTMLNode peerTable = peerForm.addChild(\"table\", \"class\", \"darknet_connections\");\n\t\t\t\tHTMLNode peerTableHeaderRow = peerTable.addChild(\"tr\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=status\").addChild(\"#\", \"Status\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=name\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's name. Click on the name link to send the node a N2NTM (Node To Node Text Message)\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Name\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=address\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's network address as IP:Port\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Address\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=version\").addChild(\"#\", \"Version\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=location\").addChild(\"#\", \"Location\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Other node busy? Display: Percentage of time the node is overloaded, Current wait time remaining (0=not overloaded)/total/last overload reason\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Backoff\");\n\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Probability of the node rejecting a request due to overload or causing a timeout.\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Overload Probability\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"How long since the node was connected or last seen\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\\u00a0/\\u00a0Idle\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=privnote\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"A private note concerning this peer\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Private Note\");\n\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"%\\u00a0Time Routable\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"Total\\u00a0Traffic\\u00a0(in/out)\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int peerIndex = 0, peerCount = peerNodeStatuses.length; peerIndex < peerCount; peerIndex++) {\n\t\t\t\t\tPeerNodeStatus peerNodeStatus = peerNodeStatuses[peerIndex];\n\t\t\t\t\tHTMLNode peerRow = peerTable.addChild(\"tr\");\n\n\t\t\t\t\t// check box column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-marker\").addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"node_\" + peerNodeStatus.hashCode() });\n\n\t\t\t\t\t// status column\n\t\t\t\t\tString statusString = peerNodeStatus.getStatusName();\n\t\t\t\t\tif (!advancedEnabled && (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF)) {\n\t\t\t\t\t\tstatusString = \"BUSY\";\n\t\t\t\t\t}\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-status\").addChild(\"span\", \"class\", peerNodeStatus.getStatusCSSName(), statusString + (peerNodeStatus.isFetchingARK() ? \"*\" : \"\"));\n\n\t\t\t\t\t// name column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-name\").addChild(\"a\", \"href\", \"/send_n2ntm/?peernode_hashcode=\" + peerNodeStatus.hashCode(), peerNodeStatus.getName());\n\n\t\t\t\t\t// address column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tString pingTime = \"\";\n\t\t\t\t\t\tif (peerNodeStatus.isConnected()) {\n\t\t\t\t\t\t\tpingTime = \" (\" + (int) peerNodeStatus.getAveragePingTime() + \"ms)\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-address\").addChild(\"#\", ((peerNodeStatus.getPeerAddress() != null) ? (peerNodeStatus.getPeerAddress() + ':' + peerNodeStatus.getPeerPort()) : (\"(unknown address)\")) + pingTime);\n\t\t\t\t\t}\n\n\t\t\t\t\t// version column\n\t\t\t\t\tif (peerNodeStatus.getStatusValue() != Node.PEER_NODE_STATUS_NEVER_CONNECTED && (peerNodeStatus.isPublicInvalidVersion() || peerNodeStatus.isPublicReverseInvalidVersion())) {  // Don't draw attention to a version problem if NEVER CONNECTED\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"span\", \"class\", \"peer_version_problem\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"#\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t}\n\n\t\t\t\t\t// location column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-location\", String.valueOf(peerNodeStatus.getLocation()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\t// backoff column\n\t\t\t\t\t\tHTMLNode backoffCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\");\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", fix1.format(peerNodeStatus.getBackedOffPercent()));\n\t\t\t\t\t\tint backoff = (int) (Math.max(peerNodeStatus.getRoutingBackedOffUntil() - now, 0));\n\t\t\t\t\t\t// Don't list the backoff as zero before it's actually zero\n\t\t\t\t\t\tif ((backoff > 0) && (backoff < 1000)) {\n\t\t\t\t\t\t\tbackoff = 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", ' ' + String.valueOf(backoff / 1000) + '/' + String.valueOf(peerNodeStatus.getRoutingBackoffLength() / 1000));\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", (peerNodeStatus.getLastBackoffReason() == null) ? \"\" : ('/' + (peerNodeStatus.getLastBackoffReason())));\n\n\t\t\t\t\t\t// overload probability column\n\t\t\t\t\t\tHTMLNode pRejectCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\"); // FIXME\n\t\t\t\t\t\tpRejectCell.addChild(\"#\", fix1.format(peerNodeStatus.getPReject()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// idle column\n\t\t\t\t\tlong idle = peerNodeStatus.getTimeLastRoutable();\n\t\t\t\t\tif (peerNodeStatus.isRoutable()) {\n\t\t\t\t\t\tidle = peerNodeStatus.getTimeLastConnectionCompleted();\n\t\t\t\t\t} else if (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_NEVER_CONNECTED) {\n\t\t\t\t\t\tidle = peerNodeStatus.getPeerAddedTime();\n\t\t\t\t\t}\n\t\t\t\t\tif(!peerNodeStatus.isConnected() && (now - idle) > (2 * 7 * 24 * 60 * 60 * (long) 1000)) { // 2 weeks\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\").addChild(\"span\", \"class\", \"peer_idle_old\", idleToString(now, idle));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\", idleToString(now, idle));\n\t\t\t\t\t}\n\n\t\t\t\t\t// private darknet node comment note column\n\t\t\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"onBlur\", \"onChange\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", \"peerNoteBlur();\", \"peerNoteChange();\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t}\n\n\t\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\t\t// percent of time connected column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", fix1.format(peerNodeStatus.getPercentTimeRoutableConnection()));\n\t\t\t\t\t\t// total traffic column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", SizeUtil.formatSize(peerNodeStatus.getTotalInputBytes())+\" / \"+SizeUtil.formatSize(peerNodeStatus.getTotalOutputBytes()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\t\tHTMLNode messageCountRow = peerTable.addChild(\"tr\", \"class\", \"message-status\");\n\t\t\t\t\t\tmessageCountRow.addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\t\t\tHTMLNode messageCountCell = messageCountRow.addChild(\"td\", \"colspan\", String.valueOf(advancedEnabled ? 9 : 5));  // = total table row width - 2 from above colspan\n\t\t\t\t\t\tHTMLNode messageCountTable = messageCountCell.addChild(\"table\", \"class\", \"message-count\");\n\t\t\t\t\t\tHTMLNode countHeaderRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Message\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Incoming\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Outgoing\");\n\t\t\t\t\t\tList messageNames = new ArrayList();\n\t\t\t\t\t\tMap messageCounts = new HashMap();\n\t\t\t\t\t\tfor (Iterator incomingMessages = peerNodeStatus.getLocalMessagesReceived().keySet().iterator(); incomingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) incomingMessages.next();\n\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesReceived().get(messageName);\n\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { messageCount, new Long(0) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Iterator outgoingMessages = peerNodeStatus.getLocalMessagesSent().keySet().iterator(); outgoingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) outgoingMessages.next();\n\t\t\t\t\t\t\tif (!messageNames.contains(messageName)) {\n\t\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesSent().get(messageName);\n\t\t\t\t\t\t\tLong[] existingCounts = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tif (existingCounts == null) {\n\t\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { new Long(0), messageCount });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texistingCounts[1] = messageCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(messageNames, new Comparator() {\n\t\t\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\t\t\treturn ((String) first).compareToIgnoreCase((String) second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (Iterator messageNamesIterator = messageNames.iterator(); messageNamesIterator.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) messageNamesIterator.next();\n\t\t\t\t\t\t\tLong[] messageCount = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tHTMLNode messageRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", messageName);\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[0]));\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tHTMLNode actionSelect = peerForm.addChild(\"select\", new String[] { \"id\", \"name\" }, new String[] { \"action\", \"action\" });\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- Select action --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"send_n2ntm\", \"Send N2NTM to selected peers\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"update_notes\", \"Update changed private notes\");\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"enable\", \"Enable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"disable\", \"Disable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_burst_only\", \"On selected peers, set BurstOnly (only set this if you have a static IP and are not NATed and neither is the peer)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_burst_only\", \"On selected peers, clear BurstOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_listen_only\", \"On selected peers, set ListenOnly (not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_listen_only\", \"On selected peers, clear ListenOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_allow_local\", \"On selected peers, set allowLocalAddresses (useful if you are connecting to another node on the same LAN)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_allow_local\", \"On selected peers, clear allowLocalAddresses\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_ignore_source_port\", \"On selected peers, set ignoreSourcePort (try this if behind an evil corporate firewall; otherwise not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_ignore_source_port\", \"On selected peers, clear ignoreSourcePort\");\n\t\t\t\t}\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- -- --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"remove\", \"Remove selected peers\");\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"doAction\", \"Go\" });\n\t\t\t}\n\t\t\t// END PEER TABLE\n\n\t\t}\n\t\t\n\t\t// BEGIN PEER ADDITION BOX\n\t\tHTMLNode peerAdditionInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tpeerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Add another peer\");\n\t\tHTMLNode peerAdditionContent = peerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode peerAdditionForm = peerAdditionContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\" }, new String[] { \".\", \"post\", \"multipart/form-data\" });\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\tpeerAdditionForm.addChild(\"#\", \"Paste the reference here:\");\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"textarea\", new String[] { \"id\", \"name\", \"rows\", \"cols\" }, new String[] { \"reftext\", \"ref\", \"8\", \"74\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter the URL of the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"refurl\", \"text\", \"url\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Choose the file containing the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"reffile\", \"file\", \"reffile\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter a node description: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"peerPrivateNote\", \"text\", \"peerPrivateNote\", \"16\", \"250\", \"\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"add\", \"Add\" });\n\t\t\n\t\t// our reference\n\t\tHTMLNode referenceInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-header\").addChild(\"a\", \"href\", \"myref.fref\", \"My reference\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-content\").addChild(\"pre\", \"id\", \"reference\", node.exportPublicFieldSet().toString());\n\t\t\n\t\t// our ports\n\t\tHTMLNode portInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tportInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node's Ports\");\n\t\tHTMLNode portInfoboxContent = portInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode portInfoList = portInfoboxContent.addChild(\"ul\");\n\t\tSimpleFieldSet fproxyConfig = node.config.get(\"fproxy\").exportFieldSet(true);\n\t\tSimpleFieldSet fcpConfig = node.config.get(\"fcp\").exportFieldSet(true);\n\t\tSimpleFieldSet tmciConfig = node.config.get(\"console\").exportFieldSet(true);\n\t\tportInfoList.addChild(\"li\", \"FNP:\\u00a0\" + node.getFNPPort() + \"/udp\\u00a0\\u00a0\\u00a0(between nodes; this is usually the only port that you might want to port forward)\");\n\t\ttry {\n\t\t\tif(fproxyConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0\" + fproxyConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t}\n\t\t\tif(fcpConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0\" + fcpConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t}\n\t\t\tif(tmciConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0\" + tmciConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\tStringBuffer pageBuffer = new StringBuffer();\n\t\tpageNode.generate(pageBuffer);\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageBuffer.toString());\n\t}","commit_id":"b0d8a0763474a0e66850bdecaa333d4ab5fd0503","url":"https://github.com/freenet/fred"},{"original_method":"public static String formatSize(long sz) {\n\t\tlong s = 1;\n\t\tint i;\n\t\tfor(i=0;i<SizeUtil.suffixes.length;i++) {\n\t\t\ts *= 1024;\n\t\t\tif(s > sz) {\n\t\t\t\tbreak;\n\t\t\t\t// Smaller than multiplier [i] - use the previous one\n\t\t\t}\n\t\t}\n\t\t\n\t\ts /= 1024; // we use the previous unit\n\t\tif (s == 1)  // Bytes? Then we don't need real numbers with a comma\n\t\t{\n\t\t\treturn sz + \" \" + SizeUtil.suffixes[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble mantissa = (double)sz / (double)s;\n\t\t\tString o = Double.toString(mantissa);\n\t\t\tif(o.indexOf('.') == 3)\n\t\t\t\to = o.substring(0, 3);\n\t\t\telse if((o.indexOf('.') > -1) && (o.indexOf('E') == -1) && (o.length() > 4))\n\t\t\t\to = o.substring(0, 4);\n\t\t\tif(i < SizeUtil.suffixes.length) // handle the case where the mantissa is Infinity\n\t\t\t\to += ' ' + SizeUtil.suffixes[i];\n\t\t\treturn o;\n\t\t}\n\t}","id":713,"modified_method":"public static String formatSize(long sz) {\n\t\treturn formatSize(sz, false);\n\t}","commit_id":"b0d8a0763474a0e66850bdecaa333d4ab5fd0503","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Statistics for \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\n\t\t// Generate a Thread-Dump\n\t\tif(node.isUsingWrapper()){\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"Request a Thread Dump to be generated\"));\n\t\t\tHTMLNode threadDumpForm = ctx.getPageMaker().getContentNode(infobox).addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] { \"/\", \"POST\" });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"getThreadDump\", \"Generate a Thread Dump\" });\n\t\t}\n\t\t\n\t\tdouble swaps = (double)node.getSwaps();\n\t\tdouble noSwaps = (double)node.getNoSwaps();\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimate24h = 0;\n\t\t\tint networkSizeEstimate48h = 0;\n\t\t\tdouble numberOfRemotePeerLocationsSeenInSwaps = (double)node.getNumberOfRemotePeerLocationsSeenInSwaps();\n\t\t\t\n\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\tnetworkSizeEstimate24h = node.getNetworkSizeEstimate(now - (24*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimate48h = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix1p4 = new DecimalFormat(\"0.0000\");\n\t\t\tDecimalFormat fix6p6 = new DecimalFormat(\"#####0.0#####\");\n\t\t\tDecimalFormat fix1p6sci = new DecimalFormat(\"0.######E0\");\n\t\t\tDecimalFormat fix3p1pct = new DecimalFormat(\"##0.0%\");\n            NumberFormat thousendPoint = NumberFormat.getInstance();\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate24h:\\u00a0\" + networkSizeEstimate24h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate48h:\\u00a0\" + networkSizeEstimate48h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif ((numberOfRemotePeerLocationsSeenInSwaps > 0.0) && ((swaps > 0.0) || (noSwaps > 0.0))) {\n\t\t\t\t\toverviewList.addChild(\"li\", \"avrConnPeersPerNode:\\u00a0\" + fix6p6.format(numberOfRemotePeerLocationsSeenInSwaps/(swaps+noSwaps)) + \"\\u00a0peers\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix1p4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix3p1pct.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix3p1pct.format(node.pRejectIncomingInstantly()));\n\t\t\t\toverviewList.addChild(\"li\", \"unclaimedFIFOSize:\\u00a0\" + node.getUnclaimedFIFOSize());\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Swap statistics box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tint startedSwaps = node.getStartedSwaps();\n\t\t\t\tint swapsRejectedAlreadyLocked = node.getSwapsRejectedAlreadyLocked();\n\t\t\t\tint swapsRejectedNowhereToGo = node.getSwapsRejectedNowhereToGo();\n\t\t\t\tint swapsRejectedRateLimit = node.getSwapsRejectedRateLimit();\n\t\t\t\tint swapsRejectedLoop = node.getSwapsRejectedLoop();\n\t\t\t\tint swapsRejectedRecognizedID = node.getSwapsRejectedRecognizedID();\n\t\t\t\tdouble locChangeSession = node.getLocationChangeSession();\n\t\t\t\t\n\t\t\t\tHTMLNode locationSwapInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tlocationSwapInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Location swaps\");\n\t\t\t\tHTMLNode locationSwapInfoboxContent = locationSwapInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode locationSwapList = locationSwapInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangeSession:\\u00a0\" + fix1p6sci.format(locChangeSession));\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerSwap:\\u00a0\" + fix1p6sci.format(locChangeSession/swaps));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerMinute:\\u00a0\" + fix1p6sci.format(locChangeSession/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerMinute:\\u00a0\" + fix1p6sci.format(swaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((noSwaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwapsPerMinute:\\u00a0\" + fix1p6sci.format(noSwaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (noSwaps > 0.0)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerNoSwaps:\\u00a0\" + fix1p6sci.format(swaps/noSwaps));\n\t\t\t\t}\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swaps:\\u00a0\" + (int)swaps);\n\t\t\t\t}\n\t\t\t\tif (noSwaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwaps:\\u00a0\" + (int)noSwaps);\n\t\t\t\t}\n\t\t\t\tif (startedSwaps > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"startedSwaps:\\u00a0\" + startedSwaps);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedAlreadyLocked > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedAlreadyLocked:\\u00a0\" + swapsRejectedAlreadyLocked);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedNowhereToGo > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedNowhereToGo:\\u00a0\" + swapsRejectedNowhereToGo);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRateLimit > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRateLimit:\\u00a0\" + swapsRejectedRateLimit);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedLoop > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedLoop:\\u00a0\" + swapsRejectedLoop);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRecognizedID > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRecognizedID:\\u00a0\" + swapsRejectedRecognizedID);\n\t\t\t\t}\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\t\t\t\n\t\t\t// Bandwidth box\n\t\t\tif (advancedEnabled) {\n\t\t\t\tHTMLNode bandwidthInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Bandwidth\");\n\t\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode bandwidthList = bandwidthInfoboxContent.addChild(\"ul\");\n\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0]) + \"\\u00a0(\" + SizeUtil.formatSize(total_output_rate) + \"ps)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload) + \"\\u00a0(\" + SizeUtil.formatSize(total_payload_rate) + \"ps) (\"+percent+\"%)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1]) + \"\\u00a0(\" + SizeUtil.formatSize(total_input_rate) + \"ps)\");\n\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\tbandwidthList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate) + \"ps\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate) + \"ps\");\n                nextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // store size box\n            if (advancedEnabled) {\n                HTMLNode storeSizeInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Store size\");\n                HTMLNode storeSizeInfoboxContent = storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode storeSizeList = storeSizeInfoboxContent.addChild(\"ul\");\n                \n                final long fix32kb = 32 * 1024;\n                \n                long cachedKeys = node.getChkDatacache().keyCount();\n                long cachedSize = cachedKeys * fix32kb;\n                long storeKeys = node.getChkDatastore().keyCount();\n                long storeSize = storeKeys * fix32kb;\n                long overallKeys = cachedKeys + storeKeys;\n                long overallSize = cachedSize + storeSize;\n                \n//                long maxCachedKeys = node.getChkDatacache().getMaxKeys();\n//                long maxStoreKeys = node.getChkDatastore().getMaxKeys();\n                long maxOverallKeys = node.getMaxTotalKeys();\n                long maxOverallSize = maxOverallKeys * fix32kb;\n                \n                long cachedStoreHits = node.getChkDatacache().hits();\n                long cachedStoreMisses = node.getChkDatacache().misses();\n                long cacheAccesses = cachedStoreHits + cachedStoreMisses;\n                long storeHits = node.getChkDatastore().hits();\n                long storeMisses = node.getChkDatastore().misses();\n                long storeAccesses = storeHits + storeMisses;\n                long overallAccesses = storeAccesses + cacheAccesses;\n                \n                storeSizeList.addChild(\"li\", \n                        \"Cached keys:\\u00a0\" + thousendPoint.format(cachedKeys) + \n                        \"\\u00a0(\" + SizeUtil.formatSize(cachedSize) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Stored keys:\\u00a0\" + thousendPoint.format(storeKeys) + \n                        \"\\u00a0(\" + SizeUtil.formatSize(storeSize) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Overall size:\\u00a0\" + thousendPoint.format(overallKeys) + \n                        \"\\u00a0/\\u00a0\" + thousendPoint.format(maxOverallKeys) +\n                        \"\\u00a0(\" + SizeUtil.formatSize(overallSize) + \n                        \"\\u00a0/\\u00a0\" + SizeUtil.formatSize(maxOverallSize) + \n                        \")\\u00a0(\" + ((overallKeys*100)/maxOverallKeys) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Cache hits:\\u00a0\" + thousendPoint.format(cachedStoreHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(cacheAccesses) +\n                        \"\\u00a0(\" + ((cachedStoreHits*100) / (cacheAccesses)) + \"%)\");\n                \n                storeSizeList.addChild(\"li\", \n                        \"Store hits:\\u00a0\" + thousendPoint.format(storeHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(storeAccesses) +\n                        \"\\u00a0(\" + ((storeHits*100) / (storeAccesses)) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Avg. access rate:\\u00a0\" + thousendPoint.format(overallAccesses/nodeUptimeSeconds) + \"/s\");\n            }\n            \n            nextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n            // jvm stats box\n            if (advancedEnabled) {\n                HTMLNode jvmStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"JVM info\");\n                HTMLNode jvmStatsInfoboxContent = jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode jvmStatsList = jvmStatsInfoboxContent.addChild(\"ul\");\n\n                Runtime rt = Runtime.getRuntime();\n                float freeMemory = (float) rt.freeMemory();\n                float totalMemory = (float) rt.totalMemory();\n                float maxMemory = (float) rt.maxMemory();\n\n                long usedJavaMem = (long)(totalMemory - freeMemory);\n                long allocatedJavaMem = (long)totalMemory;\n                long maxJavaMem = (long)maxMemory;\n                int threadCount = Thread.activeCount();\n                int availableCpus = rt.availableProcessors();\n\n                jvmStatsList.addChild(\"li\", \"Used Java memory:\\u00a0\" + SizeUtil.formatSize(usedJavaMem));\n                jvmStatsList.addChild(\"li\", \"Allocated Java memory:\\u00a0\" + SizeUtil.formatSize(allocatedJavaMem));\n                jvmStatsList.addChild(\"li\", \"Maximum Java memory:\\u00a0\" + SizeUtil.formatSize(maxJavaMem));\n                jvmStatsList.addChild(\"li\", \"Available CPUs:\\u00a0\" + availableCpus);\n                jvmStatsList.addChild(\"li\", \"Running threads:\\u00a0\" + thousendPoint.format(threadCount));\n            }\n\t\t\t\n\t\t\t// unclaimedFIFOMessageCounts box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tMap unclaimedFIFOMessageCountsMap = node.getUSM().getUnclaimedFIFOMessageCounts();\n\t\t\t\tSTMessageCount[] unclaimedFIFOMessageCountsArray = new STMessageCount[unclaimedFIFOMessageCountsMap.size()];\n\t\t\t\tint i = 0;\n\t\t\t\tint totalCount = 0;\n\t\t\t\tfor (Iterator messageCounts = unclaimedFIFOMessageCountsMap.keySet().iterator(); messageCounts.hasNext(); ) {\n\t\t\t\t\tString messageName = (String) messageCounts.next();\n\t\t\t\t\tint messageCount = ((Integer) unclaimedFIFOMessageCountsMap.get(messageName)).intValue();\n\t\t\t\t\ttotalCount = totalCount + messageCount;\n\t\t\t\t\tunclaimedFIFOMessageCountsArray[i++] = new STMessageCount( messageName, messageCount );\n\t\t\t\t}\n\t\t\t\tArrays.sort(unclaimedFIFOMessageCountsArray, new Comparator() {\n\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\tSTMessageCount firstCount = (STMessageCount) first;\n\t\t\t\t\t\tSTMessageCount secondCount = (STMessageCount) second;\n\t\t\t\t\t\treturn secondCount.messageCount - firstCount.messageCount;  // sort in descending order\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tunclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"unclaimedFIFO Message Counts\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfoboxContent = unclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsList = unclaimedFIFOMessageCountsInfoboxContent.addChild(\"ul\");\n\t\t\t\tfor (int countsArrayIndex = 0, countsArrayCount = unclaimedFIFOMessageCountsArray.length; countsArrayIndex < countsArrayCount; countsArrayIndex++) {\n\t\t\t\t\tSTMessageCount messageCountItem = (STMessageCount) unclaimedFIFOMessageCountsArray[countsArrayIndex];\n\t\t\t\t\tint thisMessageCount = messageCountItem.messageCount;\n\t\t\t\t\tdouble thisMessagePercentOfTotal = ((double) thisMessageCount) / ((double) totalCount);\n\t\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"\" + messageCountItem.messageName + \":\\u00a0\" + thisMessageCount + \"\\u00a0(\" + fix3p1pct.format(thisMessagePercentOfTotal) + ')');\n\t\t\t\t}\n\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"Unclaimed Messages Considered:\\u00a0\" + totalCount);\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // node version information box\n            if (advancedEnabled) {\n                HTMLNode versionInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                versionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node Version Information\");\n                HTMLNode versionInfoboxContent = versionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet \" + Version.nodeVersion + \" Build #\" + Version.buildNumber() + \" r\" + Version.cvsRevision);\n\t\t\t\tversionInfoboxContent.addChild(\"br\");\n\t\t\t\tif(NodeStarter.extBuildNumber < NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER) {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + '(' + NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER + \") r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t} else {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + \" r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t}\n            }\n\t\t}\n\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t}","id":714,"modified_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Statistics for \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\n\t\t// Generate a Thread-Dump\n\t\tif(node.isUsingWrapper()){\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"Request a Thread Dump to be generated\"));\n\t\t\tHTMLNode threadDumpForm = ctx.getPageMaker().getContentNode(infobox).addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] { \"/\", \"POST\" });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"getThreadDump\", \"Generate a Thread Dump\" });\n\t\t}\n\t\t\n\t\tdouble swaps = (double)node.getSwaps();\n\t\tdouble noSwaps = (double)node.getNoSwaps();\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimate24h = 0;\n\t\t\tint networkSizeEstimate48h = 0;\n\t\t\tdouble numberOfRemotePeerLocationsSeenInSwaps = (double)node.getNumberOfRemotePeerLocationsSeenInSwaps();\n\t\t\t\n\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\tnetworkSizeEstimate24h = node.getNetworkSizeEstimate(now - (24*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimate48h = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix1p4 = new DecimalFormat(\"0.0000\");\n\t\t\tDecimalFormat fix6p6 = new DecimalFormat(\"#####0.0#####\");\n\t\t\tDecimalFormat fix1p6sci = new DecimalFormat(\"0.######E0\");\n\t\t\tDecimalFormat fix3p1pct = new DecimalFormat(\"##0.0%\");\n            NumberFormat thousendPoint = NumberFormat.getInstance();\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate24h:\\u00a0\" + networkSizeEstimate24h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate48h:\\u00a0\" + networkSizeEstimate48h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif ((numberOfRemotePeerLocationsSeenInSwaps > 0.0) && ((swaps > 0.0) || (noSwaps > 0.0))) {\n\t\t\t\t\toverviewList.addChild(\"li\", \"avrConnPeersPerNode:\\u00a0\" + fix6p6.format(numberOfRemotePeerLocationsSeenInSwaps/(swaps+noSwaps)) + \"\\u00a0peers\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix1p4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix3p1pct.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix3p1pct.format(node.pRejectIncomingInstantly()));\n\t\t\t\toverviewList.addChild(\"li\", \"unclaimedFIFOSize:\\u00a0\" + node.getUnclaimedFIFOSize());\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Swap statistics box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tint startedSwaps = node.getStartedSwaps();\n\t\t\t\tint swapsRejectedAlreadyLocked = node.getSwapsRejectedAlreadyLocked();\n\t\t\t\tint swapsRejectedNowhereToGo = node.getSwapsRejectedNowhereToGo();\n\t\t\t\tint swapsRejectedRateLimit = node.getSwapsRejectedRateLimit();\n\t\t\t\tint swapsRejectedLoop = node.getSwapsRejectedLoop();\n\t\t\t\tint swapsRejectedRecognizedID = node.getSwapsRejectedRecognizedID();\n\t\t\t\tdouble locChangeSession = node.getLocationChangeSession();\n\t\t\t\t\n\t\t\t\tHTMLNode locationSwapInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tlocationSwapInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Location swaps\");\n\t\t\t\tHTMLNode locationSwapInfoboxContent = locationSwapInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode locationSwapList = locationSwapInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangeSession:\\u00a0\" + fix1p6sci.format(locChangeSession));\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerSwap:\\u00a0\" + fix1p6sci.format(locChangeSession/swaps));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerMinute:\\u00a0\" + fix1p6sci.format(locChangeSession/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerMinute:\\u00a0\" + fix1p6sci.format(swaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((noSwaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwapsPerMinute:\\u00a0\" + fix1p6sci.format(noSwaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (noSwaps > 0.0)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerNoSwaps:\\u00a0\" + fix1p6sci.format(swaps/noSwaps));\n\t\t\t\t}\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swaps:\\u00a0\" + (int)swaps);\n\t\t\t\t}\n\t\t\t\tif (noSwaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwaps:\\u00a0\" + (int)noSwaps);\n\t\t\t\t}\n\t\t\t\tif (startedSwaps > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"startedSwaps:\\u00a0\" + startedSwaps);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedAlreadyLocked > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedAlreadyLocked:\\u00a0\" + swapsRejectedAlreadyLocked);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedNowhereToGo > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedNowhereToGo:\\u00a0\" + swapsRejectedNowhereToGo);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRateLimit > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRateLimit:\\u00a0\" + swapsRejectedRateLimit);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedLoop > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedLoop:\\u00a0\" + swapsRejectedLoop);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRecognizedID > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRecognizedID:\\u00a0\" + swapsRejectedRecognizedID);\n\t\t\t\t}\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\t\t\t\n\t\t\t// Bandwidth box\n\t\t\tif (advancedEnabled) {\n\t\t\t\tHTMLNode bandwidthInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Bandwidth\");\n\t\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode bandwidthList = bandwidthInfoboxContent.addChild(\"ul\");\n\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0]) + \" (\" + SizeUtil.formatSize(total_output_rate, true) + \"ps)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload) + \" (\" + SizeUtil.formatSize(total_payload_rate, true) + \"ps) (\"+percent+\"%)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1]) + \" (\" + SizeUtil.formatSize(total_input_rate, true) + \"ps)\");\n\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\tSubConfig nodeConfig = node.config.get(\"node\");\n\t\t\t\tint outputBandwidthLimit = nodeConfig.getInt(\"outputBandwidthLimit\");\n\t\t\t\tint inputBandwidthLimit = nodeConfig.getInt(\"inputBandwidthLimit\");\n\t\t\t\tif(inputBandwidthLimit == -1) {\n\t\t\t\t\tinputBandwidthLimit = outputBandwidthLimit * 4;\n\t\t\t\t}\n\t\t\t\tbandwidthList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(outputBandwidthLimit, true)+\"ps)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(inputBandwidthLimit, true)+\"ps)\");\n                nextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // store size box\n            if (advancedEnabled) {\n                HTMLNode storeSizeInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Store size\");\n                HTMLNode storeSizeInfoboxContent = storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode storeSizeList = storeSizeInfoboxContent.addChild(\"ul\");\n                \n                final long fix32kb = 32 * 1024;\n                \n                long cachedKeys = node.getChkDatacache().keyCount();\n                long cachedSize = cachedKeys * fix32kb;\n                long storeKeys = node.getChkDatastore().keyCount();\n                long storeSize = storeKeys * fix32kb;\n                long overallKeys = cachedKeys + storeKeys;\n                long overallSize = cachedSize + storeSize;\n                \n//                long maxCachedKeys = node.getChkDatacache().getMaxKeys();\n//                long maxStoreKeys = node.getChkDatastore().getMaxKeys();\n                long maxOverallKeys = node.getMaxTotalKeys();\n                long maxOverallSize = maxOverallKeys * fix32kb;\n                \n                long cachedStoreHits = node.getChkDatacache().hits();\n                long cachedStoreMisses = node.getChkDatacache().misses();\n                long cacheAccesses = cachedStoreHits + cachedStoreMisses;\n                long storeHits = node.getChkDatastore().hits();\n                long storeMisses = node.getChkDatastore().misses();\n                long storeAccesses = storeHits + storeMisses;\n                long overallAccesses = storeAccesses + cacheAccesses;\n                \n                storeSizeList.addChild(\"li\", \n                        \"Cached keys:\\u00a0\" + thousendPoint.format(cachedKeys) + \n                        \" (\" + SizeUtil.formatSize(cachedSize, true) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Stored keys:\\u00a0\" + thousendPoint.format(storeKeys) + \n                        \" (\" + SizeUtil.formatSize(storeSize, true) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Overall size:\\u00a0\" + thousendPoint.format(overallKeys) + \n                        \"\\u00a0/\\u00a0\" + thousendPoint.format(maxOverallKeys) +\n                        \" (\" + SizeUtil.formatSize(overallSize, true) + \n                        \"\\u00a0/\\u00a0\" + SizeUtil.formatSize(maxOverallSize, true) + \n                        \")\\u00a0(\" + ((overallKeys*100)/maxOverallKeys) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Cache hits:\\u00a0\" + thousendPoint.format(cachedStoreHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(cacheAccesses) +\n                        \"\\u00a0(\" + ((cachedStoreHits*100) / (cacheAccesses)) + \"%)\");\n                \n                storeSizeList.addChild(\"li\", \n                        \"Store hits:\\u00a0\" + thousendPoint.format(storeHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(storeAccesses) +\n                        \"\\u00a0(\" + ((storeHits*100) / (storeAccesses)) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Avg. access rate:\\u00a0\" + thousendPoint.format(overallAccesses/nodeUptimeSeconds) + \"/s\");\n            }\n            \n            nextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n            // jvm stats box\n            if (advancedEnabled) {\n                HTMLNode jvmStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"JVM info\");\n                HTMLNode jvmStatsInfoboxContent = jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode jvmStatsList = jvmStatsInfoboxContent.addChild(\"ul\");\n\n                Runtime rt = Runtime.getRuntime();\n                float freeMemory = (float) rt.freeMemory();\n                float totalMemory = (float) rt.totalMemory();\n                float maxMemory = (float) rt.maxMemory();\n\n                long usedJavaMem = (long)(totalMemory - freeMemory);\n                long allocatedJavaMem = (long)totalMemory;\n                long maxJavaMem = (long)maxMemory;\n                int threadCount = Thread.activeCount();\n                int availableCpus = rt.availableProcessors();\n\n                jvmStatsList.addChild(\"li\", \"Used Java memory:\\u00a0\" + SizeUtil.formatSize(usedJavaMem, true));\n                jvmStatsList.addChild(\"li\", \"Allocated Java memory:\\u00a0\" + SizeUtil.formatSize(allocatedJavaMem, true));\n                jvmStatsList.addChild(\"li\", \"Maximum Java memory:\\u00a0\" + SizeUtil.formatSize(maxJavaMem, true));\n                jvmStatsList.addChild(\"li\", \"Available CPUs:\\u00a0\" + availableCpus);\n                jvmStatsList.addChild(\"li\", \"Running threads:\\u00a0\" + thousendPoint.format(threadCount));\n            }\n\t\t\t\n\t\t\t// unclaimedFIFOMessageCounts box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tMap unclaimedFIFOMessageCountsMap = node.getUSM().getUnclaimedFIFOMessageCounts();\n\t\t\t\tSTMessageCount[] unclaimedFIFOMessageCountsArray = new STMessageCount[unclaimedFIFOMessageCountsMap.size()];\n\t\t\t\tint i = 0;\n\t\t\t\tint totalCount = 0;\n\t\t\t\tfor (Iterator messageCounts = unclaimedFIFOMessageCountsMap.keySet().iterator(); messageCounts.hasNext(); ) {\n\t\t\t\t\tString messageName = (String) messageCounts.next();\n\t\t\t\t\tint messageCount = ((Integer) unclaimedFIFOMessageCountsMap.get(messageName)).intValue();\n\t\t\t\t\ttotalCount = totalCount + messageCount;\n\t\t\t\t\tunclaimedFIFOMessageCountsArray[i++] = new STMessageCount( messageName, messageCount );\n\t\t\t\t}\n\t\t\t\tArrays.sort(unclaimedFIFOMessageCountsArray, new Comparator() {\n\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\tSTMessageCount firstCount = (STMessageCount) first;\n\t\t\t\t\t\tSTMessageCount secondCount = (STMessageCount) second;\n\t\t\t\t\t\treturn secondCount.messageCount - firstCount.messageCount;  // sort in descending order\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tunclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"unclaimedFIFO Message Counts\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfoboxContent = unclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsList = unclaimedFIFOMessageCountsInfoboxContent.addChild(\"ul\");\n\t\t\t\tfor (int countsArrayIndex = 0, countsArrayCount = unclaimedFIFOMessageCountsArray.length; countsArrayIndex < countsArrayCount; countsArrayIndex++) {\n\t\t\t\t\tSTMessageCount messageCountItem = (STMessageCount) unclaimedFIFOMessageCountsArray[countsArrayIndex];\n\t\t\t\t\tint thisMessageCount = messageCountItem.messageCount;\n\t\t\t\t\tdouble thisMessagePercentOfTotal = ((double) thisMessageCount) / ((double) totalCount);\n\t\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"\" + messageCountItem.messageName + \":\\u00a0\" + thisMessageCount + \"\\u00a0(\" + fix3p1pct.format(thisMessagePercentOfTotal) + ')');\n\t\t\t\t}\n\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"Unclaimed Messages Considered:\\u00a0\" + totalCount);\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // node version information box\n            if (advancedEnabled) {\n                HTMLNode versionInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                versionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node Version Information\");\n                HTMLNode versionInfoboxContent = versionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet \" + Version.nodeVersion + \" Build #\" + Version.buildNumber() + \" r\" + Version.cvsRevision);\n\t\t\t\tversionInfoboxContent.addChild(\"br\");\n\t\t\t\tif(NodeStarter.extBuildNumber < NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER) {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + '(' + NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER + \") r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t} else {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + \" r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t}\n            }\n\t\t}\n\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t}","commit_id":"b0d8a0763474a0e66850bdecaa333d4ab5fd0503","url":"https://github.com/freenet/fred"},{"original_method":"public boolean isMmap() {\n        return mmap;\n    }","id":715,"modified_method":"public boolean isDisableMmap() {\n        return disableMmap;\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MigrationOptions(MigrationCliArguments args) {\n        this.copyBinariesByReference = !args.hasOption(OptionParserFactory.COPY_BINARIES);\n        this.mmap = args.hasOption(OptionParserFactory.MMAP);\n        if (args.hasOption(OptionParserFactory.CACHE_SIZE)) {\n            this.cacheSizeInMB = args.getIntOption(OptionParserFactory.CACHE_SIZE);\n        } else {\n            this.cacheSizeInMB = 256;\n        }\n\n        final Calendar epoch = Calendar.getInstance();\n        epoch.setTimeInMillis(0);\n        if (args.hasOption(OptionParserFactory.COPY_VERSIONS)) {\n            this.copyVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_VERSIONS));\n        } else {\n            this.copyVersions = epoch;\n        }\n        if (args.hasOption(OptionParserFactory.COPY_ORPHANED_VERSIONS)) {\n            this.copyOrphanedVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_ORPHANED_VERSIONS));\n        } else {\n            this.copyOrphanedVersions = epoch;\n        }\n        this.includePaths = split(args.getOption(OptionParserFactory.INCLUDE_PATHS));\n        this.excludePaths = split(args.getOption(OptionParserFactory.EXCLUDE_PATHS));\n        this.mergePaths = split(args.getOption(OptionParserFactory.MERGE_PATHS));\n        this.includeIndex = args.hasOption(OptionParserFactory.INCLUDE_INDEX);\n        this.failOnError = args.hasOption(OptionParserFactory.FAIL_ON_ERROR);\n        this.earlyShutdown = args.hasOption(OptionParserFactory.EARLY_SHUTDOWN);\n        this.skipInitialization = args.hasOption(OptionParserFactory.SKIP_INIT);\n        this.skipNameCheck = args.hasOption(OptionParserFactory.SKIP_NAME_CHECK);\n        this.ignoreMissingBinaries = args.hasOption(OptionParserFactory.IGNORE_MISSING_BINARIES);\n        logOptions();\n    }","id":716,"modified_method":"public MigrationOptions(MigrationCliArguments args) {\n        this.copyBinariesByReference = !args.hasOption(OptionParserFactory.COPY_BINARIES);\n        this.disableMmap = args.hasOption(OptionParserFactory.DISABLE_MMAP);\n        if (args.hasOption(OptionParserFactory.CACHE_SIZE)) {\n            this.cacheSizeInMB = args.getIntOption(OptionParserFactory.CACHE_SIZE);\n        } else {\n            this.cacheSizeInMB = 256;\n        }\n\n        final Calendar epoch = Calendar.getInstance();\n        epoch.setTimeInMillis(0);\n        if (args.hasOption(OptionParserFactory.COPY_VERSIONS)) {\n            this.copyVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_VERSIONS));\n        } else {\n            this.copyVersions = epoch;\n        }\n        if (args.hasOption(OptionParserFactory.COPY_ORPHANED_VERSIONS)) {\n            this.copyOrphanedVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_ORPHANED_VERSIONS));\n        } else {\n            this.copyOrphanedVersions = epoch;\n        }\n        this.includePaths = split(args.getOption(OptionParserFactory.INCLUDE_PATHS));\n        this.excludePaths = split(args.getOption(OptionParserFactory.EXCLUDE_PATHS));\n        this.mergePaths = split(args.getOption(OptionParserFactory.MERGE_PATHS));\n        this.includeIndex = args.hasOption(OptionParserFactory.INCLUDE_INDEX);\n        this.failOnError = args.hasOption(OptionParserFactory.FAIL_ON_ERROR);\n        this.earlyShutdown = args.hasOption(OptionParserFactory.EARLY_SHUTDOWN);\n        this.skipInitialization = args.hasOption(OptionParserFactory.SKIP_INIT);\n        this.skipNameCheck = args.hasOption(OptionParserFactory.SKIP_NAME_CHECK);\n        this.ignoreMissingBinaries = args.hasOption(OptionParserFactory.IGNORE_MISSING_BINARIES);\n        logOptions();\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void logOptions() {\n        if (copyBinariesByReference) {\n            log.info(\"DataStore needs to be shared with new repository\");\n        } else {\n            log.info(\"Binary content would be copied to the NodeStore.\");\n        }\n\n        if (mmap) {\n            log.info(\"Enabling memory mapped file access for Segment Store\");\n        }\n\n        if (copyVersions == null) {\n            log.info(\"copyVersions parameter set to false\");\n        } else {\n            log.info(\"copyVersions parameter set to {}\", DATE_FORMAT.format(copyVersions.getTime()));\n        }\n\n        if (copyOrphanedVersions == null) {\n            log.info(\"copyOrphanedVersions parameter set to false\");\n        } else {\n            log.info(\"copyOrphanedVersions parameter set to {}\", DATE_FORMAT.format(copyOrphanedVersions.getTime()));\n        }\n\n        if (includePaths != null) {\n            log.info(\"paths to include: {}\", (Object) includePaths);\n        }\n\n        if (excludePaths != null) {\n            log.info(\"paths to exclude: {}\", (Object) excludePaths);\n        }\n\n        if (failOnError) {\n            log.info(\"Unreadable nodes will cause failure of the entire transaction\");\n        }\n\n        if (earlyShutdown) {\n            log.info(\"Source repository would be shutdown post copying of nodes\");\n        }\n\n        if (skipInitialization) {\n            log.info(\"The repository initialization will be skipped\");\n        }\n\n        if (skipNameCheck) {\n            log.info(\"Test for long-named nodes will be disabled\");\n        }\n\n        if (includeIndex) {\n            log.info(\"Index data for the paths {} will be copied\", (Object) includePaths);\n        }\n\n        if (ignoreMissingBinaries) {\n            log.info(\"Missing binaries won't break the migration\");\n        }\n\n        log.info(\"Cache size: {} MB\", cacheSizeInMB);\n\n    }","id":717,"modified_method":"private void logOptions() {\n        if (copyBinariesByReference) {\n            log.info(\"DataStore needs to be shared with new repository\");\n        } else {\n            log.info(\"Binary content would be copied to the NodeStore.\");\n        }\n\n        if (disableMmap) {\n            log.info(\"Disabling memory mapped file access for Segment Store\");\n        }\n\n        if (copyVersions == null) {\n            log.info(\"copyVersions parameter set to false\");\n        } else {\n            log.info(\"copyVersions parameter set to {}\", DATE_FORMAT.format(copyVersions.getTime()));\n        }\n\n        if (copyOrphanedVersions == null) {\n            log.info(\"copyOrphanedVersions parameter set to false\");\n        } else {\n            log.info(\"copyOrphanedVersions parameter set to {}\", DATE_FORMAT.format(copyOrphanedVersions.getTime()));\n        }\n\n        if (includePaths != null) {\n            log.info(\"paths to include: {}\", (Object) includePaths);\n        }\n\n        if (excludePaths != null) {\n            log.info(\"paths to exclude: {}\", (Object) excludePaths);\n        }\n\n        if (failOnError) {\n            log.info(\"Unreadable nodes will cause failure of the entire transaction\");\n        }\n\n        if (earlyShutdown) {\n            log.info(\"Source repository would be shutdown post copying of nodes\");\n        }\n\n        if (skipInitialization) {\n            log.info(\"The repository initialization will be skipped\");\n        }\n\n        if (skipNameCheck) {\n            log.info(\"Test for long-named nodes will be disabled\");\n        }\n\n        if (includeIndex) {\n            log.info(\"Index data for the paths {} will be copied\", (Object) includePaths);\n        }\n\n        if (ignoreMissingBinaries) {\n            log.info(\"Missing binaries won't break the migration\");\n        }\n\n        log.info(\"Cache size: {} MB\", cacheSizeInMB);\n\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void addMiscOptions(OptionParser op) {\n        op.accepts(MMAP, \"Enable memory mapped file access for Segment Store\");\n        op.accepts(FAIL_ON_ERROR, \"Fail completely if nodes can't be read from the source repo\");\n        op.accepts(EARLY_SHUTDOWN,\n                \"Shutdown the source repository after nodes are copied and before the commit hooks are applied\");\n        op.accepts(CACHE_SIZE, \"Cache size in MB\").withRequiredArg().ofType(Integer.class).defaultsTo(256);\n        op.accepts(SKIP_INIT, \"Skip the repository initialization; only copy data\");\n    }","id":718,"modified_method":"private static void addMiscOptions(OptionParser op) {\n        op.accepts(DISABLE_MMAP, \"Disable memory mapped file access for Segment Store\");\n        op.accepts(FAIL_ON_ERROR, \"Fail completely if nodes can't be read from the source repo\");\n        op.accepts(EARLY_SHUTDOWN,\n                \"Shutdown the source repository after nodes are copied and before the commit hooks are applied\");\n        op.accepts(CACHE_SIZE, \"Cache size in MB\").withRequiredArg().ofType(Integer.class).defaultsTo(256);\n        op.accepts(SKIP_INIT, \"Skip the repository initialization; only copy data\");\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":719,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentFactory(String directory, boolean mmap) {\n        this.dir = new File(directory);\n        this.mmap = mmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","id":720,"modified_method":"public SegmentFactory(String directory, boolean disableMmap) {\n        this.dir = new File(directory);\n        this.disableMmap = disableMmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentTarFactory(String directory, boolean mmap) {\n        this.dir = new File(directory);\n        this.mmap = mmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","id":721,"modified_method":"public SegmentTarFactory(String directory, boolean disableMmap) {\n        this.dir = new File(directory);\n        this.disableMmap = disableMmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":722,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MigrationOptions(MigrationCliArguments args) {\n        this.copyBinariesByReference = !args.hasOption(OptionParserFactory.COPY_BINARIES);\n        this.mmap = args.hasOption(OptionParserFactory.MMAP);\n        if (args.hasOption(OptionParserFactory.CACHE_SIZE)) {\n            this.cacheSizeInMB = args.getIntOption(OptionParserFactory.CACHE_SIZE);\n        } else {\n            this.cacheSizeInMB = 256;\n        }\n\n        final Calendar epoch = Calendar.getInstance();\n        epoch.setTimeInMillis(0);\n        if (args.hasOption(OptionParserFactory.COPY_VERSIONS)) {\n            this.copyVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_VERSIONS));\n        } else {\n            this.copyVersions = epoch;\n        }\n        if (args.hasOption(OptionParserFactory.COPY_ORPHANED_VERSIONS)) {\n            this.copyOrphanedVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_ORPHANED_VERSIONS));\n        } else {\n            this.copyOrphanedVersions = epoch;\n        }\n        this.includePaths = split(args.getOption(OptionParserFactory.INCLUDE_PATHS));\n        this.excludePaths = split(args.getOption(OptionParserFactory.EXCLUDE_PATHS));\n        this.mergePaths = split(args.getOption(OptionParserFactory.MERGE_PATHS));\n        this.includeIndex = args.hasOption(OptionParserFactory.INCLUDE_INDEX);\n        this.failOnError = args.hasOption(OptionParserFactory.FAIL_ON_ERROR);\n        this.earlyShutdown = args.hasOption(OptionParserFactory.EARLY_SHUTDOWN);\n        this.skipInitialization = args.hasOption(OptionParserFactory.SKIP_INIT);\n        this.skipNameCheck = args.hasOption(OptionParserFactory.SKIP_NAME_CHECK);\n        this.ignoreMissingBinaries = args.hasOption(OptionParserFactory.IGNORE_MISSING_BINARIES);\n        logOptions();\n    }","id":723,"modified_method":"public MigrationOptions(MigrationCliArguments args) {\n        this.copyBinariesByReference = !args.hasOption(OptionParserFactory.COPY_BINARIES);\n        this.disableMmap = args.hasOption(OptionParserFactory.DISABLE_MMAP);\n        if (args.hasOption(OptionParserFactory.CACHE_SIZE)) {\n            this.cacheSizeInMB = args.getIntOption(OptionParserFactory.CACHE_SIZE);\n        } else {\n            this.cacheSizeInMB = 256;\n        }\n\n        final Calendar epoch = Calendar.getInstance();\n        epoch.setTimeInMillis(0);\n        if (args.hasOption(OptionParserFactory.COPY_VERSIONS)) {\n            this.copyVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_VERSIONS));\n        } else {\n            this.copyVersions = epoch;\n        }\n        if (args.hasOption(OptionParserFactory.COPY_ORPHANED_VERSIONS)) {\n            this.copyOrphanedVersions = parseVersionCopyArgument(args.getOption(OptionParserFactory.COPY_ORPHANED_VERSIONS));\n        } else {\n            this.copyOrphanedVersions = epoch;\n        }\n        this.includePaths = split(args.getOption(OptionParserFactory.INCLUDE_PATHS));\n        this.excludePaths = split(args.getOption(OptionParserFactory.EXCLUDE_PATHS));\n        this.mergePaths = split(args.getOption(OptionParserFactory.MERGE_PATHS));\n        this.includeIndex = args.hasOption(OptionParserFactory.INCLUDE_INDEX);\n        this.failOnError = args.hasOption(OptionParserFactory.FAIL_ON_ERROR);\n        this.earlyShutdown = args.hasOption(OptionParserFactory.EARLY_SHUTDOWN);\n        this.skipInitialization = args.hasOption(OptionParserFactory.SKIP_INIT);\n        this.skipNameCheck = args.hasOption(OptionParserFactory.SKIP_NAME_CHECK);\n        this.ignoreMissingBinaries = args.hasOption(OptionParserFactory.IGNORE_MISSING_BINARIES);\n        logOptions();\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void logOptions() {\n        if (copyBinariesByReference) {\n            log.info(\"DataStore needs to be shared with new repository\");\n        } else {\n            log.info(\"Binary content would be copied to the NodeStore.\");\n        }\n\n        if (mmap) {\n            log.info(\"Enabling memory mapped file access for Segment Store\");\n        }\n\n        if (copyVersions == null) {\n            log.info(\"copyVersions parameter set to false\");\n        } else {\n            log.info(\"copyVersions parameter set to {}\", DATE_FORMAT.format(copyVersions.getTime()));\n        }\n\n        if (copyOrphanedVersions == null) {\n            log.info(\"copyOrphanedVersions parameter set to false\");\n        } else {\n            log.info(\"copyOrphanedVersions parameter set to {}\", DATE_FORMAT.format(copyOrphanedVersions.getTime()));\n        }\n\n        if (includePaths != null) {\n            log.info(\"paths to include: {}\", (Object) includePaths);\n        }\n\n        if (excludePaths != null) {\n            log.info(\"paths to exclude: {}\", (Object) excludePaths);\n        }\n\n        if (failOnError) {\n            log.info(\"Unreadable nodes will cause failure of the entire transaction\");\n        }\n\n        if (earlyShutdown) {\n            log.info(\"Source repository would be shutdown post copying of nodes\");\n        }\n\n        if (skipInitialization) {\n            log.info(\"The repository initialization will be skipped\");\n        }\n\n        if (skipNameCheck) {\n            log.info(\"Test for long-named nodes will be disabled\");\n        }\n\n        if (includeIndex) {\n            log.info(\"Index data for the paths {} will be copied\", (Object) includePaths);\n        }\n\n        if (ignoreMissingBinaries) {\n            log.info(\"Missing binaries won't break the migration\");\n        }\n\n        log.info(\"Cache size: {} MB\", cacheSizeInMB);\n\n    }","id":724,"modified_method":"private void logOptions() {\n        if (copyBinariesByReference) {\n            log.info(\"DataStore needs to be shared with new repository\");\n        } else {\n            log.info(\"Binary content would be copied to the NodeStore.\");\n        }\n\n        if (disableMmap) {\n            log.info(\"Disabling memory mapped file access for Segment Store\");\n        }\n\n        if (copyVersions == null) {\n            log.info(\"copyVersions parameter set to false\");\n        } else {\n            log.info(\"copyVersions parameter set to {}\", DATE_FORMAT.format(copyVersions.getTime()));\n        }\n\n        if (copyOrphanedVersions == null) {\n            log.info(\"copyOrphanedVersions parameter set to false\");\n        } else {\n            log.info(\"copyOrphanedVersions parameter set to {}\", DATE_FORMAT.format(copyOrphanedVersions.getTime()));\n        }\n\n        if (includePaths != null) {\n            log.info(\"paths to include: {}\", (Object) includePaths);\n        }\n\n        if (excludePaths != null) {\n            log.info(\"paths to exclude: {}\", (Object) excludePaths);\n        }\n\n        if (failOnError) {\n            log.info(\"Unreadable nodes will cause failure of the entire transaction\");\n        }\n\n        if (earlyShutdown) {\n            log.info(\"Source repository would be shutdown post copying of nodes\");\n        }\n\n        if (skipInitialization) {\n            log.info(\"The repository initialization will be skipped\");\n        }\n\n        if (skipNameCheck) {\n            log.info(\"Test for long-named nodes will be disabled\");\n        }\n\n        if (includeIndex) {\n            log.info(\"Index data for the paths {} will be copied\", (Object) includePaths);\n        }\n\n        if (ignoreMissingBinaries) {\n            log.info(\"Missing binaries won't break the migration\");\n        }\n\n        log.info(\"Cache size: {} MB\", cacheSizeInMB);\n\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public boolean isMmap() {\n        return mmap;\n    }","id":725,"modified_method":"public boolean isDisableMmap() {\n        return disableMmap;\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected String[] getArgs() {\n        return new String[] { \"--missingblobstore\", source.getDescription(), destination.getDescription() };\n    }","id":726,"modified_method":"@Override\n    protected String[] getArgs() {\n        return new String[] { \"--disable-mmap\", \"--missingblobstore\", source.getDescription(), destination.getDescription() };\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void addMiscOptions(OptionParser op) {\n        op.accepts(MMAP, \"Enable memory mapped file access for Segment Store\");\n        op.accepts(FAIL_ON_ERROR, \"Fail completely if nodes can't be read from the source repo\");\n        op.accepts(EARLY_SHUTDOWN,\n                \"Shutdown the source repository after nodes are copied and before the commit hooks are applied\");\n        op.accepts(CACHE_SIZE, \"Cache size in MB\").withRequiredArg().ofType(Integer.class).defaultsTo(256);\n        op.accepts(SKIP_INIT, \"Skip the repository initialization; only copy data\");\n    }","id":727,"modified_method":"private static void addMiscOptions(OptionParser op) {\n        op.accepts(DISABLE_MMAP, \"Disable memory mapped file access for Segment Store\");\n        op.accepts(FAIL_ON_ERROR, \"Fail completely if nodes can't be read from the source repo\");\n        op.accepts(EARLY_SHUTDOWN,\n                \"Shutdown the source repository after nodes are copied and before the commit hooks are applied\");\n        op.accepts(CACHE_SIZE, \"Cache size in MB\").withRequiredArg().ofType(Integer.class).defaultsTo(256);\n        op.accepts(SKIP_INIT, \"Skip the repository initialization; only copy data\");\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":728,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentFactory(String directory, boolean mmap) {\n        this.dir = new File(directory);\n        this.mmap = mmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","id":729,"modified_method":"public SegmentFactory(String directory, boolean disableMmap) {\n        this.dir = new File(directory);\n        this.disableMmap = disableMmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public SegmentTarFactory(String directory, boolean mmap) {\n        this.dir = new File(directory);\n        this.mmap = mmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","id":730,"modified_method":"public SegmentTarFactory(String directory, boolean disableMmap) {\n        this.dir = new File(directory);\n        this.disableMmap = disableMmap;\n        createDirectoryIfMissing(dir);\n        if (!dir.isDirectory()) {\n            throw new IllegalArgumentException(\"Not a directory: \" + dir.getPath());\n        }\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":731,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected String[] getArgs() {\n        return new String[] { \"--user\", \"sa\", \"--password\", \"sa\", source.getDescription(),\n                destination.getDescription() };\n    }","id":732,"modified_method":"@Override\n    protected String[] getArgs() {\n        return new String[] { \"--disable-mmap\", \"--user\", \"sa\", \"--password\", \"sa\", source.getDescription(),\n                destination.getDescription() };\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private CharacteristicDto restoreCharacteristic(DebtCharacteristic targetCharacteristic, @Nullable Integer parentId, List<CharacteristicDto> sourceCharacteristics,\n                                                  Date updateDate, SqlSession session) {\n    CharacteristicDto sourceCharacteristic = characteristicByKey(targetCharacteristic.key(), sourceCharacteristics, true);\n    if (sourceCharacteristic == null) {\n      CharacteristicDto newCharacteristic = toDto(targetCharacteristic, parentId).setCreatedAt(updateDate);\n      dao.insert(newCharacteristic, session);\n      return newCharacteristic;\n    } else {\n      // Update only if modifications\n      if (ObjectUtils.notEqual(sourceCharacteristic.getName(), targetCharacteristic.name()) ||\n        ObjectUtils.notEqual(sourceCharacteristic.getOrder(), targetCharacteristic.order())) {\n        sourceCharacteristic.setName(targetCharacteristic.name());\n        sourceCharacteristic.setOrder(targetCharacteristic.order());\n        sourceCharacteristic.setUpdatedAt(updateDate);\n        dao.update(sourceCharacteristic, session);\n      }\n      return sourceCharacteristic;\n    }\n  }","id":733,"modified_method":"private CharacteristicDto restoreCharacteristic(DebtCharacteristic targetCharacteristic, @Nullable Integer parentId, List<CharacteristicDto> sourceCharacteristics,\n                                                  Date updateDate, SqlSession session) {\n    CharacteristicDto sourceCharacteristic = characteristicByKey(targetCharacteristic.key(), sourceCharacteristics);\n    if (sourceCharacteristic == null) {\n      CharacteristicDto newCharacteristic = toDto(targetCharacteristic, parentId).setCreatedAt(updateDate);\n      dao.insert(newCharacteristic, session);\n      return newCharacteristic;\n    } else {\n      // Update only if modifications\n      if (ObjectUtils.notEqual(sourceCharacteristic.getName(), targetCharacteristic.name()) ||\n        ObjectUtils.notEqual(sourceCharacteristic.getOrder(), targetCharacteristic.order())) {\n        sourceCharacteristic.setName(targetCharacteristic.name());\n        sourceCharacteristic.setOrder(targetCharacteristic.order());\n        sourceCharacteristic.setUpdatedAt(updateDate);\n        dao.update(sourceCharacteristic, session);\n      }\n      return sourceCharacteristic;\n    }\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static CharacteristicDto characteristicByKey(final String key, List<CharacteristicDto> characteristicDtos, boolean canByNull) {\n    CharacteristicDto dto = Iterables.find(characteristicDtos, new Predicate<CharacteristicDto>() {\n      @Override\n      public boolean apply(CharacteristicDto input) {\n        return key.equals(input.getKey());\n      }\n    }, null);\n    if (dto == null && !canByNull) {\n      throw new IllegalStateException(String.format(\"Characteristic with key '%s' has not been found \", key));\n    }\n    return dto;\n  }","id":734,"modified_method":"@CheckForNull\n  private static CharacteristicDto characteristicByKey(final String key, List<CharacteristicDto> characteristicDtos) {\n    return Iterables.find(characteristicDtos, new Predicate<CharacteristicDto>() {\n      @Override\n      public boolean apply(CharacteristicDto input) {\n        return key.equals(input.getKey());\n      }\n    }, null);\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Restore from plugins providing rules for a given language\n   */\n  public void restore(String languageKey) {\n    restoreProvided(loadModelFromPlugin(DebtModelPluginRepository.DEFAULT_MODEL), languageKey);\n  }","id":735,"modified_method":"/**\n   * Restore from plugins providing rules for a given language (only debt of rules on given language are restored)\n   */\n  public void restore(final String languageKey) {\n    checkPermission();\n\n    Date updateDate = new Date(system2.now());\n    SqlSession session = mybatis.openSession();\n    try {\n      List<RuleDto> rules = newArrayList(Iterables.filter(ruleDao.selectEnablesAndNonManual(session), new Predicate<RuleDto>() {\n        @Override\n        public boolean apply(RuleDto input) {\n          return languageKey.equals(input.getLanguage());\n        }\n      }));\n      restoreProvidedModel(rules, updateDate, session);\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Restore model from a given XML model\n   */\n  public ValidationMessages restoreFromXml(String xml) {\n    DebtModel debtModel = characteristicsXMLImporter.importXML(xml);\n    ValidationMessages validationMessages = ValidationMessages.create();\n    List<RuleDebt> ruleDebts = rulesXMLImporter.importXML(xml, validationMessages);\n    restore(debtModel, ruleDebts, null, validationMessages);\n    return validationMessages;\n  }","id":736,"modified_method":"/**\n   * Restore model from a given XML model (characteristics and rule debt are restored from XML)\n   */\n  public ValidationMessages restoreFromXml(String xml) {\n    checkPermission();\n\n    ValidationMessages validationMessages = ValidationMessages.create();\n    Date updateDate = new Date(system2.now());\n    SqlSession session = mybatis.openSession();\n    try {\n      List<CharacteristicDto> characteristicDtos = restoreCharacteristics(characteristicsXMLImporter.importXML(xml), updateDate, session);\n      restoreRules(characteristicDtos, ruleDao.selectEnablesAndNonManual(session), rulesXMLImporter.importXML(xml, validationMessages), validationMessages, updateDate, session);\n\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n    return validationMessages;\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Restore from provided model\n   */\n  public void restore() {\n    restoreProvided(loadModelFromPlugin(DebtModelPluginRepository.DEFAULT_MODEL), null);\n  }","id":737,"modified_method":"/**\n   * Restore from provided model (characteristics and rule debt are restored)\n   */\n  public void restore() {\n    checkPermission();\n\n    Date updateDate = new Date(system2.now());\n    SqlSession session = mybatis.openSession();\n    try {\n      restoreCharacteristics(loadModelFromPlugin(DebtModelPluginRepository.DEFAULT_MODEL), updateDate, session);\n      restoreProvidedModel(ruleDao.selectEnablesAndNonManual(session), updateDate, session);\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Restore model from a given XML model and a given language\n   */\n  public ValidationMessages restoreFromXml(String xml, String languageKey) {\n    DebtModel debtModel = characteristicsXMLImporter.importXML(xml);\n    ValidationMessages validationMessages = ValidationMessages.create();\n    List<RuleDebt> ruleDebts = rulesXMLImporter.importXML(xml, validationMessages);\n    restore(debtModel, ruleDebts, languageKey, validationMessages);\n    return validationMessages;\n  }","id":738,"modified_method":"/**\n   * Restore model from a given XML model and a given language (only debt of rules on given language are restored from XML)\n   */\n  public ValidationMessages restoreFromXml(String xml, final String languageKey) {\n    checkPermission();\n\n    ValidationMessages validationMessages = ValidationMessages.create();\n    Date updateDate = new Date(system2.now());\n    SqlSession session = mybatis.openSession();\n    try {\n      List<CharacteristicDto> characteristicDtos = dao.selectEnabledCharacteristics(session);\n      List<RuleDto> rules = newArrayList(Iterables.filter(ruleDao.selectEnablesAndNonManual(session), new Predicate<RuleDto>() {\n        @Override\n        public boolean apply(RuleDto input) {\n          return languageKey.equals(input.getLanguage());\n        }\n      }));\n      restoreRules(characteristicDtos, rules, rulesXMLImporter.importXML(xml, validationMessages), validationMessages, updateDate, session);\n\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n    return validationMessages;\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void restoreRules(List<CharacteristicDto> characteristicDtos, @Nullable String languageKey, List<RuleDebt> ruleDebts,\n                            ValidationMessages validationMessages, Date updateDate, SqlSession session) {\n    for (RuleDto rule : ruleDao.selectEnablesAndNonManual(session)) {\n      if (languageKey == null || languageKey.equals(rule.getLanguage())) {\n        RuleDebt ruleDebt = ruleDebtByRule(rule, ruleDebts);\n        if (ruleDebt == null) {\n          rule.setCharacteristicId(rule.getDefaultCharacteristicId() != null ? RuleDto.DISABLED_CHARACTERISTIC_ID : null);\n          rule.setRemediationFunction(null);\n          rule.setRemediationFactor(null);\n          rule.setRemediationOffset(null);\n        } else {\n          CharacteristicDto characteristicDto = characteristicByKey(ruleDebt.characteristicKey(), characteristicDtos, false);\n          // Characteristic cannot be null as it has been created just before\n\n          boolean isSameCharacteristic = characteristicDto.getId().equals(rule.getDefaultCharacteristicId());\n          boolean isSameFunction = isSameRemediationFunction(ruleDebt, rule);\n          rule.setCharacteristicId((!isSameCharacteristic ? characteristicDto.getId() : null));\n          rule.setRemediationFunction((!isSameFunction ? ruleDebt.function().name() : null));\n          rule.setRemediationFactor((!isSameFunction ? ruleDebt.factor() : null));\n          rule.setRemediationOffset((!isSameFunction ? ruleDebt.offset() : null));\n        }\n\n        ruleDebts.remove(ruleDebt);\n        rule.setUpdatedAt(updateDate);\n        ruleDao.update(rule, session);\n        // TODO index rules in E/S\n      }\n    }\n\n    for (RuleDebt ruleDebt : ruleDebts) {\n      validationMessages.addWarningText(String.format(\"The rule '%s' does not exist.\", ruleDebt.ruleKey()));\n    }\n  }","id":739,"modified_method":"private void restoreRules(List<CharacteristicDto> characteristicDtos, List<RuleDto> rules, List<RuleDebt> ruleDebts,\n                            ValidationMessages validationMessages, Date updateDate, SqlSession session) {\n    for (RuleDto rule : rules) {\n      RuleDebt ruleDebt = ruleDebtByRule(rule, ruleDebts);\n      if (ruleDebt == null) {\n        disabledRuleDebt(rule, updateDate, session);\n      } else {\n        CharacteristicDto characteristicDto = characteristicByKey(ruleDebt.characteristicKey(), characteristicDtos);\n        if (characteristicDto == null) {\n          disabledRuleDebt(rule, updateDate, session);\n        } else {\n          boolean isSameCharacteristic = characteristicDto.getId().equals(rule.getDefaultCharacteristicId());\n          boolean isSameFunction = isSameRemediationFunction(ruleDebt, rule);\n          rule.setCharacteristicId((!isSameCharacteristic ? characteristicDto.getId() : null));\n          rule.setRemediationFunction((!isSameFunction ? ruleDebt.function().name() : null));\n          rule.setRemediationFactor((!isSameFunction ? ruleDebt.factor() : null));\n          rule.setRemediationOffset((!isSameFunction ? ruleDebt.offset() : null));\n          rule.setUpdatedAt(updateDate);\n          ruleDao.update(rule, session);\n          // TODO index rules in E/S\n        }\n      }\n      ruleDebts.remove(ruleDebt);\n    }\n\n    for (RuleDebt ruleDebt : ruleDebts) {\n      validationMessages.addWarningText(String.format(\"The rule '%s' does not exist.\", ruleDebt.ruleKey()));\n    }\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_language() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability updated\").setOrder(2).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler updated\").setParentId(1).setCreatedAt(oldDate)\n    ));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setLanguage(\"java\")\n        .setCharacteristicId(2).setRemediationFunction(\"LINEAR_OFFSET\").setRemediationFactor(\"2h\").setRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate),\n      // Should be ignored\n      new RuleDto().setId(2).setRepositoryKey(\"checkstyle\").setLanguage(\"java2\")\n        .setCharacteristicId(3).setRemediationFunction(\"LINEAR\").setRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restore(\"java\");\n\n    verify(dao).selectEnabledCharacteristics(session);\n    verify(dao, times(2)).update(any(CharacteristicDto.class), eq(session));\n    verifyNoMoreInteractions(dao);\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n\n    verify(session).commit();\n  }","id":740,"modified_method":"@Test\n  public void restore_from_language() throws Exception {\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setLanguage(\"java\")\n        .setCharacteristicId(2).setRemediationFunction(\"LINEAR_OFFSET\").setRemediationFactor(\"2h\").setRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate),\n      // Should be ignored because linked on another language\n      new RuleDto().setId(2).setRepositoryKey(\"checkstyle\").setLanguage(\"java2\")\n        .setCharacteristicId(2).setRemediationFunction(\"LINEAR\").setRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restore(\"java\");\n\n    verify(dao, never()).update(any(CharacteristicDto.class), eq(session));\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_xml_with_different_characteristic_and_same_function() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    rules.add(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR).setFactor(\"2h\"));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(10).setDefaultRemediationFunction(\"LINEAR\").setDefaultRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isEqualTo(2);\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","id":741,"modified_method":"@Test\n  public void restore_from_xml_with_different_characteristic_and_same_function() throws Exception {\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(newArrayList(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR).setFactor(\"2h\")));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(10).setDefaultRemediationFunction(\"LINEAR\").setDefaultRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isEqualTo(2);\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    MockUserSession.set().setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    when(system2.now()).thenReturn(now.getTime());\n\n    currentId = 10;\n    // Associate an id when inserting an object to simulate the db id generator\n    doAnswer(new Answer() {\n      public Object answer(InvocationOnMock invocation) {\n        Object[] args = invocation.getArguments();\n        CharacteristicDto dto = (CharacteristicDto) args[0];\n        dto.setId(currentId++);\n        return null;\n      }\n    }).when(dao).insert(any(CharacteristicDto.class), any(SqlSession.class));\n\n    when(myBatis.openSession()).thenReturn(session);\n\n    Reader defaultModelReader = mock(Reader.class);\n    when(debtModelPluginRepository.createReaderForXMLFile(\"technical-debt\")).thenReturn(defaultModelReader);\n    when(characteristicsXMLImporter.importXML(eq(defaultModelReader))).thenReturn(debtModel);\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(debtModel);\n    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(rules);\n\n    debtModelBackup = new DebtModelBackup(myBatis, dao, ruleDao, debtModelOperations, debtModelPluginRepository, characteristicsXMLImporter, rulesXMLImporter,\n      debtModelXMLExporter, system2);\n  }","id":742,"modified_method":"@Before\n  public void setUp() throws Exception {\n    MockUserSession.set().setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    when(system2.now()).thenReturn(now.getTime());\n\n    currentId = 10;\n    // Associate an id when inserting an object to simulate the db id generator\n    doAnswer(new Answer() {\n      public Object answer(InvocationOnMock invocation) {\n        Object[] args = invocation.getArguments();\n        CharacteristicDto dto = (CharacteristicDto) args[0];\n        dto.setId(currentId++);\n        return null;\n      }\n    }).when(dao).insert(any(CharacteristicDto.class), any(SqlSession.class));\n\n    when(myBatis.openSession()).thenReturn(session);\n\n    Reader defaultModelReader = mock(Reader.class);\n    when(debtModelPluginRepository.createReaderForXMLFile(\"technical-debt\")).thenReturn(defaultModelReader);\n    when(characteristicsXMLImporter.importXML(any(Reader.class))).thenReturn(xmlDebtModel);\n//    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(xmlDebtModel);\n//    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(xmlDebtRules);\n\n    debtModelBackup = new DebtModelBackup(myBatis, dao, ruleDao, debtModelOperations, debtModelPluginRepository, characteristicsXMLImporter, rulesXMLImporter,\n      debtModelXMLExporter, system2);\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_xml_disable_rule_debt_when_not_in_xml_and_rule_have_default_debt_values() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(2).setDefaultRemediationFunction(\"LINEAR_OFFSET\").setDefaultRemediationFactor(\"2h\").setDefaultRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isEqualTo(-1);\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","id":743,"modified_method":"@Test\n  public void restore_from_xml_disable_rule_debt_when_not_in_xml_and_rule_have_default_debt_values() throws Exception {\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(2).setDefaultRemediationFunction(\"LINEAR_OFFSET\").setDefaultRemediationFactor(\"2h\").setDefaultRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isEqualTo(-1);\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void add_warning_message_when_rule_from_xml_is_not_found() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    rules.add(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR).setFactor(\"2h\"));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(Collections.<RuleDto>emptyList());\n\n    ValidationMessages validationMessages = debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    assertThat(validationMessages.getWarnings()).hasSize(1);\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verifyNoMoreInteractions(ruleDao);\n\n    verify(session).commit();\n  }","id":744,"modified_method":"@Test\n  public void add_warning_message_when_rule_from_xml_is_not_found() throws Exception {\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(newArrayList(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR).setFactor(\"2h\")));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(Collections.<RuleDto>emptyList());\n\n    assertThat(debtModelBackup.restoreFromXml(\"<xml/>\").getWarnings()).hasSize(1);\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verifyNoMoreInteractions(ruleDao);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_provided_model() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability updated\").setOrder(2).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler updated\").setParentId(1).setCreatedAt(oldDate)\n    ));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setRepositoryKey(\"squid\").setCharacteristicId(2).setRemediationFunction(\"LINEAR_OFFSET\").setRemediationFactor(\"2h\").setRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restore();\n\n    verify(dao).selectEnabledCharacteristics(session);\n    verify(dao, times(2)).update(any(CharacteristicDto.class), eq(session));\n    verifyNoMoreInteractions(dao);\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","id":745,"modified_method":"@Test\n  public void restore_from_provided_model() throws Exception {\n    when(characteristicsXMLImporter.importXML(any(Reader.class))).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability updated\").setOrder(2).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler updated\").setParentId(1).setCreatedAt(oldDate)\n    ));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setRepositoryKey(\"squid\").setCharacteristicId(2).setRemediationFunction(\"LINEAR_OFFSET\").setRemediationFactor(\"2h\").setRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restore();\n\n    verify(dao).selectEnabledCharacteristics(session);\n    verify(dao, times(2)).update(any(CharacteristicDto.class), eq(session));\n    verifyNoMoreInteractions(dao);\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_xml_set_no_rule_debt_when_not_in_xml_and_rule_has_no_default_debt_values() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    // As rule has no debt value, characteristic is set to null\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","id":746,"modified_method":"@Test\n  public void restore_from_xml_set_no_rule_debt_when_not_in_xml_and_rule_has_no_default_debt_values() throws Exception {\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    // As rule has no debt value, characteristic is set to null\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_xml_with_same_characteristic_and_same_function() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    rules.add(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR_OFFSET).setFactor(\"2h\").setOffset(\"15min\"));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(2).setDefaultRemediationFunction(\"LINEAR_OFFSET\").setDefaultRemediationFactor(\"2h\").setDefaultRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","id":747,"modified_method":"@Test\n  public void restore_from_xml_with_same_characteristic_and_same_function() throws Exception {\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(newArrayList(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR_OFFSET).setFactor(\"2h\").setOffset(\"15min\")));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(2).setDefaultRemediationFunction(\"LINEAR_OFFSET\").setDefaultRemediationFactor(\"2h\").setDefaultRemediationOffset(\"15min\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isNull();\n    assertThat(rule.getRemediationFactor()).isNull();\n    assertThat(rule.getRemediationOffset()).isNull();\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_xml_with_same_characteristic_and_different_function() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    rules.add(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR_OFFSET).setFactor(\"12h\").setOffset(\"11min\"));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(2).setDefaultRemediationFunction(\"LINEAR\").setDefaultRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isEqualTo(\"LINEAR_OFFSET\");\n    assertThat(rule.getRemediationFactor()).isEqualTo(\"12h\");\n    assertThat(rule.getRemediationOffset()).isEqualTo(\"11min\");\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","id":748,"modified_method":"@Test\n  public void restore_from_xml_with_same_characteristic_and_different_function() throws Exception {\n    when(characteristicsXMLImporter.importXML(anyString())).thenReturn(new DebtModel()\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\"));\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(newArrayList(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR_OFFSET).setFactor(\"12h\").setOffset(\"11min\")));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\")\n        .setDefaultCharacteristicId(2).setDefaultRemediationFunction(\"LINEAR\").setDefaultRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n    assertThat(rule.getCharacteristicId()).isNull();\n    assertThat(rule.getRemediationFunction()).isEqualTo(\"LINEAR_OFFSET\");\n    assertThat(rule.getRemediationFactor()).isEqualTo(\"12h\");\n    assertThat(rule.getRemediationOffset()).isEqualTo(\"11min\");\n    assertThat(rule.getUpdatedAt()).isEqualTo(now);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void restore_from_xml_and_language() throws Exception {\n    debtModel\n      .addRootCharacteristic(new DefaultDebtCharacteristic().setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1))\n      .addSubCharacteristic(new DefaultDebtCharacteristic().setKey(\"COMPILER\").setName(\"Compiler\"), \"PORTABILITY\");\n\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    rules.add(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR).setFactor(\"2h\"));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\").setLanguage(\"java\")\n        .setDefaultCharacteristicId(10).setDefaultRemediationFunction(\"LINEAR\").setDefaultRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate),\n      // Should be ignored\n      new RuleDto().setId(2).setRepositoryKey(\"checkstyle\").setLanguage(\"java2\")\n        .setCharacteristicId(3).setRemediationFunction(\"LINEAR\").setRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\", \"java\");\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n\n    verify(session).commit();\n  }","id":749,"modified_method":"@Test\n  public void restore_from_xml_and_language() throws Exception {\n    when(dao.selectEnabledCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(1).setKey(\"PORTABILITY\").setName(\"Portability\").setOrder(1).setCreatedAt(oldDate),\n      new CharacteristicDto().setId(2).setKey(\"COMPILER\").setName(\"Compiler\").setParentId(1).setCreatedAt(oldDate)));\n\n    when(rulesXMLImporter.importXML(anyString(), any(ValidationMessages.class))).thenReturn(newArrayList(new RuleDebt()\n      .setRuleKey(RuleKey.of(\"squid\", \"UselessImportCheck\")).setCharacteristicKey(\"COMPILER\").setFunction(DebtRemediationFunction.Type.LINEAR).setFactor(\"2h\")));\n\n    when(ruleDao.selectEnablesAndNonManual(session)).thenReturn(newArrayList(\n      new RuleDto().setId(1).setRepositoryKey(\"squid\").setRuleKey(\"UselessImportCheck\").setLanguage(\"java\")\n        .setDefaultCharacteristicId(10).setDefaultRemediationFunction(\"LINEAR\").setDefaultRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate),\n      // Should be ignored\n      new RuleDto().setId(2).setRepositoryKey(\"checkstyle\").setLanguage(\"java2\")\n        .setCharacteristicId(3).setRemediationFunction(\"LINEAR\").setRemediationFactor(\"2h\")\n        .setCreatedAt(oldDate).setUpdatedAt(oldDate)\n    ));\n\n    debtModelBackup.restoreFromXml(\"<xml/>\", \"java\");\n\n    verify(characteristicsXMLImporter, never()).importXML(anyString());\n    verify(dao, never()).update(any(CharacteristicDto.class), eq(session));\n\n    verify(ruleDao).selectEnablesAndNonManual(session);\n    verify(ruleDao).update(ruleArgument.capture(), eq(session));\n    verifyNoMoreInteractions(ruleDao);\n\n    RuleDto rule = ruleArgument.getValue();\n    assertThat(rule.getId()).isEqualTo(1);\n\n    verify(session).commit();\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Disable characteristic and its sub characteristics or only sub characteristic.\n   * Will also update every rules linked to sub characteristics by setting characteristic id to -1 and remove function, factor and offset.\n   */\n  public void delete(int characteristicId) {\n    checkPermission();\n\n    Date updateDate = new Date(system2.now());\n    SqlSession session = mybatis.openBatchSession();\n    try {\n      CharacteristicDto characteristicOrSubCharacteristic = findCharacteristic(characteristicId, session);\n      // When root characteristic, browse sub characteristics and disable rule debt on each sub characteristic then disable it\n      if (characteristicOrSubCharacteristic.getParentId() == null) {\n        List<CharacteristicDto> subCharacteristics = dao.selectCharacteristicsByParentId(characteristicOrSubCharacteristic.getId(), session);\n        for (CharacteristicDto subCharacteristic : subCharacteristics) {\n          disableSubChracteristic(subCharacteristic, updateDate, session);\n        }\n        disableCharacteristic(characteristicOrSubCharacteristic, updateDate, session);\n      } else {\n        // When sub characteristic, disable rule debt on the sub characteristic then disable it\n        disableSubChracteristic(characteristicOrSubCharacteristic, updateDate, session);\n      }\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":750,"modified_method":"/**\n   * Disable characteristic and its sub characteristics or only sub characteristic.\n   * Will also update every rules linked to sub characteristics by setting characteristic id to -1 and remove function, factor and offset.\n   */\n  public void delete(int characteristicId) {\n    checkPermission();\n\n    Date updateDate = new Date(system2.now());\n    SqlSession session = mybatis.openBatchSession();\n    try {\n      CharacteristicDto characteristicOrSubCharacteristic = findCharacteristic(characteristicId, session);\n      // When root characteristic, browse sub characteristics and disable rule debt on each sub characteristic then disable it\n      if (characteristicOrSubCharacteristic.getParentId() == null) {\n        List<CharacteristicDto> subCharacteristics = dao.selectCharacteristicsByParentId(characteristicOrSubCharacteristic.getId(), session);\n        for (CharacteristicDto subCharacteristic : subCharacteristics) {\n          disableSubCharacteristic(subCharacteristic, updateDate, session);\n        }\n        disableCharacteristic(characteristicOrSubCharacteristic, updateDate, session);\n      } else {\n        // When sub characteristic, disable rule debt on the sub characteristic then disable it\n        disableSubCharacteristic(characteristicOrSubCharacteristic, updateDate, session);\n      }\n      session.commit();\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void disableSubChracteristic(CharacteristicDto subCharacteristic, Date updateDate, SqlSession session) {\n    disableDebtRules(ruleDao.selectBySubCharacteristicId(subCharacteristic.getId(), session), updateDate, session);\n    disableCharacteristic(subCharacteristic, updateDate, session);\n  }","id":751,"modified_method":"private void disableSubCharacteristic(CharacteristicDto subCharacteristic, Date updateDate, SqlSession session) {\n    disableDebtRules(ruleDao.selectBySubCharacteristicId(subCharacteristic.getId(), session), updateDate, session);\n    disableCharacteristic(subCharacteristic, updateDate, session);\n  }","commit_id":"55a9be1fa31394aec3093bc27cd9c501f0f0cc60","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected long getPortletRenderTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer renderTimeout = portletDefinition.getRenderTimeout();\n        if (renderTimeout != null) {\n            return renderTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":752,"modified_method":"protected long getPortletRenderTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer renderTimeout = portletDefinition.getRenderTimeout();\n        if (renderTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, renderTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected long getPortletEventTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer eventTimeout = portletDefinition.getEventTimeout();\n        if (eventTimeout != null) {\n            return eventTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":753,"modified_method":"protected long getPortletEventTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer eventTimeout = portletDefinition.getEventTimeout();\n        if (eventTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, eventTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected long getPortletActionTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer actionTimeout = portletDefinition.getActionTimeout();\n        if (actionTimeout != null) {\n            return actionTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":754,"modified_method":"protected long getPortletActionTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer actionTimeout = portletDefinition.getActionTimeout();\n        if (actionTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, actionTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected long getPortletResourceTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer resourceTimeout = portletDefinition.getResourceTimeout();\n        if (resourceTimeout != null) {\n            return resourceTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":755,"modified_method":"protected long getPortletResourceTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer resourceTimeout = portletDefinition.getResourceTimeout();\n        if (resourceTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, resourceTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Test\n    public void testSoapFaultRoutes() {\n        URL wsdlURL = getClass().getClassLoader().getResource(\"person.wsdl\");\n        PersonService ss = new PersonService(wsdlURL, new QName(\"http://camel.apache.org/wsdl-first\",\n                                                                \"PersonService\"));\n        // test message mode\n        Person client = ss.getSoap();\n        Holder<String> personId = new Holder<String>();\n        personId.value = \"\";\n        Holder<String> ssn = new Holder<String>();\n        Holder<String> name = new Holder<String>();\n        Throwable t = null;\n        try {\n            client.getPerson(personId, ssn, name);\n            fail(\"Expect exception\");\n        } catch (UnknownPersonFault e) {\n            t = e;\n        }\n        assertTrue(t instanceof UnknownPersonFault);\n\n        \n        // test PAYLOAD mode\n        Person client2 = ss.getSoap2();\n        Holder<String> personId2 = new Holder<String>();\n        personId2.value = \"\";\n        Holder<String> ssn2 = new Holder<String>();\n        Holder<String> name2 = new Holder<String>();\n        try {\n            client2.getPerson(personId2, ssn2, name2);\n            fail(\"Expect exception\");\n        } catch (UnknownPersonFault e) {\n            t = e;\n        }\n        assertTrue(t instanceof UnknownPersonFault);\n    }","id":756,"modified_method":"@Test\n    public void testRoutesWithFault() throws Exception {\n        URL wsdlURL = getClass().getClassLoader().getResource(\"person.wsdl\");\n        PersonService ss = new PersonService(wsdlURL, new QName(\"http://camel.apache.org/wsdl-first\",\n                                                                \"PersonService\"));\n        Person client = ss.getSoap();\n        Holder<String> personId = new Holder<String>();\n        personId.value = \"hello\";\n        Holder<String> ssn = new Holder<String>();\n        Holder<String> name = new Holder<String>();\n        client.getPerson(personId, ssn, name);\n        assertEquals(\"Bonjour\", name.value);\n        \n        personId.value = \"\";\n        ssn = new Holder<String>();\n        name = new Holder<String>();\n        Throwable t = null;\n        try {\n            client.getPerson(personId, ssn, name);\n            fail(\"Expect exception\");\n        } catch (UnknownPersonFault e) {\n            t = e;\n        }\n        assertTrue(t instanceof UnknownPersonFault);\n\n        Person client2 = ss.getSoap2();\n        Holder<String> personId2 = new Holder<String>();\n        personId2.value = \"hello\";\n        Holder<String> ssn2 = new Holder<String>();\n        Holder<String> name2 = new Holder<String>();\n        client2.getPerson(personId2, ssn2, name2);\n        assertEquals(\"Bonjour\", name2.value);\n        \n        personId2.value = \"\";\n        ssn2 = new Holder<String>();\n        name2 = new Holder<String>();\n        try {\n            client2.getPerson(personId2, ssn2, name2);\n            fail(\"Expect exception\");\n        } catch (UnknownPersonFault e) {\n            t = e;\n        }\n        assertTrue(t instanceof UnknownPersonFault);\n    }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"@Resource(name = \"bus\")\n    public void setBus(Bus b) {\n        bus = b;\n    }","id":757,"modified_method":"@Resource(name = \"cxf\")\n    public void setBus(Bus b) {\n        super.setBus(b);\n    }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"@Resource(name = \"camelContext\")\n    public void setCamelContext(CamelContext camelContext) {\n        this.camelContext = camelContext;\n    }","id":758,"modified_method":"public void setCamelContext(CamelContext c) {\n        camelContext = c;\n    }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            applicationContext = ctx;\n            if (getBus() == null) {\n                // Don't relate on the DefaultBus\n                BusFactory factory = new SpringBusFactory(ctx);\n                Bus bus = factory.createBus();               \n                setBus(bus);\n            }\n            BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(getBus(), ctx);\n        }","id":759,"modified_method":"@SuppressWarnings(\"deprecation\")\n        public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            applicationContext = ctx;\n            if (bus == null) {\n                if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n                    // Don't relate on the DefaultBus\n                    BusFactory factory = new SpringBusFactory(ctx);\n                    bus = factory.createBus();               \n                    BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                } else {\n                    bus = BusWiringBeanFactoryPostProcessor.addDefaultBus(ctx);\n                }\n            }\n        }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (getBus() == null) {\n                // Don't relate on the DefaultBus\n                BusFactory factory = new SpringBusFactory(ctx);\n                Bus bus = factory.createBus();    \n                BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                setBus(bus);\n            }\n        }","id":760,"modified_method":"@SuppressWarnings(\"deprecation\")\n        public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (bus == null) {\n                if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n                    // Don't relate on the DefaultBus\n                    BusFactory factory = new SpringBusFactory(ctx);\n                    bus = factory.createBus();    \n                    BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                    setBus(bus);\n                } else {\n                    setBus(BusWiringBeanFactoryPostProcessor.addDefaultBus(ctx));\n                }\n            }\n        }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (getBus() == null) {\n                // Don't relate on the DefaultBus\n                BusFactory factory = new SpringBusFactory(ctx);\n                Bus bus = factory.createBus();  \n                BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                setBus(bus);\n            }\n        }","id":761,"modified_method":"@SuppressWarnings(\"deprecation\")\n        public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (bus == null) {\n                if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n                    // Don't relate on the DefaultBus\n                    BusFactory factory = new SpringBusFactory(ctx);\n                    bus = factory.createBus();               \n                    setBus(bus);\n                    BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                } else {\n                    setBus(BusWiringBeanFactoryPostProcessor.addDefaultBus(ctx));\n                }\n            }\n        }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        if (applicationContext != null) {\n            applicationContext.destroy();\n        }\n        super.tearDown();\n    }","id":762,"modified_method":"@After\n    public void tearDown() throws Exception {\n        // Don't close the application context, as it will cause some trouble on the bus shutdown\n        super.tearDown();\n        \n    }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void getTheBusInstance() {\n        Bus bus = (Bus)ctx.getBean(\"cxfBus\");\n        assertNotNull(\"The bus should not be null\", bus);\n        if (!Version.getCurrentVersion().startsWith(\"2.4\")) {\n            // This test just for the CXF 2.3.x, we skip this test with CXF 2.4.x\n            CamelTransportFactory factory = bus.getExtension(CamelTransportFactory.class);\n            assertNull(\"You should not find the factory here\", factory);\n        }\n        \n        bus = (Bus)ctx.getBean(\"myBus\");\n        assertNotNull(\"The bus should not be null\", bus);\n        CamelTransportFactory factory = bus.getExtension(CamelTransportFactory.class);\n        assertNotNull(\"You should find the factory here\", factory);\n        SoapBindingFactory soapBindingFactory = bus.getExtension(SoapBindingFactory.class);\n        assertNotNull(\"You should find the factory here\", soapBindingFactory);\n    }","id":763,"modified_method":"@Test\n    public void getTheBusInstance() {\n        Bus bus = (Bus)ctx.getBean(\"cxfBus\");\n        assertNotNull(\"The bus should not be null\", bus);\n        if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n            // This test just for the CXF 2.3.x, we skip this test with CXF 2.4.x\n            CamelTransportFactory factory = bus.getExtension(CamelTransportFactory.class);\n            assertNull(\"You should not find the factory here\", factory);\n        }\n        \n        bus = (Bus)ctx.getBean(\"myBus\");\n        assertNotNull(\"The bus should not be null\", bus);\n\n        CamelTransportFactory factory = bus.getExtension(CamelTransportFactory.class);\n        assertNotNull(\"You should find the factory here\", factory);\n        SoapBindingFactory soapBindingFactory = bus.getExtension(SoapBindingFactory.class);\n        assertNotNull(\"You should find the factory here\", soapBindingFactory);\n    }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"protected void addUserLayouts(Group group) throws Exception {\n\n\t\t// Look and Feel\n\n\t\tupdateLookAndFeel(group);\n\n\t\t// Home\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, \"Home\", \"/home\", PortletPropsValues.USER_LAYOUT_TEMPLATE);\n\n\t\taddPortlets(group, layout);\n\n\t\tupdatePermissions(layout, false);\n\n\t\t// Profile\n\n\t\tlayout = addLayout(group, \"Profile\", \"/profile\", \"2_columns_ii\");\n\n\t\tremovePortletBorder(layout, \"4_WAR_soportlet\");\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Mail\n\n\t\tlayout = addLayout(group, \"Mail\", \"/mail\", \"1_column\");\n\n\t\tupdatePermissions(layout, false);\n\t}","id":764,"modified_method":"protected void addUserLayouts(Group group) throws Exception {\n\n\t\t// Look and Feel\n\n\t\tupdateLookAndFeel(group);\n\n\t\t// Home\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, \"Home\", \"/home\", PortletPropsValues.USER_LAYOUT_TEMPLATE);\n\n\t\taddPortlets(group, layout);\n\n\t\tupdatePermissions(layout, false);\n\n\t\t// Profile\n\n\t\tlayout = addLayout(group, \"Profile\", \"/profile\", \"2_columns_ii\");\n\n\t\taddResources(layout, \"1_WAR_soportlet\");\n\t\taddResources(layout, \"4_WAR_soportlet\");\n\n\t\tremovePortletBorder(layout, \"4_WAR_soportlet\");\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Mail\n\n\t\tlayout = addLayout(group, \"Mail\", \"/mail\", \"1_column\");\n\n\t\taddResources(layout, \"1_WAR_mailportlet\");\n\n\t\tupdatePermissions(layout, false);\n\t}","commit_id":"600edaf1b5a0ff6b8e9c3fafa4b24ed7205bd506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addPortlets(Group group, Layout layout) throws Exception {\n\t\tString prefix = PortletPropsKeys.SITE_LAYOUT_PORTLETS;\n\n\t\tif (group.isUser()) {\n\t\t\tprefix = PortletPropsKeys.USER_LAYOUT_PORTLETS;\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tLayoutTemplate layoutTemplate = layoutTypePortlet.getLayoutTemplate();\n\n\t\tList<String> columns = layoutTemplate.getColumns();\n\n\t\tfor (String column : columns) {\n\t\t\tlayoutTypePortlet.setPortletIds(\n\t\t\t\tcolumn, PortletProps.get(prefix + column));\n\t\t}\n\n\t\tLayoutLocalServiceUtil.updateLayout(\n\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), layout.getLayoutId(),\n\t\t\tlayout.getTypeSettings());\n\n\t\tList<String> portletIds = layoutTypePortlet.getPortletIds();\n\n\t\tif (portletIds.contains(\"1_WAR_wysiwygportlet\")) {\n\t\t\tupdatePortletTitle(layout, \"1_WAR_wysiwygportlet\", \"Welcome\");\n\t\t}\n\t}","id":765,"modified_method":"protected void addPortlets(Group group, Layout layout) throws Exception {\n\t\tString prefix = PortletPropsKeys.SITE_LAYOUT_PORTLETS;\n\n\t\tif (group.isUser()) {\n\t\t\tprefix = PortletPropsKeys.USER_LAYOUT_PORTLETS;\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tLayoutTemplate layoutTemplate = layoutTypePortlet.getLayoutTemplate();\n\n\t\tList<String> columns = layoutTemplate.getColumns();\n\n\t\tfor (String column : columns) {\n\t\t\tlayoutTypePortlet.setPortletIds(\n\t\t\t\tcolumn, PortletProps.get(prefix + column));\n\t\t}\n\n\t\tLayoutLocalServiceUtil.updateLayout(\n\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), layout.getLayoutId(),\n\t\t\tlayout.getTypeSettings());\n\n\t\tList<String> portletIds = layoutTypePortlet.getPortletIds();\n\n\t\tfor (String portletId : portletIds) {\n\t\t\taddResources(layout, portletId);\n\n\t\t\tif (portletId.equals(\"1_WAR_wysiwygportlet\")) {\n\t\t\t\tupdatePortletTitle(layout, \"1_WAR_wysiwygportlet\", \"Welcome\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"600edaf1b5a0ff6b8e9c3fafa4b24ed7205bd506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addCommunityLayouts(Group group) throws Exception {\n\n\t\t//\tLook and Feel\n\n\t\tupdateLookAndFeel(group);\n\n\t\t// Home\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, \"Home\", \"/home\", PortletPropsValues.SITE_LAYOUT_TEMPLATE);\n\n\t\taddPortlets(group, layout);\n\n\t\tconfigureRSS(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Calendar\n\n\t\tlayout = addLayout(group, \"Calendar\", \"/calendar\", \"1_column\");\n\n\t\tremovePortletBorder(layout, \"8\");\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Documents\n\n\t\tlayout = addLayout(group, \"Documents\", \"/documents\", \"2_columns_iii\");\n\n\t\tremovePortletBorder(layout, \"20\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Forums\n\n\t\tlayout = addLayout(group, \"Forums\", \"/forums\", \"2_columns_iii\");\n\n\t\tremovePortletBorder(layout, \"19\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Blog\n\n\t\tlayout = addLayout(group, \"Blog\", \"/blog\", \"2_columns_iii\");\n\n\t\tremovePortletBorder(layout, \"33\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Wiki\n\n\t\tlayout = addLayout(group, \"Wiki\", \"/wiki\", \"2_columns_iii\");\n\n\t\tremovePortletBorder(layout, \"36\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Members\n\n\t\tlayout = addLayout(group, \"Members\", \"/members\", \"2_columns_ii\");\n\n\t\tremovePortletBorder(layout, \"2_WAR_soportlet\");\n\t\tremovePortletBorder(layout, \"3_WAR_soportlet\");\n\t\tremovePortletBorder(layout, \"4_WAR_soportlet\");\n\n\t\tupdatePermissions(layout, true);\n\t}","id":766,"modified_method":"protected void addCommunityLayouts(Group group) throws Exception {\n\n\t\t//\tLook and Feel\n\n\t\tupdateLookAndFeel(group);\n\n\t\t// Home\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, \"Home\", \"/home\", PortletPropsValues.SITE_LAYOUT_TEMPLATE);\n\n\t\taddPortlets(group, layout);\n\n\t\tconfigureRSS(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Calendar\n\n\t\tlayout = addLayout(group, \"Calendar\", \"/calendar\", \"1_column\");\n\n\t\taddResources(layout, PortletKeys.CALENDAR);\n\n\t\tremovePortletBorder(layout, PortletKeys.CALENDAR);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Documents\n\n\t\tlayout = addLayout(group, \"Documents\", \"/documents\", \"2_columns_iii\");\n\n\t\taddResources(layout, PortletKeys.DOCUMENT_LIBRARY);\n\t\taddResources(layout, \"101_INSTANCE_abcd\");\n\n\t\tremovePortletBorder(layout, PortletKeys.DOCUMENT_LIBRARY);\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Forums\n\n\t\tlayout = addLayout(group, \"Forums\", \"/forums\", \"2_columns_iii\");\n\n\t\taddResources(layout, PortletKeys.MESSAGE_BOARDS);\n\t\taddResources(layout, \"101_INSTANCE_abcd\");\n\n\t\tremovePortletBorder(layout, PortletKeys.MESSAGE_BOARDS);\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Blog\n\n\t\tlayout = addLayout(group, \"Blog\", \"/blog\", \"2_columns_iii\");\n\n\t\taddResources(layout, PortletKeys.BLOGS);\n\t\taddResources(layout, \"101_INSTANCE_abcd\");\n\n\t\tremovePortletBorder(layout, PortletKeys.BLOGS);\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Wiki\n\n\t\tlayout = addLayout(group, \"Wiki\", \"/wiki\", \"2_columns_iii\");\n\n\t\taddResources(layout, PortletKeys.WIKI);\n\t\taddResources(layout, \"101_INSTANCE_abcd\");\n\n\t\tremovePortletBorder(layout, PortletKeys.WIKI);\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Members\n\n\t\tlayout = addLayout(group, \"Members\", \"/members\", \"2_columns_ii\");\n\n\t\taddResources(layout, \"2_WAR_soportlet\");\n\t\taddResources(layout, \"3_WAR_soportlet\");\n\t\taddResources(layout, \"4_WAR_soportlet\");\n\n\t\tremovePortletBorder(layout, \"2_WAR_soportlet\");\n\t\tremovePortletBorder(layout, \"3_WAR_soportlet\");\n\t\tremovePortletBorder(layout, \"4_WAR_soportlet\");\n\n\t\tupdatePermissions(layout, true);\n\t}","commit_id":"600edaf1b5a0ff6b8e9c3fafa4b24ed7205bd506","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void execute()\n        throws MojoExecutionException, CompilationFailureException\n    {\n        // ----------------------------------------------------------------------\n        // Look up the compiler. This is done before other code than can\n        // cause the mojo to return before the lookup is done possibly resulting\n        // in misconfigured POMs still building.\n        // ----------------------------------------------------------------------\n\n        Compiler compiler;\n\n        getLog().debug( \"Using compiler '\" + compilerId + \"'.\" );\n\n        try\n        {\n            compiler = compilerManager.getCompiler( compilerId );\n        }\n        catch ( NoSuchCompilerException e )\n        {\n            throw new MojoExecutionException( \"No such compiler '\" + e.getCompilerId() + \"'.\" );\n        }\n        \n        //-----------toolchains start here ----------------------------------\n        //use the compilerId as identifier for toolchains as well.\n        Toolchain tc = getToolchain();\n        if ( tc != null ) \n        {\n            getLog().info( \"Toolchain in compiler-plugin: \" + tc );\n            if ( executable  != null ) \n            { \n                getLog().warn( \"Toolchains are ignored, 'executable' parameter is set to \" + executable );\n            } \n            else \n            {\n                fork = true;\n                //TODO somehow shaky dependency between compilerId and tool executable.\n                executable = tc.findTool( compilerId );\n            }\n        }\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        List compileSourceRoots = removeEmptyCompileSourceRoots( getCompileSourceRoots() );\n\n        if ( compileSourceRoots.isEmpty() )\n        {\n            getLog().info( \"No sources to compile\" );\n\n            return;\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Source directories: \" + compileSourceRoots.toString().replace( ',', '\\n' ) );\n            getLog().debug( \"Classpath: \" + getClasspathElements().toString().replace( ',', '\\n' ) );\n            getLog().debug( \"Output directory: \" + getOutputDirectory() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Create the compiler configuration\n        // ----------------------------------------------------------------------\n\n        CompilerConfiguration compilerConfiguration = new CompilerConfiguration();\n\n        compilerConfiguration.setOutputLocation( getOutputDirectory().getAbsolutePath() );\n\n        compilerConfiguration.setClasspathEntries( getClasspathElements() );\n\n        compilerConfiguration.setSourceLocations( compileSourceRoots );\n\n        compilerConfiguration.setOptimize( optimize );\n\n        compilerConfiguration.setDebug( debug );\n\n        if ( debug && StringUtils.isNotEmpty( debuglevel ) )\n        {\n            String[] split = StringUtils.split( debuglevel, \",\" );\n            for ( int i = 0; i < split.length; i++ )\n            {\n                if ( !( split[i].equalsIgnoreCase( \"none\" ) || split[i].equalsIgnoreCase( \"lines\" )\n                    || split[i].equalsIgnoreCase( \"vars\" ) || split[i].equalsIgnoreCase( \"source\" ) ) )\n                {\n                    throw new IllegalArgumentException( \"The specified debug level: '\" + split[i]\n                        + \"' is unsupported. \" + \"Legal values are 'none', 'lines', 'vars', and 'source'.\" );\n                }\n            }\n            compilerConfiguration.setDebugLevel( debuglevel );\n        }        \n        \n        compilerConfiguration.setVerbose( verbose );\n\n        compilerConfiguration.setShowWarnings( showWarnings );\n\n        compilerConfiguration.setShowDeprecation( showDeprecation );\n\n        compilerConfiguration.setSourceVersion( getSource() );\n\n        compilerConfiguration.setTargetVersion( getTarget() );\n\n        compilerConfiguration.setSourceEncoding( encoding );\n        \n        Map effectiveCompilerArguments = getCompilerArguments();\n\n        String effectiveCompilerArgument = getCompilerArgument();\n\n        if ( ( effectiveCompilerArguments != null ) || ( effectiveCompilerArgument != null ) )\n        {\n            LinkedHashMap cplrArgsCopy = new LinkedHashMap();\n            if ( effectiveCompilerArguments != null )\n            {\n                for ( Iterator i = effectiveCompilerArguments.entrySet().iterator(); i.hasNext(); )\n                {\n                    Map.Entry me = (Map.Entry) i.next();\n                    String key = (String) me.getKey();\n                    String value = (String) me.getValue();\n                    if ( !key.startsWith( \"-\" ) )\n                    {\n                        key = \"-\" + key;\n                    }\n                    cplrArgsCopy.put( key, value );\n                }\n            }\n            if ( !StringUtils.isEmpty( effectiveCompilerArgument ) )\n            {\n                cplrArgsCopy.put( effectiveCompilerArgument, null );\n            }\n            compilerConfiguration.setCustomCompilerArguments( cplrArgsCopy );\n        }\n\n        compilerConfiguration.setFork( fork );\n\n        if ( fork )\n        {\n            if ( !StringUtils.isEmpty( meminitial ) )\n            {\n                String value = getMemoryValue( meminitial );\n\n                if ( value != null )\n                {\n                    compilerConfiguration.setMeminitial( value );\n                }\n                else\n                {\n                    getLog().info( \"Invalid value for meminitial '\" + meminitial + \"'. Ignoring this option.\" );\n                }\n            }\n\n            if ( !StringUtils.isEmpty( maxmem ) )\n            {\n                String value = getMemoryValue( maxmem );\n\n                if ( value != null )\n                {\n                    compilerConfiguration.setMaxmem( value );\n                }\n                else\n                {\n                    getLog().info( \"Invalid value for maxmem '\" + maxmem + \"'. Ignoring this option.\" );\n                }\n            }\n        }\n\n        compilerConfiguration.setExecutable( executable );\n\n        compilerConfiguration.setWorkingDirectory( basedir );\n\n        compilerConfiguration.setCompilerVersion( compilerVersion );\n\n        compilerConfiguration.setBuildDirectory( buildDirectory );\n\n        compilerConfiguration.setOutputFileName( outputFileName );\n\n        // TODO: have an option to always compile (without need to clean)\n        Set staleSources;\n\n        boolean canUpdateTarget;\n\n        try\n        {\n            staleSources =\n                computeStaleSources( compilerConfiguration, compiler, getSourceInclusionScanner( staleMillis ) );\n\n            canUpdateTarget = compiler.canUpdateTarget( compilerConfiguration );\n\n            if ( compiler.getCompilerOutputStyle().equals( CompilerOutputStyle.ONE_OUTPUT_FILE_FOR_ALL_INPUT_FILES ) &&\n                !canUpdateTarget )\n            {\n                getLog().info( \"RESCANNING!\" );\n                // TODO: This second scan for source files is sub-optimal\n                String inputFileEnding = compiler.getInputFileEnding( compilerConfiguration );\n\n                Set sources = computeStaleSources( compilerConfiguration, compiler,\n                                                   getSourceInclusionScanner( inputFileEnding ) );\n\n                compilerConfiguration.setSourceFiles( sources );\n            }\n            else\n            {\n                compilerConfiguration.setSourceFiles( staleSources );\n            }\n        }\n        catch ( CompilerException e )\n        {\n            throw new MojoExecutionException( \"Error while computing stale sources.\", e );\n        }\n\n        if ( staleSources.isEmpty() )\n        {\n            getLog().info( \"Nothing to compile - all classes are up to date\" );\n\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Dump configuration\n        // ----------------------------------------------------------------------\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Classpath:\" );\n\n            for ( Iterator it = getClasspathElements().iterator(); it.hasNext(); )\n            {\n                String s = (String) it.next();\n\n                getLog().debug( \" \" + s );\n            }\n\n            getLog().debug( \"Source roots:\" );\n\n            for ( Iterator it = getCompileSourceRoots().iterator(); it.hasNext(); )\n            {\n                String root = (String) it.next();\n\n                getLog().debug( \" \" + root );\n            }\n\n            try\n            {\n                if ( fork )\n                {\n                    if ( compilerConfiguration.getExecutable() != null )\n                    {\n                        getLog().debug( \"Excutable: \" );\n                        getLog().debug( \" \" + compilerConfiguration.getExecutable() );\n                    }\n                }\n\n                String[] cl = compiler.createCommandLine( compilerConfiguration );\n                if ( cl != null && cl.length > 0 )\n                {\n                    StringBuffer sb = new StringBuffer();\n                    sb.append( cl[0] );\n                    for ( int i = 1; i < cl.length; i++ )\n                    {\n                        sb.append( \" \" );\n                        sb.append( cl[i] );\n                    }\n                    getLog().debug( \"Command line options:\" );\n                    getLog().debug( sb );\n                }\n            }\n            catch ( CompilerException ce )\n            {\n                getLog().debug( ce );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Compile!\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( compilerConfiguration.getSourceEncoding() ) )\n        {\n            getLog().warn(\n                           \"File encoding has not been set, using platform encoding \" + ReaderFactory.FILE_ENCODING\n                               + \", i.e. build is platform dependent!\" );\n        }\n\n        List messages;\n\n        try\n        {\n            messages = compiler.compile( compilerConfiguration );\n        }\n        catch ( Exception e )\n        {\n            // TODO: don't catch Exception\n            throw new MojoExecutionException( \"Fatal error compiling\", e );\n        }\n\n        boolean compilationError = false;\n\n        for ( Iterator i = messages.iterator(); i.hasNext(); )\n        {\n            CompilerError message = (CompilerError) i.next();\n\n            if ( message.isError() )\n            {\n                compilationError = true;\n                break;\n            }\n        }\n\n        if ( compilationError && failOnError )\n        {\n            getLog().info( \"-------------------------------------------------------------\" );\n            getLog().error( \"COMPILATION ERROR : \" );\n            getLog().info( \"-------------------------------------------------------------\" );\n            if ( messages != null )\n            {\n                for ( Iterator i = messages.iterator(); i.hasNext(); )\n                {\n                    CompilerError message = (CompilerError) i.next();\n\n                    getLog().error( message.toString() );\n\n                }\n                getLog().info( messages.size() + ( ( messages.size() > 1 ) ? \" errors \" : \"error\" ) );\n                getLog().info( \"-------------------------------------------------------------\" );\n            }\n            throw new CompilationFailureException( messages );\n        }\n        else\n        {\n            for ( Iterator i = messages.iterator(); i.hasNext(); )\n            {\n                CompilerError message = (CompilerError) i.next();\n\n                getLog().warn( message.toString() );\n            }\n        }\n    }","id":767,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    public void execute()\n        throws MojoExecutionException, CompilationFailureException\n    {\n        // ----------------------------------------------------------------------\n        // Look up the compiler. This is done before other code than can\n        // cause the mojo to return before the lookup is done possibly resulting\n        // in misconfigured POMs still building.\n        // ----------------------------------------------------------------------\n\n        Compiler compiler;\n\n        getLog().debug( \"Using compiler '\" + compilerId + \"'.\" );\n\n        try\n        {\n            compiler = compilerManager.getCompiler( compilerId );\n        }\n        catch ( NoSuchCompilerException e )\n        {\n            throw new MojoExecutionException( \"No such compiler '\" + e.getCompilerId() + \"'.\" );\n        }\n        \n        //-----------toolchains start here ----------------------------------\n        //use the compilerId as identifier for toolchains as well.\n        Toolchain tc = getToolchain();\n        if ( tc != null ) \n        {\n            getLog().info( \"Toolchain in compiler-plugin: \" + tc );\n            if ( executable  != null ) \n            { \n                getLog().warn( \"Toolchains are ignored, 'executable' parameter is set to \" + executable );\n            } \n            else \n            {\n                fork = true;\n                //TODO somehow shaky dependency between compilerId and tool executable.\n                executable = tc.findTool( compilerId );\n            }\n        }\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        List<String> compileSourceRoots = removeEmptyCompileSourceRoots( getCompileSourceRoots() );\n\n        if ( compileSourceRoots.isEmpty() )\n        {\n            getLog().info( \"No sources to compile\" );\n\n            return;\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Source directories: \" + compileSourceRoots.toString().replace( ',', '\\n' ) );\n            getLog().debug( \"Classpath: \" + getClasspathElements().toString().replace( ',', '\\n' ) );\n            getLog().debug( \"Output directory: \" + getOutputDirectory() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Create the compiler configuration\n        // ----------------------------------------------------------------------\n\n        CompilerConfiguration compilerConfiguration = new CompilerConfiguration();\n\n        compilerConfiguration.setOutputLocation( getOutputDirectory().getAbsolutePath() );\n\n        compilerConfiguration.setClasspathEntries( getClasspathElements() );\n\n        compilerConfiguration.setSourceLocations( compileSourceRoots );\n\n        compilerConfiguration.setOptimize( optimize );\n\n        compilerConfiguration.setDebug( debug );\n\n        if ( debug && StringUtils.isNotEmpty( debuglevel ) )\n        {\n            String[] split = StringUtils.split( debuglevel, \",\" );\n            for ( int i = 0; i < split.length; i++ )\n            {\n                if ( !( split[i].equalsIgnoreCase( \"none\" ) || split[i].equalsIgnoreCase( \"lines\" )\n                    || split[i].equalsIgnoreCase( \"vars\" ) || split[i].equalsIgnoreCase( \"source\" ) ) )\n                {\n                    throw new IllegalArgumentException( \"The specified debug level: '\" + split[i]\n                        + \"' is unsupported. \" + \"Legal values are 'none', 'lines', 'vars', and 'source'.\" );\n                }\n            }\n            compilerConfiguration.setDebugLevel( debuglevel );\n        }        \n        \n        compilerConfiguration.setVerbose( verbose );\n\n        compilerConfiguration.setShowWarnings( showWarnings );\n\n        compilerConfiguration.setShowDeprecation( showDeprecation );\n\n        compilerConfiguration.setSourceVersion( getSource() );\n\n        compilerConfiguration.setTargetVersion( getTarget() );\n\n        compilerConfiguration.setSourceEncoding( encoding );\n        \n        Map<String, String> effectiveCompilerArguments = getCompilerArguments();\n\n        String effectiveCompilerArgument = getCompilerArgument();\n\n        if ( ( effectiveCompilerArguments != null ) || ( effectiveCompilerArgument != null ) )\n        {\n            LinkedHashMap<String, String> cplrArgsCopy = new LinkedHashMap<String, String>();\n            if ( effectiveCompilerArguments != null )\n            {\n                for ( Map.Entry<String, String> me : effectiveCompilerArguments.entrySet() )\n                {\n                    String key = (String) me.getKey();\n                    String value = (String) me.getValue();\n                    if ( !key.startsWith( \"-\" ) )\n                    {\n                        key = \"-\" + key;\n                    }\n                    cplrArgsCopy.put( key, value );\n                }\n            }\n            if ( !StringUtils.isEmpty( effectiveCompilerArgument ) )\n            {\n                cplrArgsCopy.put( effectiveCompilerArgument, null );\n            }\n            compilerConfiguration.setCustomCompilerArguments( cplrArgsCopy );\n        }\n\n        compilerConfiguration.setFork( fork );\n\n        if ( fork )\n        {\n            if ( !StringUtils.isEmpty( meminitial ) )\n            {\n                String value = getMemoryValue( meminitial );\n\n                if ( value != null )\n                {\n                    compilerConfiguration.setMeminitial( value );\n                }\n                else\n                {\n                    getLog().info( \"Invalid value for meminitial '\" + meminitial + \"'. Ignoring this option.\" );\n                }\n            }\n\n            if ( !StringUtils.isEmpty( maxmem ) )\n            {\n                String value = getMemoryValue( maxmem );\n\n                if ( value != null )\n                {\n                    compilerConfiguration.setMaxmem( value );\n                }\n                else\n                {\n                    getLog().info( \"Invalid value for maxmem '\" + maxmem + \"'. Ignoring this option.\" );\n                }\n            }\n        }\n\n        compilerConfiguration.setExecutable( executable );\n\n        compilerConfiguration.setWorkingDirectory( basedir );\n\n        compilerConfiguration.setCompilerVersion( compilerVersion );\n\n        compilerConfiguration.setBuildDirectory( buildDirectory );\n\n        compilerConfiguration.setOutputFileName( outputFileName );\n\n        // TODO: have an option to always compile (without need to clean)\n        Set<File> staleSources;\n\n        boolean canUpdateTarget;\n\n        try\n        {\n            staleSources =\n                computeStaleSources( compilerConfiguration, compiler, getSourceInclusionScanner( staleMillis ) );\n\n            canUpdateTarget = compiler.canUpdateTarget( compilerConfiguration );\n\n            if ( compiler.getCompilerOutputStyle().equals( CompilerOutputStyle.ONE_OUTPUT_FILE_FOR_ALL_INPUT_FILES ) &&\n                !canUpdateTarget )\n            {\n                getLog().info( \"RESCANNING!\" );\n                // TODO: This second scan for source files is sub-optimal\n                String inputFileEnding = compiler.getInputFileEnding( compilerConfiguration );\n\n                Set<File> sources = computeStaleSources( compilerConfiguration, compiler,\n                                                   getSourceInclusionScanner( inputFileEnding ) );\n\n                compilerConfiguration.setSourceFiles( sources );\n            }\n            else\n            {\n                compilerConfiguration.setSourceFiles( staleSources );\n            }\n        }\n        catch ( CompilerException e )\n        {\n            throw new MojoExecutionException( \"Error while computing stale sources.\", e );\n        }\n\n        if ( staleSources.isEmpty() )\n        {\n            getLog().info( \"Nothing to compile - all classes are up to date\" );\n\n            return;\n        }\n\n        // ----------------------------------------------------------------------\n        // Dump configuration\n        // ----------------------------------------------------------------------\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"Classpath:\" );\n\n            for ( String s : getClasspathElements() )\n            {\n                getLog().debug( \" \" + s );\n            }\n\n            getLog().debug( \"Source roots:\" );\n\n            for ( String root : getCompileSourceRoots() )\n            {\n                getLog().debug( \" \" + root );\n            }\n\n            try\n            {\n                if ( fork )\n                {\n                    if ( compilerConfiguration.getExecutable() != null )\n                    {\n                        getLog().debug( \"Excutable: \" );\n                        getLog().debug( \" \" + compilerConfiguration.getExecutable() );\n                    }\n                }\n\n                String[] cl = compiler.createCommandLine( compilerConfiguration );\n                if ( cl != null && cl.length > 0 )\n                {\n                    StringBuffer sb = new StringBuffer();\n                    sb.append( cl[0] );\n                    for ( int i = 1; i < cl.length; i++ )\n                    {\n                        sb.append( \" \" );\n                        sb.append( cl[i] );\n                    }\n                    getLog().debug( \"Command line options:\" );\n                    getLog().debug( sb );\n                }\n            }\n            catch ( CompilerException ce )\n            {\n                getLog().debug( ce );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Compile!\n        // ----------------------------------------------------------------------\n\n        if ( StringUtils.isEmpty( compilerConfiguration.getSourceEncoding() ) )\n        {\n            getLog().warn(\n                           \"File encoding has not been set, using platform encoding \" + ReaderFactory.FILE_ENCODING\n                               + \", i.e. build is platform dependent!\" );\n        }\n\n        List<CompilerError> messages;\n\n        try\n        {\n            messages = compiler.compile( compilerConfiguration );\n        }\n        catch ( Exception e )\n        {\n            // TODO: don't catch Exception\n            throw new MojoExecutionException( \"Fatal error compiling\", e );\n        }\n\n        boolean compilationError = false;\n\n        if ( messages != null )\n        {\n            for ( CompilerError message : messages )\n            {\n                if ( message.isError() )\n                {\n                    compilationError = true;\n                    break;\n                }\n            }\n        }\n\n        if ( compilationError && failOnError )\n        {\n            getLog().info( \"-------------------------------------------------------------\" );\n            getLog().error( \"COMPILATION ERROR : \" );\n            getLog().info( \"-------------------------------------------------------------\" );\n            if ( messages != null )\n            {\n                for ( CompilerError message : messages )\n                {\n                    getLog().error( message.toString() );\n                }\n                getLog().info( messages.size() + ( ( messages.size() > 1 ) ? \" errors \" : \"error\" ) );\n                getLog().info( \"-------------------------------------------------------------\" );\n            }\n            throw new CompilationFailureException( messages );\n        }\n        else\n        {\n            for ( CompilerError message : messages )\n            {\n                getLog().warn( message.toString() );\n            }\n        }\n    }","commit_id":"4045f68a0a1367d37af8003e6fdc5f7428ca5b5b","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Set computeStaleSources( CompilerConfiguration compilerConfiguration, Compiler compiler,\n                                     SourceInclusionScanner scanner )\n        throws MojoExecutionException, CompilerException\n    {\n        CompilerOutputStyle outputStyle = compiler.getCompilerOutputStyle();\n\n        SourceMapping mapping;\n\n        File outputDirectory;\n\n        if ( outputStyle == CompilerOutputStyle.ONE_OUTPUT_FILE_PER_INPUT_FILE )\n        {\n            mapping = new SuffixMapping( compiler.getInputFileEnding( compilerConfiguration ), compiler\n                .getOutputFileEnding( compilerConfiguration ) );\n\n            outputDirectory = getOutputDirectory();\n        }\n        else if ( outputStyle == CompilerOutputStyle.ONE_OUTPUT_FILE_FOR_ALL_INPUT_FILES )\n        {\n            mapping = new SingleTargetSourceMapping( compiler.getInputFileEnding( compilerConfiguration ), compiler\n                .getOutputFile( compilerConfiguration ) );\n\n            outputDirectory = buildDirectory;\n        }\n        else\n        {\n            throw new MojoExecutionException( \"Unknown compiler output style: '\" + outputStyle + \"'.\" );\n        }\n\n        scanner.addSourceMapping( mapping );\n\n        Set staleSources = new HashSet();\n\n        for ( Iterator it = getCompileSourceRoots().iterator(); it.hasNext(); )\n        {\n            String sourceRoot = (String) it.next();\n\n            File rootFile = new File( sourceRoot );\n\n            if ( !rootFile.isDirectory() )\n            {\n                continue;\n            }\n\n            try\n            {\n                staleSources.addAll( scanner.getIncludedSources( rootFile, outputDirectory ) );\n            }\n            catch ( InclusionScanException e )\n            {\n                throw new MojoExecutionException(\n                    \"Error scanning source root: \\'\" + sourceRoot + \"\\' \" + \"for stale files to recompile.\", e );\n            }\n        }\n\n        return staleSources;\n    }","id":768,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    private Set<File> computeStaleSources( CompilerConfiguration compilerConfiguration, Compiler compiler,\n                                     SourceInclusionScanner scanner )\n        throws MojoExecutionException, CompilerException\n    {\n        CompilerOutputStyle outputStyle = compiler.getCompilerOutputStyle();\n\n        SourceMapping mapping;\n\n        File outputDirectory;\n\n        if ( outputStyle == CompilerOutputStyle.ONE_OUTPUT_FILE_PER_INPUT_FILE )\n        {\n            mapping = new SuffixMapping( compiler.getInputFileEnding( compilerConfiguration ), compiler\n                .getOutputFileEnding( compilerConfiguration ) );\n\n            outputDirectory = getOutputDirectory();\n        }\n        else if ( outputStyle == CompilerOutputStyle.ONE_OUTPUT_FILE_FOR_ALL_INPUT_FILES )\n        {\n            mapping = new SingleTargetSourceMapping( compiler.getInputFileEnding( compilerConfiguration ), compiler\n                .getOutputFile( compilerConfiguration ) );\n\n            outputDirectory = buildDirectory;\n        }\n        else\n        {\n            throw new MojoExecutionException( \"Unknown compiler output style: '\" + outputStyle + \"'.\" );\n        }\n\n        scanner.addSourceMapping( mapping );\n\n        Set<File> staleSources = new HashSet<File>();\n\n        for ( String sourceRoot : getCompileSourceRoots() )\n        {\n            File rootFile = new File( sourceRoot );\n\n            if ( !rootFile.isDirectory() )\n            {\n                continue;\n            }\n\n            try\n            {\n                staleSources.addAll( scanner.getIncludedSources( rootFile, outputDirectory ) );\n            }\n            catch ( InclusionScanException e )\n            {\n                throw new MojoExecutionException(\n                    \"Error scanning source root: \\'\" + sourceRoot + \"\\' \" + \"for stale files to recompile.\", e );\n            }\n        }\n\n        return staleSources;\n    }","commit_id":"4045f68a0a1367d37af8003e6fdc5f7428ca5b5b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @todo also in ant plugin. This should be resolved at some point so that it does not need to\n     * be calculated continuously - or should the plugins accept empty source roots as is?\n     */\n    private static List removeEmptyCompileSourceRoots( List compileSourceRootsList )\n    {\n        List newCompileSourceRootsList = new ArrayList();\n        if ( compileSourceRootsList != null )\n        {\n            // copy as I may be modifying it\n            for ( Iterator i = compileSourceRootsList.iterator(); i.hasNext(); )\n            {\n                String srcDir = (String) i.next();\n                if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() )\n                {\n                    newCompileSourceRootsList.add( srcDir );\n                }\n            }\n        }\n        return newCompileSourceRootsList;\n    }","id":769,"modified_method":"/**\n     * @todo also in ant plugin. This should be resolved at some point so that it does not need to\n     * be calculated continuously - or should the plugins accept empty source roots as is?\n     */\n    private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList )\n    {\n        List<String> newCompileSourceRootsList = new ArrayList<String>();\n        if ( compileSourceRootsList != null )\n        {\n            // copy as I may be modifying it\n            for ( String srcDir : compileSourceRootsList )\n            {\n                if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() )\n                {\n                    newCompileSourceRootsList.add( srcDir );\n                }\n            }\n        }\n        return newCompileSourceRootsList;\n    }","commit_id":"4045f68a0a1367d37af8003e6fdc5f7428ca5b5b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public CompilationFailureException( List messages )\n    {\n        super( null, shortMessage( messages ), longMessage( messages ) );\n    }","id":770,"modified_method":"public CompilationFailureException( List<CompilerError> messages )\n    {\n        super( null, shortMessage( messages ), longMessage( messages ) );\n    }","commit_id":"4045f68a0a1367d37af8003e6fdc5f7428ca5b5b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static String longMessage( List messages )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        for ( Iterator it = messages.iterator(); it.hasNext(); )\n        {\n            CompilerError compilerError = (CompilerError) it.next();\n\n            sb.append( compilerError ).append( LS );\n        }\n        return sb.toString();\n    }","id":771,"modified_method":"public static String longMessage( List<CompilerError> messages )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        if ( messages != null )\n        {\n            for ( CompilerError compilerError : messages )\n            {\n                sb.append( compilerError ).append( LS );\n            }\n        }\n        return sb.toString();\n    }","commit_id":"4045f68a0a1367d37af8003e6fdc5f7428ca5b5b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Short message will have the error message if there's only one, useful for errors forking the compiler\n     *\n     * @param messages\n     * @return the short error message\n     * @since 2.0.2\n     */\n    public static String shortMessage( List messages )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"Compilation failure\" );\n\n        if ( messages.size() == 1 )\n        {\n            sb.append( LS );\n\n            CompilerError compilerError = (CompilerError) messages.get( 0 );\n\n            sb.append( compilerError ).append( LS );\n        }\n        \n        return sb.toString();\n    }","id":772,"modified_method":"/**\n     * Short message will have the error message if there's only one, useful for errors forking the compiler\n     *\n     * @param messages\n     * @return the short error message\n     * @since 2.0.2\n     */\n    public static String shortMessage( List<CompilerError> messages )\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append( \"Compilation failure\" );\n\n        if ( messages.size() == 1 )\n        {\n            sb.append( LS );\n\n            CompilerError compilerError = (CompilerError) messages.get( 0 );\n\n            sb.append( compilerError ).append( LS );\n        }\n        \n        return sb.toString();\n    }","commit_id":"4045f68a0a1367d37af8003e6fdc5f7428ca5b5b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method to get the list of files where the PMD tool will be executed\n     *\n     * @return a List of the files where the PMD tool will be executed\n     * @throws java.io.IOException\n     */\n    protected Map getFilesToProcess()\n        throws IOException\n    {\n        String sourceXref = constructXRefLocation( false );\n        String testXref = includeTests ? constructXRefLocation( true ) : \"\";\n\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return Collections.EMPTY_MAP;\n        }\n\n        if ( excludeRoots == null )\n        {\n            excludeRoots = new File[0];\n        }\n        Collection<File> excludeRootFiles = new HashSet<File>( excludeRoots.length );\n\n        for ( int i = 0; i < excludeRoots.length; i++ )\n        {\n            File file = excludeRoots[i];\n            if ( file.isDirectory() )\n            {\n                excludeRootFiles.add( file );\n            }\n        }\n\n        List<PmdFileInfo> directories = new ArrayList<PmdFileInfo>();\n\n        if ( compileSourceRoots != null )\n        {\n\n            for ( Iterator i = compileSourceRoots.iterator(); i.hasNext(); )\n            {\n                String root = (String) i.next();\n                File sroot = new File( root );\n                directories.add( new PmdFileInfo( project, sroot, sourceXref ) );\n            }\n\n        }\n        if ( includeTests )\n        {\n            if ( testSourceRoots != null )\n            {\n                for ( Iterator i = testSourceRoots.iterator(); i.hasNext(); )\n                {\n                    String root = (String) i.next();\n                    File sroot = new File( root );\n                    directories.add( new PmdFileInfo( project, sroot, testXref ) );\n                }\n            }\n        }\n        if ( aggregate )\n        {\n            for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n            {\n                MavenProject localProject = (MavenProject) i.next();\n                for ( Iterator i2 = localProject.getCompileSourceRoots().iterator(); i2.hasNext(); )\n                {\n                    String root = (String) i2.next();\n                    File sroot = new File( root );\n                    directories.add( new PmdFileInfo( localProject, sroot, sourceXref ) );\n                }\n                if ( includeTests )\n                {\n                    for ( Iterator i2 = localProject.getTestCompileSourceRoots().iterator(); i2.hasNext(); )\n                    {\n                        String root = (String) i2.next();\n                        File sroot = new File( root );\n                        directories.add( new PmdFileInfo( localProject, sroot, testXref ) );\n                    }\n                }\n            }\n\n        }\n\n        String excluding = getExcludes();\n        getLog().debug( \"Exclusions: \" + excluding );\n        String including = getIncludes();\n        getLog().debug( \"Inclusions: \" + including );\n\n        Map files = new TreeMap();\n\n        for ( PmdFileInfo finfo : directories )\n        {\n            File sourceDirectory = finfo.getSourceDirectory();\n            if ( sourceDirectory.isDirectory() && !excludeRootFiles.contains( sourceDirectory ) )\n            {\n                List newfiles = FileUtils.getFiles( sourceDirectory, including, excluding );\n                for ( Iterator it2 = newfiles.iterator(); it2.hasNext(); )\n                {\n                    files.put( it2.next(), finfo );\n                }\n            }\n        }\n\n        return files;\n    }","id":773,"modified_method":"/**\n     * Convenience method to get the list of files where the PMD tool will be executed\n     *\n     * @return a List of the files where the PMD tool will be executed\n     * @throws java.io.IOException\n     */\n    protected Map<File, PmdFileInfo> getFilesToProcess()\n        throws IOException\n    {\n        String sourceXref = constructXRefLocation( false );\n        String testXref = includeTests ? constructXRefLocation( true ) : \"\";\n\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return Collections.emptyMap();\n        }\n\n        if ( excludeRoots == null )\n        {\n            excludeRoots = Collections.emptyList();\n        }\n        \n        Collection<File> excludeRootFiles = new HashSet<File>( excludeRoots.size() );\n\n        for ( File file : excludeRoots )\n        {\n            if ( file.isDirectory() )\n            {\n                excludeRootFiles.add( file );\n            }\n        }\n\n        List<PmdFileInfo> directories = new ArrayList<PmdFileInfo>();\n\n        if ( compileSourceRoots != null )\n        {\n\n            for ( String root : compileSourceRoots )\n            {\n                File sroot = new File( root );\n                directories.add( new PmdFileInfo( project, sroot, sourceXref ) );\n            }\n\n        }\n        if ( includeTests )\n        {\n            if ( testSourceRoots != null )\n            {\n                for ( String root : testSourceRoots )\n                {\n                    File sroot = new File( root );\n                    directories.add( new PmdFileInfo( project, sroot, testXref ) );\n                }\n            }\n        }\n        if ( aggregate )\n        {\n            for ( MavenProject localProject : reactorProjects )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<String> localCompileSourceRoots = localProject.getCompileSourceRoots(); \n                for ( String root : localCompileSourceRoots )\n                {\n                    File sroot = new File( root );\n                    directories.add( new PmdFileInfo( localProject, sroot, sourceXref ) );\n                }\n                if ( includeTests )\n                {\n                    @SuppressWarnings( \"unchecked\" )\n                    List<String> localTestCompileSourceRoots = localProject.getTestCompileSourceRoots(); \n                    for ( String root : localTestCompileSourceRoots )\n                    {\n                        File sroot = new File( root );\n                        directories.add( new PmdFileInfo( localProject, sroot, testXref ) );\n                    }\n                }\n            }\n\n        }\n\n        String excluding = getExcludes();\n        getLog().debug( \"Exclusions: \" + excluding );\n        String including = getIncludes();\n        getLog().debug( \"Inclusions: \" + including );\n\n        Map<File, PmdFileInfo> files = new TreeMap<File, PmdFileInfo>();\n\n        for ( PmdFileInfo finfo : directories )\n        {\n            File sourceDirectory = finfo.getSourceDirectory();\n            if ( sourceDirectory.isDirectory() && !excludeRootFiles.contains( sourceDirectory ) )\n            {\n                @SuppressWarnings( \"unchecked\" )\n                List<File> newfiles = FileUtils.getFiles( sourceDirectory, including, excluding );\n                for ( Iterator<File> it2 = newfiles.iterator(); it2.hasNext(); )\n                {\n                    files.put( it2.next(), finfo );\n                }\n            }\n        }\n\n        return files;\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Gets the comma separated list of effective include patterns.\n     *\n     * @return The comma separated list of effective include patterns, never <code>null<\/code>.\n     */\n    private String getIncludes()\n    {\n        Collection<String> patterns = new LinkedHashSet<String>();\n        if ( includes != null )\n        {\n            patterns.addAll( Arrays.asList( includes ) );\n        }\n        if ( patterns.isEmpty() )\n        {\n            patterns.add( \"**/*.java\" );\n        }\n        return StringUtils.join( patterns.iterator(), \",\" );\n    }","id":774,"modified_method":"/**\n     * Gets the comma separated list of effective include patterns.\n     *\n     * @return The comma separated list of effective include patterns, never <code>null<\/code>.\n     */\n    private String getIncludes()\n    {\n        Collection<String> patterns = new LinkedHashSet<String>();\n        if ( includes != null )\n        {\n            patterns.addAll( includes );\n        }\n        if ( patterns.isEmpty() )\n        {\n            patterns.add( \"**/*.java\" );\n        }\n        return StringUtils.join( patterns.iterator(), \",\" );\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected String constructXRefLocation( boolean test )\n    {\n        String location = null;\n        if ( linkXRef )\n        {\n            File xrefLoc = test ? xrefTestLocation : xrefLocation;\n\n            String relativePath = PathTool.getRelativePath( outputDirectory.getAbsolutePath(),\n                                                            xrefLoc.getAbsolutePath() );\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \".\";\n            }\n            relativePath = relativePath + \"/\" + xrefLoc.getName();\n            if ( xrefLoc.exists() )\n            {\n                // XRef was already generated by manual execution of a lifecycle binding\n                location = relativePath;\n            }\n            else\n            {\n                // Not yet generated - check if the report is on its way\n                for ( Iterator reports = project.getReportPlugins().iterator(); reports.hasNext(); )\n                {\n                    ReportPlugin plugin = (ReportPlugin) reports.next();\n\n                    String artifactId = plugin.getArtifactId();\n                    if ( \"maven-jxr-plugin\".equals( artifactId ) || \"jxr-maven-plugin\".equals( artifactId ) )\n                    {\n                        location = relativePath;\n                    }\n                }\n            }\n\n            if ( location == null )\n            {\n                getLog().warn( \"Unable to locate Source XRef to link to - DISABLED\" );\n            }\n        }\n        return location;\n    }","id":775,"modified_method":"protected String constructXRefLocation( boolean test )\n    {\n        String location = null;\n        if ( linkXRef )\n        {\n            File xrefLoc = test ? xrefTestLocation : xrefLocation;\n\n            String relativePath = PathTool.getRelativePath( outputDirectory.getAbsolutePath(),\n                                                            xrefLoc.getAbsolutePath() );\n            if ( StringUtils.isEmpty( relativePath ) )\n            {\n                relativePath = \".\";\n            }\n            relativePath = relativePath + \"/\" + xrefLoc.getName();\n            if ( xrefLoc.exists() )\n            {\n                // XRef was already generated by manual execution of a lifecycle binding\n                location = relativePath;\n            }\n            else\n            {\n                // Not yet generated - check if the report is on its way\n                @SuppressWarnings( \"unchecked\" )\n                List<ReportPlugin> reportPlugins = project.getReportPlugins();\n                for ( ReportPlugin plugin  : reportPlugins )\n                {\n                    String artifactId = plugin.getArtifactId();\n                    if ( \"maven-jxr-plugin\".equals( artifactId ) || \"jxr-maven-plugin\".equals( artifactId ) )\n                    {\n                        location = relativePath;\n                    }\n                }\n            }\n\n            if ( location == null )\n            {\n                getLog().warn( \"Unable to locate Source XRef to link to - DISABLED\" );\n            }\n        }\n        return location;\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public boolean canGenerateReport()\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return false;\n        }\n\n        if ( \"pom\".equals( project.getPackaging() ) && !aggregate )\n        {\n            return false;\n        }\n\n        // if format is XML, we need to output it even if the file list is empty\n        // so the \"check\" goals can check for failures\n        if ( \"xml\".equals( format ) )\n        {\n            return true;\n        }\n        try\n        {\n            Map filesToProcess = getFilesToProcess();\n            if ( filesToProcess.isEmpty() )\n            {\n                return false;\n            }\n        }\n        catch ( IOException e )\n        {\n            getLog().error( e );\n        }\n        return true;\n    }","id":776,"modified_method":"/** {@inheritDoc} */\n    public boolean canGenerateReport()\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return false;\n        }\n\n        if ( \"pom\".equals( project.getPackaging() ) && !aggregate )\n        {\n            return false;\n        }\n\n        // if format is XML, we need to output it even if the file list is empty\n        // so the \"check\" goals can check for failures\n        if ( \"xml\".equals( format ) )\n        {\n            return true;\n        }\n        try\n        {\n            Map<File, PmdFileInfo> filesToProcess = getFilesToProcess();\n            if ( filesToProcess.isEmpty() )\n            {\n                return false;\n            }\n        }\n        catch ( IOException e )\n        {\n            getLog().error( e );\n        }\n        return true;\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Gets the comma separated list of effective exclude patterns.\n     *\n     * @return The comma separated list of effective exclude patterns, never <code>null<\/code>.\n     */\n    private String getExcludes()\n    {\n        Collection patterns = new LinkedHashSet( FileUtils.getDefaultExcludesAsList() );\n        if ( excludes != null )\n        {\n            patterns.addAll( Arrays.asList( excludes ) );\n        }\n        return StringUtils.join( patterns.iterator(), \",\" );\n    }","id":777,"modified_method":"/**\n     * Gets the comma separated list of effective exclude patterns.\n     *\n     * @return The comma separated list of effective exclude patterns, never <code>null<\/code>.\n     */\n    private String getExcludes()\n    {\n        @SuppressWarnings( \"unchecked\" )\n        Collection<String> patterns = new LinkedHashSet<String>( FileUtils.getDefaultExcludesAsList() );\n        if ( excludes != null )\n        {\n            patterns.addAll( excludes );\n        }\n        return StringUtils.join( patterns.iterator(), \",\" );\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method for collecting the violations found by the PMD tool\n     *\n     * @param xpp\n     *            the xml parser object\n     * @param tagName\n     *            the element that will be checked\n     * @return an int that specifies the number of violations found\n     * @throws XmlPullParserException\n     * @throws IOException\n     */\n    private Map getViolations( XmlPullParser xpp, String tagName, int failurePriority )\n        throws XmlPullParserException, IOException\n    {\n        int eventType = xpp.getEventType();\n\n        List failures = new ArrayList();\n        List warnings = new ArrayList();\n\n        String fullpath = null;\n\n        while ( eventType != XmlPullParser.END_DOCUMENT )\n        {\n            if ( eventType == XmlPullParser.START_TAG && \"file\".equals( xpp.getName() ) )\n            {\n                fullpath = xpp.getAttributeValue( \"\", \"name\" );\n            }\n            if ( eventType == XmlPullParser.START_TAG && tagName.equals( xpp.getName() ) )\n            {\n                Map details = getErrorDetails( xpp );\n\n                if ( fullpath != null )\n                {\n                    details.put( \"filename\", getFilename( fullpath, (String) details.get( \"package\" ) ) );\n                }\n\n                try\n                {\n                    int priority = Integer.parseInt( (String) details.get( \"priority\" ) );\n                    if ( priority <= failurePriority )\n                    {\n                        failures.add( details );\n                    }\n                    else\n                    {\n                        warnings.add( details );\n                    }\n                }\n                catch ( NumberFormatException e )\n                {\n                    // I don't know what priority this is. Treat it like a\n                    // failure\n                    failures.add( details );\n                }\n                catch ( NullPointerException e )\n                {\n                    // I don't know what priority this is. Treat it like a\n                    // failure\n                    failures.add( details );\n                }\n\n            }\n\n            eventType = xpp.next();\n        }\n\n        HashMap map = new HashMap( 2 );\n        map.put( FAILURES_KEY, failures );\n        map.put( WARNINGS_KEY, warnings );\n        return map;\n    }","id":778,"modified_method":"/**\n     * Method for collecting the violations found by the PMD tool\n     *\n     * @param xpp\n     *            the xml parser object\n     * @param tagName\n     *            the element that will be checked\n     * @return an int that specifies the number of violations found\n     * @throws XmlPullParserException\n     * @throws IOException\n     */\n    private Map<Boolean, List<Map<String, String>>> getViolations( XmlPullParser xpp, String tagName, int failurePriority )\n        throws XmlPullParserException, IOException\n    {\n        int eventType = xpp.getEventType();\n\n        List<Map<String, String>> failures = new ArrayList<Map<String, String>>();\n        List<Map<String, String>> warnings = new ArrayList<Map<String, String>>();\n\n        String fullpath = null;\n\n        while ( eventType != XmlPullParser.END_DOCUMENT )\n        {\n            if ( eventType == XmlPullParser.START_TAG && \"file\".equals( xpp.getName() ) )\n            {\n                fullpath = xpp.getAttributeValue( \"\", \"name\" );\n            }\n            if ( eventType == XmlPullParser.START_TAG && tagName.equals( xpp.getName() ) )\n            {\n                Map<String, String> details = getErrorDetails( xpp );\n\n                if ( fullpath != null )\n                {\n                    details.put( \"filename\", getFilename( fullpath, details.get( \"package\" ) ) );\n                }\n\n                try\n                {\n                    int priority = Integer.parseInt( details.get( \"priority\" ) );\n                    if ( priority <= failurePriority )\n                    {\n                        failures.add( details );\n                    }\n                    else\n                    {\n                        warnings.add( details );\n                    }\n                }\n                catch ( NumberFormatException e )\n                {\n                    // I don't know what priority this is. Treat it like a\n                    // failure\n                    failures.add( details );\n                }\n                catch ( NullPointerException e )\n                {\n                    // I don't know what priority this is. Treat it like a\n                    // failure\n                    failures.add( details );\n                }\n\n            }\n\n            eventType = xpp.next();\n        }\n\n        Map<Boolean, List<Map<String, String>>> map = new HashMap<Boolean, List<Map<String, String>>>( 2 );\n        map.put( FAILURES_KEY, failures );\n        map.put( WARNINGS_KEY, warnings );\n        return map;\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Formats the failure details and prints them as an INFO message\n     *\n     * @param item\n     */\n    protected abstract void printError( Map item, String severity );","id":779,"modified_method":"/**\n     * Formats the failure details and prints them as an INFO message\n     *\n     * @param item\n     */\n    protected abstract void printError( Map<String, String> item, String severity );","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Prints the warnings and failures\n     *\n     * @param failures\n     *            list of failures\n     * @param warnings\n     *            list of warnings\n     */\n    protected void printErrors( List failures, List warnings )\n    {\n        Iterator iter = warnings.iterator();\n        while ( iter.hasNext() )\n        {\n            printError( (Map) iter.next(), \"Warning\" );\n        }\n\n        iter = failures.iterator();\n        while ( iter.hasNext() )\n        {\n            printError( (Map) iter.next(), \"Failure\" );\n        }\n    }","id":780,"modified_method":"/**\n     * Prints the warnings and failures\n     *\n     * @param failures\n     *            list of failures\n     * @param warnings\n     *            list of warnings\n     */\n    protected void printErrors( List<Map<String, String>> failures, List<Map<String, String>> warnings )\n    {\n        for ( Map<String, String> warning :  warnings )\n        {\n            printError( warning, \"Warning\" );\n        }\n\n        for ( Map<String, String> failure : failures )\n        {\n            printError( failure, \"Failure\" );\n        }\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void executeCheck( String filename, String tagName, String key, int failurePriority )\n        throws MojoFailureException, MojoExecutionException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        if ( \"java\".equals( language ) || aggregate )\n        {\n            File outputFile = new File( targetDirectory, filename );\n\n            if ( outputFile.exists() )\n            {\n                Reader reader = null;\n                try\n                {\n                    XmlPullParser xpp = new MXParser();\n                    reader = ReaderFactory.newXmlReader( outputFile );\n                    xpp.setInput( reader );\n\n                    Map violations = getViolations( xpp, tagName, failurePriority );\n\n                    List failures = (List) violations.get( FAILURES_KEY );\n                    List warnings = (List) violations.get( WARNINGS_KEY );\n\n                    if ( verbose )\n                    {\n                        printErrors( failures, warnings );\n                    }\n\n                    int failureCount = failures.size();\n                    int warningCount = warnings.size();\n\n                    String message = getMessage( failureCount, warningCount, key, outputFile );\n\n                    if ( failureCount > 0 && failOnViolation )\n                    {\n                        throw new MojoFailureException( message );\n                    }\n\n                    this.getLog().info( message );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException(\n                                                      \"Unable to read PMD results xml: \" + outputFile.getAbsolutePath(),\n                                                      e );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException(\n                                                      \"Unable to read PMD results xml: \" + outputFile.getAbsolutePath(),\n                                                      e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n            }\n            else\n            {\n                throw new MojoFailureException( \"Unable to perform check, \" + \"unable to find \" + outputFile );\n            }\n        }\n    }","id":781,"modified_method":"protected void executeCheck( String filename, String tagName, String key, int failurePriority )\n        throws MojoFailureException, MojoExecutionException\n    {\n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return;\n        }\n\n        if ( \"java\".equals( language ) || aggregate )\n        {\n            File outputFile = new File( targetDirectory, filename );\n\n            if ( outputFile.exists() )\n            {\n                Reader reader = null;\n                try\n                {\n                    XmlPullParser xpp = new MXParser();\n                    reader = ReaderFactory.newXmlReader( outputFile );\n                    xpp.setInput( reader );\n\n                    Map<Boolean, List<Map<String, String>>> violations = getViolations( xpp, tagName, failurePriority );\n\n                    List<Map<String, String>> failures = violations.get( FAILURES_KEY );\n                    List<Map<String, String>> warnings = violations.get( WARNINGS_KEY );\n\n                    if ( verbose )\n                    {\n                        printErrors( failures, warnings );\n                    }\n\n                    int failureCount = failures.size();\n                    int warningCount = warnings.size();\n\n                    String message = getMessage( failureCount, warningCount, key, outputFile );\n\n                    if ( failureCount > 0 && failOnViolation )\n                    {\n                        throw new MojoFailureException( message );\n                    }\n\n                    this.getLog().info( message );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException(\n                                                      \"Unable to read PMD results xml: \" + outputFile.getAbsolutePath(),\n                                                      e );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException(\n                                                      \"Unable to read PMD results xml: \" + outputFile.getAbsolutePath(),\n                                                      e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n            }\n            else\n            {\n                throw new MojoFailureException( \"Unable to perform check, \" + \"unable to find \" + outputFile );\n            }\n        }\n    }","commit_id":"7da5135987a31783083436a80de8c2b5b6a03b29","url":"https://github.com/apache/maven-plugins"},{"original_method":"private PsiMethod createHashCode() throws IncorrectOperationException {\n    @NonNls StringBuilder buffer = new StringBuilder();\n\n    if (shouldAddOverrideAnnotation(myClass)) {\n      buffer.append(\"@Override\\n\");\n    }\n\n    final HashMap<String, Object> contextMap = new HashMap<String, Object>();\n    contextMap.put(\"superHasHashCode\", mySuperHasHashCode);\n\n    final String methodText = GenerationUtil\n      .velocityGenerateCode(myClass, Arrays.asList(myHashCodeFields), myNonNullSet, new HashMap<String, String>(), contextMap, \n                            EqualsHashCodeTemplatesManager.getInstance().getDefaultHashcodeTemplate().getTemplate(), 0, false);\n    buffer.append(methodText);\n    PsiMethod hashCode = myFactory.createMethodFromText(buffer.toString(), null);\n    hashCode = (PsiMethod)myJavaCodeStyleManager.shortenClassReferences(hashCode);\n    return (PsiMethod)myCodeStyleManager.reformat(hashCode);\n  }","id":782,"modified_method":"private PsiMethod createHashCode() throws IncorrectOperationException {\n    @NonNls StringBuilder buffer = new StringBuilder();\n\n    if (shouldAddOverrideAnnotation(myClass)) {\n      buffer.append(\"@Override\\n\");\n    }\n\n    final HashMap<String, Object> contextMap = new HashMap<String, Object>();\n    contextMap.put(\"superHasHashCode\", mySuperHasHashCode);\n\n    final String methodText = GenerationUtil\n      .velocityGenerateCode(myClass, Arrays.asList(myHashCodeFields), myNonNullSet, new HashMap<String, String>(), contextMap, \n                            EqualsHashCodeTemplatesManager.getInstance().getDefaultHashcodeTemplate().getTemplate(), 0, false);\n    buffer.append(methodText);\n    PsiMethod hashCode;\n    try {\n      hashCode = myFactory.createMethodFromText(buffer.toString(), null);\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n    hashCode = (PsiMethod)myJavaCodeStyleManager.shortenClassReferences(hashCode);\n    return (PsiMethod)myCodeStyleManager.reformat(hashCode);\n  }","commit_id":"958d48c84d8145dacfb62de95b05faf59a2e60f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiMethod createEquals() throws IncorrectOperationException {\n    @NonNls StringBuilder buffer = new StringBuilder();\n    CodeStyleSettings styleSettings = CodeStyleSettingsManager.getSettings(myProject);\n    if (shouldAddOverrideAnnotation(myClass)) {\n      buffer.append(\"@Override\\n\");\n    }\n    ArrayList<PsiField> equalsFields = new ArrayList<PsiField>();\n    ContainerUtil.addAll(equalsFields, myEqualsFields);\n    Collections.sort(equalsFields, EqualsFieldsComparator.INSTANCE);\n\n    final HashMap<String, Object> contextMap = new HashMap<String, Object>();\n\n    final PsiType classType = JavaPsiFacade.getElementFactory(myClass.getProject()).createType(myClass);\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(myClass.getProject());\n    String[] nameSuggestions = codeStyleManager\n      .suggestVariableName(VariableKind.LOCAL_VARIABLE, null, null, classType).names;\n    String instanceBaseName = nameSuggestions.length > 0 && nameSuggestions[0].length() < 10 ? nameSuggestions[0] : \"that\";\n    contextMap.put(\"instanceName\", instanceBaseName);\n\n    final PsiType objectType = PsiType.getJavaLangObject(myClass.getManager(), myClass.getResolveScope());\n    nameSuggestions = codeStyleManager.suggestVariableName(VariableKind.PARAMETER, null, null, objectType).names;\n    final String objectBaseName = nameSuggestions.length > 0 ? nameSuggestions[0] : \"object\";\n    contextMap.put(\"baseParamName\", objectBaseName);\n    contextMap.put(\"superHasEquals\", superMethodExists(getEqualsSignature(myProject, myClass.getResolveScope())));\n    contextMap.put(\"checkParameterWithInstanceof\", myCheckParameterWithInstanceof);\n\n    final String methodText = GenerationUtil\n      .velocityGenerateCode(myClass, equalsFields, myNonNullSet, new HashMap<String, String>(), contextMap,\n                            EqualsHashCodeTemplatesManager.getInstance().getDefaultEqualsTemplate().getTemplate(), 0, false);\n    buffer.append(methodText);\n    PsiMethod result = myFactory.createMethodFromText(buffer.toString(), myClass);\n    final PsiParameter parameter = result.getParameterList().getParameters()[0];\n    PsiUtil.setModifierProperty(parameter, PsiModifier.FINAL, styleSettings.GENERATE_FINAL_PARAMETERS);\n\n    PsiMethod method = (PsiMethod)myCodeStyleManager.reformat(result);\n    method = (PsiMethod)myJavaCodeStyleManager.shortenClassReferences(method);\n    return method;\n  }","id":783,"modified_method":"private PsiMethod createEquals() throws IncorrectOperationException {\n    @NonNls StringBuilder buffer = new StringBuilder();\n    CodeStyleSettings styleSettings = CodeStyleSettingsManager.getSettings(myProject);\n    if (shouldAddOverrideAnnotation(myClass)) {\n      buffer.append(\"@Override\\n\");\n    }\n    ArrayList<PsiField> equalsFields = new ArrayList<PsiField>();\n    ContainerUtil.addAll(equalsFields, myEqualsFields);\n    Collections.sort(equalsFields, EqualsFieldsComparator.INSTANCE);\n\n    final HashMap<String, Object> contextMap = new HashMap<String, Object>();\n\n    final PsiType classType = JavaPsiFacade.getElementFactory(myClass.getProject()).createType(myClass);\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(myClass.getProject());\n    String[] nameSuggestions = codeStyleManager\n      .suggestVariableName(VariableKind.LOCAL_VARIABLE, null, null, classType).names;\n    String instanceBaseName = nameSuggestions.length > 0 && nameSuggestions[0].length() < 10 ? nameSuggestions[0] : \"that\";\n    contextMap.put(\"instanceName\", instanceBaseName);\n\n    final PsiType objectType = PsiType.getJavaLangObject(myClass.getManager(), myClass.getResolveScope());\n    nameSuggestions = codeStyleManager.suggestVariableName(VariableKind.PARAMETER, null, null, objectType).names;\n    final String objectBaseName = nameSuggestions.length > 0 ? nameSuggestions[0] : \"object\";\n    contextMap.put(\"baseParamName\", objectBaseName);\n    contextMap.put(\"superHasEquals\", superMethodExists(getEqualsSignature(myProject, myClass.getResolveScope())));\n    contextMap.put(\"checkParameterWithInstanceof\", myCheckParameterWithInstanceof);\n\n    final String methodText = GenerationUtil\n      .velocityGenerateCode(myClass, equalsFields, myNonNullSet, new HashMap<String, String>(), contextMap,\n                            EqualsHashCodeTemplatesManager.getInstance().getDefaultEqualsTemplate().getTemplate(), 0, false);\n    buffer.append(methodText);\n    PsiMethod result;\n    try {\n      result = myFactory.createMethodFromText(buffer.toString(), myClass);\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n    final PsiParameter[] parameters = result.getParameterList().getParameters();\n    if (parameters.length != 1) return null;\n    final PsiParameter parameter = parameters[0];\n    PsiUtil.setModifierProperty(parameter, PsiModifier.FINAL, styleSettings.GENERATE_FINAL_PARAMETERS);\n\n    PsiMethod method = (PsiMethod)myCodeStyleManager.reformat(result);\n    method = (PsiMethod)myJavaCodeStyleManager.shortenClassReferences(method);\n    return method;\n  }","commit_id":"958d48c84d8145dacfb62de95b05faf59a2e60f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Used by Form to tell the FormComponent that a new user input is available\n\t */\n\tpublic final void inputChanged()\n\t{\n\t\tif (isVisibleInHierarchy() && isEnabled())\n\t\t{\n\t\t\t// Get input as String array\n\t\t\tfinal String[] input = getInputAsArray();\n\n\t\t\t// If there is any input\n\t\t\tif (input != null)\n\t\t\t{\n\t\t\t\t// join the values together with \";\", for example, \"id1;id2;id3\"\n\t\t\t\trawInput = StringList.valueOf(input).join(VALUE_SEPARATOR);\n\t\t\t}\n\t\t\telse if (isInputNullable())\n\t\t\t{\n\t\t\t\t// no input\n\t\t\t\trawInput = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trawInput = NO_RAW_INPUT;\n\t\t\t}\n\t\t}\n\t}","id":784,"modified_method":"/**\n\t * Used by Form to tell the FormComponent that a new user input is available\n\t */\n\tpublic final void inputChanged()\n\t{\n\t\tif (isVisibleInHierarchy() && isEnabled())\n\t\t{\n\t\t\t// Get input as String array\n\t\t\tfinal String[] input = getInputAsArray();\n\n\t\t\t// If there is any input\n\t\t\tif (input != null && input.length > 0 && input[0] != null)\n\t\t\t{\n\t\t\t\t// join the values together with \";\", for example, \"id1;id2;id3\"\n\t\t\t\trawInput = StringList.valueOf(input).join(VALUE_SEPARATOR);\n\t\t\t}\n\t\t\telse if (isInputNullable())\n\t\t\t{\n\t\t\t\t// no input\n\t\t\t\trawInput = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trawInput = NO_RAW_INPUT;\n\t\t\t}\n\t\t}\n\t}","commit_id":"6bd8defa11250364333d33af0e201b858426cca8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the request parameters for this component as strings.\n\t * \n\t * @return The values in the request for this component\n\t */\n\tpublic String[] getInputAsArray()\n\t{\n\t\treturn getRequest().getParameters(getInputName());\n\t}","id":785,"modified_method":"/**\n\t * Gets the request parameters for this component as strings.\n\t * \n\t * @return The values in the request for this component\n\t */\n\tpublic String[] getInputAsArray()\n\t{\n\t\tString[] values = getRequest().getParameters(getInputName());\n\t\tif (!isInputNullable())\n\t\t{\n\t\t\tif (values != null && values.length == 1 && values[0] == null)\n\t\t\t{\n\t\t\t\t// we the key got passed in (otherwise values would be null),\n\t\t\t\t// but the value was set to null.\n\t\t\t\t// As the servlet spec isn't clear on what to do with 'empty'\n\t\t\t\t// request values - most return an empty string, but some null -\n\t\t\t\t// we have to workaround here and deliberately set to an empty\n\t\t\t\t// string if the the component is not nullable (text components)\n\t\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}","commit_id":"6bd8defa11250364333d33af0e201b858426cca8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the request parameters for this component as strings.\n\t * \n\t * @return The values in the request for this component\n\t */\n\tpublic String[] getInputAsArray()\n\t{\n\t\treturn getRequest().getParameters(getInputName());\n\t}","id":786,"modified_method":"/**\n\t * Gets the request parameters for this component as strings.\n\t * \n\t * @return The values in the request for this component\n\t */\n\tpublic String[] getInputAsArray()\n\t{\n\t\tString[] values = getRequest().getParameters(getInputName());\n\t\tif (!isInputNullable())\n\t\t{\n\t\t\tif (values != null && values.length == 1 && values[0] == null)\n\t\t\t{\n\t\t\t\t// we the key got passed in (otherwise values would be null),\n\t\t\t\t// but the value was set to null.\n\t\t\t\t// As the servlet spec isn't clear on what to do with 'empty'\n\t\t\t\t// request values - most return an empty string, but some null -\n\t\t\t\t// we have to workaround here and deliberately set to an empty\n\t\t\t\t// string if the the component is not nullable (text components)\n\t\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}","commit_id":"0556798ec40c7700c679c3ebfe8cddd27a18efe9","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Used by Form to tell the FormComponent that a new user input is available\n\t */\n\tpublic final void inputChanged()\n\t{\n\t\tif (isVisibleInHierarchy() && isEnabled())\n\t\t{\n\t\t\t// Get input as String array\n\t\t\tfinal String[] input = getInputAsArray();\n\n\t\t\t// If there is any input\n\t\t\tif (input != null)\n\t\t\t{\n\t\t\t\t// join the values together with \";\", for example, \"id1;id2;id3\"\n\t\t\t\trawInput = StringList.valueOf(input).join(VALUE_SEPARATOR);\n\t\t\t}\n\t\t\telse if (isInputNullable())\n\t\t\t{\n\t\t\t\t// no input\n\t\t\t\trawInput = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trawInput = NO_RAW_INPUT;\n\t\t\t}\n\t\t}\n\t}","id":787,"modified_method":"/**\n\t * Used by Form to tell the FormComponent that a new user input is available\n\t */\n\tpublic final void inputChanged()\n\t{\n\t\tif (isVisibleInHierarchy() && isEnabled())\n\t\t{\n\t\t\t// Get input as String array\n\t\t\tfinal String[] input = getInputAsArray();\n\n\t\t\t// If there is any input\n\t\t\tif (input != null && input.length > 0 && input[0] != null)\n\t\t\t{\n\t\t\t\t// join the values together with \";\", for example, \"id1;id2;id3\"\n\t\t\t\trawInput = StringList.valueOf(input).join(VALUE_SEPARATOR);\n\t\t\t}\n\t\t\telse if (isInputNullable())\n\t\t\t{\n\t\t\t\t// no input\n\t\t\t\trawInput = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trawInput = NO_RAW_INPUT;\n\t\t\t}\n\t\t}\n\t}","commit_id":"0556798ec40c7700c679c3ebfe8cddd27a18efe9","url":"https://github.com/apache/wicket"},{"original_method":"private static PsiExpression addApplyReference(final PsiExpression expression) {\n    String samMethodName = null;\n    PsiType type = expression.getType();\n    if (type instanceof PsiClassType) {\n      PsiClass resolvedClass = ((PsiClassType)type).resolve();\n      if (resolvedClass != null) {\n        final String qName = resolvedClass.getQualifiedName();\n        if (GuavaSupplierConversionRule.GUAVA_SUPPLIER.equals(qName)) {\n          samMethodName = \"get\";\n        }\n        else if (GuavaFunctionConversionRule.GUAVA_FUNCTION.equals(qName)) {\n          samMethodName = \"apply\";\n        }\n        else if (GuavaPredicateConversionRule.GUAVA_PREDICATE.equals(qName)) {\n          samMethodName = \"test\";\n        }\n      }\n      LOG.assertTrue(samMethodName != null);\n    }\n    return (PsiExpression)expression.replace(\n      JavaPsiFacade.getElementFactory(expression.getProject()).createExpressionFromText(expression.getText() + \"::\" + samMethodName, null));\n  }","id":788,"modified_method":"private static PsiExpression addApplyReference(final PsiExpression expression) {\n    String samMethodName = null;\n    PsiType type = expression.getType();\n    if (type instanceof PsiClassType) {\n      PsiClass resolvedClass = ((PsiClassType)type).resolve();\n      if (resolvedClass != null) {\n        final JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(expression.getProject());\n        final GlobalSearchScope scope = resolvedClass.getResolveScope();\n        if (InheritanceUtil.isInheritorOrSelf(resolvedClass, javaPsiFacade.findClass(GuavaSupplierConversionRule.GUAVA_SUPPLIER, scope), true)) {\n          samMethodName = \"get\";\n        }\n        else if (InheritanceUtil.isInheritorOrSelf(resolvedClass, javaPsiFacade.findClass(GuavaFunctionConversionRule.GUAVA_FUNCTION, scope), true)) {\n          samMethodName = \"apply\";\n        }\n        else if (InheritanceUtil.isInheritorOrSelf(resolvedClass, javaPsiFacade.findClass(GuavaPredicateConversionRule.GUAVA_PREDICATE, scope), true)) {\n          samMethodName = \"test\";\n        }\n      }\n      LOG.assertTrue(samMethodName != null);\n    }\n    return (PsiExpression)expression.replace(\n      JavaPsiFacade.getElementFactory(expression.getProject()).createExpressionFromText(expression.getText() + \"::\" + samMethodName, null));\n  }","commit_id":"347cac97d157e82251f5d912397812155dc330f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) {\n    Optional<? extends String> image = new ArrayList<String>().stream().filter(getPredicate()::apply).findFirst();\n    if (image.isPresent()) {\n      System.out.println(image.get());\n    }\n  }","id":789,"modified_method":"public static void main(String[] args) {\n    Optional<? extends String> image = new ArrayList<String>().stream().filter(getPredicate()::test).findFirst();\n    if (image.isPresent()) {\n      System.out.println(image.get());\n    }\n  }","commit_id":"347cac97d157e82251f5d912397812155dc330f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testDetectorFailWrongPort() throws UnknownHostException {\n        m_detector.setPort(5000);\n        m_detector.setLookup(\"www.google.com\");\n        \n        assertFalse(m_detector.isServiceDetected(InetAddress.getByName(\"151.197.0.38\"), new NullDetectorMonitor()));\n\n    }","id":790,"modified_method":"@Test\n    public void testDetectorFailWrongPort() throws UnknownHostException {\n        m_detector.setPort(5000);\n        m_detector.setLookup(\"www.google.com\");\n        m_detector.init();\n        \n        assertFalse(m_detector.isServiceDetected(InetAddress.getByName(\"151.197.0.38\"), new NullDetectorMonitor()));\n\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        expectBanner(expectedCodeRange(100, 600), singleLineRequest(\"quit\"));\n        addFtpResponseHandler(expectedCodeRange(100,600), null);\n    }","id":791,"modified_method":"public void onInit() {\n        expectBanner(expectCodeRange(100, 600));\n        send(request(\"quit\"), expectCodeRange(100,600));\n        expectClose();\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected FtpDetector() {\n        super(21, 500, 3);\n    }","id":792,"modified_method":"public FtpDetector() {\n        super(21, 500, 3);\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ResponseHandler expectedCodeRange(final int begin, final int end) {\n        return new ResponseHandler() {\n\n            public boolean matches(String input) {\n                int code = Integer.parseInt(input);\n                return code >= begin && code < end;\n            }\n            \n        };\n    }","id":793,"modified_method":"protected ResponseValidator<MultilineOrientedResponse> expectCodeRange(final int beginRange, final int endRange){\n        return new ResponseValidator<MultilineOrientedResponse>() {\n            \n            public boolean validate(MultilineOrientedResponse response) {\n                return response.expectedCodeRange(beginRange, endRange);\n            }\n            \n        };\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void onInit() {\n        sendHttpQuery(queryURLRequest(getUrl()));\n        addHttpResponseHandler(contains(\"HTTP/\"), null, getUrl(), isCheckRetCode(), getMaxRetCode());\n    }","id":794,"modified_method":"protected void onInit() {\n        send(request(httpCommand(\"GET\")), contains(\"HTTP/\",  getUrl(), isCheckRetCode(), getMaxRetCode()));\n        expectClose();\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected HttpsDetector() {\n        super();\n    }","id":795,"modified_method":"protected HttpsDetector() {\n        setServiceName(\"Https\");\n        setPort(443);\n        setTimeout(500);\n        setRetries(1);\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        setServiceName(\"Https\");\n        setPort(443);\n        setTimeout(500);\n        setRetries(1);\n        \n        sendHttpQuery(queryURLRequest(getUrl()));\n        addHttpResponseHandler(contains(\"HTTP/\"), null, getUrl(), isCheckRetCode(), getMaxRetCode());\n    }","id":796,"modified_method":"protected void onInit() {\n        send(request(httpCommand(\"GET\")), contains(\"HTTP/\",getUrl(), isCheckRetCode(), getMaxRetCode()));\n        expectClose();\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@After\n    public void tearDown() throws IOException {\n       System.out.println(\"Tear Down\");\n       m_server.stopServer();\n       m_detector.closeDetector();\n    }","id":797,"modified_method":"@After\n    public void tearDown() throws IOException {\n       m_server.stopServer();\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDetectorSuccess() throws Exception {\n        \n        assertTrue(m_detector.isServiceDetected(m_server.getInetAddress(),new NullDetectorMonitor()));\n        \n    }","id":798,"modified_method":"@Test\n    public void testDetectorSuccess() throws Exception {\n        m_detector.init();\n        //FIXME: At some point tonight\n        assertFalse(m_detector.isServiceDetected(m_server.getInetAddress(),new NullDetectorMonitor()));\n        \n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        System.out.println(\"Seting up\");\n        m_detector = new HttpsDetector();\n        m_detector.init();\n        \n        m_server = getServer();\n        m_server.init();\n        m_server.startServer();\n        m_detector.setPort(m_server.getLocalPort());\n    }","id":799,"modified_method":"@Before\n    public void setUp() throws Exception {\n        m_detector = new HttpsDetector();\n        m_detector.setRetries(0);\n        \n        m_server = getServer();\n        m_server.init();\n        m_server.startServer();\n        m_detector.setPort(m_server.getLocalPort());\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit(){\n        expectBanner(startsWith(\"* OK \"), singleLineRequest(\"ONMSCAPSD LOGOUT\"));\n        addResponseHandler(startsWith(\"* BYE\"), null);\n        addResponseHandler(startsWith(\"ONMSCAPSD OK\"), null);\n    }","id":800,"modified_method":"public void onInit(){\n        expectBanner(startsWith(\"* OK \"));\n        send(request(\"ONMSCAPSD LOGOUT\"), startsWith(\"* BYE\"));\n        expectClose();\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Pop3Detector() {\n        super(110, 5000, 1);\n    }","id":801,"modified_method":"public Pop3Detector() {\n        super(110, 5000, 1);\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit(){\n        expectBanner(startsWith(\"+OK\"), singleLineRequest(\"QUIT\")); \n        addResponseHandler(startsWith(\"+OK\"), closeDetector());\n    }","id":802,"modified_method":"protected void onInit(){\n        expectBanner(startsWith(\"+OK\"));\n        send(request(\"QUIT\"), startsWith(\"+OK\"));\n        expectClose();\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        addMultilineResponseHandler(startsWith(\"220\"), singleLineRequest(\"HELO LOCALHOST\"));\n        addMultilineResponseHandler(startsWith(\"250\"), singleLineRequest(\"QUIT\"));\n        addMultilineResponseHandler(startsWith(\"221\"), null);\n    }","id":803,"modified_method":"public void onInit() {\n        expectBanner(startsWith(\"220\"));\n        send(request(\"HELO LOCALHOST\"), startsWith(\"250\"));\n        send(request(\"QUIT\"), startsWith(\"221\"));\n        //addMultilineResponseHandler(startsWith(\"220\"), singleLineRequest(\"HELO LOCALHOST\"));\n        //addMultilineResponseHandler(startsWith(\"250\"), singleLineRequest(\"QUIT\"));\n        //addMultilineResponseHandler(startsWith(\"221\"), null);\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        //Using the regex to find a word that gets sent back from TCP. Any word counts.\n        expectBanner(find(\"\\\\w\"), singleLineRequest(\"LOGOUT\"));\n    }","id":804,"modified_method":"public void onInit() {\n        expectBanner(find(\"\\\\w\"));\n    }","commit_id":"c527e7ad0877bdfe3a575f20fcf57e301d1dced1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDetectorFailWrongPort() throws UnknownHostException {\n        m_detector.setPort(5000);\n        m_detector.setLookup(\"www.google.com\");\n        \n        assertFalse(m_detector.isServiceDetected(InetAddress.getByName(\"151.197.0.38\"), new NullDetectorMonitor()));\n\n    }","id":805,"modified_method":"@Test\n    public void testDetectorFailWrongPort() throws UnknownHostException {\n        m_detector.setPort(5000);\n        m_detector.setLookup(\"www.google.com\");\n        m_detector.init();\n        \n        assertFalse(m_detector.isServiceDetected(InetAddress.getByName(\"151.197.0.38\"), new NullDetectorMonitor()));\n\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected FtpDetector() {\n        super(21, 500, 3);\n    }","id":806,"modified_method":"public FtpDetector() {\n        super(21, 500, 3);\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ResponseHandler expectedCodeRange(final int begin, final int end) {\n        return new ResponseHandler() {\n\n            public boolean matches(String input) {\n                int code = Integer.parseInt(input);\n                return code >= begin && code < end;\n            }\n            \n        };\n    }","id":807,"modified_method":"protected ResponseValidator<MultilineOrientedResponse> expectCodeRange(final int beginRange, final int endRange){\n        return new ResponseValidator<MultilineOrientedResponse>() {\n            \n            public boolean validate(MultilineOrientedResponse response) {\n                return response.expectedCodeRange(beginRange, endRange);\n            }\n            \n        };\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        expectBanner(expectedCodeRange(100, 600), singleLineRequest(\"quit\"));\n        addFtpResponseHandler(expectedCodeRange(100,600), null);\n    }","id":808,"modified_method":"public void onInit() {\n        expectBanner(expectCodeRange(100, 600));\n        send(request(\"quit\"), expectCodeRange(100,600));\n        expectClose();\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void onInit() {\n        sendHttpQuery(queryURLRequest(getUrl()));\n        addHttpResponseHandler(contains(\"HTTP/\"), null, getUrl(), isCheckRetCode(), getMaxRetCode());\n    }","id":809,"modified_method":"protected void onInit() {\n        send(request(httpCommand(\"GET\")), contains(\"HTTP/\",  getUrl(), isCheckRetCode(), getMaxRetCode()));\n        expectClose();\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        setServiceName(\"Https\");\n        setPort(443);\n        setTimeout(500);\n        setRetries(1);\n        \n        sendHttpQuery(queryURLRequest(getUrl()));\n        addHttpResponseHandler(contains(\"HTTP/\"), null, getUrl(), isCheckRetCode(), getMaxRetCode());\n    }","id":810,"modified_method":"protected void onInit() {\n        send(request(httpCommand(\"GET\")), contains(\"HTTP/\",getUrl(), isCheckRetCode(), getMaxRetCode()));\n        expectClose();\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected HttpsDetector() {\n        super();\n    }","id":811,"modified_method":"protected HttpsDetector() {\n        setServiceName(\"Https\");\n        setPort(443);\n        setTimeout(500);\n        setRetries(1);\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDetectorSuccess() throws Exception {\n        \n        assertTrue(m_detector.isServiceDetected(m_server.getInetAddress(),new NullDetectorMonitor()));\n        \n    }","id":812,"modified_method":"@Test\n    public void testDetectorSuccess() throws Exception {\n        m_detector.init();\n        //FIXME: At some point tonight\n        assertFalse(m_detector.isServiceDetected(m_server.getInetAddress(),new NullDetectorMonitor()));\n        \n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        System.out.println(\"Seting up\");\n        m_detector = new HttpsDetector();\n        m_detector.init();\n        \n        m_server = getServer();\n        m_server.init();\n        m_server.startServer();\n        m_detector.setPort(m_server.getLocalPort());\n    }","id":813,"modified_method":"@Before\n    public void setUp() throws Exception {\n        m_detector = new HttpsDetector();\n        m_detector.setRetries(0);\n        \n        m_server = getServer();\n        m_server.init();\n        m_server.startServer();\n        m_detector.setPort(m_server.getLocalPort());\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@After\n    public void tearDown() throws IOException {\n       System.out.println(\"Tear Down\");\n       m_server.stopServer();\n       m_detector.closeDetector();\n    }","id":814,"modified_method":"@After\n    public void tearDown() throws IOException {\n       m_server.stopServer();\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit(){\n        expectBanner(startsWith(\"* OK \"), singleLineRequest(\"ONMSCAPSD LOGOUT\"));\n        addResponseHandler(startsWith(\"* BYE\"), null);\n        addResponseHandler(startsWith(\"ONMSCAPSD OK\"), null);\n    }","id":815,"modified_method":"public void onInit(){\n        expectBanner(startsWith(\"* OK \"));\n        send(request(\"ONMSCAPSD LOGOUT\"), startsWith(\"* BYE\"));\n        expectClose();\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit(){\n        expectBanner(startsWith(\"+OK\"), singleLineRequest(\"QUIT\")); \n        addResponseHandler(startsWith(\"+OK\"), closeDetector());\n    }","id":816,"modified_method":"protected void onInit(){\n        expectBanner(startsWith(\"+OK\"));\n        send(request(\"QUIT\"), startsWith(\"+OK\"));\n        expectClose();\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Pop3Detector() {\n        super(110, 5000, 1);\n    }","id":817,"modified_method":"public Pop3Detector() {\n        super(110, 5000, 1);\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        addMultilineResponseHandler(startsWith(\"220\"), singleLineRequest(\"HELO LOCALHOST\"));\n        addMultilineResponseHandler(startsWith(\"250\"), singleLineRequest(\"QUIT\"));\n        addMultilineResponseHandler(startsWith(\"221\"), null);\n    }","id":818,"modified_method":"public void onInit() {\n        expectBanner(startsWith(\"220\"));\n        send(request(\"HELO LOCALHOST\"), startsWith(\"250\"));\n        send(request(\"QUIT\"), startsWith(\"221\"));\n        //addMultilineResponseHandler(startsWith(\"220\"), singleLineRequest(\"HELO LOCALHOST\"));\n        //addMultilineResponseHandler(startsWith(\"250\"), singleLineRequest(\"QUIT\"));\n        //addMultilineResponseHandler(startsWith(\"221\"), null);\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        //Using the regex to find a word that gets sent back from TCP. Any word counts.\n        expectBanner(find(\"\\\\w\"), singleLineRequest(\"LOGOUT\"));\n    }","id":819,"modified_method":"public void onInit() {\n        expectBanner(find(\"\\\\w\"));\n    }","commit_id":"63f9ecb6937943e98effbb3dcc3de1454910bd10","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDetectorFailWrongPort() throws UnknownHostException {\n        m_detector.setPort(5000);\n        m_detector.setLookup(\"www.google.com\");\n        \n        assertFalse(m_detector.isServiceDetected(InetAddress.getByName(\"151.197.0.38\"), new NullDetectorMonitor()));\n\n    }","id":820,"modified_method":"@Test\n    public void testDetectorFailWrongPort() throws UnknownHostException {\n        m_detector.setPort(5000);\n        m_detector.setLookup(\"www.google.com\");\n        m_detector.init();\n        \n        assertFalse(m_detector.isServiceDetected(InetAddress.getByName(\"151.197.0.38\"), new NullDetectorMonitor()));\n\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        expectBanner(expectedCodeRange(100, 600), singleLineRequest(\"quit\"));\n        addFtpResponseHandler(expectedCodeRange(100,600), null);\n    }","id":821,"modified_method":"public void onInit() {\n        expectBanner(expectCodeRange(100, 600));\n        send(request(\"quit\"), expectCodeRange(100,600));\n        expectClose();\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected FtpDetector() {\n        super(21, 500, 3);\n    }","id":822,"modified_method":"public FtpDetector() {\n        super(21, 500, 3);\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ResponseHandler expectedCodeRange(final int begin, final int end) {\n        return new ResponseHandler() {\n\n            public boolean matches(String input) {\n                int code = Integer.parseInt(input);\n                return code >= begin && code < end;\n            }\n            \n        };\n    }","id":823,"modified_method":"protected ResponseValidator<MultilineOrientedResponse> expectCodeRange(final int beginRange, final int endRange){\n        return new ResponseValidator<MultilineOrientedResponse>() {\n            \n            public boolean validate(MultilineOrientedResponse response) {\n                return response.expectedCodeRange(beginRange, endRange);\n            }\n            \n        };\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public void onInit() {\n        sendHttpQuery(queryURLRequest(getUrl()));\n        addHttpResponseHandler(contains(\"HTTP/\"), null, getUrl(), isCheckRetCode(), getMaxRetCode());\n    }","id":824,"modified_method":"protected void onInit() {\n        send(request(httpCommand(\"GET\")), contains(\"HTTP/\",  getUrl(), isCheckRetCode(), getMaxRetCode()));\n        expectClose();\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected HttpsDetector() {\n        super();\n    }","id":825,"modified_method":"protected HttpsDetector() {\n        setServiceName(\"Https\");\n        setPort(443);\n        setTimeout(500);\n        setRetries(1);\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        setServiceName(\"Https\");\n        setPort(443);\n        setTimeout(500);\n        setRetries(1);\n        \n        sendHttpQuery(queryURLRequest(getUrl()));\n        addHttpResponseHandler(contains(\"HTTP/\"), null, getUrl(), isCheckRetCode(), getMaxRetCode());\n    }","id":826,"modified_method":"protected void onInit() {\n        send(request(httpCommand(\"GET\")), contains(\"HTTP/\",getUrl(), isCheckRetCode(), getMaxRetCode()));\n        expectClose();\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@After\n    public void tearDown() throws IOException {\n       System.out.println(\"Tear Down\");\n       m_server.stopServer();\n       m_detector.closeDetector();\n    }","id":827,"modified_method":"@After\n    public void tearDown() throws IOException {\n       m_server.stopServer();\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        System.out.println(\"Seting up\");\n        m_detector = new HttpsDetector();\n        m_detector.init();\n        \n        m_server = getServer();\n        m_server.init();\n        m_server.startServer();\n        m_detector.setPort(m_server.getLocalPort());\n    }","id":828,"modified_method":"@Before\n    public void setUp() throws Exception {\n        m_detector = new HttpsDetector();\n        m_detector.setRetries(0);\n        \n        m_server = getServer();\n        m_server.init();\n        m_server.startServer();\n        m_detector.setPort(m_server.getLocalPort());\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testDetectorSuccess() throws Exception {\n        \n        assertTrue(m_detector.isServiceDetected(m_server.getInetAddress(),new NullDetectorMonitor()));\n        \n    }","id":829,"modified_method":"@Test\n    public void testDetectorSuccess() throws Exception {\n        m_detector.init();\n        //FIXME: At some point tonight\n        assertFalse(m_detector.isServiceDetected(m_server.getInetAddress(),new NullDetectorMonitor()));\n        \n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit(){\n        expectBanner(startsWith(\"* OK \"), singleLineRequest(\"ONMSCAPSD LOGOUT\"));\n        addResponseHandler(startsWith(\"* BYE\"), null);\n        addResponseHandler(startsWith(\"ONMSCAPSD OK\"), null);\n    }","id":830,"modified_method":"public void onInit(){\n        expectBanner(startsWith(\"* OK \"));\n        send(request(\"ONMSCAPSD LOGOUT\"), startsWith(\"* BYE\"));\n        expectClose();\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit(){\n        expectBanner(startsWith(\"+OK\"), singleLineRequest(\"QUIT\")); \n        addResponseHandler(startsWith(\"+OK\"), closeDetector());\n    }","id":831,"modified_method":"protected void onInit(){\n        expectBanner(startsWith(\"+OK\"));\n        send(request(\"QUIT\"), startsWith(\"+OK\"));\n        expectClose();\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Pop3Detector() {\n        super(110, 5000, 1);\n    }","id":832,"modified_method":"public Pop3Detector() {\n        super(110, 5000, 1);\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        addMultilineResponseHandler(startsWith(\"220\"), singleLineRequest(\"HELO LOCALHOST\"));\n        addMultilineResponseHandler(startsWith(\"250\"), singleLineRequest(\"QUIT\"));\n        addMultilineResponseHandler(startsWith(\"221\"), null);\n    }","id":833,"modified_method":"public void onInit() {\n        expectBanner(startsWith(\"220\"));\n        send(request(\"HELO LOCALHOST\"), startsWith(\"250\"));\n        send(request(\"QUIT\"), startsWith(\"221\"));\n        //addMultilineResponseHandler(startsWith(\"220\"), singleLineRequest(\"HELO LOCALHOST\"));\n        //addMultilineResponseHandler(startsWith(\"250\"), singleLineRequest(\"QUIT\"));\n        //addMultilineResponseHandler(startsWith(\"221\"), null);\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onInit() {\n        //Using the regex to find a word that gets sent back from TCP. Any word counts.\n        expectBanner(find(\"\\\\w\"), singleLineRequest(\"LOGOUT\"));\n    }","id":834,"modified_method":"public void onInit() {\n        expectBanner(find(\"\\\\w\"));\n    }","commit_id":"211448f350971cb300eff8c55aca98f493b8bcd3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static InterceptorFactory weaved(final Collection<InterceptorFactory> interceptorFactories) {\n        if(interceptorFactories == null) {\n            return null;\n        }\n        return new InterceptorFactory() {\n            @Override\n            public Interceptor create(InterceptorFactoryContext context) {\n                final Interceptor[] interceptors = new Interceptor[interceptorFactories.size()];\n                final Iterator<InterceptorFactory> factories = interceptorFactories.iterator();\n                for (int i = 0; i < interceptors.length; i++) {\n                    interceptors[i] = factories.next().create(context);\n                }\n                return Interceptors.getWeavedInterceptor(interceptors);\n            }\n        };\n    }","id":835,"modified_method":"/**\n     * The weaved interceptor factory results in a lot of runtime allocations, and should not be used\n     * @param interceptorFactories The interceptor factories\n     * @return\n     */\n    @Deprecated\n    protected static InterceptorFactory weaved(final Collection<InterceptorFactory> interceptorFactories) {\n        if(interceptorFactories == null) {\n            return null;\n        }\n        return new InterceptorFactory() {\n            @Override\n            public Interceptor create(InterceptorFactoryContext context) {\n                final Interceptor[] interceptors = new Interceptor[interceptorFactories.size()];\n                final Iterator<InterceptorFactory> factories = interceptorFactories.iterator();\n                for (int i = 0; i < interceptors.length; i++) {\n                    interceptors[i] = factories.next().create(context);\n                }\n                return Interceptors.getWeavedInterceptor(interceptors);\n            }\n        };\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the around-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getAroundConstructInterceptors() {\n        return aroundConstructInterceptors.getSortedItems();\n    }","id":836,"modified_method":"/**\n     * Get the around-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getAroundConstructInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = aroundConstructInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the pre-destroy interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptor\n     */\n    public List<InterceptorFactory> getPreDestroyInterceptors() {\n        return preDestroyInterceptors.getSortedItems();\n    }","id":837,"modified_method":"/**\n     * Get the pre-destroy interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptor\n     */\n    public List<InterceptorFactory> getPreDestroyInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = preDestroyInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds a post construct interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addPostConstructInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        postConstructInterceptors.add(interceptorFactory, priority);\n    }","id":838,"modified_method":"/**\n     * Adds a post construct interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addPostConstructInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        postConstructInterceptors.add(Collections.singletonList(interceptorFactory), priority);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds an interceptor factory to every method on the component.\n     *\n     * @param factory    The interceptor factory to add\n     * @param priority   The interceptors relative order\n     * @param publicOnly If true then then interceptor is only added to public methods\n     */\n    public void addComponentInterceptor(InterceptorFactory factory, int priority, boolean publicOnly) {\n        for (Method method : classIndex.getClassMethods()) {\n            if (publicOnly && !Modifier.isPublic(method.getModifiers())) {\n                continue;\n            }\n            OrderedItemContainer<InterceptorFactory> interceptors = componentInterceptors.get(method);\n            if (interceptors == null) {\n                componentInterceptors.put(method, interceptors = new OrderedItemContainer<InterceptorFactory>());\n            }\n            interceptors.add(factory, priority);\n        }\n    }","id":839,"modified_method":"/**\n     * Adds an interceptor factory to every method on the component.\n     *\n     * @param factory    The interceptor factory to add\n     * @param priority   The interceptors relative order\n     * @param publicOnly If true then then interceptor is only added to public methods\n     */\n    public void addComponentInterceptor(InterceptorFactory factory, int priority, boolean publicOnly) {\n        addComponentInterceptors(Collections.singletonList(factory), priority, publicOnly);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the post-activate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostActivateInterceptors() {\n        return postActivateInterceptors.getSortedItems();\n    }","id":840,"modified_method":"/**\n     * Get the post-activate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostActivateInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = postActivateInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds an interceptor factory to a given method. The method parameter *must* be retrived from either the\n     * {@link org.jboss.as.server.deployment.reflect.DeploymentReflectionIndex} or from {@link #getDefinedComponentMethods()},\n     * as the methods are stored in an identity hash map\n     *\n     * @param method   The method to add the interceptor to\n     * @param factory  The interceptor factory to add\n     * @param priority The interceptors relative order\n     */\n    public void addComponentInterceptor(Method method, InterceptorFactory factory, int priority) {\n        OrderedItemContainer<InterceptorFactory> interceptors = componentInterceptors.get(method);\n        if (interceptors == null) {\n            componentInterceptors.put(method, interceptors = new OrderedItemContainer<InterceptorFactory>());\n        }\n        interceptors.add(factory, priority);\n    }","id":841,"modified_method":"/**\n     * Adds an interceptor factory to a given method. The method parameter *must* be retrived from either the\n     * {@link org.jboss.as.server.deployment.reflect.DeploymentReflectionIndex} or from {@link #getDefinedComponentMethods()},\n     * as the methods are stored in an identity hash map\n     *\n     * @param method   The method to add the interceptor to\n     * @param factory  The interceptor factory to add\n     * @param priority The interceptors relative order\n     */\n    public void addComponentInterceptor(Method method, InterceptorFactory factory, int priority) {\n        addComponentInterceptors(method, Collections.singletonList(factory), priority);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the pre-passivate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPrePassivateInterceptors() {\n        return prePassivateInterceptors.getSortedItems();\n    }","id":842,"modified_method":"/**\n     * Get the pre-passivate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPrePassivateInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = prePassivateInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds an around-construct interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addAroundConstructInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        aroundConstructInterceptors.add(interceptorFactory, priority);\n    }","id":843,"modified_method":"/**\n     * Adds an around-construct interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addAroundConstructInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        aroundConstructInterceptors.add(Collections.singletonList(interceptorFactory), priority);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds a post activate interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addPostActivateInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        postActivateInterceptors.add(interceptorFactory, priority);\n    }","id":844,"modified_method":"/**\n     * Adds a post activate interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addPostActivateInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        postActivateInterceptors.add(Collections.singletonList(interceptorFactory), priority);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the post-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostConstructInterceptors() {\n        return postConstructInterceptors.getSortedItems();\n    }","id":845,"modified_method":"/**\n     * Get the post-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostConstructInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = postConstructInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds a pre passivate interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addPrePassivateInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        prePassivateInterceptors.add(interceptorFactory, priority);\n    }","id":846,"modified_method":"/**\n     * Adds a pre passivate interceptor\n     *\n     * @param interceptorFactory The interceptor to add\n     * @param priority           The priority\n     */\n    public void addPrePassivateInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        prePassivateInterceptors.add(Collections.singletonList(interceptorFactory), priority);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Gets the interceptor list for a given method. This should not be called until\n     * all interceptors have been added.\n     *\n     * @param method the component method\n     * @return the deque\n     */\n    public List<InterceptorFactory> getComponentInterceptors(Method method) {\n        Map<Method, OrderedItemContainer<InterceptorFactory>> map = componentInterceptors;\n        OrderedItemContainer<InterceptorFactory> interceptors = map.get(method);\n        if (interceptors == null) {\n            return Collections.emptyList();\n        }\n        return interceptors.getSortedItems();\n    }","id":847,"modified_method":"/**\n     * Gets the interceptor list for a given method. This should not be called until\n     * all interceptors have been added.\n     *\n     * @param method the component method\n     * @return the deque\n     */\n    public List<InterceptorFactory> getComponentInterceptors(Method method) {\n        Map<Method, OrderedItemContainer<List<InterceptorFactory>>> map = componentInterceptors;\n        OrderedItemContainer<List<InterceptorFactory>> interceptors = map.get(method);\n        if (interceptors == null) {\n            return Collections.emptyList();\n        }\n        List<List<InterceptorFactory>> sortedItems = interceptors.getSortedItems();\n        List<InterceptorFactory> ret = new ArrayList<>();\n        for(List<InterceptorFactory> item : sortedItems) {\n            ret.addAll(item);\n        }\n        return ret;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Adds a pre destroy interceptor\n     *\n     * @param interceptorFactory The interceptor factory to add\n     * @param priority           The factories priority\n     */\n    public void addPreDestroyInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        preDestroyInterceptors.add(interceptorFactory, priority);\n    }","id":848,"modified_method":"/**\n     * Adds a pre destroy interceptor\n     *\n     * @param interceptorFactory The interceptor factory to add\n     * @param priority           The factories priority\n     */\n    public void addPreDestroyInterceptor(InterceptorFactory interceptorFactory, int priority) {\n        preDestroyInterceptors.add(Collections.singletonList(interceptorFactory), priority);\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);\n        final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n\n        final boolean metadataComplete = MetadataCompleteMarker.isMetadataComplete(deploymentUnit);\n\n        // Module stuff\n\n        final Deque<InterceptorFactory> injectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> uninjectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> destructors = new ArrayDeque<>();\n\n        final List<InterceptorFactory> componentUserAroundInvoke = new ArrayList<>();\n        final List<InterceptorFactory> componentUserAroundTimeout;\n        final List<InterceptorFactory> userPostConstruct = new ArrayList<>();\n        final List<InterceptorFactory> userPreDestroy = new ArrayList<>();\n        final List<InterceptorFactory> componentUserPrePassivate;\n        final List<InterceptorFactory> componentUserPostActivate;\n\n        final Set<MethodIdentifier> timeoutMethods = description.getTimerMethods();\n        if (description.isTimerServiceRequired()) {\n            componentUserAroundTimeout = new ArrayList<>();\n        } else {\n            componentUserAroundTimeout = null;\n        }\n\n\n        if (description.isPassivationApplicable()) {\n            componentUserPrePassivate = new ArrayList<>();\n            componentUserPostActivate = new ArrayList<>();\n        } else {\n            componentUserPrePassivate = null;\n            componentUserPostActivate = null;\n        }\n\n\n        destructors.addLast(new ImmediateInterceptorFactory(new ManagedReferenceReleaseInterceptor(BasicComponentInstance.INSTANCE_KEY)));\n\n        new ClassDescriptionTraversal(configuration.getComponentClass(), applicationClasses) {\n            @Override\n            public void handle(Class<?> clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                mergeInjectionsForClass(clazz, configuration.getComponentClass(), classDescription, moduleDescription, deploymentReflectionIndex, description, configuration, context, injectors, BasicComponentInstance.INSTANCE_KEY, uninjectors, metadataComplete);\n            }\n        }.run();\n\n\n        new ClassDescriptionTraversal(configuration.getComponentClass(), applicationClasses) {\n            @Override\n            public void handle(final Class<?> clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n\n                final InterceptorClassDescription interceptorConfig = InterceptorClassDescription.merge(ComponentDescription.mergeInterceptorConfig(clazz, classDescription, description, metadataComplete), moduleDescription.getInterceptorClassOverride(clazz.getName()));\n\n                handleClassMethod(clazz, interceptorConfig.getAroundInvoke(), componentUserAroundInvoke, false, false, configuration);\n\n                if (description.isTimerServiceRequired()) {\n                    handleClassMethod(clazz, interceptorConfig.getAroundTimeout(), componentUserAroundTimeout, false, false, configuration);\n                }\n                if (!description.isIgnoreLifecycleInterceptors()) {\n                    handleClassMethod(clazz, interceptorConfig.getPostConstruct(), userPostConstruct, true, true, configuration);\n                    handleClassMethod(clazz, interceptorConfig.getPreDestroy(), userPreDestroy, true, true, configuration);\n\n\n                    if (description.isPassivationApplicable()) {\n                        handleClassMethod(clazz, interceptorConfig.getPrePassivate(), componentUserPrePassivate, false, false, configuration);\n                        handleClassMethod(clazz, interceptorConfig.getPostActivate(), componentUserPostActivate, false, false, configuration);\n                    }\n                }\n            }\n\n            private void handleClassMethod(final Class<?> clazz, final MethodIdentifier methodIdentifier, final List<InterceptorFactory> interceptors, boolean changeMethod, boolean lifecycleMethod, ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                if (methodIdentifier != null) {\n                    final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, clazz, methodIdentifier);\n                    if (isNotOverriden(clazz, method, configuration.getComponentClass(), deploymentReflectionIndex)) {\n                        InterceptorFactory interceptorFactory = new ImmediateInterceptorFactory(new ManagedReferenceLifecycleMethodInterceptor(BasicComponentInstance.INSTANCE_KEY, method, changeMethod, lifecycleMethod));\n                        interceptors.add(interceptorFactory);\n                        if(lifecycleMethod) {\n                            configuration.addLifecycleMethod(method);\n                        }\n                    }\n                }\n            }\n        }.run();\n\n        final ClassLoader classLoader = module.getClassLoader();\n        final InterceptorFactory tcclInterceptor = new ImmediateInterceptorFactory(new ContextClassLoaderInterceptor(classLoader));\n        final InterceptorFactory privilegedInterceptor = PrivilegedWithCombinerInterceptor.getFactory();\n\n\n        if (!injectors.isEmpty()) {\n            configuration.addPostConstructInterceptor(weaved(injectors), InterceptorOrder.ComponentPostConstruct.COMPONENT_RESOURCE_INJECTION_INTERCEPTORS);\n        }\n        // Apply post-construct\n        if (!userPostConstruct.isEmpty()) {\n            configuration.addPostConstructInterceptor(weaved(userPostConstruct), InterceptorOrder.ComponentPostConstruct.COMPONENT_USER_INTERCEPTORS);\n        }\n        configuration.addPostConstructInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPostConstruct.TERMINAL_INTERCEPTOR);\n        configuration.addPostConstructInterceptor(tcclInterceptor, InterceptorOrder.ComponentPostConstruct.TCCL_INTERCEPTOR);\n        configuration.addPostConstructInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPostConstruct.PRIVILEGED_INTERCEPTOR);\n\n        // Apply pre-destroy\n        if (!uninjectors.isEmpty()) {\n            configuration.addPreDestroyInterceptor(weaved(uninjectors), InterceptorOrder.ComponentPreDestroy.COMPONENT_UNINJECTION_INTERCEPTORS);\n        }\n        if (!destructors.isEmpty()) {\n            configuration.addPreDestroyInterceptor(weaved(destructors), InterceptorOrder.ComponentPreDestroy.COMPONENT_DESTRUCTION_INTERCEPTORS);\n        }\n        if (!userPreDestroy.isEmpty()) {\n            configuration.addPreDestroyInterceptor(weaved(userPreDestroy), InterceptorOrder.ComponentPreDestroy.COMPONENT_USER_INTERCEPTORS);\n        }\n        configuration.addPreDestroyInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPreDestroy.TERMINAL_INTERCEPTOR);\n        configuration.addPreDestroyInterceptor(tcclInterceptor, InterceptorOrder.ComponentPreDestroy.TCCL_INTERCEPTOR);\n        configuration.addPreDestroyInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPreDestroy.PRIVILEGED_INTERCEPTOR);\n\n        if (description.isPassivationApplicable()) {\n            if (!componentUserPrePassivate.isEmpty()) {\n                configuration.addPrePassivateInterceptor(weaved(componentUserPrePassivate), InterceptorOrder.ComponentPassivation.COMPONENT_USER_INTERCEPTORS);\n            }\n            configuration.addPrePassivateInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPassivation.TERMINAL_INTERCEPTOR);\n            configuration.addPrePassivateInterceptor(tcclInterceptor, InterceptorOrder.ComponentPassivation.TCCL_INTERCEPTOR);\n            configuration.addPrePassivateInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPassivation.PRIVILEGED_INTERCEPTOR);\n            if (!componentUserPostActivate.isEmpty()) {\n                configuration.addPostActivateInterceptor(weaved(componentUserPostActivate), InterceptorOrder.ComponentPassivation.COMPONENT_USER_INTERCEPTORS);\n            }\n            configuration.addPostActivateInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPassivation.TERMINAL_INTERCEPTOR);\n            configuration.addPostActivateInterceptor(tcclInterceptor, InterceptorOrder.ComponentPassivation.TCCL_INTERCEPTOR);\n            configuration.addPostActivateInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPassivation.PRIVILEGED_INTERCEPTOR);\n        }\n\n        // @AroundInvoke interceptors\n        if (description.isIntercepted()) {\n\n            for (final Method method : configuration.getDefinedComponentMethods()) {\n\n                //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n\n                configuration.addComponentInterceptor(method, Interceptors.getInitialInterceptorFactory(), InterceptorOrder.Component.INITIAL_INTERCEPTOR);\n                configuration.addComponentInterceptor(method, new ImmediateInterceptorFactory(new ManagedReferenceMethodInterceptor(BasicComponentInstance.INSTANCE_KEY, method)), InterceptorOrder.Component.TERMINAL_INTERCEPTOR);\n\n                final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n\n                // first add the default interceptors (if not excluded) to the deque\n                final boolean requiresTimerChain = description.isTimerServiceRequired() && timeoutMethods.contains(identifier);\n\n                configuration.addComponentInterceptor(method, new UserInterceptorFactory(weaved(componentUserAroundInvoke), weaved(requiresTimerChain ? componentUserAroundTimeout : null)), InterceptorOrder.Component.COMPONENT_USER_INTERCEPTORS);\n            }\n        }\n\n    }","id":849,"modified_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);\n        final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n\n        final boolean metadataComplete = MetadataCompleteMarker.isMetadataComplete(deploymentUnit);\n\n        // Module stuff\n\n        final Deque<InterceptorFactory> injectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> uninjectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> destructors = new ArrayDeque<>();\n\n        final List<InterceptorFactory> componentUserAroundInvoke = new ArrayList<>();\n        final List<InterceptorFactory> componentUserAroundTimeout;\n        final List<InterceptorFactory> userPostConstruct = new ArrayList<>();\n        final List<InterceptorFactory> userPreDestroy = new ArrayList<>();\n        final List<InterceptorFactory> componentUserPrePassivate;\n        final List<InterceptorFactory> componentUserPostActivate;\n\n        final Set<MethodIdentifier> timeoutMethods = description.getTimerMethods();\n        if (description.isTimerServiceRequired()) {\n            componentUserAroundTimeout = new ArrayList<>();\n        } else {\n            componentUserAroundTimeout = null;\n        }\n\n\n        if (description.isPassivationApplicable()) {\n            componentUserPrePassivate = new ArrayList<>();\n            componentUserPostActivate = new ArrayList<>();\n        } else {\n            componentUserPrePassivate = null;\n            componentUserPostActivate = null;\n        }\n\n\n        destructors.add(new ImmediateInterceptorFactory(new ManagedReferenceReleaseInterceptor(BasicComponentInstance.INSTANCE_KEY)));\n\n        new ClassDescriptionTraversal(configuration.getComponentClass(), applicationClasses) {\n            @Override\n            public void handle(Class<?> clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                mergeInjectionsForClass(clazz, configuration.getComponentClass(), classDescription, moduleDescription, deploymentReflectionIndex, description, configuration, context, injectors, BasicComponentInstance.INSTANCE_KEY, uninjectors, metadataComplete);\n            }\n        }.run();\n\n\n        new ClassDescriptionTraversal(configuration.getComponentClass(), applicationClasses) {\n            @Override\n            public void handle(final Class<?> clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n\n                final InterceptorClassDescription interceptorConfig = InterceptorClassDescription.merge(ComponentDescription.mergeInterceptorConfig(clazz, classDescription, description, metadataComplete), moduleDescription.getInterceptorClassOverride(clazz.getName()));\n\n                handleClassMethod(clazz, interceptorConfig.getAroundInvoke(), componentUserAroundInvoke, false, false, configuration);\n\n                if (description.isTimerServiceRequired()) {\n                    handleClassMethod(clazz, interceptorConfig.getAroundTimeout(), componentUserAroundTimeout, false, false, configuration);\n                }\n                if (!description.isIgnoreLifecycleInterceptors()) {\n                    handleClassMethod(clazz, interceptorConfig.getPostConstruct(), userPostConstruct, true, true, configuration);\n                    handleClassMethod(clazz, interceptorConfig.getPreDestroy(), userPreDestroy, true, true, configuration);\n\n\n                    if (description.isPassivationApplicable()) {\n                        handleClassMethod(clazz, interceptorConfig.getPrePassivate(), componentUserPrePassivate, false, false, configuration);\n                        handleClassMethod(clazz, interceptorConfig.getPostActivate(), componentUserPostActivate, false, false, configuration);\n                    }\n                }\n            }\n\n            private void handleClassMethod(final Class<?> clazz, final MethodIdentifier methodIdentifier, final List<InterceptorFactory> interceptors, boolean changeMethod, boolean lifecycleMethod, ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n                if (methodIdentifier != null) {\n                    final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, clazz, methodIdentifier);\n                    if (isNotOverriden(clazz, method, configuration.getComponentClass(), deploymentReflectionIndex)) {\n                        InterceptorFactory interceptorFactory = new ImmediateInterceptorFactory(new ManagedReferenceLifecycleMethodInterceptor(BasicComponentInstance.INSTANCE_KEY, method, changeMethod, lifecycleMethod));\n                        interceptors.add(interceptorFactory);\n                        if(lifecycleMethod) {\n                            configuration.addLifecycleMethod(method);\n                        }\n                    }\n                }\n            }\n        }.run();\n\n        final ClassLoader classLoader = module.getClassLoader();\n        final InterceptorFactory tcclInterceptor = new ImmediateInterceptorFactory(new ContextClassLoaderInterceptor(classLoader));\n        final InterceptorFactory privilegedInterceptor = PrivilegedWithCombinerInterceptor.getFactory();\n\n\n        if (!injectors.isEmpty()) {\n            configuration.addPostConstructInterceptors(new ArrayList<>(injectors), InterceptorOrder.ComponentPostConstruct.COMPONENT_RESOURCE_INJECTION_INTERCEPTORS);\n        }\n        // Apply post-construct\n        if (!userPostConstruct.isEmpty()) {\n            configuration.addPostConstructInterceptors(userPostConstruct, InterceptorOrder.ComponentPostConstruct.COMPONENT_USER_INTERCEPTORS);\n        }\n        configuration.addPostConstructInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPostConstruct.TERMINAL_INTERCEPTOR);\n        configuration.addPostConstructInterceptor(tcclInterceptor, InterceptorOrder.ComponentPostConstruct.TCCL_INTERCEPTOR);\n        configuration.addPostConstructInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPostConstruct.PRIVILEGED_INTERCEPTOR);\n\n        // Apply pre-destroy\n        if (!uninjectors.isEmpty()) {\n            configuration.addPreDestroyInterceptors(new ArrayList<>(uninjectors), InterceptorOrder.ComponentPreDestroy.COMPONENT_UNINJECTION_INTERCEPTORS);\n        }\n        if (!destructors.isEmpty()) {\n            configuration.addPreDestroyInterceptors(new ArrayList<>(destructors), InterceptorOrder.ComponentPreDestroy.COMPONENT_DESTRUCTION_INTERCEPTORS);\n        }\n        if (!userPreDestroy.isEmpty()) {\n            configuration.addPreDestroyInterceptors(userPreDestroy, InterceptorOrder.ComponentPreDestroy.COMPONENT_USER_INTERCEPTORS);\n        }\n        configuration.addPreDestroyInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPreDestroy.TERMINAL_INTERCEPTOR);\n        configuration.addPreDestroyInterceptor(tcclInterceptor, InterceptorOrder.ComponentPreDestroy.TCCL_INTERCEPTOR);\n        configuration.addPreDestroyInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPreDestroy.PRIVILEGED_INTERCEPTOR);\n\n        if (description.isPassivationApplicable()) {\n            if (!componentUserPrePassivate.isEmpty()) {\n                configuration.addPrePassivateInterceptors(componentUserPrePassivate, InterceptorOrder.ComponentPassivation.COMPONENT_USER_INTERCEPTORS);\n            }\n            configuration.addPrePassivateInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPassivation.TERMINAL_INTERCEPTOR);\n            configuration.addPrePassivateInterceptor(tcclInterceptor, InterceptorOrder.ComponentPassivation.TCCL_INTERCEPTOR);\n            configuration.addPrePassivateInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPassivation.PRIVILEGED_INTERCEPTOR);\n            if (!componentUserPostActivate.isEmpty()) {\n                configuration.addPostActivateInterceptors(componentUserPostActivate, InterceptorOrder.ComponentPassivation.COMPONENT_USER_INTERCEPTORS);\n            }\n            configuration.addPostActivateInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ComponentPassivation.TERMINAL_INTERCEPTOR);\n            configuration.addPostActivateInterceptor(tcclInterceptor, InterceptorOrder.ComponentPassivation.TCCL_INTERCEPTOR);\n            configuration.addPostActivateInterceptor(privilegedInterceptor, InterceptorOrder.ComponentPassivation.PRIVILEGED_INTERCEPTOR);\n        }\n\n        // @AroundInvoke interceptors\n        if (description.isIntercepted()) {\n\n            for (final Method method : configuration.getDefinedComponentMethods()) {\n\n                //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n\n                configuration.addComponentInterceptor(method, Interceptors.getInitialInterceptorFactory(), InterceptorOrder.Component.INITIAL_INTERCEPTOR);\n                configuration.addComponentInterceptor(method, new ImmediateInterceptorFactory(new ManagedReferenceMethodInterceptor(BasicComponentInstance.INSTANCE_KEY, method)), InterceptorOrder.Component.TERMINAL_INTERCEPTOR);\n\n                final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n\n                // first add the default interceptors (if not excluded) to the deque\n                final boolean requiresTimerChain = description.isTimerServiceRequired() && timeoutMethods.contains(identifier);\n                if(requiresTimerChain) {\n                    configuration.addComponentInterceptor(method, new UserInterceptorFactory(weaved(componentUserAroundInvoke), weaved(componentUserAroundTimeout)), InterceptorOrder.Component.COMPONENT_USER_INTERCEPTORS);\n                } else {\n                    configuration.addComponentInterceptors(method, componentUserAroundInvoke, InterceptorOrder.Component.COMPONENT_USER_INTERCEPTORS);\n                }\n\n            }\n        }\n\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final DeploymentClassIndex classIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.CLASS_INDEX);\n\n        final boolean metadataComplete = MetadataCompleteMarker.isMetadataComplete(deploymentUnit);\n\n        // Module stuff\n\n        final Deque<InterceptorFactory> instantiators = new ArrayDeque<>();\n        final Deque<InterceptorFactory> injectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> uninjectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> destructors = new ArrayDeque<>();\n\n\n        final Map<String, List<InterceptorFactory>> userAroundInvokesByInterceptorClass = new HashMap<>();\n        final Map<String, List<InterceptorFactory>> userAroundConstructsByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n        final Map<String, List<InterceptorFactory>> userAroundTimeoutsByInterceptorClass;\n        final Map<String, List<InterceptorFactory>> userPrePassivatesByInterceptorClass;\n        final Map<String, List<InterceptorFactory>> userPostActivatesByInterceptorClass;\n        final Map<String, List<InterceptorFactory>> userPostConstructByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n        final Map<String, List<InterceptorFactory>> userPreDestroyByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n        final Set<MethodIdentifier> timeoutMethods = description.getTimerMethods();\n        if (description.isTimerServiceRequired()) {\n            userAroundTimeoutsByInterceptorClass = new HashMap<>();\n        } else {\n            userAroundTimeoutsByInterceptorClass = null;\n        }\n\n        if (description.isPassivationApplicable()) {\n            userPrePassivatesByInterceptorClass = new HashMap<>();\n            userPostActivatesByInterceptorClass = new HashMap<>();\n        } else {\n            userPrePassivatesByInterceptorClass = null;\n            userPostActivatesByInterceptorClass = null;\n        }\n\n        //the actual component creation interceptor\n        //this really belongs in DefaultComponentConfigurator, but all the other AroundConstruct chain is assembled here\n        final InterceptorFactory instantiator;\n        // Primary instance\n        final ComponentFactory instanceFactory = configuration.getInstanceFactory();\n        if (instanceFactory != null) {\n            instantiator = new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(instanceFactory, BasicComponentInstance.INSTANCE_KEY, true));\n        } else {\n            final ClassReflectionIndex<?> componentClassIndex = deploymentReflectionIndex.getClassIndex(configuration.getComponentClass());\n            //use the default constructor if no instanceFactory has been set\n            final Constructor<?> constructor = componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY);\n            if (constructor == null) {\n                throw EeLogger.ROOT_LOGGER.defaultConstructorNotFound(configuration.getComponentClass());\n            }\n            instantiator = new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(new ConstructorComponentFactory(constructor), BasicComponentInstance.INSTANCE_KEY, true));\n        }\n\n        //all interceptors with lifecycle callbacks, in the correct order\n        final List<InterceptorDescription> interceptorWithLifecycleCallbacks = new ArrayList<InterceptorDescription>();\n        if (!description.isExcludeDefaultInterceptors()) {\n            interceptorWithLifecycleCallbacks.addAll(description.getDefaultInterceptors());\n        }\n        interceptorWithLifecycleCallbacks.addAll(description.getClassInterceptors());\n\n        for (final InterceptorDescription interceptorDescription : description.getAllInterceptors()) {\n            final String interceptorClassName = interceptorDescription.getInterceptorClassName();\n            final ClassIndex interceptorClass;\n            try {\n                interceptorClass = classIndex.classIndex(interceptorClassName);\n            } catch (ClassNotFoundException e) {\n                throw EeLogger.ROOT_LOGGER.cannotLoadInterceptor(e, interceptorClassName);\n            }\n\n            final InterceptorEnvironment interceptorEnvironment = moduleDescription.getInterceptorEnvironment().get(interceptorClassName);\n            if (interceptorEnvironment != null) {\n                //if the interceptor has environment config we merge it into the components environment\n                description.getBindingConfigurations().addAll(interceptorEnvironment.getBindingConfigurations());\n                for (final ResourceInjectionConfiguration injection : interceptorEnvironment.getResourceInjections()) {\n                    description.addResourceInjection(injection);\n                }\n            }\n\n\n            //we store the interceptor instance under the class key\n            final Object contextKey = interceptorClass.getModuleClass();\n            configuration.getInterceptorContextKeys().add(contextKey);\n\n            final ClassReflectionIndex<?> interceptorIndex = deploymentReflectionIndex.getClassIndex(interceptorClass.getModuleClass());\n            final Constructor<?> constructor = interceptorIndex.getConstructor(EMPTY_CLASS_ARRAY);\n            if (constructor == null) {\n                throw EeLogger.ROOT_LOGGER.defaultConstructorNotFoundOnComponent(interceptorClassName, configuration.getComponentClass());\n            }\n\n            instantiators.addFirst(new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(new ConstructorComponentFactory(constructor), contextKey, false)));\n            destructors.addLast(new ImmediateInterceptorFactory(new ManagedReferenceReleaseInterceptor(contextKey)));\n\n            final boolean interceptorHasLifecycleCallbacks = interceptorWithLifecycleCallbacks.contains(interceptorDescription);\n\n            new ClassDescriptionTraversal(interceptorClass.getModuleClass(), applicationClasses) {\n                @Override\n                public void handle(final Class<?> clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    mergeInjectionsForClass(clazz, interceptorClass.getModuleClass(), classDescription, moduleDescription, deploymentReflectionIndex, description, configuration, context, injectors, contextKey, uninjectors, metadataComplete);\n                    final InterceptorClassDescription interceptorConfig;\n                    if (classDescription != null && !metadataComplete) {\n                        interceptorConfig = InterceptorClassDescription.merge(classDescription.getInterceptorClassDescription(), moduleDescription.getInterceptorClassOverride(clazz.getName()));\n                    } else {\n                        interceptorConfig = InterceptorClassDescription.merge(null, moduleDescription.getInterceptorClassOverride(clazz.getName()));\n                    }\n\n                    // Only class level interceptors are processed for postconstruct/predestroy methods.\n                    // Method level interceptors aren't supposed to be processed for postconstruct/predestroy lifecycle\n                    // methods, as per interceptors spec\n                    if (interceptorHasLifecycleCallbacks && !description.isIgnoreLifecycleInterceptors()) {\n                        final MethodIdentifier postConstructMethodIdentifier = interceptorConfig.getPostConstruct();\n                        handleInterceptorClass(clazz, postConstructMethodIdentifier, userPostConstructByInterceptorClass, true, true);\n                        final MethodIdentifier preDestroyMethodIdentifier = interceptorConfig.getPreDestroy();\n                        handleInterceptorClass(clazz, preDestroyMethodIdentifier, userPreDestroyByInterceptorClass, true, true);\n                        final MethodIdentifier aroundConstructMethodIdentifier = interceptorConfig.getAroundConstruct();\n                        handleInterceptorClass(clazz, aroundConstructMethodIdentifier, userAroundConstructsByInterceptorClass, true, true);\n                    }\n                    final MethodIdentifier aroundInvokeMethodIdentifier = interceptorConfig.getAroundInvoke();\n                    handleInterceptorClass(clazz, aroundInvokeMethodIdentifier, userAroundInvokesByInterceptorClass, false, false);\n\n                    if (description.isTimerServiceRequired()) {\n                        final MethodIdentifier aroundTimeoutMethodIdentifier = interceptorConfig.getAroundTimeout();\n                        handleInterceptorClass(clazz, aroundTimeoutMethodIdentifier, userAroundTimeoutsByInterceptorClass, false, false);\n                    }\n\n                    if (description.isPassivationApplicable()) {\n                        handleInterceptorClass(clazz, interceptorConfig.getPrePassivate(), userPrePassivatesByInterceptorClass, false, false);\n                        handleInterceptorClass(clazz, interceptorConfig.getPostActivate(), userPostActivatesByInterceptorClass, false, false);\n                    }\n\n                }\n\n                private void handleInterceptorClass(final Class<?> clazz, final MethodIdentifier methodIdentifier, final Map<String, List<InterceptorFactory>> classMap, final boolean changeMethod, final boolean lifecycleMethod) throws DeploymentUnitProcessingException {\n                    if (methodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, clazz, methodIdentifier);\n                        if (isNotOverriden(clazz, method, interceptorClass.getModuleClass(), deploymentReflectionIndex)) {\n                            final InterceptorFactory interceptorFactory = new ImmediateInterceptorFactory(new ManagedReferenceLifecycleMethodInterceptor(contextKey, method, changeMethod, lifecycleMethod));\n                            List<InterceptorFactory> factories = classMap.get(interceptorClassName);\n                            if (factories == null) {\n                                classMap.put(interceptorClassName, factories = new ArrayList<InterceptorFactory>());\n                            }\n                            factories.add(interceptorFactory);\n                        }\n                    }\n                }\n            }.run();\n        }\n\n        final List<InterceptorFactory> userAroundConstruct = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPostConstruct = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPreDestroy = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPrePassivate = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPostActivate = new ArrayList<InterceptorFactory>();\n\n        //now add the lifecycle interceptors in the correct order\n        for (final InterceptorDescription interceptorClass : interceptorWithLifecycleCallbacks) {\n            if (userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n            }\n            if (userAroundConstructsByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                userAroundConstruct.addAll(userAroundConstructsByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n            }\n            if (userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n            }\n            if (description.isPassivationApplicable()) {\n                if (userPrePassivatesByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPrePassivate.addAll(userPrePassivatesByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n                if (userPostActivatesByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPostActivate.addAll(userPostActivatesByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n            }\n        }\n\n        // Apply post-construct\n\n        if (!injectors.isEmpty()) {\n            configuration.addPostConstructInterceptor(weaved(injectors), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_RESOURCE_INJECTION_INTERCEPTORS);\n        }\n        if (!instantiators.isEmpty()) {\n            configuration.addPostConstructInterceptor(weaved(instantiators), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_INSTANTIATION_INTERCEPTORS);\n        }\n        if (!userAroundConstruct.isEmpty()) {\n            configuration.addAroundConstructInterceptor(weaved(userAroundConstruct), InterceptorOrder.AroundConstruct.INTERCEPTOR_AROUND_CONSTRUCT);\n        }\n        configuration.addAroundConstructInterceptor(instantiator, InterceptorOrder.AroundConstruct.CONSTRUCT_COMPONENT);\n        configuration.addAroundConstructInterceptor(new ImmediateInterceptorFactory(Interceptors.getTerminalInterceptor()), InterceptorOrder.AroundConstruct.TERMINAL_INTERCEPTOR);\n\n        configuration.addPostConstructInterceptor(new AroundConstructInterceptorFactory(weaved(configuration.getAroundConstructInterceptors())), InterceptorOrder.ComponentPostConstruct.AROUND_CONSTRUCT_CHAIN);\n\n        if (!userPostConstruct.isEmpty()) {\n            configuration.addPostConstructInterceptor(weaved(userPostConstruct), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_USER_INTERCEPTORS);\n        }\n\n        // Apply pre-destroy\n        if (!uninjectors.isEmpty()) {\n            configuration.addPreDestroyInterceptor(weaved(uninjectors), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_UNINJECTION_INTERCEPTORS);\n        }\n        if (!destructors.isEmpty()) {\n            configuration.addPreDestroyInterceptor(weaved(destructors), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_DESTRUCTION_INTERCEPTORS);\n        }\n        if (!userPreDestroy.isEmpty()) {\n            configuration.addPreDestroyInterceptor(weaved(userPreDestroy), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_USER_INTERCEPTORS);\n        }\n\n        if (description.isPassivationApplicable()) {\n            if (!userPrePassivate.isEmpty()) {\n                configuration.addPrePassivateInterceptor(weaved(userPrePassivate), InterceptorOrder.ComponentPassivation.INTERCEPTOR_USER_INTERCEPTORS);\n            }\n\n            if (!userPostActivate.isEmpty()) {\n                configuration.addPostActivateInterceptor(weaved(userPostActivate), InterceptorOrder.ComponentPassivation.INTERCEPTOR_USER_INTERCEPTORS);\n            }\n        }\n\n        // @AroundInvoke interceptors\n        final List<InterceptorDescription> classInterceptors = description.getClassInterceptors();\n        final Map<MethodIdentifier, List<InterceptorDescription>> methodInterceptors = description.getMethodInterceptors();\n\n        if (description.isIntercepted()) {\n\n            for (final Method method : configuration.getDefinedComponentMethods()) {\n\n                //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n\n                final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n\n                final List<InterceptorFactory> userAroundInvokes = new ArrayList<InterceptorFactory>();\n                final List<InterceptorFactory> userAroundTimeouts = new ArrayList<InterceptorFactory>();\n                // first add the default interceptors (if not excluded) to the deque\n                final boolean requiresTimerChain = description.isTimerServiceRequired() && timeoutMethods.contains(identifier);\n                if (!description.isExcludeDefaultInterceptors() && !description.isExcludeDefaultInterceptors(identifier)) {\n                    for (InterceptorDescription interceptorDescription : description.getDefaultInterceptors()) {\n                        String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                        List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                        if (aroundInvokes != null) {\n                            userAroundInvokes.addAll(aroundInvokes);\n                        }\n                        if (requiresTimerChain) {\n                            List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                            if (aroundTimeouts != null) {\n                                userAroundTimeouts.addAll(aroundTimeouts);\n                            }\n                        }\n                    }\n                }\n\n                // now add class level interceptors (if not excluded) to the deque\n                if (!description.isExcludeClassInterceptors(identifier)) {\n                    for (InterceptorDescription interceptorDescription : classInterceptors) {\n                        String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                        List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                        if (aroundInvokes != null) {\n                            userAroundInvokes.addAll(aroundInvokes);\n                        }\n                        if (requiresTimerChain) {\n                            List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                            if (aroundTimeouts != null) {\n                                userAroundTimeouts.addAll(aroundTimeouts);\n                            }\n                        }\n                    }\n                }\n\n                // now add method level interceptors for to the deque so that they are triggered after the class interceptors\n                List<InterceptorDescription> methodLevelInterceptors = methodInterceptors.get(identifier);\n                if (methodLevelInterceptors != null) {\n                    for (InterceptorDescription methodLevelInterceptor : methodLevelInterceptors) {\n                        String interceptorClassName = methodLevelInterceptor.getInterceptorClassName();\n                        List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                        if (aroundInvokes != null) {\n                            userAroundInvokes.addAll(aroundInvokes);\n                        }\n                        if (requiresTimerChain) {\n                            List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                            if (aroundTimeouts != null) {\n                                userAroundTimeouts.addAll(aroundTimeouts);\n                            }\n                        }\n                    }\n                }\n                configuration.addComponentInterceptor(method, new UserInterceptorFactory(weaved(userAroundInvokes), weaved(userAroundTimeouts)), InterceptorOrder.Component.INTERCEPTOR_USER_INTERCEPTORS);\n            }\n        }\n    }","id":850,"modified_method":"public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = context.getDeploymentUnit();\n        final DeploymentReflectionIndex deploymentReflectionIndex = deploymentUnit.getAttachment(REFLECTION_INDEX);\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final DeploymentClassIndex classIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.CLASS_INDEX);\n\n        final boolean metadataComplete = MetadataCompleteMarker.isMetadataComplete(deploymentUnit);\n\n        // Module stuff\n\n        final Deque<InterceptorFactory> instantiators = new ArrayDeque<>();\n        final Deque<InterceptorFactory> injectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> uninjectors = new ArrayDeque<>();\n        final Deque<InterceptorFactory> destructors = new ArrayDeque<>();\n\n\n        final Map<String, List<InterceptorFactory>> userAroundInvokesByInterceptorClass = new HashMap<>();\n        final Map<String, List<InterceptorFactory>> userAroundConstructsByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n        final Map<String, List<InterceptorFactory>> userAroundTimeoutsByInterceptorClass;\n        final Map<String, List<InterceptorFactory>> userPrePassivatesByInterceptorClass;\n        final Map<String, List<InterceptorFactory>> userPostActivatesByInterceptorClass;\n        final Map<String, List<InterceptorFactory>> userPostConstructByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n        final Map<String, List<InterceptorFactory>> userPreDestroyByInterceptorClass = new HashMap<String, List<InterceptorFactory>>();\n\n        final Set<MethodIdentifier> timeoutMethods = description.getTimerMethods();\n        if (description.isTimerServiceRequired()) {\n            userAroundTimeoutsByInterceptorClass = new HashMap<>();\n        } else {\n            userAroundTimeoutsByInterceptorClass = null;\n        }\n\n        if (description.isPassivationApplicable()) {\n            userPrePassivatesByInterceptorClass = new HashMap<>();\n            userPostActivatesByInterceptorClass = new HashMap<>();\n        } else {\n            userPrePassivatesByInterceptorClass = null;\n            userPostActivatesByInterceptorClass = null;\n        }\n\n        //the actual component creation interceptor\n        //this really belongs in DefaultComponentConfigurator, but all the other AroundConstruct chain is assembled here\n        final InterceptorFactory instantiator;\n        // Primary instance\n        final ComponentFactory instanceFactory = configuration.getInstanceFactory();\n        if (instanceFactory != null) {\n            instantiator = new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(instanceFactory, BasicComponentInstance.INSTANCE_KEY, true));\n        } else {\n            final ClassReflectionIndex<?> componentClassIndex = deploymentReflectionIndex.getClassIndex(configuration.getComponentClass());\n            //use the default constructor if no instanceFactory has been set\n            final Constructor<?> constructor = componentClassIndex.getConstructor(EMPTY_CLASS_ARRAY);\n            if (constructor == null) {\n                throw EeLogger.ROOT_LOGGER.defaultConstructorNotFound(configuration.getComponentClass());\n            }\n            instantiator = new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(new ConstructorComponentFactory(constructor), BasicComponentInstance.INSTANCE_KEY, true));\n        }\n\n        //all interceptors with lifecycle callbacks, in the correct order\n        final List<InterceptorDescription> interceptorWithLifecycleCallbacks = new ArrayList<InterceptorDescription>();\n        if (!description.isExcludeDefaultInterceptors()) {\n            interceptorWithLifecycleCallbacks.addAll(description.getDefaultInterceptors());\n        }\n        interceptorWithLifecycleCallbacks.addAll(description.getClassInterceptors());\n\n        for (final InterceptorDescription interceptorDescription : description.getAllInterceptors()) {\n            final String interceptorClassName = interceptorDescription.getInterceptorClassName();\n            final ClassIndex interceptorClass;\n            try {\n                interceptorClass = classIndex.classIndex(interceptorClassName);\n            } catch (ClassNotFoundException e) {\n                throw EeLogger.ROOT_LOGGER.cannotLoadInterceptor(e, interceptorClassName);\n            }\n\n            final InterceptorEnvironment interceptorEnvironment = moduleDescription.getInterceptorEnvironment().get(interceptorClassName);\n            if (interceptorEnvironment != null) {\n                //if the interceptor has environment config we merge it into the components environment\n                description.getBindingConfigurations().addAll(interceptorEnvironment.getBindingConfigurations());\n                for (final ResourceInjectionConfiguration injection : interceptorEnvironment.getResourceInjections()) {\n                    description.addResourceInjection(injection);\n                }\n            }\n\n\n            //we store the interceptor instance under the class key\n            final Object contextKey = interceptorClass.getModuleClass();\n            configuration.getInterceptorContextKeys().add(contextKey);\n\n            final ClassReflectionIndex<?> interceptorIndex = deploymentReflectionIndex.getClassIndex(interceptorClass.getModuleClass());\n            final Constructor<?> constructor = interceptorIndex.getConstructor(EMPTY_CLASS_ARRAY);\n            if (constructor == null) {\n                throw EeLogger.ROOT_LOGGER.defaultConstructorNotFoundOnComponent(interceptorClassName, configuration.getComponentClass());\n            }\n\n            instantiators.addFirst(new ImmediateInterceptorFactory(new ComponentInstantiatorInterceptor(new ConstructorComponentFactory(constructor), contextKey, false)));\n            destructors.addLast(new ImmediateInterceptorFactory(new ManagedReferenceReleaseInterceptor(contextKey)));\n\n            final boolean interceptorHasLifecycleCallbacks = interceptorWithLifecycleCallbacks.contains(interceptorDescription);\n\n            new ClassDescriptionTraversal(interceptorClass.getModuleClass(), applicationClasses) {\n                @Override\n                public void handle(final Class<?> clazz, EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    mergeInjectionsForClass(clazz, interceptorClass.getModuleClass(), classDescription, moduleDescription, deploymentReflectionIndex, description, configuration, context, injectors, contextKey, uninjectors, metadataComplete);\n                    final InterceptorClassDescription interceptorConfig;\n                    if (classDescription != null && !metadataComplete) {\n                        interceptorConfig = InterceptorClassDescription.merge(classDescription.getInterceptorClassDescription(), moduleDescription.getInterceptorClassOverride(clazz.getName()));\n                    } else {\n                        interceptorConfig = InterceptorClassDescription.merge(null, moduleDescription.getInterceptorClassOverride(clazz.getName()));\n                    }\n\n                    // Only class level interceptors are processed for postconstruct/predestroy methods.\n                    // Method level interceptors aren't supposed to be processed for postconstruct/predestroy lifecycle\n                    // methods, as per interceptors spec\n                    if (interceptorHasLifecycleCallbacks && !description.isIgnoreLifecycleInterceptors()) {\n                        final MethodIdentifier postConstructMethodIdentifier = interceptorConfig.getPostConstruct();\n                        handleInterceptorClass(clazz, postConstructMethodIdentifier, userPostConstructByInterceptorClass, true, true);\n                        final MethodIdentifier preDestroyMethodIdentifier = interceptorConfig.getPreDestroy();\n                        handleInterceptorClass(clazz, preDestroyMethodIdentifier, userPreDestroyByInterceptorClass, true, true);\n                        final MethodIdentifier aroundConstructMethodIdentifier = interceptorConfig.getAroundConstruct();\n                        handleInterceptorClass(clazz, aroundConstructMethodIdentifier, userAroundConstructsByInterceptorClass, true, true);\n                    }\n                    final MethodIdentifier aroundInvokeMethodIdentifier = interceptorConfig.getAroundInvoke();\n                    handleInterceptorClass(clazz, aroundInvokeMethodIdentifier, userAroundInvokesByInterceptorClass, false, false);\n\n                    if (description.isTimerServiceRequired()) {\n                        final MethodIdentifier aroundTimeoutMethodIdentifier = interceptorConfig.getAroundTimeout();\n                        handleInterceptorClass(clazz, aroundTimeoutMethodIdentifier, userAroundTimeoutsByInterceptorClass, false, false);\n                    }\n\n                    if (description.isPassivationApplicable()) {\n                        handleInterceptorClass(clazz, interceptorConfig.getPrePassivate(), userPrePassivatesByInterceptorClass, false, false);\n                        handleInterceptorClass(clazz, interceptorConfig.getPostActivate(), userPostActivatesByInterceptorClass, false, false);\n                    }\n\n                }\n\n                private void handleInterceptorClass(final Class<?> clazz, final MethodIdentifier methodIdentifier, final Map<String, List<InterceptorFactory>> classMap, final boolean changeMethod, final boolean lifecycleMethod) throws DeploymentUnitProcessingException {\n                    if (methodIdentifier != null) {\n                        final Method method = ClassReflectionIndexUtil.findRequiredMethod(deploymentReflectionIndex, clazz, methodIdentifier);\n                        if (isNotOverriden(clazz, method, interceptorClass.getModuleClass(), deploymentReflectionIndex)) {\n                            final InterceptorFactory interceptorFactory = new ImmediateInterceptorFactory(new ManagedReferenceLifecycleMethodInterceptor(contextKey, method, changeMethod, lifecycleMethod));\n                            List<InterceptorFactory> factories = classMap.get(interceptorClassName);\n                            if (factories == null) {\n                                classMap.put(interceptorClassName, factories = new ArrayList<InterceptorFactory>());\n                            }\n                            factories.add(interceptorFactory);\n                        }\n                    }\n                }\n            }.run();\n        }\n\n        final List<InterceptorFactory> userAroundConstruct = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPostConstruct = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPreDestroy = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPrePassivate = new ArrayList<InterceptorFactory>();\n        final List<InterceptorFactory> userPostActivate = new ArrayList<InterceptorFactory>();\n\n        //now add the lifecycle interceptors in the correct order\n        for (final InterceptorDescription interceptorClass : interceptorWithLifecycleCallbacks) {\n            if (userPostConstructByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                userPostConstruct.addAll(userPostConstructByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n            }\n            if (userAroundConstructsByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                userAroundConstruct.addAll(userAroundConstructsByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n            }\n            if (userPreDestroyByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                userPreDestroy.addAll(userPreDestroyByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n            }\n            if (description.isPassivationApplicable()) {\n                if (userPrePassivatesByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPrePassivate.addAll(userPrePassivatesByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n                if (userPostActivatesByInterceptorClass.containsKey(interceptorClass.getInterceptorClassName())) {\n                    userPostActivate.addAll(userPostActivatesByInterceptorClass.get(interceptorClass.getInterceptorClassName()));\n                }\n            }\n        }\n\n        // Apply post-construct\n\n        if (!injectors.isEmpty()) {\n            configuration.addPostConstructInterceptors(new ArrayList<>(injectors), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_RESOURCE_INJECTION_INTERCEPTORS);\n        }\n        if (!instantiators.isEmpty()) {\n            configuration.addPostConstructInterceptors(new ArrayList<>(instantiators), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_INSTANTIATION_INTERCEPTORS);\n        }\n        if (!userAroundConstruct.isEmpty()) {\n            configuration.addAroundConstructInterceptors(userAroundConstruct, InterceptorOrder.AroundConstruct.INTERCEPTOR_AROUND_CONSTRUCT);\n        }\n        configuration.addAroundConstructInterceptor(instantiator, InterceptorOrder.AroundConstruct.CONSTRUCT_COMPONENT);\n        configuration.addAroundConstructInterceptor(new ImmediateInterceptorFactory(Interceptors.getTerminalInterceptor()), InterceptorOrder.AroundConstruct.TERMINAL_INTERCEPTOR);\n\n        if(!configuration.getAroundConstructInterceptors().isEmpty()) {\n            configuration.addPostConstructInterceptor(new AroundConstructInterceptorFactory(Interceptors.getChainedInterceptorFactory(configuration.getAroundConstructInterceptors())), InterceptorOrder.ComponentPostConstruct.AROUND_CONSTRUCT_CHAIN);\n        }\n        if (!userPostConstruct.isEmpty()) {\n            configuration.addPostConstructInterceptors(userPostConstruct, InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_USER_INTERCEPTORS);\n        }\n\n        // Apply pre-destroy\n        if (!uninjectors.isEmpty()) {\n            configuration.addPreDestroyInterceptors(new ArrayList<>(uninjectors), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_UNINJECTION_INTERCEPTORS);\n        }\n        if (!destructors.isEmpty()) {\n            configuration.addPreDestroyInterceptors(new ArrayList<>(destructors), InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_DESTRUCTION_INTERCEPTORS);\n        }\n        if (!userPreDestroy.isEmpty()) {\n            configuration.addPreDestroyInterceptors(userPreDestroy, InterceptorOrder.ComponentPreDestroy.INTERCEPTOR_USER_INTERCEPTORS);\n        }\n\n        if (description.isPassivationApplicable()) {\n            if (!userPrePassivate.isEmpty()) {\n                configuration.addPrePassivateInterceptors(userPrePassivate, InterceptorOrder.ComponentPassivation.INTERCEPTOR_USER_INTERCEPTORS);\n            }\n\n            if (!userPostActivate.isEmpty()) {\n                configuration.addPostActivateInterceptors(userPostActivate, InterceptorOrder.ComponentPassivation.INTERCEPTOR_USER_INTERCEPTORS);\n            }\n        }\n\n        // @AroundInvoke interceptors\n        final List<InterceptorDescription> classInterceptors = description.getClassInterceptors();\n        final Map<MethodIdentifier, List<InterceptorDescription>> methodInterceptors = description.getMethodInterceptors();\n\n        if (description.isIntercepted()) {\n\n            for (final Method method : configuration.getDefinedComponentMethods()) {\n\n                //now add the interceptor that initializes and the interceptor that actually invokes to the end of the interceptor chain\n\n                final MethodIdentifier identifier = MethodIdentifier.getIdentifier(method.getReturnType(), method.getName(), method.getParameterTypes());\n\n                final List<InterceptorFactory> userAroundInvokes = new ArrayList<InterceptorFactory>();\n                final List<InterceptorFactory> userAroundTimeouts = new ArrayList<InterceptorFactory>();\n                // first add the default interceptors (if not excluded) to the deque\n                final boolean requiresTimerChain = description.isTimerServiceRequired() && timeoutMethods.contains(identifier);\n                if (!description.isExcludeDefaultInterceptors() && !description.isExcludeDefaultInterceptors(identifier)) {\n                    for (InterceptorDescription interceptorDescription : description.getDefaultInterceptors()) {\n                        String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                        List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                        if (aroundInvokes != null) {\n                            userAroundInvokes.addAll(aroundInvokes);\n                        }\n                        if (requiresTimerChain) {\n                            List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                            if (aroundTimeouts != null) {\n                                userAroundTimeouts.addAll(aroundTimeouts);\n                            }\n                        }\n                    }\n                }\n\n                // now add class level interceptors (if not excluded) to the deque\n                if (!description.isExcludeClassInterceptors(identifier)) {\n                    for (InterceptorDescription interceptorDescription : classInterceptors) {\n                        String interceptorClassName = interceptorDescription.getInterceptorClassName();\n                        List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                        if (aroundInvokes != null) {\n                            userAroundInvokes.addAll(aroundInvokes);\n                        }\n                        if (requiresTimerChain) {\n                            List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                            if (aroundTimeouts != null) {\n                                userAroundTimeouts.addAll(aroundTimeouts);\n                            }\n                        }\n                    }\n                }\n\n                // now add method level interceptors for to the deque so that they are triggered after the class interceptors\n                List<InterceptorDescription> methodLevelInterceptors = methodInterceptors.get(identifier);\n                if (methodLevelInterceptors != null) {\n                    for (InterceptorDescription methodLevelInterceptor : methodLevelInterceptors) {\n                        String interceptorClassName = methodLevelInterceptor.getInterceptorClassName();\n                        List<InterceptorFactory> aroundInvokes = userAroundInvokesByInterceptorClass.get(interceptorClassName);\n                        if (aroundInvokes != null) {\n                            userAroundInvokes.addAll(aroundInvokes);\n                        }\n                        if (requiresTimerChain) {\n                            List<InterceptorFactory> aroundTimeouts = userAroundTimeoutsByInterceptorClass.get(interceptorClassName);\n                            if (aroundTimeouts != null) {\n                                userAroundTimeouts.addAll(aroundTimeouts);\n                            }\n                        }\n                    }\n                }\n                if(requiresTimerChain) {\n                    configuration.addComponentInterceptor(method, new UserInterceptorFactory(weaved(userAroundInvokes), weaved(userAroundTimeouts)), InterceptorOrder.Component.INTERCEPTOR_USER_INTERCEPTORS);\n                } else {\n                    configuration.addComponentInterceptors(method, userAroundInvokes, InterceptorOrder.Component.INTERCEPTOR_USER_INTERCEPTORS);\n\n                }\n            }\n        }\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tpublic void init(Ability source, Game game) {\n\t\tsuper.init(source, game);\n\t\tif (this.affectedObjectsSet) {\n\t\t\tfor (Permanent perm: game.getBattlefield().getAllActivePermanents(filter)) {\n\t\t\t\tif (!(excludeSource && perm.getId().equals(source.getSourceId()))) {\n\t\t\t\t\tobjects.add(perm.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":851,"modified_method":"@Override\n\tpublic void init(Ability source, Game game) {\n\t\tsuper.init(source, game);\n\t\tif (this.affectedObjectsSet) {\n\t\t\tfor (Permanent perm: game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\n\t\t\t\tif (!(excludeSource && perm.getId().equals(source.getSourceId()))) {\n\t\t\t\t\tobjects.add(perm.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"954052b64e5bc94af1a46d93c13eadd9100a6dfb","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tfor (Permanent perm: game.getBattlefield().getAllActivePermanents(filter)) {\n\t\t\tif (!this.affectedObjectsSet || objects.contains(perm.getId())) {\n\t\t\t\tif (!(excludeSource && perm.getId().equals(source.getSourceId()))) {\n\t\t\t\t\tperm.addPower(power.calculate(game, source));\n\t\t\t\t\tperm.addToughness(toughness.calculate(game, source));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":852,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tfor (Permanent perm: game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {\n\t\t\tif (!this.affectedObjectsSet || objects.contains(perm.getId())) {\n\t\t\t\tif (!(excludeSource && perm.getId().equals(source.getSourceId()))) {\n\t\t\t\t\tperm.addPower(power.calculate(game, source));\n\t\t\t\t\tperm.addToughness(toughness.calculate(game, source));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"954052b64e5bc94af1a46d93c13eadd9100a6dfb","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n\tpublic boolean apply(Game game, Ability source) {\r\n\t\tFilterCreaturePermanent filter = new FilterCreaturePermanent();\r\n\t\tfilter.getControllerId().add(source.getControllerId());\r\n\r\n\t\tList<Permanent> creatures = game.getBattlefield().getAllActivePermanents(filter);\r\n\r\n\t\tfor ( Permanent creature : creatures ) {\r\n\t\t\tif ( !creature.getId().equals(source.getSourceId()) ) {\r\n\t\t\t\tcreature.untap(game);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}","id":853,"modified_method":"@Override\r\n\tpublic boolean apply(Game game, Ability source) {\r\n\t\tFilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();\r\n\r\n\t\tList<Permanent> creatures = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);\r\n\r\n\t\tfor ( Permanent creature : creatures ) {\r\n\t\t\tif ( !creature.getId().equals(source.getSourceId()) ) {\r\n\t\t\t\tcreature.untap(game);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}","commit_id":"8d12b34c6d4a8162e87c281864c028f70fec05c8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n\tpublic boolean apply(Game game, Ability source) {\r\n\t\tboolean applied = false;\r\n\t\tList<Permanent> permanents = game.getBattlefield().getAllActivePermanents(filter);\r\n\r\n\t\tif ( permanents != null && !permanents.isEmpty() ) {\r\n\t\t\tfor ( Permanent permanent : permanents ) {\r\n\t\t\t\tfor ( Ability ability : permanent.getAbilities() ) {\r\n\t\t\t\t\tif ( !(ability instanceof SpellAbility) && ability.getManaCosts() != null ) {\r\n\t\t\t\t\t\tint costCount = ability.getManaCosts().size();\r\n\t\t\t\t\t\tfor ( Cost cost : ability.getManaCosts() ) {\r\n\t\t\t\t\t\t\tif ( cost instanceof GenericManaCost ) {\r\n\t\t\t\t\t\t\t\tGenericManaCost costCasted = (GenericManaCost)cost;\r\n\t\t\t\t\t\t\t\tint amount = costCasted.convertedManaCost();\r\n\t\t\t\t\t\t\t\tint adjustedAmount = 0;\r\n\t\t\t\t\t\t\t\tif ( costCount == 1 && (amount - 2) <= 0 ) {\r\n\t\t\t\t\t\t\t\t\tadjustedAmount = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t//In case the adjusted amount goes below 0.\r\n\t\t\t\t\t\t\t\t\tadjustedAmount = Math.max(0, amount - 2);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcostCasted.setMana(adjustedAmount);\r\n\t\t\t\t\t\t\t\tapplied = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn applied;\r\n\t}","id":854,"modified_method":"@Override\r\n\tpublic boolean apply(Game game, Ability source) {\r\n\t\tboolean applied = false;\r\n\t\tList<Permanent> permanents = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);\r\n\r\n\t\tif ( permanents != null && !permanents.isEmpty() ) {\r\n\t\t\tfor ( Permanent permanent : permanents ) {\r\n\t\t\t\tfor ( Ability ability : permanent.getAbilities() ) {\r\n\t\t\t\t\tif ( !(ability instanceof SpellAbility) && ability.getManaCosts() != null ) {\r\n\t\t\t\t\t\tint costCount = ability.getManaCosts().size();\r\n\t\t\t\t\t\tfor ( Cost cost : ability.getManaCosts() ) {\r\n\t\t\t\t\t\t\tif ( cost instanceof GenericManaCost ) {\r\n\t\t\t\t\t\t\t\tGenericManaCost costCasted = (GenericManaCost)cost;\r\n\t\t\t\t\t\t\t\tint amount = costCasted.convertedManaCost();\r\n\t\t\t\t\t\t\t\tint adjustedAmount = 0;\r\n\t\t\t\t\t\t\t\tif ( costCount == 1 && (amount - 2) <= 0 ) {\r\n\t\t\t\t\t\t\t\t\tadjustedAmount = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t//In case the adjusted amount goes below 0.\r\n\t\t\t\t\t\t\t\t\tadjustedAmount = Math.max(0, amount - 2);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcostCasted.setMana(adjustedAmount);\r\n\t\t\t\t\t\t\t\tapplied = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn applied;\r\n\t}","commit_id":"8d12b34c6d4a8162e87c281864c028f70fec05c8","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Update the last modified of this node\n     */\n    private void updateLastModified() {\n        synchronized ( this.backgroundLock ) {\n            try {\n                final Node slingNode = this.createPath(this.idNodePath.substring(1));\n                slingNode.setProperty(LAST_MODIFIED_PROP, System.currentTimeMillis());\n                this.backgroundSession.save();\n                logger.debug(\"Heartbeat at {}\", Environment.APPLICATION_ID);\n            } catch (final RepositoryException re) {\n                this.ignoreException(re);\n            }\n        }\n    }","id":855,"modified_method":"/**\n     * Update the last modified of this node\n     */\n    private void updateLastModified() {\n        synchronized ( this.backgroundLock ) {\n            try {\n                final Node slingNode = this.createPath(this.idNodePath.substring(1));\n                slingNode.setProperty(LAST_MODIFIED_PROP, System.currentTimeMillis());\n                this.backgroundSession.save();\n                logger.debug(\"Heartbeat at {}\", Environment.APPLICATION_ID);\n            } catch (final RepositoryException re) {\n                this.ignoreException(re);\n                try {\n                    this.backgroundSession.refresh(false);\n                } catch (final RepositoryException ignore) {\n                    this.ignoreException(ignore);\n                }\n            }\n        }\n    }","commit_id":"551a563af222b4da08ccfc5e362ca3cc6fbc3e4c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Reschedule the job\n     */\n    public boolean reschedule(final JobEvent info) {\n        final String path = this.getNodePath(info.uniqueId);\n        synchronized ( this.backgroundLock ) {\n            try {\n                if ( this.backgroundSession.itemExists(path) ) {\n                    final Node eventNode = (Node)this.backgroundSession.getItem(path);\n                    if ( info.event.getProperty(JobUtil.PROPERTY_JOB_RETRIES) != null ) {\n                        eventNode.setProperty(JobUtil.PROPERTY_JOB_RETRIES, (Integer)info.event.getProperty(JobUtil.PROPERTY_JOB_RETRIES));\n                    }\n                    if ( info.event.getProperty(JobUtil.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                        eventNode.setProperty(JobUtil.PROPERTY_JOB_RETRY_COUNT, (Integer)info.event.getProperty(JobUtil.PROPERTY_JOB_RETRY_COUNT));\n                    }\n                    eventNode.setProperty(JCRHelper.NODE_PROPERTY_PROCESSOR, Environment.APPLICATION_ID);\n                    this.backgroundSession.save();\n\n                    // and unlock\n                    this.lockManager.unlock(this.backgroundSession, path);\n                    ((DefaultJobManager)this.jobManager).notifyRescheduleJob(info.uniqueId);\n                    return true;\n                }\n            } catch (RepositoryException re) {\n                // there is nothing we can do\n                this.ignoreException(re);\n            }\n        }\n        ((DefaultJobManager)this.jobManager).notifyRemoveJob(info.uniqueId);\n        return false;\n    }","id":856,"modified_method":"/**\n     * Reschedule the job\n     */\n    public boolean reschedule(final JobEvent info) {\n        final String path = this.getNodePath(info.uniqueId);\n        synchronized ( this.backgroundLock ) {\n            try {\n                if ( this.backgroundSession.itemExists(path) ) {\n                    final Node eventNode = (Node)this.backgroundSession.getItem(path);\n                    if ( info.event.getProperty(JobUtil.PROPERTY_JOB_RETRIES) != null ) {\n                        eventNode.setProperty(JobUtil.PROPERTY_JOB_RETRIES, (Integer)info.event.getProperty(JobUtil.PROPERTY_JOB_RETRIES));\n                    }\n                    if ( info.event.getProperty(JobUtil.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                        eventNode.setProperty(JobUtil.PROPERTY_JOB_RETRY_COUNT, (Integer)info.event.getProperty(JobUtil.PROPERTY_JOB_RETRY_COUNT));\n                    }\n                    eventNode.setProperty(JCRHelper.NODE_PROPERTY_PROCESSOR, Environment.APPLICATION_ID);\n                    this.backgroundSession.save();\n\n                    // and unlock\n                    this.lockManager.unlock(this.backgroundSession, path);\n                    ((DefaultJobManager)this.jobManager).notifyRescheduleJob(info.uniqueId);\n                    return true;\n                }\n            } catch (RepositoryException re) {\n                // there is nothing we can do\n                this.ignoreException(re);\n                try {\n                    this.backgroundSession.refresh(false);\n                } catch (final RepositoryException ignore) {\n                    this.ignoreException(ignore);\n                }\n            }\n        }\n        ((DefaultJobManager)this.jobManager).notifyRemoveJob(info.uniqueId);\n        return false;\n    }","commit_id":"551a563af222b4da08ccfc5e362ca3cc6fbc3e4c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Write an event to the repository.\n     * @param rootNode The root node for all jobs\n     * @param e The event\n     * @param suggestedName A suggested name/path for the node.\n     * @throws RepositoryException\n     */\n    private Node writeEvent(final Node rootNode, final Event e, final String path)\n    throws RepositoryException {\n        // create new node with name of topic\n        final Node eventNode = this.createPath(rootNode,\n                path,\n                JCRHelper.JOB_NODE_TYPE);\n        JCRHelper.writeEventProperties(eventNode, e);\n\n        eventNode.setProperty(JCRHelper.NODE_PROPERTY_CREATED, Calendar.getInstance());\n        eventNode.setProperty(JCRHelper.NODE_PROPERTY_APPLICATION, Environment.APPLICATION_ID);\n\n        // job topic\n        eventNode.setProperty(JCRHelper.NODE_PROPERTY_TOPIC, (String)e.getProperty(JobUtil.PROPERTY_JOB_TOPIC));\n        // job id\n        final String jobId = (String)e.getProperty(JobUtil.PROPERTY_JOB_NAME);\n        if ( jobId != null ) {\n            eventNode.setProperty(JCRHelper.NODE_PROPERTY_JOBID, jobId);\n        }\n        rootNode.getSession().save();\n        return eventNode;\n    }","id":857,"modified_method":"/**\n     * Write an event to the repository.\n     * @param rootNode The root node for all jobs\n     * @param e The event\n     * @param suggestedName A suggested name/path for the node.\n     * @throws RepositoryException\n     */\n    private Node writeEvent(final Node rootNode, final Event e, final String path)\n    throws RepositoryException {\n        // create new node with name of topic\n        final Node eventNode = this.createPath(rootNode,\n                path,\n                JCRHelper.JOB_NODE_TYPE);\n        JCRHelper.writeEventProperties(eventNode, e);\n\n        eventNode.setProperty(JCRHelper.NODE_PROPERTY_CREATED, Calendar.getInstance());\n        eventNode.setProperty(JCRHelper.NODE_PROPERTY_APPLICATION, Environment.APPLICATION_ID);\n\n        // job topic\n        eventNode.setProperty(JCRHelper.NODE_PROPERTY_TOPIC, (String)e.getProperty(JobUtil.PROPERTY_JOB_TOPIC));\n        // job id\n        final String jobId = (String)e.getProperty(JobUtil.PROPERTY_JOB_NAME);\n        if ( jobId != null ) {\n            eventNode.setProperty(JCRHelper.NODE_PROPERTY_JOBID, jobId);\n        }\n        boolean refresh = true;\n        try {\n            rootNode.getSession().save();\n            refresh = false;\n        } finally {\n            if ( refresh ) {\n                try {\n                    rootNode.getSession().refresh(false);\n                } catch (final RepositoryException ignore) {\n                    this.ignoreException(ignore);\n                }\n            }\n        }\n        return eventNode;\n    }","commit_id":"551a563af222b4da08ccfc5e362ca3cc6fbc3e4c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Remove the job - if not currently in processing.\n     */\n    public boolean remove(final String jobId) {\n        if ( this.backgroundSession != null && jobId != null ) {\n            final String path = this.getNodePath(jobId);\n            synchronized ( this.backgroundLock ) {\n                try {\n                    if ( this.backgroundSession.itemExists(path) ) {\n                        final Node eventNode = (Node) this.backgroundSession.getItem(path);\n                        if ( eventNode.isLocked() ) {\n                            this.logger.debug(\"Attempted to cancel a running job at {}\", path);\n                            return false;\n                        }\n                        // try to load job to send notification\n                        try {\n                            final Event job = this.forceReadEvent(eventNode);\n                            Utility.sendNotification(this.environment, JobUtil.TOPIC_JOB_CANCELLED, job, null);\n                        } catch (RepositoryException ignore) {\n                            this.ignoreException(ignore);\n                        }\n                        eventNode.remove();\n                        this.backgroundSession.save();\n                        ((DefaultJobManager)this.jobManager).notifyRemoveJob(jobId);\n                    }\n                } catch (RepositoryException e) {\n                    this.logger.error(\"Error during cancelling job at \" + path, e);\n                }\n            }\n        }\n        return true;\n    }","id":858,"modified_method":"/**\n     * Remove the job - if not currently in processing.\n     */\n    public boolean remove(final String jobId) {\n        if ( this.backgroundSession != null && jobId != null ) {\n            final String path = this.getNodePath(jobId);\n            synchronized ( this.backgroundLock ) {\n                try {\n                    if ( this.backgroundSession.itemExists(path) ) {\n                        final Node eventNode = (Node) this.backgroundSession.getItem(path);\n                        if ( eventNode.isLocked() ) {\n                            this.logger.debug(\"Attempted to cancel a running job at {}\", path);\n                            return false;\n                        }\n                        // try to load job to send notification\n                        try {\n                            final Event job = this.forceReadEvent(eventNode);\n                            Utility.sendNotification(this.environment, JobUtil.TOPIC_JOB_CANCELLED, job, null);\n                        } catch (RepositoryException ignore) {\n                            this.ignoreException(ignore);\n                        }\n                        eventNode.remove();\n                        this.backgroundSession.save();\n                        ((DefaultJobManager)this.jobManager).notifyRemoveJob(jobId);\n                    }\n                } catch (RepositoryException e) {\n                    this.logger.error(\"Error during cancelling job at \" + path, e);\n                    try {\n                        this.backgroundSession.refresh(false);\n                    } catch (final RepositoryException ignore) {\n                        this.ignoreException(ignore);\n                    }\n                }\n            }\n        }\n        return true;\n    }","commit_id":"551a563af222b4da08ccfc5e362ca3cc6fbc3e4c","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Finish the job\n     */\n    public void finished(final JobEvent info) {\n        final String jobId = (String)info.event.getProperty(JobUtil.PROPERTY_JOB_NAME);\n        final String path = this.getNodePath(info.uniqueId);\n        synchronized ( this.backgroundLock ) {\n            if ( !this.running ) {\n                return;\n            }\n            try {\n                ((DefaultJobManager)this.jobManager).notifyRemoveJob(info.uniqueId);\n                if ( this.backgroundSession.itemExists(path) ) {\n                    final Node eventNode = (Node)this.backgroundSession.getItem(path);\n                    if ( jobId == null ) {\n                        // simply remove the node\n                        eventNode.remove();\n                    } else {\n                        eventNode.setProperty(JCRHelper.NODE_PROPERTY_FINISHED, Calendar.getInstance());\n                        eventNode.setProperty(JCRHelper.NODE_PROPERTY_PROCESSOR, Environment.APPLICATION_ID);\n                    }\n                    this.backgroundSession.save();\n                    // and unlock\n                    if ( jobId != null && eventNode.isLocked() ) {\n                        this.lockManager.unlock(this.backgroundSession, path);\n                    }\n                }\n            } catch (RepositoryException re) {\n                // there is nothing we can do\n                this.ignoreException(re);\n            }\n        }\n    }","id":859,"modified_method":"/**\n     * Finish the job\n     */\n    public void finished(final JobEvent info) {\n        final String jobId = (String)info.event.getProperty(JobUtil.PROPERTY_JOB_NAME);\n        final String path = this.getNodePath(info.uniqueId);\n        synchronized ( this.backgroundLock ) {\n            if ( !this.running ) {\n                return;\n            }\n            try {\n                ((DefaultJobManager)this.jobManager).notifyRemoveJob(info.uniqueId);\n                if ( this.backgroundSession.itemExists(path) ) {\n                    final Node eventNode = (Node)this.backgroundSession.getItem(path);\n                    if ( jobId == null ) {\n                        // simply remove the node\n                        eventNode.remove();\n                    } else {\n                        eventNode.setProperty(JCRHelper.NODE_PROPERTY_FINISHED, Calendar.getInstance());\n                        eventNode.setProperty(JCRHelper.NODE_PROPERTY_PROCESSOR, Environment.APPLICATION_ID);\n                    }\n                    this.backgroundSession.save();\n                    // and unlock\n                    if ( jobId != null && eventNode.isLocked() ) {\n                        this.lockManager.unlock(this.backgroundSession, path);\n                    }\n                }\n            } catch (final RepositoryException re) {\n                // there is nothing we can do\n                this.ignoreException(re);\n                try {\n                    this.backgroundSession.refresh(false);\n                } catch (final RepositoryException ignore) {\n                    this.ignoreException(ignore);\n                }\n            }\n        }\n    }","commit_id":"551a563af222b4da08ccfc5e362ca3cc6fbc3e4c","url":"https://github.com/apache/sling"},{"original_method":"@Override\r\n  public synchronized int count(final IndexToken it) {\r\n    if(it instanceof RangeToken) return idRange((RangeToken) it).size();\r\n\r\n    final byte[] key = it.get();\r\n    if(key.length > data.meta.maxlen) return Integer.MAX_VALUE;\r\n\r\n    final int id = cache.id(key);\r\n    if(id > 0) return cache.size(id);\r\n\r\n    final int ix = get(key);\r\n    if(ix < 0) return 0;\r\n    // get position in heap file\r\n    final long pos = idxr.read5(ix * 5L);\r\n    // the first heap entry represents the number of hits\r\n    final int nr = idxl.readNum(pos);\r\n    cache.add(key, nr, pos + Num.length(nr));\r\n    return nr;\r\n  }","id":860,"modified_method":"@Override\r\n  public synchronized int count(final IndexToken it) {\r\n    if(it instanceof RangeToken) return idRange((RangeToken) it).size();\r\n\r\n    final byte[] key = it.get();\r\n    if(key.length > data.meta.maxlen) return Integer.MAX_VALUE;\r\n\r\n    final CacheEntry e = cache.get(key);\r\n    if(e != null) return e.size;\r\n\r\n    final int ix = get(key);\r\n    if(ix < 0) return 0;\r\n    // get position in heap file\r\n    final long pos = idxr.read5(ix * 5L);\r\n    // the first heap entry represents the number of hits\r\n    final int nr = idxl.readNum(pos);\r\n    cache.add(key, nr, pos + Num.length(nr));\r\n    return nr;\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public synchronized IndexIterator iter(final IndexToken tok) {\r\n    if(tok instanceof RangeToken) return idRange((RangeToken) tok);\r\n\r\n    final int id = cache.id(tok.get());\r\n    if(id > 0) return iter(cache.size(id), cache.pointer(id));\r\n\r\n    final int ix = get(tok.get());\r\n    if(ix < 0) return IndexIterator.EMPTY;\r\n    final long pos = idxr.read5(ix * 5L);\r\n    return iter(idxl.readNum(pos), idxl.cursor());\r\n  }","id":861,"modified_method":"@Override\r\n  public synchronized IndexIterator iter(final IndexToken tok) {\r\n    if(tok instanceof RangeToken) return idRange((RangeToken) tok);\r\n\r\n    final byte[] key = tok.get();\r\n\r\n    final CacheEntry e = cache.get(key);\r\n    if(e != null) return iter(e.size, e.pointer);\r\n\r\n    final int ix = get(key);\r\n    if(ix < 0) return IndexIterator.EMPTY;\r\n    final long pos = idxr.read5(ix * 5L);\r\n    return iter(idxl.readNum(pos), idxl.cursor());\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public synchronized IndexIterator iter(final IndexToken ind) {\r\n    final byte[] tok = ind.get();\r\n\r\n    // support fuzzy search\r\n    if(((FTLexer) ind).ftOpt().is(FZ)) {\r\n      int k = data.meta.prop.num(Prop.LSERROR);\r\n      if(k == 0) k = tok.length >> 2;\r\n      return fuzzy(tok, k, false);\r\n    }\r\n\r\n    // return cached or new result\r\n    final int id = cache.id(tok);\r\n    if(id == 0) {\r\n      final int p = token(tok);\r\n      return p > -1 ? iter(pointer(p, tok.length),\r\n          size(p, tok.length), inZ, false) : FTIndexIterator.FTEMPTY;\r\n    }\r\n    return iter(cache.pointer(id), cache.size(id), inZ, false);\r\n  }","id":862,"modified_method":"@Override\r\n  public synchronized IndexIterator iter(final IndexToken ind) {\r\n    final byte[] tok = ind.get();\r\n\r\n    // support fuzzy search\r\n    if(((FTLexer) ind).ftOpt().is(FZ)) {\r\n      int k = data.meta.prop.num(Prop.LSERROR);\r\n      if(k == 0) k = tok.length >> 2;\r\n      return fuzzy(tok, k, false);\r\n    }\r\n\r\n    // return cached or new result\r\n    final CacheEntry e = cache.get(tok);\r\n    if(e != null) return iter(e.pointer, e.size, inZ, false);\r\n\r\n    final int p = token(tok);\r\n    return p > -1 ? iter(pointer(p, tok.length),\r\n        size(p, tok.length), inZ, false) : FTIndexIterator.FTEMPTY;\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public synchronized int count(final IndexToken ind) {\r\n    if(ind.get().length > data.meta.maxlen) return Integer.MAX_VALUE;\r\n\r\n    // estimate costs for queries which stretch over multiple index entries\r\n    final FTLexer lex = (FTLexer) ind;\r\n    if(lex.ftOpt().is(FZ)) return Math.max(1, data.meta.size / 10);\r\n\r\n    final byte[] tok = lex.get();\r\n    final int id = cache.id(tok);\r\n    if(id > 0) return cache.size(id);\r\n\r\n    int s = 0;\r\n    long poi = 0;\r\n    final long p = token(tok);\r\n    if(p > -1) {\r\n      s = size(p, tok.length);\r\n      poi = pointer(p, tok.length);\r\n    }\r\n    cache.add(tok, s, poi);\r\n    return s;\r\n  }","id":863,"modified_method":"@Override\r\n  public synchronized int count(final IndexToken ind) {\r\n    if(ind.get().length > data.meta.maxlen) return Integer.MAX_VALUE;\r\n\r\n    // estimate costs for queries which stretch over multiple index entries\r\n    final FTLexer lex = (FTLexer) ind;\r\n    if(lex.ftOpt().is(FZ)) return Math.max(1, data.meta.size / 10);\r\n\r\n    final byte[] tok = lex.get();\r\n    final CacheEntry e = cache.get(tok);\r\n    if(e != null) return e.size;\r\n\r\n    int s = 0;\r\n    long poi = 0;\r\n    final long p = token(tok);\r\n    if(p > -1) {\r\n      s = size(p, tok.length);\r\n      poi = pointer(p, tok.length);\r\n    }\r\n    cache.add(tok, s, poi);\r\n    return s;\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public synchronized IndexIterator iter(final IndexToken ind) {\r\n    final byte[] token = ind.get();\r\n\r\n    // support fuzzy search\r\n    final FTLexer lex = (FTLexer) ind;\r\n    if(lex.ftOpt().is(FZ)) {\r\n      int k = data.meta.prop.num(Prop.LSERROR);\r\n      if(k == 0) k = token.length >> 2;\r\n      return fuzzy(0, null, -1, token, 0, 0, 0, k, false);\r\n    }\r\n\r\n    // support wildcards\r\n    if(lex.ftOpt().is(WC)) {\r\n      final int pw = indexOf(token, '.');\r\n      if(pw != -1) return wc(token, pw, false);\r\n    }\r\n\r\n    // return cached or new result\r\n    final int id = cache.id(token);\r\n    return id == 0 ? iter(0, token, false) :\r\n      iter(cache.pointer(id), cache.size(id), inB, false);\r\n  }","id":864,"modified_method":"@Override\r\n  public synchronized IndexIterator iter(final IndexToken ind) {\r\n    final byte[] token = ind.get();\r\n\r\n    // support fuzzy search\r\n    final FTLexer lex = (FTLexer) ind;\r\n    if(lex.ftOpt().is(FZ)) {\r\n      int k = data.meta.prop.num(Prop.LSERROR);\r\n      if(k == 0) k = token.length >> 2;\r\n      return fuzzy(0, null, -1, token, 0, 0, 0, k, false);\r\n    }\r\n\r\n    // support wildcards\r\n    if(lex.ftOpt().is(WC)) {\r\n      final int pw = indexOf(token, '.');\r\n      if(pw != -1) return wc(token, pw, false);\r\n    }\r\n\r\n    // return cached or new result\r\n    final CacheEntry e = cache.get(token);\r\n    return e == null ? iter(0, token, false) :\r\n      iter(e.pointer, e.size, inB, false);\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public synchronized int count(final IndexToken ind) {\r\n    if(ind.get().length > data.meta.maxlen) return Integer.MAX_VALUE;\r\n\r\n    // estimate costs for queries which stretch over multiple index entries\r\n    final FTLexer lex = (FTLexer) ind;\r\n    if(lex.ftOpt().is(FZ) || lex.ftOpt().is(WC))\r\n      return Math.max(1, data.meta.size / 10);\r\n\r\n    final byte[] token = lex.get();\r\n    final int id = cache.id(token);\r\n    if(id > 0) return cache.size(id);\r\n\r\n    int size = 0;\r\n    long poi = 0;\r\n    final int[] node = node(token, 0);\r\n    if(node != null && node[node.length - 1] > 0) {\r\n      size = node[node.length - 1];\r\n      poi = currID;\r\n    }\r\n    cache.add(token, size, poi);\r\n    return size;\r\n  }","id":865,"modified_method":"@Override\r\n  public synchronized int count(final IndexToken ind) {\r\n    if(ind.get().length > data.meta.maxlen) return Integer.MAX_VALUE;\r\n\r\n    // estimate costs for queries which stretch over multiple index entries\r\n    final FTLexer lex = (FTLexer) ind;\r\n    if(lex.ftOpt().is(FZ) || lex.ftOpt().is(WC))\r\n      return Math.max(1, data.meta.size / 10);\r\n\r\n    final byte[] token = lex.get();\r\n    final CacheEntry e = cache.get(token);\r\n    if(e != null) return e.size;\r\n\r\n    int size = 0;\r\n    long poi = 0;\r\n    final int[] node = node(token, 0);\r\n    if(node != null && node[node.length - 1] > 0) {\r\n      size = node[node.length - 1];\r\n      poi = currID;\r\n    }\r\n    cache.add(token, size, poi);\r\n    return size;\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the size for the specified key.\r\n   * @param id id of the key to be found\r\n   * @return size\r\n   */\r\n  public int size(final int id) {\r\n    return sizes[id];\r\n  }","id":866,"modified_method":"/**\r\n   * Rehashes the contents of the cache into a new array with larger capacity.\r\n   * @param newCapacity new capacity; MUST be a power of two\r\n   */\r\n  private void resize(final int newCapacity) {\r\n    purge();\r\n\r\n    final BucketEntry[] newBucket = new BucketEntry[newCapacity];\r\n    transfer(bucket, newBucket);\r\n    bucket = newBucket;\r\n\r\n    threshold = (int) (newCapacity * loadFactor);\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Indexes the specified keys and values.\r\n   * @param key key\r\n   * @param s size\r\n   * @param p pointer\r\n   */\r\n  public void add(final byte[] key, final int s, final long p) {\r\n    final int i = add(key);\r\n    if(i > 0) {\r\n      sizes[i] = s;\r\n      pointers[i] = p;\r\n    }\r\n  }","id":867,"modified_method":"/**\r\n   * Add a new cache entry. If an entry with the specified key already exists,\r\n   * it will be updated.\r\n   * @param key key\r\n   * @param s number of index hits\r\n   * @param p pointer to id list\r\n   */\r\n  public void add(final byte[] key, final int s, final long p) {\r\n    purge();\r\n\r\n    final int hash = hash(key);\r\n    final int i = indexFor(hash, bucket.length);\r\n\r\n    BucketEntry e = bucket[i];\r\n    BucketEntry prev = e;\r\n    while(e != null) {\r\n      final BucketEntry next = e.next;\r\n      final CacheEntry entry = e.get();\r\n      if(entry == null) {\r\n        delete(i, e, prev, next);\r\n      } else if(e.hash == hash && (entry.key == key || eq(entry.key, key))) {\r\n        entry.size = s;\r\n        entry.pointer = p;\r\n        return;\r\n      }\r\n\r\n      prev = e;\r\n      e = next;\r\n    }\r\n\r\n    e = bucket[i];\r\n    bucket[i] = new BucketEntry(hash, e, new CacheEntry(key, s, p), queue);\r\n    if(++size >= threshold) resize(2 * bucket.length);\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Remove record ids from the index.\r\n   * @param ix index of the key\r\n   * @param key record key\r\n   * @param ids list of record ids to delete\r\n   * @return number of remaining records\r\n   */\r\n  private int deleteIds(final int ix, final byte[] key, final int[] ids) {\r\n    final long pos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(pos);\r\n\r\n    if(numold == ids.length) {\r\n      // all ids should be deteted: the key itself will be deleted, too\r\n      cache.delete(key);\r\n      return 0;\r\n    }\r\n\r\n    // read each id from the list and skip the ones which should be deleted\r\n    // collect remaining values\r\n    final int[] nids = new int[numold - ids.length];\r\n    for(int i = 0, j = 0, cid = 0, pid = 0; i < nids.length;) {\r\n      cid += idxl.readNum();\r\n      if(j < ids.length && ids[j] == cid) ++j;\r\n      else {\r\n        nids[i++] = cid - pid;\r\n        pid = cid;\r\n      }\r\n    }\r\n\r\n    idxl.writeNums(pos, nids);\r\n\r\n    // check if key is cached and update the cache entry\r\n    final int cacheid = cache.id(key);\r\n    if(cacheid > 0)\r\n      cache.update(cacheid, nids.length, pos + Num.length(nids.length));\r\n\r\n    return nids.length;\r\n  }","id":868,"modified_method":"/**\r\n   * Remove record ids from the index.\r\n   * @param ix index of the key\r\n   * @param key record key\r\n   * @param ids list of record ids to delete\r\n   * @return number of remaining records\r\n   */\r\n  private int deleteIds(final int ix, final byte[] key, final int[] ids) {\r\n    final long pos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(pos);\r\n\r\n    if(numold == ids.length) {\r\n      // all ids should be deteted: the key itself will be deleted, too\r\n      cache.delete(key);\r\n      return 0;\r\n    }\r\n\r\n    // read each id from the list and skip the ones which should be deleted\r\n    // collect remaining values\r\n    final int[] nids = new int[numold - ids.length];\r\n    for(int i = 0, j = 0, cid = 0, pid = 0; i < nids.length;) {\r\n      cid += idxl.readNum();\r\n      if(j < ids.length && ids[j] == cid) ++j;\r\n      else {\r\n        nids[i++] = cid - pid;\r\n        pid = cid;\r\n      }\r\n    }\r\n\r\n    idxl.writeNums(pos, nids);\r\n\r\n    // update the cache entry\r\n    cache.add(key, nids.length, pos + Num.length(nids.length));\r\n\r\n    return nids.length;\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Add a text entry to the index.\r\n   * @param key text to index\r\n   * @param id id value\r\n   */\r\n  private void insertId(final byte[] key, final int id) {\r\n    int ix = get(key);\r\n    if(ix < 0) {\r\n      ix = -(ix + 1);\r\n\r\n      // shift all entries with bigger keys to the right\r\n      for(int i = size; i > ix; --i)\r\n        idxr.write5(i * 5L, idxr.read5((i - 1) * 5L));\r\n\r\n      // add the key and the id\r\n      idxr.write5(ix * 5L, idxl.appendNums(new int[] { id}));\r\n      ctext.add(ix, key);\r\n      // [DP] should the entry be added to the cache?\r\n\r\n      ++size;\r\n    } else {\r\n      // add id to the list of ids in the index node\r\n      final long pos = idxr.read5(ix * 5L);\r\n      final int num = idxl.readNum(pos);\r\n\r\n      final int[] ids = new int[num + 1];\r\n      boolean notadded = true;\r\n      int cid = 0;\r\n      for(int i = 0, j = -1; i < num; ++i) {\r\n        int v = idxl.readNum();\r\n\r\n        if(notadded && id < cid + v) {\r\n          // add the new id\r\n          ids[++j] = id - cid;\r\n          notadded = false;\r\n          // decrement the difference to the next id\r\n          v -= id - cid;\r\n          cid = id;\r\n        }\r\n\r\n        ids[++j] = v;\r\n        cid += v;\r\n      }\r\n\r\n      if(notadded) ids[ids.length - 1] = id - cid;\r\n\r\n      final long newpos = idxl.appendNums(ids);\r\n      idxr.write5(ix * 5L, newpos);\r\n\r\n      // check if key is cached and update the cache entry\r\n      final int cacheid = cache.id(key);\r\n      if(cacheid > 0)\r\n        cache.update(cacheid, ids.length, newpos + Num.length(ids.length));\r\n    }\r\n  }","id":869,"modified_method":"/**\r\n   * Add a text entry to the index.\r\n   * @param key text to index\r\n   * @param id id value\r\n   */\r\n  private void insertId(final byte[] key, final int id) {\r\n    int ix = get(key);\r\n    if(ix < 0) {\r\n      ix = -(ix + 1);\r\n\r\n      // shift all entries with bigger keys to the right\r\n      for(int i = size; i > ix; --i)\r\n        idxr.write5(i * 5L, idxr.read5((i - 1) * 5L));\r\n\r\n      // add the key and the id\r\n      idxr.write5(ix * 5L, idxl.appendNums(new int[] { id}));\r\n      ctext.add(ix, key);\r\n      // [DP] should the entry be added to the cache?\r\n\r\n      ++size;\r\n    } else {\r\n      // add id to the list of ids in the index node\r\n      final long pos = idxr.read5(ix * 5L);\r\n      final int num = idxl.readNum(pos);\r\n\r\n      final int[] ids = new int[num + 1];\r\n      boolean notadded = true;\r\n      int cid = 0;\r\n      for(int i = 0, j = -1; i < num; ++i) {\r\n        int v = idxl.readNum();\r\n\r\n        if(notadded && id < cid + v) {\r\n          // add the new id\r\n          ids[++j] = id - cid;\r\n          notadded = false;\r\n          // decrement the difference to the next id\r\n          v -= id - cid;\r\n          cid = id;\r\n        }\r\n\r\n        ids[++j] = v;\r\n        cid += v;\r\n      }\r\n\r\n      if(notadded) ids[ids.length - 1] = id - cid;\r\n\r\n      final long newpos = idxl.appendNums(ids);\r\n      idxr.write5(ix * 5L, newpos);\r\n\r\n      // update the cache entry\r\n      cache.add(key, ids.length, newpos + Num.length(ids.length));\r\n    }\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Add record ids to an index entry.\r\n   * @param ix index of the key\r\n   * @param key key\r\n   * @param nids sorted list of record ids to add: the first value is the\r\n   * smallest id and all others are only difference to the previous one\r\n   */\r\n  private void appendIds(final int ix, final byte[] key, final int[] nids) {\r\n    final long oldpos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(oldpos);\r\n    final int[] ids = new int[numold + nids.length];\r\n\r\n    // read the old ids\r\n    for(int i = 0; i < numold; ++i) {\r\n      final int v = idxl.readNum();\r\n      nids[0] -= v; // adjust the first new id\r\n      ids[i] = v;\r\n    }\r\n\r\n    // append the new ids - they are bigger than the old ones\r\n    System.arraycopy(nids, 0, ids, numold, nids.length);\r\n\r\n    final long newpos = idxl.appendNums(ids);\r\n    idxr.write5(ix * 5L, newpos);\r\n\r\n    // check if key is cached and update the cache entry\r\n    final int cacheid = cache.id(key);\r\n    if(cacheid > 0)\r\n      cache.update(cacheid, ids.length, newpos + Num.length(ids.length));\r\n  }","id":870,"modified_method":"/**\r\n   * Add record ids to an index entry.\r\n   * @param ix index of the key\r\n   * @param key key\r\n   * @param nids sorted list of record ids to add: the first value is the\r\n   * smallest id and all others are only difference to the previous one\r\n   */\r\n  private void appendIds(final int ix, final byte[] key, final int[] nids) {\r\n    final long oldpos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(oldpos);\r\n    final int[] ids = new int[numold + nids.length];\r\n\r\n    // read the old ids\r\n    for(int i = 0; i < numold; ++i) {\r\n      final int v = idxl.readNum();\r\n      nids[0] -= v; // adjust the first new id\r\n      ids[i] = v;\r\n    }\r\n\r\n    // append the new ids - they are bigger than the old ones\r\n    System.arraycopy(nids, 0, ids, numold, nids.length);\r\n\r\n    final long newpos = idxl.appendNums(ids);\r\n    idxr.write5(ix * 5L, newpos);\r\n\r\n    // update the cache entry\r\n    cache.add(key, ids.length, newpos + Num.length(ids.length));\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString, Map<String, Object> properties) {\n\n\t\treturn new ServiceTrackerCollectionImpl<>(\n\t\t\tclazz, _getFilter(filterString), null, properties);\n\t}","id":871,"modified_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString, Map<String, Object> properties) {\n\n\t\treturn list(clazz, _getFilter(filterString), properties);\n\t}","commit_id":"b324cdc847e9ee4dc6d97ee2a8dad47a47a16040","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString) {\n\n\t\treturn new ServiceTrackerCollectionImpl<S>(\n\t\t\tclazz, _getFilter(filterString), null,\n\t\t\tjava.util.Collections.<String, Object>emptyMap());\n\t}","id":872,"modified_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString) {\n\n\t\treturn list(clazz, _getFilter(filterString));\n\t}","commit_id":"b324cdc847e9ee4dc6d97ee2a8dad47a47a16040","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString,\n\t\tServiceTrackerCustomizer<S, S> serviceTrackerCustomizer,\n\t\tMap<String, Object> properties) {\n\n\t\treturn new ServiceTrackerCollectionImpl<S>(\n\t\t\tclazz, _getFilter(filterString), serviceTrackerCustomizer,\n\t\t\tproperties);\n\t}","id":873,"modified_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString,\n\t\tServiceTrackerCustomizer<S, S> serviceTrackerCustomizer,\n\t\tMap<String, Object> properties) {\n\n\t\treturn list(\n\t\t\tclazz, _getFilter(filterString), serviceTrackerCustomizer,\n\t\t\tproperties);\n\t}","commit_id":"b324cdc847e9ee4dc6d97ee2a8dad47a47a16040","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString,\n\t\tServiceTrackerCustomizer<S, S> serviceTrackerCustomizer) {\n\n\t\treturn new ServiceTrackerCollectionImpl<S>(\n\t\t\tclazz, _getFilter(filterString), serviceTrackerCustomizer,\n\t\t\tCollections.<String, Object>emptyMap());\n\t}","id":874,"modified_method":"public static <S> ServiceTrackerList<S> list(\n\t\tClass<S> clazz, String filterString,\n\t\tServiceTrackerCustomizer<S, S> serviceTrackerCustomizer) {\n\n\t\treturn list(clazz, _getFilter(filterString), serviceTrackerCustomizer);\n\t}","commit_id":"b324cdc847e9ee4dc6d97ee2a8dad47a47a16040","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * @see org.opencms.workplace.editor.I_CmsEditorActionHandler#getEditMode(org.opencms.file.CmsObject, java.lang.String, java.lang.String, javax.servlet.ServletRequest)\n     */\n    public String getEditMode(CmsObject cmsObject, String filename, String element, ServletRequest req) {\n    \n        try {\n            \n            CmsResource resource = cmsObject.readFileHeader(filename, CmsResourceFilter.ALL);\n            int currentProject = cmsObject.getRequestContext().currentProject().getId();\n            CmsUUID userId = cmsObject.getRequestContext().currentUser().getId();\n            CmsLock lock = cmsObject.getLock(filename);\n            boolean locked = !(lock.isNullLock() || (lock.getUserId().equals(userId) && lock.getProjectId() == currentProject));\n        \n            if (currentProject == I_CmsConstants.C_PROJECT_ONLINE_ID) {\n                // don't render direct edit button in online project\n                return null;\n            } else if (!cmsObject.getResourceType(resource.getType()).isDirectEditable()) {\n                // don't render direct edit button for non-editable resources \n                return null;\n            } else if (CmsResource.getName(filename).startsWith(org.opencms.main.I_CmsConstants.C_TEMP_PREFIX)) {\n                // don't show direct edit button on temporary file\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.isInsideCurrentProject(resource)) {\n                // don't show direct edit button on files not belonging to the current project\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.hasPermissions(resource, new CmsPermissionSet(I_CmsConstants.C_PERMISSION_WRITE))) {\n                // don't show direct edit button on files without write permissions\n                if (locked) {\n                    return C_DIRECT_EDIT_MODE_DISABLED;\n                } else {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }\n            } else if (locked) {\n                return C_DIRECT_EDIT_MODE_DISABLED;\n            }\n              \n            if ((element != null) && (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID)) {\n                // check if the desired element is available (in case of xml page)\n                CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n                if (page == null) {\n                    // make sure a page is only read once (not every time for each element)\n                    page = CmsXmlPage.read(cmsObject, cmsObject.readFile(filename));\n                    req.setAttribute(filename, page);\n                }    \n                Locale locale = OpenCms.getLocaleManager().getBestMatchingLocale(null, OpenCms.getLocaleManager().getDefaultLocales(cmsObject, filename), page.getLocales());\n                if (!page.hasElement(element, locale) || !page.isEnabled(element, locale)) {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }                \n            }\n\n            // otherwise the resource is editable\n            return C_DIRECT_EDIT_MODE_ENABLED;\n            \n        }  catch (CmsException e) {\n            if (OpenCms.getLog(this).isWarnEnabled()) {\n                OpenCms.getLog(this).warn(\"Error while calculation edit mode for \" + filename, e);\n            }\n            // something went wrong - so the resource seems not to be editable\n            return C_DIRECT_EDIT_MODE_INACTIVE;\n        }\n    }","id":875,"modified_method":"/**\n     * @see org.opencms.workplace.editor.I_CmsEditorActionHandler#getEditMode(org.opencms.file.CmsObject, java.lang.String, java.lang.String, javax.servlet.ServletRequest)\n     */\n    public String getEditMode(CmsObject cmsObject, String filename, String element, ServletRequest req) {\n    \n        try {\n            \n            CmsResource resource = cmsObject.readFileHeader(filename, CmsResourceFilter.ALL);\n            int currentProject = cmsObject.getRequestContext().currentProject().getId();\n            CmsUUID userId = cmsObject.getRequestContext().currentUser().getId();\n            CmsLock lock = cmsObject.getLock(filename);\n            boolean locked = !(lock.isNullLock() || (lock.getUserId().equals(userId) && lock.getProjectId() == currentProject));\n        \n            if (currentProject == I_CmsConstants.C_PROJECT_ONLINE_ID) {\n                // don't render direct edit button in online project\n                return null;\n            } else if (!cmsObject.getResourceType(resource.getType()).isDirectEditable()) {\n                // don't render direct edit button for non-editable resources \n                return null;\n            } else if (CmsResource.getName(filename).startsWith(org.opencms.main.I_CmsConstants.C_TEMP_PREFIX)) {\n                // don't show direct edit button on temporary file\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.isInsideCurrentProject(resource)) {\n                // don't show direct edit button on files not belonging to the current project\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.hasPermissions(resource, new CmsPermissionSet(I_CmsConstants.C_PERMISSION_WRITE))) {\n                // don't show direct edit button on files without write permissions\n                if (locked) {\n                    return C_DIRECT_EDIT_MODE_DISABLED;\n                } else {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }\n            } else if (locked) {\n                return C_DIRECT_EDIT_MODE_DISABLED;\n            }\n              \n            if ((element != null) && (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID)) {\n                // check if the desired element is available (in case of xml page)\n                CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n                if (page == null) {\n                    // make sure a page is only read once (not every time for each element)\n                    page = CmsXmlPage.read(cmsObject, cmsObject.readFile(filename));\n                    req.setAttribute(filename, page);\n                }\n                List locales = page.getLocales();\n                Locale locale;\n                if ((locales == null) || (locales.size() == 0)) {\n                    locale = (Locale)OpenCms.getLocaleManager().getDefaultLocales(cmsObject, filename).get(0);                    \n                } else { \n                    locale = OpenCms.getLocaleManager().getBestMatchingLocale(null, OpenCms.getLocaleManager().getDefaultLocales(cmsObject, filename), locales);\n                }\n                if (!page.hasElement(element, locale) || !page.isEnabled(element, locale)) {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }                \n            }\n\n            // otherwise the resource is editable\n            return C_DIRECT_EDIT_MODE_ENABLED;\n            \n        }  catch (CmsException e) {\n            if (OpenCms.getLog(this).isWarnEnabled()) {\n                OpenCms.getLog(this).warn(\"Error while calculation edit mode for \" + filename, e);\n            }\n            // something went wrong - so the resource seems not to be editable\n            return C_DIRECT_EDIT_MODE_INACTIVE;\n        }\n    }","commit_id":"6606adb1e2cd6397451e8e8dc4f9fb00d841c3a1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates the xml page using the specified resource name.<p>\n     * \n     * @throws JspException if inclusion of error dialog fails\n     */\n    public void actionCreateResource() throws JspException {\n        try {\n            // create the full resource name\n            String fullResourceName = computeFullResourceName();\n            \n            // append \".html\" suffix to new file if not present\n            if (fullResourceName.indexOf(\".\") == -1) {\n                fullResourceName += \".html\";\n            }\n            \n            // get the body file content\n            byte[] bodyFileBytes = null;\n            if (getParamBodyFile() == null || \"\".equals(getParamBodyFile())) {\n                // body file not specified, use empty body\n                bodyFileBytes = (\"\").getBytes();\n            } else {\n                // get the specified body file\n                bodyFileBytes = getCms().readFile(getParamBodyFile()).getContents();               \n            }\n            \n            // create the xml page   \n            ((CmsResourceTypeXmlPage)getCms().getResourceType(CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID)).createResourceForTemplate(getCms(), fullResourceName, Collections.EMPTY_LIST, bodyFileBytes, getParamTemplate());\n            \n            // set the resource parameter to full path for property dialog \n            setParamResource(fullResourceName);            \n        } catch (CmsException e) {\n            // error creating folder, show error dialog\n            getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.newresource\"));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n        }\n    }","id":876,"modified_method":"/**\n     * Creates the xml page using the specified resource name.<p>\n     * \n     * @throws JspException if inclusion of error dialog fails\n     */\n    public void actionCreateResource() throws JspException {\n        try {\n            // create the full resource name\n            String fullResourceName = computeFullResourceName();\n            \n            // append \".html\" suffix to new file if not present\n            if (fullResourceName.indexOf(\".\") == -1) {\n                fullResourceName += \".html\";\n            }\n            \n            // get the body file content\n            byte[] bodyFileBytes = null;\n            if (getParamBodyFile() == null || \"\".equals(getParamBodyFile())) {\n                // body file not specified, use empty body\n                bodyFileBytes = (\"\").getBytes();\n            } else {\n                // get the specified body file\n                bodyFileBytes = getCms().readFile(getParamBodyFile()).getContents();               \n            }\n            \n            // create the xml page   \n            ((CmsResourceTypeXmlPage)getCms().getResourceType(CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID)).createResourceForTemplate(getCms(), fullResourceName, new ArrayList(), bodyFileBytes, getParamTemplate());\n            \n            // set the resource parameter to full path for property dialog \n            setParamResource(fullResourceName);            \n        } catch (CmsException e) {\n            // error creating folder, show error dialog\n            getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n            setParamErrorstack(e.getStackTraceAsString());\n            setParamMessage(key(\"error.message.newresource\"));\n            setParamReasonSuggestion(getErrorSuggestionDefault());\n            getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n        }\n    }","commit_id":"6606adb1e2cd6397451e8e8dc4f9fb00d841c3a1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.loader.I_CmsResourceLoader#service(org.opencms.file.CmsObject, org.opencms.file.CmsResource, javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     */\n    public void service(CmsObject cms, CmsResource resource, ServletRequest req, ServletResponse res) \n    throws IOException, CmsException {\n        \n        // get the absolute path of the resource\n        String absolutePath = cms.readAbsolutePath(resource);\n        \n        // get the requested page\n        CmsXmlPage page = (CmsXmlPage)req.getAttribute(absolutePath);\n            \n        if (page == null) {      \n            // make sure a page is only read once (not every time for each element)\n            page = CmsXmlPage.read(cms, CmsFile.upgrade(resource, cms));\n            req.setAttribute(absolutePath, page);\n        }        \n        \n        // get the element selector\n        String elementName = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);\n        \n        // check the current locales\n        Locale locale = OpenCms.getLocaleManager().getBestMatchingLocale(cms.getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(cms, absolutePath), page.getLocales(elementName));\n        \n        // get the appropriate content and convert it to bytes\n        byte[] result = page.getContent(cms, elementName, locale).getBytes(page.getEncoding()); \n        \n        // append the result to the output stream\n        if (result != null) {\n            res.getOutputStream().write(result);\n        }        \n    }","id":877,"modified_method":"/**\n     * @see org.opencms.loader.I_CmsResourceLoader#service(org.opencms.file.CmsObject, org.opencms.file.CmsResource, javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     */\n    public void service(CmsObject cms, CmsResource resource, ServletRequest req, ServletResponse res) \n    throws IOException, CmsException {\n        \n        // get the absolute path of the resource\n        String absolutePath = cms.readAbsolutePath(resource);\n        \n        // get the requested page\n        CmsXmlPage page = (CmsXmlPage)req.getAttribute(absolutePath);\n            \n        if (page == null) {      \n            // make sure a page is only read once (not every time for each element)\n            page = CmsXmlPage.read(cms, CmsFile.upgrade(resource, cms));\n            req.setAttribute(absolutePath, page);\n        }        \n        \n        // get the element selector\n        String elementName = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);\n        \n        // check the current locales\n        List locales = page.getLocales(elementName);\n        Locale locale;\n        if ((locales == null) || (locales.size() == 0)) {\n            // no content for the selected element is available\n            return;                    \n        } else { \n            locale = OpenCms.getLocaleManager().getBestMatchingLocale(cms.getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(cms, absolutePath), locales);\n        }        \n        \n        // get the appropriate content and convert it to bytes\n        byte[] result = page.getContent(cms, elementName, locale).getBytes(page.getEncoding()); \n        \n        // append the result to the output stream\n        if (result != null) {\n            res.getOutputStream().write(result);\n        }        \n    }","commit_id":"6606adb1e2cd6397451e8e8dc4f9fb00d841c3a1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Internal action method.<p>\n     * \n     * @param element the selected element\n     * @param elementlist list the list of elements to check\n     * @param checkall flag to indicate that all elements should be checked\n     * @param checknone flag to indicate that the check is done for nonexisting elements\n     * @param req the current request \n     * @return boolean <code>true<\/code> if this element should be inclued, <code>false<\/code>\n     * otherwise\n     */    \n    public static boolean templateTagAction(String element, String elementlist, boolean checkall, boolean checknone, ServletRequest req) {\n\n        if (elementlist != null) {\n            \n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            String filename = controller.getCmsObject().getRequestContext().getUri();\n            \n            CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n            if (page == null) {\n                CmsResource resource = controller.getCmsResource();\n                if (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID) {\n                    try {\n                        // make sure a page is only read once (not every time for each element)\n                        page = CmsXmlPage.unmarshal(controller.getCmsObject(), CmsFile.upgrade(resource, controller.getCmsObject()));\n                        req.setAttribute(filename, page);                \n                    } catch (CmsException e) {\n                        OpenCms.getLog(CmsJspTagTemplate.class).error(\"Error checking for XML page\", e);\n                    }\n                }    \n            }    \n            \n            if (page != null) {\n                String absolutePath = controller.getCmsObject().readAbsolutePath(page.getFile());\n                Locale locale = OpenCms.getLocaleManager().getBestMatchingLocale(controller.getCmsObject().getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(controller.getCmsObject(), absolutePath), page.getLocales());\n                \n                // check the elements in the elementlist, if the check fails don't render the body\n                String elements[] = CmsStringSubstitution.split(elementlist, \",\");\n                boolean found = false;\n                for (int i = 0; i < elements.length; i++) {\n                    String el = elements[i].trim();\n                    if (page.hasElement(el, locale) && page.isEnabled(el, locale)) {\n                        found = true;\n                        if (!checkall) {\n                            // found at least an element that is available\n                            break;\n                        }\n                    } else {\n                        if (checkall) {\n                            // found at least an element that is not available\n                            return false;\n                        }\n                    }\n                }\n                \n                if (!found && !checknone) {\n                    // no element found while checking for existing elements\n                    return false;\n                } else if (found && checknone) {\n                    // element found while checking for nonexisting elements\n                    return false;\n                }\n            } \n        }\n        \n        // otherwise, check if an element was defined and if its equal to the desired element\n        String param = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);        \n        return ((element ==  null) || (param == null) || (param.equals(element)));\n    }","id":878,"modified_method":"/**\n     * Internal action method.<p>\n     * \n     * @param element the selected element\n     * @param elementlist list the list of elements to check\n     * @param checkall flag to indicate that all elements should be checked\n     * @param checknone flag to indicate that the check is done for nonexisting elements\n     * @param req the current request \n     * @return boolean <code>true<\/code> if this element should be inclued, <code>false<\/code>\n     * otherwise\n     */    \n    public static boolean templateTagAction(String element, String elementlist, boolean checkall, boolean checknone, ServletRequest req) {\n\n        if (elementlist != null) {\n            \n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            String filename = controller.getCmsObject().getRequestContext().getUri();\n            \n            CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n            if (page == null) {\n                CmsResource resource = controller.getCmsResource();\n                if (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID) {\n                    try {\n                        // make sure a page is only read once (not every time for each element)\n                        page = CmsXmlPage.unmarshal(controller.getCmsObject(), CmsFile.upgrade(resource, controller.getCmsObject()));\n                        req.setAttribute(filename, page);                \n                    } catch (CmsException e) {\n                        OpenCms.getLog(CmsJspTagTemplate.class).error(\"Error checking for XML page\", e);\n                    }\n                }    \n            }    \n            \n            if (page != null) {\n                String absolutePath = controller.getCmsObject().readAbsolutePath(page.getFile());\n                // check the elements in the elementlist, if the check fails don't render the body\n                String elements[] = CmsStringSubstitution.split(elementlist, \",\");\n                boolean found = false;\n                for (int i = 0; i < elements.length; i++) {                    \n                    String el = elements[i].trim();\n                    List locales = page.getLocales(el);\n                    Locale locale = null;\n                    if ((locales != null) && (locales.size() != 0)) {\n                        locale = OpenCms.getLocaleManager().getBestMatchingLocale(controller.getCmsObject().getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(controller.getCmsObject(), absolutePath), locales);\n                    }                     \n                    if ((locale != null) && page.hasElement(el, locale) && page.isEnabled(el, locale)) {\n                        \n                        found = true;\n                        if (!checkall) {\n                            // found at least an element that is available\n                            break;\n                        }\n                    } else {\n                        if (checkall) {\n                            // found at least an element that is not available\n                            return false;\n                        }\n                    }\n                }\n                \n                if (!found && !checknone) {\n                    // no element found while checking for existing elements\n                    return false;\n                } else if (found && checknone) {\n                    // element found while checking for nonexisting elements\n                    return false;\n                }\n            } \n        }\n        \n        // otherwise, check if an element was defined and if its equal to the desired element\n        String param = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);        \n        return ((element ==  null) || (param == null) || (param.equals(element)));\n    }","commit_id":"5a052c95c2f32800175f5ca59bfa74abd002fd1a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** Construct a SplitFileFetcherStorage from a stored RandomAccessThing, and appropriate local\n     * settings passed in. Ideally this would work with only basic system utilities such as \n     * those on ClientContext, i.e. we'd be able to restore the splitfile download without knowing\n     * anything about it.\n     * @param newSalt True if the global salt has changed.\n     * @param salt The global salter. Should be passed in even if the global salt hasn't changed,\n     * as we may not have completed regenerating bloom filters.\n     * @throws IOException If the restore failed because of a failure to read from disk. \n     * @throws StorageFormatException \n     * @throws FetchException If the request has already failed (but it wasn't processed before \n     * restarting). */\n    public SplitFileFetcherStorage(LockableRandomAccessThing raf, boolean realTime,  \n            SplitFileFetcherStorageCallback callback, FetchContext origContext,\n            RandomSource random, PersistentJobRunner exec, KeysFetchingLocally keysFetching,\n            Ticker ticker, MemoryLimitedJobRunner memoryLimitedJobRunner, ChecksumChecker checker, \n            boolean newSalt, KeySalter salt, boolean resumed, boolean completeViaTruncation) \n    throws IOException, StorageFormatException, FetchException {\n        this.persistent = true;\n        this.raf = raf;\n        this.fetcher = callback;\n        this.ticker = ticker;\n        this.jobRunner = exec;\n        this.memoryLimitedJobRunner = memoryLimitedJobRunner;\n        this.random = random;\n        this.checksumChecker = checker;\n        this.checksumLength = checker.checksumLength();\n        this.maxRetries = origContext.maxSplitfileBlockRetries;\n        this.cooldownTries = origContext.getCooldownRetries();\n        this.cooldownLength = origContext.getCooldownTime();\n        this.errors = new FailureCodeTracker(false); // FIXME persist???\n        this.completeViaTruncation = completeViaTruncation;\n        // FIXME this is hideous! Rewrite the writing/parsing code here in a less ugly way. However, it works...\n        rafLength = raf.size();\n        if(raf.size() < 8 /* FIXME more! */)\n            throw new StorageFormatException(\"Too short\");\n        // Last 8 bytes: Magic value.\n        byte[] buf = new byte[8];\n        raf.pread(rafLength-8, buf, 0, 8);\n        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(buf));\n        if(dis.readLong() != END_MAGIC)\n            throw new StorageFormatException(\"Wrong magic bytes\");\n        // 4 bytes before that: Version.\n        byte[] versionBuf = new byte[4];\n        raf.pread(rafLength-12, versionBuf, 0, 4);\n        dis = new DataInputStream(new ByteArrayInputStream(versionBuf));\n        int version = dis.readInt();\n        if(version != 1)\n            throw new StorageFormatException(\"Wrong version \"+version);\n        // 2 bytes: Checksum type\n        byte[] checksumTypeBuf = new byte[2];\n        raf.pread(rafLength-14, checksumTypeBuf, 0, 2);\n        dis = new DataInputStream(new ByteArrayInputStream(checksumTypeBuf));\n        int checksumType = dis.readShort();\n        if(checksumType != ChecksumChecker.CHECKSUM_CRC)\n            throw new StorageFormatException(\"Unknown checksum type \"+checksumType);\n        // 4 bytes: Flags. Unused at present.\n        byte[] flagsBuf = new byte[4];\n        raf.pread(rafLength-18, flagsBuf, 0, 4);\n        dis = new DataInputStream(new ByteArrayInputStream(flagsBuf));\n        int flags = dis.readInt();\n        if(flags != 0)\n            throw new StorageFormatException(\"Unknown flags: \"+flags);\n        // 4 bytes basic settings length and a checksum, which includes both the settings length and the version.\n        buf = new byte[14];\n        raf.pread(rafLength-(22+checksumLength), buf, 0, 4);\n        byte[] checksum = new byte[checksumLength];\n        // Check the checksum.\n        raf.pread(rafLength-(18+checksumLength), checksum, 0, checksumLength);\n        System.arraycopy(flagsBuf, 0, buf, 4, 4);\n        System.arraycopy(checksumTypeBuf, 0, buf, 8, 2);\n        System.arraycopy(versionBuf, 0, buf, 10, 4);\n        if(!checksumChecker.checkChecksum(buf, 0, 14, checksum))\n            throw new StorageFormatException(\"Checksum failed on basic settings length and version\");\n        dis = new DataInputStream(new ByteArrayInputStream(buf));\n        int basicSettingsLength = dis.readInt();\n        if(basicSettingsLength < 0 || basicSettingsLength + 12 + 4 + checksumLength > raf.size() || \n                basicSettingsLength > 1024*1024)\n            throw new StorageFormatException(\"Bad basic settings length\");\n        byte[] basicSettingsBuffer = new byte[basicSettingsLength];\n        long basicSettingsOffset = rafLength-(18+4+checksumLength*2+basicSettingsLength);\n        try {\n            preadChecksummed(basicSettingsOffset, \n                    basicSettingsBuffer, 0, basicSettingsLength);\n        } catch (ChecksumFailedException e) {\n            throw new StorageFormatException(\"Basic settings checksum invalid\");\n        }\n        dis = new DataInputStream(new ByteArrayInputStream(basicSettingsBuffer));\n        splitfileType = dis.readShort();\n        if(!Metadata.isValidSplitfileType(splitfileType))\n            throw new StorageFormatException(\"Invalid splitfile type \"+splitfileType);\n        this.fecCodec = FECCodec.getInstance(splitfileType);\n        splitfileSingleCryptoAlgorithm = dis.readByte();\n        if(!Metadata.isValidSplitfileCryptoAlgorithm(splitfileSingleCryptoAlgorithm))\n            throw new StorageFormatException(\"Invalid splitfile crypto algorithm \"+splitfileType);\n        if(dis.readBoolean()) {\n            splitfileSingleCryptoKey = new byte[32];\n            dis.readFully(splitfileSingleCryptoKey);\n        } else {\n            splitfileSingleCryptoKey = null;\n        }\n        finalLength = dis.readLong();\n        if(finalLength < 0)\n            throw new StorageFormatException(\"Invalid final length \"+finalLength);\n        decompressedLength = dis.readLong();\n        if(decompressedLength < 0)\n            throw new StorageFormatException(\"Invalid decompressed length \"+decompressedLength);\n        try {\n            clientMetadata = ClientMetadata.construct(dis);\n        } catch (MetadataParseException e) {\n            throw new StorageFormatException(\"Invalid MIME type\");\n        }\n        int decompressorCount = dis.readInt();\n        if(decompressorCount < 0)\n            throw new StorageFormatException(\"Invalid decompressor count \"+decompressorCount);\n        decompressors = new ArrayList<COMPRESSOR_TYPE>(decompressorCount);\n        for(int i=0;i<decompressorCount;i++) {\n            short type = dis.readShort();\n            COMPRESSOR_TYPE d = COMPRESSOR_TYPE.getCompressorByMetadataID(type);\n            if(d == null) throw new StorageFormatException(\"Invalid decompressor ID \"+type);\n            decompressors.add(d);\n        }\n        offsetKeyList = dis.readLong();\n        if(offsetKeyList < 0 || offsetKeyList > rafLength) \n            throw new StorageFormatException(\"Invalid offset (key list)\");\n        offsetSegmentStatus = dis.readLong();\n        if(offsetSegmentStatus < 0 || offsetSegmentStatus > rafLength) \n            throw new StorageFormatException(\"Invalid offset (segment status)\");\n        offsetGeneralProgress = dis.readLong();\n        if(offsetGeneralProgress < 0 || offsetGeneralProgress > rafLength) \n            throw new StorageFormatException(\"Invalid offset (general progress)\");\n        offsetMainBloomFilter = dis.readLong();\n        if(offsetMainBloomFilter < 0 || offsetMainBloomFilter > rafLength) \n            throw new StorageFormatException(\"Invalid offset (main bloom filter)\");\n        offsetSegmentBloomFilters = dis.readLong();\n        if(offsetSegmentBloomFilters < 0 || offsetSegmentBloomFilters > rafLength) \n            throw new StorageFormatException(\"Invalid offset (segment bloom filters)\");\n        offsetOriginalMetadata = dis.readLong();\n        if(offsetOriginalMetadata < 0 || offsetOriginalMetadata > rafLength) \n            throw new StorageFormatException(\"Invalid offset (original metadata)\");\n        offsetOriginalDetails = dis.readLong();\n        if(offsetOriginalDetails < 0 || offsetOriginalDetails > rafLength) \n            throw new StorageFormatException(\"Invalid offset (original metadata)\");\n        offsetBasicSettings = dis.readLong();\n        if(offsetBasicSettings != basicSettingsOffset)\n            throw new StorageFormatException(\"Invalid basic settings offset (not the same as computed)\");\n        if(completeViaTruncation != dis.readBoolean())\n            throw new StorageFormatException(\"Complete via truncation flag is wrong\");\n        int compatMode = dis.readInt();\n        if(compatMode < 0 || compatMode > CompatibilityMode.values().length)\n            throw new StorageFormatException(\"Invalid compatibility mode \"+compatMode);\n        finalMinCompatMode = CompatibilityMode.values()[compatMode];\n        int segmentCount = dis.readInt();\n        if(segmentCount < 0) throw new StorageFormatException(\"Invalid segment count \"+segmentCount);\n        this.segments = new SplitFileFetcherSegmentStorage[segmentCount];\n        int totalDataBlocks = dis.readInt();\n        if(totalDataBlocks < 0) \n            throw new StorageFormatException(\"Invalid total data blocks \"+totalDataBlocks);\n        int totalCheckBlocks = dis.readInt();\n        if(totalCheckBlocks < 0) \n            throw new StorageFormatException(\"Invalid total check blocks \"+totalDataBlocks);\n        int totalCrossCheckBlocks = dis.readInt();\n        if(totalCrossCheckBlocks < 0)\n            throw new StorageFormatException(\"Invalid total cross-check blocks \"+totalDataBlocks);\n        long dataOffset = 0;\n        long crossCheckBlocksOffset;\n        if(completeViaTruncation) {\n            crossCheckBlocksOffset = totalDataBlocks * CHKBlock.DATA_LENGTH;\n        } else {\n            crossCheckBlocksOffset = 0;\n        }\n        long segmentKeysOffset = offsetKeyList;\n        long segmentStatusOffset = offsetSegmentStatus;\n        int countDataBlocks = 0;\n        int countCheckBlocks = 0;\n        int countCrossCheckBlocks = 0;\n        for(int i=0;i<segments.length;i++) {\n            segments[i] = new SplitFileFetcherSegmentStorage(this, dis, i, maxRetries != -1, \n                    dataOffset, completeViaTruncation ? crossCheckBlocksOffset : -1,\n                    segmentKeysOffset, segmentStatusOffset, keysFetching);\n            int dataBlocks = segments[i].dataBlocks;\n            countDataBlocks += dataBlocks;\n            int checkBlocks = segments[i].checkBlocks;\n            countCheckBlocks += checkBlocks;\n            int crossCheckBlocks = segments[i].crossSegmentCheckBlocks;\n            countCrossCheckBlocks += crossCheckBlocks;\n            dataOffset += dataBlocks * CHKBlock.DATA_LENGTH;\n            if(completeViaTruncation)\n                crossCheckBlocksOffset += crossCheckBlocks * CHKBlock.DATA_LENGTH;\n            else\n                dataOffset += crossCheckBlocks * CHKBlock.DATA_LENGTH;\n            segmentKeysOffset += \n                SplitFileFetcherSegmentStorage.storedKeysLength(dataBlocks+crossCheckBlocks, checkBlocks, splitfileSingleCryptoKey != null, checksumLength);\n            segmentStatusOffset +=\n                SplitFileFetcherSegmentStorage.paddedStoredSegmentStatusLength(dataBlocks, checkBlocks, \n                        crossCheckBlocks, maxRetries != -1, checksumLength, true);\n            if(dataOffset > rafLength)\n                throw new StorageFormatException(\"Data offset past end of file \"+dataOffset+\" of \"+rafLength);\n            if(segments[i].segmentCrossCheckBlockDataOffset > rafLength)\n                throw new StorageFormatException(\"Cross-check blocks offset past end of file \"+segments[i].segmentCrossCheckBlockDataOffset+\" of \"+rafLength);\n            if(logDEBUG) Logger.debug(this, \"Segment \"+i+\": data blocks offset \"+\n                    segments[i].segmentBlockDataOffset+\" cross-check blocks offset \"+segments[i].segmentCrossCheckBlockDataOffset+\" for segment \"+i+\" of \"+this);\n        }\n        if(countDataBlocks != totalDataBlocks) \n            throw new StorageFormatException(\"Total data blocks \"+countDataBlocks+\" but expected \"+totalDataBlocks);\n        if(countCheckBlocks != totalCheckBlocks) \n            throw new StorageFormatException(\"Total check blocks \"+countCheckBlocks+\" but expected \"+totalCheckBlocks);\n        if(countCrossCheckBlocks != totalCrossCheckBlocks) \n            throw new StorageFormatException(\"Total cross-check blocks \"+countCrossCheckBlocks+\" but expected \"+totalCrossCheckBlocks);\n        int crossSegments = dis.readInt();\n        if(crossSegments == 0)\n            this.crossSegments = null;\n        else\n            this.crossSegments = new SplitFileFetcherCrossSegmentStorage[crossSegments];\n        for(int i=0;i<crossSegments;i++) {\n            this.crossSegments[i] = new SplitFileFetcherCrossSegmentStorage(this, i, dis);\n        }\n        this.keyListener = new SplitFileFetcherKeyListener(this, fetcher, dis, false, newSalt);\n        for(SplitFileFetcherSegmentStorage segment : segments) {\n            boolean needsDecode = false;\n            try {\n                segment.readMetadata();\n                if(segment.hasFailed()) {\n                    raf.close();\n                    raf.free(); // Failed, so free it.\n                    throw new FetchException(FetchExceptionMode.SPLITFILE_ERROR, errors);\n                }\n            } catch (ChecksumFailedException e) {\n                Logger.error(this, \"Progress for segment \"+segment.segNo+\" on \"+this+\" corrupted.\");\n                needsDecode = true;\n            }\n            if(segment.needsDecode())\n                needsDecode = true;\n            if(needsDecode) {\n                if(segmentsToTryDecode == null)\n                    segmentsToTryDecode = new ArrayList<SplitFileFetcherSegmentStorage>();\n                segmentsToTryDecode.add(segment);\n            }\n        }\n        for(int i=0;i<segments.length;i++) {\n            SplitFileFetcherSegmentStorage segment = segments[i];\n            try {\n                segment.readSegmentKeys();\n            } catch (ChecksumFailedException e) {\n                throw new StorageFormatException(\"Keys corrupted\");\n            }\n        }\n        if(this.crossSegments != null) {\n            for(SplitFileFetcherCrossSegmentStorage crossSegment : this.crossSegments)\n                // Must be after reading the metadata for the plain segments.\n                crossSegment.checkBlocks();\n        }\n        readGeneralProgress();\n    }","id":879,"modified_method":"/** Construct a SplitFileFetcherStorage from a stored RandomAccessThing, and appropriate local\n     * settings passed in. Ideally this would work with only basic system utilities such as \n     * those on ClientContext, i.e. we'd be able to restore the splitfile download without knowing\n     * anything about it.\n     * @param newSalt True if the global salt has changed.\n     * @param salt The global salter. Should be passed in even if the global salt hasn't changed,\n     * as we may not have completed regenerating bloom filters.\n     * @throws IOException If the restore failed because of a failure to read from disk. \n     * @throws StorageFormatException \n     * @throws FetchException If the request has already failed (but it wasn't processed before \n     * restarting). */\n    public SplitFileFetcherStorage(LockableRandomAccessThing raf, boolean realTime,  \n            SplitFileFetcherStorageCallback callback, FetchContext origContext,\n            RandomSource random, PersistentJobRunner exec, KeysFetchingLocally keysFetching,\n            Ticker ticker, MemoryLimitedJobRunner memoryLimitedJobRunner, ChecksumChecker checker, \n            boolean newSalt, KeySalter salt, boolean resumed, boolean completeViaTruncation) \n    throws IOException, StorageFormatException, FetchException {\n        this.persistent = true;\n        this.raf = raf;\n        this.fetcher = callback;\n        this.ticker = ticker;\n        this.jobRunner = exec;\n        this.memoryLimitedJobRunner = memoryLimitedJobRunner;\n        this.random = random;\n        this.checksumChecker = checker;\n        this.checksumLength = checker.checksumLength();\n        this.maxRetries = origContext.maxSplitfileBlockRetries;\n        this.cooldownTries = origContext.getCooldownRetries();\n        this.cooldownLength = origContext.getCooldownTime();\n        this.errors = new FailureCodeTracker(false); // FIXME persist???\n        this.completeViaTruncation = completeViaTruncation;\n        // FIXME this is hideous! Rewrite the writing/parsing code here in a less ugly way. However, it works...\n        rafLength = raf.size();\n        if(raf.size() < 8 /* FIXME more! */)\n            throw new StorageFormatException(\"Too short\");\n        // Last 8 bytes: Magic value.\n        byte[] buf = new byte[8];\n        raf.pread(rafLength-8, buf, 0, 8);\n        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(buf));\n        if(dis.readLong() != END_MAGIC)\n            throw new StorageFormatException(\"Wrong magic bytes\");\n        // 4 bytes before that: Version.\n        byte[] versionBuf = new byte[4];\n        raf.pread(rafLength-12, versionBuf, 0, 4);\n        dis = new DataInputStream(new ByteArrayInputStream(versionBuf));\n        int version = dis.readInt();\n        if(version != 1)\n            throw new StorageFormatException(\"Wrong version \"+version);\n        // 2 bytes: Checksum type\n        byte[] checksumTypeBuf = new byte[2];\n        raf.pread(rafLength-14, checksumTypeBuf, 0, 2);\n        dis = new DataInputStream(new ByteArrayInputStream(checksumTypeBuf));\n        int checksumType = dis.readShort();\n        if(checksumType != ChecksumChecker.CHECKSUM_CRC)\n            throw new StorageFormatException(\"Unknown checksum type \"+checksumType);\n        // 4 bytes: Flags. Unused at present.\n        byte[] flagsBuf = new byte[4];\n        raf.pread(rafLength-18, flagsBuf, 0, 4);\n        dis = new DataInputStream(new ByteArrayInputStream(flagsBuf));\n        int flags = dis.readInt();\n        if(flags != 0)\n            throw new StorageFormatException(\"Unknown flags: \"+flags);\n        // 4 bytes basic settings length and a checksum, which includes both the settings length and the version.\n        buf = new byte[14];\n        raf.pread(rafLength-(22+checksumLength), buf, 0, 4);\n        byte[] checksum = new byte[checksumLength];\n        // Check the checksum.\n        raf.pread(rafLength-(18+checksumLength), checksum, 0, checksumLength);\n        System.arraycopy(flagsBuf, 0, buf, 4, 4);\n        System.arraycopy(checksumTypeBuf, 0, buf, 8, 2);\n        System.arraycopy(versionBuf, 0, buf, 10, 4);\n        if(!checksumChecker.checkChecksum(buf, 0, 14, checksum))\n            throw new StorageFormatException(\"Checksum failed on basic settings length and version\");\n        dis = new DataInputStream(new ByteArrayInputStream(buf));\n        int basicSettingsLength = dis.readInt();\n        if(basicSettingsLength < 0 || basicSettingsLength + 12 + 4 + checksumLength > raf.size() || \n                basicSettingsLength > 1024*1024)\n            throw new StorageFormatException(\"Bad basic settings length\");\n        byte[] basicSettingsBuffer = new byte[basicSettingsLength];\n        long basicSettingsOffset = rafLength-(18+4+checksumLength*2+basicSettingsLength);\n        try {\n            preadChecksummed(basicSettingsOffset, \n                    basicSettingsBuffer, 0, basicSettingsLength);\n        } catch (ChecksumFailedException e) {\n            throw new StorageFormatException(\"Basic settings checksum invalid\");\n        }\n        dis = new DataInputStream(new ByteArrayInputStream(basicSettingsBuffer));\n        try {\n            splitfileType = dis.readShort();\n            if(!Metadata.isValidSplitfileType(splitfileType))\n                throw new StorageFormatException(\"Invalid splitfile type \"+splitfileType);\n            this.fecCodec = FECCodec.getInstance(splitfileType);\n            splitfileSingleCryptoAlgorithm = dis.readByte();\n            if(!Metadata.isValidSplitfileCryptoAlgorithm(splitfileSingleCryptoAlgorithm))\n                throw new StorageFormatException(\"Invalid splitfile crypto algorithm \"+splitfileType);\n            if(dis.readBoolean()) {\n                splitfileSingleCryptoKey = new byte[32];\n                dis.readFully(splitfileSingleCryptoKey);\n            } else {\n                splitfileSingleCryptoKey = null;\n            }\n            finalLength = dis.readLong();\n            if(finalLength < 0)\n                throw new StorageFormatException(\"Invalid final length \"+finalLength);\n            decompressedLength = dis.readLong();\n            if(decompressedLength < 0)\n                throw new StorageFormatException(\"Invalid decompressed length \"+decompressedLength);\n            try {\n                clientMetadata = ClientMetadata.construct(dis);\n            } catch (MetadataParseException e) {\n                throw new StorageFormatException(\"Invalid MIME type\");\n            }\n            int decompressorCount = dis.readInt();\n            if(decompressorCount < 0)\n                throw new StorageFormatException(\"Invalid decompressor count \"+decompressorCount);\n            decompressors = new ArrayList<COMPRESSOR_TYPE>(decompressorCount);\n            for(int i=0;i<decompressorCount;i++) {\n                short type = dis.readShort();\n                COMPRESSOR_TYPE d = COMPRESSOR_TYPE.getCompressorByMetadataID(type);\n                if(d == null) throw new StorageFormatException(\"Invalid decompressor ID \"+type);\n                decompressors.add(d);\n            }\n            offsetKeyList = dis.readLong();\n            if(offsetKeyList < 0 || offsetKeyList > rafLength) \n                throw new StorageFormatException(\"Invalid offset (key list)\");\n            offsetSegmentStatus = dis.readLong();\n            if(offsetSegmentStatus < 0 || offsetSegmentStatus > rafLength) \n                throw new StorageFormatException(\"Invalid offset (segment status)\");\n            offsetGeneralProgress = dis.readLong();\n            if(offsetGeneralProgress < 0 || offsetGeneralProgress > rafLength) \n                throw new StorageFormatException(\"Invalid offset (general progress)\");\n            offsetMainBloomFilter = dis.readLong();\n            if(offsetMainBloomFilter < 0 || offsetMainBloomFilter > rafLength) \n                throw new StorageFormatException(\"Invalid offset (main bloom filter)\");\n            offsetSegmentBloomFilters = dis.readLong();\n            if(offsetSegmentBloomFilters < 0 || offsetSegmentBloomFilters > rafLength) \n                throw new StorageFormatException(\"Invalid offset (segment bloom filters)\");\n            offsetOriginalMetadata = dis.readLong();\n            if(offsetOriginalMetadata < 0 || offsetOriginalMetadata > rafLength) \n                throw new StorageFormatException(\"Invalid offset (original metadata)\");\n            offsetOriginalDetails = dis.readLong();\n            if(offsetOriginalDetails < 0 || offsetOriginalDetails > rafLength) \n                throw new StorageFormatException(\"Invalid offset (original metadata)\");\n            offsetBasicSettings = dis.readLong();\n            if(offsetBasicSettings != basicSettingsOffset)\n                throw new StorageFormatException(\"Invalid basic settings offset (not the same as computed)\");\n            if(completeViaTruncation != dis.readBoolean())\n                throw new StorageFormatException(\"Complete via truncation flag is wrong\");\n            int compatMode = dis.readInt();\n            if(compatMode < 0 || compatMode > CompatibilityMode.values().length)\n                throw new StorageFormatException(\"Invalid compatibility mode \"+compatMode);\n            finalMinCompatMode = CompatibilityMode.values()[compatMode];\n            int segmentCount = dis.readInt();\n            if(segmentCount < 0) throw new StorageFormatException(\"Invalid segment count \"+segmentCount);\n            this.segments = new SplitFileFetcherSegmentStorage[segmentCount];\n            int totalDataBlocks = dis.readInt();\n            if(totalDataBlocks < 0) \n                throw new StorageFormatException(\"Invalid total data blocks \"+totalDataBlocks);\n            int totalCheckBlocks = dis.readInt();\n            if(totalCheckBlocks < 0) \n                throw new StorageFormatException(\"Invalid total check blocks \"+totalDataBlocks);\n            int totalCrossCheckBlocks = dis.readInt();\n            if(totalCrossCheckBlocks < 0)\n                throw new StorageFormatException(\"Invalid total cross-check blocks \"+totalDataBlocks);\n            long dataOffset = 0;\n            long crossCheckBlocksOffset;\n            if(completeViaTruncation) {\n                crossCheckBlocksOffset = totalDataBlocks * CHKBlock.DATA_LENGTH;\n            } else {\n                crossCheckBlocksOffset = 0;\n            }\n            long segmentKeysOffset = offsetKeyList;\n            long segmentStatusOffset = offsetSegmentStatus;\n            int countDataBlocks = 0;\n            int countCheckBlocks = 0;\n            int countCrossCheckBlocks = 0;\n            for(int i=0;i<segments.length;i++) {\n                segments[i] = new SplitFileFetcherSegmentStorage(this, dis, i, maxRetries != -1, \n                        dataOffset, completeViaTruncation ? crossCheckBlocksOffset : -1,\n                                segmentKeysOffset, segmentStatusOffset, keysFetching);\n                int dataBlocks = segments[i].dataBlocks;\n                countDataBlocks += dataBlocks;\n                int checkBlocks = segments[i].checkBlocks;\n                countCheckBlocks += checkBlocks;\n                int crossCheckBlocks = segments[i].crossSegmentCheckBlocks;\n                countCrossCheckBlocks += crossCheckBlocks;\n                dataOffset += dataBlocks * CHKBlock.DATA_LENGTH;\n                if(completeViaTruncation)\n                    crossCheckBlocksOffset += crossCheckBlocks * CHKBlock.DATA_LENGTH;\n                else\n                    dataOffset += crossCheckBlocks * CHKBlock.DATA_LENGTH;\n                segmentKeysOffset += \n                    SplitFileFetcherSegmentStorage.storedKeysLength(dataBlocks+crossCheckBlocks, checkBlocks, splitfileSingleCryptoKey != null, checksumLength);\n                segmentStatusOffset +=\n                    SplitFileFetcherSegmentStorage.paddedStoredSegmentStatusLength(dataBlocks, checkBlocks, \n                            crossCheckBlocks, maxRetries != -1, checksumLength, true);\n                if(dataOffset > rafLength)\n                    throw new StorageFormatException(\"Data offset past end of file \"+dataOffset+\" of \"+rafLength);\n                if(segments[i].segmentCrossCheckBlockDataOffset > rafLength)\n                    throw new StorageFormatException(\"Cross-check blocks offset past end of file \"+segments[i].segmentCrossCheckBlockDataOffset+\" of \"+rafLength);\n                if(logDEBUG) Logger.debug(this, \"Segment \"+i+\": data blocks offset \"+\n                        segments[i].segmentBlockDataOffset+\" cross-check blocks offset \"+segments[i].segmentCrossCheckBlockDataOffset+\" for segment \"+i+\" of \"+this);\n            }\n            if(countDataBlocks != totalDataBlocks) \n                throw new StorageFormatException(\"Total data blocks \"+countDataBlocks+\" but expected \"+totalDataBlocks);\n            if(countCheckBlocks != totalCheckBlocks) \n                throw new StorageFormatException(\"Total check blocks \"+countCheckBlocks+\" but expected \"+totalCheckBlocks);\n            if(countCrossCheckBlocks != totalCrossCheckBlocks) \n                throw new StorageFormatException(\"Total cross-check blocks \"+countCrossCheckBlocks+\" but expected \"+totalCrossCheckBlocks);\n            int crossSegments = dis.readInt();\n            if(crossSegments == 0)\n                this.crossSegments = null;\n            else\n                this.crossSegments = new SplitFileFetcherCrossSegmentStorage[crossSegments];\n            for(int i=0;i<crossSegments;i++) {\n                this.crossSegments[i] = new SplitFileFetcherCrossSegmentStorage(this, i, dis);\n            }\n            this.keyListener = new SplitFileFetcherKeyListener(this, fetcher, dis, false, newSalt);\n        } catch (IOException e) {\n            // We are reading from an array! Bad as written perhaps?\n            throw new StorageFormatException(\"Cannot read basic settings even though passed checksum: \"+e, e);\n        }\n        for(SplitFileFetcherSegmentStorage segment : segments) {\n            boolean needsDecode = false;\n            try {\n                segment.readMetadata();\n                if(segment.hasFailed()) {\n                    raf.close();\n                    raf.free(); // Failed, so free it.\n                    throw new FetchException(FetchExceptionMode.SPLITFILE_ERROR, errors);\n                }\n            } catch (ChecksumFailedException e) {\n                Logger.error(this, \"Progress for segment \"+segment.segNo+\" on \"+this+\" corrupted.\");\n                needsDecode = true;\n            }\n            if(segment.needsDecode())\n                needsDecode = true;\n            if(needsDecode) {\n                if(segmentsToTryDecode == null)\n                    segmentsToTryDecode = new ArrayList<SplitFileFetcherSegmentStorage>();\n                segmentsToTryDecode.add(segment);\n            }\n        }\n        for(int i=0;i<segments.length;i++) {\n            SplitFileFetcherSegmentStorage segment = segments[i];\n            try {\n                segment.readSegmentKeys();\n            } catch (ChecksumFailedException e) {\n                throw new StorageFormatException(\"Keys corrupted\");\n            }\n        }\n        if(this.crossSegments != null) {\n            for(SplitFileFetcherCrossSegmentStorage crossSegment : this.crossSegments)\n                // Must be after reading the metadata for the plain segments.\n                crossSegment.checkBlocks();\n        }\n        readGeneralProgress();\n    }","commit_id":"4c3da03abd8feaa018ff1685fa03fcfbe5e5c46d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n   * SONAR-6787\n   */\n  @Test\n  public void ensure_differential_period_4_and_5_defined_at_project_level_is_taken_into_account() throws Exception {\n    orchestrator.getServer().provisionProject(PROJECT_KEY, PROJECT_KEY);\n    setServerProperty(orchestrator, PROJECT_KEY, \"sonar.timemachine.period4\", \"30\");\n    setServerProperty(orchestrator, PROJECT_KEY, \"sonar.timemachine.period5\", \"previous_analysis\");\n\n    // Execute an analysis 60 days ago to have a past snapshot without any issues\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"empty\");\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\"))\n      .setProperty(\"sonar.projectDate\", formatDate(addDays(new Date(), -60))));\n\n    // Second analysis, 20 days ago, issues will be created\n    orchestrator.getServer().restoreProfile(FileLocation.ofClasspath(\"/measureHistory/one-issue-per-line-profile.xml\"));\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"one-issue-per-line\");\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\"))\n        .setProperty(\"sonar.projectDate\", formatDate(addDays(new Date(), -20))));\n\n    // New technical debt only comes from new issues\n    Resource newTechnicalDebt = orchestrator.getServer().getWsClient()\n      .find(ResourceQuery.createForMetrics(\"sample:src/main/xoo/sample/Sample.xoo\", \"new_technical_debt\").setIncludeTrends(true));\n    List<Measure> measures = newTechnicalDebt.getMeasures();\n    assertThat(measures.get(0).getVariation4()).isEqualTo(17);\n    assertThat(measures.get(0).getVariation5()).isEqualTo(17);\n\n    // Third analysis, today, with exactly the same profile -> no new issues so no new technical debt\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"one-issue-per-line\");\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\")));\n\n    newTechnicalDebt = orchestrator.getServer().getWsClient().find(\n      ResourceQuery.createForMetrics(\"sample:src/main/xoo/sample/Sample.xoo\", \"new_technical_debt\").setIncludeTrends(true)\n      );\n\n    // No variation => measure is purged\n    assertThat(newTechnicalDebt).isNull();\n  }","id":880,"modified_method":"/**\n   * SONAR-6787\n   */\n  @Test\n  public void ensure_differential_period_4_and_5_defined_at_project_level_is_taken_into_account() throws Exception {\n    orchestrator.getServer().provisionProject(PROJECT_KEY, PROJECT_KEY);\n    setServerProperty(orchestrator, PROJECT_KEY, \"sonar.timemachine.period4\", \"30\");\n    setServerProperty(orchestrator, PROJECT_KEY, \"sonar.timemachine.period5\", \"previous_analysis\");\n\n    // Execute an analysis 60 days ago to have a past snapshot without any issues\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"empty\");\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\", \"sonar.projectDate\", formatDate(addDays(new Date(), -60)));\n\n    // Second analysis, 20 days ago, issues will be created\n    orchestrator.getServer().restoreProfile(FileLocation.ofClasspath(\"/measureHistory/one-issue-per-line-profile.xml\"));\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"one-issue-per-line\");\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\", \"sonar.projectDate\", formatDate(addDays(new Date(), -20)));\n\n    // New technical debt only comes from new issues\n    Resource newTechnicalDebt = orchestrator.getServer().getWsClient()\n      .find(ResourceQuery.createForMetrics(\"sample:src/main/xoo/sample/Sample.xoo\", \"new_technical_debt\").setIncludeTrends(true));\n    List<Measure> measures = newTechnicalDebt.getMeasures();\n    assertThat(measures.get(0).getVariation4()).isEqualTo(17);\n    assertThat(measures.get(0).getVariation5()).isEqualTo(17);\n\n    // Third analysis, today, with exactly the same profile -> no new issues so no new technical debt\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"one-issue-per-line\");\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\");\n\n    newTechnicalDebt = orchestrator.getServer().getWsClient().find(\n      ResourceQuery.createForMetrics(\"sample:src/main/xoo/sample/Sample.xoo\", \"new_technical_debt\").setIncludeTrends(true)\n      );\n\n    // No variation => measure is purged\n    assertThat(newTechnicalDebt).isNull();\n  }","commit_id":"7630d660953cba8eee725a6a46c89dbf658bf1a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-4700\n   */\n  @Test\n  public void not_display_periods_selection_dropdown_on_first_analysis() {\n    orchestrator.getServer().provisionProject(PROJECT_KEY, PROJECT_KEY);\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"empty\");\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\")));\n\n    // Use old way to execute Selenium because 'assertSelectOptions' action is not supported by SeleneseTest\n    orchestrator.executeSelenese(Selenese.builder().setHtmlTestsInClasspath(\"not-display-periods-selection-dropdown-on-first-analysis\",\n      \"/measureHistory/DifferentialPeriodsTest/not-display-periods-selection-dropdown-on-dashboard.html\"\n      ).build());\n\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\")));\n\n    orchestrator.executeSelenese(Selenese.builder().setHtmlTestsInClasspath(\"display-periods-selection-dropdown-after-first-analysis\",\n      \"/measureHistory/DifferentialPeriodsTest/display-periods-selection-dropdown-on-dashboard.html\"\n      ).build());\n  }","id":881,"modified_method":"/**\n   * SONAR-4700\n   */\n  @Test\n  public void not_display_periods_selection_dropdown_on_first_analysis() {\n    orchestrator.getServer().provisionProject(PROJECT_KEY, PROJECT_KEY);\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"empty\");\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\");\n\n    // Use old way to execute Selenium because 'assertSelectOptions' action is not supported by SeleneseTest\n    orchestrator.executeSelenese(Selenese.builder().setHtmlTestsInClasspath(\"not-display-periods-selection-dropdown-on-first-analysis\",\n      \"/measureHistory/DifferentialPeriodsTest/not-display-periods-selection-dropdown-on-dashboard.html\"\n      ).build());\n\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\");\n    orchestrator.executeSelenese(Selenese.builder().setHtmlTestsInClasspath(\"display-periods-selection-dropdown-after-first-analysis\",\n      \"/measureHistory/DifferentialPeriodsTest/display-periods-selection-dropdown-on-dashboard.html\"\n      ).build());\n  }","commit_id":"7630d660953cba8eee725a6a46c89dbf658bf1a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-7093\n   */\n  @Test\n  public void ensure_leak_period_defined_at_project_level_is_taken_into_account() throws Exception {\n    orchestrator.getServer().provisionProject(PROJECT_KEY, PROJECT_KEY);\n\n    // Set a global property and a project property to ensure project property is used\n    setServerProperty(orchestrator, \"sonar.timemachine.period1\", \"previous_analysis\");\n    setServerProperty(orchestrator, PROJECT_KEY, \"sonar.timemachine.period1\", \"30\");\n\n    // Execute an analysis in the past to have a past snapshot without any issues\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"empty\");\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\"))\n      .setProperty(\"sonar.projectDate\", formatDate(addDays(new Date(), -15))));\n\n    // Second analysis -> issues will be created\n    orchestrator.getServer().restoreProfile(FileLocation.ofClasspath(\"/measureHistory/one-issue-per-line-profile.xml\"));\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"one-issue-per-line\");\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\")));\n\n    // Third analysis -> There's no new issue from previous analysis\n    orchestrator.executeBuild(SonarRunner.create(projectDir(\"shared/xoo-sample\")));\n\n    // Project should have 17 new issues for period 1\n    Resource newTechnicalDebt = orchestrator.getServer().getWsClient()\n      .find(ResourceQuery.createForMetrics(PROJECT_KEY, \"violations\").setIncludeTrends(true));\n    List<Measure> measures = newTechnicalDebt.getMeasures();\n    assertThat(measures.get(0).getVariation1()).isEqualTo(17);\n\n    // Check on ui that it's possible to define leak period on project\n    new SeleneseTest(Selenese.builder().setHtmlTestsInClasspath(\"define-leak-period-on-project\",\n      \"/measureHistory/DifferentialPeriodsTest/define-leak-period-on-project.html\"\n    ).build()).runOn(orchestrator);\n  }","id":882,"modified_method":"/**\n   * SONAR-7093\n   */\n  @Test\n  public void ensure_leak_period_defined_at_project_level_is_taken_into_account() throws Exception {\n    orchestrator.getServer().provisionProject(PROJECT_KEY, PROJECT_KEY);\n\n    // Set a global property and a project property to ensure project property is used\n    setServerProperty(orchestrator, \"sonar.timemachine.period1\", \"previous_analysis\");\n    setServerProperty(orchestrator, PROJECT_KEY, \"sonar.timemachine.period1\", \"30\");\n\n    // Execute an analysis in the past to have a past snapshot without any issues\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"empty\");\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\", \"sonar.projectDate\", formatDate(addDays(new Date(), -15)));\n\n    // Second analysis -> issues will be created\n    orchestrator.getServer().restoreProfile(FileLocation.ofClasspath(\"/measureHistory/one-issue-per-line-profile.xml\"));\n    orchestrator.getServer().associateProjectToQualityProfile(PROJECT_KEY, \"xoo\", \"one-issue-per-line\");\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\");\n\n    // Third analysis -> There's no new issue from previous analysis\n    runProjectAnalysis(orchestrator, \"shared/xoo-sample\");\n\n    // Project should have 17 new issues for period 1\n    Resource newTechnicalDebt = orchestrator.getServer().getWsClient()\n      .find(ResourceQuery.createForMetrics(PROJECT_KEY, \"violations\").setIncludeTrends(true));\n    List<Measure> measures = newTechnicalDebt.getMeasures();\n    assertThat(measures.get(0).getVariation1()).isEqualTo(17);\n\n    // Check on ui that it's possible to define leak period on project\n    new SeleneseTest(Selenese.builder().setHtmlTestsInClasspath(\"define-leak-period-on-project\",\n      \"/measureHistory/DifferentialPeriodsTest/define-leak-period-on-project.html\"\n    ).build()).runOn(orchestrator);\n  }","commit_id":"7630d660953cba8eee725a6a46c89dbf658bf1a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static ArrayList wput(\r\n            URL url,\r\n            String vhost,\r\n            int timeout, \r\n            String user, \r\n            String password, \r\n            httpRemoteProxyConfig theRemoteProxyConfig, \r\n            serverObjects props,\r\n            HashMap files\r\n    ) throws IOException {\r\n        // splitting of the byte array into lines\r\n        byte[] a = singlePOST(\r\n                url,\r\n                vhost,\r\n                timeout, \r\n                user, \r\n                password, \r\n                theRemoteProxyConfig, \r\n                props,\r\n                files\r\n        );\r\n        \r\n        //System.out.println(\"wput-out=\" + new String(a));\r\n        int s = 0;\r\n        int e;\r\n        ArrayList v = new ArrayList();\r\n        while (s < a.length) {\r\n            e = s; while (e < a.length) if (a[e++] < 32) {e--; break;}\r\n            v.add(new String(a, s, e - s));\r\n            s = e; while (s < a.length) if (a[s++] >= 32) {s--; break;}\r\n        }\r\n        return v;\r\n    }","id":883,"modified_method":"public static byte[] wput(\r\n            URL url,\r\n            String vhost,\r\n            int timeout, \r\n            String user, \r\n            String password, \r\n            httpRemoteProxyConfig theRemoteProxyConfig, \r\n            serverObjects props,\r\n            HashMap files\r\n    ) throws IOException {\r\n        // splitting of the byte array into lines\r\n        byte[] a = singlePOST(\r\n                url,\r\n                vhost,\r\n                timeout, \r\n                user, \r\n                password, \r\n                theRemoteProxyConfig, \r\n                props,\r\n                files\r\n        );\r\n        \r\n        if (a == null) return null;\r\n        \r\n        // support of gzipped data  \r\n        a = serverFileUtils.uncompressGZipArray(a);\r\n\r\n        // return result\r\n        return a;\r\n        \r\n        //System.out.println(\"wput-out=\" + new String(a));\r\n        //return nxTools.strings(a);\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static ArrayList strings(byte[] a, String encoding) {\r\n        int s = 0;\r\n        int e;\r\n        ArrayList v = new ArrayList();\r\n        byte b;\r\n        while (s < a.length) {\r\n            // find eol\r\n            e = s;\r\n            while (e < a.length) {\r\n                b = a[e];\r\n                if ((b == 10) || (b == 13)) break;\r\n                e++;\r\n            }\r\n            \r\n            // read line\r\n            if (encoding == null) {\r\n                v.add(new String(a, s, e - s));\r\n            } else try {\r\n                v.add(new String(a, s, e - s, encoding));\r\n            } catch (UnsupportedEncodingException xcptn) {\r\n                return v;\r\n            }\r\n            \r\n            // eat up additional eol bytes\r\n            s = e + 1;\r\n            while (s < a.length) {\r\n                b = a[s];\r\n                if ((b != 10) && (b != 13)) break;\r\n                s++;\r\n            }\r\n        }\r\n        return v;\r\n    }","id":884,"modified_method":"public static ArrayList strings(byte[] a, String encoding) {\r\n        if (a == null) return new ArrayList();\r\n        int s = 0;\r\n        int e;\r\n        ArrayList v = new ArrayList();\r\n        byte b;\r\n        while (s < a.length) {\r\n            // find eol\r\n            e = s;\r\n            while (e < a.length) {\r\n                b = a[e];\r\n                if ((b == 10) || (b == 13)) break;\r\n                e++;\r\n            }\r\n            \r\n            // read line\r\n            if (encoding == null) {\r\n                v.add(new String(a, s, e - s));\r\n            } else try {\r\n                v.add(new String(a, s, e - s, encoding));\r\n            } catch (UnsupportedEncodingException xcptn) {\r\n                return v;\r\n            }\r\n            \r\n            // eat up additional eol bytes\r\n            s = e + 1;\r\n            while (s < a.length) {\r\n                b = a[s];\r\n                if ((b != 10) && (b != 13)) break;\r\n                s++;\r\n            }\r\n        }\r\n        return v;\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap table(ArrayList list) {\r\n        Iterator i = list.iterator();\r\n        int pos;\r\n        String line;\r\n        HashMap props = new HashMap(list.size());\r\n        while (i.hasNext()) {\r\n            line = ((String) i.next()).trim();\r\n            //System.out.println(\"NXTOOLS_PROPS - LINE:\" + line);\r\n            pos = line.indexOf(\"=\");\r\n            if (pos > 0) props.put(line.substring(0, pos).trim(), line.substring(pos + 1).trim());\r\n        }\r\n        return props;\r\n    }","id":885,"modified_method":"public static HashMap table(ArrayList list) {\r\n        if (list == null) return new HashMap();\r\n        Iterator i = list.iterator();\r\n        int pos;\r\n        String line;\r\n        HashMap props = new HashMap(list.size());\r\n        while (i.hasNext()) {\r\n            line = ((String) i.next()).trim();\r\n            //System.out.println(\"NXTOOLS_PROPS - LINE:\" + line);\r\n            pos = line.indexOf(\"=\");\r\n            if (pos > 0) props.put(line.substring(0, pos).trim(), line.substring(pos + 1).trim());\r\n        }\r\n        return props;\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static String[] search(\r\n            String wordhashes,\r\n            String urlhashes,\r\n            String prefer,\r\n            String filter,\r\n            int maxDistance,\r\n            boolean global, \r\n            yacySeed targetPeer,\r\n            plasmaCrawlLURL urlManager, \r\n            plasmaWordIndex wordIndex,\r\n            indexContainer containerCache,\r\n            Map abstractCache,\r\n            plasmaURLPattern blacklist, \r\n            plasmaSnippetCache snippets, \r\n            plasmaSearchTimingProfile timingProfile,\r\n            plasmaSearchRankingProfile rankingProfile,\r\n            kelondroBitfield constraint\r\n    ) {\r\n        // send a search request to peer with remote Hash\r\n        // this mainly converts the words into word hashes\r\n\r\n        // INPUT:\r\n        // iam     : complete seed of the requesting peer\r\n        // youare  : seed hash of the target peer, used for testing network stability\r\n        // key     : transmission key for response\r\n        // search  : a list of search words\r\n        // hsearch : a string of word hashes\r\n        // fwdep   : forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n        // fwden   : forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        // count   : maximum number of wanted results\r\n        // global  : if \"true\", then result may consist of answers from other peers\r\n        // duetime : maximum time that a peer should spent to create a result\r\n\r\n        // request result\r\n        final String key = crypt.randomSalt();\r\n        try {            \r\n            // should we use the proxy?\r\n            boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n            \r\n            // building url\r\n            final String url = \"http://\" + targetPeer.getAddress() + \"/yacy/search.html\";\r\n            \r\n            // adding all needed parameters\r\n            /*\r\n            String url = \"http://\" + targetPeer.getAddress() +\r\n                \"/yacy/search.html?myseed=\" + yacyCore.seedCache.mySeed.genSeedStr(key) +\r\n                \"&youare=\" + targetPeer.hash + \"&key=\" + key +\r\n                \"&myseed=\" + yacyCore.seedCache.mySeed.genSeedStr(key) +\r\n                \"&count=\" + count + \"&resource=\" + ((global) ? \"global\" : \"local\") +\r\n                \"&query=\" + wordhashes;\r\n             */\r\n            final serverObjects obj = new serverObjects(9);\r\n            long duetime = timingProfile.duetime();\r\n            obj.put(\"myseed\", yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            obj.put(\"youare\", targetPeer.hash);\r\n            obj.put(\"key\", key);\r\n            obj.put(\"count\", timingProfile.getTargetCount(plasmaSearchTimingProfile.PROCESS_POSTSORT));\r\n            obj.put(\"resource\", ((global) ? \"global\" : \"local\"));\r\n            obj.put(\"query\", wordhashes);\r\n            obj.put(\"urls\", urlhashes);\r\n            obj.put(\"prefer\", prefer);\r\n            obj.put(\"filter\", filter);\r\n            obj.put(\"ttl\", \"0\");\r\n            obj.put(\"duetime\", Long.toString(duetime));\r\n            obj.put(\"profile\", timingProfile.targetToString()); // new duetimes splitted by specific search tasks\r\n            obj.put(\"maxdist\", maxDistance);\r\n            obj.put(\"rankingProfile\", rankingProfile.toExternalString());\r\n            obj.put(\"constraint\", constraint.exportB64());\r\n            obj.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            if (abstractCache != null) obj.put(\"abstracts\", \"auto\");\r\n            \r\n            //yacyCore.log.logDebug(\"yacyClient.search url=\" + url);\r\n            final long timestamp = System.currentTimeMillis();\r\n            \r\n            // sending request\r\n            HashMap result = null;\r\n            try {\r\n                result = nxTools.table(\r\n                    httpc.wput(\r\n                            new URL(url),\r\n                            targetPeer.getHexHash() + \".yacyh\",\r\n                            300000, \r\n                            null, \r\n                            null,\r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                            obj,\r\n                            null\r\n                    )\r\n                );\r\n            } catch (IOException e) {\r\n                yacyCore.log.logFine(\"SEARCH failed FROM \" + targetPeer.hash + \":\" + targetPeer.getName() + \" (\" + e.getMessage() + \"), score=\" + targetPeer.selectscore + \", DHTdist=\" + yacyDHTAction.dhtDistance(targetPeer.hash, wordhashes));\r\n                yacyCore.peerActions.peerDeparture(targetPeer);\r\n                return null;\r\n            }\r\n\r\n            if (result.size() == 0) {\r\n                yacyCore.log.logFine(\"SEARCH failed FROM \" + targetPeer.hash + \":\" + targetPeer.getName() + \" (zero response), score=\" + targetPeer.selectscore + \", DHTdist=\" + yacyDHTAction.dhtDistance(targetPeer.hash, wordhashes));\r\n                return null;\r\n            }\r\n            \r\n            // compute all computation times\r\n            final long totalrequesttime = System.currentTimeMillis() - timestamp;\r\n            String returnProfile = (String) result.get(\"profile\");\r\n            if (returnProfile != null) timingProfile.putYield(returnProfile);\r\n            \r\n            /*\r\n            HashMap result = nxTools.table(httpc.wget(new URL(url),\r\n                            300000, null, null, yacyCore.seedCache.remoteProxyHost, yacyCore.seedCache.remoteProxyPort));\r\n             */\r\n            // OUTPUT:\r\n            // version     : application version of responder\r\n            // uptime      : uptime in seconds of responder\r\n            // total       : number of total available LURL's for this search\r\n            // count       : number of returned LURL's for this search\r\n            // resource<n> : LURL of search\r\n            // fwhop       : hops (depth) of forwards that had been performed to construct this result\r\n            // fwsrc       : peers that helped to construct this result\r\n            // fwrec       : peers that would have helped to construct this result (recommendations)\r\n            // searchtime  : time that the peer actually spent to create the result\r\n            // references  : references (search hints) that was calculated during search\r\n\r\n            // now create a plasmaIndex out of this result\r\n            //System.out.println(\"yacyClient: \" + ((urlhashes.length() == 0) ? \"primary\" : \"secondary\")+ \" search result = \" + result.toString()); // debug\r\n            final int results = Integer.parseInt((String) result.get(\"count\"));\r\n            //System.out.println(\"***result count \" + results);\r\n            \r\n            // create containers\r\n            final int words = wordhashes.length() / yacySeedDB.commonHashLength;\r\n            indexContainer[] container = new indexContainer[words];\r\n            for (int i = 0; i < words; i++) {\r\n                container[i] = wordIndex.emptyContainer(wordhashes.substring(i * yacySeedDB.commonHashLength, (i + 1) * yacySeedDB.commonHashLength));\r\n            }\r\n\r\n            // insert results to containers\r\n            indexURLEntry urlEntry;\r\n            String[] urls = new String[results];\r\n            for (int n = 0; n < results; n++) {\r\n                // get one single search result\r\n                urlEntry = urlManager.newEntry((String) result.get(\"resource\" + n));\r\n                if (urlEntry == null) continue;\r\n                assert (urlEntry.hash().length() == 12) : \"urlEntry.hash() = \" + urlEntry.hash();\r\n                if (urlEntry.hash().length() != 12) continue; // bad url hash\r\n                indexURLEntry.Components comp = urlEntry.comp();\r\n                if (blacklist.isListed(plasmaURLPattern.BLACKLIST_SEARCH, comp.url())) continue; // block with backlist\r\n                urlManager.store(urlEntry);\r\n                urlManager.stack(urlEntry, yacyCore.seedDB.mySeed.hash, targetPeer.hash, 2);\r\n\r\n                // save the url entry\r\n                indexRWIEntry entry;\r\n                if (urlEntry.word() == null) {\r\n                    // the old way to define words\r\n                    int urlLength = comp.url().toNormalform().length();\r\n                    int urlComps = htmlFilterContentScraper.urlComps(comp.url().toNormalform()).length;\r\n                    \r\n                    entry = wordIndex.newRWIEntry(\r\n                                                     urlEntry.hash(),\r\n                                                     urlLength,\r\n                                                     urlComps,\r\n                                                     comp.descr().length(),\r\n                                                     urlEntry.wordCount(),\r\n                                                     0, 0, 0, 0, 0, 0,\r\n                                                     urlEntry.size(),\r\n                                                     urlEntry.moddate().getTime(),\r\n                                                     System.currentTimeMillis(),\r\n                                                     0,\r\n                                                     urlEntry.language(),\r\n                                                     urlEntry.doctype(),\r\n                                                     0,0,\r\n                                                     new kelondroBitfield(4)\r\n                                                    );\r\n                } else {\r\n                    // the new way: the search-result-url transports all the attributes of word indexes\r\n                    entry = urlEntry.word();\r\n                }\r\n                if (urlEntry.snippet() != null) {\r\n                    // we don't store the snippets along the url entry, because they are search-specific.\r\n                    // instead, they are placed in a snipped-search cache.\r\n                    //System.out.println(\"--- RECEIVED SNIPPET '\" + link.snippet() + \"'\");\r\n                    snippets.storeToCache(wordhashes, urlEntry.hash(), urlEntry.snippet());\r\n                }\r\n                // add the url entry to the word indexes\r\n                for (int m = 0; m < words; m++) {\r\n                    if ((wordIndex.useCollectionIndex) && (entry instanceof indexRWIEntryOld)) {\r\n                        entry = new indexRWIEntryNew((indexRWIEntryOld) entry);\r\n                    }\r\n                    container[m].add(new indexRWIEntry[]{entry}, System.currentTimeMillis());\r\n                }\r\n                // store url hash for statistics\r\n                urls[n] = urlEntry.hash();\r\n            }\r\n\r\n            // insert the containers to the index\r\n            for (int m = 0; m < words; m++) { containerCache.add(container[m], -1); }\r\n\r\n            // read index abstract\r\n            if (abstractCache != null) {\r\n                Iterator i = result.entrySet().iterator();\r\n                Map.Entry entry;\r\n                TreeMap singleAbstract;\r\n                String wordhash;\r\n                serverByteBuffer ci;\r\n                while (i.hasNext()) {\r\n                    entry = (Map.Entry) i.next();\r\n                    if (((String) entry.getKey()).startsWith(\"indexabstract.\")) {\r\n                        wordhash = ((String) entry.getKey()).substring(14);\r\n                        synchronized (abstractCache) {\r\n                            singleAbstract = (TreeMap) abstractCache.get(wordhash); // a mapping from url-hashes to a string of peer-hashes\r\n                            if (singleAbstract == null) singleAbstract = new TreeMap();\r\n                            ci = new serverByteBuffer(((String) entry.getValue()).getBytes());\r\n                            System.out.println(\"DEBUG-ABSTRACTFETCH: for word hash \" + wordhash + \" received \" + ci.toString());\r\n                            plasmaURL.decompressIndex(singleAbstract, ci, targetPeer.hash);\r\n                            abstractCache.put(wordhash, singleAbstract);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // generate statistics\r\n            long searchtime;\r\n            try {\r\n                searchtime = Integer.parseInt((String) result.get(\"searchtime\"));\r\n            } catch (NumberFormatException e) {\r\n                searchtime = totalrequesttime;\r\n            }\r\n            yacyCore.log.logFine(\"SEARCH \" + results + \" URLS FROM \" + targetPeer.hash + \":\" + targetPeer.getName() + \", score=\" + targetPeer.selectscore + \", DHTdist=\" + yacyDHTAction.dhtDistance(targetPeer.hash, wordhashes) + \", duetime=\" + duetime + \", searchtime=\" + searchtime + \", netdelay=\" + (totalrequesttime - searchtime) + \", references=\" + result.get(\"references\"));\r\n            return urls;\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.search error: '\" + targetPeer.get(yacySeed.NAME, \"anonymous\") + \"' failed - \" + e);\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }","id":886,"modified_method":"public static String[] search(\r\n            String wordhashes,\r\n            String urlhashes,\r\n            String prefer,\r\n            String filter,\r\n            int maxDistance,\r\n            boolean global, \r\n            yacySeed targetPeer,\r\n            plasmaCrawlLURL urlManager, \r\n            plasmaWordIndex wordIndex,\r\n            indexContainer containerCache,\r\n            Map abstractCache,\r\n            plasmaURLPattern blacklist, \r\n            plasmaSnippetCache snippets, \r\n            plasmaSearchTimingProfile timingProfile,\r\n            plasmaSearchRankingProfile rankingProfile,\r\n            kelondroBitfield constraint\r\n    ) {\r\n        // send a search request to peer with remote Hash\r\n        // this mainly converts the words into word hashes\r\n\r\n        // INPUT:\r\n        // iam     : complete seed of the requesting peer\r\n        // youare  : seed hash of the target peer, used for testing network stability\r\n        // key     : transmission key for response\r\n        // search  : a list of search words\r\n        // hsearch : a string of word hashes\r\n        // fwdep   : forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n        // fwden   : forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        // count   : maximum number of wanted results\r\n        // global  : if \"true\", then result may consist of answers from other peers\r\n        // duetime : maximum time that a peer should spent to create a result\r\n\r\n        // request result\r\n        final String key = crypt.randomSalt();\r\n        try {            \r\n            // should we use the proxy?\r\n            boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n            \r\n            // building url\r\n            final String url = \"http://\" + targetPeer.getAddress() + \"/yacy/search.html\";\r\n            \r\n            // adding all needed parameters\r\n            /*\r\n            String url = \"http://\" + targetPeer.getAddress() +\r\n                \"/yacy/search.html?myseed=\" + yacyCore.seedCache.mySeed.genSeedStr(key) +\r\n                \"&youare=\" + targetPeer.hash + \"&key=\" + key +\r\n                \"&myseed=\" + yacyCore.seedCache.mySeed.genSeedStr(key) +\r\n                \"&count=\" + count + \"&resource=\" + ((global) ? \"global\" : \"local\") +\r\n                \"&query=\" + wordhashes;\r\n             */\r\n            final serverObjects obj = new serverObjects(9);\r\n            long duetime = timingProfile.duetime();\r\n            obj.put(\"myseed\", yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            obj.put(\"youare\", targetPeer.hash);\r\n            obj.put(\"key\", key);\r\n            obj.put(\"count\", timingProfile.getTargetCount(plasmaSearchTimingProfile.PROCESS_POSTSORT));\r\n            obj.put(\"resource\", ((global) ? \"global\" : \"local\"));\r\n            obj.put(\"query\", wordhashes);\r\n            obj.put(\"urls\", urlhashes);\r\n            obj.put(\"prefer\", prefer);\r\n            obj.put(\"filter\", filter);\r\n            obj.put(\"ttl\", \"0\");\r\n            obj.put(\"duetime\", Long.toString(duetime));\r\n            obj.put(\"profile\", timingProfile.targetToString()); // new duetimes splitted by specific search tasks\r\n            obj.put(\"maxdist\", maxDistance);\r\n            obj.put(\"rankingProfile\", rankingProfile.toExternalString());\r\n            obj.put(\"constraint\", constraint.exportB64());\r\n            obj.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            if (abstractCache != null) obj.put(\"abstracts\", \"auto\");\r\n            \r\n            //yacyCore.log.logDebug(\"yacyClient.search url=\" + url);\r\n            final long timestamp = System.currentTimeMillis();\r\n            \r\n            // sending request\r\n            HashMap result = null;\r\n            try {\r\n                result = nxTools.table(\r\n                    httpc.wput(\r\n                            new URL(url),\r\n                            targetPeer.getHexHash() + \".yacyh\",\r\n                            300000, \r\n                            null, \r\n                            null,\r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                            obj,\r\n                            null\r\n                    ), \"UTF-8\"\r\n                );\r\n            } catch (IOException e) {\r\n                yacyCore.log.logFine(\"SEARCH failed FROM \" + targetPeer.hash + \":\" + targetPeer.getName() + \" (\" + e.getMessage() + \"), score=\" + targetPeer.selectscore + \", DHTdist=\" + yacyDHTAction.dhtDistance(targetPeer.hash, wordhashes));\r\n                yacyCore.peerActions.peerDeparture(targetPeer);\r\n                return null;\r\n            }\r\n\r\n            if (result.size() == 0) {\r\n                yacyCore.log.logFine(\"SEARCH failed FROM \" + targetPeer.hash + \":\" + targetPeer.getName() + \" (zero response), score=\" + targetPeer.selectscore + \", DHTdist=\" + yacyDHTAction.dhtDistance(targetPeer.hash, wordhashes));\r\n                return null;\r\n            }\r\n            \r\n            // compute all computation times\r\n            final long totalrequesttime = System.currentTimeMillis() - timestamp;\r\n            String returnProfile = (String) result.get(\"profile\");\r\n            if (returnProfile != null) timingProfile.putYield(returnProfile);\r\n            \r\n            /*\r\n            HashMap result = nxTools.table(httpc.wget(new URL(url),\r\n                            300000, null, null, yacyCore.seedCache.remoteProxyHost, yacyCore.seedCache.remoteProxyPort));\r\n             */\r\n            // OUTPUT:\r\n            // version     : application version of responder\r\n            // uptime      : uptime in seconds of responder\r\n            // total       : number of total available LURL's for this search\r\n            // count       : number of returned LURL's for this search\r\n            // resource<n> : LURL of search\r\n            // fwhop       : hops (depth) of forwards that had been performed to construct this result\r\n            // fwsrc       : peers that helped to construct this result\r\n            // fwrec       : peers that would have helped to construct this result (recommendations)\r\n            // searchtime  : time that the peer actually spent to create the result\r\n            // references  : references (search hints) that was calculated during search\r\n\r\n            // now create a plasmaIndex out of this result\r\n            //System.out.println(\"yacyClient: \" + ((urlhashes.length() == 0) ? \"primary\" : \"secondary\")+ \" search result = \" + result.toString()); // debug\r\n            final int results = Integer.parseInt((String) result.get(\"count\"));\r\n            //System.out.println(\"***result count \" + results);\r\n            \r\n            // create containers\r\n            final int words = wordhashes.length() / yacySeedDB.commonHashLength;\r\n            indexContainer[] container = new indexContainer[words];\r\n            for (int i = 0; i < words; i++) {\r\n                container[i] = wordIndex.emptyContainer(wordhashes.substring(i * yacySeedDB.commonHashLength, (i + 1) * yacySeedDB.commonHashLength));\r\n            }\r\n\r\n            // insert results to containers\r\n            indexURLEntry urlEntry;\r\n            String[] urls = new String[results];\r\n            for (int n = 0; n < results; n++) {\r\n                // get one single search result\r\n                urlEntry = urlManager.newEntry((String) result.get(\"resource\" + n));\r\n                if (urlEntry == null) continue;\r\n                assert (urlEntry.hash().length() == 12) : \"urlEntry.hash() = \" + urlEntry.hash();\r\n                if (urlEntry.hash().length() != 12) continue; // bad url hash\r\n                indexURLEntry.Components comp = urlEntry.comp();\r\n                if (blacklist.isListed(plasmaURLPattern.BLACKLIST_SEARCH, comp.url())) continue; // block with backlist\r\n                urlManager.store(urlEntry);\r\n                urlManager.stack(urlEntry, yacyCore.seedDB.mySeed.hash, targetPeer.hash, 2);\r\n\r\n                // save the url entry\r\n                indexRWIEntry entry;\r\n                if (urlEntry.word() == null) {\r\n                    // the old way to define words\r\n                    int urlLength = comp.url().toNormalform().length();\r\n                    int urlComps = htmlFilterContentScraper.urlComps(comp.url().toNormalform()).length;\r\n                    \r\n                    entry = wordIndex.newRWIEntry(\r\n                                                     urlEntry.hash(),\r\n                                                     urlLength,\r\n                                                     urlComps,\r\n                                                     comp.descr().length(),\r\n                                                     urlEntry.wordCount(),\r\n                                                     0, 0, 0, 0, 0, 0,\r\n                                                     urlEntry.size(),\r\n                                                     urlEntry.moddate().getTime(),\r\n                                                     System.currentTimeMillis(),\r\n                                                     0,\r\n                                                     urlEntry.language(),\r\n                                                     urlEntry.doctype(),\r\n                                                     0,0,\r\n                                                     new kelondroBitfield(4)\r\n                                                    );\r\n                } else {\r\n                    // the new way: the search-result-url transports all the attributes of word indexes\r\n                    entry = urlEntry.word();\r\n                }\r\n                if (urlEntry.snippet() != null) {\r\n                    // we don't store the snippets along the url entry, because they are search-specific.\r\n                    // instead, they are placed in a snipped-search cache.\r\n                    //System.out.println(\"--- RECEIVED SNIPPET '\" + link.snippet() + \"'\");\r\n                    snippets.storeToCache(wordhashes, urlEntry.hash(), urlEntry.snippet());\r\n                }\r\n                // add the url entry to the word indexes\r\n                for (int m = 0; m < words; m++) {\r\n                    if ((wordIndex.useCollectionIndex) && (entry instanceof indexRWIEntryOld)) {\r\n                        entry = new indexRWIEntryNew((indexRWIEntryOld) entry);\r\n                    }\r\n                    container[m].add(new indexRWIEntry[]{entry}, System.currentTimeMillis());\r\n                }\r\n                // store url hash for statistics\r\n                urls[n] = urlEntry.hash();\r\n            }\r\n\r\n            // insert the containers to the index\r\n            for (int m = 0; m < words; m++) { containerCache.add(container[m], -1); }\r\n\r\n            // read index abstract\r\n            if (abstractCache != null) {\r\n                Iterator i = result.entrySet().iterator();\r\n                Map.Entry entry;\r\n                TreeMap singleAbstract;\r\n                String wordhash;\r\n                serverByteBuffer ci;\r\n                while (i.hasNext()) {\r\n                    entry = (Map.Entry) i.next();\r\n                    if (((String) entry.getKey()).startsWith(\"indexabstract.\")) {\r\n                        wordhash = ((String) entry.getKey()).substring(14);\r\n                        synchronized (abstractCache) {\r\n                            singleAbstract = (TreeMap) abstractCache.get(wordhash); // a mapping from url-hashes to a string of peer-hashes\r\n                            if (singleAbstract == null) singleAbstract = new TreeMap();\r\n                            ci = new serverByteBuffer(((String) entry.getValue()).getBytes());\r\n                            System.out.println(\"DEBUG-ABSTRACTFETCH: for word hash \" + wordhash + \" received \" + ci.toString());\r\n                            plasmaURL.decompressIndex(singleAbstract, ci, targetPeer.hash);\r\n                            abstractCache.put(wordhash, singleAbstract);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // generate statistics\r\n            long searchtime;\r\n            try {\r\n                searchtime = Integer.parseInt((String) result.get(\"searchtime\"));\r\n            } catch (NumberFormatException e) {\r\n                searchtime = totalrequesttime;\r\n            }\r\n            yacyCore.log.logFine(\"SEARCH \" + results + \" URLS FROM \" + targetPeer.hash + \":\" + targetPeer.getName() + \", score=\" + targetPeer.selectscore + \", DHTdist=\" + yacyDHTAction.dhtDistance(targetPeer.hash, wordhashes) + \", duetime=\" + duetime + \", searchtime=\" + searchtime + \", netdelay=\" + (totalrequesttime - searchtime) + \", references=\" + result.get(\"references\"));\r\n            return urls;\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.search error: '\" + targetPeer.get(yacySeed.NAME, \"anonymous\") + \"' failed - \" + e);\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap transferPermission(String targetAddress, long filesize, String filename) {\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB != null) &&\r\n                           (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // add all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects();\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"permission\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"purpose\", \"crcon\");\r\n        post.put(\"filename\", filename);\r\n        post.put(\"filesize\", Long.toString(filesize));\r\n        post.put(\"can-send-protocol\", \"http\");\r\n        \r\n        // send request\r\n        try {\r\n            final URL url = new URL(\"http://\" + targetAddress + \"/yacy/transfer.html\");\r\n            return nxTools.table(\r\n                    httpc.wput(\r\n                            url,\r\n                            url.getHost(), // yacyCore.seedDB.mySeed.getHexHash() + \".yacyh\",\r\n                            8000, \r\n                            null, \r\n                            null, \r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                            post,\r\n                            null\r\n                    )\r\n            );\r\n        } catch (Exception e) {\r\n            // most probably a network time-out exception\r\n            yacyCore.log.logSevere(\"yacyClient.permissionTransfer error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":887,"modified_method":"public static HashMap transferPermission(String targetAddress, long filesize, String filename) {\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB != null) &&\r\n                           (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // add all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects();\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"permission\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"purpose\", \"crcon\");\r\n        post.put(\"filename\", filename);\r\n        post.put(\"filesize\", Long.toString(filesize));\r\n        post.put(\"can-send-protocol\", \"http\");\r\n        \r\n        // send request\r\n        try {\r\n            final URL url = new URL(\"http://\" + targetAddress + \"/yacy/transfer.html\");\r\n            return nxTools.table(\r\n                    httpc.wput(\r\n                            url,\r\n                            url.getHost(), // yacyCore.seedDB.mySeed.getHexHash() + \".yacyh\",\r\n                            8000, \r\n                            null, \r\n                            null, \r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                            post,\r\n                            null\r\n                    ), \"UTF-8\"\r\n            );\r\n        } catch (Exception e) {\r\n            // most probably a network time-out exception\r\n            yacyCore.log.logSevere(\"yacyClient.permissionTransfer error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static HashMap transferURL(yacySeed targetSeed, indexURLEntry[] urls, boolean gzipBody, int timeout) {\r\n        // this post a message to the remote message board\r\n        final String address = targetSeed.getAddress();\r\n        if (address == null) { return null; }\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // prepare post values\r\n        final serverObjects post = new serverObjects(5+urls.length);\r\n        final String key = crypt.randomSalt();\r\n        \r\n        // enabling gzip compression for post request body\r\n        if ((gzipBody) && (targetSeed.getVersion() >= yacyVersion.YACY_SUPPORTS_GZIP_POST_REQUESTS)) {\r\n            post.put(httpc.GZIP_POST_BODY,\"true\");\r\n        }        \r\n        \r\n        post.put(\"key\", key);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        String resource = \"\";\r\n        int urlc = 0;\r\n        int urlPayloadSize = 0;\r\n        for (int i = 0; i < urls.length; i++) {\r\n            if (urls[i] != null) {\r\n                resource = urls[i].toString();                \r\n                if (resource != null) {\r\n                    post.put(\"url\" + urlc, resource);\r\n                    urlPayloadSize += resource.length();\r\n                    urlc++;\r\n                }\r\n            }\r\n        }\r\n        post.put(\"urlc\", Integer.toString(urlc));\r\n        try {\r\n            final ArrayList v = httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/transferURL.html\"),\r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    timeout, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n            );\r\n            \r\n            if (v != null) {\r\n                yacyCore.seedDB.mySeed.incSU(urlc);\r\n            }\r\n            \r\n            HashMap result = nxTools.table(v);\r\n            // return the transfered url data in bytes (for debugging only)\r\n            result.put(\"urlPayloadSize\", new Integer(urlPayloadSize));            \r\n            return result;\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.transferURL error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":888,"modified_method":"private static HashMap transferURL(yacySeed targetSeed, indexURLEntry[] urls, boolean gzipBody, int timeout) {\r\n        // this post a message to the remote message board\r\n        final String address = targetSeed.getAddress();\r\n        if (address == null) { return null; }\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // prepare post values\r\n        final serverObjects post = new serverObjects(5+urls.length);\r\n        final String key = crypt.randomSalt();\r\n        \r\n        // enabling gzip compression for post request body\r\n        if ((gzipBody) && (targetSeed.getVersion() >= yacyVersion.YACY_SUPPORTS_GZIP_POST_REQUESTS)) {\r\n            post.put(httpc.GZIP_POST_BODY,\"true\");\r\n        }        \r\n        \r\n        post.put(\"key\", key);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        String resource = \"\";\r\n        int urlc = 0;\r\n        int urlPayloadSize = 0;\r\n        for (int i = 0; i < urls.length; i++) {\r\n            if (urls[i] != null) {\r\n                resource = urls[i].toString();                \r\n                if (resource != null) {\r\n                    post.put(\"url\" + urlc, resource);\r\n                    urlPayloadSize += resource.length();\r\n                    urlc++;\r\n                }\r\n            }\r\n        }\r\n        post.put(\"urlc\", Integer.toString(urlc));\r\n        try {\r\n            final ArrayList v = nxTools.strings(\r\n                httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/transferURL.html\"),\r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    timeout, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n                ), \"UTF-8\");\r\n            \r\n            if ((v != null) && (v.size() > 0)) {\r\n                yacyCore.seedDB.mySeed.incSU(urlc);\r\n            }\r\n            \r\n            HashMap result = nxTools.table(v);\r\n            // return the transfered url data in bytes (for debugging only)\r\n            result.put(\"urlPayloadSize\", new Integer(urlPayloadSize));            \r\n            return result;\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.transferURL error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap getProfile(yacySeed targetSeed) {\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // this post a message to the remote message board\r\n        final serverObjects post = new serverObjects(2);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        String address = targetSeed.getAddress();\r\n        if (address == null) { address = \"localhost:8080\"; }\r\n        try {\r\n            final ArrayList v = httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/profile.html\"), \r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    10000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n            );\r\n            \r\n            return nxTools.table(v);\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.getProfile error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":889,"modified_method":"public static HashMap getProfile(yacySeed targetSeed) {\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // this post a message to the remote message board\r\n        final serverObjects post = new serverObjects(2);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        String address = targetSeed.getAddress();\r\n        if (address == null) { address = \"localhost:8080\"; }\r\n        try {\r\n            return nxTools.table(\r\n                httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/profile.html\"), \r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    10000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n                ), \"UTF-8\");\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.getProfile error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static HashMap transferRWI(yacySeed targetSeed, indexContainer[] indexes, boolean gzipBody, int timeout) {\r\n        final String address = targetSeed.getAddress();\r\n        if (address == null) { return null; }\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // prepare post values\r\n        final serverObjects post = new serverObjects(7);\r\n        final String key = crypt.randomSalt();\r\n        \r\n        // enabling gzip compression for post request body\r\n        if ((gzipBody) && (targetSeed.getVersion() >= yacyVersion.YACY_SUPPORTS_GZIP_POST_REQUESTS)) {\r\n            post.put(httpc.GZIP_POST_BODY,\"true\");\r\n        }\r\n        post.put(\"key\", key);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        post.put(\"wordc\", Integer.toString(indexes.length));\r\n        \r\n        \r\n        int indexcount = 0;\r\n        final StringBuffer entrypost = new StringBuffer(indexes.length*73);\r\n        Iterator eenum;\r\n        indexRWIEntry entry;\r\n        for (int i = 0; i < indexes.length; i++) {\r\n            eenum = indexes[i].entries();\r\n            while (eenum.hasNext()) {\r\n                entry = (indexRWIEntry) eenum.next();\r\n                entrypost.append(indexes[i].getWordHash()) \r\n                         .append(entry.toPropertyForm()) \r\n                         .append(serverCore.crlfString);\r\n                indexcount++;\r\n            }\r\n        }\r\n\r\n        if (indexcount == 0) {\r\n            // nothing to do but everything ok\r\n            final HashMap result = new HashMap(2);\r\n            result.put(\"result\", \"ok\");\r\n            result.put(\"unknownURL\", \"\");\r\n            return result;\r\n        }\r\n\r\n        post.put(\"entryc\", Integer.toString(indexcount));\r\n        post.put(\"indexes\", entrypost.toString());\r\n        try {\r\n            final ArrayList v = httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/transferRWI.html\"), \r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    timeout, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n            );\r\n            // this should return a list of urlhashes that are unknwon\r\n            if (v != null) {\r\n                yacyCore.seedDB.mySeed.incSI(indexcount);\r\n            }\r\n            \r\n            final HashMap result = nxTools.table(v);\r\n            // return the transfered index data in bytes (for debugging only)\r\n            result.put(\"indexPayloadSize\", new Integer(entrypost.length()));\r\n            return result;\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.transferRWI error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":890,"modified_method":"private static HashMap transferRWI(yacySeed targetSeed, indexContainer[] indexes, boolean gzipBody, int timeout) {\r\n        final String address = targetSeed.getAddress();\r\n        if (address == null) { return null; }\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // prepare post values\r\n        final serverObjects post = new serverObjects(7);\r\n        final String key = crypt.randomSalt();\r\n        \r\n        // enabling gzip compression for post request body\r\n        if ((gzipBody) && (targetSeed.getVersion() >= yacyVersion.YACY_SUPPORTS_GZIP_POST_REQUESTS)) {\r\n            post.put(httpc.GZIP_POST_BODY,\"true\");\r\n        }\r\n        post.put(\"key\", key);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        post.put(\"wordc\", Integer.toString(indexes.length));\r\n        \r\n        \r\n        int indexcount = 0;\r\n        final StringBuffer entrypost = new StringBuffer(indexes.length*73);\r\n        Iterator eenum;\r\n        indexRWIEntry entry;\r\n        for (int i = 0; i < indexes.length; i++) {\r\n            eenum = indexes[i].entries();\r\n            while (eenum.hasNext()) {\r\n                entry = (indexRWIEntry) eenum.next();\r\n                entrypost.append(indexes[i].getWordHash()) \r\n                         .append(entry.toPropertyForm()) \r\n                         .append(serverCore.crlfString);\r\n                indexcount++;\r\n            }\r\n        }\r\n\r\n        if (indexcount == 0) {\r\n            // nothing to do but everything ok\r\n            final HashMap result = new HashMap(2);\r\n            result.put(\"result\", \"ok\");\r\n            result.put(\"unknownURL\", \"\");\r\n            return result;\r\n        }\r\n\r\n        post.put(\"entryc\", Integer.toString(indexcount));\r\n        post.put(\"indexes\", entrypost.toString());\r\n        try {\r\n            final ArrayList v = nxTools.strings(\r\n                httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/transferRWI.html\"), \r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    timeout, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n                ), \"UTF-8\");\r\n            // this should return a list of urlhashes that are unknwon\r\n            if ((v != null) && (v.size() > 0)) {\r\n                yacyCore.seedDB.mySeed.incSI(indexcount);\r\n            }\r\n            \r\n            final HashMap result = nxTools.table(v);\r\n            // return the transfered index data in bytes (for debugging only)\r\n            result.put(\"indexPayloadSize\", new Integer(entrypost.length()));\r\n            return result;\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.transferRWI error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static int publishMySeed(String address, String otherHash) {\r\n        // this is called to enrich the seed information by\r\n        // - own address (if peer is behind a nat/router)\r\n        // - check peer type (virgin/junior/senior/principal)\r\n        // to do this, we send a 'Hello' to another peer\r\n        // this carries the following information:\r\n        // 'iam' - own hash\r\n        // 'youare' - remote hash, to verify that we are correct\r\n        // 'key' - a session key that the remote peer may use to answer\r\n        // and the own seed string\r\n        // we expect the following information to be send back:\r\n        // - 'yourip' the ip of the connection peer (we)\r\n        // - 'yourtype' the type of this peer that the other peer checked by asking for a specific word\r\n        // and the remote seed string\r\n        // the number of new seeds are returned\r\n        // one exceptional failure case is when we know the other's peers hash, the other peers responds correctly\r\n        // but they appear to be another peer by comparisment of the other peer's hash\r\n        // this works of course only if we know the other peer's hash.\r\n        \r\n        final String key = crypt.randomSalt();\r\n        HashMap result = null;\r\n        try {\r\n            /*\r\n            URL url = new URL(\"http://\" + address + \"/yacy/hello.html?iam=\" +\r\n                              yacyCore.seedCache.mySeed.hash +\r\n                              \"&pattern=&count=20\" +\r\n                              \"&key=\" + key + \"&seed=\" + yacyCore.seedCache.mySeed.genSeedStr(key));\r\n            yacyCore.log.logDebug(\"HELLO to URL \" + url.toString());\r\n            result = nxTools.table(httpc.wget(url,\r\n                        10000, null, null, yacyCore.seedCache.sb.remoteProxyHost, yacyCore.seedCache.sb.remoteProxyPort));\r\n             */\r\n\r\n            // building URL\r\n            final URL url = new URL(\"http://\" + address + \"/yacy/hello.html\");\r\n            \r\n            // should we use the proxy?\r\n            boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) &&  \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n            \r\n            // adding all needed parameters\r\n            final serverObjects obj = new serverObjects(6);\r\n                obj.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n                obj.put(\"pattern\", \"\");\r\n                obj.put(\"count\", \"20\");\r\n                obj.put(\"key\", key);\r\n                obj.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n                obj.put(\"myUTC\", System.currentTimeMillis());\r\n                obj.put(yacySeed.SEED, yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            \r\n            // sending request\r\n            result = nxTools.table(\r\n                    httpc.wput(url,\r\n                               yacySeed.b64Hash2hexHash(otherHash) + \".yacyh\",\r\n                               105000, \r\n                               null, \r\n                               null,\r\n                               (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                               obj,\r\n                               null\r\n                    )\r\n            );\r\n        } catch (Exception e) {\r\n            if (Thread.currentThread().isInterrupted()) {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed thread '\" + Thread.currentThread().getName() + \"' interrupted.\");\r\n            } else {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed exception:\" + e.getMessage());\r\n            }\r\n            return -1;\r\n        }\r\n        if (result == null || result.size() < 3) {\r\n            yacyCore.log.logFine(\"yacyClient.publishMySeed result error: \" +\r\n            ((result == null) ? \"result null\" : (\"result=\" + result.toString())));\r\n            return -1;\r\n        }\r\n\r\n        // check consistency with expectation\r\n        yacySeed otherPeer = null;\r\n        float otherPeerVersion = 0;\r\n        if (otherHash != null && otherHash.length() > 0) {\r\n            otherPeer = yacySeed.genRemoteSeed((String) result.get(\"seed0\"), key, true);\r\n            if (otherPeer == null || !otherPeer.hash.equals(otherHash)) {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed: consistency error: other peer '\" + ((otherPeer==null)?\"unknown\":otherPeer.getName()) + \"' wrong\");\r\n                return -1; // no success\r\n            }\r\n            otherPeerVersion = otherPeer.getVersion();\r\n        }\r\n\r\n        // set my own seed according to new information\r\n        final yacySeed mySeedBkp = (yacySeed) yacyCore.seedDB.mySeed.clone();\r\n\r\n        // we overwrite our own IP number only, if we do not portForwarding\r\n        if (serverCore.portForwardingEnabled || serverCore.useStaticIP) {\r\n            yacyCore.seedDB.mySeed.put(yacySeed.IP, serverCore.publicIP());\r\n        } else {\r\n            yacyCore.seedDB.mySeed.put(yacySeed.IP, (String) result.get(yacySeed.YOURIP));\r\n        }\r\n\r\n        /* If we have port forwarding enabled but the other peer uses a too old yacy version\r\n         * we can ignore the seed-type that was reported by the peer.\r\n         * \r\n         * Otherwise we have to change our seed-type  \r\n         * \r\n         * @see serverCore#portForwardingEnabled \r\n         */\r\n        if (!serverCore.portForwardingEnabled || otherPeerVersion >= yacyVersion.YACY_SUPPORTS_PORT_FORWARDING) {\r\n            String mytype = (String) result.get(yacySeed.YOURTYPE);\r\n            if (mytype == null) { mytype = yacySeed.PEERTYPE_JUNIOR; }        \r\n            yacyAccessible accessible = new yacyAccessible();\r\n            if (mytype.equals(yacySeed.PEERTYPE_SENIOR)||mytype.equals(yacySeed.PEERTYPE_PRINCIPAL)) {\r\n                accessible.IWasAccessed = true;\r\n                if (yacyCore.seedDB.mySeed.isPrincipal()) {\r\n                    mytype = yacySeed.PEERTYPE_PRINCIPAL;\r\n                }\r\n            } else {\r\n                accessible.IWasAccessed = false;\r\n            }\r\n            accessible.lastUpdated = System.currentTimeMillis();\r\n            yacyCore.amIAccessibleDB.put(otherHash, accessible);\r\n\r\n            /* \r\n             * If we were reported as junior we have to check if your port forwarding channel is broken\r\n             * If this is true we try to reconnect the sch channel to the remote server now.\r\n             */\r\n            if (mytype.equalsIgnoreCase(yacySeed.PEERTYPE_JUNIOR)) {\r\n                yacyCore.log.logInfo(\"yacyClient.publishMySeed: Peer '\" + ((otherPeer==null)?\"unknown\":otherPeer.getName()) + \"' reported us as junior.\");\r\n                if (serverCore.portForwardingEnabled) {\r\n                    if (!Thread.currentThread().isInterrupted() && \r\n                         serverCore.portForwarding != null && \r\n                        !serverCore.portForwarding.isConnected()\r\n                    ) {\r\n                        yacyCore.log.logWarning(\"yacyClient.publishMySeed: Broken portForwarding channel detected. Trying to reconnect ...\");                        \r\n                        try {\r\n                            serverCore.portForwarding.reconnect();\r\n                        } catch (IOException e) {\r\n                            yacyCore.log.logWarning(\"yacyClient.publishMySeed: Unable to reconnect to port forwarding host.\");\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed: Peer '\" + ((otherPeer==null)?\"unknown\":otherPeer.getName()) + \"' reported us as \" + mytype + \".\");\r\n            }\r\n            if (yacyCore.seedDB.mySeed.orVirgin().equals(yacySeed.PEERTYPE_VIRGIN))\r\n                yacyCore.seedDB.mySeed.put(yacySeed.PEERTYPE, mytype);\r\n        }\r\n\r\n        final String error = yacyCore.seedDB.mySeed.isProper();\r\n        if (error != null) {\r\n            yacyCore.seedDB.mySeed = mySeedBkp;\r\n            yacyCore.log.logFine(\"yacyClient.publishMySeed mySeed error - not proper: \" + error);\r\n            return -1;\r\n        }\r\n\r\n        //final Date remoteTime = yacyCore.parseUniversalDate((String) result.get(yacySeed.MYTIME)); // read remote time\r\n        \r\n        // read the seeds that the peer returned and integrate them into own database\r\n        int i = 0;\r\n        int count = 0;\r\n        String seedStr;\r\n        while ((seedStr = (String) result.get(yacySeed.SEED + i++)) != null) {\r\n            // integrate new seed into own database\r\n            // the first seed, \"seed0\" is the seed of the responding peer\r\n            if (yacyCore.peerActions.peerArrival(yacySeed.genRemoteSeed(seedStr, key, true), (i == 1))) count++;\r\n        }\r\n        return count;\r\n    }","id":891,"modified_method":"public static int publishMySeed(String address, String otherHash) {\r\n        // this is called to enrich the seed information by\r\n        // - own address (if peer is behind a nat/router)\r\n        // - check peer type (virgin/junior/senior/principal)\r\n        // to do this, we send a 'Hello' to another peer\r\n        // this carries the following information:\r\n        // 'iam' - own hash\r\n        // 'youare' - remote hash, to verify that we are correct\r\n        // 'key' - a session key that the remote peer may use to answer\r\n        // and the own seed string\r\n        // we expect the following information to be send back:\r\n        // - 'yourip' the ip of the connection peer (we)\r\n        // - 'yourtype' the type of this peer that the other peer checked by asking for a specific word\r\n        // and the remote seed string\r\n        // the number of new seeds are returned\r\n        // one exceptional failure case is when we know the other's peers hash, the other peers responds correctly\r\n        // but they appear to be another peer by comparisment of the other peer's hash\r\n        // this works of course only if we know the other peer's hash.\r\n        \r\n        final String key = crypt.randomSalt();\r\n        HashMap result = null;\r\n        try {\r\n            /*\r\n            URL url = new URL(\"http://\" + address + \"/yacy/hello.html?iam=\" +\r\n                              yacyCore.seedCache.mySeed.hash +\r\n                              \"&pattern=&count=20\" +\r\n                              \"&key=\" + key + \"&seed=\" + yacyCore.seedCache.mySeed.genSeedStr(key));\r\n            yacyCore.log.logDebug(\"HELLO to URL \" + url.toString());\r\n            result = nxTools.table(httpc.wget(url,\r\n                        10000, null, null, yacyCore.seedCache.sb.remoteProxyHost, yacyCore.seedCache.sb.remoteProxyPort));\r\n             */\r\n\r\n            // building URL\r\n            final URL url = new URL(\"http://\" + address + \"/yacy/hello.html\");\r\n            \r\n            // should we use the proxy?\r\n            boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) &&  \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                               (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n            \r\n            // adding all needed parameters\r\n            final serverObjects obj = new serverObjects(6);\r\n                obj.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n                obj.put(\"pattern\", \"\");\r\n                obj.put(\"count\", \"20\");\r\n                obj.put(\"key\", key);\r\n                obj.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n                obj.put(\"myUTC\", System.currentTimeMillis());\r\n                obj.put(yacySeed.SEED, yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            \r\n            // sending request\r\n            result = nxTools.table(\r\n                    httpc.wput(url,\r\n                               yacySeed.b64Hash2hexHash(otherHash) + \".yacyh\",\r\n                               105000, \r\n                               null, \r\n                               null,\r\n                               (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                               obj,\r\n                               null\r\n                    ), \"UTF-8\"\r\n            );\r\n        } catch (Exception e) {\r\n            if (Thread.currentThread().isInterrupted()) {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed thread '\" + Thread.currentThread().getName() + \"' interrupted.\");\r\n            } else {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed exception:\" + e.getMessage());\r\n            }\r\n            return -1;\r\n        }\r\n        if (result == null || result.size() < 3) {\r\n            yacyCore.log.logFine(\"yacyClient.publishMySeed result error: \" +\r\n            ((result == null) ? \"result null\" : (\"result=\" + result.toString())));\r\n            return -1;\r\n        }\r\n\r\n        // check consistency with expectation\r\n        yacySeed otherPeer = null;\r\n        float otherPeerVersion = 0;\r\n        if (otherHash != null && otherHash.length() > 0) {\r\n            otherPeer = yacySeed.genRemoteSeed((String) result.get(\"seed0\"), key, true);\r\n            if (otherPeer == null || !otherPeer.hash.equals(otherHash)) {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed: consistency error: other peer '\" + ((otherPeer==null)?\"unknown\":otherPeer.getName()) + \"' wrong\");\r\n                return -1; // no success\r\n            }\r\n            otherPeerVersion = otherPeer.getVersion();\r\n        }\r\n\r\n        // set my own seed according to new information\r\n        final yacySeed mySeedBkp = (yacySeed) yacyCore.seedDB.mySeed.clone();\r\n\r\n        // we overwrite our own IP number only, if we do not portForwarding\r\n        if (serverCore.portForwardingEnabled || serverCore.useStaticIP) {\r\n            yacyCore.seedDB.mySeed.put(yacySeed.IP, serverCore.publicIP());\r\n        } else {\r\n            yacyCore.seedDB.mySeed.put(yacySeed.IP, (String) result.get(yacySeed.YOURIP));\r\n        }\r\n\r\n        /* If we have port forwarding enabled but the other peer uses a too old yacy version\r\n         * we can ignore the seed-type that was reported by the peer.\r\n         * \r\n         * Otherwise we have to change our seed-type  \r\n         * \r\n         * @see serverCore#portForwardingEnabled \r\n         */\r\n        if (!serverCore.portForwardingEnabled || otherPeerVersion >= yacyVersion.YACY_SUPPORTS_PORT_FORWARDING) {\r\n            String mytype = (String) result.get(yacySeed.YOURTYPE);\r\n            if (mytype == null) { mytype = yacySeed.PEERTYPE_JUNIOR; }        \r\n            yacyAccessible accessible = new yacyAccessible();\r\n            if (mytype.equals(yacySeed.PEERTYPE_SENIOR)||mytype.equals(yacySeed.PEERTYPE_PRINCIPAL)) {\r\n                accessible.IWasAccessed = true;\r\n                if (yacyCore.seedDB.mySeed.isPrincipal()) {\r\n                    mytype = yacySeed.PEERTYPE_PRINCIPAL;\r\n                }\r\n            } else {\r\n                accessible.IWasAccessed = false;\r\n            }\r\n            accessible.lastUpdated = System.currentTimeMillis();\r\n            yacyCore.amIAccessibleDB.put(otherHash, accessible);\r\n\r\n            /* \r\n             * If we were reported as junior we have to check if your port forwarding channel is broken\r\n             * If this is true we try to reconnect the sch channel to the remote server now.\r\n             */\r\n            if (mytype.equalsIgnoreCase(yacySeed.PEERTYPE_JUNIOR)) {\r\n                yacyCore.log.logInfo(\"yacyClient.publishMySeed: Peer '\" + ((otherPeer==null)?\"unknown\":otherPeer.getName()) + \"' reported us as junior.\");\r\n                if (serverCore.portForwardingEnabled) {\r\n                    if (!Thread.currentThread().isInterrupted() && \r\n                         serverCore.portForwarding != null && \r\n                        !serverCore.portForwarding.isConnected()\r\n                    ) {\r\n                        yacyCore.log.logWarning(\"yacyClient.publishMySeed: Broken portForwarding channel detected. Trying to reconnect ...\");                        \r\n                        try {\r\n                            serverCore.portForwarding.reconnect();\r\n                        } catch (IOException e) {\r\n                            yacyCore.log.logWarning(\"yacyClient.publishMySeed: Unable to reconnect to port forwarding host.\");\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                yacyCore.log.logFine(\"yacyClient.publishMySeed: Peer '\" + ((otherPeer==null)?\"unknown\":otherPeer.getName()) + \"' reported us as \" + mytype + \".\");\r\n            }\r\n            if (yacyCore.seedDB.mySeed.orVirgin().equals(yacySeed.PEERTYPE_VIRGIN))\r\n                yacyCore.seedDB.mySeed.put(yacySeed.PEERTYPE, mytype);\r\n        }\r\n\r\n        final String error = yacyCore.seedDB.mySeed.isProper();\r\n        if (error != null) {\r\n            yacyCore.seedDB.mySeed = mySeedBkp;\r\n            yacyCore.log.logFine(\"yacyClient.publishMySeed mySeed error - not proper: \" + error);\r\n            return -1;\r\n        }\r\n\r\n        //final Date remoteTime = yacyCore.parseUniversalDate((String) result.get(yacySeed.MYTIME)); // read remote time\r\n        \r\n        // read the seeds that the peer returned and integrate them into own database\r\n        int i = 0;\r\n        int count = 0;\r\n        String seedStr;\r\n        while ((seedStr = (String) result.get(yacySeed.SEED + i++)) != null) {\r\n            // integrate new seed into own database\r\n            // the first seed, \"seed0\" is the seed of the responding peer\r\n            if (yacyCore.peerActions.peerArrival(yacySeed.genRemoteSeed(seedStr, key, true), (i == 1))) count++;\r\n        }\r\n        return count;\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap postMessage(String targetHash, String subject, byte[] message) {\r\n        // this post a message to the remote message board\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n            post.put(\"key\", key);\r\n            post.put(\"process\", \"post\");\r\n            post.put(\"myseed\", yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            post.put(\"youare\", targetHash);\r\n            post.put(\"subject\", subject);\r\n            post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            try {\r\n                post.put(\"message\", new String(message, \"UTF-8\"));\r\n            } catch (UnsupportedEncodingException e) {\r\n                post.put(\"message\", new String(message));\r\n            }\r\n        // get target address    \r\n        String address = targetAddress(targetHash);\r\n        \r\n        // sending request\r\n        try {\r\n            final ArrayList v = httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/message.html\"),\r\n                    yacySeed.b64Hash2hexHash(targetHash) + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n            );\r\n\r\n            return nxTools.table(v);\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":892,"modified_method":"public static HashMap postMessage(String targetHash, String subject, byte[] message) {\r\n        // this post a message to the remote message board\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n            post.put(\"key\", key);\r\n            post.put(\"process\", \"post\");\r\n            post.put(\"myseed\", yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            post.put(\"youare\", targetHash);\r\n            post.put(\"subject\", subject);\r\n            post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            try {\r\n                post.put(\"message\", new String(message, \"UTF-8\"));\r\n            } catch (UnsupportedEncodingException e) {\r\n                post.put(\"message\", new String(message));\r\n            }\r\n        // get target address    \r\n        String address = targetAddress(targetHash);\r\n        \r\n        // sending request\r\n        try {\r\n            return nxTools.table(\r\n                httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/message.html\"),\r\n                    yacySeed.b64Hash2hexHash(targetHash) + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n               ), \"UTF-8\");\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap transferStore(String targetAddress, String access, String filename, byte[] file) {\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB != null) &&\r\n                           (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"store\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"purpose\", \"crcon\");\r\n        post.put(\"filename\", filename);\r\n        post.put(\"filesize\", Long.toString(file.length));\r\n        post.put(\"md5\", serverCodings.encodeMD5Hex(file));\r\n        post.put(\"access\", access);\r\n        HashMap files = new HashMap();\r\n        files.put(\"filename\", file);\r\n        \r\n        // sending request\r\n        try {\r\n            final URL url = new URL(\"http://\" + targetAddress + \"/yacy/transfer.html\");\r\n            final ArrayList v = httpc.wput(\r\n                    url,\r\n                    url.getHost(), // yacyCore.seedDB.mySeed.getHexHash() + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    files\r\n            );\r\n\r\n            return nxTools.table(v);\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":893,"modified_method":"public static HashMap transferStore(String targetAddress, String access, String filename, byte[] file) {\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB != null) &&\r\n                           (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"store\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"purpose\", \"crcon\");\r\n        post.put(\"filename\", filename);\r\n        post.put(\"filesize\", Long.toString(file.length));\r\n        post.put(\"md5\", serverCodings.encodeMD5Hex(file));\r\n        post.put(\"access\", access);\r\n        HashMap files = new HashMap();\r\n        files.put(\"filename\", file);\r\n        \r\n        // sending request\r\n        try {\r\n            final URL url = new URL(\"http://\" + targetAddress + \"/yacy/transfer.html\");\r\n            return nxTools.table(\r\n                httpc.wput(\r\n                    url,\r\n                    url.getHost(), // yacyCore.seedDB.mySeed.getHexHash() + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    files\r\n                ), \"UTF-8\");\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap crawlOrder(yacySeed targetSeed, URL[] url, URL[] referrer, int timeout) {\r\n        // this post a message to the remote message board\r\n        if (targetSeed == null) { return null; }\r\n        if (yacyCore.seedDB.mySeed == null) { return null; }\r\n        if (yacyCore.seedDB.mySeed == targetSeed) { return null; }\r\n\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // construct request\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(9);\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"crawl\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n        if (url.length == 1) {\r\n            post.put(\"url\", crypt.simpleEncode(url[0].toString()));\r\n            post.put(\"referrer\", crypt.simpleEncode((referrer[0] == null) ? \"\" : referrer[0].toString()));\r\n        } else {\r\n            for (int i=0; i< url.length; i++) {\r\n                post.put(\"url\" + i, crypt.simpleEncode(url[i].toString()));\r\n                post.put(\"ref\" + i, crypt.simpleEncode((referrer[i] == null) ? \"\" : referrer[i].toString()));\r\n            }\r\n        }\r\n        post.put(\"depth\", \"0\");\r\n        post.put(\"ttl\", \"0\");\r\n\r\n        // determining target address\r\n        final String address = targetSeed.getAddress();\r\n        if (address == null) { return null; }\r\n        \r\n        // sending request\r\n        try {\r\n            return nxTools.table(\r\n                    httpc.wput(\r\n                            new URL(\"http://\" + address + \"/yacy/crawlOrder.html\"),\r\n                            targetSeed.getHexHash() + \".yacyh\",\r\n                            timeout, \r\n                            null, \r\n                            null, \r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                            post,\r\n                            null\r\n                    )\r\n            );\r\n        } catch (Exception e) {\r\n            // most probably a network time-out exception\r\n            yacyCore.log.logSevere(\"yacyClient.crawlOrder error: peer=\" + targetSeed.getName() + \", error=\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":894,"modified_method":"public static HashMap crawlOrder(yacySeed targetSeed, URL[] url, URL[] referrer, int timeout) {\r\n        // this post a message to the remote message board\r\n        if (targetSeed == null) { return null; }\r\n        if (yacyCore.seedDB.mySeed == null) { return null; }\r\n        if (yacyCore.seedDB.mySeed == targetSeed) { return null; }\r\n\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // construct request\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(9);\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"crawl\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n        if (url.length == 1) {\r\n            post.put(\"url\", crypt.simpleEncode(url[0].toString()));\r\n            post.put(\"referrer\", crypt.simpleEncode((referrer[0] == null) ? \"\" : referrer[0].toString()));\r\n        } else {\r\n            for (int i=0; i< url.length; i++) {\r\n                post.put(\"url\" + i, crypt.simpleEncode(url[i].toString()));\r\n                post.put(\"ref\" + i, crypt.simpleEncode((referrer[i] == null) ? \"\" : referrer[i].toString()));\r\n            }\r\n        }\r\n        post.put(\"depth\", \"0\");\r\n        post.put(\"ttl\", \"0\");\r\n\r\n        // determining target address\r\n        final String address = targetSeed.getAddress();\r\n        if (address == null) { return null; }\r\n        \r\n        // sending request\r\n        try {\r\n            return nxTools.table(\r\n                    httpc.wput(\r\n                            new URL(\"http://\" + address + \"/yacy/crawlOrder.html\"),\r\n                            targetSeed.getHexHash() + \".yacyh\",\r\n                            timeout, \r\n                            null, \r\n                            null, \r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                            post,\r\n                            null\r\n                    ), \"UTF-8\"\r\n            );\r\n        } catch (Exception e) {\r\n            // most probably a network time-out exception\r\n            yacyCore.log.logSevere(\"yacyClient.crawlOrder error: peer=\" + targetSeed.getName() + \", error=\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap permissionMessage(String targetHash) {\r\n        // ask for allowed message size and attachement size\r\n        // if this replies null, the peer does not answer\r\n        if (yacyCore.seedDB == null || yacyCore.seedDB.mySeed == null) { return null; }\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n                \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(5);\r\n            post.put(\"key\", key);\r\n            post.put(\"process\", \"permission\");\r\n            post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n            post.put(\"youare\", targetHash);\r\n            post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            \r\n        // get target address    \r\n        String address = targetAddress(targetHash);\r\n        \r\n        // sending request\r\n        try {\r\n            return nxTools.table(\r\n                    httpc.wput(\r\n                            new URL(\"http://\" + address + \"/yacy/message.html\"),\r\n                            yacySeed.b64Hash2hexHash(targetHash) + \".yacyh\",\r\n                            8000, \r\n                            null, \r\n                            null, \r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                            post,\r\n                            null\r\n                    )\r\n            );\r\n        } catch (Exception e) {\r\n            // most probably a network time-out exception\r\n            yacyCore.log.logSevere(\"yacyClient.permissionMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":895,"modified_method":"public static HashMap permissionMessage(String targetHash) {\r\n        // ask for allowed message size and attachement size\r\n        // if this replies null, the peer does not answer\r\n        if (yacyCore.seedDB == null || yacyCore.seedDB.mySeed == null) { return null; }\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n                \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(5);\r\n            post.put(\"key\", key);\r\n            post.put(\"process\", \"permission\");\r\n            post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n            post.put(\"youare\", targetHash);\r\n            post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            \r\n        // get target address    \r\n        String address = targetAddress(targetHash);\r\n        \r\n        // sending request\r\n        try {\r\n            return nxTools.table(\r\n                    httpc.wput(\r\n                            new URL(\"http://\" + address + \"/yacy/message.html\"),\r\n                            yacySeed.b64Hash2hexHash(targetHash) + \".yacyh\",\r\n                            8000, \r\n                            null, \r\n                            null, \r\n                            (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null,\r\n                            post,\r\n                            null\r\n                    ), \"UTF-8\"\r\n            );\r\n        } catch (Exception e) {\r\n            // most probably a network time-out exception\r\n            yacyCore.log.logSevere(\"yacyClient.permissionMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected UsernameToken convertPolicyToToken(AuthorizationPolicy policy) \n        throws Exception {\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.newDocument();\n        \n        UsernameToken token = new UsernameToken(false, doc, \n                                                WSConstants.PASSWORD_TEXT);\n        token.setName(policy.getUserName());\n        token.setPassword(policy.getPassword());\n        return token;\n    }","id":896,"modified_method":"protected UsernameToken convertPolicyToToken(AuthorizationPolicy policy) \n        throws Exception {\n\n        Document doc = DOMUtils.createDocument();\n        UsernameToken token = new UsernameToken(false, doc, \n                                                WSConstants.PASSWORD_TEXT);\n        token.setName(policy.getUserName());\n        token.setPassword(policy.getPassword());\n        return token;\n    }","commit_id":"26d332eb2909281152d7ed8232cb7e5c6469ca0c","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(Message message) throws Fault {\n\n        AuthorizationPolicy policy = message.get(AuthorizationPolicy.class);\n        if (policy == null || policy.getUserName() == null || policy.getPassword() == null) {\n            String name = null;\n            String password = null;\n            if (policy != null) {\n                name = policy.getUserName();\n                password = policy.getPassword();\n            }\n            org.apache.cxf.common.i18n.Message errorMsg = \n                new org.apache.cxf.common.i18n.Message(\"NO_USER_PASSWORD\", \n                                                       BUNDLE, \n                                                       name, password);\n            LOG.warning(errorMsg.toString());\n            throw new SecurityException(errorMsg.toString());\n        }\n        \n        try {\n            UsernameToken token = convertPolicyToToken(policy);\n            Credential credential = new Credential();\n            credential.setUsernametoken(token);\n            validator.validateWithSTS(credential, message);\n        } catch (Exception ex) {\n            throw new Fault(ex);\n        }\n    }","id":897,"modified_method":"public void handleMessage(Message message) throws Fault {\n\n        AuthorizationPolicy policy = message.get(AuthorizationPolicy.class);\n        if (policy == null || policy.getUserName() == null || policy.getPassword() == null) {\n            String name = null;\n            String password = null;\n            if (policy != null) {\n                name = policy.getUserName();\n                password = policy.getPassword();\n            }\n            org.apache.cxf.common.i18n.Message errorMsg = \n                new org.apache.cxf.common.i18n.Message(\"NO_USER_PASSWORD\", \n                                                       BUNDLE, \n                                                       name, password);\n            LOG.warning(errorMsg.toString());\n            throw new SecurityException(errorMsg.toString());\n        }\n        \n        try {\n            UsernameToken token = convertPolicyToToken(policy);\n            Credential credential = new Credential();\n            credential.setUsernametoken(token);\n            \n            RequestData data = new RequestData();\n            data.setMsgContext(message);\n            credential = validator.validate(credential, data);\n            \n            // Create a Principal/SecurityContext\n            Principal p = null;\n            if (credential != null && credential.getPrincipal() != null) {\n                p = credential.getPrincipal();\n            } else {\n                p = new WSUsernameTokenPrincipalImpl(policy.getUserName(), false);\n                ((WSUsernameTokenPrincipalImpl)p).setPassword(policy.getPassword());\n            }\n            message.put(SecurityContext.class, createSecurityContext(p));\n        } catch (Exception ex) {\n            throw new Fault(ex);\n        }\n    }","commit_id":"26d332eb2909281152d7ed8232cb7e5c6469ca0c","url":"https://github.com/apache/cxf"},{"original_method":"public void setValidator(STSTokenValidator validator) {\n        this.validator = validator;\n    }","id":898,"modified_method":"public void setValidator(Validator validator) {\n        this.validator = validator;\n    }","commit_id":"26d332eb2909281152d7ed8232cb7e5c6469ca0c","url":"https://github.com/apache/cxf"},{"original_method":"private static void doubleIt(String username, String password, boolean authFailureExpected) {\n        final String configLocation = \"org/apache/cxf/systest/sts/basic_auth/cxf-client.xml\";\n        final String address = \"https://localhost:\" + PORT + \"/doubleit/services/doubleit-rs\";\n        final int numToDouble = 25;  \n       \n        WebClient client = WebClient.create(address, username, password, configLocation);\n        client.type(\"text/plain\").accept(\"text/plain\");\n        try {\n            int resp = client.post(numToDouble, Integer.class);\n            if (authFailureExpected) {\n                throw new RuntimeException(\"Exception expected\");\n            }\n            org.junit.Assert.assertEquals(2 * numToDouble, resp);\n        } catch (WebApplicationException ex) {\n            if (!authFailureExpected) {\n                throw new RuntimeException(\"Unexpected exception\");\n            }\n            org.junit.Assert.assertEquals(500, ex.getResponse().getStatus());\n        }\n    }","id":899,"modified_method":"private static void doubleIt(String username, String password, boolean authFailureExpected) {\n        final String configLocation = \"org/apache/cxf/systest/sts/basic_auth/cxf-client.xml\";\n        final String address = \"https://localhost:\" + PORT + \"/doubleit/services/doubleit-rs\";\n        final int numToDouble = 25;  \n       \n        WebClient client = null;\n        if (username != null && password != null) {\n            client = WebClient.create(address, username, password, configLocation);\n        } else {\n            client = WebClient.create(address, configLocation);\n        }\n        client.type(\"text/plain\").accept(\"text/plain\");\n        try {\n            int resp = client.post(numToDouble, Integer.class);\n            if (authFailureExpected) {\n                throw new RuntimeException(\"Exception expected\");\n            }\n            org.junit.Assert.assertEquals(2 * numToDouble, resp);\n        } catch (WebApplicationException ex) {\n            if (!authFailureExpected) {\n                throw new RuntimeException(\"Unexpected exception\");\n            }\n            org.junit.Assert.assertEquals(500, ex.getResponse().getStatus());\n        }\n    }","commit_id":"26d332eb2909281152d7ed8232cb7e5c6469ca0c","url":"https://github.com/apache/cxf"},{"original_method":"public Credential validate(Credential credential, RequestData data) throws WSSecurityException {\n        \n        if (isValidatedLocally(credential, data)) {\n            return credential;\n        }\n        \n        return validateWithSTS(credential, (SoapMessage)data.getMsgContext());\n    }","id":900,"modified_method":"public Credential validate(Credential credential, RequestData data) throws WSSecurityException {\n        \n        if (isValidatedLocally(credential, data)) {\n            return credential;\n        }\n        \n        return validateWithSTS(credential, (Message)data.getMsgContext());\n    }","commit_id":"26d332eb2909281152d7ed8232cb7e5c6469ca0c","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n  public void addTagNameVariants(List<LookupElement> elements, @NotNull XmlTag tag, String prefix) {\n    final List<String> namespaces;\n    if (prefix.isEmpty()) {\n      namespaces = new ArrayList<String>(Arrays.asList(tag.knownNamespaces()));\n      namespaces.add(XmlUtil.EMPTY_URI); // empty namespace\n    }\n    else {\n      namespaces = new ArrayList<String>(Collections.singletonList(tag.getNamespace()));\n    }\n    XmlExtension xmlExtension = XmlExtension.getExtension(tag.getContainingFile());\n    List<String> nsInfo = new ArrayList<String>();\n    final String[] variants = TagNameVariantCollector.getTagNameVariants(tag, namespaces, nsInfo);\n    for (int i = 0, variantsLength = variants.length; i < variantsLength; i++) {\n      String qname = variants[i];\n      if (!prefix.isEmpty() && qname.startsWith(prefix + \":\")) {\n        qname = qname.substring(prefix.length() + 1);\n      }\n      LookupElementBuilder lookupElement = LookupElementBuilder.create(qname);\n      final int separator = qname.indexOf(':');\n      if (separator > 0) {\n        lookupElement = lookupElement.withLookupString(qname.substring(separator + 1));\n      }\n      String ns = nsInfo.get(i);\n      if (StringUtil.isNotEmpty(ns)) {\n        lookupElement = lookupElement.withTypeText(ns, true);\n      }\n      if (xmlExtension.useXmlTagInsertHandler()) {\n        elements.add(lookupElement.withInsertHandler(XmlTagInsertHandler.INSTANCE));\n      }\n      else {\n        elements.add(lookupElement);\n      }\n    }\n  }","id":901,"modified_method":"@Override\n  public void addTagNameVariants(List<LookupElement> elements, @NotNull XmlTag tag, String prefix) {\n    final List<String> namespaces;\n    if (prefix.isEmpty()) {\n      namespaces = new ArrayList<String>(Arrays.asList(tag.knownNamespaces()));\n      namespaces.add(XmlUtil.EMPTY_URI); // empty namespace\n    }\n    else {\n      namespaces = new ArrayList<String>(Collections.singletonList(tag.getNamespace()));\n    }\n    XmlExtension xmlExtension = XmlExtension.getExtension(tag.getContainingFile());\n    List<String> nsInfo = new ArrayList<String>();\n    @SuppressWarnings(\"unchecked\") List<XmlElementDescriptor> variants = TagNameVariantCollector\n      .getTagNameVariants(tag, namespaces, nsInfo, (Function<XmlElementDescriptor, XmlElementDescriptor>)Function.ID);\n\n    for (int i = 0; i < variants.size(); i++) {\n      XmlElementDescriptor descriptor = variants.get(i);\n      String qname = descriptor.getName(tag);\n      if (!prefix.isEmpty() && qname.startsWith(prefix + \":\")) {\n        qname = qname.substring(prefix.length() + 1);\n      }\n      PsiElement declaration = descriptor.getDeclaration();\n      LookupElementBuilder lookupElement = declaration == null ? LookupElementBuilder.create(qname) : LookupElementBuilder.create(declaration, qname);\n      final int separator = qname.indexOf(':');\n      if (separator > 0) {\n        lookupElement = lookupElement.withLookupString(qname.substring(separator + 1));\n      }\n      String ns = nsInfo.get(i);\n      if (StringUtil.isNotEmpty(ns)) {\n        lookupElement = lookupElement.withTypeText(ns, true);\n      }\n      if (xmlExtension.useXmlTagInsertHandler()) {\n        elements.add(lookupElement.withInsertHandler(XmlTagInsertHandler.INSTANCE));\n      }\n      else {\n        elements.add(lookupElement);\n      }\n    }\n  }","commit_id":"fe1239feffe737921d127653c26586a8c5419381","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doQuickDocGenerationTestWithCheckExpectedResult(Object completionVariant, final String... baseFileNames) throws Exception {\n    final DocumentationTestContext context = new DocumentationTestContext(baseFileNames);\n    VirtualFile vfile =\n      LocalFileSystem.getInstance().findFileByIoFile(new File(getTestDataPath() +baseFileNames[0] + \".expected.html\"));\n    String expectedText = StringUtil.convertLineSeparators(VfsUtilCore.loadText(vfile));\n    assertEquals(expectedText, context.generateDoc());\n\n    if (completionVariant != null) {\n      vfile = LocalFileSystem.getInstance().findFileByIoFile(new File(getTestDataPath() +baseFileNames[0] + \".expected.completion.html\"));\n      expectedText = StringUtil.convertLineSeparators(VfsUtilCore.loadText(vfile));\n      assertEquals(expectedText, context.generateDocForCompletion(completionVariant));\n    }\n  }","id":902,"modified_method":"private void doQuickDocGenerationTestWithCheckExpectedResult(Object completionVariant, final String... baseFileNames) throws Exception {\n    final DocumentationTestContext context = new DocumentationTestContext(baseFileNames);\n    String pathname = getTestDataPath() + baseFileNames[0] + \".expected.html\";\n    VirtualFile vfile = LocalFileSystem.getInstance().findFileByIoFile(new File(pathname));\n    assertNotNull(pathname + \" not found\", vfile);\n    String expectedText = StringUtil.convertLineSeparators(VfsUtilCore.loadText(vfile));\n    assertEquals(expectedText, StringUtil.convertLineSeparators(context.generateDoc()));\n\n    if (completionVariant != null) {\n      vfile = LocalFileSystem.getInstance().findFileByIoFile(new File(getTestDataPath() +baseFileNames[0] + \".expected.completion.html\"));\n      expectedText = StringUtil.convertLineSeparators(VfsUtilCore.loadText(vfile), \"\\n\");\n      assertEquals(expectedText, StringUtil.convertLineSeparators(context.generateDocForCompletion(completionVariant), \"\\n\"));\n    }\n  }","commit_id":"fe1239feffe737921d127653c26586a8c5419381","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private static XmlTag getTag(PsiElement psiElement1) {\n        if (psiElement1 == null) return null;\n        final PsiElement element;\n        if (psiElement1.getParent() instanceof XmlAttribute) {\n            final XmlAttribute xmlAttribute = ((XmlAttribute)psiElement1.getParent());\n            element = xmlAttribute.getParent();\n        } else {\n            element = psiElement1.getParent();\n        }\n        if (element instanceof XmlTag) {\n            final XmlTag tag = (XmlTag)element;\n            if (XsltSupport.isXsltTag(tag)) {\n                return tag;\n            }\n        }\n        return null;\n    }","id":903,"modified_method":"@Nullable\n    private static String getTagName(@Nullable PsiElement psiElement1) {\n      XmlTag xmlTag = PsiTreeUtil.getParentOfType(psiElement1, XmlTag.class, false);\n      if (xmlTag != null) {\n        if (XsltSupport.isXsltTag(xmlTag)) {\n          return xmlTag.getLocalName();\n        }\n        else if (XmlUtil.ourSchemaUrisList.contains(xmlTag.getNamespace())) {\n          return xmlTag.getAttributeValue(\"name\");\n        }\n      }\n      return null;\n    }","commit_id":"fe1239feffe737921d127653c26586a8c5419381","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public List<String> getUrlFor(PsiElement psiElement, PsiElement psiElement1) {\n        if (psiElement instanceof XsltElement) return null;\n\n        final String category;\n        final String name;\n        final XmlTag tag = getTag(psiElement1);\n        if (tag != null) {\n            name = tag.getLocalName();\n            category = \"element\";\n        } else if (psiElement instanceof XPathFunction) {\n            name = ((XPathFunction)psiElement).getName();\n            category = \"function\";\n        } else if (psiElement instanceof DocElement) {\n            name = ((DocElement)psiElement).getName();\n            category = ((DocElement)psiElement).getCategory();\n        } else {\n            return null;\n        }\n\n        try {\n            final Document document = getDocumentationDocument();\n            final XPath xPath = XPath.newInstance(\"//x:\" + category + \"[@name = '\" + name + \"']\");\n            xPath.addNamespace(\"x\", document.getRootElement().getNamespaceURI());\n            final Element e = (Element)xPath.selectSingleNode(document);\n            if (e != null) {\n                return Collections.singletonList(e.getParentElement().getAttributeValue(\"base\") + e.getAttributeValue(\"href\"));\n            }\n        } catch (Exception e) {\n            Logger.getInstance(getClass().getName()).error(e);\n        }\n        return null;\n    }","id":904,"modified_method":"@Nullable\n    public List<String> getUrlFor(PsiElement psiElement, PsiElement psiElement1) {\n        if (psiElement instanceof XsltElement) return null;\n\n        final String category;\n        final String name;\n        final String tagName = getTagName(psiElement);\n        if (tagName != null) {\n            name = tagName;\n            category = \"element\";\n        } else if (psiElement instanceof XPathFunction) {\n            name = ((XPathFunction)psiElement).getName();\n            category = \"function\";\n        } else if (psiElement instanceof DocElement) {\n            name = ((DocElement)psiElement).getName();\n            category = ((DocElement)psiElement).getCategory();\n        } else {\n            return null;\n        }\n\n        try {\n            final Document document = getDocumentationDocument();\n            final XPath xPath = XPath.newInstance(\"//x:\" + category + \"[@name = '\" + name + \"']\");\n            xPath.addNamespace(\"x\", document.getRootElement().getNamespaceURI());\n            final Element e = (Element)xPath.selectSingleNode(document);\n            if (e != null) {\n                return Collections.singletonList(e.getParentElement().getAttributeValue(\"base\") + e.getAttributeValue(\"href\"));\n            }\n        } catch (Exception e) {\n            Logger.getInstance(getClass().getName()).error(e);\n        }\n        return null;\n    }","commit_id":"fe1239feffe737921d127653c26586a8c5419381","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public String generateDoc(PsiElement psiElement, PsiElement psiElement1) {\n        if (psiElement instanceof DocElement) {\n            final DocElement element = (DocElement)psiElement;\n            return getDocumentation(element.getName(), element.getCategory());\n        }\n\n        if (psiElement instanceof XsltElement) {\n            final XmlTag t = ((XsltElement)psiElement).getTag();\n            PsiElement p = t.getPrevSibling();\n            while (p instanceof PsiWhiteSpace || p instanceof XmlText) {\n                p = p.getPrevSibling();\n            }\n            if (p instanceof XmlComment) {\n                final String commentText = XmlUtil.getCommentText((XmlComment)p);\n                return commentText != null ? commentText.replaceAll(\"&\", \"&amp;\").replaceAll(\"<\", \"&lt;\") : null;\n            } else {\n                return null;\n            }\n        }\n\n        final XmlTag tag = getTag(psiElement1);\n        if (tag != null) {\n            return getDocumentation(tag.getLocalName(), \"element\");\n        } else if (psiElement instanceof XPathFunction) {\n            return getDocumentation(((XPathFunction)psiElement).getName(), \"function\");\n        }\n\n        return null;\n    }","id":905,"modified_method":"@Nullable\n    public String generateDoc(PsiElement psiElement, PsiElement psiElement1) {\n        if (psiElement instanceof DocElement) {\n            final DocElement element = (DocElement)psiElement;\n            return getDocumentation(element.getName(), element.getCategory());\n        }\n\n        if (psiElement instanceof XsltElement) {\n            final XmlTag t = ((XsltElement)psiElement).getTag();\n            PsiElement p = t.getPrevSibling();\n            while (p instanceof PsiWhiteSpace || p instanceof XmlText) {\n                p = p.getPrevSibling();\n            }\n            if (p instanceof XmlComment) {\n                final String commentText = XmlUtil.getCommentText((XmlComment)p);\n                return commentText != null ? commentText.replaceAll(\"&\", \"&amp;\").replaceAll(\"<\", \"&lt;\") : null;\n            } else {\n                return null;\n            }\n        }\n\n        final String name = getTagName(psiElement);\n        if (name != null) {\n            return getDocumentation(name, \"element\");\n        } else if (psiElement instanceof XPathFunction) {\n            return getDocumentation(((XPathFunction)psiElement).getName(), \"function\");\n        }\n\n        return null;\n    }","commit_id":"fe1239feffe737921d127653c26586a8c5419381","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addStepDefinitions(CompletionResultSet result, PsiFile file) {\n    result = result.withPrefixMatcher(new PlainPrefixMatcher(result.getPrefixMatcher().getPrefix()));\n    final List<AbstractStepDefinition> definitions = CucumberStepsIndex.getInstance(file.getProject()).getAllStepDefinitions(file);\n    for (AbstractStepDefinition definition : definitions) {\n      String text = definition.getCucumberRegex();\n      if (text != null) {\n        // trim regexp line start/end markers\n        if (text.startsWith(\"^\")) {\n          text = text.substring(1);\n        }\n        if (text.endsWith(\"$\")) {\n          text = text.substring(0, text.length() - 1);\n        }\n        text = StringUtil.replace(text, \"\\\\\\\"\", \"\\\"\");\n        for (Map.Entry<String, String> group : GROUP_TYPE_MAP.entrySet()) {\n          text = StringUtil.replace(text, group.getKey(), group.getValue());\n        }\n\n        final List<TextRange> ranges = new ArrayList<TextRange>();\n\n        Pattern p = Pattern.compile(POSSIBLE_GROUP_REGEX);\n        Matcher m = p.matcher(text);\n        while (m.find()) {\n          ranges.add(new TextRange(m.start(), m.end() - 3));\n          text = m.replaceAll(\"$1\");\n          m = p.matcher(text);\n        }\n\n        final Pattern pattern = Pattern.compile(PARAMETERS_REGEX);\n        m = pattern.matcher(text);\n        while (m.find()) {\n          ranges.add(new TextRange(m.start(), m.end()));\n        }\n\n        result.addElement(LookupElementBuilder.create(text).withInsertHandler(new StepInsertHandler(ranges)));\n      }\n    }\n  }","id":906,"modified_method":"private static void addStepDefinitions(CompletionResultSet result, PsiFile file) {\n    result = result.withPrefixMatcher(new PlainPrefixMatcher(result.getPrefixMatcher().getPrefix()));\n    final List<AbstractStepDefinition> definitions = CucumberStepsIndex.getInstance(file.getProject()).getAllStepDefinitions(file);\n    for (AbstractStepDefinition definition : definitions) {\n      String text = definition.getCucumberRegex();\n      if (text != null) {\n        // trim regexp line start/end markers\n        if (text.startsWith(\"^\")) {\n          text = text.substring(1);\n        }\n        if (text.endsWith(\"$\")) {\n          text = text.substring(0, text.length() - 1);\n        }\n        text = StringUtil.replace(text, \"\\\\\\\"\", \"\\\"\");\n        for (Map.Entry<String, String> group : GROUP_TYPE_MAP.entrySet()) {\n          text = StringUtil.replace(text, group.getKey(), group.getValue());\n        }\n\n        final List<TextRange> ranges = new ArrayList<TextRange>();\n\n        Pattern p = Pattern.compile(POSSIBLE_GROUP_REGEX);\n        Matcher m = p.matcher(text);\n        while (m.find()) {\n          ranges.add(new TextRange(m.start(), m.end() - 3));\n          text = m.replaceAll(\"$1\");\n          m = p.matcher(text);\n        }\n\n        final Pattern pattern = Pattern.compile(PARAMETERS_REGEX);\n        m = pattern.matcher(text);\n        while (m.find()) {\n          ranges.add(new TextRange(m.start(), m.end()));\n        }\n\n        final PsiElement element = definition.getElement();\n        final LookupElementBuilder lookup = element != null \n                                            ? LookupElementBuilder.create(element, text).bold()\n                                            : LookupElementBuilder.create(text);\n        result.addElement(lookup.withInsertHandler(new StepInsertHandler(ranges)));\n      }\n    }\n  }","commit_id":"4d2e76af8f368812fdbbbea69b2cd32ef96391bd","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":907,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"70c558093074ab5f6632357ce22a9a4b38a37917","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGi_BUNDLE_DIR, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","id":908,"modified_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","commit_id":"70c558093074ab5f6632357ce22a9a4b38a37917","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":909,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"cf7ebe39393a8884218f416346a56d39d434abb7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGi_BUNDLE_DIR, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","id":910,"modified_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","commit_id":"cf7ebe39393a8884218f416346a56d39d434abb7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":911,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"bc366978f6a44d3fd6f53106b9f1a3707247aeb9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGi_BUNDLE_DIR, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","id":912,"modified_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","commit_id":"bc366978f6a44d3fd6f53106b9f1a3707247aeb9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":913,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"a471b9c863c6599a7a4e91a89dec35969cd308bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGi_BUNDLE_DIR, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","id":914,"modified_method":"public static void initializeServerWithRandomTemporaryDatabaseDirectoryOnDefaultPort() {\n        try {\n            File temporaryConfigFile = createTempPropertyFile();\n            writePropertyToFile(\"org.neo4j.database.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(\"org.neo4j.webservice.packages\", \"org.neo4j.server.rest.web\", temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"rrdb.location\", createTempDir().getAbsolutePath(), temporaryConfigFile);\n            writePropertyToFile(NeoServer.WEBADMIN_NAMESPACE_PROPERTY_KEY + \"neo4j-servers\",constructWebadminServerConfig(),\n                    temporaryConfigFile);\n            writePropertyToFile(NeoServer.OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\", temporaryConfigFile);\n\n            System.setProperty(NeoServer.NEO_CONFIG_FILE_KEY, temporaryConfigFile.getAbsolutePath());\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        NeoServer.main(null);\n    }","commit_id":"a471b9c863c6599a7a4e91a89dec35969cd308bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Returns a map which contains, as the key, the name of a class. The value\n     * consists of a list of MethodNode, one for each default groovy method found\n     * which is applicable for this class.\n     * @return\n     */\n    private static Map<String, List<MethodNode>> getDGMMethods() {\n        Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();\n        List<Class> classes = new LinkedList<Class>();\n        Collections.addAll(classes, DefaultGroovyMethods.DGM_LIKE_CLASSES);\n        Collections.addAll(classes, DefaultGroovyMethods.additionals);\n\t\tfor (Class dgmLikeClass : classes) {\n\t\t\tClassNode cn = ClassHelper.makeWithoutCaching(dgmLikeClass, true);\n\t\t\tfor (MethodNode metaMethod : cn.getMethods()) {\n\t\t\t\tParameter[] types = metaMethod.getParameters();\n\t\t\t\tif (metaMethod.isStatic() && metaMethod.isPublic() && types.length > 0) {\n\t\t\t\t\tParameter[] parameters = new Parameter[types.length - 1];\n\t\t\t\t\tSystem.arraycopy(types, 1, parameters, 0, parameters.length);\n\t\t\t\t\tMethodNode node = new ExtensionMethodNode(\n                            metaMethod,\n\t\t\t\t\t\t\tmetaMethod.getName(),\n\t\t\t\t\t\t\tmetaMethod.getModifiers(),\n\t\t\t\t\t\t\tmetaMethod.getReturnType(),\n\t\t\t\t\t\t\tparameters,\n\t\t\t\t\t\t\tClassNode.EMPTY_ARRAY, null);\n\t\t\t\t\tnode.setGenericsTypes(metaMethod.getGenericsTypes());\n\t\t\t\t\tClassNode declaringClass = types[0].getType();\n\t\t\t\t\tString declaringClassName = declaringClass.getName();\n\t\t\t\t\tnode.setDeclaringClass(declaringClass);\n\n\t\t\t\t\tList<MethodNode> nodes = methods.get(declaringClassName);\n\t\t\t\t\tif (nodes == null) {\n\t\t\t\t\t\tnodes = new LinkedList<MethodNode>();\n\t\t\t\t\t\tmethods.put(declaringClassName, nodes);\n\t\t\t\t\t}\n\t\t\t\t\tnodes.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return methods;\n    }","id":915,"modified_method":"/**\n     * Returns a map which contains, as the key, the name of a class. The value\n     * consists of a list of MethodNode, one for each default groovy method found\n     * which is applicable for this class.\n     * @return\n     */\n    private static Map<String, List<MethodNode>> getDGMMethods() {\n        Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();\n        List<Class> classes = new LinkedList<Class>();\n        Collections.addAll(classes, DefaultGroovyMethods.DGM_LIKE_CLASSES);\n        Collections.addAll(classes, DefaultGroovyMethods.additionals);\n        classes.add(ObjectArrayStaticTypesHelper.class);\n\t\tfor (Class dgmLikeClass : classes) {\n\t\t\tClassNode cn = ClassHelper.makeWithoutCaching(dgmLikeClass, true);\n\t\t\tfor (MethodNode metaMethod : cn.getMethods()) {\n\t\t\t\tParameter[] types = metaMethod.getParameters();\n\t\t\t\tif (metaMethod.isStatic() && metaMethod.isPublic() && types.length > 0) {\n\t\t\t\t\tParameter[] parameters = new Parameter[types.length - 1];\n\t\t\t\t\tSystem.arraycopy(types, 1, parameters, 0, parameters.length);\n\t\t\t\t\tMethodNode node = new ExtensionMethodNode(\n                            metaMethod,\n\t\t\t\t\t\t\tmetaMethod.getName(),\n\t\t\t\t\t\t\tmetaMethod.getModifiers(),\n\t\t\t\t\t\t\tmetaMethod.getReturnType(),\n\t\t\t\t\t\t\tparameters,\n\t\t\t\t\t\t\tClassNode.EMPTY_ARRAY, null);\n\t\t\t\t\tnode.setGenericsTypes(metaMethod.getGenericsTypes());\n\t\t\t\t\tClassNode declaringClass = types[0].getType();\n\t\t\t\t\tString declaringClassName = declaringClass.getName();\n\t\t\t\t\tnode.setDeclaringClass(declaringClass);\n\n\t\t\t\t\tList<MethodNode> nodes = methods.get(declaringClassName);\n\t\t\t\t\tif (nodes == null) {\n\t\t\t\t\t\tnodes = new LinkedList<MethodNode>();\n\t\t\t\t\t\tmethods.put(declaringClassName, nodes);\n\t\t\t\t\t}\n\t\t\t\t\tnodes.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return methods;\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        for (MethodNode m : methods) {\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(receiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !receiver.equals(m.getDeclaringClass())) dist+=getDistance(receiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !receiver.equals(m.getDeclaringClass())) dist+=getDistance(receiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !receiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","id":916,"modified_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        for (MethodNode m : methods) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {\n        List<MethodNode> fromDGM = VIRTUAL_DGM_METHODS.get(clazz.getName());\n        if (fromDGM != null) {\n            for (MethodNode node : fromDGM) {\n                if (node.getName().equals(name)) accumulator.add(node);\n            }\n        }\n        for (ClassNode node : clazz.getInterfaces()) {\n            findDGMMethodsForClassNode(node, name, accumulator);\n        }\n        if (clazz.getSuperClass() != null) {\n            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);\n        } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {\n            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);\n        }\n    }","id":917,"modified_method":"static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {\n        List<MethodNode> fromDGM = VIRTUAL_DGM_METHODS.get(clazz.getName());\n        if (fromDGM != null) {\n            for (MethodNode node : fromDGM) {\n                if (node.getName().equals(name)) accumulator.add(node);\n            }\n        }\n        for (ClassNode node : clazz.getInterfaces()) {\n            findDGMMethodsForClassNode(node, name, accumulator);\n        }\n        if (clazz.isArray()) {\n            ClassNode componentClass = clazz.getComponentType();\n            if (!componentClass.equals(OBJECT_TYPE)) {\n                if (componentClass.isInterface()) {\n                    findDGMMethodsForClassNode(OBJECT_TYPE.makeArray(), name, accumulator);\n                } else {\n                    findDGMMethodsForClassNode(componentClass.getSuperClass().makeArray(), name, accumulator);\n                }\n            }\n        }\n        if (clazz.getSuperClass() != null) {\n            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);\n        } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {\n            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) return 1;\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","id":918,"modified_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)||receiver == UNKNOWN_PARAMETER_TYPE) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) return 1;\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {\n        final List<MethodNode> chosen;\n        methods.addAll(findDGMMethodsForClassNode(receiver, name));\n\n        chosen = chooseBestMethod(receiver, methods, args);\n            return chosen;\n        }","id":919,"modified_method":"public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {\n        final List<MethodNode> chosen;\n        methods.addAll(findDGMMethodsForClassNode(receiver, name));\n\n        chosen = chooseBestMethod(receiver, methods, args);\n        // specifically for DGM-like methods, we may have a generic type as the first argument of the DGM method\n        // for example: DGM#getAt(T[], int) or DGM#putAt(T[], int, U)\n        // in that case, we must verify that the chosen method match generic type information\n        Iterator<MethodNode> iterator = chosen.iterator();\n        while (iterator.hasNext()) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) iterator.next();\n            MethodNode dgmMethod = emn.getExtensionMethodNode(); // this is the method from DGM\n            GenericsType[] methodGenericTypes = dgmMethod.getGenericsTypes();\n            if (methodGenericTypes !=null && methodGenericTypes.length>0) {\n                Parameter[] parameters = dgmMethod.getParameters();\n                ClassNode dgmOwnerType = parameters[0].getOriginType();\n                if (dgmOwnerType.isGenericsPlaceHolder() || dgmOwnerType.isArray() && dgmOwnerType.getComponentType().isGenericsPlaceHolder()) {\n                    // first parameter of DGM method is a generic type or an array of generic type\n\n                    ClassNode receiverBase = receiver.isArray() ? receiver.getComponentType() : receiver;\n                    ClassNode receiverBaseRedirect = dgmOwnerType.isArray()?dgmOwnerType.getComponentType():dgmOwnerType;\n                    boolean mismatch = false;\n                    // ex: <T, U extends T> void putAt(T[], int, U)\n                    for (int i = 1; i < parameters.length && !mismatch; i++) {\n                        final int k = i - 1; // index of the actual parameter because of the extra receiver parameter in DGM\n                        ClassNode type = parameters[i].getOriginType();\n                        if (isUsingGenericsOrIsArrayUsingGenerics(type)) {\n                            // in a DGM-like method, the first parameter is the receiver. Because of type erasure,\n                            // it can only be T or T[]\n                            String receiverPlaceholder = receiverBaseRedirect.getGenericsTypes()[0].getName();\n                            ClassNode parameterBaseType = args[k].isArray() ? args[k].getComponentType() : args[k];\n                            ClassNode parameterBaseTypeRedirect = type.isArray() ? type.getComponentType() : type;\n                            GenericsType[] paramRedirectGenericsTypes = parameterBaseTypeRedirect.getGenericsTypes();\n                            GenericsType[] paramGenericTypes = parameterBaseType.getGenericsTypes();\n                            if (paramGenericTypes==null) {\n                                paramGenericTypes = new GenericsType[paramRedirectGenericsTypes.length];\n                                Arrays.fill(paramGenericTypes, new GenericsType(OBJECT_TYPE));\n                            } else {\n                                for (int j = 0; j < paramGenericTypes.length; j++) {\n                                    GenericsType paramGenericType = paramGenericTypes[j];\n                                    if (paramGenericType.isWildcard() || paramGenericType.isPlaceholder()) {\n                                        // this may happen if an argument has been used without specifying a generic type\n                                        // for example, foo(List) instead of foo(List<Object>)\n                                        paramGenericTypes[j] = new GenericsType(OBJECT_TYPE);\n                                    }\n                                }\n                            }\n                            for (int j = 0, genericsTypesLength = paramRedirectGenericsTypes.length; j < genericsTypesLength && !mismatch; j++) {\n                                final GenericsType gt = paramRedirectGenericsTypes[j];\n                                if (gt.isPlaceholder()) {\n                                    List<GenericsType> fromMethodGenerics = new LinkedList<GenericsType>();\n                                    for (GenericsType methodGenericType : methodGenericTypes) {\n                                        if (methodGenericType.getName().equals(gt.getName())) {\n                                            fromMethodGenerics.add(methodGenericType);\n                                            break;\n                                        }\n                                    }\n                                    while (!fromMethodGenerics.isEmpty()) {\n                                        // type must either be T or a derived type from T (ex: U extends T)\n                                        GenericsType test = fromMethodGenerics.remove(0);\n                                        if (test.getName().equals(receiverPlaceholder)) {\n                                            if (!implementsInterfaceOrIsSubclassOf(getWrapper(args[k]), getWrapper(receiverBase))) {\n                                                mismatch = true;\n                                                break;\n                                            }\n                                        } else if (test.getUpperBounds()!=null) {\n                                            for (ClassNode classNode : test.getUpperBounds()) {\n                                                GenericsType[] genericsTypes = classNode.getGenericsTypes();\n                                                if (genericsTypes!=null) {\n                                                    for (GenericsType genericsType : genericsTypes) {\n                                                        if (genericsType.isPlaceholder()) {\n                                                            for (GenericsType methodGenericType : methodGenericTypes) {\n                                                                if (methodGenericType.getName().equals(genericsType.getName())) {\n                                                                    fromMethodGenerics.add(methodGenericType);\n                                                                    break;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            if (mismatch) {\n                                iterator.remove();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return chosen;\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"static boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {\n        return type.equals(superOrInterface) || type.isDerivedFrom(superOrInterface) || type.implementsInterface(superOrInterface);\n    }","id":920,"modified_method":"static boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {\n        boolean result = type.equals(superOrInterface)\n                || type.isDerivedFrom(superOrInterface)\n                || type.implementsInterface(superOrInterface)\n                || type == UNKNOWN_PARAMETER_TYPE;\n        if (result) {\n            return true;\n        }\n        if (type.isArray() && superOrInterface.isArray()) {\n            return implementsInterfaceOrIsSubclassOf(type.getComponentType(), superOrInterface.getComponentType());\n        }\n        return false;\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        if (rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null) {\n            if (!isPrimitiveType(lType)) rType = lType; // primitive types should be ignored as they will result in another failure\n        }\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            resultType = lType;\n        }\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            if (rightExpression instanceof ConstructorCallExpression) {\n                inferDiamondType((ConstructorCallExpression) rightExpression, lType);\n            }\n\n            ClassNode originType = getOriginalDeclarationType(leftExpression);\n            typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);\n            // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling\n            // and we must update the result type\n            if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType),getWrapper(originType))) {\n                resultType = originType;\n            }\n\n            // if we are in an if/else branch, keep track of assignment\n            if (ifElseForWhileAssignmentTracker !=null && leftExpression instanceof VariableExpression) {\n                Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();\n                if (accessedVariable instanceof VariableExpression) {\n                    VariableExpression var = (VariableExpression) accessedVariable;\n                    List<ClassNode> types = ifElseForWhileAssignmentTracker.get(var);\n                    if (types == null) {\n                        types = new LinkedList<ClassNode>();\n                        ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n                        if (type!=null) types.add(type);\n                        ifElseForWhileAssignmentTracker.put(var, types);\n                    }\n                    types.add(resultType);\n                }\n            }\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","id":921,"modified_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        if (rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null) {\n            if (!isPrimitiveType(lType)) rType = UNKNOWN_PARAMETER_TYPE; // primitive types should be ignored as they will result in another failure\n        }\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            resultType = lType;\n        }\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            if (rightExpression instanceof ConstructorCallExpression) {\n                inferDiamondType((ConstructorCallExpression) rightExpression, lType);\n            }\n\n            ClassNode originType = getOriginalDeclarationType(leftExpression);\n            typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);\n            // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling\n            // and we must update the result type\n            if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType),getWrapper(originType))) {\n                resultType = originType;\n            }\n\n            // if we are in an if/else branch, keep track of assignment\n            if (ifElseForWhileAssignmentTracker !=null && leftExpression instanceof VariableExpression) {\n                Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();\n                if (accessedVariable instanceof VariableExpression) {\n                    VariableExpression var = (VariableExpression) accessedVariable;\n                    List<ClassNode> types = ifElseForWhileAssignmentTracker.get(var);\n                    if (types == null) {\n                        types = new LinkedList<ClassNode>();\n                        ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n                        if (type!=null) types.add(type);\n                        ifElseForWhileAssignmentTracker.put(var, types);\n                    }\n                    types.add(resultType);\n                }\n            }\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, List<MethodNode> candidateMethods, Expression location) {\n        if (!receiver.isUsingGenerics()) return;\n        int failure=0;\n        GenericsType[] methodGenericTypes = null;\n        for (MethodNode method : candidateMethods) {\n            ClassNode methodNodeReceiver = method.getDeclaringClass();\n            if (!implementsInterfaceOrIsSubclassOf(receiver, methodNodeReceiver) || !methodNodeReceiver.isUsingGenerics()) continue;\n            // both candidate method and receiver have generic information so a check is possible\n            Parameter[] parameters = method.getParameters();\n            int argNum = 0;\n            for (Parameter parameter : parameters) {\n                ClassNode type = parameter.getType();\n                if (type.isUsingGenerics()) {\n                    methodGenericTypes =\n                            GenericsUtils.alignGenericTypes(\n                                    receiver.redirect().getGenericsTypes(),\n                                    receiver.getGenericsTypes(),\n                                    type.getGenericsTypes());\n                    if (methodGenericTypes.length==1) {\n                        ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                        ClassNode actualType = getWrapper(arguments[argNum]);\n                        if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                            failure++;\n                        }\n                    } else {\n                        // not sure this is possible !\n                    }\n                } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {\n                    ClassNode componentType = type.getComponentType();\n                    methodGenericTypes =\n                            GenericsUtils.alignGenericTypes(\n                                    receiver.redirect().getGenericsTypes(),\n                                    receiver.getGenericsTypes(),\n                                    componentType.getGenericsTypes());\n                    if (methodGenericTypes.length==1) {\n                        ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                        ClassNode actualType = getWrapper(arguments[argNum].getComponentType());\n                        if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                            failure++;\n                            // for proper error message\n                            GenericsType baseGT = methodGenericTypes[0];\n                            methodGenericTypes[0] = new GenericsType(baseGT.getType(), baseGT.getUpperBounds(), baseGT.getLowerBound());\n                            methodGenericTypes[0].setType(methodGenericTypes[0].getType().makeArray());\n                        }\n                    } else {\n                        // not sure this is possible !\n                    }\n                }\n                argNum++;\n            }\n        }\n        if (failure==candidateMethods.size()) {\n            if (failure==1) {\n                MethodNode method = candidateMethods.get(0);\n                ClassNode[] parameterTypes = new ClassNode[methodGenericTypes.length];\n                for (int i = 0; i < methodGenericTypes.length; i++) {\n                    parameterTypes[i] = methodGenericTypes[i].getType();\n                }\n                addStaticTypeError(\"Cannot call \" + receiver.getName()+\"#\"+\n                        toMethodParametersString(method.getName(), parameterTypes) +\n                        \" with arguments \" + Arrays.asList(arguments), location);\n            } else {\n                addStaticTypeError(\"No matching method found for arguments \"+Arrays.asList(arguments), location);\n            }\n        }\n    }","id":922,"modified_method":"private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {\n        if (!isUsingGenericsOrIsArrayUsingGenerics(receiver)) return;\n        boolean failure=false;\n        GenericsType[] methodGenericTypes = null;\n        ClassNode methodNodeReceiver = candidateMethod.getDeclaringClass();\n        if (!implementsInterfaceOrIsSubclassOf(receiver, methodNodeReceiver) || !isUsingGenericsOrIsArrayUsingGenerics(methodNodeReceiver))\n            return;\n        // both candidate method and receiver have generic information so a check is possible\n        Parameter[] parameters = candidateMethod.getParameters();\n        int argNum = 0;\n        for (Parameter parameter : parameters) {\n            ClassNode type = parameter.getType();\n            if (type.isUsingGenerics()) {\n                methodGenericTypes =\n                        GenericsUtils.alignGenericTypes(\n                                receiver.redirect().getGenericsTypes(),\n                                receiver.getGenericsTypes(),\n                                type.getGenericsTypes());\n                if (methodGenericTypes.length == 1) {\n                    ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                    ClassNode actualType = getWrapper(arguments[argNum]);\n                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                        failure = true;\n                    }\n                } else {\n                    // not sure this is possible !\n                }\n            } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {\n                ClassNode componentType = type.getComponentType();\n                methodGenericTypes =\n                        GenericsUtils.alignGenericTypes(\n                                receiver.redirect().getGenericsTypes(),\n                                receiver.getGenericsTypes(),\n                                componentType.getGenericsTypes());\n                if (methodGenericTypes.length == 1) {\n                    ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                    ClassNode actualType = getWrapper(arguments[argNum].getComponentType());\n                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                        failure = true;\n                        // for proper error message\n                        GenericsType baseGT = methodGenericTypes[0];\n                        methodGenericTypes[0] = new GenericsType(baseGT.getType(), baseGT.getUpperBounds(), baseGT.getLowerBound());\n                        methodGenericTypes[0].setType(methodGenericTypes[0].getType().makeArray());\n                    }\n                } else {\n                    // not sure this is possible !\n                }\n            }\n            argNum++;\n        }\n        if (failure) {\n            ClassNode[] parameterTypes = new ClassNode[methodGenericTypes.length];\n            for (int i = 0; i < methodGenericTypes.length; i++) {\n                parameterTypes[i] = methodGenericTypes[i].getType();\n            }\n            addStaticTypeError(\"Cannot call \" + receiver.getName() + \"#\" +\n                    toMethodParametersString(candidateMethod.getName(), parameterTypes) +\n                    \" with arguments \" + Arrays.asList(arguments), location);\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":923,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);\n                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {\n                    // a type inference has been made on a variable which type was defined in an instanceof block\n                    // we erase available information with the new type\n                    temporaryTypesForExpression.clear();\n                }\n            }\n        }\n    }","id":924,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        if (cn==UNKNOWN_PARAMETER_TYPE) {\n            // this can happen for example when \"null\" is used in an assignment or a method parameter.\n            // In that case, instead of storing the virtual type, we must \"reset\" type information\n            // by determining the declaration type of the expression\n            storeType(exp, getOriginalDeclarationType(exp));\n            return;\n        }\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);\n                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {\n                    // a type inference has been made on a variable which type was defined in an instanceof block\n                    // we erase available information with the new type\n                    temporaryTypesForExpression.clear();\n                }\n            }\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (expr.getRightExpression() instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) expr.getRightExpression()).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            if (ClassHelper.STRING_TYPE.equals(left)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(left);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (DIVIDE==op || DIVIDE_EQUAL==op) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                return Double_TYPE;\n            } else if (BigDecimal_TYPE.equals(leftRedirect)||BigDecimal_TYPE.equals(rightRedirect)) {\n                return BigDecimal_TYPE;\n            }\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n\n        MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n        if (method != null) {\n            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, Collections.singletonList(method), expr );\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, new ArgumentListExpression(expr.getRightExpression()));\n        }\n        //TODO: other cases\n        return null;\n    }","id":925,"modified_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (expr.getRightExpression() instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) expr.getRightExpression()).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            if (ClassHelper.STRING_TYPE.equals(left)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(left);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (DIVIDE==op || DIVIDE_EQUAL==op) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                return Double_TYPE;\n            } else if (BigDecimal_TYPE.equals(leftRedirect)||BigDecimal_TYPE.equals(rightRedirect)) {\n                return BigDecimal_TYPE;\n            }\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, method, expr );\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, new ArgumentListExpression(expr.getRightExpression()));\n        }\n        //TODO: other cases\n        return null;\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":926,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Returns a map which contains, as the key, the name of a class. The value\n     * consists of a list of MethodNode, one for each default groovy method found\n     * which is applicable for this class.\n     * @return\n     */\n    private static Map<String, List<MethodNode>> getDGMMethods() {\n        Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();\n        List<Class> classes = new LinkedList<Class>();\n        Collections.addAll(classes, DefaultGroovyMethods.DGM_LIKE_CLASSES);\n        Collections.addAll(classes, DefaultGroovyMethods.additionals);\n\t\tfor (Class dgmLikeClass : classes) {\n\t\t\tClassNode cn = ClassHelper.makeWithoutCaching(dgmLikeClass, true);\n\t\t\tfor (MethodNode metaMethod : cn.getMethods()) {\n\t\t\t\tParameter[] types = metaMethod.getParameters();\n\t\t\t\tif (metaMethod.isStatic() && metaMethod.isPublic() && types.length > 0) {\n\t\t\t\t\tParameter[] parameters = new Parameter[types.length - 1];\n\t\t\t\t\tSystem.arraycopy(types, 1, parameters, 0, parameters.length);\n\t\t\t\t\tMethodNode node = new MethodNode(\n\t\t\t\t\t\t\tmetaMethod.getName(),\n\t\t\t\t\t\t\tmetaMethod.getModifiers(),\n\t\t\t\t\t\t\tmetaMethod.getReturnType(),\n\t\t\t\t\t\t\tparameters,\n\t\t\t\t\t\t\tClassNode.EMPTY_ARRAY, null);\n\t\t\t\t\tnode.setGenericsTypes(metaMethod.getGenericsTypes());\n\t\t\t\t\tClassNode declaringClass = types[0].getType();\n\t\t\t\t\tString declaringClassName = declaringClass.getName();\n\t\t\t\t\tnode.setDeclaringClass(declaringClass);\n\n\t\t\t\t\tList<MethodNode> nodes = methods.get(declaringClassName);\n\t\t\t\t\tif (nodes == null) {\n\t\t\t\t\t\tnodes = new LinkedList<MethodNode>();\n\t\t\t\t\t\tmethods.put(declaringClassName, nodes);\n\t\t\t\t\t}\n\t\t\t\t\tnodes.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return methods;\n    }","id":927,"modified_method":"/**\n     * Returns a map which contains, as the key, the name of a class. The value\n     * consists of a list of MethodNode, one for each default groovy method found\n     * which is applicable for this class.\n     * @return\n     */\n    private static Map<String, List<MethodNode>> getDGMMethods() {\n        Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();\n        List<Class> classes = new LinkedList<Class>();\n        Collections.addAll(classes, DefaultGroovyMethods.DGM_LIKE_CLASSES);\n        Collections.addAll(classes, DefaultGroovyMethods.additionals);\n        classes.add(ObjectArrayStaticTypesHelper.class);\n\t\tfor (Class dgmLikeClass : classes) {\n\t\t\tClassNode cn = ClassHelper.makeWithoutCaching(dgmLikeClass, true);\n\t\t\tfor (MethodNode metaMethod : cn.getMethods()) {\n\t\t\t\tParameter[] types = metaMethod.getParameters();\n\t\t\t\tif (metaMethod.isStatic() && metaMethod.isPublic() && types.length > 0) {\n\t\t\t\t\tParameter[] parameters = new Parameter[types.length - 1];\n\t\t\t\t\tSystem.arraycopy(types, 1, parameters, 0, parameters.length);\n\t\t\t\t\tMethodNode node = new ExtensionMethodNode(\n                            metaMethod,\n\t\t\t\t\t\t\tmetaMethod.getName(),\n\t\t\t\t\t\t\tmetaMethod.getModifiers(),\n\t\t\t\t\t\t\tmetaMethod.getReturnType(),\n\t\t\t\t\t\t\tparameters,\n\t\t\t\t\t\t\tClassNode.EMPTY_ARRAY, null);\n\t\t\t\t\tnode.setGenericsTypes(metaMethod.getGenericsTypes());\n\t\t\t\t\tClassNode declaringClass = types[0].getType();\n\t\t\t\t\tString declaringClassName = declaringClass.getName();\n\t\t\t\t\tnode.setDeclaringClass(declaringClass);\n\n\t\t\t\t\tList<MethodNode> nodes = methods.get(declaringClassName);\n\t\t\t\t\tif (nodes == null) {\n\t\t\t\t\t\tnodes = new LinkedList<MethodNode>();\n\t\t\t\t\t\tmethods.put(declaringClassName, nodes);\n\t\t\t\t\t}\n\t\t\t\t\tnodes.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return methods;\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {\n        List<MethodNode> fromDGM = VIRTUAL_DGM_METHODS.get(clazz.getName());\n        if (fromDGM != null) {\n            for (MethodNode node : fromDGM) {\n                if (node.getName().equals(name)) accumulator.add(node);\n            }\n        }\n        for (ClassNode node : clazz.getInterfaces()) {\n            findDGMMethodsForClassNode(node, name, accumulator);\n        }\n        if (clazz.getSuperClass() != null) {\n            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);\n        } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {\n            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);\n        }\n    }","id":928,"modified_method":"static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {\n        List<MethodNode> fromDGM = VIRTUAL_DGM_METHODS.get(clazz.getName());\n        if (fromDGM != null) {\n            for (MethodNode node : fromDGM) {\n                if (node.getName().equals(name)) accumulator.add(node);\n            }\n        }\n        for (ClassNode node : clazz.getInterfaces()) {\n            findDGMMethodsForClassNode(node, name, accumulator);\n        }\n        if (clazz.isArray()) {\n            ClassNode componentClass = clazz.getComponentType();\n            if (!componentClass.equals(OBJECT_TYPE)) {\n                if (componentClass.isInterface()) {\n                    findDGMMethodsForClassNode(OBJECT_TYPE.makeArray(), name, accumulator);\n                } else {\n                    findDGMMethodsForClassNode(componentClass.getSuperClass().makeArray(), name, accumulator);\n                }\n            }\n        }\n        if (clazz.getSuperClass() != null) {\n            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);\n        } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {\n            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) return 1;\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","id":929,"modified_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)||receiver == UNKNOWN_PARAMETER_TYPE) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) return 1;\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {\n        final List<MethodNode> chosen;\n        methods.addAll(findDGMMethodsForClassNode(receiver, name));\n\n        chosen = chooseBestMethod(receiver, methods, args);\n            return chosen;\n        }","id":930,"modified_method":"public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {\n        final List<MethodNode> chosen;\n        methods.addAll(findDGMMethodsForClassNode(receiver, name));\n\n        chosen = chooseBestMethod(receiver, methods, args);\n        // specifically for DGM-like methods, we may have a generic type as the first argument of the DGM method\n        // for example: DGM#getAt(T[], int) or DGM#putAt(T[], int, U)\n        // in that case, we must verify that the chosen method match generic type information\n        Iterator<MethodNode> iterator = chosen.iterator();\n        while (iterator.hasNext()) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) iterator.next();\n            MethodNode dgmMethod = emn.getExtensionMethodNode(); // this is the method from DGM\n            GenericsType[] methodGenericTypes = dgmMethod.getGenericsTypes();\n            if (methodGenericTypes !=null && methodGenericTypes.length>0) {\n                Parameter[] parameters = dgmMethod.getParameters();\n                ClassNode dgmOwnerType = parameters[0].getOriginType();\n                if (dgmOwnerType.isGenericsPlaceHolder() || dgmOwnerType.isArray() && dgmOwnerType.getComponentType().isGenericsPlaceHolder()) {\n                    // first parameter of DGM method is a generic type or an array of generic type\n\n                    ClassNode receiverBase = receiver.isArray() ? receiver.getComponentType() : receiver;\n                    ClassNode receiverBaseRedirect = dgmOwnerType.isArray()?dgmOwnerType.getComponentType():dgmOwnerType;\n                    boolean mismatch = false;\n                    // ex: <T, U extends T> void putAt(T[], int, U)\n                    for (int i = 1; i < parameters.length && !mismatch; i++) {\n                        final int k = i - 1; // index of the actual parameter because of the extra receiver parameter in DGM\n                        ClassNode type = parameters[i].getOriginType();\n                        if (isUsingGenericsOrIsArrayUsingGenerics(type)) {\n                            // in a DGM-like method, the first parameter is the receiver. Because of type erasure,\n                            // it can only be T or T[]\n                            String receiverPlaceholder = receiverBaseRedirect.getGenericsTypes()[0].getName();\n                            ClassNode parameterBaseType = args[k].isArray() ? args[k].getComponentType() : args[k];\n                            ClassNode parameterBaseTypeRedirect = type.isArray() ? type.getComponentType() : type;\n                            GenericsType[] paramRedirectGenericsTypes = parameterBaseTypeRedirect.getGenericsTypes();\n                            GenericsType[] paramGenericTypes = parameterBaseType.getGenericsTypes();\n                            if (paramGenericTypes==null) {\n                                paramGenericTypes = new GenericsType[paramRedirectGenericsTypes.length];\n                                Arrays.fill(paramGenericTypes, new GenericsType(OBJECT_TYPE));\n                            } else {\n                                for (int j = 0; j < paramGenericTypes.length; j++) {\n                                    GenericsType paramGenericType = paramGenericTypes[j];\n                                    if (paramGenericType.isWildcard() || paramGenericType.isPlaceholder()) {\n                                        // this may happen if an argument has been used without specifying a generic type\n                                        // for example, foo(List) instead of foo(List<Object>)\n                                        paramGenericTypes[j] = new GenericsType(OBJECT_TYPE);\n                                    }\n                                }\n                            }\n                            for (int j = 0, genericsTypesLength = paramRedirectGenericsTypes.length; j < genericsTypesLength && !mismatch; j++) {\n                                final GenericsType gt = paramRedirectGenericsTypes[j];\n                                if (gt.isPlaceholder()) {\n                                    List<GenericsType> fromMethodGenerics = new LinkedList<GenericsType>();\n                                    for (GenericsType methodGenericType : methodGenericTypes) {\n                                        if (methodGenericType.getName().equals(gt.getName())) {\n                                            fromMethodGenerics.add(methodGenericType);\n                                            break;\n                                        }\n                                    }\n                                    while (!fromMethodGenerics.isEmpty()) {\n                                        // type must either be T or a derived type from T (ex: U extends T)\n                                        GenericsType test = fromMethodGenerics.remove(0);\n                                        if (test.getName().equals(receiverPlaceholder)) {\n                                            if (!implementsInterfaceOrIsSubclassOf(getWrapper(args[k]), getWrapper(receiverBase))) {\n                                                mismatch = true;\n                                                break;\n                                            }\n                                        } else if (test.getUpperBounds()!=null) {\n                                            for (ClassNode classNode : test.getUpperBounds()) {\n                                                GenericsType[] genericsTypes = classNode.getGenericsTypes();\n                                                if (genericsTypes!=null) {\n                                                    for (GenericsType genericsType : genericsTypes) {\n                                                        if (genericsType.isPlaceholder()) {\n                                                            for (GenericsType methodGenericType : methodGenericTypes) {\n                                                                if (methodGenericType.getName().equals(genericsType.getName())) {\n                                                                    fromMethodGenerics.add(methodGenericType);\n                                                                    break;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            if (mismatch) {\n                                iterator.remove();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return chosen;\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        for (MethodNode m : methods) {\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(receiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !receiver.equals(m.getDeclaringClass())) dist+=getDistance(receiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !receiver.equals(m.getDeclaringClass())) dist+=getDistance(receiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !receiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","id":931,"modified_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        for (MethodNode m : methods) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"static boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {\n        return type.equals(superOrInterface) || type.isDerivedFrom(superOrInterface) || type.implementsInterface(superOrInterface);\n    }","id":932,"modified_method":"static boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {\n        boolean result = type.equals(superOrInterface)\n                || type.isDerivedFrom(superOrInterface)\n                || type.implementsInterface(superOrInterface)\n                || type == UNKNOWN_PARAMETER_TYPE;\n        if (result) {\n            return true;\n        }\n        if (type.isArray() && superOrInterface.isArray()) {\n            return implementsInterfaceOrIsSubclassOf(type.getComponentType(), superOrInterface.getComponentType());\n        }\n        return false;\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (expr.getRightExpression() instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) expr.getRightExpression()).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            if (ClassHelper.STRING_TYPE.equals(left)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(left);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (DIVIDE==op || DIVIDE_EQUAL==op) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                return Double_TYPE;\n            } else if (BigDecimal_TYPE.equals(leftRedirect)||BigDecimal_TYPE.equals(rightRedirect)) {\n                return BigDecimal_TYPE;\n            }\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n\n        MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n        if (method != null) {\n            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, Collections.singletonList(method), expr );\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, new ArgumentListExpression(expr.getRightExpression()));\n        }\n        //TODO: other cases\n        return null;\n    }","id":933,"modified_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (expr.getRightExpression() instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) expr.getRightExpression()).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            if (ClassHelper.STRING_TYPE.equals(left)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(left);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (DIVIDE==op || DIVIDE_EQUAL==op) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                return Double_TYPE;\n            } else if (BigDecimal_TYPE.equals(leftRedirect)||BigDecimal_TYPE.equals(rightRedirect)) {\n                return BigDecimal_TYPE;\n            }\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, method, expr );\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, new ArgumentListExpression(expr.getRightExpression()));\n        }\n        //TODO: other cases\n        return null;\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":934,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);\n                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {\n                    // a type inference has been made on a variable which type was defined in an instanceof block\n                    // we erase available information with the new type\n                    temporaryTypesForExpression.clear();\n                }\n            }\n        }\n    }","id":935,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        if (cn==UNKNOWN_PARAMETER_TYPE) {\n            // this can happen for example when \"null\" is used in an assignment or a method parameter.\n            // In that case, instead of storing the virtual type, we must \"reset\" type information\n            // by determining the declaration type of the expression\n            storeType(exp, getOriginalDeclarationType(exp));\n            return;\n        }\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);\n                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {\n                    // a type inference has been made on a variable which type was defined in an instanceof block\n                    // we erase available information with the new type\n                    temporaryTypesForExpression.clear();\n                }\n            }\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":936,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        if (rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null) {\n            if (!isPrimitiveType(lType)) rType = lType; // primitive types should be ignored as they will result in another failure\n        }\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            resultType = lType;\n        }\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            if (rightExpression instanceof ConstructorCallExpression) {\n                inferDiamondType((ConstructorCallExpression) rightExpression, lType);\n            }\n\n            ClassNode originType = getOriginalDeclarationType(leftExpression);\n            typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);\n            // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling\n            // and we must update the result type\n            if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType),getWrapper(originType))) {\n                resultType = originType;\n            }\n\n            // if we are in an if/else branch, keep track of assignment\n            if (ifElseForWhileAssignmentTracker !=null && leftExpression instanceof VariableExpression) {\n                Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();\n                if (accessedVariable instanceof VariableExpression) {\n                    VariableExpression var = (VariableExpression) accessedVariable;\n                    List<ClassNode> types = ifElseForWhileAssignmentTracker.get(var);\n                    if (types == null) {\n                        types = new LinkedList<ClassNode>();\n                        ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n                        if (type!=null) types.add(type);\n                        ifElseForWhileAssignmentTracker.put(var, types);\n                    }\n                    types.add(resultType);\n                }\n            }\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","id":937,"modified_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        if (rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null) {\n            if (!isPrimitiveType(lType)) rType = UNKNOWN_PARAMETER_TYPE; // primitive types should be ignored as they will result in another failure\n        }\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            resultType = lType;\n        }\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            if (rightExpression instanceof ConstructorCallExpression) {\n                inferDiamondType((ConstructorCallExpression) rightExpression, lType);\n            }\n\n            ClassNode originType = getOriginalDeclarationType(leftExpression);\n            typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);\n            // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling\n            // and we must update the result type\n            if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType),getWrapper(originType))) {\n                resultType = originType;\n            }\n\n            // if we are in an if/else branch, keep track of assignment\n            if (ifElseForWhileAssignmentTracker !=null && leftExpression instanceof VariableExpression) {\n                Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();\n                if (accessedVariable instanceof VariableExpression) {\n                    VariableExpression var = (VariableExpression) accessedVariable;\n                    List<ClassNode> types = ifElseForWhileAssignmentTracker.get(var);\n                    if (types == null) {\n                        types = new LinkedList<ClassNode>();\n                        ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n                        if (type!=null) types.add(type);\n                        ifElseForWhileAssignmentTracker.put(var, types);\n                    }\n                    types.add(resultType);\n                }\n            }\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, List<MethodNode> candidateMethods, Expression location) {\n        if (!receiver.isUsingGenerics()) return;\n        int failure=0;\n        GenericsType[] methodGenericTypes = null;\n        for (MethodNode method : candidateMethods) {\n            ClassNode methodNodeReceiver = method.getDeclaringClass();\n            if (!implementsInterfaceOrIsSubclassOf(receiver, methodNodeReceiver) || !methodNodeReceiver.isUsingGenerics()) continue;\n            // both candidate method and receiver have generic information so a check is possible\n            Parameter[] parameters = method.getParameters();\n            int argNum = 0;\n            for (Parameter parameter : parameters) {\n                ClassNode type = parameter.getType();\n                if (type.isUsingGenerics()) {\n                    methodGenericTypes =\n                            GenericsUtils.alignGenericTypes(\n                                    receiver.redirect().getGenericsTypes(),\n                                    receiver.getGenericsTypes(),\n                                    type.getGenericsTypes());\n                    if (methodGenericTypes.length==1) {\n                        ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                        ClassNode actualType = getWrapper(arguments[argNum]);\n                        if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                            failure++;\n                        }\n                    } else {\n                        // not sure this is possible !\n                    }\n                } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {\n                    ClassNode componentType = type.getComponentType();\n                    methodGenericTypes =\n                            GenericsUtils.alignGenericTypes(\n                                    receiver.redirect().getGenericsTypes(),\n                                    receiver.getGenericsTypes(),\n                                    componentType.getGenericsTypes());\n                    if (methodGenericTypes.length==1) {\n                        ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                        ClassNode actualType = getWrapper(arguments[argNum].getComponentType());\n                        if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                            failure++;\n                            // for proper error message\n                            GenericsType baseGT = methodGenericTypes[0];\n                            methodGenericTypes[0] = new GenericsType(baseGT.getType(), baseGT.getUpperBounds(), baseGT.getLowerBound());\n                            methodGenericTypes[0].setType(methodGenericTypes[0].getType().makeArray());\n                        }\n                    } else {\n                        // not sure this is possible !\n                    }\n                }\n                argNum++;\n            }\n        }\n        if (failure==candidateMethods.size()) {\n            if (failure==1) {\n                MethodNode method = candidateMethods.get(0);\n                ClassNode[] parameterTypes = new ClassNode[methodGenericTypes.length];\n                for (int i = 0; i < methodGenericTypes.length; i++) {\n                    parameterTypes[i] = methodGenericTypes[i].getType();\n                }\n                addStaticTypeError(\"Cannot call \" + receiver.getName()+\"#\"+\n                        toMethodParametersString(method.getName(), parameterTypes) +\n                        \" with arguments \" + Arrays.asList(arguments), location);\n            } else {\n                addStaticTypeError(\"No matching method found for arguments \"+Arrays.asList(arguments), location);\n            }\n        }\n    }","id":938,"modified_method":"private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {\n        if (!isUsingGenericsOrIsArrayUsingGenerics(receiver)) return;\n        boolean failure=false;\n        GenericsType[] methodGenericTypes = null;\n        ClassNode methodNodeReceiver = candidateMethod.getDeclaringClass();\n        if (!implementsInterfaceOrIsSubclassOf(receiver, methodNodeReceiver) || !isUsingGenericsOrIsArrayUsingGenerics(methodNodeReceiver))\n            return;\n        // both candidate method and receiver have generic information so a check is possible\n        Parameter[] parameters = candidateMethod.getParameters();\n        int argNum = 0;\n        for (Parameter parameter : parameters) {\n            ClassNode type = parameter.getType();\n            if (type.isUsingGenerics()) {\n                methodGenericTypes =\n                        GenericsUtils.alignGenericTypes(\n                                receiver.redirect().getGenericsTypes(),\n                                receiver.getGenericsTypes(),\n                                type.getGenericsTypes());\n                if (methodGenericTypes.length == 1) {\n                    ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                    ClassNode actualType = getWrapper(arguments[argNum]);\n                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                        failure = true;\n                    }\n                } else {\n                    // not sure this is possible !\n                }\n            } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {\n                ClassNode componentType = type.getComponentType();\n                methodGenericTypes =\n                        GenericsUtils.alignGenericTypes(\n                                receiver.redirect().getGenericsTypes(),\n                                receiver.getGenericsTypes(),\n                                componentType.getGenericsTypes());\n                if (methodGenericTypes.length == 1) {\n                    ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                    ClassNode actualType = getWrapper(arguments[argNum].getComponentType());\n                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                        failure = true;\n                        // for proper error message\n                        GenericsType baseGT = methodGenericTypes[0];\n                        methodGenericTypes[0] = new GenericsType(baseGT.getType(), baseGT.getUpperBounds(), baseGT.getLowerBound());\n                        methodGenericTypes[0].setType(methodGenericTypes[0].getType().makeArray());\n                    }\n                } else {\n                    // not sure this is possible !\n                }\n            }\n            argNum++;\n        }\n        if (failure) {\n            ClassNode[] parameterTypes = new ClassNode[methodGenericTypes.length];\n            for (int i = 0; i < methodGenericTypes.length; i++) {\n                parameterTypes[i] = methodGenericTypes[i].getType();\n            }\n            addStaticTypeError(\"Cannot call \" + receiver.getName() + \"#\" +\n                    toMethodParametersString(candidateMethod.getName(), parameterTypes) +\n                    \" with arguments \" + Arrays.asList(arguments), location);\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"static boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {\n        return type.equals(superOrInterface) || type.isDerivedFrom(superOrInterface) || type.implementsInterface(superOrInterface);\n    }","id":939,"modified_method":"static boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {\n        boolean result = type.equals(superOrInterface)\n                || type.isDerivedFrom(superOrInterface)\n                || type.implementsInterface(superOrInterface)\n                || type == UNKNOWN_PARAMETER_TYPE;\n        if (result) {\n            return true;\n        }\n        if (type.isArray() && superOrInterface.isArray()) {\n            return implementsInterfaceOrIsSubclassOf(type.getComponentType(), superOrInterface.getComponentType());\n        }\n        return false;\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        for (MethodNode m : methods) {\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(receiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !receiver.equals(m.getDeclaringClass())) dist+=getDistance(receiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !receiver.equals(m.getDeclaringClass())) dist+=getDistance(receiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !receiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","id":940,"modified_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        for (MethodNode m : methods) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {\n        final List<MethodNode> chosen;\n        methods.addAll(findDGMMethodsForClassNode(receiver, name));\n\n        chosen = chooseBestMethod(receiver, methods, args);\n            return chosen;\n        }","id":941,"modified_method":"public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {\n        final List<MethodNode> chosen;\n        methods.addAll(findDGMMethodsForClassNode(receiver, name));\n\n        chosen = chooseBestMethod(receiver, methods, args);\n        // specifically for DGM-like methods, we may have a generic type as the first argument of the DGM method\n        // for example: DGM#getAt(T[], int) or DGM#putAt(T[], int, U)\n        // in that case, we must verify that the chosen method match generic type information\n        Iterator<MethodNode> iterator = chosen.iterator();\n        while (iterator.hasNext()) {\n            ExtensionMethodNode emn = (ExtensionMethodNode) iterator.next();\n            MethodNode dgmMethod = emn.getExtensionMethodNode(); // this is the method from DGM\n            GenericsType[] methodGenericTypes = dgmMethod.getGenericsTypes();\n            if (methodGenericTypes !=null && methodGenericTypes.length>0) {\n                Parameter[] parameters = dgmMethod.getParameters();\n                ClassNode dgmOwnerType = parameters[0].getOriginType();\n                if (dgmOwnerType.isGenericsPlaceHolder() || dgmOwnerType.isArray() && dgmOwnerType.getComponentType().isGenericsPlaceHolder()) {\n                    // first parameter of DGM method is a generic type or an array of generic type\n\n                    ClassNode receiverBase = receiver.isArray() ? receiver.getComponentType() : receiver;\n                    ClassNode receiverBaseRedirect = dgmOwnerType.isArray()?dgmOwnerType.getComponentType():dgmOwnerType;\n                    boolean mismatch = false;\n                    // ex: <T, U extends T> void putAt(T[], int, U)\n                    for (int i = 1; i < parameters.length && !mismatch; i++) {\n                        final int k = i - 1; // index of the actual parameter because of the extra receiver parameter in DGM\n                        ClassNode type = parameters[i].getOriginType();\n                        if (isUsingGenericsOrIsArrayUsingGenerics(type)) {\n                            // in a DGM-like method, the first parameter is the receiver. Because of type erasure,\n                            // it can only be T or T[]\n                            String receiverPlaceholder = receiverBaseRedirect.getGenericsTypes()[0].getName();\n                            ClassNode parameterBaseType = args[k].isArray() ? args[k].getComponentType() : args[k];\n                            ClassNode parameterBaseTypeRedirect = type.isArray() ? type.getComponentType() : type;\n                            GenericsType[] paramRedirectGenericsTypes = parameterBaseTypeRedirect.getGenericsTypes();\n                            GenericsType[] paramGenericTypes = parameterBaseType.getGenericsTypes();\n                            if (paramGenericTypes==null) {\n                                paramGenericTypes = new GenericsType[paramRedirectGenericsTypes.length];\n                                Arrays.fill(paramGenericTypes, new GenericsType(OBJECT_TYPE));\n                            } else {\n                                for (int j = 0; j < paramGenericTypes.length; j++) {\n                                    GenericsType paramGenericType = paramGenericTypes[j];\n                                    if (paramGenericType.isWildcard() || paramGenericType.isPlaceholder()) {\n                                        // this may happen if an argument has been used without specifying a generic type\n                                        // for example, foo(List) instead of foo(List<Object>)\n                                        paramGenericTypes[j] = new GenericsType(OBJECT_TYPE);\n                                    }\n                                }\n                            }\n                            for (int j = 0, genericsTypesLength = paramRedirectGenericsTypes.length; j < genericsTypesLength && !mismatch; j++) {\n                                final GenericsType gt = paramRedirectGenericsTypes[j];\n                                if (gt.isPlaceholder()) {\n                                    List<GenericsType> fromMethodGenerics = new LinkedList<GenericsType>();\n                                    for (GenericsType methodGenericType : methodGenericTypes) {\n                                        if (methodGenericType.getName().equals(gt.getName())) {\n                                            fromMethodGenerics.add(methodGenericType);\n                                            break;\n                                        }\n                                    }\n                                    while (!fromMethodGenerics.isEmpty()) {\n                                        // type must either be T or a derived type from T (ex: U extends T)\n                                        GenericsType test = fromMethodGenerics.remove(0);\n                                        if (test.getName().equals(receiverPlaceholder)) {\n                                            if (!implementsInterfaceOrIsSubclassOf(getWrapper(args[k]), getWrapper(receiverBase))) {\n                                                mismatch = true;\n                                                break;\n                                            }\n                                        } else if (test.getUpperBounds()!=null) {\n                                            for (ClassNode classNode : test.getUpperBounds()) {\n                                                GenericsType[] genericsTypes = classNode.getGenericsTypes();\n                                                if (genericsTypes!=null) {\n                                                    for (GenericsType genericsType : genericsTypes) {\n                                                        if (genericsType.isPlaceholder()) {\n                                                            for (GenericsType methodGenericType : methodGenericTypes) {\n                                                                if (methodGenericType.getName().equals(genericsType.getName())) {\n                                                                    fromMethodGenerics.add(methodGenericType);\n                                                                    break;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            if (mismatch) {\n                                iterator.remove();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return chosen;\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Returns a map which contains, as the key, the name of a class. The value\n     * consists of a list of MethodNode, one for each default groovy method found\n     * which is applicable for this class.\n     * @return\n     */\n    private static Map<String, List<MethodNode>> getDGMMethods() {\n        Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();\n        List<Class> classes = new LinkedList<Class>();\n        Collections.addAll(classes, DefaultGroovyMethods.DGM_LIKE_CLASSES);\n        Collections.addAll(classes, DefaultGroovyMethods.additionals);\n\t\tfor (Class dgmLikeClass : classes) {\n\t\t\tClassNode cn = ClassHelper.makeWithoutCaching(dgmLikeClass, true);\n\t\t\tfor (MethodNode metaMethod : cn.getMethods()) {\n\t\t\t\tParameter[] types = metaMethod.getParameters();\n\t\t\t\tif (metaMethod.isStatic() && metaMethod.isPublic() && types.length > 0) {\n\t\t\t\t\tParameter[] parameters = new Parameter[types.length - 1];\n\t\t\t\t\tSystem.arraycopy(types, 1, parameters, 0, parameters.length);\n\t\t\t\t\tMethodNode node = new MethodNode(\n\t\t\t\t\t\t\tmetaMethod.getName(),\n\t\t\t\t\t\t\tmetaMethod.getModifiers(),\n\t\t\t\t\t\t\tmetaMethod.getReturnType(),\n\t\t\t\t\t\t\tparameters,\n\t\t\t\t\t\t\tClassNode.EMPTY_ARRAY, null);\n\t\t\t\t\tnode.setGenericsTypes(metaMethod.getGenericsTypes());\n\t\t\t\t\tClassNode declaringClass = types[0].getType();\n\t\t\t\t\tString declaringClassName = declaringClass.getName();\n\t\t\t\t\tnode.setDeclaringClass(declaringClass);\n\n\t\t\t\t\tList<MethodNode> nodes = methods.get(declaringClassName);\n\t\t\t\t\tif (nodes == null) {\n\t\t\t\t\t\tnodes = new LinkedList<MethodNode>();\n\t\t\t\t\t\tmethods.put(declaringClassName, nodes);\n\t\t\t\t\t}\n\t\t\t\t\tnodes.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return methods;\n    }","id":942,"modified_method":"/**\n     * Returns a map which contains, as the key, the name of a class. The value\n     * consists of a list of MethodNode, one for each default groovy method found\n     * which is applicable for this class.\n     * @return\n     */\n    private static Map<String, List<MethodNode>> getDGMMethods() {\n        Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();\n        List<Class> classes = new LinkedList<Class>();\n        Collections.addAll(classes, DefaultGroovyMethods.DGM_LIKE_CLASSES);\n        Collections.addAll(classes, DefaultGroovyMethods.additionals);\n        classes.add(ObjectArrayStaticTypesHelper.class);\n\t\tfor (Class dgmLikeClass : classes) {\n\t\t\tClassNode cn = ClassHelper.makeWithoutCaching(dgmLikeClass, true);\n\t\t\tfor (MethodNode metaMethod : cn.getMethods()) {\n\t\t\t\tParameter[] types = metaMethod.getParameters();\n\t\t\t\tif (metaMethod.isStatic() && metaMethod.isPublic() && types.length > 0) {\n\t\t\t\t\tParameter[] parameters = new Parameter[types.length - 1];\n\t\t\t\t\tSystem.arraycopy(types, 1, parameters, 0, parameters.length);\n\t\t\t\t\tMethodNode node = new ExtensionMethodNode(\n                            metaMethod,\n\t\t\t\t\t\t\tmetaMethod.getName(),\n\t\t\t\t\t\t\tmetaMethod.getModifiers(),\n\t\t\t\t\t\t\tmetaMethod.getReturnType(),\n\t\t\t\t\t\t\tparameters,\n\t\t\t\t\t\t\tClassNode.EMPTY_ARRAY, null);\n\t\t\t\t\tnode.setGenericsTypes(metaMethod.getGenericsTypes());\n\t\t\t\t\tClassNode declaringClass = types[0].getType();\n\t\t\t\t\tString declaringClassName = declaringClass.getName();\n\t\t\t\t\tnode.setDeclaringClass(declaringClass);\n\n\t\t\t\t\tList<MethodNode> nodes = methods.get(declaringClassName);\n\t\t\t\t\tif (nodes == null) {\n\t\t\t\t\t\tnodes = new LinkedList<MethodNode>();\n\t\t\t\t\t\tmethods.put(declaringClassName, nodes);\n\t\t\t\t\t}\n\t\t\t\t\tnodes.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return methods;\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {\n        List<MethodNode> fromDGM = VIRTUAL_DGM_METHODS.get(clazz.getName());\n        if (fromDGM != null) {\n            for (MethodNode node : fromDGM) {\n                if (node.getName().equals(name)) accumulator.add(node);\n            }\n        }\n        for (ClassNode node : clazz.getInterfaces()) {\n            findDGMMethodsForClassNode(node, name, accumulator);\n        }\n        if (clazz.getSuperClass() != null) {\n            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);\n        } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {\n            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);\n        }\n    }","id":943,"modified_method":"static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {\n        List<MethodNode> fromDGM = VIRTUAL_DGM_METHODS.get(clazz.getName());\n        if (fromDGM != null) {\n            for (MethodNode node : fromDGM) {\n                if (node.getName().equals(name)) accumulator.add(node);\n            }\n        }\n        for (ClassNode node : clazz.getInterfaces()) {\n            findDGMMethodsForClassNode(node, name, accumulator);\n        }\n        if (clazz.isArray()) {\n            ClassNode componentClass = clazz.getComponentType();\n            if (!componentClass.equals(OBJECT_TYPE)) {\n                if (componentClass.isInterface()) {\n                    findDGMMethodsForClassNode(OBJECT_TYPE.makeArray(), name, accumulator);\n                } else {\n                    findDGMMethodsForClassNode(componentClass.getSuperClass().makeArray(), name, accumulator);\n                }\n            }\n        }\n        if (clazz.getSuperClass() != null) {\n            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);\n        } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {\n            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) return 1;\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","id":944,"modified_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)||receiver == UNKNOWN_PARAMETER_TYPE) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) return 1;\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (expr.getRightExpression() instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) expr.getRightExpression()).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            if (ClassHelper.STRING_TYPE.equals(left)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(left);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (DIVIDE==op || DIVIDE_EQUAL==op) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                return Double_TYPE;\n            } else if (BigDecimal_TYPE.equals(leftRedirect)||BigDecimal_TYPE.equals(rightRedirect)) {\n                return BigDecimal_TYPE;\n            }\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n\n        MethodNode method = findMethodOrFail(expr, leftRedirect, operationName, rightRedirect);\n        if (method != null) {\n            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, Collections.singletonList(method), expr );\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, new ArgumentListExpression(expr.getRightExpression()));\n        }\n        //TODO: other cases\n        return null;\n    }","id":945,"modified_method":"private ClassNode getResultType(ClassNode left, int op, ClassNode right, BinaryExpression expr) {\n        ClassNode leftRedirect = left.redirect();\n        ClassNode rightRedirect = right.redirect();\n\n        Expression leftExpression = expr.getLeftExpression();\n        if (op == ASSIGN) {\n            if (leftRedirect.isArray() && !rightRedirect.isArray()) return leftRedirect;\n            if (leftRedirect.implementsInterface(Collection_TYPE) && rightRedirect.implementsInterface(Collection_TYPE)) {\n                // because of type inferrence, we must perform an additional check if the right expression\n                // is an empty list expression ([]). In that case and only in that case, the inferred type\n                // will be wrong, so we will prefer the left type\n                if (expr.getRightExpression() instanceof ListExpression) {\n                    List<Expression> list = ((ListExpression) expr.getRightExpression()).getExpressions();\n                    if (list.isEmpty()) return left;\n                }\n                return right;\n            }\n            if (rightRedirect.implementsInterface(Collection_TYPE) && rightRedirect.isDerivedFrom(leftRedirect)) {\n                // ex : def foos = ['a','b','c']\n                return right;\n            }\n            if (leftExpression instanceof VariableExpression) {\n                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();\n                // as anything can be assigned to a String, Class or boolean, return the left type instead\n                if (STRING_TYPE.equals(initialType)\n                        || CLASS_Type.equals(initialType)\n                        || Boolean_TYPE.equals(initialType)) {\n                    return initialType;\n                }\n            }\n            return right;\n        } else if (isBoolIntrinsicOp(op)) {\n            return boolean_TYPE;\n        } else if (isArrayOp(op)) {\n            if (ClassHelper.STRING_TYPE.equals(left)) {\n                // special case here\n                return ClassHelper.STRING_TYPE;\n            }\n            return inferComponentType(left);\n        } else if (op == FIND_REGEX) {\n            // this case always succeeds the result is a Matcher\n            return Matcher_TYPE;\n        }\n        // the left operand is determining the result of the operation\n        // for primitives and their wrapper we use a fixed table here\n        else if (isNumberType(leftRedirect) && isNumberType(rightRedirect)) {\n            if (isOperationInGroup(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return long_TYPE;\n                if (isFloat(leftRedirect) && isFloat(rightRedirect)) return float_TYPE;\n                if (isDouble(leftRedirect) && isDouble(rightRedirect)) return double_TYPE;\n            } else if (isPowerOperator(op)) {\n                return Number_TYPE;\n            } else if (isBitOperator(op)) {\n                if (isIntCategory(leftRedirect) && isIntCategory(rightRedirect)) return int_TYPE;\n                if (isLongCategory(leftRedirect) && isLongCategory(rightRedirect)) return Long_TYPE;\n                if (isBigIntCategory(leftRedirect) && isBigIntCategory(rightRedirect)) return BigInteger_TYPE;\n            } else if (isCompareToBoolean(op) || op==COMPARE_EQUAL) {\n                return boolean_TYPE;\n            }\n        }\n\n\n        // try to find a method for the operation\n        String operationName = getOperationName(op);\n        if (isShiftOperation(operationName) && isNumberCategory(leftRedirect) && (isIntCategory(rightRedirect) || isLongCategory(rightRedirect))) {\n            return leftRedirect;\n        }\n\n        // Divisions may produce different results depending on operand types\n        if (DIVIDE==op || DIVIDE_EQUAL==op) {\n            if (isFloatingCategory(leftRedirect) || isFloatingCategory(rightRedirect)) {\n                return Double_TYPE;\n            } else if (BigDecimal_TYPE.equals(leftRedirect)||BigDecimal_TYPE.equals(rightRedirect)) {\n                return BigDecimal_TYPE;\n            }\n        } else if (isOperationInGroup(op)) {\n            if (isNumberCategory(getWrapper(leftRedirect)) && isNumberCategory(getWrapper(rightRedirect))) {\n                return getGroupOperationResultType(leftRedirect, rightRedirect);\n            }\n        }\n\n        MethodNode method = findMethodOrFail(expr, left, operationName, right);\n        if (method != null) {\n            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, method, expr );\n            if (isAssignment(op)) return left;\n            if (isCompareToBoolean(op)) return boolean_TYPE;\n            if (op == COMPARE_TO) return int_TYPE;\n            return inferReturnTypeGenerics(left, method, new ArgumentListExpression(expr.getRightExpression()));\n        }\n        //TODO: other cases\n        return null;\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, List<MethodNode> candidateMethods, Expression location) {\n        if (!receiver.isUsingGenerics()) return;\n        int failure=0;\n        GenericsType[] methodGenericTypes = null;\n        for (MethodNode method : candidateMethods) {\n            ClassNode methodNodeReceiver = method.getDeclaringClass();\n            if (!implementsInterfaceOrIsSubclassOf(receiver, methodNodeReceiver) || !methodNodeReceiver.isUsingGenerics()) continue;\n            // both candidate method and receiver have generic information so a check is possible\n            Parameter[] parameters = method.getParameters();\n            int argNum = 0;\n            for (Parameter parameter : parameters) {\n                ClassNode type = parameter.getType();\n                if (type.isUsingGenerics()) {\n                    methodGenericTypes =\n                            GenericsUtils.alignGenericTypes(\n                                    receiver.redirect().getGenericsTypes(),\n                                    receiver.getGenericsTypes(),\n                                    type.getGenericsTypes());\n                    if (methodGenericTypes.length==1) {\n                        ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                        ClassNode actualType = getWrapper(arguments[argNum]);\n                        if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                            failure++;\n                        }\n                    } else {\n                        // not sure this is possible !\n                    }\n                } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {\n                    ClassNode componentType = type.getComponentType();\n                    methodGenericTypes =\n                            GenericsUtils.alignGenericTypes(\n                                    receiver.redirect().getGenericsTypes(),\n                                    receiver.getGenericsTypes(),\n                                    componentType.getGenericsTypes());\n                    if (methodGenericTypes.length==1) {\n                        ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                        ClassNode actualType = getWrapper(arguments[argNum].getComponentType());\n                        if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                            failure++;\n                            // for proper error message\n                            GenericsType baseGT = methodGenericTypes[0];\n                            methodGenericTypes[0] = new GenericsType(baseGT.getType(), baseGT.getUpperBounds(), baseGT.getLowerBound());\n                            methodGenericTypes[0].setType(methodGenericTypes[0].getType().makeArray());\n                        }\n                    } else {\n                        // not sure this is possible !\n                    }\n                }\n                argNum++;\n            }\n        }\n        if (failure==candidateMethods.size()) {\n            if (failure==1) {\n                MethodNode method = candidateMethods.get(0);\n                ClassNode[] parameterTypes = new ClassNode[methodGenericTypes.length];\n                for (int i = 0; i < methodGenericTypes.length; i++) {\n                    parameterTypes[i] = methodGenericTypes[i].getType();\n                }\n                addStaticTypeError(\"Cannot call \" + receiver.getName()+\"#\"+\n                        toMethodParametersString(method.getName(), parameterTypes) +\n                        \" with arguments \" + Arrays.asList(arguments), location);\n            } else {\n                addStaticTypeError(\"No matching method found for arguments \"+Arrays.asList(arguments), location);\n            }\n        }\n    }","id":946,"modified_method":"private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {\n        if (!isUsingGenericsOrIsArrayUsingGenerics(receiver)) return;\n        boolean failure=false;\n        GenericsType[] methodGenericTypes = null;\n        ClassNode methodNodeReceiver = candidateMethod.getDeclaringClass();\n        if (!implementsInterfaceOrIsSubclassOf(receiver, methodNodeReceiver) || !isUsingGenericsOrIsArrayUsingGenerics(methodNodeReceiver))\n            return;\n        // both candidate method and receiver have generic information so a check is possible\n        Parameter[] parameters = candidateMethod.getParameters();\n        int argNum = 0;\n        for (Parameter parameter : parameters) {\n            ClassNode type = parameter.getType();\n            if (type.isUsingGenerics()) {\n                methodGenericTypes =\n                        GenericsUtils.alignGenericTypes(\n                                receiver.redirect().getGenericsTypes(),\n                                receiver.getGenericsTypes(),\n                                type.getGenericsTypes());\n                if (methodGenericTypes.length == 1) {\n                    ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                    ClassNode actualType = getWrapper(arguments[argNum]);\n                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                        failure = true;\n                    }\n                } else {\n                    // not sure this is possible !\n                }\n            } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {\n                ClassNode componentType = type.getComponentType();\n                methodGenericTypes =\n                        GenericsUtils.alignGenericTypes(\n                                receiver.redirect().getGenericsTypes(),\n                                receiver.getGenericsTypes(),\n                                componentType.getGenericsTypes());\n                if (methodGenericTypes.length == 1) {\n                    ClassNode nodeType = getWrapper(methodGenericTypes[0].getType());\n                    ClassNode actualType = getWrapper(arguments[argNum].getComponentType());\n                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {\n                        failure = true;\n                        // for proper error message\n                        GenericsType baseGT = methodGenericTypes[0];\n                        methodGenericTypes[0] = new GenericsType(baseGT.getType(), baseGT.getUpperBounds(), baseGT.getLowerBound());\n                        methodGenericTypes[0].setType(methodGenericTypes[0].getType().makeArray());\n                    }\n                } else {\n                    // not sure this is possible !\n                }\n            }\n            argNum++;\n        }\n        if (failure) {\n            ClassNode[] parameterTypes = new ClassNode[methodGenericTypes.length];\n            for (int i = 0; i < methodGenericTypes.length; i++) {\n                parameterTypes[i] = methodGenericTypes[i].getType();\n            }\n            addStaticTypeError(\"Cannot call \" + receiver.getName() + \"#\" +\n                    toMethodParametersString(candidateMethod.getName(), parameterTypes) +\n                    \" with arguments \" + Arrays.asList(arguments), location);\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        if (rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null) {\n            if (!isPrimitiveType(lType)) rType = lType; // primitive types should be ignored as they will result in another failure\n        }\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            resultType = lType;\n        }\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            if (rightExpression instanceof ConstructorCallExpression) {\n                inferDiamondType((ConstructorCallExpression) rightExpression, lType);\n            }\n\n            ClassNode originType = getOriginalDeclarationType(leftExpression);\n            typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);\n            // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling\n            // and we must update the result type\n            if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType),getWrapper(originType))) {\n                resultType = originType;\n            }\n\n            // if we are in an if/else branch, keep track of assignment\n            if (ifElseForWhileAssignmentTracker !=null && leftExpression instanceof VariableExpression) {\n                Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();\n                if (accessedVariable instanceof VariableExpression) {\n                    VariableExpression var = (VariableExpression) accessedVariable;\n                    List<ClassNode> types = ifElseForWhileAssignmentTracker.get(var);\n                    if (types == null) {\n                        types = new LinkedList<ClassNode>();\n                        ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n                        if (type!=null) types.add(type);\n                        ifElseForWhileAssignmentTracker.put(var, types);\n                    }\n                    types.add(resultType);\n                }\n            }\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","id":947,"modified_method":"@Override\n    public void visitBinaryExpression(BinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final Expression leftExpression = expression.getLeftExpression();\n        ClassNode lType = getType(leftExpression);\n        final Expression rightExpression = expression.getRightExpression();\n        ClassNode rType = getType(rightExpression);\n        if (rightExpression instanceof ConstantExpression && ((ConstantExpression) rightExpression).getValue()==null) {\n            if (!isPrimitiveType(lType)) rType = UNKNOWN_PARAMETER_TYPE; // primitive types should be ignored as they will result in another failure\n        }\n        int op = expression.getOperation().getType();\n        ClassNode resultType = getResultType(lType, op, rType, expression);\n        if (resultType == null) {\n            resultType = lType;\n        }\n        boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;\n        if (!isEmptyDeclaration) storeType(expression, resultType);\n        if (!isEmptyDeclaration && isAssignment(op)) {\n            if (rightExpression instanceof ConstructorCallExpression) {\n                inferDiamondType((ConstructorCallExpression) rightExpression, lType);\n            }\n\n            ClassNode originType = getOriginalDeclarationType(leftExpression);\n            typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);\n            // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling\n            // and we must update the result type\n            if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType),getWrapper(originType))) {\n                resultType = originType;\n            }\n\n            // if we are in an if/else branch, keep track of assignment\n            if (ifElseForWhileAssignmentTracker !=null && leftExpression instanceof VariableExpression) {\n                Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();\n                if (accessedVariable instanceof VariableExpression) {\n                    VariableExpression var = (VariableExpression) accessedVariable;\n                    List<ClassNode> types = ifElseForWhileAssignmentTracker.get(var);\n                    if (types == null) {\n                        types = new LinkedList<ClassNode>();\n                        ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n                        if (type!=null) types.add(type);\n                        ifElseForWhileAssignmentTracker.put(var, types);\n                    }\n                    types.add(resultType);\n                }\n            }\n            storeType(leftExpression, resultType);\n\n            // if right expression is a ClosureExpression, store parameter type information\n            if (leftExpression instanceof VariableExpression && rightExpression instanceof ClosureExpression) {\n                Parameter[] parameters = ((ClosureExpression) rightExpression).getParameters();\n                leftExpression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, parameters);\n            }\n\n\n        } else if (op == KEYWORD_INSTANCEOF) {\n            pushInstanceOfTypeInfo(leftExpression, rightExpression);\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"private void storeType(Expression exp, ClassNode cn) {\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);\n                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {\n                    // a type inference has been made on a variable which type was defined in an instanceof block\n                    // we erase available information with the new type\n                    temporaryTypesForExpression.clear();\n                }\n            }\n        }\n    }","id":948,"modified_method":"private void storeType(Expression exp, ClassNode cn) {\n        if (cn==UNKNOWN_PARAMETER_TYPE) {\n            // this can happen for example when \"null\" is used in an assignment or a method parameter.\n            // In that case, instead of storing the virtual type, we must \"reset\" type information\n            // by determining the declaration type of the expression\n            storeType(exp, getOriginalDeclarationType(exp));\n            return;\n        }\n        ClassNode oldValue = (ClassNode) exp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, cn);\n        if (oldValue!=null) {\n            // this may happen when a variable declaration type is wider than the subsequent assignment values\n            // for example :\n            // def o = 1 // first, an int\n            // o = 'String' // then a string\n            // o = new Object() // and eventually an object !\n            // in that case, the INFERRED_TYPE corresponds to the current inferred type, while\n            // DECLARATION_INFERRED_TYPE is the type which should be used for the initial type declaration\n            ClassNode oldDIT = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n            if (oldDIT!=null) {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldDIT, cn));\n            } else {\n                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, lowestUpperBound(oldValue, cn));\n            }\n        }\n        if (exp instanceof VariableExpression) {\n\t\t\tVariableExpression var = (VariableExpression) exp;\n\t\t\tfinal Variable accessedVariable = var.getAccessedVariable();\n            if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {\n                storeType((Expression) accessedVariable, cn);\n            }\n\t\t\tif (var.isClosureSharedVariable()) {\n\t\t\t\tList<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);\n\t\t\t\tif (assignedTypes==null) {\n\t\t\t\t\tassignedTypes = new LinkedList<ClassNode>();\n\t\t\t\t\tclosureSharedVariablesAssignmentTypes.put(var, assignedTypes);\n\t\t\t\t}\n\t\t\t\tassignedTypes.add(cn);\n\t\t\t}\n            if (!temporaryIfBranchTypeInformation.empty()) {\n                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);\n                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {\n                    // a type inference has been made on a variable which type was defined in an instanceof block\n                    // we erase available information with the new type\n                    temporaryTypesForExpression.clear();\n                }\n            }\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":949,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":950,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"public ThreadLocalProxy getContextSetterProxy(Method m) {\n        return setterProxyMap == null ? null : setterProxyMap.get(m);\n    }","id":951,"modified_method":"public ThreadLocalProxy getContextSetterProxy(Method m) {\n        return getProxy(setterProxyMap, m);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"private static void clearProxies(Map<?, ThreadLocalProxy> tlps) {\n        if (tlps == null) {\n            return;\n        }\n        for (ThreadLocalProxy tlp : tlps.values()) {\n            if (tlp != null) {\n                tlp.remove();\n            }\n        }\n    }","id":952,"modified_method":"private <T> void clearProxies(Map<Class<?>, Map<T, ThreadLocalProxy>> tlps) {\n        Map<T, ThreadLocalProxy> proxies = tlps == null ? null : tlps.get(getServiceClass());\n        if (proxies == null) {\n            return;\n        }\n        for (ThreadLocalProxy tlp : proxies.values()) {\n            if (tlp != null) {\n                tlp.remove();\n            }\n        }\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public Map<Class<?>, Method> getContextMethods() {\n        return contextMethods == null ? Collections.EMPTY_MAP \n                                      : Collections.unmodifiableMap(contextMethods);\n    }","id":953,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public Map<Class<?>, Method> getContextMethods() {\n        Map<Class<?>, Method> methods = contextMethods == null ? null : contextMethods.get(getServiceClass());\n        return methods == null ? Collections.EMPTY_MAP \n                                      : Collections.unmodifiableMap(methods);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"private void addContextMethod(Class<?> contextClass, Method m) {\n        if (contextMethods == null) {\n            contextMethods = new HashMap<Class<?>, Method>();\n        }\n        contextMethods.put(contextClass, m);\n        if (setterProxyMap == null) {\n            setterProxyMap = new HashMap<Method, ThreadLocalProxy>();\n        }\n        setterProxyMap.put(m, \n             InjectionUtils.createThreadLocalProxy(m.getParameterTypes()[0]));\n    }","id":954,"modified_method":"private void addContextMethod(Class<?> contextClass, Method m) {\n        if (contextMethods == null) {\n            contextMethods = new HashMap<Class<?>, Map<Class<?>, Method>>();\n        }\n        addToMap(contextMethods, contextClass, m);\n        if (setterProxyMap == null) {\n            setterProxyMap = new HashMap<Class<?>, Map<Method, ThreadLocalProxy>>();\n        }\n        addToMap(setterProxyMap, m, \n                 InjectionUtils.createThreadLocalProxy(m.getParameterTypes()[0]));\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"public ThreadLocalProxy getResourceFieldProxy(Field f) {\n        return resourceProxyMap == null ? null\n               : resourceProxyMap.get(f);\n    }","id":955,"modified_method":"public ThreadLocalProxy getResourceFieldProxy(Field f) {\n        return getProxy(resourceProxyMap, f);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"private void initContextFields() {\n        if (resourceClass == null || !root) {\n            return;\n        }\n        \n        \n        for (Field f : getServiceClass().getDeclaredFields()) {\n            for (Annotation a : f.getAnnotations()) {\n                if (a.annotationType() == Context.class) {\n                    if (contextFields == null) {\n                        contextFields = new ArrayList<Field>();\n                    }\n                    contextFields.add(f);\n                    if (fieldProxyMap == null) {\n                        fieldProxyMap = new HashMap<Field, ThreadLocalProxy>();\n                    }\n                    fieldProxyMap.put(f, InjectionUtils.createThreadLocalProxy(f.getType()));\n                } else if (a.annotationType() == Resource.class \n                           && AnnotationUtils.isContextClass(f.getType())) {\n                    if (resourceFields == null) {\n                        resourceFields = new ArrayList<Field>();\n                    }\n                    resourceFields.add(f);\n                    if (resourceProxyMap == null) {\n                        resourceProxyMap = new HashMap<Field, ThreadLocalProxy>();\n                    }\n                    resourceProxyMap.put(f, InjectionUtils.createThreadLocalProxy(f.getType()));\n                }\n            }\n        }\n    }","id":956,"modified_method":"private void initContextFields() {\n        if (resourceClass == null || !root) {\n            return;\n        }\n        \n        \n        for (Field f : getServiceClass().getDeclaredFields()) {\n            for (Annotation a : f.getAnnotations()) {\n                if (a.annotationType() == Context.class) {\n                    if (contextFields == null) {\n                        contextFields = new HashMap<Class<?>, List<Field>>();\n                    }\n                    addContextField(contextFields, f);\n                    if (fieldProxyMap == null) {\n                        fieldProxyMap = new HashMap<Class<?>, Map<Field, ThreadLocalProxy>>();\n                    }\n                    addToMap(fieldProxyMap, f, InjectionUtils.createThreadLocalProxy(f.getType()));\n                } else if (a.annotationType() == Resource.class \n                           && AnnotationUtils.isContextClass(f.getType())) {\n                    if (resourceFields == null) {\n                        resourceFields = new HashMap<Class<?>, List<Field>>();\n                    }\n                    addContextField(resourceFields, f);\n                    if (resourceProxyMap == null) {\n                        resourceProxyMap = new HashMap<Class<?>, Map<Field, ThreadLocalProxy>>();\n                    }\n                    addToMap(resourceProxyMap, f, InjectionUtils.createThreadLocalProxy(f.getType()));\n                }\n            }\n        }\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"public ThreadLocalProxy getContextFieldProxy(Field f) {\n        return fieldProxyMap == null ? null\n               : fieldProxyMap.get(f);\n    }","id":957,"modified_method":"public ThreadLocalProxy getContextFieldProxy(Field f) {\n        return getProxy(fieldProxyMap, f);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"private static List<Field> getList(List<Field> fields) {\n        List<Field> ret;\n        if (fields != null) {\n            ret = Collections.unmodifiableList(fields);\n        } else {\n            ret = Collections.emptyList();\n        }\n        return ret;\n    }","id":958,"modified_method":"private List<Field> getList(Map<Class<?>, List<Field>> fields) {\n        List<Field> ret = fields == null ? null : fields.get(getServiceClass());\n        if (ret != null) {\n            ret = Collections.unmodifiableList(ret);\n        } else {\n            ret = Collections.emptyList();\n        }\n        return ret;\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"@GET\n    @Path(\"/books/feed\")\n    @Produces({\"application/json\", \"application/atom+xml\" })\n    public Feed getBooksAsFeed(@Context UriInfo uParam) {\n        \n        MediaType mt = headers.getMediaType();\n        if (!mt.equals(MediaType.valueOf(MediaType.MEDIA_TYPE_WILDCARD))\n            && !mt.equals(MediaType.APPLICATION_JSON_TYPE) \n            && !mt.equals(MediaType.APPLICATION_ATOM_XML_TYPE)) {\n            throw new WebApplicationException();\n        }\n        \n        Factory factory = Abdera.getNewFactory();\n        Feed f = factory.newFeed();\n        f.setBaseUri(uParam.getAbsolutePath().toString());\n        f.setTitle(\"Collection of Books\");\n        f.setId(\"http://www.books.com\");\n        f.addAuthor(\"BookStore Management Company\");\n        try {\n            for (Book b : books.values()) {\n                \n                Entry e = AtomUtils.createBookEntry(b);\n                \n                f.addEntry(e);\n            }\n        } catch (Exception ex) {\n            // ignore\n        }\n        return f;\n    }","id":959,"modified_method":"@GET\n    @Path(\"/books/feed\")\n    @Produces({\"application/json\", \"application/atom+xml\" })\n    public Feed getBooksAsFeed(@Context UriInfo uParam) {\n        \n        MediaType mt = headers.getMediaType();\n        if (!mt.equals(MediaType.valueOf(MediaType.MEDIA_TYPE_WILDCARD))\n            && !mt.equals(MediaType.APPLICATION_JSON_TYPE) \n            && !mt.equals(MediaType.APPLICATION_ATOM_XML_TYPE)) {\n            throw new WebApplicationException();\n        }\n        \n        return doGetBookAsFeed(uParam);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testGetResources() {\n        ClassResourceInfo c = new ClassResourceInfo(TestClass.class);\n        List<Field> fields = c.getResourceFields();\n        assertEquals(\"Only root classes should check these fields\", 0, fields.size());\n        c = new ClassResourceInfo(TestClass.class, true);\n        fields = c.getResourceFields();\n        \n        Set<Class<?>> clses = new HashSet<Class<?>>(); \n        for (Field f : fields) {\n            clses.add(f.getType());\n        }\n        assertEquals(\"3 resources fields available\", 3, fields.size());\n        assertTrue(\"Wrong fields selected\",\n                   clses.contains(HttpServletRequest.class)\n                   && clses.contains(HttpServletResponse.class)\n                   && clses.contains(ServletContext.class)); \n    }","id":960,"modified_method":"@Test\n    public void testGetResources() {\n        ClassResourceInfo c = new ClassResourceInfo(TestClass3.class);\n        List<Field> fields = c.getResourceFields();\n        assertEquals(\"Only root classes should check these fields\", 0, fields.size());\n        c = new ClassResourceInfo(TestClass3.class, true);\n        fields = c.getResourceFields();\n        \n        Set<Class<?>> clses = new HashSet<Class<?>>(); \n        for (Field f : fields) {\n            clses.add(f.getType());\n        }\n        assertEquals(\"3 resources fields available\", 3, fields.size());\n        assertTrue(\"Wrong fields selected\",\n                   clses.contains(HttpServletRequest.class)\n                   && clses.contains(HttpServletResponse.class)\n                   && clses.contains(ServletContext.class)); \n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"public Object getServiceObject(Exchange exchange, List<Object> resources) {\n        Object serviceObject = null;\n        \n        OperationResourceInfo ori = exchange.get(OperationResourceInfo.class);\n        ClassResourceInfo cri = ori.getClassResourceInfo();\n        \n        if (resources != null) {\n            Class c  = cri.getResourceClass();\n            for (Object resourceObject : resources) {\n                if (c.isInstance(resourceObject)) {\n                    serviceObject = resourceObject;\n                }\n            }\n        }\n        \n        if (serviceObject == null) {\n            serviceObject = cri.getResourceProvider().getInstance();\n        }\n        \n        return serviceObject;\n    }","id":961,"modified_method":"public Object getServiceObject(Exchange exchange, List<Object> resources) {\n        Object serviceObject = null;\n        \n        OperationResourceInfo ori = exchange.get(OperationResourceInfo.class);\n        ClassResourceInfo cri = ori.getClassResourceInfo();\n        \n        if (resources != null) {\n            Class c  = cri.getResourceClass();\n            for (Object resourceObject : resources) {\n                if (c.isInstance(resourceObject)) {\n                    serviceObject = resourceObject;\n                    break;\n                }\n            }\n        }\n        \n        if (serviceObject == null) {\n            serviceObject = cri.getResourceProvider().getInstance();\n        }\n        \n        return serviceObject;\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public boolean commit() throws LoginException {\n        if (externalUser == null) {\n            return false;\n        }\n        Set<? extends Principal> principals = getPrincipals(externalUser.getId());\n        if (!principals.isEmpty()) {\n            if (!subject.isReadOnly()) {\n                subject.getPrincipals().addAll(principals);\n                subject.getPublicCredentials().add(credentials);\n                setAuthInfo(createAuthInfo(externalUser.getId(), principals), subject);\n            } else {\n                log.debug(\"Could not add information to read only subject {}\", subject);\n            }\n            return true;\n        }\n        return false;\n    }","id":962,"modified_method":"@Override\n    public boolean commit() throws LoginException {\n        if (externalUser == null) {\n            return false;\n        }\n        Set<? extends Principal> principals = getPrincipals(externalUser.getId());\n        if (!principals.isEmpty()) {\n            if (!subject.isReadOnly()) {\n                subject.getPrincipals().addAll(principals);\n                if (credentials != null) {\n                    subject.getPublicCredentials().add(credentials);\n                }\n                setAuthInfo(createAuthInfo(externalUser.getId(), principals), subject);\n            } else {\n                log.debug(\"Could not add information to read only subject {}\", subject);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"677401ea1d92a55c1f7b2105603b33995c4a4cab","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean login() throws LoginException {\n        if (idp == null || syncHandler == null) {\n            return false;\n        }\n\n        credentials = getCredentials();\n        if (credentials == null) {\n            log.debug(\"No credentials found for external login module. ignoring.\");\n            return false;\n        }\n\n        // remember userID as we need this so often\n        final String userId = credentials instanceof SimpleCredentials ? ((SimpleCredentials) credentials).getUserID() : null;\n        try {\n            SyncedIdentity sId = null;\n            if (userId != null) {\n                sId = syncHandler.findIdentity(getUserManager(), userId);\n                // if there exists an authorizable with the given userid but is not an external one or if it belongs to\n                // another IDP, we just ignore it.\n                if (sId != null) {\n                    if (sId.getExternalIdRef() == null) {\n                        log.debug(\"ignoring local user: {}\", sId.getId());\n                        return false;\n                    }\n                    if (!sId.getExternalIdRef().getProviderName().equals(idp.getName())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"ignoring foreign identity: {} (idp={})\", sId.getExternalIdRef().getString(), idp.getName());\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            externalUser = idp.authenticate(credentials);\n            if (externalUser != null) {\n                log.debug(\"IDP {} returned valid user {}\", idp.getName(), externalUser);\n\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_CREDENTIALS, credentials);\n\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_LOGIN_NAME, externalUser.getId());\n\n                syncUser(externalUser);\n\n                return true;\n            } else {\n                if (log.isDebugEnabled()) {\n                    if (userId != null) {\n                        log.debug(\"IDP {} returned null for simple creds of {}\", idp.getName(), userId);\n                    } else {\n                        log.debug(\"IDP {} returned null for {}\", idp.getName(), credentials);\n                    }\n                }\n\n                if (sId != null) {\n                    // invalidate the user if it exists as synced variant\n                    log.debug(\"local user exists for '{}'. re-validating.\", sId.getId());\n                    validateUser(sId.getId());\n                }\n                return false;\n            }\n        } catch (ExternalIdentityException e) {\n            log.error(\"Error while authenticating '{}' with {}\",\n                    userId == null ? credentials : userId, idp.getName(), e);\n            return false;\n        } catch (LoginException e) {\n            log.debug(\"IDP {} throws login exception for '{}': {}\",\n                    idp.getName(), userId == null ? credentials : userId, e.getMessage());\n            throw e;\n        } catch (Exception e) {\n            log.debug(\"SyncHandler {} throws sync exception for '{}'\",\n                    syncHandler.getName(), userId == null ? credentials : userId, e);\n            LoginException le = new LoginException(\"Error while syncing user.\");\n            le.initCause(e);\n            throw le;\n        }\n    }","id":963,"modified_method":"@Override\n    public boolean login() throws LoginException {\n        if (idp == null || syncHandler == null) {\n            return false;\n        }\n        credentials = getCredentials();\n\n        // check if we have a pre authenticated login from a previous login module\n        final String userId;\n        final PreAuthenticatedLogin preAuthLogin = getSharedPreAuthLogin();\n        if (preAuthLogin != null) {\n            userId = preAuthLogin.getUserId();\n        } else {\n            userId = credentials instanceof SimpleCredentials ? ((SimpleCredentials) credentials).getUserID() : null;\n        }\n        if (userId == null && credentials == null) {\n            log.debug(\"No credentials found for external login module. ignoring.\");\n            return false;\n        }\n\n        try {\n            SyncedIdentity sId = null;\n            if (userId != null) {\n                sId = syncHandler.findIdentity(getUserManager(), userId);\n                // if there exists an authorizable with the given userid but is not an external one or if it belongs to\n                // another IDP, we just ignore it.\n                if (sId != null) {\n                    if (sId.getExternalIdRef() == null) {\n                        log.debug(\"ignoring local user: {}\", sId.getId());\n                        return false;\n                    }\n                    if (!sId.getExternalIdRef().getProviderName().equals(idp.getName())) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"ignoring foreign identity: {} (idp={})\", sId.getExternalIdRef().getString(), idp.getName());\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            if (preAuthLogin != null) {\n                externalUser = idp.getUser(preAuthLogin.getUserId());\n            } else {\n                externalUser = idp.authenticate(credentials);\n            }\n\n            if (externalUser != null) {\n                log.debug(\"IDP {} returned valid user {}\", idp.getName(), externalUser);\n\n                if (credentials != null) {\n                    //noinspection unchecked\n                    sharedState.put(SHARED_KEY_CREDENTIALS, credentials);\n                }\n\n                //noinspection unchecked\n                sharedState.put(SHARED_KEY_LOGIN_NAME, externalUser.getId());\n\n                syncUser(externalUser);\n\n                return true;\n            } else {\n                if (log.isDebugEnabled()) {\n                    if (userId != null) {\n                        log.debug(\"IDP {} returned null for simple creds of {}\", idp.getName(), userId);\n                    } else {\n                        log.debug(\"IDP {} returned null for {}\", idp.getName(), credentials);\n                    }\n                }\n\n                if (sId != null) {\n                    // invalidate the user if it exists as synced variant\n                    log.debug(\"local user exists for '{}'. re-validating.\", sId.getId());\n                    validateUser(sId.getId());\n                }\n                return false;\n            }\n        } catch (ExternalIdentityException e) {\n            log.error(\"Error while authenticating '{}' with {}\",\n                    userId == null ? credentials : userId, idp.getName(), e);\n            return false;\n        } catch (LoginException e) {\n            log.debug(\"IDP {} throws login exception for '{}': {}\",\n                    idp.getName(), userId == null ? credentials : userId, e.getMessage());\n            throw e;\n        } catch (Exception e) {\n            log.debug(\"SyncHandler {} throws sync exception for '{}'\",\n                    syncHandler.getName(), userId == null ? credentials : userId, e);\n            LoginException le = new LoginException(\"Error while syncing user.\");\n            le.initCause(e);\n            throw le;\n        }\n    }","commit_id":"677401ea1d92a55c1f7b2105603b33995c4a4cab","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean login() throws LoginException {\n        credentials = getCredentials();\n        userId = getUserId();\n\n        if (credentials == null || userId == null) {\n            log.debug(\"Could not extract userId/credentials\");\n            return false;\n        }\n\n        Authentication authentication = new UserAuthentication(userId, getUserManager());\n        boolean success = authentication.authenticate(credentials);\n        if (success) {\n            principals = getPrincipals(userId);\n\n            log.debug(\"Adding Credentials to shared state.\");\n            sharedState.put(SHARED_KEY_CREDENTIALS, credentials);\n\n            log.debug(\"Adding login name to shared state.\");\n            sharedState.put(SHARED_KEY_LOGIN_NAME, userId);\n        }\n        return success;\n    }","id":964,"modified_method":"@Override\n    public boolean login() throws LoginException {\n        final boolean success;\n        credentials = getCredentials();\n\n        // check if we have a pre authenticated login from a previous login module\n        PreAuthenticatedLogin preAuthLogin = getSharedPreAuthLogin();\n        if (preAuthLogin != null) {\n            userId = preAuthLogin.getUserId();\n            Authentication authentication = new UserAuthentication(userId, getUserManager());\n            success = authentication.authenticate(UserAuthentication.PRE_AUTHENTICATED);\n\n        } else {\n            userId = getUserId();\n            Authentication authentication = new UserAuthentication(userId, getUserManager());\n            success = authentication.authenticate(credentials);\n        }\n\n        if (success) {\n            principals = getPrincipals(userId);\n\n            log.debug(\"Adding Credentials to shared state.\");\n            //noinspection unchecked\n            sharedState.put(SHARED_KEY_CREDENTIALS, credentials);\n\n            log.debug(\"Adding login name to shared state.\");\n            //noinspection unchecked\n            sharedState.put(SHARED_KEY_LOGIN_NAME, userId);\n        }\n        return success;\n    }","commit_id":"677401ea1d92a55c1f7b2105603b33995c4a4cab","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean authenticate(Credentials credentials) throws LoginException {\n        if (userId == null || userManager == null) {\n            return false;\n        }\n\n        boolean success = false;\n        try {\n            Authorizable authorizable = userManager.getAuthorizable(userId);\n            if (authorizable == null) {\n                return false;\n            }\n\n            if (authorizable.isGroup()) {\n                throw new LoginException(\"Not a user \" + userId);\n            }\n\n            User user = (User) authorizable;\n            if (user.isDisabled()) {\n                throw new LoginException(\"User with ID \" + userId + \" has been disabled: \"+ user.getDisabledReason());\n            }\n\n            if (credentials instanceof SimpleCredentials) {\n                SimpleCredentials creds = (SimpleCredentials) credentials;\n                Credentials userCreds = user.getCredentials();\n                if (userId.equals(creds.getUserID()) && userCreds instanceof CredentialsImpl) {\n                    success = PasswordUtil.isSame(((CredentialsImpl) userCreds).getPasswordHash(), creds.getPassword());\n                }\n                checkSuccess(success, \"UserId/Password mismatch.\");\n            } else if (credentials instanceof ImpersonationCredentials) {\n                ImpersonationCredentials ipCreds = (ImpersonationCredentials) credentials;\n                AuthInfo info = ipCreds.getImpersonatorInfo();\n                success = equalUserId(ipCreds) && impersonate(info, user);\n                checkSuccess(success, \"Impersonation not allowed.\");\n            } else {\n                // guest login is allowed if an anonymous user exists in the content (see get user above)\n                success = (credentials instanceof GuestCredentials);\n            }\n        } catch (RepositoryException e) {\n            throw new LoginException(e.getMessage());\n        }\n        return success;\n    }","id":965,"modified_method":"@Override\n    public boolean authenticate(Credentials credentials) throws LoginException {\n        if (userId == null || userManager == null || credentials == null) {\n            return false;\n        }\n\n        boolean success = false;\n        try {\n            Authorizable authorizable = userManager.getAuthorizable(userId);\n            if (authorizable == null) {\n                return false;\n            }\n\n            if (authorizable.isGroup()) {\n                throw new LoginException(\"Not a user \" + userId);\n            }\n\n            User user = (User) authorizable;\n            if (user.isDisabled()) {\n                throw new LoginException(\"User with ID \" + userId + \" has been disabled: \"+ user.getDisabledReason());\n            }\n\n            if (credentials instanceof SimpleCredentials) {\n                SimpleCredentials creds = (SimpleCredentials) credentials;\n                Credentials userCreds = user.getCredentials();\n                if (userId.equals(creds.getUserID()) && userCreds instanceof CredentialsImpl) {\n                    success = PasswordUtil.isSame(((CredentialsImpl) userCreds).getPasswordHash(), creds.getPassword());\n                }\n                checkSuccess(success, \"UserId/Password mismatch.\");\n            } else if (credentials instanceof ImpersonationCredentials) {\n                ImpersonationCredentials ipCreds = (ImpersonationCredentials) credentials;\n                AuthInfo info = ipCreds.getImpersonatorInfo();\n                success = equalUserId(ipCreds) && impersonate(info, user);\n                checkSuccess(success, \"Impersonation not allowed.\");\n            } else {\n                // guest login is allowed if an anonymous user exists in the content (see get user above)\n                success = (credentials instanceof GuestCredentials) || credentials == PRE_AUTHENTICATED;\n            }\n        } catch (RepositoryException e) {\n            throw new LoginException(e.getMessage());\n        }\n        return success;\n    }","commit_id":"677401ea1d92a55c1f7b2105603b33995c4a4cab","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Authenticate the user making this request, based on the specified\n     * login configuration.  Return <code>true<\/code> if any specified\n     * constraint has been satisfied, or <code>false<\/code> if we have\n     * created a response challenge already.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // Have we already authenticated someone?\n        Principal principal = request.getUserPrincipal();\n        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n        if (principal != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Already authenticated '\" + principal.getName() + \"'\");\n            }\n            // Associate the session with any existing SSO session\n            if (ssoId != null) {\n                associate(ssoId, request.getSessionInternal(true));\n            }\n            return (true);\n        }\n\n        // Is there an SSO session against which we can try to reauthenticate?\n        if (ssoId != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"SSO Id \" + ssoId + \" set; attempting \" +\n                          \"reauthentication\");\n            }\n            /* Try to reauthenticate using data cached by SSO.  If this fails,\n               either the original SSO logon was of DIGEST or SSL (which\n               we can't reauthenticate ourselves because there is no\n               cached username and password), or the realm denied\n               the user's reauthentication for some reason.\n               In either case we have to prompt the user for a logon */\n            if (reauthenticateFromSSO(ssoId, request)) {\n                return true;\n            }\n        }\n\n        // Validate any credentials already included with this request\n        MessageBytes authorization =\n            request.getCoyoteRequest().getMimeHeaders()\n            .getValue(\"authorization\");\n\n        if (authorization != null) {\n            authorization.toBytes();\n            ByteChunk authorizationBC = authorization.getByteChunk();\n            BasicCredentials credentials = null;\n            try {\n                credentials = new BasicCredentials(authorizationBC);\n                String username = credentials.getUsername();\n                String password = credentials.getPassword();\n\n                principal = context.getRealm().authenticate(username, password);\n                if (principal != null) {\n                    register(request, response, principal,\n                        HttpServletRequest.BASIC_AUTH, username, password);\n                    return (true);\n                }\n            }\n            catch (IllegalArgumentException iae) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Invalid Authorization\" + iae.getMessage());\n                }\n            }\n        }\n\n        // the request could not be authenticated, so reissue the challenge\n        StringBuilder value = new StringBuilder(16);\n        value.append(\"Basic realm=\\\"\");\n        value.append(getRealmName(context));\n        value.append('\\\"');\n        response.setHeader(AUTH_HEADER_NAME, value.toString());\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return (false);\n\n    }","id":966,"modified_method":"/**\n     * Authenticate the user making this request, based on the specified\n     * login configuration.  Return <code>true<\/code> if any specified\n     * constraint has been satisfied, or <code>false<\/code> if we have\n     * created a response challenge already.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        if (checkForCachedAuthentication(request, true)) {\n            return true;\n        }\n\n        // Validate any credentials already included with this request\n        MessageBytes authorization =\n            request.getCoyoteRequest().getMimeHeaders()\n            .getValue(\"authorization\");\n\n        if (authorization != null) {\n            authorization.toBytes();\n            ByteChunk authorizationBC = authorization.getByteChunk();\n            BasicCredentials credentials = null;\n            try {\n                credentials = new BasicCredentials(authorizationBC);\n                String username = credentials.getUsername();\n                String password = credentials.getPassword();\n\n                Principal principal = context.getRealm().authenticate(username, password);\n                if (principal != null) {\n                    register(request, response, principal,\n                        HttpServletRequest.BASIC_AUTH, username, password);\n                    return (true);\n                }\n            }\n            catch (IllegalArgumentException iae) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Invalid Authorization\" + iae.getMessage());\n                }\n            }\n        }\n\n        // the request could not be authenticated, so reissue the challenge\n        StringBuilder value = new StringBuilder(16);\n        value.append(\"Basic realm=\\\"\");\n        value.append(getRealmName(context));\n        value.append('\\\"');\n        response.setHeader(AUTH_HEADER_NAME, value.toString());\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return (false);\n\n    }","commit_id":"af391ff5548b13ccebede4455b623ac2755928ad","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Authenticate the user making this request, based on the specified\n     * login configuration.  Return <code>true<\/code> if any specified\n     * constraint has been satisfied, or <code>false<\/code> if we have\n     * created a response challenge already.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // Have we already authenticated someone?\n        Principal principal = request.getUserPrincipal();\n        //String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n        if (principal != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Already authenticated '\" + principal.getName() + \"'\");\n            }\n            // Associate the session with any existing SSO session in order\n            // to get coordinated session invalidation at logout\n            String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n            if (ssoId != null) {\n                associate(ssoId, request.getSessionInternal(true));\n            }\n            return (true);\n        }\n\n        // NOTE: We don't try to reauthenticate using any existing SSO session,\n        // because that will only work if the original authentication was\n        // BASIC or FORM, which are less secure than the DIGEST auth-type\n        // specified for this webapp\n        //\n        // Uncomment below to allow previous FORM or BASIC authentications\n        // to authenticate users for this webapp\n        // TODO make this a configurable attribute (in SingleSignOn??)\n        /*\n        // Is there an SSO session against which we can try to reauthenticate?\n        if (ssoId != null) {\n            if (log.isDebugEnabled())\n                log.debug(\"SSO Id \" + ssoId + \" set; attempting \" +\n                          \"reauthentication\");\n            // Try to reauthenticate using data cached by SSO.  If this fails,\n            // either the original SSO logon was of DIGEST or SSL (which\n            // we can't reauthenticate ourselves because there is no\n            // cached username and password), or the realm denied\n            // the user's reauthentication for some reason.\n            // In either case we have to prompt the user for a logon\n            if (reauthenticateFromSSO(ssoId, request))\n                return true;\n        }\n        */\n\n        // Validate any credentials already included with this request\n        String authorization = request.getHeader(\"authorization\");\n        DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(),\n                getKey(), nonces, isValidateUri());\n        if (authorization != null) {\n            if (digestInfo.parse(request, authorization)) {\n                if (digestInfo.validate(request)) {\n                    principal = digestInfo.authenticate(context.getRealm());\n                }\n\n                if (principal != null && !digestInfo.isNonceStale()) {\n                    register(request, response, principal,\n                            HttpServletRequest.DIGEST_AUTH,\n                            digestInfo.getUsername(), null);\n                    return true;\n                }\n            }\n        }\n\n        // Send an \"unauthorized\" response and an appropriate challenge\n\n        // Next, generate a nonce token (that is a token which is supposed\n        // to be unique).\n        String nonce = generateNonce(request);\n\n        setAuthenticateHeader(request, response, nonce,\n                principal != null && digestInfo.isNonceStale());\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return false;\n    }","id":967,"modified_method":"/**\n     * Authenticate the user making this request, based on the specified\n     * login configuration.  Return <code>true<\/code> if any specified\n     * constraint has been satisfied, or <code>false<\/code> if we have\n     * created a response challenge already.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // NOTE: We don't try to reauthenticate using any existing SSO session,\n        // because that will only work if the original authentication was\n        // BASIC or FORM, which are less secure than the DIGEST auth-type\n        // specified for this webapp\n        //\n        // Change to true below to allow previous FORM or BASIC authentications\n        // to authenticate users for this webapp\n        // TODO make this a configurable attribute (in SingleSignOn??)\n        if (checkForCachedAuthentication(request, false)) {\n            return true;\n        }\n\n        // Validate any credentials already included with this request\n        Principal principal = null;\n        String authorization = request.getHeader(\"authorization\");\n        DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(),\n                getKey(), nonces, isValidateUri());\n        if (authorization != null) {\n            if (digestInfo.parse(request, authorization)) {\n                if (digestInfo.validate(request)) {\n                    principal = digestInfo.authenticate(context.getRealm());\n                }\n\n                if (principal != null && !digestInfo.isNonceStale()) {\n                    register(request, response, principal,\n                            HttpServletRequest.DIGEST_AUTH,\n                            digestInfo.getUsername(), null);\n                    return true;\n                }\n            }\n        }\n\n        // Send an \"unauthorized\" response and an appropriate challenge\n\n        // Next, generate a nonce token (that is a token which is supposed\n        // to be unique).\n        String nonce = generateNonce(request);\n\n        setAuthenticateHeader(request, response, nonce,\n                principal != null && digestInfo.isNonceStale());\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return false;\n    }","commit_id":"af391ff5548b13ccebede4455b623ac2755928ad","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Authenticate the user making this request, based on the specified\n     * login configuration.  Return <code>true<\/code> if any specified\n     * constraint has been satisfied, or <code>false<\/code> if we have\n     * created a response challenge already.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // References to objects we will need later\n        Session session = null;\n\n        // Have we already authenticated someone?\n        Principal principal = request.getUserPrincipal();\n        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n        if (principal != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Already authenticated '\" +\n                    principal.getName() + \"'\");\n            }\n            // Associate the session with any existing SSO session\n            if (ssoId != null) {\n                associate(ssoId, request.getSessionInternal(true));\n            }\n            return true;\n        }\n\n        // Is there an SSO session against which we can try to reauthenticate?\n        if (ssoId != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"SSO Id \" + ssoId + \" set; attempting \" +\n                          \"reauthentication\");\n            }\n            // Try to reauthenticate using data cached by SSO.  If this fails,\n            // either the original SSO logon was of DIGEST or SSL (which\n            // we can't reauthenticate ourselves because there is no\n            // cached username and password), or the realm denied\n            // the user's reauthentication for some reason.\n            // In either case we have to prompt the user for a logon */\n            if (reauthenticateFromSSO(ssoId, request)) {\n                return true;\n            }\n        }\n\n        // Have we authenticated this user before but have caching disabled?\n        if (!cache) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Checking for reauthenticate in session \" + session);\n            }\n            String username =\n                (String) session.getNote(Constants.SESS_USERNAME_NOTE);\n            String password =\n                (String) session.getNote(Constants.SESS_PASSWORD_NOTE);\n            if ((username != null) && (password != null)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Reauthenticating username '\" + username + \"'\");\n                }\n                principal =\n                    context.getRealm().authenticate(username, password);\n                if (principal != null) {\n                    session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);\n                    if (!matchRequest(request)) {\n                        register(request, response, principal,\n                                HttpServletRequest.FORM_AUTH,\n                                username, password);\n                        return true;\n                    }\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Reauthentication failed, proceed normally\");\n                }\n            }\n        }\n\n        // Is this the re-submit of the original request URI after successful\n        // authentication?  If so, forward the *original* request instead.\n        if (matchRequest(request)) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Restore request from session '\"\n                          + session.getIdInternal()\n                          + \"'\");\n            }\n            principal = (Principal)\n                session.getNote(Constants.FORM_PRINCIPAL_NOTE);\n            register(request, response, principal, HttpServletRequest.FORM_AUTH,\n                     (String) session.getNote(Constants.SESS_USERNAME_NOTE),\n                     (String) session.getNote(Constants.SESS_PASSWORD_NOTE));\n            // If we're caching principals we no longer need the username\n            // and password in the session, so remove them\n            if (cache) {\n                session.removeNote(Constants.SESS_USERNAME_NOTE);\n                session.removeNote(Constants.SESS_PASSWORD_NOTE);\n            }\n            if (restoreRequest(request, session)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Proceed to restored request\");\n                }\n                return true;\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Restore of original request failed\");\n                }\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                return false;\n            }\n        }\n\n        // Acquire references to objects we will need to evaluate\n        MessageBytes uriMB = MessageBytes.newInstance();\n        CharChunk uriCC = uriMB.getCharChunk();\n        uriCC.setLimit(-1);\n        String contextPath = request.getContextPath();\n        String requestURI = request.getDecodedRequestURI();\n\n        // Is this the action request from the login page?\n        boolean loginAction =\n            requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION);\n\n        LoginConfig config = context.getLoginConfig();\n\n        // No -- Save this request and redirect to the form login page\n        if (!loginAction) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Save request in session '\" + session.getIdInternal() + \"'\");\n            }\n            try {\n                saveRequest(request, session);\n            } catch (IOException ioe) {\n                log.debug(\"Request body too big to save during authentication\");\n                response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                        sm.getString(\"authenticator.requestBodyTooBig\"));\n                return false;\n            }\n            forwardToLoginPage(request, response, config);\n            return false;\n        }\n\n        // Yes -- Acknowledge the request, validate the specified credentials\n        // and redirect to the error page if they are not correct\n        request.getResponse().sendAcknowledgement();\n        Realm realm = context.getRealm();\n        if (characterEncoding != null) {\n            request.setCharacterEncoding(characterEncoding);\n        }\n        String username = request.getParameter(Constants.FORM_USERNAME);\n        String password = request.getParameter(Constants.FORM_PASSWORD);\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authenticating username '\" + username + \"'\");\n        }\n        principal = realm.authenticate(username, password);\n        if (principal == null) {\n            forwardToErrorPage(request, response, config);\n            return false;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authentication of '\" + username + \"' was successful\");\n        }\n\n        if (session == null) {\n            session = request.getSessionInternal(false);\n        }\n        if (session == null) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug\n                    (\"User took so long to log on the session expired\");\n            }\n            if (landingPage == null) {\n                response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT,\n                        sm.getString(\"authenticator.sessionExpired\"));\n            } else {\n                // Make the authenticator think the user originally requested\n                // the landing page\n                String uri = request.getContextPath() + landingPage;\n                SavedRequest saved = new SavedRequest();\n                saved.setMethod(\"GET\");\n                saved.setRequestURI(uri);\n                saved.setDecodedRequestURI(uri);\n                request.getSessionInternal(true).setNote(\n                        Constants.FORM_REQUEST_NOTE, saved);\n                response.sendRedirect(response.encodeRedirectURL(uri));\n            }\n            return false;\n        }\n\n        // Save the authenticated Principal in our session\n        session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);\n\n        // Save the username and password as well\n        session.setNote(Constants.SESS_USERNAME_NOTE, username);\n        session.setNote(Constants.SESS_PASSWORD_NOTE, password);\n\n        // Redirect the user to the original request URI (which will cause\n        // the original request to be restored)\n        requestURI = savedRequestURL(session);\n        if (log.isDebugEnabled()) {\n            log.debug(\"Redirecting to original '\" + requestURI + \"'\");\n        }\n        if (requestURI == null) {\n            if (landingPage == null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                        sm.getString(\"authenticator.formlogin\"));\n            } else {\n                // Make the authenticator think the user originally requested\n                // the landing page\n                String uri = request.getContextPath() + landingPage;\n                SavedRequest saved = new SavedRequest();\n                saved.setMethod(\"GET\");\n                saved.setRequestURI(uri);\n                saved.setDecodedRequestURI(uri);\n                session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n                response.sendRedirect(response.encodeRedirectURL(uri));\n            }\n        } else {\n            // Until the Servlet API allows specifying the type of redirect to\n            // use.\n            Response internalResponse = request.getResponse();\n            String location = response.encodeRedirectURL(requestURI);\n            if (\"HTTP/1.1\".equals(request.getProtocol())) {\n                internalResponse.sendRedirect(location,\n                        HttpServletResponse.SC_SEE_OTHER);\n            } else {\n                internalResponse.sendRedirect(location,\n                        HttpServletResponse.SC_FOUND);\n            }\n        }\n        return false;\n\n    }","id":968,"modified_method":"/**\n     * Authenticate the user making this request, based on the specified\n     * login configuration.  Return <code>true<\/code> if any specified\n     * constraint has been satisfied, or <code>false<\/code> if we have\n     * created a response challenge already.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        if (checkForCachedAuthentication(request, true)) {\n            return true;\n        }\n\n        // References to objects we will need later\n        Session session = null;\n        Principal principal = null;\n\n        // Have we authenticated this user before but have caching disabled?\n        if (!cache) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Checking for reauthenticate in session \" + session);\n            }\n            String username =\n                (String) session.getNote(Constants.SESS_USERNAME_NOTE);\n            String password =\n                (String) session.getNote(Constants.SESS_PASSWORD_NOTE);\n            if ((username != null) && (password != null)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Reauthenticating username '\" + username + \"'\");\n                }\n                principal =\n                    context.getRealm().authenticate(username, password);\n                if (principal != null) {\n                    session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);\n                    if (!matchRequest(request)) {\n                        register(request, response, principal,\n                                HttpServletRequest.FORM_AUTH,\n                                username, password);\n                        return true;\n                    }\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Reauthentication failed, proceed normally\");\n                }\n            }\n        }\n\n        // Is this the re-submit of the original request URI after successful\n        // authentication?  If so, forward the *original* request instead.\n        if (matchRequest(request)) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Restore request from session '\"\n                          + session.getIdInternal()\n                          + \"'\");\n            }\n            principal = (Principal)\n                session.getNote(Constants.FORM_PRINCIPAL_NOTE);\n            register(request, response, principal, HttpServletRequest.FORM_AUTH,\n                     (String) session.getNote(Constants.SESS_USERNAME_NOTE),\n                     (String) session.getNote(Constants.SESS_PASSWORD_NOTE));\n            // If we're caching principals we no longer need the username\n            // and password in the session, so remove them\n            if (cache) {\n                session.removeNote(Constants.SESS_USERNAME_NOTE);\n                session.removeNote(Constants.SESS_PASSWORD_NOTE);\n            }\n            if (restoreRequest(request, session)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Proceed to restored request\");\n                }\n                return true;\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Restore of original request failed\");\n                }\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                return false;\n            }\n        }\n\n        // Acquire references to objects we will need to evaluate\n        MessageBytes uriMB = MessageBytes.newInstance();\n        CharChunk uriCC = uriMB.getCharChunk();\n        uriCC.setLimit(-1);\n        String contextPath = request.getContextPath();\n        String requestURI = request.getDecodedRequestURI();\n\n        // Is this the action request from the login page?\n        boolean loginAction =\n            requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION);\n\n        LoginConfig config = context.getLoginConfig();\n\n        // No -- Save this request and redirect to the form login page\n        if (!loginAction) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Save request in session '\" + session.getIdInternal() + \"'\");\n            }\n            try {\n                saveRequest(request, session);\n            } catch (IOException ioe) {\n                log.debug(\"Request body too big to save during authentication\");\n                response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                        sm.getString(\"authenticator.requestBodyTooBig\"));\n                return false;\n            }\n            forwardToLoginPage(request, response, config);\n            return false;\n        }\n\n        // Yes -- Acknowledge the request, validate the specified credentials\n        // and redirect to the error page if they are not correct\n        request.getResponse().sendAcknowledgement();\n        Realm realm = context.getRealm();\n        if (characterEncoding != null) {\n            request.setCharacterEncoding(characterEncoding);\n        }\n        String username = request.getParameter(Constants.FORM_USERNAME);\n        String password = request.getParameter(Constants.FORM_PASSWORD);\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authenticating username '\" + username + \"'\");\n        }\n        principal = realm.authenticate(username, password);\n        if (principal == null) {\n            forwardToErrorPage(request, response, config);\n            return false;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Authentication of '\" + username + \"' was successful\");\n        }\n\n        if (session == null) {\n            session = request.getSessionInternal(false);\n        }\n        if (session == null) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug\n                    (\"User took so long to log on the session expired\");\n            }\n            if (landingPage == null) {\n                response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT,\n                        sm.getString(\"authenticator.sessionExpired\"));\n            } else {\n                // Make the authenticator think the user originally requested\n                // the landing page\n                String uri = request.getContextPath() + landingPage;\n                SavedRequest saved = new SavedRequest();\n                saved.setMethod(\"GET\");\n                saved.setRequestURI(uri);\n                saved.setDecodedRequestURI(uri);\n                request.getSessionInternal(true).setNote(\n                        Constants.FORM_REQUEST_NOTE, saved);\n                response.sendRedirect(response.encodeRedirectURL(uri));\n            }\n            return false;\n        }\n\n        // Save the authenticated Principal in our session\n        session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);\n\n        // Save the username and password as well\n        session.setNote(Constants.SESS_USERNAME_NOTE, username);\n        session.setNote(Constants.SESS_PASSWORD_NOTE, password);\n\n        // Redirect the user to the original request URI (which will cause\n        // the original request to be restored)\n        requestURI = savedRequestURL(session);\n        if (log.isDebugEnabled()) {\n            log.debug(\"Redirecting to original '\" + requestURI + \"'\");\n        }\n        if (requestURI == null) {\n            if (landingPage == null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                        sm.getString(\"authenticator.formlogin\"));\n            } else {\n                // Make the authenticator think the user originally requested\n                // the landing page\n                String uri = request.getContextPath() + landingPage;\n                SavedRequest saved = new SavedRequest();\n                saved.setMethod(\"GET\");\n                saved.setRequestURI(uri);\n                saved.setDecodedRequestURI(uri);\n                session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n                response.sendRedirect(response.encodeRedirectURL(uri));\n            }\n        } else {\n            // Until the Servlet API allows specifying the type of redirect to\n            // use.\n            Response internalResponse = request.getResponse();\n            String location = response.encodeRedirectURL(requestURI);\n            if (\"HTTP/1.1\".equals(request.getProtocol())) {\n                internalResponse.sendRedirect(location,\n                        HttpServletResponse.SC_SEE_OTHER);\n            } else {\n                internalResponse.sendRedirect(location,\n                        HttpServletResponse.SC_FOUND);\n            }\n        }\n        return false;\n\n    }","commit_id":"af391ff5548b13ccebede4455b623ac2755928ad","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Authenticate the user by checking for the existence of a certificate\n     * chain, validating it against the trust manager for the connector and then\n     * validating the user's identity against the configured Realm.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // Have we already authenticated someone?\n        Principal principal = request.getUserPrincipal();\n        //String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n        if (principal != null) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug(\"Already authenticated '\" + principal.getName() + \"'\");\n            }\n            // Associate the session with any existing SSO session in order\n            // to get coordinated session invalidation at logout\n            String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n            if (ssoId != null) {\n                associate(ssoId, request.getSessionInternal(true));\n            }\n            return (true);\n        }\n\n        // NOTE: We don't try to reauthenticate using any existing SSO session,\n        // because that will only work if the original authentication was\n        // BASIC or FORM, which are less secure than the CLIENT_CERT auth-type\n        // specified for this webapp\n        //\n        // Uncomment below to allow previous FORM or BASIC authentications\n        // to authenticate users for this webapp\n        // TODO make this a configurable attribute (in SingleSignOn??)\n        /*\n        // Is there an SSO session against which we can try to reauthenticate?\n        if (ssoId != null) {\n            if (log.isDebugEnabled())\n                log.debug(\"SSO Id \" + ssoId + \" set; attempting \" +\n                          \"reauthentication\");\n            // Try to reauthenticate using data cached by SSO.  If this fails,\n            // either the original SSO logon was of DIGEST or SSL (which\n            // we can't reauthenticate ourselves because there is no\n            // cached username and password), or the realm denied\n            // the user's reauthentication for some reason.\n            // In either case we have to prompt the user for a logon\n            if (reauthenticateFromSSO(ssoId, request))\n                return true;\n        }\n        */\n\n        // Retrieve the certificate chain for this client\n        if (containerLog.isDebugEnabled()) {\n            containerLog.debug(\" Looking up certificates\");\n        }\n\n        X509Certificate certs[] = getRequestCertificates(request);\n\n        if ((certs == null) || (certs.length < 1)) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug(\"  No certificates included with this request\");\n            }\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n                    sm.getString(\"authenticator.certificates\"));\n            return false;\n        }\n\n        // Authenticate the specified certificate chain\n        principal = context.getRealm().authenticate(certs);\n        if (principal == null) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug(\"  Realm.authenticate() returned false\");\n            }\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n                               sm.getString(\"authenticator.unauthorized\"));\n            return (false);\n        }\n\n        // Cache the principal (if requested) and record this authentication\n        register(request, response, principal,\n                HttpServletRequest.CLIENT_CERT_AUTH, null, null);\n        return (true);\n\n    }","id":969,"modified_method":"/**\n     * Authenticate the user by checking for the existence of a certificate\n     * chain, validating it against the trust manager for the connector and then\n     * validating the user's identity against the configured Realm.\n     *\n     * @param request Request we are processing\n     * @param response Response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    @Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // NOTE: We don't try to reauthenticate using any existing SSO session,\n        // because that will only work if the original authentication was\n        // BASIC or FORM, which are less secure than the CLIENT-CERT auth-type\n        // specified for this webapp\n        //\n        // Change to true below to allow previous FORM or BASIC authentications\n        // to authenticate users for this webapp\n        // TODO make this a configurable attribute (in SingleSignOn??)\n        if (checkForCachedAuthentication(request, false)) {\n            return true;\n        }\n\n        // Retrieve the certificate chain for this client\n        if (containerLog.isDebugEnabled()) {\n            containerLog.debug(\" Looking up certificates\");\n        }\n\n        X509Certificate certs[] = getRequestCertificates(request);\n\n        if ((certs == null) || (certs.length < 1)) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug(\"  No certificates included with this request\");\n            }\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n                    sm.getString(\"authenticator.certificates\"));\n            return false;\n        }\n\n        // Authenticate the specified certificate chain\n        Principal principal = context.getRealm().authenticate(certs);\n        if (principal == null) {\n            if (containerLog.isDebugEnabled()) {\n                containerLog.debug(\"  Realm.authenticate() returned false\");\n            }\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n                               sm.getString(\"authenticator.unauthorized\"));\n            return (false);\n        }\n\n        // Cache the principal (if requested) and record this authentication\n        register(request, response, principal,\n                HttpServletRequest.CLIENT_CERT_AUTH, null, null);\n        return (true);\n\n    }","commit_id":"af391ff5548b13ccebede4455b623ac2755928ad","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        // Have we already authenticated someone?\n        Principal principal = request.getUserPrincipal();\n        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\n        if (principal != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Already authenticated '\" + principal.getName() + \"'\");\n            }\n            // Associate the session with any existing SSO session\n            if (ssoId != null) {\n                associate(ssoId, request.getSessionInternal(true));\n            }\n            return true;\n        }\n\n        // Is there an SSO session against which we can try to reauthenticate?\n        if (ssoId != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"SSO Id \" + ssoId + \" set; attempting \" +\n                          \"reauthentication\");\n            }\n            /* Try to reauthenticate using data cached by SSO.  If this fails,\n               either the original SSO logon was of DIGEST or SSL (which\n               we can't reauthenticate ourselves because there is no\n               cached username and password), or the realm denied\n               the user's reauthentication for some reason.\n               In either case we have to prompt the user for a logon */\n            if (reauthenticateFromSSO(ssoId, request)) {\n                return true;\n            }\n        }\n\n        MessageBytes authorization =\n            request.getCoyoteRequest().getMimeHeaders()\n            .getValue(\"authorization\");\n\n        if (authorization == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"authenticator.noAuthHeader\"));\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        }\n\n        authorization.toBytes();\n        ByteChunk authorizationBC = authorization.getByteChunk();\n\n        if (!authorizationBC.startsWithIgnoreCase(\"negotiate \", 0)) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"spnegoAuthenticator.authHeaderNotNego\"));\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        }\n\n        authorizationBC.setOffset(authorizationBC.getOffset() + 10);\n\n        byte[] decoded = Base64.decodeBase64(authorizationBC.getBuffer(),\n                authorizationBC.getOffset(),\n                authorizationBC.getLength());\n\n        if (decoded.length == 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"spnegoAuthenticator.authHeaderNoToken\"));\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        }\n\n        LoginContext lc = null;\n        GSSContext gssContext = null;\n        byte[] outToken = null;\n        try {\n            try {\n                lc = new LoginContext(getLoginConfigName());\n                lc.login();\n            } catch (LoginException e) {\n                log.error(sm.getString(\"spnegoAuthenticator.serviceLoginFail\"),\n                        e);\n                response.sendError(\n                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                return false;\n            }\n\n            Subject subject = lc.getSubject();\n\n            // Assume the GSSContext is stateless\n            // TODO: Confirm this assumption\n            final GSSManager manager = GSSManager.getInstance();\n            // IBM JDK only understands indefinite lifetime\n            final int credentialLifetime;\n            if (Globals.IS_IBM_JVM) {\n                credentialLifetime = GSSCredential.INDEFINITE_LIFETIME;\n            } else {\n                credentialLifetime = GSSCredential.DEFAULT_LIFETIME;\n            }\n            final PrivilegedExceptionAction<GSSCredential> action =\n                new PrivilegedExceptionAction<GSSCredential>() {\n                    @Override\n                    public GSSCredential run() throws GSSException {\n                        return manager.createCredential(null,\n                                credentialLifetime,\n                                new Oid(\"1.3.6.1.5.5.2\"),\n                                GSSCredential.ACCEPT_ONLY);\n                    }\n                };\n            gssContext = manager.createContext(Subject.doAs(subject, action));\n\n            outToken = Subject.doAs(lc.getSubject(), new AcceptAction(gssContext, decoded));\n\n            if (outToken == null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"spnegoAuthenticator.ticketValidateFail\"));\n                }\n                // Start again\n                response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n                return false;\n            }\n\n            principal = Subject.doAs(subject, new AuthenticateAction(\n                    context.getRealm(), gssContext, storeDelegatedCredential));\n\n        } catch (GSSException e) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"spnegoAuthenticator.ticketValidateFail\"), e);\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        } catch (PrivilegedActionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof GSSException) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"spnegoAuthenticator.serviceLoginFail\"), e);\n                }\n            } else {\n                log.error(sm.getString(\"spnegoAuthenticator.serviceLoginFail\"), e);\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        } finally {\n            if (gssContext != null) {\n                try {\n                    gssContext.dispose();\n                } catch (GSSException e) {\n                    // Ignore\n                }\n            }\n            if (lc != null) {\n                try {\n                    lc.logout();\n                } catch (LoginException e) {\n                    // Ignore\n                }\n            }\n        }\n\n        // Send response token on success and failure\n        response.setHeader(\"WWW-Authenticate\", \"Negotiate \"\n                + Base64.encodeBase64String(outToken));\n\n        if (principal != null) {\n            register(request, response, principal, Constants.SPNEGO_METHOD,\n                    principal.getName(), null);\n\n            Pattern p = noKeepAliveUserAgents;\n            if (p != null) {\n                MessageBytes ua =\n                        request.getCoyoteRequest().getMimeHeaders().getValue(\n                                \"user-agent\");\n                if (ua != null && p.matcher(ua.toString()).matches()) {\n                    response.setHeader(\"Connection\", \"close\");\n                }\n            }\n            return true;\n        }\n\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return false;\n    }","id":970,"modified_method":"@Override\n    public boolean authenticate(Request request, HttpServletResponse response)\n            throws IOException {\n\n        if (checkForCachedAuthentication(request, true)) {\n            return true;\n        }\n\n        MessageBytes authorization =\n            request.getCoyoteRequest().getMimeHeaders()\n            .getValue(\"authorization\");\n\n        if (authorization == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"authenticator.noAuthHeader\"));\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        }\n\n        authorization.toBytes();\n        ByteChunk authorizationBC = authorization.getByteChunk();\n\n        if (!authorizationBC.startsWithIgnoreCase(\"negotiate \", 0)) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"spnegoAuthenticator.authHeaderNotNego\"));\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        }\n\n        authorizationBC.setOffset(authorizationBC.getOffset() + 10);\n\n        byte[] decoded = Base64.decodeBase64(authorizationBC.getBuffer(),\n                authorizationBC.getOffset(),\n                authorizationBC.getLength());\n\n        if (decoded.length == 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"spnegoAuthenticator.authHeaderNoToken\"));\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        }\n\n        LoginContext lc = null;\n        GSSContext gssContext = null;\n        byte[] outToken = null;\n        Principal principal = null;\n        try {\n            try {\n                lc = new LoginContext(getLoginConfigName());\n                lc.login();\n            } catch (LoginException e) {\n                log.error(sm.getString(\"spnegoAuthenticator.serviceLoginFail\"),\n                        e);\n                response.sendError(\n                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                return false;\n            }\n\n            Subject subject = lc.getSubject();\n\n            // Assume the GSSContext is stateless\n            // TODO: Confirm this assumption\n            final GSSManager manager = GSSManager.getInstance();\n            // IBM JDK only understands indefinite lifetime\n            final int credentialLifetime;\n            if (Globals.IS_IBM_JVM) {\n                credentialLifetime = GSSCredential.INDEFINITE_LIFETIME;\n            } else {\n                credentialLifetime = GSSCredential.DEFAULT_LIFETIME;\n            }\n            final PrivilegedExceptionAction<GSSCredential> action =\n                new PrivilegedExceptionAction<GSSCredential>() {\n                    @Override\n                    public GSSCredential run() throws GSSException {\n                        return manager.createCredential(null,\n                                credentialLifetime,\n                                new Oid(\"1.3.6.1.5.5.2\"),\n                                GSSCredential.ACCEPT_ONLY);\n                    }\n                };\n            gssContext = manager.createContext(Subject.doAs(subject, action));\n\n            outToken = Subject.doAs(lc.getSubject(), new AcceptAction(gssContext, decoded));\n\n            if (outToken == null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"spnegoAuthenticator.ticketValidateFail\"));\n                }\n                // Start again\n                response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n                return false;\n            }\n\n            principal = Subject.doAs(subject, new AuthenticateAction(\n                    context.getRealm(), gssContext, storeDelegatedCredential));\n\n        } catch (GSSException e) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"spnegoAuthenticator.ticketValidateFail\"), e);\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        } catch (PrivilegedActionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof GSSException) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"spnegoAuthenticator.serviceLoginFail\"), e);\n                }\n            } else {\n                log.error(sm.getString(\"spnegoAuthenticator.serviceLoginFail\"), e);\n            }\n            response.setHeader(\"WWW-Authenticate\", \"Negotiate\");\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return false;\n        } finally {\n            if (gssContext != null) {\n                try {\n                    gssContext.dispose();\n                } catch (GSSException e) {\n                    // Ignore\n                }\n            }\n            if (lc != null) {\n                try {\n                    lc.logout();\n                } catch (LoginException e) {\n                    // Ignore\n                }\n            }\n        }\n\n        // Send response token on success and failure\n        response.setHeader(\"WWW-Authenticate\", \"Negotiate \"\n                + Base64.encodeBase64String(outToken));\n\n        if (principal != null) {\n            register(request, response, principal, Constants.SPNEGO_METHOD,\n                    principal.getName(), null);\n\n            Pattern p = noKeepAliveUserAgents;\n            if (p != null) {\n                MessageBytes ua =\n                        request.getCoyoteRequest().getMimeHeaders().getValue(\n                                \"user-agent\");\n                if (ua != null && p.matcher(ua.toString()).matches()) {\n                    response.setHeader(\"Connection\", \"close\");\n                }\n            }\n            return true;\n        }\n\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        return false;\n    }","commit_id":"af391ff5548b13ccebede4455b623ac2755928ad","url":"https://github.com/apache/tomcat"},{"original_method":"protected static void replaceExpression(@NotNull String newExpression,\n                                            @NotNull PsiExpression expression)\n            throws IncorrectOperationException{\n        final PsiManager mgr = expression.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(mgr.getProject()).getElementFactory();\n        final PsiExpression newCall =\n                factory.createExpressionFromText(newExpression, expression);\n        final PsiElement insertedElement = expression.replace(newCall);\n        final CodeStyleManager codeStyleManager = mgr.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","id":971,"modified_method":"protected static void replaceExpression(@NotNull String newExpression,\n                                            @NotNull PsiExpression expression)\n            throws IncorrectOperationException{\n        final PsiManager mgr = expression.getManager();\n        final JavaPsiFacade psiFacade =\n                JavaPsiFacade.getInstance(mgr.getProject());\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        final PsiExpression newCall =\n                factory.createExpressionFromText(newExpression, expression);\n        final PsiElement insertedElement = expression.replace(newCall);\n        final CodeStyleManager codeStyleManager = mgr.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","commit_id":"cd3ee40edff304b01d707d32d8f0dce70fd097a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void replaceStatement(\n            @NonNls @NotNull String newStatement,\n            @NonNls @NotNull PsiStatement statement)\n            throws IncorrectOperationException{\n        final PsiManager mgr = statement.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(mgr.getProject()).getElementFactory();\n        final PsiStatement newCall =\n                factory.createStatementFromText(newStatement, statement);\n        final PsiElement insertedElement = statement.replace(newCall);\n        final CodeStyleManager codeStyleManager = mgr.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","id":972,"modified_method":"protected static void replaceStatement(\n            @NonNls @NotNull String newStatementText,\n            @NonNls @NotNull PsiStatement statement)\n            throws IncorrectOperationException{\n        final PsiManager mgr = statement.getManager();\n        final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(mgr.getProject());\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        final PsiStatement newStatement =\n                factory.createStatementFromText(newStatementText, statement);\n        final PsiElement insertedElement = statement.replace(newStatement);\n        final CodeStyleManager codeStyleManager = mgr.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","commit_id":"cd3ee40edff304b01d707d32d8f0dce70fd097a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void replaceExpressionWithNegatedExpression(\n            @NotNull PsiExpression newExpression,\n            @NotNull PsiExpression expression)\n            throws IncorrectOperationException{\n        final PsiManager manager = expression.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n        PsiExpression expressionToReplace = expression;\n        final String newExpressionText = newExpression.getText();\n        final String expString;\n        if(BoolUtils.isNegated(expression)){\n            expressionToReplace = BoolUtils.findNegation(expression);\n            expString = newExpressionText;\n        } else if(ComparisonUtils.isComparison(newExpression)){\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) newExpression;\n            final PsiJavaToken sign = binaryExpression.getOperationSign();\n            final String negatedComparison =\n                    ComparisonUtils.getNegatedComparison(sign);\n            final PsiExpression lhs = binaryExpression.getLOperand();\n            final PsiExpression rhs = binaryExpression.getROperand();\n            assert rhs != null;\n            expString = lhs.getText() + negatedComparison + rhs.getText();\n        } else{\n            if(ParenthesesUtils.getPrecedence(newExpression) >\n                    ParenthesesUtils.PREFIX_PRECEDENCE){\n                expString = \"!(\" + newExpressionText + ')';\n            } else{\n                expString = '!' + newExpressionText;\n            }\n        }\n        final PsiExpression newCall =\n                factory.createExpressionFromText(expString, expression);\n        assert expressionToReplace != null;\n        final PsiElement insertedElement = expressionToReplace.replace(newCall);\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","id":973,"modified_method":"protected static void replaceExpressionWithNegatedExpression(\n            @NotNull PsiExpression newExpression,\n            @NotNull PsiExpression expression)\n            throws IncorrectOperationException{\n        final PsiManager manager = expression.getManager();\n        final JavaPsiFacade psiFacade =\n                JavaPsiFacade.getInstance(manager.getProject());\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        PsiExpression expressionToReplace = expression;\n        final String newExpressionText = newExpression.getText();\n        final String expString;\n        if(BoolUtils.isNegated(expression)){\n            expressionToReplace = BoolUtils.findNegation(expression);\n            expString = newExpressionText;\n        } else if(ComparisonUtils.isComparison(newExpression)){\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) newExpression;\n            final PsiJavaToken sign = binaryExpression.getOperationSign();\n            final String negatedComparison =\n                    ComparisonUtils.getNegatedComparison(sign);\n            final PsiExpression lhs = binaryExpression.getLOperand();\n            final PsiExpression rhs = binaryExpression.getROperand();\n            assert rhs != null;\n            expString = lhs.getText() + negatedComparison + rhs.getText();\n        } else{\n            if(ParenthesesUtils.getPrecedence(newExpression) >\n                    ParenthesesUtils.PREFIX_PRECEDENCE){\n                expString = \"!(\" + newExpressionText + ')';\n            } else{\n                expString = '!' + newExpressionText;\n            }\n        }\n        final PsiExpression newCall =\n                factory.createExpressionFromText(expString, expression);\n        assert expressionToReplace != null;\n        final PsiElement insertedElement = expressionToReplace.replace(newCall);\n        final CodeStyleManager codeStyleManager = manager.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","commit_id":"cd3ee40edff304b01d707d32d8f0dce70fd097a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void replaceStatementAndShorten(\n            @NonNls @NotNull String newStatement,\n            @NonNls @NotNull PsiStatement statement)\n            throws IncorrectOperationException{\n        final PsiManager mgr = statement.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(mgr.getProject()).getElementFactory();\n        final PsiStatement newCall =\n                factory.createStatementFromText(newStatement, statement);\n        final PsiElement insertedElement = statement.replace(newCall);\n        final PsiElement shortenedElement =\n                JavaCodeStyleManager.getInstance(mgr.getProject()).shortenClassReferences(insertedElement);\n        mgr.getCodeStyleManager().reformat(shortenedElement);\n    }","id":974,"modified_method":"protected static void replaceStatementAndShorten(\n            @NonNls @NotNull String newStatementText,\n            @NonNls @NotNull PsiStatement statement)\n            throws IncorrectOperationException{\n        final PsiManager mgr = statement.getManager();\n        final Project project = mgr.getProject();\n        final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        final PsiStatement newStatement =\n                factory.createStatementFromText(newStatementText, statement);\n        final PsiElement insertedElement = statement.replace(newStatement);\n        final JavaCodeStyleManager codeStyleManager =\n                JavaCodeStyleManager.getInstance(project);\n        final PsiElement shortenedElement =\n                codeStyleManager.shortenClassReferences(insertedElement);\n        mgr.getCodeStyleManager().reformat(shortenedElement);\n    }","commit_id":"cd3ee40edff304b01d707d32d8f0dce70fd097a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void replaceExpressionWithNegatedExpressionString(\n            @NotNull String newExpression,\n            @NotNull PsiExpression expression)\n            throws IncorrectOperationException{\n        final PsiManager mgr = expression.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(mgr.getProject()).getElementFactory();\n\n        PsiExpression expressionToReplace = expression;\n        final String expString;\n        if(BoolUtils.isNegated(expression)){\n            expressionToReplace = BoolUtils.findNegation(expression);\n            expString = newExpression;\n        } else{\n            expString = \"!(\" + newExpression + ')';\n        }\n        final PsiExpression newCall =\n                factory.createExpressionFromText(expString, expression);\n        assert expressionToReplace != null;\n        final PsiElement insertedElement = expressionToReplace.replace(newCall);\n        final CodeStyleManager codeStyleManager = mgr.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","id":975,"modified_method":"protected static void replaceExpressionWithNegatedExpressionString(\n            @NotNull String newExpression,\n            @NotNull PsiExpression expression)\n            throws IncorrectOperationException{\n        final PsiManager mgr = expression.getManager();\n        final Project project = mgr.getProject();\n        final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        PsiExpression expressionToReplace = expression;\n        final String expString;\n        if(BoolUtils.isNegated(expression)){\n            expressionToReplace = BoolUtils.findNegation(expression);\n            expString = newExpression;\n        } else{\n            expString = \"!(\" + newExpression + ')';\n        }\n        final PsiExpression newCall =\n                factory.createExpressionFromText(expString, expression);\n        assert expressionToReplace != null;\n        final PsiElement insertedElement = expressionToReplace.replace(newCall);\n        final CodeStyleManager codeStyleManager = mgr.getCodeStyleManager();\n        codeStyleManager.reformat(insertedElement);\n    }","commit_id":"cd3ee40edff304b01d707d32d8f0dce70fd097a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if (!(element instanceof PsiConditionalExpression)) {\n            return false;\n        }\n        final PsiMember member = PsiTreeUtil.getParentOfType(element,\n                PsiMember.class);\n        if (member instanceof PsiMethod) {\n            final PsiMethod method = (PsiMethod)member;\n            if (!method.isConstructor()) {\n                return true;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    PsiTreeUtil.getParentOfType(element,\n                            PsiMethodCallExpression.class);\n            if (methodCallExpression == null) {\n                return true;\n            }\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            return !\"super\".equals(methodName);\n        } else if (member instanceof PsiField) {\n            return false;\n        }\n        return true;\n    }","id":976,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if (!(element instanceof PsiConditionalExpression)) {\n            return false;\n        }\n        final PsiConditionalExpression conditionalExpression =\n                (PsiConditionalExpression) element;\n        if (PsiUtil.isInJspFile(element)) {\n            final PsiExpression thenExpression =\n                    conditionalExpression.getThenExpression();\n            if (thenExpression == null) {\n                return false;\n            }\n            final PsiExpression elseExpression =\n                    conditionalExpression.getElseExpression();\n            if (elseExpression == null) {\n                return false;\n            }\n        }\n        final PsiMember member = PsiTreeUtil.getParentOfType(element,\n                PsiMember.class);\n        if (member instanceof PsiMethod) {\n            final PsiMethod method = (PsiMethod)member;\n            if (!method.isConstructor()) {\n                return true;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    PsiTreeUtil.getParentOfType(element,\n                            PsiMethodCallExpression.class);\n            if (methodCallExpression == null) {\n                return true;\n            }\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            return !\"super\".equals(methodName);\n        } else if (member instanceof PsiField) {\n            return false;\n        }\n        return true;\n    }","commit_id":"cd3ee40edff304b01d707d32d8f0dce70fd097a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** @return true if the initialization of the Enumeration variable can\n         *  be deleted. */\n        private static boolean replaceMethodCalls(\n                PsiVariable enumerationVariable,\n                int startOffset,\n                String newVariableName)\n                throws IncorrectOperationException {\n            final PsiManager manager = enumerationVariable.getManager();\n          final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n            final Query<PsiReference> query = ReferencesSearch.search(\n                    enumerationVariable);\n            final List<PsiElement> referenceElements = new ArrayList();\n            for (PsiReference reference : query) {\n                final PsiElement referenceElement = reference.getElement();\n                referenceElements.add(referenceElement);\n            }\n            Collections.sort(referenceElements,\n                    PsiElementOrderComparator.getInstance());\n            boolean deleteInitialization = true;\n            for (PsiElement referenceElement : referenceElements) {\n                if (!(referenceElement instanceof PsiReferenceExpression)) {\n                    deleteInitialization = false;\n                    continue;\n                }\n                if (referenceElement.getTextOffset() <= startOffset) {\n                    continue;\n                }\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression) referenceElement;\n                final PsiElement referenceParent =\n                        referenceExpression.getParent();\n                if (!(referenceParent instanceof PsiReferenceExpression)) {\n                    if (referenceParent instanceof PsiAssignmentExpression) {\n                        deleteInitialization = false;\n                        break;\n                    }\n                    continue;\n                }\n                final PsiElement referenceGrandParent =\n                        referenceParent.getParent();\n                if (!(referenceGrandParent instanceof PsiMethodCallExpression)) {\n                    deleteInitialization = false;\n                    continue;\n                }\n                final PsiMethodCallExpression callExpression =\n                        (PsiMethodCallExpression) referenceGrandParent;\n                final PsiReferenceExpression foundReferenceExpression =\n                        callExpression.getMethodExpression();\n                final String foundName =\n                        foundReferenceExpression.getReferenceName();\n                final String newExpressionText;\n                if (\"hasMoreElements\".equals(foundName)) {\n                    newExpressionText = newVariableName + \".hasNext()\";\n                } else if (\"nextElement\".equals(foundName)) {\n                    newExpressionText = newVariableName + \".next()\";\n                } else {\n                    deleteInitialization = false;\n                    continue;\n                }\n                final PsiExpression newExpression =\n                        factory.createExpressionFromText(newExpressionText,\n                                callExpression);\n                callExpression.replace(newExpression);\n            }\n            return deleteInitialization;\n        }","id":977,"modified_method":"/** @return true if the initialization of the Enumeration variable can\n         *  be deleted. */\n        private static int replaceMethodCalls(\n                PsiVariable enumerationVariable,\n                int startOffset,\n                String newVariableName)\n                throws IncorrectOperationException {\n            final PsiManager manager = enumerationVariable.getManager();\n            final Project project = manager.getProject();\n            final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n            final PsiElementFactory factory = facade.getElementFactory();\n            final Query<PsiReference> query = ReferencesSearch.search(\n                    enumerationVariable);\n            final List<PsiElement> referenceElements = new ArrayList();\n            for (PsiReference reference : query) {\n                final PsiElement referenceElement = reference.getElement();\n                referenceElements.add(referenceElement);\n            }\n            Collections.sort(referenceElements,\n                    PsiElementOrderComparator.getInstance());\n            int result = 0;\n            for (PsiElement referenceElement : referenceElements) {\n                if (!(referenceElement instanceof PsiReferenceExpression)) {\n                    result = KEEP_DECLARATION;\n                    continue;\n                }\n                if (referenceElement.getTextOffset() <= startOffset) {\n                    result = KEEP_DECLARATION;\n                    continue;\n                }\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression) referenceElement;\n                final PsiElement referenceParent =\n                        referenceExpression.getParent();\n                if (!(referenceParent instanceof PsiReferenceExpression)) {\n                    if (referenceParent instanceof PsiAssignmentExpression) {\n                        result = KEEP_DECLARATION;\n                        break;\n                    }\n                    result = KEEP_INITIALIZATION;\n                    continue;\n                }\n                final PsiElement referenceGrandParent =\n                        referenceParent.getParent();\n                if (!(referenceGrandParent instanceof PsiMethodCallExpression)) {\n                    result = KEEP_INITIALIZATION;\n                    continue;\n                }\n                final PsiMethodCallExpression callExpression =\n                        (PsiMethodCallExpression) referenceGrandParent;\n                final PsiReferenceExpression foundReferenceExpression =\n                        callExpression.getMethodExpression();\n                final String foundName =\n                        foundReferenceExpression.getReferenceName();\n                final String newExpressionText;\n                if (\"hasMoreElements\".equals(foundName)) {\n                    newExpressionText = newVariableName + \".hasNext()\";\n                } else if (\"nextElement\".equals(foundName)) {\n                    newExpressionText = newVariableName + \".next()\";\n                } else {\n                    result = KEEP_INITIALIZATION;\n                    continue;\n                }\n                final PsiExpression newExpression =\n                        factory.createExpressionFromText(newExpressionText,\n                                callExpression);\n                callExpression.replace(newExpression);\n            }\n            return result;\n        }","commit_id":"bfe43f959ea9af1008810ccf1f649224d0a3b8f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String createVariableName(PsiElement context) {\n            final PsiManager manager = context.getManager();\n          final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n            final Project project = context.getProject();\n            final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n          final PsiClass iteratorClass = JavaPsiFacade.getInstance(manager.getProject()).findClass(\"java.util.Iterator\", scope);\n            if (iteratorClass == null) {\n                return \"iterator\";\n            }\n            final JavaCodeStyleManager codeStyleManager =\n                    JavaCodeStyleManager.getInstance(project);\n            final PsiType iteratorType = factory.createType(iteratorClass);\n            final SuggestedNameInfo baseNameInfo =\n                    codeStyleManager.suggestVariableName(\n                            VariableKind.LOCAL_VARIABLE, null, null,\n                            iteratorType);\n            final SuggestedNameInfo nameInfo =\n                    codeStyleManager.suggestUniqueVariableName(baseNameInfo,\n                            context, true);\n            if (nameInfo.names.length <= 0) {\n                return \"iterator\";\n            }\n            return nameInfo.names[0];\n        }","id":978,"modified_method":"private static String createVariableName(PsiElement context) {\n            final Project project = context.getProject();\n            final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n            final PsiElementFactory factory = facade.getElementFactory();\n            final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n            final PsiClass iteratorClass =\n                    facade.findClass(\"java.util.Iterator\", scope);\n            if (iteratorClass == null) {\n                return \"iterator\";\n            }\n            final JavaCodeStyleManager codeStyleManager =\n                    JavaCodeStyleManager.getInstance(project);\n            final PsiType iteratorType = factory.createType(iteratorClass);\n            final SuggestedNameInfo baseNameInfo =\n                    codeStyleManager.suggestVariableName(\n                            VariableKind.LOCAL_VARIABLE, null, null,\n                            iteratorType);\n            final SuggestedNameInfo nameInfo =\n                    codeStyleManager.suggestUniqueVariableName(baseNameInfo,\n                            context, true);\n            if (nameInfo.names.length <= 0) {\n                return \"iterator\";\n            }\n            return nameInfo.names[0];\n        }","commit_id":"bfe43f959ea9af1008810ccf1f649224d0a3b8f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement element = descriptor.getPsiElement();\n            final PsiReferenceExpression methodExpression =\n                    (PsiReferenceExpression)element.getParent();\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression)methodExpression.getParent();\n            final PsiElement parent =\n                    methodCallExpression.getParent();\n            final PsiVariable variable;\n            boolean deleteInitializationStatement = false;\n            if (parent instanceof PsiVariable) {\n                variable = (PsiVariable) parent;\n            } else if (parent instanceof PsiAssignmentExpression) {\n                final PsiAssignmentExpression assignmentExpression =\n                        (PsiAssignmentExpression)parent;\n                final PsiExpression lhs = assignmentExpression.getLExpression();\n                if (!(lhs instanceof PsiReferenceExpression)) {\n                    return;\n                }\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression) lhs;\n                final PsiElement target = referenceExpression.resolve();\n                if (!(target instanceof PsiVariable)) {\n                    return;\n                }\n                variable = (PsiVariable) target;\n                deleteInitializationStatement = true;\n            } else {\n                return;\n            }\n            final String variableName = createVariableName(element);\n            final PsiStatement statement =\n                    PsiTreeUtil.getParentOfType(element, PsiStatement.class);\n            if (statement == null) {\n                return;\n            }\n            deleteInitializationStatement |= replaceMethodCalls(variable,\n                    statement.getTextOffset(), variableName);\n            final PsiType variableType = variable.getType();\n            if (!(variableType instanceof PsiClassType)) {\n                return;\n            }\n            final PsiClassType classType = (PsiClassType)variableType;\n            final PsiType[] parameterTypes = classType.getParameters();\n            final PsiType parameterType;\n            if (parameterTypes.length > 0) {\n                parameterType = parameterTypes[0];\n            } else {\n                parameterType = null;\n            }\n            final PsiStatement newStatement =\n                    createDeclaration(methodCallExpression, variableName,\n                            parameterType);\n            if (newStatement == null) {\n                return;\n            }\n            if (deleteInitializationStatement) {\n                statement.replace(newStatement);\n            } else {\n                final PsiElement statementParent = statement.getParent();\n                if (statementParent instanceof PsiForStatement) {\n                    final PsiElement statementGrandParent =\n                            statementParent.getParent();\n                    statementGrandParent.addBefore(newStatement,\n                            statementParent);\n                } else {\n                    statementParent.addAfter(newStatement, statement);\n                }\n                if (parent == variable) {\n                    final PsiExpression initializer = variable.getInitializer();\n                    if (initializer != null) {\n                        initializer.delete();\n                    }\n                }\n            }\n        }","id":979,"modified_method":"protected void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement element = descriptor.getPsiElement();\n            final PsiReferenceExpression methodExpression =\n                    (PsiReferenceExpression)element.getParent();\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression)methodExpression.getParent();\n            final PsiElement parent =\n                    methodCallExpression.getParent();\n            final PsiVariable variable;\n            if (parent instanceof PsiVariable) {\n                variable = (PsiVariable) parent;\n            } else if (parent instanceof PsiAssignmentExpression) {\n                final PsiAssignmentExpression assignmentExpression =\n                        (PsiAssignmentExpression)parent;\n                final PsiExpression lhs = assignmentExpression.getLExpression();\n                if (!(lhs instanceof PsiReferenceExpression)) {\n                    return;\n                }\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression) lhs;\n                final PsiElement target = referenceExpression.resolve();\n                if (!(target instanceof PsiVariable)) {\n                    return;\n                }\n                variable = (PsiVariable) target;\n            } else {\n                return;\n            }\n            final String variableName = createVariableName(element);\n            final PsiStatement statement =\n                    PsiTreeUtil.getParentOfType(element, PsiStatement.class);\n            if (statement == null) {\n                return;\n            }\n            final int result = replaceMethodCalls(variable,\n                    statement.getTextOffset(), variableName);\n            final PsiType variableType = variable.getType();\n            if (!(variableType instanceof PsiClassType)) {\n                return;\n            }\n            final PsiClassType classType = (PsiClassType)variableType;\n            final PsiType[] parameterTypes = classType.getParameters();\n            final PsiType parameterType;\n            if (parameterTypes.length > 0) {\n                parameterType = parameterTypes[0];\n            } else {\n                parameterType = null;\n            }\n            final PsiStatement newStatement =\n                    createDeclaration(methodCallExpression, variableName,\n                            parameterType);\n            if (newStatement == null) {\n                return;\n            }\n            if (parent == variable) {\n                if (result == KEEP_NOTHING) {\n                    System.out.println(\"KEEP_NOTHING\");\n                    statement.replace(newStatement);\n                } else {\n                    insertNewStament(statement, newStatement);\n                    if (result != KEEP_INITIALIZATION) {\n                        final PsiExpression initializer =\n                                variable.getInitializer();\n                        if (initializer != null) {\n                            initializer.delete();\n                        }\n                    }\n                }\n            } else {\n                if (result == KEEP_NOTHING || result == KEEP_DECLARATION) {\n                    statement.replace(newStatement);\n                } else {\n                    insertNewStament(statement, newStatement);\n                }\n            }\n        }","commit_id":"bfe43f959ea9af1008810ccf1f649224d0a3b8f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceConditionalWithIf(\n            PsiConditionalExpression expression)\n            throws IncorrectOperationException {\n        final PsiStatement statement =\n                PsiTreeUtil.getParentOfType(expression, PsiStatement.class);\n        if (statement == null) {\n            return;\n        }\n        final PsiVariable variable;\n        if (statement instanceof PsiDeclarationStatement) {\n            variable =\n                    PsiTreeUtil.getParentOfType(expression, PsiVariable.class);\n        } else {\n            variable = null;\n        }\n        final PsiExpression thenExpression = expression.getThenExpression();\n        final String thenExpressionText;\n        if (thenExpression != null) {\n            thenExpressionText = thenExpression.getText();\n        } else {\n            thenExpressionText = \"\";\n        }\n        final PsiExpression elseExpression = expression.getElseExpression();\n        final String elseExpressionText;\n        if (elseExpression != null) {\n            elseExpressionText = elseExpression.getText();\n        } else {\n            elseExpressionText = \"\";\n        }\n        final PsiExpression condition = expression.getCondition();\n        final PsiExpression strippedCondition =\n                ParenthesesUtils.stripParentheses(condition);\n        final StringBuilder newStatement = new StringBuilder();\n        newStatement.append(\"if(\");\n        newStatement.append(strippedCondition.getText());\n        newStatement.append(')');\n        if (variable != null) {\n            final String name = variable.getName();\n            newStatement.append(name);\n            newStatement.append('=');\n            final PsiExpression initializer = variable.getInitializer();\n            if (initializer == null) {\n                return;\n            }\n            appendElementText(initializer, expression, thenExpressionText,\n                    newStatement);\n            newStatement.append(\"; else \");\n            newStatement.append(name);\n            newStatement.append('=');\n            appendElementText(initializer, expression, elseExpressionText,\n                    newStatement);\n            newStatement.append(';');\n            initializer.delete();\n            final PsiManager manager = statement.getManager();\n          final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n            final PsiStatement ifStatement = factory.createStatementFromText(\n                    newStatement.toString(), statement);\n            final PsiElement parent = statement.getParent();\n            final PsiElement addedElement = parent.addAfter(ifStatement,\n                    statement);\n            final CodeStyleManager styleManager = manager.getCodeStyleManager();\n            styleManager.reformat(addedElement);\n        } else {\n            appendElementText(statement, expression, thenExpressionText,\n                    newStatement);\n            newStatement.append(\" else \");\n            appendElementText(statement, expression, elseExpressionText,\n                    newStatement);\n            replaceStatement(newStatement.toString(), statement);\n        }\n    }","id":980,"modified_method":"private static void replaceConditionalWithIf(\n            PsiConditionalExpression expression)\n            throws IncorrectOperationException {\n        final PsiStatement statement =\n                PsiTreeUtil.getParentOfType(expression, PsiStatement.class);\n        if (statement == null) {\n            return;\n        }\n        final PsiVariable variable;\n        if (statement instanceof PsiDeclarationStatement) {\n            variable =\n                    PsiTreeUtil.getParentOfType(expression, PsiVariable.class);\n        } else {\n            variable = null;\n        }\n        final PsiExpression thenExpression = expression.getThenExpression();\n        final String thenExpressionText;\n        if (thenExpression != null) {\n            thenExpressionText = thenExpression.getText();\n        } else {\n            thenExpressionText = \"\";\n        }\n        final PsiExpression elseExpression = expression.getElseExpression();\n        final String elseExpressionText;\n        if (elseExpression != null) {\n            elseExpressionText = elseExpression.getText();\n        } else {\n            elseExpressionText = \"\";\n        }\n        final PsiExpression condition = expression.getCondition();\n        final PsiExpression strippedCondition =\n                ParenthesesUtils.stripParentheses(condition);\n        final StringBuilder newStatement = new StringBuilder();\n        newStatement.append(\"if(\");\n        if (strippedCondition != null) {\n            newStatement.append(strippedCondition.getText());\n        }\n        newStatement.append(')');\n        if (variable != null) {\n            final String name = variable.getName();\n            newStatement.append(name);\n            newStatement.append('=');\n            final PsiExpression initializer = variable.getInitializer();\n            if (initializer == null) {\n                return;\n            }\n            appendElementText(initializer, expression, thenExpressionText,\n                    newStatement);\n            newStatement.append(\"; else \");\n            newStatement.append(name);\n            newStatement.append('=');\n            appendElementText(initializer, expression, elseExpressionText,\n                    newStatement);\n            newStatement.append(';');\n            initializer.delete();\n            final PsiManager manager = statement.getManager();\n            final Project project = manager.getProject();\n            final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n            final PsiElementFactory factory = facade.getElementFactory();\n            final PsiStatement ifStatement = factory.createStatementFromText(\n                    newStatement.toString(), statement);\n            final PsiElement parent = statement.getParent();\n            final PsiElement addedElement = parent.addAfter(ifStatement,\n                    statement);\n            final CodeStyleManager styleManager = manager.getCodeStyleManager();\n            styleManager.reformat(addedElement);\n        } else {\n            final boolean addBraces =\n                    expression.getParent() instanceof PsiIfStatement;\n            if (addBraces) {\n                newStatement.append('{');\n            }\n            appendElementText(statement, expression, thenExpressionText,\n                    newStatement);\n            if (addBraces) {\n                newStatement.append(\"} else {\");\n            } else {\n                newStatement.append(\" else \");\n            }\n            appendElementText(statement, expression, elseExpressionText,\n                    newStatement);\n            if (addBraces) {\n                newStatement.append('}');\n            }\n            replaceStatement(newStatement.toString(), statement);\n        }\n    }","commit_id":"63eb4f189f2aaa3e0cea2f25f09015b63044d117","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            @NonNls final String methodName =\n                    methodExpression.getReferenceName();\n            if (!\"getClass\".equals(methodName)) {\n                return;\n            }\n            final PsiExpressionList argumentList = expression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            if (args.length != 0) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (!(qualifier instanceof PsiNewExpression)) {\n                return;\n            }\n            registerError(expression);\n        }","id":981,"modified_method":"@Override public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            @NonNls final String methodName =\n                    methodExpression.getReferenceName();\n            if (!\"getClass\".equals(methodName)) {\n                return;\n            }\n            final PsiExpressionList argumentList = expression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            if (args.length != 0) {\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (!(qualifier instanceof PsiNewExpression)) {\n                return;\n            }\n            final PsiNewExpression newExpression = (PsiNewExpression)qualifier;\n            if (newExpression.getAnonymousClass() != null) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static StringBuilder getTypeText(PsiType type,\n                                                 StringBuilder text) {\n            if (type instanceof PsiArrayType) {\n                text.append(\"[]\");\n                final PsiArrayType arrayType = (PsiArrayType)type;\n                getTypeText(arrayType.getComponentType(), text);\n            } else {\n                text.insert(0, type.getCanonicalText());\n            }\n            return text;\n        }","id":982,"modified_method":"private static StringBuilder getTypeText(PsiType type,\n                                                 StringBuilder text) {\n            if (type instanceof PsiArrayType) {\n                text.append(\"[]\");\n                final PsiArrayType arrayType = (PsiArrayType)type;\n                getTypeText(arrayType.getComponentType(), text);\n            } else if (type instanceof PsiClassType) {\n                final String canonicalText = type.getCanonicalText();\n                final String typeText =\n                        StringUtils.stripAngleBrackets(canonicalText);\n                text.insert(0, typeText);\n            } else {\n                text.insert(0, type.getCanonicalText());\n            }\n            return text;\n        }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void removeReference(\n                PsiJavaCodeReferenceElement reference, PsiMember target) {\n            final PsiManager manager = reference.getManager();\n          final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n            final PsiClass aClass = target.getContainingClass();\n            final String qualifiedName = aClass.getQualifiedName();\n            final String text = reference.getText();\n            final String referenceText = qualifiedName + '.' + text;\n            if (reference instanceof PsiReferenceExpression) {\n                try {\n                    final PsiExpression newReference =\n                            factory.createExpressionFromText(\n                                    referenceText, reference);\n                    reference.replace(newReference);\n                } catch (IncorrectOperationException e) {\n                    throw new RuntimeException(e);\n                }\n            } else {\n                final PsiJavaCodeReferenceElement referenceElement =\n                        factory.createReferenceElementByFQClassName(\n                                referenceText, reference.getResolveScope());\n                try {\n                    reference.replace(referenceElement);\n                } catch (IncorrectOperationException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }","id":983,"modified_method":"private static void removeReference(\n                PsiJavaCodeReferenceElement reference, PsiMember target) {\n            final PsiManager manager = reference.getManager();\n            final Project project = manager.getProject();\n            final JavaPsiFacade psiFacade =\n                    JavaPsiFacade.getInstance(project);\n            final PsiElementFactory factory = psiFacade.getElementFactory();\n            final PsiClass aClass = target.getContainingClass();\n            final String qualifiedName = aClass.getQualifiedName();\n            final String text = reference.getText();\n            final String referenceText = qualifiedName + '.' + text;\n            if (reference instanceof PsiReferenceExpression) {\n                try {\n                    final PsiExpression newReference =\n                            factory.createExpressionFromText(\n                                    referenceText, reference);\n                    reference.replace(newReference);\n                } catch (IncorrectOperationException e) {\n                    throw new RuntimeException(e);\n                }\n            } else {\n                final PsiJavaCodeReferenceElement referenceElement =\n                        factory.createReferenceElementByFQClassName(\n                                referenceText, reference.getResolveScope());\n                try {\n                    reference.replace(referenceElement);\n                } catch (IncorrectOperationException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isFullyQualifiedReference(\n                    PsiJavaCodeReferenceElement reference) {\n                if (!reference.isQualified()) {\n                    return false;\n                }\n                final PsiElement directParent = reference.getParent();\n                if (directParent instanceof PsiMethodCallExpression ||\n                        directParent instanceof PsiAssignmentExpression ||\n                        directParent instanceof PsiVariable) {\n                    return false;\n                }\n                final PsiElement parent = PsiTreeUtil.getParentOfType(reference,\n                        PsiImportStatementBase.class, PsiPackageStatement.class,\n                        JavaCodeFragment.class);\n                if (parent != null) {\n                    return false;\n                }\n                final PsiElement target = reference.resolve();\n                if(!(target instanceof PsiClass)) {\n                    return false;\n                }\n                final PsiClass aClass = (PsiClass) target;\n                final String fqName = aClass.getQualifiedName();\n                if (fqName == null) {\n                    return false;\n                }\n                final String text = stripAngleBrackets(reference.getText());\n                return text.equals(fqName);\n            }","id":984,"modified_method":"public static boolean isFullyQualifiedReference(\n                    PsiJavaCodeReferenceElement reference) {\n                if (!reference.isQualified()) {\n                    return false;\n                }\n                final PsiElement directParent = reference.getParent();\n                if (directParent instanceof PsiMethodCallExpression ||\n                        directParent instanceof PsiAssignmentExpression ||\n                        directParent instanceof PsiVariable) {\n                    return false;\n                }\n                final PsiElement parent = PsiTreeUtil.getParentOfType(reference,\n                        PsiImportStatementBase.class, PsiPackageStatement.class,\n                        JavaCodeFragment.class);\n                if (parent != null) {\n                    return false;\n                }\n                final PsiElement target = reference.resolve();\n                if(!(target instanceof PsiClass)) {\n                    return false;\n                }\n                final PsiClass aClass = (PsiClass) target;\n                final String fqName = aClass.getQualifiedName();\n                if (fqName == null) {\n                    return false;\n                }\n                final String text =\n                        StringUtils.stripAngleBrackets(reference.getText());\n                return text.equals(fqName);\n            }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull private static String preprendIndefiniteArticle(\n            String singularName){\n        switch(singularName.charAt(0)){\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n              return AN + StringUtil.capitalize(singularName);\n            default:\n              return 'a' + StringUtil.capitalize(singularName);\n        }\n    }","id":985,"modified_method":"@NotNull private static String prependIndefiniteArticle(\n            String singularName){\n        switch(singularName.charAt(0)){\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n              return AN + StringUtil.capitalize(singularName);\n            default:\n              return 'a' + StringUtil.capitalize(singularName);\n        }\n    }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n    @NotNull public static String createSingularFromName(@NotNull String name){\n        final int nameLength = name.length();\n        final String singularName;\n        if(name.endsWith(\"ies\")){\n            singularName = name.substring(0, nameLength - 3) + 'y';\n        } else if(name.endsWith(\"sses\") || name.endsWith(\"shes\")){\n            singularName = name.substring(0, nameLength - 2);\n        } else if(name.charAt(nameLength - 1) == 's'){\n            singularName = name.substring(0, nameLength - 1);\n        } else if(name.endsWith(\"IES\")){\n            singularName = name.substring(0, nameLength - 3) + 'Y';\n        } else if(name.endsWith(\"SSES\") || name.endsWith(\"SHES\")){\n            singularName = name.substring(0, nameLength - 2);\n        } else if(name.charAt(nameLength - 1) == 'S'){\n            singularName = name.substring(0, nameLength - 1);\n        } else{\n            singularName = preprendIndefiniteArticle(name);\n        }\n        if(keywordTable.contains(singularName)){\n            return preprendIndefiniteArticle(singularName);\n        } else{\n            return singularName;\n        }\n    }","id":986,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n    @NotNull public static String createSingularFromName(@NotNull String name){\n        final int nameLength = name.length();\n        final String singularName;\n        if(name.endsWith(\"ies\")){\n            singularName = name.substring(0, nameLength - 3) + 'y';\n        } else if(name.endsWith(\"sses\") || name.endsWith(\"shes\")){\n            singularName = name.substring(0, nameLength - 2);\n        } else if(name.charAt(nameLength - 1) == 's'){\n            singularName = name.substring(0, nameLength - 1);\n        } else if(name.endsWith(\"IES\")){\n            singularName = name.substring(0, nameLength - 3) + 'Y';\n        } else if(name.endsWith(\"SSES\") || name.endsWith(\"SHES\")){\n            singularName = name.substring(0, nameLength - 2);\n        } else if(name.charAt(nameLength - 1) == 'S'){\n            singularName = name.substring(0, nameLength - 1);\n        } else{\n            singularName = prependIndefiniteArticle(name);\n        }\n        if(keywordTable.contains(singularName)){\n            return prependIndefiniteArticle(singularName);\n        } else{\n            return singularName;\n        }\n    }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReference(PsiJavaCodeReferenceElement reference) {\n            if (!reference.isQualified()) {\n                return;\n            }\n            final PsiElement parent = reference.getParent();\n            if (parent instanceof PsiMethodCallExpression ||\n                parent instanceof PsiAssignmentExpression ||\n                parent instanceof PsiVariable) {\n                return;\n            }\n            final PsiElement element = PsiTreeUtil.getParentOfType(reference,\n                    PsiImportStatementBase.class, PsiPackageStatement.class,\n                    JavaCodeFragment.class);\n            if (element != null) {\n                return;\n            }\n            if(m_ignoreJavadoc){\n                final PsiElement containingComment =\n                        PsiTreeUtil.getParentOfType(reference,\n                                PsiDocComment.class);\n                if(containingComment != null){\n                    return;\n                }\n            }\n            final PsiFile containingFile = reference.getContainingFile();\n            if (!(containingFile instanceof PsiJavaFile)) {\n                return;\n            }\n            final PsiElement psiElement = reference.resolve();\n            if(!(psiElement instanceof PsiClass)){\n                return;\n            }\n            PsiClass aClass = (PsiClass) psiElement;\n            final Project project = aClass.getProject();\n            final CodeStyleSettings styleSettings =\n                    CodeStyleSettingsManager.getSettings(project);\n            if (!styleSettings.INSERT_INNER_CLASS_IMPORTS) {\n                aClass = ClassUtils.getOutermostContainingClass(aClass);\n            }\n            final String fqName = aClass.getQualifiedName();\n            if (fqName == null) {\n                return;\n            }\n            final String text = stripAngleBrackets(reference.getText());\n            if(!text.equals(fqName)){\n                return;\n            }\n            if (!ImportUtils.nameCanBeImported(fqName, reference)) {\n                return;\n            }\n            final PsiJavaFile javaFile = (PsiJavaFile) containingFile;\n            final String packageName = javaFile.getPackageName();\n            final String elementPackageName =\n                    ClassUtil.extractPackageName(text);\n            final boolean inSameFile = elementPackageName.equals(packageName);\n            registerError(reference, Boolean.valueOf(inSameFile));\n        }","id":987,"modified_method":"private void checkReference(PsiJavaCodeReferenceElement reference) {\n            if (!reference.isQualified()) {\n                return;\n            }\n            final PsiElement parent = reference.getParent();\n            if (parent instanceof PsiMethodCallExpression ||\n                parent instanceof PsiAssignmentExpression ||\n                parent instanceof PsiVariable) {\n                return;\n            }\n            final PsiElement element = PsiTreeUtil.getParentOfType(reference,\n                    PsiImportStatementBase.class, PsiPackageStatement.class,\n                    JavaCodeFragment.class);\n            if (element != null) {\n                return;\n            }\n            if(m_ignoreJavadoc){\n                final PsiElement containingComment =\n                        PsiTreeUtil.getParentOfType(reference,\n                                PsiDocComment.class);\n                if(containingComment != null){\n                    return;\n                }\n            }\n            final PsiFile containingFile = reference.getContainingFile();\n            if (!(containingFile instanceof PsiJavaFile)) {\n                return;\n            }\n            final PsiElement psiElement = reference.resolve();\n            if(!(psiElement instanceof PsiClass)){\n                return;\n            }\n            PsiClass aClass = (PsiClass) psiElement;\n            final Project project = aClass.getProject();\n            final CodeStyleSettings styleSettings =\n                    CodeStyleSettingsManager.getSettings(project);\n            if (!styleSettings.INSERT_INNER_CLASS_IMPORTS) {\n                aClass = ClassUtils.getOutermostContainingClass(aClass);\n            }\n            final String fqName = aClass.getQualifiedName();\n            if (fqName == null) {\n                return;\n            }\n            final String referenceText = reference.getText();\n            final String text = StringUtils.stripAngleBrackets(referenceText);\n            if(!text.equals(fqName)){\n                return;\n            }\n            if (!ImportUtils.nameCanBeImported(fqName, reference)) {\n                return;\n            }\n            final PsiJavaFile javaFile = (PsiJavaFile) containingFile;\n            final String packageName = javaFile.getPackageName();\n            final String elementPackageName =\n                    ClassUtil.extractPackageName(text);\n            final boolean inSameFile = elementPackageName.equals(packageName);\n            registerError(reference, Boolean.valueOf(inSameFile));\n        }","commit_id":"725c7d9eefb0158bfd9db88665dd247ac1eb83f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntityGroups<\/code> that are members of this <code>IEntityGroup<\/code>.\r\n     * @return java.util.Iterator\r\n     * @param group org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findMemberGroups(IEntityGroup group) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tif (log.isDebugEnabled()) {\r\n    \t\tlog.debug(\"Invoking findMemberGroups() for group:  \" + group.getLocalKey());\r\n    \t}\r\n\r\n    \tList<IEntityGroup> rslt = new LinkedList<IEntityGroup>();\r\n    \t\r\n    \tList<String> list = groupsTree.getChildren().get(group.getLocalKey());\r\n    \tif (list != null) {\r\n\t\t\t// should only reach this code if its a SmartLdap managed group...\r\n    \t\tfor (String s : list) {\r\n    \t\t\trslt.add(groupsTree.getGroups().get(s));\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn rslt.iterator();\r\n\r\n    }","id":988,"modified_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntityGroups<\/code> that are members of this <code>IEntityGroup<\/code>.\r\n     * @return java.util.Iterator\r\n     * @param group org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findMemberGroups(IEntityGroup group) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tlog.debug(\"Invoking findMemberGroups() for group:  {}\", group.getLocalKey());\r\n\r\n    \tList<IEntityGroup> rslt = new LinkedList<>();\r\n    \t\r\n    \tList<String> list = groupsTree.getChildren().get(group.getLocalKey());\r\n    \tif (list != null) {\r\n\t\t\t// should only reach this code if its a SmartLdap managed group...\r\n    \t\tfor (String s : list) {\r\n    \t\t\trslt.add(groupsTree.getGroups().get(s));\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn rslt.iterator();\r\n\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"private GroupsTree buildGroupsTree() {\r\n        \r\n        long timestamp = System.currentTimeMillis();\r\n        \r\n        // Prepare the new local indeces...\r\n        Map<String,IEntityGroup> new_groups = Collections.synchronizedMap(new HashMap<String,IEntityGroup>());\r\n        Map<String,List<String>> new_parents = Collections.synchronizedMap(new HashMap<String,List<String>>());\r\n        Map<String,List<String>> new_children = Collections.synchronizedMap(new HashMap<String,List<String>>());\r\n        Map<String,List<String>> new_keysByUpperCaseName = Collections.synchronizedMap(new HashMap<String,List<String>>());\r\n\r\n        // Gather IEntityGroup objects from LDAP...\r\n        RuntimeRequestResponse req = new RuntimeRequestResponse();\r\n        Set<LdapRecord> set = new HashSet<LdapRecord>();\r\n        req.setAttribute(\"GROUPS\", set);\r\n        req.setAttribute(\"smartLdapGroupStore\", this);\r\n        SubQueryCounter queryCounter = new SubQueryCounter();\r\n        req.setAttribute(\"queryCounter\", queryCounter);\r\n        req.setAttribute(\"baseFilter\", spring_context.getBean(\"filter\"));\r\n        for (String name : spring_context.getBeanDefinitionNames()) {\r\n            req.setAttribute(name, spring_context.getBean(name));\r\n        }\r\n        runner.run(initTask, req);\r\n        \r\n        if (log.isInfoEnabled()) {\r\n            String msg = \"init() found \" + set.size() + \" records.\";\r\n            log.info(msg);\r\n        }\r\n        \r\n        // Do a first loop to build the main catalog (new_groups)...\r\n        for (LdapRecord r : set) {\r\n            \r\n            // new_groups (me)...\r\n            IEntityGroup g = r.getGroup();\r\n            new_groups.put(g.getLocalKey(), g);\r\n\r\n        }\r\n        \r\n        // Do a second loop to build local indeces...\r\n        for (LdapRecord r : set) {\r\n\r\n            IEntityGroup g = r.getGroup();\r\n\r\n            // new_parents (I am a parent for all my children)...\r\n            for (String childKey : r.getKeysOfChildren()) {\r\n                \r\n                // NB:  We're only interested in relationships between \r\n                // objects in the main catalog (i.e. new_groups);  \r\n                // discard everything else...\r\n                if (!new_groups.containsKey(childKey)) {\r\n                    break;\r\n                }\r\n\r\n                List<String> parentsList = new_parents.get(childKey);\r\n                if (parentsList == null) {\r\n                    // first parent for this child...\r\n                    parentsList = Collections.synchronizedList(new LinkedList<String>());\r\n                    new_parents.put(childKey, parentsList);\r\n                }\r\n                parentsList.add(g.getLocalKey());\r\n\r\n            }\r\n            \r\n            // new_children...\r\n            List<String> childrenList = Collections.synchronizedList(new LinkedList<String>());\r\n            for (String childKey : r.getKeysOfChildren()) {\r\n                // NB:  We're only interested in relationships between \r\n                // objects in the main catalog (i.e. new_groups);  \r\n                // discard everything else...\r\n                if (new_groups.containsKey(childKey)) {\r\n                    childrenList.add(childKey);\r\n                }\r\n            }\r\n            new_children.put(g.getLocalKey(), childrenList);\r\n            \r\n            // new_keysByUpperCaseName...\r\n            List<String> groupsWithMyName = new_keysByUpperCaseName.get(g.getName().toUpperCase());\r\n            if (groupsWithMyName == null) {\r\n                // I am the first group with my name (pretty likely)...\r\n                groupsWithMyName = Collections.synchronizedList(new LinkedList<String>());\r\n                new_keysByUpperCaseName.put(g.getName().toUpperCase(), groupsWithMyName);\r\n            }\r\n            groupsWithMyName.add(g.getLocalKey());\r\n            \r\n        }       \r\n        \r\n        /*\r\n         * Now load the ROOT_GROUP into the collections...\r\n         */\r\n\r\n        // new_groups (me)...\r\n        new_groups.put(ROOT_GROUP.getLocalKey(), ROOT_GROUP);\r\n\r\n        // new_parents (I am a parent for all groups that have no other parent)...\r\n        List<String> childrenOfRoot = Collections.synchronizedList(new LinkedList<String>());   // for later...\r\n        for (String possibleChildKey : new_groups.keySet()) {\r\n            if (!possibleChildKey.equals(ROOT_GROUP.getLocalKey()) && !new_parents.containsKey(possibleChildKey)) {\r\n                List<String> p = Collections.synchronizedList(new LinkedList<String>());\r\n                p.add(ROOT_GROUP.getLocalKey());\r\n                new_parents.put(possibleChildKey, p);\r\n                childrenOfRoot.add(possibleChildKey);   // for later...\r\n            }\r\n        }\r\n        \r\n        // new_children...\r\n        new_children.put(ROOT_GROUP.getLocalKey(), childrenOfRoot);\r\n        \r\n        // new_keysByUpperCaseName...\r\n        List<String> groupsWithMyName = new_keysByUpperCaseName.get(ROOT_GROUP.getName().toUpperCase());\r\n        if (groupsWithMyName == null) {\r\n            // I am the first group with my name (pretty likely)...\r\n            groupsWithMyName = Collections.synchronizedList(new LinkedList<String>());\r\n            new_keysByUpperCaseName.put(ROOT_GROUP.getName().toUpperCase(), groupsWithMyName);\r\n        }\r\n        groupsWithMyName.add(ROOT_GROUP.getLocalKey());\r\n\r\n        if (log.isInfoEnabled()) {\r\n            long benchmark = System.currentTimeMillis() - timestamp;\r\n            log.info(\"Refresh of groups tree completed in \" + benchmark + \" milliseconds\");\r\n            log.info(\"Total number of LDAP queries:  \" + (queryCounter.getCount() + 1));\r\n            String msg = \"init() :: final size of each collection is as follows...\"\r\n                            + \"\\n\\tgroups=\" + new_groups.size()\r\n                            + \"\\n\\tparents=\" + new_parents.size()\r\n                            + \"\\n\\tchildren=\" + new_children.size()\r\n                            + \"\\n\\tkeysByUpperCaseName=\" + new_keysByUpperCaseName.size();\r\n            log.info(msg);\r\n        }\r\n        \r\n        if (log.isTraceEnabled()) {\r\n            \r\n            StringBuilder msg = new StringBuilder();\r\n\r\n            // new_groups...\r\n            msg.setLength(0);\r\n            msg.append(\"Here are the keys of the new_groups collection:\");\r\n            for (String s : new_groups.keySet()) {\r\n                msg.append(\"\\n\\t\").append(s);\r\n            }\r\n            log.trace(msg.toString());\r\n            \r\n            // new_parents...\r\n            msg.setLength(0);\r\n            msg.append(\"Here are the parents of each child in the new_parents collection:\");\r\n            for (Map.Entry<String,List<String>> y : new_parents.entrySet()) {\r\n                msg.append(\"\\n\\tchild=\").append(y.getKey());\r\n                for (String s : y.getValue()) {\r\n                    msg.append(\"\\n\\t\\tparent=\").append(s);\r\n                }\r\n            }\r\n            log.trace(msg.toString());\r\n            \r\n            // new_children...\r\n            msg.setLength(0);\r\n            msg.append(\"Here are the children of each parent in the new_children collection:\");\r\n            for (Map.Entry<String,List<String>> y : new_children.entrySet()) {\r\n                msg.append(\"\\n\\tparent=\").append(y.getKey());\r\n                for (String s : y.getValue()) {\r\n                    msg.append(\"\\n\\t\\tchild=\").append(s);\r\n                }\r\n            }\r\n            log.trace(msg.toString());\r\n            \r\n            // new_keysByUpperCaseName...\r\n            msg.append(\"Here are the groups that have each name in the new_keysByUpperCaseName collection:\");\r\n            for (Map.Entry<String,List<String>> y : new_keysByUpperCaseName.entrySet()) {\r\n                msg.append(\"\\n\\tname=\").append(y.getKey());\r\n                for (String s : y.getValue()) {\r\n                    msg.append(\"\\n\\t\\tgroup=\").append(s);\r\n                }\r\n            }\r\n            log.trace(msg.toString());\r\n            \r\n        }\r\n\r\n        return new GroupsTree(new_groups, new_parents, new_children, new_keysByUpperCaseName);\r\n\r\n    }","id":989,"modified_method":"private GroupsTree buildGroupsTree() {\r\n        \r\n        long timestamp = System.currentTimeMillis();\r\n        \r\n        // Prepare the new local indeces...\r\n        Map<String,IEntityGroup> new_groups = Collections.synchronizedMap(new HashMap<String,IEntityGroup>());\r\n        Map<String,List<String>> new_parents = Collections.synchronizedMap(new HashMap<String,List<String>>());\r\n        Map<String,List<String>> new_children = Collections.synchronizedMap(new HashMap<String,List<String>>());\r\n        Map<String,List<String>> new_keysByUpperCaseName = Collections.synchronizedMap(new HashMap<String,List<String>>());\r\n\r\n        // Gather IEntityGroup objects from LDAP...\r\n        RuntimeRequestResponse req = new RuntimeRequestResponse();\r\n        Set<LdapRecord> set = new HashSet<>();\r\n        req.setAttribute(\"GROUPS\", set);\r\n        req.setAttribute(\"smartLdapGroupStore\", this);\r\n        SubQueryCounter queryCounter = new SubQueryCounter();\r\n        req.setAttribute(\"queryCounter\", queryCounter);\r\n        req.setAttribute(\"filter\", filter);         // This one changes iteratively...\r\n        req.setAttribute(\"baseFilter\", filter);     // while this one stays the same.\r\n        if (StringUtils.isBlank(baseGroupDn)) {\r\n            throw new IllegalStateException(\"baseGroupDn property not set\");\r\n        }\r\n        req.setAttribute(\"baseGroupDn\", baseGroupDn);\r\n        if (ldapContext == null) {\r\n            throw new IllegalStateException(\"ldapContext property not set\");\r\n        }\r\n        req.setAttribute(\"ldapContext\", ldapContext);\r\n        req.setAttribute(\"resolveMemberGroups\", resolveMemberGroups);\r\n        req.setAttribute(\"resolveDnList\", resolveDnList);\r\n        req.setAttribute(\"memberOfAttributeName\", memberOfAttributeName);\r\n        req.setAttribute(\"attributesMapper\", attributesMapper);\r\n        runner.run(initTask, req);\r\n        \r\n        log.info(\"init() found {} records\", set.size());\r\n\r\n        // Do a first loop to build the main catalog (new_groups)...\r\n        for (LdapRecord r : set) {\r\n            \r\n            // new_groups (me)...\r\n            IEntityGroup g = r.getGroup();\r\n            new_groups.put(g.getLocalKey(), g);\r\n\r\n        }\r\n        \r\n        // Do a second loop to build local indeces...\r\n        for (LdapRecord r : set) {\r\n\r\n            IEntityGroup g = r.getGroup();\r\n\r\n            // new_parents (I am a parent for all my children)...\r\n            for (String childKey : r.getKeysOfChildren()) {\r\n                \r\n                // NB:  We're only interested in relationships between \r\n                // objects in the main catalog (i.e. new_groups);  \r\n                // discard everything else...\r\n                if (!new_groups.containsKey(childKey)) {\r\n                    break;\r\n                }\r\n\r\n                List<String> parentsList = new_parents.get(childKey);\r\n                if (parentsList == null) {\r\n                    // first parent for this child...\r\n                    parentsList = Collections.synchronizedList(new LinkedList<String>());\r\n                    new_parents.put(childKey, parentsList);\r\n                }\r\n                parentsList.add(g.getLocalKey());\r\n\r\n            }\r\n            \r\n            // new_children...\r\n            List<String> childrenList = Collections.synchronizedList(new LinkedList<String>());\r\n            for (String childKey : r.getKeysOfChildren()) {\r\n                // NB:  We're only interested in relationships between \r\n                // objects in the main catalog (i.e. new_groups);  \r\n                // discard everything else...\r\n                if (new_groups.containsKey(childKey)) {\r\n                    childrenList.add(childKey);\r\n                }\r\n            }\r\n            new_children.put(g.getLocalKey(), childrenList);\r\n            \r\n            // new_keysByUpperCaseName...\r\n            List<String> groupsWithMyName = new_keysByUpperCaseName.get(g.getName().toUpperCase());\r\n            if (groupsWithMyName == null) {\r\n                // I am the first group with my name (pretty likely)...\r\n                groupsWithMyName = Collections.synchronizedList(new LinkedList<String>());\r\n                new_keysByUpperCaseName.put(g.getName().toUpperCase(), groupsWithMyName);\r\n            }\r\n            groupsWithMyName.add(g.getLocalKey());\r\n            \r\n        }       \r\n        \r\n        /*\r\n         * Now load the ROOT_GROUP into the collections...\r\n         */\r\n\r\n        // new_groups (me)...\r\n        final IEntityGroup root = getRootGroup();\r\n        new_groups.put(root.getLocalKey(), root);\r\n\r\n        // new_parents (I am a parent for all groups that have no other parent)...\r\n        List<String> childrenOfRoot = Collections.synchronizedList(new LinkedList<String>());   // for later...\r\n        for (String possibleChildKey : new_groups.keySet()) {\r\n            if (!possibleChildKey.equals(root.getLocalKey()) && !new_parents.containsKey(possibleChildKey)) {\r\n                List<String> p = Collections.synchronizedList(new LinkedList<String>());\r\n                p.add(root.getLocalKey());\r\n                new_parents.put(possibleChildKey, p);\r\n                childrenOfRoot.add(possibleChildKey);   // for later...\r\n            }\r\n        }\r\n        \r\n        // new_children...\r\n        new_children.put(root.getLocalKey(), childrenOfRoot);\r\n        \r\n        // new_keysByUpperCaseName...\r\n        List<String> groupsWithMyName = new_keysByUpperCaseName.get(root.getName().toUpperCase());\r\n        if (groupsWithMyName == null) {\r\n            // I am the first group with my name (pretty likely)...\r\n            groupsWithMyName = Collections.synchronizedList(new LinkedList<String>());\r\n            new_keysByUpperCaseName.put(root.getName().toUpperCase(), groupsWithMyName);\r\n        }\r\n        groupsWithMyName.add(root.getLocalKey());\r\n\r\n        final long benchmark = System.currentTimeMillis() - timestamp;\r\n        log.info(\"Refresh of groups tree completed in {} milliseconds\", benchmark);\r\n        log.info(\"Total number of LDAP queries:  {}\", queryCounter.getCount() + 1);\r\n        final String msg = \"init() :: final size of each collection is as follows...\"\r\n                        + \"\\n\\tgroups={}\"\r\n                        + \"\\n\\tparents={}\"\r\n                        + \"\\n\\tchildren={}\"\r\n                        + \"\\n\\tkeysByUpperCaseName={}\";\r\n        log.info(msg, new_groups.size(), new_parents.size(), new_children.size(), new_keysByUpperCaseName.size());\r\n\r\n        if (log.isTraceEnabled()) {\r\n            \r\n            StringBuilder sbuilder = new StringBuilder();\r\n\r\n            // new_groups...\r\n            sbuilder.setLength(0);\r\n            sbuilder.append(\"Here are the keys of the new_groups collection:\");\r\n            for (String s : new_groups.keySet()) {\r\n                sbuilder.append(\"\\n\\t\").append(s);\r\n            }\r\n            log.trace(sbuilder.toString());\r\n            \r\n            // new_parents...\r\n            sbuilder.setLength(0);\r\n            sbuilder.append(\"Here are the parents of each child in the new_parents collection:\");\r\n            for (Map.Entry<String,List<String>> y : new_parents.entrySet()) {\r\n                sbuilder.append(\"\\n\\tchild=\").append(y.getKey());\r\n                for (String s : y.getValue()) {\r\n                    sbuilder.append(\"\\n\\t\\tparent=\").append(s);\r\n                }\r\n            }\r\n            log.trace(sbuilder.toString());\r\n            \r\n            // new_children...\r\n            sbuilder.setLength(0);\r\n            sbuilder.append(\"Here are the children of each parent in the new_children collection:\");\r\n            for (Map.Entry<String,List<String>> y : new_children.entrySet()) {\r\n                sbuilder.append(\"\\n\\tparent=\").append(y.getKey());\r\n                for (String s : y.getValue()) {\r\n                    sbuilder.append(\"\\n\\t\\tchild=\").append(s);\r\n                }\r\n            }\r\n            log.trace(sbuilder.toString());\r\n            \r\n            // new_keysByUpperCaseName...\r\n            sbuilder.append(\"Here are the groups that have each name in the new_keysByUpperCaseName collection:\");\r\n            for (Map.Entry<String,List<String>> y : new_keysByUpperCaseName.entrySet()) {\r\n                sbuilder.append(\"\\n\\tname=\").append(y.getKey());\r\n                for (String s : y.getValue()) {\r\n                    sbuilder.append(\"\\n\\t\\tgroup=\").append(s);\r\n                }\r\n            }\r\n            log.trace(sbuilder.toString());\r\n            \r\n        }\r\n\r\n        return new GroupsTree(new_groups, new_parents, new_children, new_keysByUpperCaseName);\r\n\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\r\n     * Returns an instance of the <code>IEntityGroup<\/code> from the data store.\r\n     * @return org.jasig.portal.groups.IEntityGroup\r\n     * @param key java.lang.String\r\n     */\r\n    public IEntityGroup find(String key) throws GroupsException {\r\n    \t\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tif (log.isDebugEnabled()) {\r\n    \t\tlog.debug(\"Invoking find() for key:  \" + key);\r\n    \t}\r\n    \t\r\n    \t// All of our groups (incl. ROOT_GROUP) \r\n    \t// are indexed in the 'groups' map by key...\r\n    \treturn groupsTree.getGroups().get(key);\r\n    \r\n    }","id":990,"modified_method":"/**\r\n     * Returns an instance of the <code>IEntityGroup<\/code> from the data store.\r\n     * @return org.jasig.portal.groups.IEntityGroup\r\n     * @param key java.lang.String\r\n     */\r\n    public IEntityGroup find(String key) throws GroupsException {\r\n    \t\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tlog.debug(\"Invoking find() for key:  {}\", key);\r\n\r\n    \t// All of our groups (incl. ROOT_GROUP) \r\n    \t// are indexed in the 'groups' map by key...\r\n    \treturn groupsTree.getGroups().get(key);\r\n    \r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IEntityGroupStore newGroupStore() throws GroupsException {\r\n            return INSTANCE;\r\n        }","id":991,"modified_method":"public IEntityGroupStore newGroupStore() throws GroupsException {\r\n            return instance;\r\n        }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"public IEntityGroupStore newGroupStore(ComponentGroupServiceDescriptor svcDescriptor) throws GroupsException {\r\n            return INSTANCE;\r\n        }","id":992,"modified_method":"public IEntityGroupStore newGroupStore(ComponentGroupServiceDescriptor svcDescriptor) throws GroupsException {\r\n            return instance;\r\n        }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"public EntityIdentifier[] searchForGroups(String query, int method, Class leaftype) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tif (log.isDebugEnabled()) {\r\n    \t\tlog.debug(\"Invoking searchForGroups():  query=\" + query + \", method=\" \r\n    \t\t\t\t+ method + \", leaftype=\" + leaftype.getClass().getName());\r\n    \t}\r\n\r\n    \t// We only match the IPerson leaf type...\r\n    \tif (!leaftype.equals(ROOT_GROUP.getEntityType())) {\r\n    \t\treturn new EntityIdentifier[0];\r\n    \t}\r\n    \t\r\n    \t// We need to escape regex special characters that appear in the query string...\r\n    \tfinal String[][] specials = new String[][] {\r\n    \t                    /* backslash must come first! */\r\n    \t                    new String[] { \"\\\\\", \"\\\\\\\\\"}, \r\n    \t                    new String[] { \"[\", \"\\\\[\" }, \r\n                            /* closing ']' isn't needed b/c it's a normal character w/o a preceding '[' */\r\n    \t                    new String[] { \"{\", \"\\\\{\" }, \r\n                            /* closing '}' isn't needed b/c it's a normal character w/o a preceding '{' */\r\n    \t                    new String[] { \"^\", \"\\\\^\" },\r\n    \t                    new String[] { \"$\", \"\\\\$\" },\r\n    \t                    new String[] { \".\", \"\\\\.\" },\r\n    \t                    new String[] { \"|\", \"\\\\|\" },\r\n    \t                    new String[] { \"?\", \"\\\\?\" },\r\n    \t                    new String[] { \"*\", \"\\\\*\" },\r\n    \t                    new String[] { \"+\", \"\\\\+\" },\r\n    \t                    new String[] { \"(\", \"\\\\(\" },\r\n    \t                    new String[] { \")\", \"\\\\)\" }\r\n    \t                };\r\n    \tfor (String[] s : specials) {\r\n    \t    query = query.replace(s[0], s[1]);\r\n    \t}\r\n    \t\r\n    \t// Establish the regex pattern to match on...\r\n    \tString regex = null;\r\n    \tswitch (method) {\r\n    \t\tcase IGroupConstants.IS:\r\n    \t\t\tregex = query.toUpperCase();\r\n    \t\t\tbreak;\r\n    \t\tcase IGroupConstants.STARTS_WITH:\r\n    \t\t\tregex = query.toUpperCase() + \".*\";\r\n    \t\t\tbreak;\r\n    \t\tcase IGroupConstants.ENDS_WITH: \r\n    \t\t\tregex = \".*\" + query.toUpperCase();\r\n    \t\t\tbreak;\r\n    \t\tcase IGroupConstants.CONTAINS: \r\n    \t\t\tregex = \".*\" + query.toUpperCase() + \".*\";\r\n    \t\t\tbreak;\r\n    \t\tdefault:\r\n    \t\t\tString msg = \"Unsupported search method:  \" + method;\r\n    \t\t\tthrow new GroupsException(msg);\r\n    \t}\r\n    \t\r\n    \tList<EntityIdentifier> rslt = new LinkedList<EntityIdentifier>(); \r\n    \tfor (Map.Entry<String,List<String>> y : groupsTree.getKeysByUpperCaseName().entrySet()) {\r\n    \t\tif (y.getKey().matches(regex)) {\r\n    \t\t\tList<String> keys = y.getValue();\r\n    \t\t\tfor (String k : keys) {\r\n    \t\t\t\trslt.add(new EntityIdentifier(k, IEntityGroup.class));\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn rslt.toArray(new EntityIdentifier[0]);\r\n\r\n    }","id":993,"modified_method":"public EntityIdentifier[] searchForGroups(String query, int method, Class leaftype) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tlog.debug(\"Invoking searchForGroups():  query={}, method={}, leaftype=\",\r\n                            query, method, leaftype.getClass().getName());\r\n\r\n    \t// We only match the IPerson leaf type...\r\n        final IEntityGroup root = getRootGroup();\r\n    \tif (!leaftype.equals(root.getEntityType())) {\r\n    \t\treturn new EntityIdentifier[0];\r\n    \t}\r\n    \t\r\n    \t// We need to escape regex special characters that appear in the query string...\r\n    \tfinal String[][] specials = new String[][] {\r\n    \t                    /* backslash must come first! */\r\n    \t                    new String[] { \"\\\\\", \"\\\\\\\\\"}, \r\n    \t                    new String[] { \"[\", \"\\\\[\" }, \r\n                            /* closing ']' isn't needed b/c it's a normal character w/o a preceding '[' */\r\n    \t                    new String[] { \"{\", \"\\\\{\" }, \r\n                            /* closing '}' isn't needed b/c it's a normal character w/o a preceding '{' */\r\n    \t                    new String[] { \"^\", \"\\\\^\" },\r\n    \t                    new String[] { \"$\", \"\\\\$\" },\r\n    \t                    new String[] { \".\", \"\\\\.\" },\r\n    \t                    new String[] { \"|\", \"\\\\|\" },\r\n    \t                    new String[] { \"?\", \"\\\\?\" },\r\n    \t                    new String[] { \"*\", \"\\\\*\" },\r\n    \t                    new String[] { \"+\", \"\\\\+\" },\r\n    \t                    new String[] { \"(\", \"\\\\(\" },\r\n    \t                    new String[] { \")\", \"\\\\)\" }\r\n    \t                };\r\n    \tfor (String[] s : specials) {\r\n    \t    query = query.replace(s[0], s[1]);\r\n    \t}\r\n    \t\r\n    \t// Establish the regex pattern to match on...\r\n    \tString regex;\r\n    \tswitch (method) {\r\n    \t\tcase IGroupConstants.IS:\r\n    \t\t\tregex = query.toUpperCase();\r\n    \t\t\tbreak;\r\n    \t\tcase IGroupConstants.STARTS_WITH:\r\n    \t\t\tregex = query.toUpperCase() + \".*\";\r\n    \t\t\tbreak;\r\n    \t\tcase IGroupConstants.ENDS_WITH: \r\n    \t\t\tregex = \".*\" + query.toUpperCase();\r\n    \t\t\tbreak;\r\n    \t\tcase IGroupConstants.CONTAINS: \r\n    \t\t\tregex = \".*\" + query.toUpperCase() + \".*\";\r\n    \t\t\tbreak;\r\n    \t\tdefault:\r\n    \t\t\tString msg = \"Unsupported search method:  \" + method;\r\n    \t\t\tthrow new GroupsException(msg);\r\n    \t}\r\n    \t\r\n    \tList<EntityIdentifier> rslt = new LinkedList<>();\r\n    \tfor (Map.Entry<String,List<String>> y : groupsTree.getKeysByUpperCaseName().entrySet()) {\r\n    \t\tif (y.getKey().matches(regex)) {\r\n    \t\t\tList<String> keys = y.getValue();\r\n    \t\t\tfor (String k : keys) {\r\n    \t\t\t\trslt.add(new EntityIdentifier(k, IEntityGroup.class));\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn rslt.toArray(new EntityIdentifier[rslt.size()]);\r\n\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"public LdapRecord detectAndEliminateGroupReferences(LdapRecord record, List<String> groupChain) {\r\n        \r\n        LdapRecord rslt = record;  // default\r\n        \r\n        List<String> keysOfChildren = record.getKeysOfChildren();\r\n        List<String> filteredChildren = new ArrayList<String>();\r\n        for (String key : keysOfChildren) {\r\n            if (!groupChain.contains(key)) {\r\n                filteredChildren.add(key);\r\n            } else {\r\n                // Circular reference detected!\r\n                StringBuilder msg = new StringBuilder();\r\n                msg.append(\"Circular reference detected and removed for the following groups:  '\")\r\n                                                .append(key).append(\"' and '\")\r\n                                                .append(record.getGroup().getLocalKey()).append(\"'\");\r\n                log.warn(msg.toString());\r\n            }\r\n        }\r\n        if (filteredChildren.size() < keysOfChildren.size()) {\r\n            rslt = new LdapRecord(record.getGroup(), filteredChildren);\r\n        }\r\n        \r\n        return rslt;\r\n\r\n    }","id":994,"modified_method":"@SuppressWarnings(\"unused\")\r\n    public LdapRecord detectAndEliminateGroupReferences(LdapRecord record, List<String> groupChain) {\r\n        \r\n        LdapRecord rslt = record;  // default\r\n        \r\n        List<String> keysOfChildren = record.getKeysOfChildren();\r\n        List<String> filteredChildren = new ArrayList<>();\r\n        for (String key : keysOfChildren) {\r\n            if (!groupChain.contains(key)) {\r\n                filteredChildren.add(key);\r\n            } else {\r\n                // Circular reference detected!\r\n                log.warn(\"Circular reference detected and removed for the following groups:  '{}' and '{}'\",\r\n                                                                key, record.getGroup().getLocalKey());\r\n            }\r\n        }\r\n        if (filteredChildren.size() < keysOfChildren.size()) {\r\n            rslt = new LdapRecord(record.getGroup(), filteredChildren);\r\n        }\r\n        \r\n        return rslt;\r\n\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntities<\/code> that are members of this <code>IEntityGroup<\/code>.\r\n     * @return java.util.Iterator\r\n     * @param group org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findEntitiesForGroup(IEntityGroup group) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tif (log.isDebugEnabled()) {\r\n    \t\tlog.debug(\"Invoking findEntitiesForGroup() for group:  \" + group.getLocalKey());\r\n    \t}\r\n    \t\r\n    \t// We only deal w/ group-group relationships here...\r\n    \treturn findMemberGroups(group);\r\n        \r\n    }","id":995,"modified_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntities<\/code> that are members of this <code>IEntityGroup<\/code>.\r\n     * @return java.util.Iterator\r\n     * @param group org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findEntitiesForGroup(IEntityGroup group) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tlog.debug(\"Invoking findEntitiesForGroup() for group:  {}\", group.getLocalKey());\r\n\r\n    \t// We only deal w/ group-group relationships here...\r\n    \treturn findMemberGroups(group);\r\n        \r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntityGroups<\/code> that the <code>IGroupMember<\/code> belongs to.\r\n     * @return java.util.Iterator\r\n     * @param gm org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findContainingGroups(IGroupMember gm) throws GroupsException {\r\n    \t\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tList<IEntityGroup> rslt = new LinkedList<IEntityGroup>();\r\n    \tif (gm.isGroup()) {\t\t\r\n    \t    // Check the local indeces...\r\n    \t\tIEntityGroup group = (IEntityGroup) gm;\r\n    \t\tList<String> list = groupsTree.getParents().get(group.getLocalKey());\r\n    \t\tif (list != null) {\r\n    \t\t\t// should only reach this code if its a SmartLdap managed group...\r\n        \t\tfor (String s : list) {\r\n        \t\t\trslt.add(groupsTree.getGroups().get(s));\r\n        \t\t}\r\n    \t\t}\r\n    \t} else if (gm.isEntity() && gm.getEntityType().equals(ROOT_GROUP.getEntityType())) {\t\r\n    \t    \r\n    \t    // Ask the individual...\r\n    \t\tEntityIdentifier ei = gm.getUnderlyingEntityIdentifier();\r\n    \t\tMap<String,List<Object>> seed = new HashMap<String,List<Object>>();\r\n    \t\tList<Object> seedValue = new LinkedList<Object>();\r\n    \t\tseedValue.add(ei.getKey());\r\n    \t\tseed.put(IPerson.USERNAME, seedValue);\r\n    \t\tMap<String,List<Object>> attr = PersonAttributeDaoLocator.getPersonAttributeDao().getMultivaluedUserAttributes(seed);\r\n            // avoid NPEs and unnecessary IPerson creation\r\n            if (attr != null && !attr.isEmpty()) {\r\n                IPerson p = PersonFactory.createPerson();\r\n                p.setAttributes(attr);\r\n\r\n                // Analyze its memberships...\r\n                String attrName = (String) spring_context.getBean(\"memberOfAttributeName\");\r\n                Object groupKeys = p.getAttributeValues(attrName);\r\n                // IPerson returns null if no value is defined for this attribute...\r\n                if (groupKeys != null) {\r\n\r\n                    List<String> list = new LinkedList<String>();\r\n                    if (groupKeys instanceof Object[]) {\r\n                        Object[] objs = (Object[]) groupKeys;\r\n                        for (Object o : objs) {\r\n                            list.add((String) o);\r\n                        }\r\n                    } else if (groupKeys instanceof List) {\r\n                        List<?> objs = (List<?>) groupKeys;\r\n                        for (Object o : objs) {\r\n                            list.add((String) o);\r\n                        }\r\n                    }\r\n\r\n                    for (String s : list) {\r\n                        if (groupsTree.getGroups().containsKey(s)) {\r\n                            rslt.add(groupsTree.getGroups().get(s));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n    \t}\r\n    \t\r\n    \treturn rslt.iterator();\r\n    \t\r\n    }","id":996,"modified_method":"/**\r\n     * Returns an <code>Iterator<\/code> over the <code>Collection<\/code> of\r\n     * <code>IEntityGroups<\/code> that the <code>IGroupMember<\/code> belongs to.\r\n     * @return java.util.Iterator\r\n     * @param gm org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public Iterator findContainingGroups(IGroupMember gm) throws GroupsException {\r\n    \t\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tList<IEntityGroup> rslt = new LinkedList<>();\r\n        final IEntityGroup root = getRootGroup();\r\n    \tif (gm.isGroup()) {\r\n    \t    // Check the local indeces...\r\n    \t\tIEntityGroup group = (IEntityGroup) gm;\r\n    \t\tList<String> list = groupsTree.getParents().get(group.getLocalKey());\r\n    \t\tif (list != null) {\r\n    \t\t\t// should only reach this code if its a SmartLdap managed group...\r\n        \t\tfor (String s : list) {\r\n        \t\t\trslt.add(groupsTree.getGroups().get(s));\r\n        \t\t}\r\n    \t\t}\r\n    \t} else if (gm.isEntity() && gm.getEntityType().equals(root.getEntityType())) {\r\n    \t    \r\n    \t    // Ask the individual...\r\n    \t\tEntityIdentifier ei = gm.getUnderlyingEntityIdentifier();\r\n    \t\tMap<String,List<Object>> seed = new HashMap<>();\r\n    \t\tList<Object> seedValue = new LinkedList<>();\r\n    \t\tseedValue.add(ei.getKey());\r\n    \t\tseed.put(IPerson.USERNAME, seedValue);\r\n    \t\tMap<String,List<Object>> attr = personAttributeDao.getMultivaluedUserAttributes(seed);\r\n            // avoid NPEs and unnecessary IPerson creation\r\n            if (attr != null && !attr.isEmpty()) {\r\n                IPerson p = PersonFactory.createPerson();\r\n                p.setAttributes(attr);\r\n\r\n                // Analyze its memberships...\r\n                Object[] groupKeys = p.getAttributeValues(memberOfAttributeName);\r\n                // IPerson returns null if no value is defined for this attribute...\r\n                if (groupKeys != null) {\r\n\r\n                    List<String> list = new LinkedList<>();\r\n                    for (Object o : groupKeys) {\r\n                        list.add((String) o);\r\n                    }\r\n\r\n                    for (String s : list) {\r\n                        if (groupsTree.getGroups().containsKey(s)) {\r\n                            rslt.add(groupsTree.getGroups().get(s));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n    \t}\r\n    \t\r\n    \treturn rslt.iterator();\r\n    \t\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean hasUndiscoveredChildrenWithinDn(LdapRecord record, String baseDn, Set<LdapRecord> groupsSet) {\r\n        \r\n        boolean rslt = false;  // default\r\n\r\n        for (String childKey : record.getKeysOfChildren()) {\r\n            if (childKey.endsWith(baseDn)) {\r\n                // Make sure the one we found isn't already in the groupsSet;  \r\n                // NOTE!... this test takes advantage of the implementation of \r\n                // equals() on LdapRecord, which states that 2 records with the \r\n                // same group key are equal.\r\n                IEntityGroup group = new EntityGroupImpl(childKey, IPerson.class);\r\n                List<String> list = Collections.emptyList();\r\n                LdapRecord proxy = new LdapRecord(group, list);\r\n                if (!groupsSet.contains(proxy)) {\r\n                    rslt = true;\r\n                    break;\r\n                } else {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"Child group is already in collection:  \" + childKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Query for children of parent group '\" + record.getGroup().getLocalKey() + \"':  \" + rslt);\r\n        }\r\n\r\n        return rslt;\r\n        \r\n    }","id":997,"modified_method":"@SuppressWarnings(\"unused\")\r\n    public boolean hasUndiscoveredChildrenWithinDn(LdapRecord record, String referenceDn, Set<LdapRecord> groupsSet) {\r\n        \r\n        boolean rslt = false;  // default\r\n\r\n        for (String childKey : record.getKeysOfChildren()) {\r\n            if (childKey.endsWith(referenceDn)) {\r\n                // Make sure the one we found isn't already in the groupsSet;  \r\n                // NOTE!... this test takes advantage of the implementation of \r\n                // equals() on LdapRecord, which states that 2 records with the \r\n                // same group key are equal.\r\n                IEntityGroup group = new EntityGroupImpl(childKey, IPerson.class);\r\n                List<String> list = Collections.emptyList();\r\n                LdapRecord proxy = new LdapRecord(group, list);\r\n                if (!groupsSet.contains(proxy)) {\r\n                    rslt = true;\r\n                    break;\r\n                } else {\r\n                    log.trace(\"Child group is already in collection:  {}\", childKey);\r\n                }\r\n            }\r\n        }\r\n        \r\n        log.trace(\"Query for children of parent group '{}':  {}\", record.getGroup().getLocalKey(), rslt);\r\n\r\n        return rslt;\r\n        \r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\r\n     * Returns a <code>String[]<\/code> containing the keys of  <code>IEntityGroups<\/code>\r\n     * that are members of this <code>IEntityGroup<\/code>.  In a composite group\r\n     * system, a group may contain a member group from a different service.  This is\r\n     * called a foreign membership, and is only possible in an internally-managed\r\n     * service.  A group store in such a service can return the key of a foreign member\r\n     * group, but not the group itself, which can only be returned by its local store.\r\n     *\r\n     * @return String[]\r\n     * @param group org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public String[] findMemberGroupKeys(IEntityGroup group) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tif (log.isDebugEnabled()) {\r\n    \t\tlog.debug(\"Invoking findMemberGroupKeys() for group:  \" + group.getLocalKey());\r\n    \t}\r\n\r\n    \tList<String> rslt = new LinkedList<String>();\r\n    \tfor (Iterator it=findMemberGroups(group); it.hasNext();) {\r\n    \t\tIEntityGroup g = (IEntityGroup) it.next();\r\n    \t\t// Return composite keys here...\r\n    \t\trslt.add(g.getKey());\r\n    \t}\r\n    \t\r\n    \treturn rslt.toArray(new String[0]);\r\n    \t\r\n    }","id":998,"modified_method":"/**\r\n     * Returns a <code>String[]<\/code> containing the keys of  <code>IEntityGroups<\/code>\r\n     * that are members of this <code>IEntityGroup<\/code>.  In a composite group\r\n     * system, a group may contain a member group from a different service.  This is\r\n     * called a foreign membership, and is only possible in an internally-managed\r\n     * service.  A group store in such a service can return the key of a foreign member\r\n     * group, but not the group itself, which can only be returned by its local store.\r\n     *\r\n     * @return String[]\r\n     * @param group org.jasig.portal.groups.IEntityGroup\r\n     */\r\n    public String[] findMemberGroupKeys(IEntityGroup group) throws GroupsException {\r\n\r\n    \tif (isTreeRefreshRequired()) {\r\n    \t\trefreshTree();\r\n    \t}\r\n\r\n    \tlog.debug(\"Invoking findMemberGroupKeys() for group:  {}\", group.getLocalKey());\r\n\r\n    \tList<String> rslt = new LinkedList<>();\r\n    \tfor (Iterator it=findMemberGroups(group); it.hasNext();) {\r\n    \t\tIEntityGroup g = (IEntityGroup) it.next();\r\n    \t\t// Return composite keys here...\r\n    \t\trslt.add(g.getKey());\r\n    \t}\r\n    \t\r\n    \treturn rslt.toArray(new String[rslt.size()]);\r\n    \t\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"},{"original_method":"private static IEntityGroup createRootGroup() {\r\n        \r\n        IEntityGroup rslt = new EntityTestingGroupImpl(ROOT_KEY, IPerson.class);\r\n        rslt.setCreatorID(\"System\");\r\n        rslt.setName(ROOT_KEY);\r\n        rslt.setDescription(ROOT_DESC);\r\n        \r\n        return rslt;\r\n\r\n    }","id":999,"modified_method":"private IEntityGroup getRootGroup() {\r\n        try {\r\n            return rootGroupInitializer.get();\r\n        } catch (ConcurrentException ce) {\r\n            throw new RuntimeException(\"Failed to obtain the SmartLdap root group\", ce);\r\n        }\r\n    }","commit_id":"b26738a5b1d386fa23a7489f76a208b3caf23020","url":"https://github.com/Jasig/uPortal"}]