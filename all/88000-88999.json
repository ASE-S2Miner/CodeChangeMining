[{"original_method":"public String open() {\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n\t\tprops.setLook(shell);\r\n\t\tsetShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() {\r\n\t\t\tpublic void modifyText(ModifyEvent e) {\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\r\n\t\tFormLayout formLayout = new FormLayout();\r\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.DialogTitle\"));\r\n\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Stepname line\r\n\t\twlStepname = new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\r\n\t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname = new FormData();\r\n\t\tfdlStepname.left = new FormAttachment(0, 0);\r\n\t\tfdlStepname.top = new FormAttachment(0, margin);\r\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n\t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname = new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top = new FormAttachment(0, margin);\r\n\t\tfdStepname.right = new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n\t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\t\t\r\n\t\t\r\n\r\n\t\t// ////////////////////////\r\n\t\t// START OF FILE TAB ///\r\n\t\t// ////////////////////////\r\n\t\twFileTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFileTab.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.File.Tab\"));\r\n\r\n\t\twFileComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\tprops.setLook(wFileComp);\r\n\r\n\t\tFormLayout fileLayout = new FormLayout();\r\n\t\tfileLayout.marginWidth = 3;\r\n\t\tfileLayout.marginHeight = 3;\r\n\t\twFileComp.setLayout(fileLayout);\r\n\t\t\r\n\t\t\r\n        //////////////////////////\r\n        // START CONNECTION GROUP\r\n\r\n        wConnectionGroup = new Group(wFileComp, SWT.SHADOW_ETCHED_IN);\r\n        wConnectionGroup.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ConnectionGroup.Label\")); //$NON-NLS-1$;\r\n        FormLayout fconnLayout = new FormLayout();\r\n        fconnLayout .marginWidth = 3;\r\n        fconnLayout .marginHeight = 3;\r\n        wConnectionGroup.setLayout(fconnLayout );\r\n        props.setLook(wConnectionGroup);\r\n\t\t\r\n\t      // Webservice URL\r\n        wURL = new LabelTextVar(transMeta,wConnectionGroup, BaseMessages.getString(PKG, \"SalesforceInputDialog.URL.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.URL.Tooltip\"));\r\n        props.setLook(wURL);\r\n        wURL.addModifyListener(lsMod);\r\n        fdURL = new FormData();\r\n        fdURL.left = new FormAttachment(0, 0);\r\n        fdURL.top = new FormAttachment(0, margin);\r\n        fdURL.right = new FormAttachment(100, 0);\r\n        wURL.setLayoutData(fdURL);\r\n        \r\n\r\n\t      // UserName line\r\n        wUserName = new LabelTextVar(transMeta,wConnectionGroup, BaseMessages.getString(PKG, \"SalesforceInputDialog.User.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.User.Tooltip\"));\r\n        props.setLook(wUserName);\r\n        wUserName.addModifyListener(lsMod);\r\n        fdUserName = new FormData();\r\n        fdUserName.left = new FormAttachment(0, 0);\r\n        fdUserName.top = new FormAttachment(wURL, margin);\r\n        fdUserName.right = new FormAttachment(100, 0);\r\n        wUserName.setLayoutData(fdUserName);\r\n\t\t\r\n        // Password line\r\n        wPassword = new LabelTextVar(transMeta,wConnectionGroup, BaseMessages.getString(PKG, \"SalesforceInputDialog.Password.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.Password.Tooltip\"));\r\n        props.setLook(wPassword);\r\n        //wPassword.setEchoChar('*');\r\n        wPassword.addModifyListener(lsMod);\r\n        fdPassword = new FormData();\r\n        fdPassword.left = new FormAttachment(0, 0);\r\n        fdPassword.top = new FormAttachment(wUserName, margin);\r\n        fdPassword.right = new FormAttachment(100, 0);\r\n        wPassword.setLayoutData(fdPassword);\r\n\r\n        // OK, if the password contains a variable, we don't want to have the password hidden...\r\n        wPassword.getTextWidget().addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                checkPasswordVisible();\r\n            }\r\n        });\r\n\r\n\t\t// Test Salesforce connection button\r\n\t\twTest=new Button(wConnectionGroup,SWT.PUSH);\r\n\t\twTest.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.TestConnection.Label\"));\r\n \t\tprops.setLook(wTest);\r\n\t\tfdTest=new FormData();\r\n\t\twTest.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.TestConnection.Tooltip\"));\r\n\t\t//fdTest.left = new FormAttachment(middle, 0);\r\n\t\tfdTest.top  = new FormAttachment(wPassword, margin);\r\n\t\tfdTest.right= new FormAttachment(100, 0);\r\n\t\twTest.setLayoutData(fdTest);\r\n\t\t\r\n        FormData fdConnectionGroup= new FormData();\r\n        fdConnectionGroup.left = new FormAttachment(0, 0);\r\n        fdConnectionGroup.right = new FormAttachment(100, 0);\r\n        fdConnectionGroup.top = new FormAttachment(0, margin);\r\n        wConnectionGroup.setLayoutData(fdConnectionGroup);\r\n\r\n        // END CONNECTION  GROUP\r\n        //////////////////////////\r\n\t\t\r\n        //////////////////////////\r\n        // START SETTINGS GROUP\r\n\r\n        wSettingsGroup = new Group(wFileComp, SWT.SHADOW_ETCHED_IN);\r\n        wSettingsGroup.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.HttpAuthGroup.Label\")); //$NON-NLS-1$;\r\n        FormLayout fsettingsLayout = new FormLayout();\r\n        fsettingsLayout .marginWidth = 3;\r\n        fsettingsLayout .marginHeight = 3;\r\n        wSettingsGroup.setLayout(fsettingsLayout );\r\n        props.setLook(wSettingsGroup);\r\n        \r\n        wlspecifyQuery = new Label(wSettingsGroup, SWT.RIGHT);\r\n\t\twlspecifyQuery.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.specifyQuery.Label\"));\r\n\t\tprops.setLook(wlspecifyQuery);\r\n\t\tfdlspecifyQuery = new FormData();\r\n\t\tfdlspecifyQuery.left = new FormAttachment(0, 0);\r\n\t\tfdlspecifyQuery.top = new FormAttachment(wConnectionGroup, 2*margin);\r\n\t\tfdlspecifyQuery.right = new FormAttachment(middle, -margin);\r\n\t\twlspecifyQuery.setLayoutData(fdlspecifyQuery);\r\n\t\twspecifyQuery = new Button(wSettingsGroup, SWT.CHECK);\r\n\t\tprops.setLook(wspecifyQuery);\r\n\t\twspecifyQuery.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.specifyQuery.Tooltip\"));\r\n\t\tfdspecifyQuery = new FormData();\r\n\t\tfdspecifyQuery.left = new FormAttachment(middle, 0);\r\n\t\tfdspecifyQuery.top = new FormAttachment(wConnectionGroup, 2*margin);\r\n\t\twspecifyQuery.setLayoutData(fdspecifyQuery);\r\n\t\twspecifyQuery.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableQuery();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n        \r\n \t\t// Module\r\n\t\twlModule=new Label(wSettingsGroup, SWT.RIGHT);\r\n        wlModule.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Module.Label\"));\r\n        props.setLook(wlModule);\r\n        fdlModule=new FormData();\r\n        fdlModule.left = new FormAttachment(0, 0);\r\n        fdlModule.top  = new FormAttachment(wspecifyQuery, margin);\r\n        fdlModule.right= new FormAttachment(middle, -margin);\r\n        wlModule.setLayoutData(fdlModule);\r\n        wModule=new ComboVar(transMeta,wSettingsGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wModule.setEditable(true);\r\n        props.setLook(wModule);\r\n        wModule.addModifyListener(lsMod);\r\n        fdModule=new FormData();\r\n        fdModule.left = new FormAttachment(middle, margin);\r\n        fdModule.top  = new FormAttachment(wspecifyQuery, margin);\r\n        fdModule.right= new FormAttachment(100, -margin);\r\n        wModule.setLayoutData(fdModule);\r\n        wModule.addFocusListener(new FocusListener()\r\n        {\r\n            public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n            {\r\n            \tgetModulesListError = false;\r\n            }\r\n        \r\n            public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n            {\r\n                // check if the URL and login credentials passed and not just had error \r\n            \tif (Const.isEmpty(wURL.getText()) || \r\n               \t\tConst.isEmpty(wUserName.getText()) ||\r\n            \t\tConst.isEmpty(wPassword.getText()) ||\r\n            \t\t(getModulesListError )) return; \r\n\r\n\r\n                Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                shell.setCursor(busy);\r\n                getModulesList();\r\n                shell.setCursor(null);\r\n                busy.dispose();\r\n            }\r\n        }\r\n    );\r\n\r\n       \r\n\t    // condition\r\n        wlCondition = new Label(wSettingsGroup, SWT.RIGHT);\r\n        wlCondition.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Condition.Label\"));\r\n        props.setLook(wlCondition);\r\n        fdlCondition = new FormData();\r\n        fdlCondition.left = new FormAttachment(0, -margin);\r\n        fdlCondition.top = new FormAttachment(wModule, margin);\r\n        fdlCondition.right = new FormAttachment(middle, -margin);\r\n        wlCondition.setLayoutData(fdlCondition);\r\n\r\n        wCondition=new StyledTextComp(wSettingsGroup, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n        wCondition.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Condition.Tooltip\"));\r\n        props.setLook(wCondition, Props.WIDGET_STYLE_FIXED);\r\n        wCondition.addModifyListener(lsMod);\r\n        fdCondition = new FormData();\r\n        fdCondition.left = new FormAttachment(middle, margin);\r\n        fdCondition.top = new FormAttachment(wModule, margin);\r\n        fdCondition.right = new FormAttachment(100, -margin);\r\n        fdCondition.bottom = new FormAttachment(100, -margin);\r\n        wCondition.setLayoutData(fdCondition);\r\n        \r\n\r\n\r\n\t    // Query\r\n        wlQuery = new Label(wSettingsGroup, SWT.RIGHT);\r\n        wlQuery.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Query.Label\"));\r\n        props.setLook(wlQuery);\r\n        fdlQuery = new FormData();\r\n        fdlQuery.left = new FormAttachment(0, -margin);\r\n        fdlQuery.top = new FormAttachment(wspecifyQuery, margin);\r\n        fdlQuery.right = new FormAttachment(middle, -margin);\r\n        wlQuery.setLayoutData(fdlQuery);\r\n        \r\n\t\twQuery=new StyledTextComp(wSettingsGroup, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n \t\tprops.setLook(wQuery, Props.WIDGET_STYLE_FIXED);\r\n\t\twQuery.addModifyListener(lsMod);\r\n\t\tfdQuery=new FormData();\r\n\t\tfdQuery.left  = new FormAttachment(middle, margin);\r\n\t\tfdQuery.top   = new FormAttachment(wspecifyQuery, margin );\r\n\t\tfdQuery.right = new FormAttachment(100, -margin);\r\n\t\tfdQuery.bottom= new FormAttachment(100, -margin );\r\n\t\twQuery.setLayoutData(fdQuery);\r\n\t\twQuery.addModifyListener(new ModifyListener()\r\n            {\r\n                public void modifyText(ModifyEvent arg0)\r\n                {\r\n                    setQueryToolTip();\r\n                }\r\n            }\r\n        );\r\n\t\t\r\n\t\t\r\n\t\t\r\n        FormData fdSettingsGroup= new FormData();\r\n        fdSettingsGroup.left = new FormAttachment(0, 0);\r\n        fdSettingsGroup.right = new FormAttachment(100, 0);\r\n        fdSettingsGroup.bottom = new FormAttachment(100, 0);\r\n        fdSettingsGroup.top = new FormAttachment(wConnectionGroup, margin);\r\n        wSettingsGroup.setLayoutData(fdSettingsGroup);\r\n\r\n        // END SETTINGS GROUP\r\n        //////////////////////////\r\n        \r\n        \r\n\t\tfdFileComp = new FormData();\r\n\t\tfdFileComp.left = new FormAttachment(0, 0);\r\n\t\tfdFileComp.top = new FormAttachment(0, 0);\r\n\t\tfdFileComp.right = new FormAttachment(100, 0);\r\n\t\tfdFileComp.bottom = new FormAttachment(100, 0);\r\n\t\twFileComp.setLayoutData(fdFileComp);\r\n\r\n\t\twFileComp.layout();\r\n\t\twFileTab.setControl(wFileComp);\r\n\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF FILE TAB\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\r\n\t\t// ////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t// /\r\n\t\twContentTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Content.Tab\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout();\r\n\t\tcontentLayout.marginWidth = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\r\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\tprops.setLook(wContentComp);\r\n\t\twContentComp.setLayout(contentLayout);\r\n\r\n\t\t\r\n\t\t// ///////////////////////////////\r\n\t\t// START OF Advanced GROUP  //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twAdvancedGroup= new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wAdvancedGroup);\r\n\t\twAdvancedGroup.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.AdvancedGroup.Label\"));\r\n\t\t\r\n\t\tFormLayout advancedgroupLayout = new FormLayout();\r\n\t\tadvancedgroupLayout .marginWidth = 10;\r\n\t\tadvancedgroupLayout .marginHeight = 10;\r\n\t\twAdvancedGroup.setLayout(advancedgroupLayout );\r\n\t\t\r\n\r\n\t\t// RecordsFilter\r\n\t\twlRecordsFilter=new Label(wAdvancedGroup, SWT.RIGHT);\r\n\t\twlRecordsFilter.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.RecordsFilter.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlRecordsFilter);\r\n\t\tfdlRecordsFilter=new FormData();\r\n\t\tfdlRecordsFilter.left = new FormAttachment(0, 0);\r\n\t\tfdlRecordsFilter.right= new FormAttachment(middle, -margin);\r\n\t\tfdlRecordsFilter.top  = new FormAttachment(0, 2*margin);\r\n\t\twlRecordsFilter.setLayoutData(fdlRecordsFilter);\r\n\t\t\r\n\t\twRecordsFilter=new CCombo(wAdvancedGroup, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wRecordsFilter);\r\n \t\twRecordsFilter.addModifyListener(lsMod);\r\n\t\tfdRecordsFilter=new FormData();\r\n\t\tfdRecordsFilter.left = new FormAttachment(middle, 0);\r\n\t\tfdRecordsFilter.top  = new FormAttachment(0, 2*margin);\r\n\t\tfdRecordsFilter.right= new FormAttachment(100, -margin);\r\n\t\twRecordsFilter.setLayoutData(fdRecordsFilter);\r\n\t\twRecordsFilter.setItems(SalesforceConnectionUtils.recordsFilterDesc);\r\n\t\twRecordsFilter.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tupdateRecordsFilter();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\topen = new Button (wAdvancedGroup, SWT.PUSH);\r\n\t\topen.setImage(GUIResource.getInstance().getImageCalendar());\r\n\t\topen.setToolTipText (BaseMessages.getString(PKG, \"SalesforceInputDialog.OpenCalendar\"));\r\n\t    FormData fdlButton=new FormData();\r\n\t    fdlButton.top  = new FormAttachment(wRecordsFilter, margin);\r\n\t    fdlButton.right= new FormAttachment(100, 0);\r\n\t    open.setLayoutData(fdlButton);\r\n\t    open.addSelectionListener (new SelectionAdapter () {\r\n\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\tfinal Shell dialog = new Shell (shell, SWT.DIALOG_TRIM );\r\n\t\t\t\tdialog.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.SelectDate\"));\r\n\t\t\t\tdialog.setImage(GUIResource.getInstance().getImageSpoon());\r\n\t\t\t\tdialog.setLayout (new GridLayout (3, false));\r\n\r\n\t\t\t\tfinal DateTime calendar = new DateTime (dialog, SWT.CALENDAR);\r\n\t\t\t    final DateTime time = new DateTime (dialog, SWT.TIME | SWT.TIME);\r\n\t\t\t\tnew Label (dialog, SWT.NONE);\r\n\t\t\t\tnew Label (dialog, SWT.NONE);\r\n\r\n\t\t\t\tButton ok = new Button (dialog, SWT.PUSH);\r\n\t\t\t\tok.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\t\t\t\tok.setLayoutData(new GridData (SWT.FILL, SWT.CENTER, false, false));\r\n\t\t\t\tok.addSelectionListener (new SelectionAdapter () {\r\n\t\t\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\t\t\twReadFrom.setText(calendar.getYear()+\"-\"+\r\n\t\t\t\t\t\t\t\t((calendar.getMonth () + 1)<10 ? \"0\"+(calendar.getMonth () + 1) : (calendar.getMonth () + 1)) \r\n\t\t\t\t\t\t\t\t\t\t+\"-\"+(calendar.getDay()<10 ? \"0\"+calendar.getDay () : calendar.getDay())\r\n\t\t\t\t\t\t\t\t\t\t+\" \"+(time.getHours()<10 ? \"0\"+time.getHours() : time.getHours())\r\n\t\t\t\t\t\t\t\t\t\t+\":\"+(time.getMinutes()<10 ? \"0\"+time.getMinutes() : time.getMinutes())\r\n\t\t\t\t\t\t\t\t\t\t+\":\"+(time.getMinutes()<10 ? \"0\"+time.getMinutes() : time.getMinutes())\t\t\t\t\t\r\n\t\t\t\t\t\t); \r\n\t\t\t\t          \r\n\t\t\t\t\t\tdialog.close ();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tdialog.setDefaultButton (ok);\r\n\t\t\t\tdialog.pack ();\r\n\t\t\t\tdialog.open ();\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\twlReadFrom=new Label(wAdvancedGroup, SWT.RIGHT);\r\n\t\twlReadFrom.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadFrom.Label\"));\r\n \t\tprops.setLook(wlReadFrom);\r\n\t\tfdlReadFrom=new FormData();\r\n\t\tfdlReadFrom.left = new FormAttachment(0, 0);\r\n\t\tfdlReadFrom.top  = new FormAttachment(wRecordsFilter, margin);\r\n\t\tfdlReadFrom.right= new FormAttachment(middle, -margin);\r\n\t\twlReadFrom.setLayoutData(fdlReadFrom);\r\n\t\twReadFrom=new TextVar(transMeta, wAdvancedGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twReadFrom.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadFrom.Tooltip\"));\r\n \t\tprops.setLook(wReadFrom);\r\n\t\twReadFrom.addModifyListener(lsMod);\r\n\t\tfdReadFrom=new FormData();\r\n\t\tfdReadFrom.left = new FormAttachment(middle, 0);\r\n\t\tfdReadFrom.top  = new FormAttachment(wRecordsFilter, margin);\r\n\t\tfdReadFrom.right= new FormAttachment(open, -margin);\r\n\t\twReadFrom.setLayoutData(fdReadFrom);\r\n\r\n\t\t\r\n\t\topento = new Button (wAdvancedGroup, SWT.PUSH);\r\n\t\topento.setImage(GUIResource.getInstance().getImageCalendar());\r\n\t\topento.setToolTipText (BaseMessages.getString(PKG, \"SalesforceInputDialog.OpenCalendar\"));\r\n\t    FormData fdlButtonto=new FormData();\r\n\t    fdlButtonto.top  = new FormAttachment(wReadFrom, 2*margin);\r\n\t    fdlButtonto.right= new FormAttachment(100, 0);\r\n\t    opento.setLayoutData(fdlButtonto);\r\n\t    opento.addSelectionListener (new SelectionAdapter () {\r\n\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\tfinal Shell dialogto = new Shell (shell, SWT.DIALOG_TRIM );\r\n\t\t\t\tdialogto.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.SelectDate\"));\r\n\t\t\t\tdialogto.setImage(GUIResource.getInstance().getImageSpoon());\r\n\t\t\t\tdialogto.setLayout (new GridLayout (3, false));\r\n\r\n\t\t\t\tfinal DateTime calendarto = new DateTime (dialogto, SWT.CALENDAR | SWT.BORDER);\r\n\t\t\t    final DateTime timeto = new DateTime (dialogto, SWT.TIME | SWT.TIME);\r\n\t\t\t\tnew Label (dialogto, SWT.NONE);\r\n\t\t\t\tnew Label (dialogto, SWT.NONE);\r\n\t\t\t\tButton okto = new Button (dialogto, SWT.PUSH);\r\n\t\t\t\tokto.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\t\t\t\tokto.setLayoutData(new GridData (SWT.FILL, SWT.CENTER, false, false));\r\n\t\t\t\tokto.addSelectionListener (new SelectionAdapter () {\r\n\t\t\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\t\t\twReadTo.setText(calendarto.getYear()+\"-\"+\r\n\t\t\t\t\t\t\t\t((calendarto.getMonth() + 1)<10 ? \"0\"+(calendarto.getMonth () + 1) : (calendarto.getMonth () + 1)) \r\n\t\t\t\t\t\t\t\t+\"-\"+(calendarto.getDay()<10 ? \"0\"+calendarto.getDay() : calendarto.getDay())\r\n\t\t\t\t\t\t\t\t+\" \"+(timeto.getHours()<10 ? \"0\"+timeto.getHours() : timeto.getHours())\r\n\t\t\t\t\t\t\t\t+\":\"+(timeto.getMinutes()<10 ? \"0\"+timeto.getMinutes() : timeto.getMinutes())\r\n\t\t\t\t\t\t\t\t+\":\"+(timeto.getSeconds()<10 ? \"0\"+timeto.getSeconds() : timeto.getSeconds())\r\n\t\t\t\t\t\t); \r\n\t\t\t\t\t\tdialogto.close ();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tdialogto.setDefaultButton (okto);\r\n\t\t\t\tdialogto.pack ();\r\n\t\t\t\tdialogto.open ();\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\twlReadTo=new Label(wAdvancedGroup, SWT.RIGHT);\r\n\t\twlReadTo.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadTo.Label\"));\r\n \t\tprops.setLook(wlReadTo);\r\n\t\tfdlReadTo=new FormData();\r\n\t\tfdlReadTo.left = new FormAttachment(0, 0);\r\n\t\tfdlReadTo.top  = new FormAttachment(wReadFrom, 2*margin);\r\n\t\tfdlReadTo.right= new FormAttachment(middle, -margin);\r\n\t\twlReadTo.setLayoutData(fdlReadTo);\r\n\t\twReadTo=new TextVar(transMeta, wAdvancedGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twReadTo.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadTo.Tooltip\"));\r\n \t\tprops.setLook(wReadTo);\r\n\t\twReadTo.addModifyListener(lsMod);\r\n\t\tfdReadTo=new FormData();\r\n\t\tfdReadTo.left = new FormAttachment(middle, 0);\r\n\t\tfdReadTo.top  = new FormAttachment(wReadFrom, 2*margin);\r\n\t\tfdReadTo.right= new FormAttachment(opento, -margin);\r\n\t\twReadTo.setLayoutData(fdReadTo);\r\n\r\n\t\t\r\n\t\tfdAdvancedGroup= new FormData();\r\n\t\tfdAdvancedGroup.left = new FormAttachment(0, margin);\r\n\t\tfdAdvancedGroup.top = new FormAttachment(0, 2*margin);\r\n\t\tfdAdvancedGroup.right = new FormAttachment(100, -margin);\r\n\t\twAdvancedGroup.setLayoutData(fdAdvancedGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Advanced GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\r\n\t\t\r\n\t\t// ///////////////////////////////\r\n\t\t// START OF Additional Fields GROUP  //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twAdditionalFields = new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wAdditionalFields);\r\n\t\twAdditionalFields.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.wAdditionalFields.Label\"));\r\n\t\t\r\n\t\tFormLayout AdditionalFieldsgroupLayout = new FormLayout();\r\n\t\tAdditionalFieldsgroupLayout.marginWidth = 10;\r\n\t\tAdditionalFieldsgroupLayout.marginHeight = 10;\r\n\t\twAdditionalFields.setLayout(AdditionalFieldsgroupLayout);\r\n\t\t\r\n\t\t// Add Salesforce URL in the output stream ?\r\n\t\twlInclURL = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclURL.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclURL.Label\"));\r\n\t\tprops.setLook(wlInclURL);\r\n\t\tfdlInclURL = new FormData();\r\n\t\tfdlInclURL.left = new FormAttachment(0, 0);\r\n\t\tfdlInclURL.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\tfdlInclURL.right = new FormAttachment(middle, -margin);\r\n\t\twlInclURL.setLayoutData(fdlInclURL);\r\n\t\twInclURL = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclURL);\r\n\t\twInclURL.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclURL.Tooltip\"));\r\n\t\tfdInclURL = new FormData();\r\n\t\tfdInclURL.left = new FormAttachment(middle, 0);\r\n\t\tfdInclURL.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\twInclURL.setLayoutData(fdInclURL);\r\n\t\twInclURL.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclTargetURL();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\r\n\t\twlInclURLField = new Label(wAdditionalFields, SWT.LEFT);\r\n\t\twlInclURLField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclURLField.Label\"));\r\n\t\tprops.setLook(wlInclURLField);\r\n\t\tfdlInclURLField = new FormData();\r\n\t\tfdlInclURLField.left = new FormAttachment(wInclURL, margin);\r\n\t\tfdlInclURLField.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\twlInclURLField.setLayoutData(fdlInclURLField);\r\n\t\twInclURLField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\t| SWT.BORDER);\r\n\t\tprops.setLook(wlInclURLField);\r\n\t\twInclURLField.addModifyListener(lsMod);\r\n\t\tfdInclURLField = new FormData();\r\n\t\tfdInclURLField.left = new FormAttachment(wlInclURLField,margin);\r\n\t\tfdInclURLField.top = new FormAttachment(wAdvancedGroup,  margin);\r\n\t\tfdInclURLField.right = new FormAttachment(100, 0);\r\n\t\twInclURLField.setLayoutData(fdInclURLField);\r\n\t\t\r\n\t\t\r\n\t\t//\tAdd module in the output stream ?\r\n\t\twlInclModule = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclModule.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclModule.Label\"));\r\n\t\tprops.setLook(wlInclModule);\r\n\t\tfdlInclModule = new FormData();\r\n\t\tfdlInclModule.left = new FormAttachment(0, 0);\r\n\t\tfdlInclModule.top = new FormAttachment(wInclURLField, margin);\r\n\t\tfdlInclModule.right = new FormAttachment(middle, -margin);\r\n\t\twlInclModule.setLayoutData(fdlInclModule);\r\n\t\twInclModule = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclModule);\r\n\t\twInclModule.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclModule.Tooltip\"));\r\n\t\tfdModule = new FormData();\r\n\t\tfdModule.left = new FormAttachment(middle, 0);\r\n\t\tfdModule.top = new FormAttachment(wInclURLField, margin);\r\n\t\twInclModule.setLayoutData(fdModule);\r\n\r\n\t\twInclModule.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclModule();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t\t\r\n\t\twlInclModuleField = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclModuleField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclModuleField.Label\"));\r\n\t\tprops.setLook(wlInclModuleField);\r\n\t\tfdlInclModuleField = new FormData();\r\n\t\tfdlInclModuleField.left = new FormAttachment(wInclModule, margin);\r\n\t\tfdlInclModuleField.top = new FormAttachment(wInclURLField, margin);\r\n\t\twlInclModuleField.setLayoutData(fdlInclModuleField);\r\n\t\twInclModuleField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\r\n\t\t\t\t| SWT.BORDER);\r\n\t\tprops.setLook(wInclModuleField);\r\n\t\twInclModuleField.addModifyListener(lsMod);\r\n\t\tfdInclModuleField = new FormData();\r\n\t\tfdInclModuleField.left = new FormAttachment(wlInclModuleField, margin);\r\n\t\tfdInclModuleField.top = new FormAttachment(wInclURLField, margin);\r\n\t\tfdInclModuleField.right = new FormAttachment(100, 0);\r\n\t\twInclModuleField.setLayoutData(fdInclModuleField);\r\n\r\n\r\n\t\t// Add SQL in the output stream ?\r\n\t\twlInclSQL = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclSQL.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclSQL.Label\"));\r\n\t\tprops.setLook(wlInclSQL);\r\n\t\tfdlInclSQL = new FormData();\r\n\t\tfdlInclSQL.left = new FormAttachment(0, 0);\r\n\t\tfdlInclSQL.top = new FormAttachment(wInclModuleField, margin);\r\n\t\tfdlInclSQL.right = new FormAttachment(middle, -margin);\r\n\t\twlInclSQL.setLayoutData(fdlInclSQL);\r\n\t\twInclSQL = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclSQL);\r\n\t\twInclSQL.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclSQL.Tooltip\"));\r\n\t\tfdInclSQL = new FormData();\r\n\t\tfdInclSQL.left = new FormAttachment(middle, 0);\r\n\t\tfdInclSQL.top = new FormAttachment(wInclModuleField, margin);\r\n\t\twInclSQL.setLayoutData(fdInclSQL);\r\n\t\twInclSQL.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclSQL();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\r\n\t\twlInclSQLField = new Label(wAdditionalFields, SWT.LEFT);\r\n\t\twlInclSQLField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclSQLField.Label\"));\r\n\t\tprops.setLook(wlInclSQLField);\r\n\t\tfdlInclSQLField = new FormData();\r\n\t\tfdlInclSQLField.left = new FormAttachment(wInclSQL, margin);\r\n\t\tfdlInclSQLField.top = new FormAttachment(wInclModuleField, margin);\r\n\t\twlInclSQLField.setLayoutData(fdlInclSQLField);\r\n\t\twInclSQLField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\t| SWT.BORDER);\r\n\t\tprops.setLook(wlInclSQLField);\r\n\t\twInclSQLField.addModifyListener(lsMod);\r\n\t\tfdInclSQLField = new FormData();\r\n\t\tfdInclSQLField.left = new FormAttachment(wlInclSQLField,margin);\r\n\t\tfdInclSQLField.top = new FormAttachment(wInclModuleField,  margin);\r\n\t\tfdInclSQLField.right = new FormAttachment(100, 0);\r\n\t\twInclSQLField.setLayoutData(fdInclSQLField);\r\n\t\t\r\n\t\t// Add Timestamp in the output stream ?\r\n\t\twlInclTimestamp = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclTimestamp.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclTimestamp.Label\"));\r\n\t\tprops.setLook(wlInclTimestamp);\r\n\t\tfdlInclTimestamp = new FormData();\r\n\t\tfdlInclTimestamp.left = new FormAttachment(0, 0);\r\n\t\tfdlInclTimestamp.top = new FormAttachment(wInclSQLField, margin);\r\n\t\tfdlInclTimestamp.right = new FormAttachment(middle, -margin);\r\n\t\twlInclTimestamp.setLayoutData(fdlInclTimestamp);\r\n\t\twInclTimestamp = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclTimestamp);\r\n\t\twInclTimestamp.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclTimestamp.Tooltip\"));\r\n\t\tfdInclTimestamp = new FormData();\r\n\t\tfdInclTimestamp.left = new FormAttachment(middle, 0);\r\n\t\tfdInclTimestamp.top = new FormAttachment(wInclSQLField, margin);\r\n\t\twInclTimestamp.setLayoutData(fdInclTimestamp);\r\n\t\twInclTimestamp.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclTimestamp();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\r\n\t\twlInclTimestampField = new Label(wAdditionalFields, SWT.LEFT);\r\n\t\twlInclTimestampField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclTimestampField.Label\"));\r\n\t\tprops.setLook(wlInclTimestampField);\r\n\t\tfdlInclTimestampField = new FormData();\r\n\t\tfdlInclTimestampField.left = new FormAttachment(wInclTimestamp, margin);\r\n\t\tfdlInclTimestampField.top = new FormAttachment(wInclSQLField, margin);\r\n\t\twlInclTimestampField.setLayoutData(fdlInclTimestampField);\r\n\t\twInclTimestampField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\t| SWT.BORDER);\r\n\t\tprops.setLook(wlInclTimestampField);\r\n\t\twInclTimestampField.addModifyListener(lsMod);\r\n\t\tfdInclTimestampField = new FormData();\r\n\t\tfdInclTimestampField.left = new FormAttachment(wlInclTimestampField,margin);\r\n\t\tfdInclTimestampField.top = new FormAttachment(wInclSQLField,  margin);\r\n\t\tfdInclTimestampField.right = new FormAttachment(100, 0);\r\n\t\twInclTimestampField.setLayoutData(fdInclTimestampField);\r\n\t\t\r\n\t\t\r\n\t\t// Include Rownum in output stream?\r\n\t\twlInclRownum=new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclRownum.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclRownum.Label\"));\r\n \t\tprops.setLook(wlInclRownum);\r\n\t\tfdlInclRownum=new FormData();\r\n\t\tfdlInclRownum.left = new FormAttachment(0, 0);\r\n\t\tfdlInclRownum.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\tfdlInclRownum.right= new FormAttachment(middle, -margin);\r\n\t\twlInclRownum.setLayoutData(fdlInclRownum);\r\n\t\twInclRownum=new Button(wAdditionalFields, SWT.CHECK );\r\n \t\tprops.setLook(wInclRownum);\r\n\t\twInclRownum.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclRownum.Tooltip\"));\r\n\t\tfdRownum=new FormData();\r\n\t\tfdRownum.left = new FormAttachment(middle, 0);\r\n\t\tfdRownum.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\twInclRownum.setLayoutData(fdRownum);\r\n\r\n\t\twInclRownum.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclRownum();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t\t\r\n\t\twlInclRownumField=new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclRownumField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclRownumField.Label\"));\r\n \t\tprops.setLook(wlInclRownumField);\r\n\t\tfdlInclRownumField=new FormData();\r\n\t\tfdlInclRownumField.left = new FormAttachment(wInclRownum, margin);\r\n\t\tfdlInclRownumField.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\r\n\t\twInclRownumField=new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wInclRownumField);\r\n\t\twInclRownumField.addModifyListener(lsMod);\r\n\t\tfdInclRownumField=new FormData();\r\n\t\tfdInclRownumField.left = new FormAttachment(wlInclRownumField, margin);\r\n\t\tfdInclRownumField.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\r\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\r\n\r\n\t\t\r\n\t\tfdAdditionalFields = new FormData();\r\n\t\tfdAdditionalFields.left = new FormAttachment(0, margin);\r\n\t\tfdAdditionalFields.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\tfdAdditionalFields.right = new FormAttachment(100, -margin);\r\n\t\twAdditionalFields.setLayoutData(fdAdditionalFields);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Additional Fields GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\r\n\t\t// Timeout\r\n\t\twlTimeOut = new Label(wContentComp, SWT.RIGHT);\r\n\t\twlTimeOut.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.TimeOut.Label\"));\r\n\t\tprops.setLook(wlTimeOut);\r\n\t\tfdlTimeOut = new FormData();\r\n\t\tfdlTimeOut.left = new FormAttachment(0, 0);\r\n\t\tfdlTimeOut.top = new FormAttachment(wAdditionalFields, 2*margin);\r\n\t\tfdlTimeOut.right = new FormAttachment(middle, -margin);\r\n\t\twlTimeOut.setLayoutData(fdlTimeOut);\r\n\t\twTimeOut = new TextVar(transMeta,wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wTimeOut);\r\n\t\twTimeOut.addModifyListener(lsMod);\r\n\t\tfdTimeOut = new FormData();\r\n\t\tfdTimeOut.left = new FormAttachment(middle, 0);\r\n\t\tfdTimeOut.top = new FormAttachment(wAdditionalFields, 2*margin);\r\n\t\tfdTimeOut.right = new FormAttachment(100, 0);\r\n\t\twTimeOut.setLayoutData(fdTimeOut);\r\n\t\t\r\n\t\t\r\n\t\t// Use compression?\r\n\t\twlUseCompression=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlUseCompression.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.UseCompression.Label\"));\r\n \t\tprops.setLook(wlUseCompression);\r\n\t\tfdlUseCompression=new FormData();\r\n\t\tfdlUseCompression.left = new FormAttachment(0, 0);\r\n\t\tfdlUseCompression.top  = new FormAttachment(wTimeOut, margin);\r\n\t\tfdlUseCompression.right= new FormAttachment(middle, -margin);\r\n\t\twlUseCompression.setLayoutData(fdlUseCompression);\r\n\t\twUseCompression=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wUseCompression);\r\n\t\twUseCompression.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.UseCompression.Tooltip\"));\r\n\t\tfdUseCompression=new FormData();\r\n\t\tfdUseCompression.left = new FormAttachment(middle, 0);\r\n\t\tfdUseCompression.top  = new FormAttachment(wTimeOut, margin);\r\n\t\twUseCompression.setLayoutData(fdUseCompression);\r\n\r\n\t\t\r\n\t\t// Limit rows\r\n\t\twlLimit = new Label(wContentComp, SWT.RIGHT);\r\n\t\twlLimit.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Limit.Label\"));\r\n\t\tprops.setLook(wlLimit);\r\n\t\tfdlLimit = new FormData();\r\n\t\tfdlLimit.left = new FormAttachment(0, 0);\r\n\t\tfdlLimit.top = new FormAttachment(wUseCompression, margin);\r\n\t\tfdlLimit.right = new FormAttachment(middle, -margin);\r\n\t\twlLimit.setLayoutData(fdlLimit);\r\n\t\twLimit = new TextVar(transMeta,wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wLimit);\r\n\t\twLimit.addModifyListener(lsMod);\r\n\t\tfdLimit = new FormData();\r\n\t\tfdLimit.left = new FormAttachment(middle, 0);\r\n\t\tfdLimit.top = new FormAttachment(wUseCompression, margin);\r\n\t\tfdLimit.right = new FormAttachment(100, 0);\r\n\t\twLimit.setLayoutData(fdLimit);\r\n\r\n\t\tfdContentComp = new FormData();\r\n\t\tfdContentComp.left = new FormAttachment(0, 0);\r\n\t\tfdContentComp.top = new FormAttachment(0, 0);\r\n\t\tfdContentComp.right = new FormAttachment(100, 0);\r\n\t\tfdContentComp.bottom = new FormAttachment(100, 0);\r\n\t\twContentComp.setLayoutData(fdContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF CONTENT TAB\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\r\n\t\t// Fields tab...\r\n\t\t//\r\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFieldsTab.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Fields.Tab\"));\r\n\r\n\t\tFormLayout fieldsLayout = new FormLayout();\r\n\t\tfieldsLayout.marginWidth = Const.FORM_MARGIN;\r\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\twFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twFieldsComp.setLayout(fieldsLayout);\r\n\t\tprops.setLook(wFieldsComp);\r\n\r\n\t\twGet = new Button(wFieldsComp, SWT.PUSH);\r\n\t\twGet.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.GetFields.Button\"));\r\n\t\tfdGet = new FormData();\r\n\t\tfdGet.left = new FormAttachment(50, 0);\r\n\t\tfdGet.bottom = new FormAttachment(100, 0);\r\n\t\twGet.setLayoutData(fdGet);\r\n\r\n\r\n\t\tfinal int FieldsRows = input.getInputFields().length;\r\n\r\n\t\tColumnInfo[] colinf = new ColumnInfo[] {\r\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Name.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Field.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Type.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes(), true),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Format.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_FORMAT, 3),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Length.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Precision.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Currency.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Decimal.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Group.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.TrimType.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_CCOMBO,\r\n\t\t\t\t\t\tSalesforceInputField.trimTypeDesc, true),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Repeat.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_CCOMBO, new String[] {\r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"System.Combo.Yes\"),\r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"System.Combo.No\") }, true),\r\n\r\n\t\t};\r\n\r\n\t\tcolinf[0].setUsingVariables(true);\r\n\t\tcolinf[0].setToolTip(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Name.Column.Tooltip\"));\r\n\t\tcolinf[1].setUsingVariables(true);\r\n\t\tcolinf[1].setToolTip(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Field.Column.Tooltip\"));\r\n\r\n\t\twFields=new TableView(transMeta,wFieldsComp, \r\n\t\t\t      SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t      colinf, \r\n\t\t\t      FieldsRows,  \r\n\t\t\t      lsMod,\r\n\t\t\t\t  props\r\n\t\t\t      );\r\n\t\t\r\n\t\tfdFields = new FormData();\r\n\t\tfdFields.left = new FormAttachment(0, 0);\r\n\t\tfdFields.top = new FormAttachment(0, 0);\r\n\t\tfdFields.right = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom = new FormAttachment(wGet, -margin);\r\n\t\twFields.setLayoutData(fdFields);\r\n\r\n\t\tfdFieldsComp = new FormData();\r\n\t\tfdFieldsComp.left = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.top = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\r\n\t\tfdFieldsComp.bottom = new FormAttachment(100, 0);\r\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\r\n\r\n\t\twFieldsComp.layout();\r\n\t\twFieldsTab.setControl(wFieldsComp);\r\n\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom = new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\t\t\r\n\t\t\r\n\r\n\t\t// THE BUTTONS\r\n\t\twOK = new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\r\n\t\twPreview = new Button(shell, SWT.PUSH);\r\n\t\twPreview.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Button.PreviewRows\"));\r\n\r\n\t\twCancel = new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder);\r\n\r\n\t\t// Add listeners\r\n\t\tlsOK = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t\t\tok();\r\n\t\t\t}\r\n\t\t};\r\n\t\tlsTest     = new Listener() { public void handleEvent(Event e) { test(); } };\r\n\t\tlsGet = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t        Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n\t\t        shell.setCursor(busy);\r\n\t\t\t\tget();\r\n\t\t        shell.setCursor(null);\r\n\t\t        busy.dispose();\r\n\t\t\t}\r\n\t\t};\r\n\t\tlsPreview = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t\t\tpreview();\r\n\t\t\t}\r\n\t\t};\r\n\t\tlsCancel = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\twOK.addListener(SWT.Selection, lsOK);\r\n\t\twGet.addListener(SWT.Selection, lsGet);\r\n\t\twTest.addListener    (SWT.Selection, lsTest    );\t\r\n\t\twPreview.addListener(SWT.Selection, lsPreview);\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\t\tlsDef = new SelectionAdapter() {\r\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\r\n\t\t\t\tok();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\twStepname.addSelectionListener(lsDef);\r\n\t\twLimit.addSelectionListener(lsDef);\r\n\t\twInclModuleField.addSelectionListener(lsDef);\r\n\t\twInclURLField.addSelectionListener(lsDef);\r\n\r\n\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(new ShellAdapter() {\r\n\t\t\tpublic void shellClosed(ShellEvent e) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\twTabFolder.setSelection(0);\r\n\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\tgetData(input);\r\n\t\tsetEnableInclTargetURL();\r\n\t\tsetEnableInclSQL();\r\n\t\tsetEnableInclTimestamp();\r\n\t\tsetEnableInclModule();\r\n\t\tsetEnableInclRownum();\r\n\t\tsetEnableQuery();\r\n\t\r\n\t\tinput.setChanged(changed);\r\n\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed()) {\r\n\t\t\tif (!display.readAndDispatch())\r\n\t\t\t\tdisplay.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","id":88000,"modified_method":"public String open() {\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n\t\tprops.setLook(shell);\r\n\t\tsetShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() {\r\n\t\t\tpublic void modifyText(ModifyEvent e) {\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\r\n\t\tFormLayout formLayout = new FormLayout();\r\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.DialogTitle\"));\r\n\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Stepname line\r\n\t\twlStepname = new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\r\n\t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname = new FormData();\r\n\t\tfdlStepname.left = new FormAttachment(0, 0);\r\n\t\tfdlStepname.top = new FormAttachment(0, margin);\r\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n\t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname = new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top = new FormAttachment(0, margin);\r\n\t\tfdStepname.right = new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n\t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\t\t\r\n\t\t\r\n\r\n\t\t// ////////////////////////\r\n\t\t// START OF FILE TAB ///\r\n\t\t// ////////////////////////\r\n\t\twFileTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFileTab.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.File.Tab\"));\r\n\r\n\t\twFileComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\tprops.setLook(wFileComp);\r\n\r\n\t\tFormLayout fileLayout = new FormLayout();\r\n\t\tfileLayout.marginWidth = 3;\r\n\t\tfileLayout.marginHeight = 3;\r\n\t\twFileComp.setLayout(fileLayout);\r\n\t\t\r\n\t\t\r\n        //////////////////////////\r\n        // START CONNECTION GROUP\r\n\r\n        wConnectionGroup = new Group(wFileComp, SWT.SHADOW_ETCHED_IN);\r\n        wConnectionGroup.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ConnectionGroup.Label\")); //$NON-NLS-1$;\r\n        FormLayout fconnLayout = new FormLayout();\r\n        fconnLayout .marginWidth = 3;\r\n        fconnLayout .marginHeight = 3;\r\n        wConnectionGroup.setLayout(fconnLayout );\r\n        props.setLook(wConnectionGroup);\r\n\t\t\r\n\t      // Webservice URL\r\n        wURL = new LabelTextVar(transMeta,wConnectionGroup, BaseMessages.getString(PKG, \"SalesforceInputDialog.URL.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.URL.Tooltip\"));\r\n        props.setLook(wURL);\r\n        wURL.addModifyListener(lsMod);\r\n        fdURL = new FormData();\r\n        fdURL.left = new FormAttachment(0, 0);\r\n        fdURL.top = new FormAttachment(0, margin);\r\n        fdURL.right = new FormAttachment(100, 0);\r\n        wURL.setLayoutData(fdURL);\r\n        \r\n\r\n\t      // UserName line\r\n        wUserName = new LabelTextVar(transMeta,wConnectionGroup, BaseMessages.getString(PKG, \"SalesforceInputDialog.User.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.User.Tooltip\"));\r\n        props.setLook(wUserName);\r\n        wUserName.addModifyListener(lsMod);\r\n        fdUserName = new FormData();\r\n        fdUserName.left = new FormAttachment(0, 0);\r\n        fdUserName.top = new FormAttachment(wURL, margin);\r\n        fdUserName.right = new FormAttachment(100, 0);\r\n        wUserName.setLayoutData(fdUserName);\r\n\t\t\r\n        // Password line\r\n        wPassword = new LabelTextVar(transMeta,wConnectionGroup, BaseMessages.getString(PKG, \"SalesforceInputDialog.Password.Label\"), \r\n        \t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.Password.Tooltip\"));\r\n        props.setLook(wPassword);\r\n        //wPassword.setEchoChar('*');\r\n        wPassword.addModifyListener(lsMod);\r\n        fdPassword = new FormData();\r\n        fdPassword.left = new FormAttachment(0, 0);\r\n        fdPassword.top = new FormAttachment(wUserName, margin);\r\n        fdPassword.right = new FormAttachment(100, 0);\r\n        wPassword.setLayoutData(fdPassword);\r\n\r\n        // OK, if the password contains a variable, we don't want to have the password hidden...\r\n        wPassword.getTextWidget().addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                checkPasswordVisible();\r\n            }\r\n        });\r\n\r\n\t\t// Test Salesforce connection button\r\n\t\twTest=new Button(wConnectionGroup,SWT.PUSH);\r\n\t\twTest.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.TestConnection.Label\"));\r\n \t\tprops.setLook(wTest);\r\n\t\tfdTest=new FormData();\r\n\t\twTest.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.TestConnection.Tooltip\"));\r\n\t\t//fdTest.left = new FormAttachment(middle, 0);\r\n\t\tfdTest.top  = new FormAttachment(wPassword, margin);\r\n\t\tfdTest.right= new FormAttachment(100, 0);\r\n\t\twTest.setLayoutData(fdTest);\r\n\t\t\r\n        FormData fdConnectionGroup= new FormData();\r\n        fdConnectionGroup.left = new FormAttachment(0, 0);\r\n        fdConnectionGroup.right = new FormAttachment(100, 0);\r\n        fdConnectionGroup.top = new FormAttachment(0, margin);\r\n        wConnectionGroup.setLayoutData(fdConnectionGroup);\r\n\r\n        // END CONNECTION  GROUP\r\n        //////////////////////////\r\n\t\t\r\n        //////////////////////////\r\n        // START SETTINGS GROUP\r\n\r\n        wSettingsGroup = new Group(wFileComp, SWT.SHADOW_ETCHED_IN);\r\n        wSettingsGroup.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.HttpAuthGroup.Label\")); //$NON-NLS-1$;\r\n        FormLayout fsettingsLayout = new FormLayout();\r\n        fsettingsLayout .marginWidth = 3;\r\n        fsettingsLayout .marginHeight = 3;\r\n        wSettingsGroup.setLayout(fsettingsLayout );\r\n        props.setLook(wSettingsGroup);\r\n        \r\n        wlspecifyQuery = new Label(wSettingsGroup, SWT.RIGHT);\r\n\t\twlspecifyQuery.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.specifyQuery.Label\"));\r\n\t\tprops.setLook(wlspecifyQuery);\r\n\t\tfdlspecifyQuery = new FormData();\r\n\t\tfdlspecifyQuery.left = new FormAttachment(0, 0);\r\n\t\tfdlspecifyQuery.top = new FormAttachment(wConnectionGroup, 2*margin);\r\n\t\tfdlspecifyQuery.right = new FormAttachment(middle, -margin);\r\n\t\twlspecifyQuery.setLayoutData(fdlspecifyQuery);\r\n\t\twspecifyQuery = new Button(wSettingsGroup, SWT.CHECK);\r\n\t\tprops.setLook(wspecifyQuery);\r\n\t\twspecifyQuery.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.specifyQuery.Tooltip\"));\r\n\t\tfdspecifyQuery = new FormData();\r\n\t\tfdspecifyQuery.left = new FormAttachment(middle, 0);\r\n\t\tfdspecifyQuery.top = new FormAttachment(wConnectionGroup, 2*margin);\r\n\t\twspecifyQuery.setLayoutData(fdspecifyQuery);\r\n\t\twspecifyQuery.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableQuery();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n        \r\n \t\t// Module\r\n\t\twlModule=new Label(wSettingsGroup, SWT.RIGHT);\r\n        wlModule.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Module.Label\"));\r\n        props.setLook(wlModule);\r\n        fdlModule=new FormData();\r\n        fdlModule.left = new FormAttachment(0, 0);\r\n        fdlModule.top  = new FormAttachment(wspecifyQuery, margin);\r\n        fdlModule.right= new FormAttachment(middle, -margin);\r\n        wlModule.setLayoutData(fdlModule);\r\n        wModule=new ComboVar(transMeta,wSettingsGroup, SWT.BORDER | SWT.READ_ONLY);\r\n        wModule.setEditable(true);\r\n        props.setLook(wModule);\r\n        wModule.addModifyListener(lsMod);\r\n        fdModule=new FormData();\r\n        fdModule.left = new FormAttachment(middle, margin);\r\n        fdModule.top  = new FormAttachment(wspecifyQuery, margin);\r\n        fdModule.right= new FormAttachment(100, -margin);\r\n        wModule.setLayoutData(fdModule);\r\n        wModule.addFocusListener(new FocusListener()\r\n        {\r\n            public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n            {\r\n            \tgetModulesListError = false;\r\n            }\r\n        \r\n            public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n            {\r\n                // check if the URL and login credentials passed and not just had error \r\n            \tif (Const.isEmpty(wURL.getText()) || \r\n               \t\tConst.isEmpty(wUserName.getText()) ||\r\n            \t\tConst.isEmpty(wPassword.getText()) ||\r\n            \t\t(getModulesListError )) return; \r\n\r\n                getModulesList();\r\n            }\r\n        }\r\n    );\r\n\r\n       \r\n\t    // condition\r\n        wlCondition = new Label(wSettingsGroup, SWT.RIGHT);\r\n        wlCondition.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Condition.Label\"));\r\n        props.setLook(wlCondition);\r\n        fdlCondition = new FormData();\r\n        fdlCondition.left = new FormAttachment(0, -margin);\r\n        fdlCondition.top = new FormAttachment(wModule, margin);\r\n        fdlCondition.right = new FormAttachment(middle, -margin);\r\n        wlCondition.setLayoutData(fdlCondition);\r\n\r\n        wCondition=new StyledTextComp(wSettingsGroup, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n        wCondition.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Condition.Tooltip\"));\r\n        props.setLook(wCondition, Props.WIDGET_STYLE_FIXED);\r\n        wCondition.addModifyListener(lsMod);\r\n        fdCondition = new FormData();\r\n        fdCondition.left = new FormAttachment(middle, margin);\r\n        fdCondition.top = new FormAttachment(wModule, margin);\r\n        fdCondition.right = new FormAttachment(100, -margin);\r\n        fdCondition.bottom = new FormAttachment(100, -margin);\r\n        wCondition.setLayoutData(fdCondition);\r\n        \r\n\r\n\r\n\t    // Query\r\n        wlQuery = new Label(wSettingsGroup, SWT.RIGHT);\r\n        wlQuery.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Query.Label\"));\r\n        props.setLook(wlQuery);\r\n        fdlQuery = new FormData();\r\n        fdlQuery.left = new FormAttachment(0, -margin);\r\n        fdlQuery.top = new FormAttachment(wspecifyQuery, margin);\r\n        fdlQuery.right = new FormAttachment(middle, -margin);\r\n        wlQuery.setLayoutData(fdlQuery);\r\n        \r\n\t\twQuery=new StyledTextComp(wSettingsGroup, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\r\n \t\tprops.setLook(wQuery, Props.WIDGET_STYLE_FIXED);\r\n\t\twQuery.addModifyListener(lsMod);\r\n\t\tfdQuery=new FormData();\r\n\t\tfdQuery.left  = new FormAttachment(middle, margin);\r\n\t\tfdQuery.top   = new FormAttachment(wspecifyQuery, margin );\r\n\t\tfdQuery.right = new FormAttachment(100, -margin);\r\n\t\tfdQuery.bottom= new FormAttachment(100, -margin );\r\n\t\twQuery.setLayoutData(fdQuery);\r\n\t\twQuery.addModifyListener(new ModifyListener()\r\n            {\r\n                public void modifyText(ModifyEvent arg0)\r\n                {\r\n                    setQueryToolTip();\r\n                }\r\n            }\r\n        );\r\n\t\t\r\n\t\t\r\n\t\t\r\n        FormData fdSettingsGroup= new FormData();\r\n        fdSettingsGroup.left = new FormAttachment(0, 0);\r\n        fdSettingsGroup.right = new FormAttachment(100, 0);\r\n        fdSettingsGroup.bottom = new FormAttachment(100, 0);\r\n        fdSettingsGroup.top = new FormAttachment(wConnectionGroup, margin);\r\n        wSettingsGroup.setLayoutData(fdSettingsGroup);\r\n\r\n        // END SETTINGS GROUP\r\n        //////////////////////////\r\n        \r\n        \r\n\t\tfdFileComp = new FormData();\r\n\t\tfdFileComp.left = new FormAttachment(0, 0);\r\n\t\tfdFileComp.top = new FormAttachment(0, 0);\r\n\t\tfdFileComp.right = new FormAttachment(100, 0);\r\n\t\tfdFileComp.bottom = new FormAttachment(100, 0);\r\n\t\twFileComp.setLayoutData(fdFileComp);\r\n\r\n\t\twFileComp.layout();\r\n\t\twFileTab.setControl(wFileComp);\r\n\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF FILE TAB\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\r\n\t\t// ////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t// /\r\n\t\twContentTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Content.Tab\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout();\r\n\t\tcontentLayout.marginWidth = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\r\n\t\twContentComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\tprops.setLook(wContentComp);\r\n\t\twContentComp.setLayout(contentLayout);\r\n\r\n\t\t\r\n\t\t// ///////////////////////////////\r\n\t\t// START OF Advanced GROUP  //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twAdvancedGroup= new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wAdvancedGroup);\r\n\t\twAdvancedGroup.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.AdvancedGroup.Label\"));\r\n\t\t\r\n\t\tFormLayout advancedgroupLayout = new FormLayout();\r\n\t\tadvancedgroupLayout .marginWidth = 10;\r\n\t\tadvancedgroupLayout .marginHeight = 10;\r\n\t\twAdvancedGroup.setLayout(advancedgroupLayout );\r\n\t\t\r\n\r\n\t\t// RecordsFilter\r\n\t\twlRecordsFilter=new Label(wAdvancedGroup, SWT.RIGHT);\r\n\t\twlRecordsFilter.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.RecordsFilter.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlRecordsFilter);\r\n\t\tfdlRecordsFilter=new FormData();\r\n\t\tfdlRecordsFilter.left = new FormAttachment(0, 0);\r\n\t\tfdlRecordsFilter.right= new FormAttachment(middle, -margin);\r\n\t\tfdlRecordsFilter.top  = new FormAttachment(0, 2*margin);\r\n\t\twlRecordsFilter.setLayoutData(fdlRecordsFilter);\r\n\t\t\r\n\t\twRecordsFilter=new CCombo(wAdvancedGroup, SWT.BORDER | SWT.READ_ONLY);\r\n \t\tprops.setLook(wRecordsFilter);\r\n \t\twRecordsFilter.addModifyListener(lsMod);\r\n\t\tfdRecordsFilter=new FormData();\r\n\t\tfdRecordsFilter.left = new FormAttachment(middle, 0);\r\n\t\tfdRecordsFilter.top  = new FormAttachment(0, 2*margin);\r\n\t\tfdRecordsFilter.right= new FormAttachment(100, -margin);\r\n\t\twRecordsFilter.setLayoutData(fdRecordsFilter);\r\n\t\twRecordsFilter.setItems(SalesforceConnectionUtils.recordsFilterDesc);\r\n\t\twRecordsFilter.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tupdateRecordsFilter();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\topen = new Button (wAdvancedGroup, SWT.PUSH);\r\n\t\topen.setImage(GUIResource.getInstance().getImageCalendar());\r\n\t\topen.setToolTipText (BaseMessages.getString(PKG, \"SalesforceInputDialog.OpenCalendar\"));\r\n\t    FormData fdlButton=new FormData();\r\n\t    fdlButton.top  = new FormAttachment(wRecordsFilter, margin);\r\n\t    fdlButton.right= new FormAttachment(100, 0);\r\n\t    open.setLayoutData(fdlButton);\r\n\t    open.addSelectionListener (new SelectionAdapter () {\r\n\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\tfinal Shell dialog = new Shell (shell, SWT.DIALOG_TRIM );\r\n\t\t\t\tdialog.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.SelectDate\"));\r\n\t\t\t\tdialog.setImage(GUIResource.getInstance().getImageSpoon());\r\n\t\t\t\tdialog.setLayout (new GridLayout (3, false));\r\n\r\n\t\t\t\tfinal DateTime calendar = new DateTime (dialog, SWT.CALENDAR);\r\n\t\t\t    final DateTime time = new DateTime (dialog, SWT.TIME | SWT.TIME);\r\n\t\t\t\tnew Label (dialog, SWT.NONE);\r\n\t\t\t\tnew Label (dialog, SWT.NONE);\r\n\r\n\t\t\t\tButton ok = new Button (dialog, SWT.PUSH);\r\n\t\t\t\tok.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\t\t\t\tok.setLayoutData(new GridData (SWT.FILL, SWT.CENTER, false, false));\r\n\t\t\t\tok.addSelectionListener (new SelectionAdapter () {\r\n\t\t\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\t\t\twReadFrom.setText(calendar.getYear()+\"-\"+\r\n\t\t\t\t\t\t\t\t((calendar.getMonth () + 1)<10 ? \"0\"+(calendar.getMonth () + 1) : (calendar.getMonth () + 1)) \r\n\t\t\t\t\t\t\t\t\t\t+\"-\"+(calendar.getDay()<10 ? \"0\"+calendar.getDay () : calendar.getDay())\r\n\t\t\t\t\t\t\t\t\t\t+\" \"+(time.getHours()<10 ? \"0\"+time.getHours() : time.getHours())\r\n\t\t\t\t\t\t\t\t\t\t+\":\"+(time.getMinutes()<10 ? \"0\"+time.getMinutes() : time.getMinutes())\r\n\t\t\t\t\t\t\t\t\t\t+\":\"+(time.getMinutes()<10 ? \"0\"+time.getMinutes() : time.getMinutes())\t\t\t\t\t\r\n\t\t\t\t\t\t); \r\n\t\t\t\t          \r\n\t\t\t\t\t\tdialog.close ();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tdialog.setDefaultButton (ok);\r\n\t\t\t\tdialog.pack ();\r\n\t\t\t\tdialog.open ();\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\twlReadFrom=new Label(wAdvancedGroup, SWT.RIGHT);\r\n\t\twlReadFrom.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadFrom.Label\"));\r\n \t\tprops.setLook(wlReadFrom);\r\n\t\tfdlReadFrom=new FormData();\r\n\t\tfdlReadFrom.left = new FormAttachment(0, 0);\r\n\t\tfdlReadFrom.top  = new FormAttachment(wRecordsFilter, margin);\r\n\t\tfdlReadFrom.right= new FormAttachment(middle, -margin);\r\n\t\twlReadFrom.setLayoutData(fdlReadFrom);\r\n\t\twReadFrom=new TextVar(transMeta, wAdvancedGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twReadFrom.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadFrom.Tooltip\"));\r\n \t\tprops.setLook(wReadFrom);\r\n\t\twReadFrom.addModifyListener(lsMod);\r\n\t\tfdReadFrom=new FormData();\r\n\t\tfdReadFrom.left = new FormAttachment(middle, 0);\r\n\t\tfdReadFrom.top  = new FormAttachment(wRecordsFilter, margin);\r\n\t\tfdReadFrom.right= new FormAttachment(open, -margin);\r\n\t\twReadFrom.setLayoutData(fdReadFrom);\r\n\r\n\t\t\r\n\t\topento = new Button (wAdvancedGroup, SWT.PUSH);\r\n\t\topento.setImage(GUIResource.getInstance().getImageCalendar());\r\n\t\topento.setToolTipText (BaseMessages.getString(PKG, \"SalesforceInputDialog.OpenCalendar\"));\r\n\t    FormData fdlButtonto=new FormData();\r\n\t    fdlButtonto.top  = new FormAttachment(wReadFrom, 2*margin);\r\n\t    fdlButtonto.right= new FormAttachment(100, 0);\r\n\t    opento.setLayoutData(fdlButtonto);\r\n\t    opento.addSelectionListener (new SelectionAdapter () {\r\n\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\tfinal Shell dialogto = new Shell (shell, SWT.DIALOG_TRIM );\r\n\t\t\t\tdialogto.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.SelectDate\"));\r\n\t\t\t\tdialogto.setImage(GUIResource.getInstance().getImageSpoon());\r\n\t\t\t\tdialogto.setLayout (new GridLayout (3, false));\r\n\r\n\t\t\t\tfinal DateTime calendarto = new DateTime (dialogto, SWT.CALENDAR | SWT.BORDER);\r\n\t\t\t    final DateTime timeto = new DateTime (dialogto, SWT.TIME | SWT.TIME);\r\n\t\t\t\tnew Label (dialogto, SWT.NONE);\r\n\t\t\t\tnew Label (dialogto, SWT.NONE);\r\n\t\t\t\tButton okto = new Button (dialogto, SWT.PUSH);\r\n\t\t\t\tokto.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\t\t\t\tokto.setLayoutData(new GridData (SWT.FILL, SWT.CENTER, false, false));\r\n\t\t\t\tokto.addSelectionListener (new SelectionAdapter () {\r\n\t\t\t\t\tpublic void widgetSelected (SelectionEvent e) {\r\n\t\t\t\t\t\twReadTo.setText(calendarto.getYear()+\"-\"+\r\n\t\t\t\t\t\t\t\t((calendarto.getMonth() + 1)<10 ? \"0\"+(calendarto.getMonth () + 1) : (calendarto.getMonth () + 1)) \r\n\t\t\t\t\t\t\t\t+\"-\"+(calendarto.getDay()<10 ? \"0\"+calendarto.getDay() : calendarto.getDay())\r\n\t\t\t\t\t\t\t\t+\" \"+(timeto.getHours()<10 ? \"0\"+timeto.getHours() : timeto.getHours())\r\n\t\t\t\t\t\t\t\t+\":\"+(timeto.getMinutes()<10 ? \"0\"+timeto.getMinutes() : timeto.getMinutes())\r\n\t\t\t\t\t\t\t\t+\":\"+(timeto.getSeconds()<10 ? \"0\"+timeto.getSeconds() : timeto.getSeconds())\r\n\t\t\t\t\t\t); \r\n\t\t\t\t\t\tdialogto.close ();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tdialogto.setDefaultButton (okto);\r\n\t\t\t\tdialogto.pack ();\r\n\t\t\t\tdialogto.open ();\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\twlReadTo=new Label(wAdvancedGroup, SWT.RIGHT);\r\n\t\twlReadTo.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadTo.Label\"));\r\n \t\tprops.setLook(wlReadTo);\r\n\t\tfdlReadTo=new FormData();\r\n\t\tfdlReadTo.left = new FormAttachment(0, 0);\r\n\t\tfdlReadTo.top  = new FormAttachment(wReadFrom, 2*margin);\r\n\t\tfdlReadTo.right= new FormAttachment(middle, -margin);\r\n\t\twlReadTo.setLayoutData(fdlReadTo);\r\n\t\twReadTo=new TextVar(transMeta, wAdvancedGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twReadTo.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.ReadTo.Tooltip\"));\r\n \t\tprops.setLook(wReadTo);\r\n\t\twReadTo.addModifyListener(lsMod);\r\n\t\tfdReadTo=new FormData();\r\n\t\tfdReadTo.left = new FormAttachment(middle, 0);\r\n\t\tfdReadTo.top  = new FormAttachment(wReadFrom, 2*margin);\r\n\t\tfdReadTo.right= new FormAttachment(opento, -margin);\r\n\t\twReadTo.setLayoutData(fdReadTo);\r\n\r\n\t\t\r\n\t\tfdAdvancedGroup= new FormData();\r\n\t\tfdAdvancedGroup.left = new FormAttachment(0, margin);\r\n\t\tfdAdvancedGroup.top = new FormAttachment(0, 2*margin);\r\n\t\tfdAdvancedGroup.right = new FormAttachment(100, -margin);\r\n\t\twAdvancedGroup.setLayoutData(fdAdvancedGroup);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Advanced GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\r\n\t\t\r\n\t\t// ///////////////////////////////\r\n\t\t// START OF Additional Fields GROUP  //\r\n\t\t///////////////////////////////// \r\n\r\n\t\twAdditionalFields = new Group(wContentComp, SWT.SHADOW_NONE);\r\n\t\tprops.setLook(wAdditionalFields);\r\n\t\twAdditionalFields.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.wAdditionalFields.Label\"));\r\n\t\t\r\n\t\tFormLayout AdditionalFieldsgroupLayout = new FormLayout();\r\n\t\tAdditionalFieldsgroupLayout.marginWidth = 10;\r\n\t\tAdditionalFieldsgroupLayout.marginHeight = 10;\r\n\t\twAdditionalFields.setLayout(AdditionalFieldsgroupLayout);\r\n\t\t\r\n\t\t// Add Salesforce URL in the output stream ?\r\n\t\twlInclURL = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclURL.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclURL.Label\"));\r\n\t\tprops.setLook(wlInclURL);\r\n\t\tfdlInclURL = new FormData();\r\n\t\tfdlInclURL.left = new FormAttachment(0, 0);\r\n\t\tfdlInclURL.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\tfdlInclURL.right = new FormAttachment(middle, -margin);\r\n\t\twlInclURL.setLayoutData(fdlInclURL);\r\n\t\twInclURL = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclURL);\r\n\t\twInclURL.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclURL.Tooltip\"));\r\n\t\tfdInclURL = new FormData();\r\n\t\tfdInclURL.left = new FormAttachment(middle, 0);\r\n\t\tfdInclURL.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\twInclURL.setLayoutData(fdInclURL);\r\n\t\twInclURL.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclTargetURL();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\r\n\t\twlInclURLField = new Label(wAdditionalFields, SWT.LEFT);\r\n\t\twlInclURLField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclURLField.Label\"));\r\n\t\tprops.setLook(wlInclURLField);\r\n\t\tfdlInclURLField = new FormData();\r\n\t\tfdlInclURLField.left = new FormAttachment(wInclURL, margin);\r\n\t\tfdlInclURLField.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\twlInclURLField.setLayoutData(fdlInclURLField);\r\n\t\twInclURLField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\t| SWT.BORDER);\r\n\t\tprops.setLook(wlInclURLField);\r\n\t\twInclURLField.addModifyListener(lsMod);\r\n\t\tfdInclURLField = new FormData();\r\n\t\tfdInclURLField.left = new FormAttachment(wlInclURLField,margin);\r\n\t\tfdInclURLField.top = new FormAttachment(wAdvancedGroup,  margin);\r\n\t\tfdInclURLField.right = new FormAttachment(100, 0);\r\n\t\twInclURLField.setLayoutData(fdInclURLField);\r\n\t\t\r\n\t\t\r\n\t\t//\tAdd module in the output stream ?\r\n\t\twlInclModule = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclModule.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclModule.Label\"));\r\n\t\tprops.setLook(wlInclModule);\r\n\t\tfdlInclModule = new FormData();\r\n\t\tfdlInclModule.left = new FormAttachment(0, 0);\r\n\t\tfdlInclModule.top = new FormAttachment(wInclURLField, margin);\r\n\t\tfdlInclModule.right = new FormAttachment(middle, -margin);\r\n\t\twlInclModule.setLayoutData(fdlInclModule);\r\n\t\twInclModule = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclModule);\r\n\t\twInclModule.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclModule.Tooltip\"));\r\n\t\tfdModule = new FormData();\r\n\t\tfdModule.left = new FormAttachment(middle, 0);\r\n\t\tfdModule.top = new FormAttachment(wInclURLField, margin);\r\n\t\twInclModule.setLayoutData(fdModule);\r\n\r\n\t\twInclModule.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclModule();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t\t\r\n\t\twlInclModuleField = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclModuleField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclModuleField.Label\"));\r\n\t\tprops.setLook(wlInclModuleField);\r\n\t\tfdlInclModuleField = new FormData();\r\n\t\tfdlInclModuleField.left = new FormAttachment(wInclModule, margin);\r\n\t\tfdlInclModuleField.top = new FormAttachment(wInclURLField, margin);\r\n\t\twlInclModuleField.setLayoutData(fdlInclModuleField);\r\n\t\twInclModuleField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\r\n\t\t\t\t| SWT.BORDER);\r\n\t\tprops.setLook(wInclModuleField);\r\n\t\twInclModuleField.addModifyListener(lsMod);\r\n\t\tfdInclModuleField = new FormData();\r\n\t\tfdInclModuleField.left = new FormAttachment(wlInclModuleField, margin);\r\n\t\tfdInclModuleField.top = new FormAttachment(wInclURLField, margin);\r\n\t\tfdInclModuleField.right = new FormAttachment(100, 0);\r\n\t\twInclModuleField.setLayoutData(fdInclModuleField);\r\n\r\n\r\n\t\t// Add SQL in the output stream ?\r\n\t\twlInclSQL = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclSQL.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclSQL.Label\"));\r\n\t\tprops.setLook(wlInclSQL);\r\n\t\tfdlInclSQL = new FormData();\r\n\t\tfdlInclSQL.left = new FormAttachment(0, 0);\r\n\t\tfdlInclSQL.top = new FormAttachment(wInclModuleField, margin);\r\n\t\tfdlInclSQL.right = new FormAttachment(middle, -margin);\r\n\t\twlInclSQL.setLayoutData(fdlInclSQL);\r\n\t\twInclSQL = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclSQL);\r\n\t\twInclSQL.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclSQL.Tooltip\"));\r\n\t\tfdInclSQL = new FormData();\r\n\t\tfdInclSQL.left = new FormAttachment(middle, 0);\r\n\t\tfdInclSQL.top = new FormAttachment(wInclModuleField, margin);\r\n\t\twInclSQL.setLayoutData(fdInclSQL);\r\n\t\twInclSQL.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclSQL();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\r\n\t\twlInclSQLField = new Label(wAdditionalFields, SWT.LEFT);\r\n\t\twlInclSQLField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclSQLField.Label\"));\r\n\t\tprops.setLook(wlInclSQLField);\r\n\t\tfdlInclSQLField = new FormData();\r\n\t\tfdlInclSQLField.left = new FormAttachment(wInclSQL, margin);\r\n\t\tfdlInclSQLField.top = new FormAttachment(wInclModuleField, margin);\r\n\t\twlInclSQLField.setLayoutData(fdlInclSQLField);\r\n\t\twInclSQLField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\t| SWT.BORDER);\r\n\t\tprops.setLook(wlInclSQLField);\r\n\t\twInclSQLField.addModifyListener(lsMod);\r\n\t\tfdInclSQLField = new FormData();\r\n\t\tfdInclSQLField.left = new FormAttachment(wlInclSQLField,margin);\r\n\t\tfdInclSQLField.top = new FormAttachment(wInclModuleField,  margin);\r\n\t\tfdInclSQLField.right = new FormAttachment(100, 0);\r\n\t\twInclSQLField.setLayoutData(fdInclSQLField);\r\n\t\t\r\n\t\t// Add Timestamp in the output stream ?\r\n\t\twlInclTimestamp = new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclTimestamp.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclTimestamp.Label\"));\r\n\t\tprops.setLook(wlInclTimestamp);\r\n\t\tfdlInclTimestamp = new FormData();\r\n\t\tfdlInclTimestamp.left = new FormAttachment(0, 0);\r\n\t\tfdlInclTimestamp.top = new FormAttachment(wInclSQLField, margin);\r\n\t\tfdlInclTimestamp.right = new FormAttachment(middle, -margin);\r\n\t\twlInclTimestamp.setLayoutData(fdlInclTimestamp);\r\n\t\twInclTimestamp = new Button(wAdditionalFields, SWT.CHECK);\r\n\t\tprops.setLook(wInclTimestamp);\r\n\t\twInclTimestamp.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclTimestamp.Tooltip\"));\r\n\t\tfdInclTimestamp = new FormData();\r\n\t\tfdInclTimestamp.left = new FormAttachment(middle, 0);\r\n\t\tfdInclTimestamp.top = new FormAttachment(wInclSQLField, margin);\r\n\t\twInclTimestamp.setLayoutData(fdInclTimestamp);\r\n\t\twInclTimestamp.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclTimestamp();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\r\n\t\twlInclTimestampField = new Label(wAdditionalFields, SWT.LEFT);\r\n\t\twlInclTimestampField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclTimestampField.Label\"));\r\n\t\tprops.setLook(wlInclTimestampField);\r\n\t\tfdlInclTimestampField = new FormData();\r\n\t\tfdlInclTimestampField.left = new FormAttachment(wInclTimestamp, margin);\r\n\t\tfdlInclTimestampField.top = new FormAttachment(wInclSQLField, margin);\r\n\t\twlInclTimestampField.setLayoutData(fdlInclTimestampField);\r\n\t\twInclTimestampField = new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT\t| SWT.BORDER);\r\n\t\tprops.setLook(wlInclTimestampField);\r\n\t\twInclTimestampField.addModifyListener(lsMod);\r\n\t\tfdInclTimestampField = new FormData();\r\n\t\tfdInclTimestampField.left = new FormAttachment(wlInclTimestampField,margin);\r\n\t\tfdInclTimestampField.top = new FormAttachment(wInclSQLField,  margin);\r\n\t\tfdInclTimestampField.right = new FormAttachment(100, 0);\r\n\t\twInclTimestampField.setLayoutData(fdInclTimestampField);\r\n\t\t\r\n\t\t\r\n\t\t// Include Rownum in output stream?\r\n\t\twlInclRownum=new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclRownum.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclRownum.Label\"));\r\n \t\tprops.setLook(wlInclRownum);\r\n\t\tfdlInclRownum=new FormData();\r\n\t\tfdlInclRownum.left = new FormAttachment(0, 0);\r\n\t\tfdlInclRownum.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\tfdlInclRownum.right= new FormAttachment(middle, -margin);\r\n\t\twlInclRownum.setLayoutData(fdlInclRownum);\r\n\t\twInclRownum=new Button(wAdditionalFields, SWT.CHECK );\r\n \t\tprops.setLook(wInclRownum);\r\n\t\twInclRownum.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclRownum.Tooltip\"));\r\n\t\tfdRownum=new FormData();\r\n\t\tfdRownum.left = new FormAttachment(middle, 0);\r\n\t\tfdRownum.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\twInclRownum.setLayoutData(fdRownum);\r\n\r\n\t\twInclRownum.addSelectionListener(new SelectionAdapter() \r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t{\r\n\t\t\t\tsetEnableInclRownum();\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t\t\r\n\t\twlInclRownumField=new Label(wAdditionalFields, SWT.RIGHT);\r\n\t\twlInclRownumField.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.InclRownumField.Label\"));\r\n \t\tprops.setLook(wlInclRownumField);\r\n\t\tfdlInclRownumField=new FormData();\r\n\t\tfdlInclRownumField.left = new FormAttachment(wInclRownum, margin);\r\n\t\tfdlInclRownumField.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\r\n\t\twInclRownumField=new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wInclRownumField);\r\n\t\twInclRownumField.addModifyListener(lsMod);\r\n\t\tfdInclRownumField=new FormData();\r\n\t\tfdInclRownumField.left = new FormAttachment(wlInclRownumField, margin);\r\n\t\tfdInclRownumField.top  = new FormAttachment(wInclTimestampField, margin);\r\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\r\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\r\n\r\n\t\t\r\n\t\tfdAdditionalFields = new FormData();\r\n\t\tfdAdditionalFields.left = new FormAttachment(0, margin);\r\n\t\tfdAdditionalFields.top = new FormAttachment(wAdvancedGroup, margin);\r\n\t\tfdAdditionalFields.right = new FormAttachment(100, -margin);\r\n\t\twAdditionalFields.setLayoutData(fdAdditionalFields);\r\n\t\t\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF Additional Fields GROUP\r\n\t\t// ///////////////////////////////////////////////////////////\t\r\n\t\r\n\t\t// Timeout\r\n\t\twlTimeOut = new Label(wContentComp, SWT.RIGHT);\r\n\t\twlTimeOut.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.TimeOut.Label\"));\r\n\t\tprops.setLook(wlTimeOut);\r\n\t\tfdlTimeOut = new FormData();\r\n\t\tfdlTimeOut.left = new FormAttachment(0, 0);\r\n\t\tfdlTimeOut.top = new FormAttachment(wAdditionalFields, 2*margin);\r\n\t\tfdlTimeOut.right = new FormAttachment(middle, -margin);\r\n\t\twlTimeOut.setLayoutData(fdlTimeOut);\r\n\t\twTimeOut = new TextVar(transMeta,wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wTimeOut);\r\n\t\twTimeOut.addModifyListener(lsMod);\r\n\t\tfdTimeOut = new FormData();\r\n\t\tfdTimeOut.left = new FormAttachment(middle, 0);\r\n\t\tfdTimeOut.top = new FormAttachment(wAdditionalFields, 2*margin);\r\n\t\tfdTimeOut.right = new FormAttachment(100, 0);\r\n\t\twTimeOut.setLayoutData(fdTimeOut);\r\n\t\t\r\n\t\t\r\n\t\t// Use compression?\r\n\t\twlUseCompression=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlUseCompression.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.UseCompression.Label\"));\r\n \t\tprops.setLook(wlUseCompression);\r\n\t\tfdlUseCompression=new FormData();\r\n\t\tfdlUseCompression.left = new FormAttachment(0, 0);\r\n\t\tfdlUseCompression.top  = new FormAttachment(wTimeOut, margin);\r\n\t\tfdlUseCompression.right= new FormAttachment(middle, -margin);\r\n\t\twlUseCompression.setLayoutData(fdlUseCompression);\r\n\t\twUseCompression=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wUseCompression);\r\n\t\twUseCompression.setToolTipText(BaseMessages.getString(PKG, \"SalesforceInputDialog.UseCompression.Tooltip\"));\r\n\t\tfdUseCompression=new FormData();\r\n\t\tfdUseCompression.left = new FormAttachment(middle, 0);\r\n\t\tfdUseCompression.top  = new FormAttachment(wTimeOut, margin);\r\n\t\twUseCompression.setLayoutData(fdUseCompression);\r\n\r\n\t\t\r\n\t\t// Limit rows\r\n\t\twlLimit = new Label(wContentComp, SWT.RIGHT);\r\n\t\twlLimit.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Limit.Label\"));\r\n\t\tprops.setLook(wlLimit);\r\n\t\tfdlLimit = new FormData();\r\n\t\tfdlLimit.left = new FormAttachment(0, 0);\r\n\t\tfdlLimit.top = new FormAttachment(wUseCompression, margin);\r\n\t\tfdlLimit.right = new FormAttachment(middle, -margin);\r\n\t\twlLimit.setLayoutData(fdlLimit);\r\n\t\twLimit = new TextVar(transMeta,wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wLimit);\r\n\t\twLimit.addModifyListener(lsMod);\r\n\t\tfdLimit = new FormData();\r\n\t\tfdLimit.left = new FormAttachment(middle, 0);\r\n\t\tfdLimit.top = new FormAttachment(wUseCompression, margin);\r\n\t\tfdLimit.right = new FormAttachment(100, 0);\r\n\t\twLimit.setLayoutData(fdLimit);\r\n\r\n\t\tfdContentComp = new FormData();\r\n\t\tfdContentComp.left = new FormAttachment(0, 0);\r\n\t\tfdContentComp.top = new FormAttachment(0, 0);\r\n\t\tfdContentComp.right = new FormAttachment(100, 0);\r\n\t\tfdContentComp.bottom = new FormAttachment(100, 0);\r\n\t\twContentComp.setLayoutData(fdContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\t\t// / END OF CONTENT TAB\r\n\t\t// ///////////////////////////////////////////////////////////\r\n\r\n\t\t// Fields tab...\r\n\t\t//\r\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFieldsTab.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Fields.Tab\"));\r\n\r\n\t\tFormLayout fieldsLayout = new FormLayout();\r\n\t\tfieldsLayout.marginWidth = Const.FORM_MARGIN;\r\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\twFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twFieldsComp.setLayout(fieldsLayout);\r\n\t\tprops.setLook(wFieldsComp);\r\n\r\n\t\twGet = new Button(wFieldsComp, SWT.PUSH);\r\n\t\twGet.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.GetFields.Button\"));\r\n\t\tfdGet = new FormData();\r\n\t\tfdGet.left = new FormAttachment(50, 0);\r\n\t\tfdGet.bottom = new FormAttachment(100, 0);\r\n\t\twGet.setLayoutData(fdGet);\r\n\r\n\r\n\t\tfinal int FieldsRows = input.getInputFields().length;\r\n\r\n\t\tColumnInfo[] colinf = new ColumnInfo[] {\r\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Name.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Field.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Type.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes(), true),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Format.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_FORMAT, 3),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Length.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Precision.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Currency.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Decimal.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Group.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_TEXT, false),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.TrimType.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_CCOMBO,\r\n\t\t\t\t\t\tSalesforceInputField.trimTypeDesc, true),\r\n\t\t\t\tnew ColumnInfo(\r\n\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Repeat.Column\"),\r\n\t\t\t\t\t\tColumnInfo.COLUMN_TYPE_CCOMBO, new String[] {\r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"System.Combo.Yes\"),\r\n\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"System.Combo.No\") }, true),\r\n\r\n\t\t};\r\n\r\n\t\tcolinf[0].setUsingVariables(true);\r\n\t\tcolinf[0].setToolTip(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Name.Column.Tooltip\"));\r\n\t\tcolinf[1].setUsingVariables(true);\r\n\t\tcolinf[1].setToolTip(BaseMessages.getString(PKG, \"SalesforceInputDialog.FieldsTable.Field.Column.Tooltip\"));\r\n\r\n\t\twFields=new TableView(transMeta,wFieldsComp, \r\n\t\t\t      SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t      colinf, \r\n\t\t\t      FieldsRows,  \r\n\t\t\t      lsMod,\r\n\t\t\t\t  props\r\n\t\t\t      );\r\n\t\t\r\n\t\tfdFields = new FormData();\r\n\t\tfdFields.left = new FormAttachment(0, 0);\r\n\t\tfdFields.top = new FormAttachment(0, 0);\r\n\t\tfdFields.right = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom = new FormAttachment(wGet, -margin);\r\n\t\twFields.setLayoutData(fdFields);\r\n\r\n\t\tfdFieldsComp = new FormData();\r\n\t\tfdFieldsComp.left = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.top = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\r\n\t\tfdFieldsComp.bottom = new FormAttachment(100, 0);\r\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\r\n\r\n\t\twFieldsComp.layout();\r\n\t\twFieldsTab.setControl(wFieldsComp);\r\n\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom = new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\t\t\r\n\t\t\r\n\r\n\t\t// THE BUTTONS\r\n\t\twOK = new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\r\n\t\twPreview = new Button(shell, SWT.PUSH);\r\n\t\twPreview.setText(BaseMessages.getString(PKG, \"SalesforceInputDialog.Button.PreviewRows\"));\r\n\r\n\t\twCancel = new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder);\r\n\r\n\t\t// Add listeners\r\n\t\tlsOK = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t\t\tok();\r\n\t\t\t}\r\n\t\t};\r\n\t\tlsTest     = new Listener() { public void handleEvent(Event e) { test(); } };\r\n\t\tlsGet = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t        Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n\t\t        shell.setCursor(busy);\r\n\t\t\t\tget();\r\n\t\t        shell.setCursor(null);\r\n\t\t        busy.dispose();\r\n\t\t\t}\r\n\t\t};\r\n\t\tlsPreview = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t\t\tpreview();\r\n\t\t\t}\r\n\t\t};\r\n\t\tlsCancel = new Listener() {\r\n\t\t\tpublic void handleEvent(Event e) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\twOK.addListener(SWT.Selection, lsOK);\r\n\t\twGet.addListener(SWT.Selection, lsGet);\r\n\t\twTest.addListener    (SWT.Selection, lsTest    );\t\r\n\t\twPreview.addListener(SWT.Selection, lsPreview);\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\t\tlsDef = new SelectionAdapter() {\r\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\r\n\t\t\t\tok();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\twStepname.addSelectionListener(lsDef);\r\n\t\twLimit.addSelectionListener(lsDef);\r\n\t\twInclModuleField.addSelectionListener(lsDef);\r\n\t\twInclURLField.addSelectionListener(lsDef);\r\n\r\n\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(new ShellAdapter() {\r\n\t\t\tpublic void shellClosed(ShellEvent e) {\r\n\t\t\t\tcancel();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\twTabFolder.setSelection(0);\r\n\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\tgetData(input);\r\n\t\tsetEnableInclTargetURL();\r\n\t\tsetEnableInclSQL();\r\n\t\tsetEnableInclTimestamp();\r\n\t\tsetEnableInclModule();\r\n\t\tsetEnableInclRownum();\r\n\t\tsetEnableQuery();\r\n\t\r\n\t\tinput.setChanged(changed);\r\n\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed()) {\r\n\t\t\tif (!display.readAndDispatch())\r\n\t\t\t\tdisplay.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","commit_id":"3a1d3403292d03aadf2b2715b4fcd4feb51c8bdb","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    public void run(IAction action) {\n        if (selection==null || !(selection instanceof IStructuredSelection)) {\n            return;\n        }\n        IStructuredSelection ss = (IStructuredSelection)selection;\n        JcrNode node = (JcrNode) ss.getFirstElement();\n        if (!node.canCreateChild()) {\n            MessageDialog.openInformation(shell, \"Cannot create node\",\n                    \"Node is not covered by the workspace filter as defined in filter.xml\");\n            return;\n        }\n        Repository repository = ServerUtil.getDefaultRepository(node.getProject());\n        NodeTypeRegistry ntManager = (repository==null) ? null : repository.getNodeTypeRegistry();\n        if (ntManager == null) {\n            MessageDialog.openWarning(null, \"Unable to create a new node\", \"Unable to create a new node since project \"\n                    + node.getProject().getName() + \" is not associated with a server or the server is not started.\");\n            return;\n        }\n        final NodeType nodeType = node.getNodeType();\n        if (nodeType!=null && nodeType.getName()!=null && nodeType.getName().equals(\"nt:file\")) {\n            MessageDialog.openInformation(shell, \"Cannot create node\", \"Node of type nt:file cannot have children\");\n            return;\n        }\n        \n        try {\n            final NewNodeDialog nnd = new NewNodeDialog(shell, node, ntManager);\n            if (nnd.open() == IStatus.OK) {\n                node.createChild(nnd.getValue(), nnd.getChosenNodeType());\n                return;\n            }\n        } catch (RepositoryException e1) {\n            Activator.getDefault().getPluginLogger().warn(\n                    \"Could not open NewNodeDialog due to \"+e1, e1);\n        }\n        \n    }","id":88001,"modified_method":"@Override\n    public void run(IAction action) {\n        if (selection==null || !(selection instanceof IStructuredSelection)) {\n            return;\n        }\n        IStructuredSelection ss = (IStructuredSelection)selection;\n        JcrNode node = (JcrNode) ss.getFirstElement();\n        if (!node.canCreateChild()) {\n            MessageDialog.openInformation(shell, \"Cannot create node\",\n                    \"Node is not covered by the workspace filter as defined in filter.xml\");\n            return;\n        }\n        Repository repository = ServerUtil.getDefaultRepository(node.getProject());\n        NodeTypeRegistry ntManager = (repository==null) ? null : repository.getNodeTypeRegistry();\n        if (ntManager == null) {\n            \n            if (!doNotAskAgain) {\n                MessageDialog dialog = new MessageDialog(null,  \"Unable to validate node type\", null,\n                        \"Unable to validate node types since project \" + node.getProject().getName() + \" is not associated with a server or the server is not started.\",\n                        MessageDialog.QUESTION_WITH_CANCEL, \n                        new String[] {\"Cancel\", \"Continue (do not ask again)\", \"Continue\"}, 1) {\n                    @Override\n                    protected void configureShell(Shell shell) {\n                        super.configureShell(shell);\n                        setShellStyle(getShellStyle() | SWT.SHEET);\n                    }\n                };\n                int choice = dialog.open();\n                if (choice <= 0) {\n                    return;\n                }\n                if (choice==1) {\n                    doNotAskAgain = true;\n                }\n            }\n\n        }\n        final NodeType nodeType = node.getNodeType();\n        if (nodeType!=null && nodeType.getName()!=null && nodeType.getName().equals(\"nt:file\")) {\n            MessageDialog.openInformation(shell, \"Cannot create node\", \"Node of type nt:file cannot have children\");\n            return;\n        }\n        \n        try {\n            final NewNodeDialog nnd = new NewNodeDialog(shell, node, ntManager);\n            if (nnd.open() == IStatus.OK) {\n                node.createChild(nnd.getValue(), nnd.getChosenNodeType());\n                return;\n            }\n        } catch (RepositoryException e1) {\n            Activator.getDefault().getPluginLogger().warn(\n                    \"Could not open NewNodeDialog due to \"+e1, e1);\n        }\n        \n    }","commit_id":"3c6dd16f392d1e6e5d40bc2ad38d9805b97d616b","url":"https://github.com/apache/sling"},{"original_method":"protected void validateInput() {\n        final String firstInput = getText().getText();\n        final String secondInput = comboSelection;\n        try {\n            if (secondInput==null || secondInput.length()==0) {\n                setErrorMessage(\"\");\n            } else if (ntManager.isAllowedPrimaryChildNodeType(parentNodeType, secondInput)) {\n                // also check on the name, not only the type\n                if (allChildNodeDefs==null) {\n                    setErrorMessage(\"No child node definitions found for \"+parentNodeType);\n                } else {\n                    boolean fail = false;\n                    for (int i = 0; i < allChildNodeDefs.length; i++) {\n                        NodeDefinition aChildNodeDef = allChildNodeDefs[i];\n                        if (aChildNodeDef.getName()!=null && aChildNodeDef.getName().length()>0) {\n                            if (firstInput.equals(aChildNodeDef.getName())) {\n                                setErrorMessage(null);\n                                return;\n                            } else {\n                                // mark fail if no other child node definition matches\n                                fail = true;\n                            }\n                        }\n                    }\n                    if (!fail) {\n                        setErrorMessage(null);\n                        return;\n                    }\n                    StringBuffer details = new StringBuffer();\n                    for (int i = 0; i < allChildNodeDefs.length; i++) {\n                        NodeDefinition aChildNodeDef = allChildNodeDefs[i];\n                        if (details.length()!=0) {\n                            details.append(\", \");\n                        }\n                        details.append(\"(name=\"+aChildNodeDef.getName()+\", required primary type(s)=\");\n                        String[] requiredPrimaryTypeNames = aChildNodeDef.getRequiredPrimaryTypeNames();\n                        if (requiredPrimaryTypeNames==null) {\n                            details.append(\"null\");\n                        } else {\n                            for (int j = 0; j < requiredPrimaryTypeNames.length; j++) {\n                                String rptn = requiredPrimaryTypeNames[j];\n                                if (j>0) {\n                                    details.append(\",\");\n                                }\n                                details.append(rptn);\n                            }\n                        }\n                        details.append(\")\");\n                    }\n                    setErrorMessage(\"No matching child node definition found for \"+parentNodeType+\". Expected one of: \"+details);\n                }\n            } else {\n                setErrorMessage(\"Error: Invalid child node type of \"+parentNodeType);\n            }\n        } catch(RepositoryException e) {\n            setErrorMessage(\"RepositoryException: \"+e);\n        }\n        \n    }","id":88002,"modified_method":"protected void validateInput() {\n        final String firstInput = getText().getText();\n        final String secondInput = comboSelection;\n        try {\n            if (secondInput==null || secondInput.length()==0) {\n                setErrorMessage(\"\");\n            } else if (ntManager==null) {\n                setErrorMessage(null);\n            } else if (ntManager.isAllowedPrimaryChildNodeType(parentNodeType, secondInput)) {\n                // also check on the name, not only the type\n                if (allChildNodeDefs==null) {\n                    setErrorMessage(\"No child node definitions found for \"+parentNodeType);\n                } else {\n                    boolean fail = false;\n                    for (int i = 0; i < allChildNodeDefs.length; i++) {\n                        NodeDefinition aChildNodeDef = allChildNodeDefs[i];\n                        if (aChildNodeDef.getName()!=null && aChildNodeDef.getName().length()>0) {\n                            if (firstInput.equals(aChildNodeDef.getName())) {\n                                setErrorMessage(null);\n                                return;\n                            } else {\n                                // mark fail if no other child node definition matches\n                                fail = true;\n                            }\n                        }\n                    }\n                    if (!fail) {\n                        setErrorMessage(null);\n                        return;\n                    }\n                    StringBuffer details = new StringBuffer();\n                    for (int i = 0; i < allChildNodeDefs.length; i++) {\n                        NodeDefinition aChildNodeDef = allChildNodeDefs[i];\n                        if (details.length()!=0) {\n                            details.append(\", \");\n                        }\n                        details.append(\"(name=\"+aChildNodeDef.getName()+\", required primary type(s)=\");\n                        String[] requiredPrimaryTypeNames = aChildNodeDef.getRequiredPrimaryTypeNames();\n                        if (requiredPrimaryTypeNames==null) {\n                            details.append(\"null\");\n                        } else {\n                            for (int j = 0; j < requiredPrimaryTypeNames.length; j++) {\n                                String rptn = requiredPrimaryTypeNames[j];\n                                if (j>0) {\n                                    details.append(\",\");\n                                }\n                                details.append(rptn);\n                            }\n                        }\n                        details.append(\")\");\n                    }\n                    setErrorMessage(\"No matching child node definition found for \"+parentNodeType+\". Expected one of: \"+details);\n                }\n            } else {\n                setErrorMessage(\"Error: Invalid child node type of \"+parentNodeType);\n            }\n        } catch(RepositoryException e) {\n            setErrorMessage(\"RepositoryException: \"+e);\n        }\n        \n    }","commit_id":"3c6dd16f392d1e6e5d40bc2ad38d9805b97d616b","url":"https://github.com/apache/sling"},{"original_method":"public String getChosenNodeType() {\n        return comboSelection;\n    }","id":88003,"modified_method":"public String getChosenNodeType() {\n        lastChosenNodeType = comboSelection;\n        return comboSelection;\n    }","commit_id":"3c6dd16f392d1e6e5d40bc2ad38d9805b97d616b","url":"https://github.com/apache/sling"},{"original_method":"public NewNodeDialog(Shell parentShell, JcrNode node,\n            NodeTypeRegistry ntManager) throws RepositoryException {\n        super(parentShell, \"Enter Node Name\",\n                \"Enter name for new node under:\\n path: \"+node.getJcrPath(), \"\", null);\n        this.parentNodeType = node.getPrimaryType();\n        this.ntManager = ntManager;\n        final LinkedList<String> ac = new LinkedList<String>(ntManager.getAllowedPrimaryChildNodeTypes(parentNodeType));\n        final NodeType parentNt = ntManager.getNodeType(parentNodeType);\n        allChildNodeDefs = parentNt.getChildNodeDefinitions();\n        Collections.sort(ac);\n        this.allowedChildren = ac;\n    }","id":88004,"modified_method":"public NewNodeDialog(Shell parentShell, JcrNode node,\n            NodeTypeRegistry ntManager) throws RepositoryException {\n        super(parentShell, \"Enter Node Name\",\n                \"Enter name for new node under:\\n path: \"+node.getJcrPath(), \"\", null);\n        this.parentNodeType = node.getPrimaryType();\n        this.ntManager = ntManager;\n        if (ntManager!=null) {\n            final LinkedList<String> ac = new LinkedList<String>(ntManager.getAllowedPrimaryChildNodeTypes(parentNodeType));\n            final NodeType parentNt = ntManager.getNodeType(parentNodeType);\n            allChildNodeDefs = parentNt.getChildNodeDefinitions();\n            Collections.sort(ac);\n            this.allowedChildren = ac;\n        }\n    }","commit_id":"3c6dd16f392d1e6e5d40bc2ad38d9805b97d616b","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        \n        Control[] children = composite.getChildren();\n        Control errorMessageText = children[children.length-1];\n        GridData errorMessageGridData = new GridData(GridData.GRAB_HORIZONTAL\n                | GridData.HORIZONTAL_ALIGN_FILL);\n        errorMessageGridData.heightHint = convertHeightInCharsToPixels(2);\n        errorMessageText.setLayoutData(errorMessageGridData);\n        \n        // now add the node type dropbox-combo\n        Label label = new Label(composite, SWT.WRAP);\n        label.moveAbove(errorMessageText);\n        label.setText(\"Define node type\");\n        GridData data = new GridData(GridData.GRAB_HORIZONTAL\n                | GridData.GRAB_VERTICAL | GridData.HORIZONTAL_ALIGN_FILL\n                | GridData.VERTICAL_ALIGN_CENTER);\n        data.widthHint = convertHorizontalDLUsToPixels(IDialogConstants.MINIMUM_MESSAGE_AREA_WIDTH);\n        label.setLayoutData(data);\n        label.setFont(parent.getFont());\n\n        combo = new Combo(composite, SWT.DROP_DOWN);\n        combo.moveAbove(errorMessageText);\n        combo.setItems(allowedChildren.toArray(new String[0]));\n        combo.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL\n                | GridData.HORIZONTAL_ALIGN_FILL));\n        combo.addSelectionListener(new SelectionAdapter() {\n            @Override\n            public void widgetSelected(SelectionEvent e) {\n                comboSelection = combo.getText();\n                validateInput();\n            }\n        });\n        combo.addModifyListener(new ModifyListener() {\n\n            @Override\n            public void modifyText(ModifyEvent e) {\n                comboSelection = combo.getText();\n                validateInput();\n            }\n            \n        });\n\n        SimpleContentProposalProvider proposalProvider = new SimpleContentProposalProvider(combo.getItems());\n        proposalProvider.setFiltering(true);\n        final ComboContentAdapter controlContentAdapter = new ComboContentAdapter() {\n            @Override\n            public void insertControlContents(Control control, String text,\n                    int cursorPosition) {\n                Point selection = combo.getSelection();\n                combo.setText(text);\n                selection.x = selection.x + cursorPosition;\n                selection.y = selection.x;\n                combo.setSelection(selection);\n            }\n            \n            @Override\n            public Rectangle getInsertionBounds(Control control) {\n                final Rectangle insertionBounds = super.getInsertionBounds(control);\n                // always insert at start\n                insertionBounds.x = 0;\n                insertionBounds.y = 0;\n                return insertionBounds;\n            }\n            \n            \n        };\n        // this variant opens auto-complete on each character\n        proposalAdapter = new ContentProposalAdapter(combo, controlContentAdapter, proposalProvider, null, null);\n        // this variant opens auto-complete only when invoking the auto-complete hotkey\n//        proposalAdapter = new ContentAssistCommandAdapter(combo, controlContentAdapter,\n//            proposalProvider, null, new char[0], true);\n        if (allowedChildren.size()==1) {\n            combo.setText(allowedChildren.iterator().next());\n        }\n        \n        return composite;\n    }","id":88005,"modified_method":"@Override\n    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        \n        Control[] children = composite.getChildren();\n        Control errorMessageText = children[children.length-1];\n        GridData errorMessageGridData = new GridData(GridData.GRAB_HORIZONTAL\n                | GridData.HORIZONTAL_ALIGN_FILL);\n        errorMessageGridData.heightHint = convertHeightInCharsToPixels(2);\n        errorMessageText.setLayoutData(errorMessageGridData);\n        \n        // now add the node type dropbox-combo\n        Label label = new Label(composite, SWT.WRAP);\n        label.moveAbove(errorMessageText);\n        label.setText(\"Define node type\");\n        GridData data = new GridData(GridData.GRAB_HORIZONTAL\n                | GridData.GRAB_VERTICAL | GridData.HORIZONTAL_ALIGN_FILL\n                | GridData.VERTICAL_ALIGN_CENTER);\n        data.widthHint = convertHorizontalDLUsToPixels(IDialogConstants.MINIMUM_MESSAGE_AREA_WIDTH);\n        label.setLayoutData(data);\n        label.setFont(parent.getFont());\n\n        combo = new Combo(composite, SWT.DROP_DOWN);\n        combo.moveAbove(errorMessageText);\n        if (allowedChildren!=null) {\n            combo.setItems(allowedChildren.toArray(new String[0]));\n        }\n        combo.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL\n                | GridData.HORIZONTAL_ALIGN_FILL));\n        combo.addSelectionListener(new SelectionAdapter() {\n            @Override\n            public void widgetSelected(SelectionEvent e) {\n                comboSelection = combo.getText();\n                validateInput();\n            }\n        });\n        combo.addModifyListener(new ModifyListener() {\n\n            @Override\n            public void modifyText(ModifyEvent e) {\n                comboSelection = combo.getText();\n                validateInput();\n            }\n            \n        });\n\n        SimpleContentProposalProvider proposalProvider = new SimpleContentProposalProvider(combo.getItems());\n        proposalProvider.setFiltering(true);\n        final ComboContentAdapter controlContentAdapter = new ComboContentAdapter() {\n            @Override\n            public void insertControlContents(Control control, String text,\n                    int cursorPosition) {\n                Point selection = combo.getSelection();\n                combo.setText(text);\n                selection.x = selection.x + cursorPosition;\n                selection.y = selection.x;\n                combo.setSelection(selection);\n            }\n            \n            @Override\n            public Rectangle getInsertionBounds(Control control) {\n                final Rectangle insertionBounds = super.getInsertionBounds(control);\n                // always insert at start\n                insertionBounds.x = 0;\n                insertionBounds.y = 0;\n                return insertionBounds;\n            }\n            \n            \n        };\n        // this variant opens auto-complete on each character\n        proposalAdapter = new ContentProposalAdapter(combo, controlContentAdapter, proposalProvider, null, null);\n        // this variant opens auto-complete only when invoking the auto-complete hotkey\n        if (allowedChildren!=null && allowedChildren.size()==1) {\n            combo.setText(allowedChildren.iterator().next());\n        } else if (allowedChildren!=null) {\n            if (allowedChildren.contains(lastChosenNodeType)) {\n                combo.setText(lastChosenNodeType);\n            }\n        }\n        \n        return composite;\n    }","commit_id":"3c6dd16f392d1e6e5d40bc2ad38d9805b97d616b","url":"https://github.com/apache/sling"},{"original_method":"public static MappingConfig_AbstractRef loadGeneratorMappingConfigRef(final Element parentElement, final String genUID, boolean childOfGen) {\n    if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-mappings\")).isNotEmpty()) {\n      return new MappingConfig_RefAllGlobal();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-local-mappings\")).isNotEmpty()) {\n      final MappingConfig_RefAllLocal local = new MappingConfig_RefAllLocal();\n      if (childOfGen) {\n        return local;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_35 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_36 = ModuleReference.fromString(genUID);\n          result_9427_35.setGenerator(result_9427_36);\n          MappingConfig_AbstractRef result_9427_37 = local;\n          result_9427_35.setMappingConfig(result_9427_37);\n          return result_9427_35;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).isNotEmpty()) {\n      final MappingConfig_RefSet mappingSet = new MappingConfig_RefSet();\n      for (Element mappingSetElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).first(), \"mapping-set-element\"))) {\n        mappingSet.getMappingConfigs().add(loadGeneratorMappingConfigRef(mappingSetElement, genUID, true));\n      }\n\n      if (childOfGen) {\n        return mappingSet;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_38 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_39 = ModuleReference.fromString(genUID);\n          result_9427_38.setGenerator(result_9427_39);\n          MappingConfig_AbstractRef result_9427_40 = mappingSet;\n          result_9427_38.setMappingConfig(result_9427_40);\n          return result_9427_38;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).isNotEmpty()) {\n      // external reference \n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_41 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_42 = ModuleReference.fromString(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"));\n          result_9427_41.setGenerator(result_9427_42);\n          MappingConfig_AbstractRef result_9427_43 = loadGeneratorMappingConfigRef(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"external-mapping\")).first(), ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"), true);\n          result_9427_41.setMappingConfig(result_9427_43);\n          return result_9427_41;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).isNotEmpty()) {\n      // simple reference \n      ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first();\n\n      final MappingConfig_SimpleRef mapping_SimpleRef = new MappingConfig_SimpleRef();\n      MappingConfig_SimpleRef result_9427_44 = mapping_SimpleRef;\n      String result_9427_45 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"modelUID\");\n      result_9427_44.setModelUID(result_9427_45);\n      String result_9427_46 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"nodeID\");\n      result_9427_44.setNodeID(result_9427_46);\n\n      if (childOfGen) {\n        return mapping_SimpleRef;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_47 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_48 = ModuleReference.fromString(genUID);\n          result_9427_47.setGenerator(result_9427_48);\n          MappingConfig_AbstractRef result_9427_49 = mapping_SimpleRef;\n          result_9427_47.setMappingConfig(result_9427_49);\n          return result_9427_47;\n        }\n      }.invoke();\n    }\n\n    // empty? \n    return new MappingConfig_AbstractRef();\n  }","id":88006,"modified_method":"public static MappingConfig_AbstractRef loadGeneratorMappingConfigRef(final Element parentElement, final String genUID, boolean childOfGen) {\n    if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-mappings\")).isNotEmpty()) {\n      return new MappingConfig_RefAllGlobal();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-local-mappings\")).isNotEmpty()) {\n      final MappingConfig_RefAllLocal local = new MappingConfig_RefAllLocal();\n      if (childOfGen) {\n        return local;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_34 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_35 = ModuleReference.fromString(genUID);\n          result_9427_34.setGenerator(result_9427_35);\n          MappingConfig_AbstractRef result_9427_36 = local;\n          result_9427_34.setMappingConfig(result_9427_36);\n          return result_9427_34;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).isNotEmpty()) {\n      final MappingConfig_RefSet mappingSet = new MappingConfig_RefSet();\n      for (Element mappingSetElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).first(), \"mapping-set-element\"))) {\n        mappingSet.getMappingConfigs().add(loadGeneratorMappingConfigRef(mappingSetElement, genUID, true));\n      }\n\n      if (childOfGen) {\n        return mappingSet;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_37 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_38 = ModuleReference.fromString(genUID);\n          result_9427_37.setGenerator(result_9427_38);\n          MappingConfig_AbstractRef result_9427_39 = mappingSet;\n          result_9427_37.setMappingConfig(result_9427_39);\n          return result_9427_37;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).isNotEmpty()) {\n      // external reference \n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_40 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_41 = ModuleReference.fromString(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"));\n          result_9427_40.setGenerator(result_9427_41);\n          MappingConfig_AbstractRef result_9427_42 = loadGeneratorMappingConfigRef(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"external-mapping\")).first(), ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"), true);\n          result_9427_40.setMappingConfig(result_9427_42);\n          return result_9427_40;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).isNotEmpty()) {\n      // simple reference \n      ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first();\n\n      final MappingConfig_SimpleRef mapping_SimpleRef = new MappingConfig_SimpleRef();\n      MappingConfig_SimpleRef result_9427_43 = mapping_SimpleRef;\n      String result_9427_44 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"modelUID\");\n      result_9427_43.setModelUID(result_9427_44);\n      String result_9427_45 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"nodeID\");\n      result_9427_43.setNodeID(result_9427_45);\n\n      if (childOfGen) {\n        return mapping_SimpleRef;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_46 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_47 = ModuleReference.fromString(genUID);\n          result_9427_46.setGenerator(result_9427_47);\n          MappingConfig_AbstractRef result_9427_48 = mapping_SimpleRef;\n          result_9427_46.setMappingConfig(result_9427_48);\n          return result_9427_46;\n        }\n      }.invoke();\n    }\n\n    // empty? \n    return new MappingConfig_AbstractRef();\n  }","commit_id":"1acee04a5cdf3000385119c82da2881bd49cde60","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void saveGeneratorMappingConfigRef(MappingConfig_AbstractRef mappingRef, Element parentElement) {\n    Element result_9427_24 = parentElement;\n    if (mappingRef instanceof MappingConfig_RefAllLocal) {\n      Element result_9427_25 = new Element(\"all-local-mappings\");\n      result_9427_24.addContent(result_9427_25);\n    } else if (mappingRef instanceof MappingConfig_RefAllGlobal) {\n      Element result_9427_26 = new Element(\"all-mappings\");\n      result_9427_24.addContent(result_9427_26);\n    } else if (mappingRef instanceof MappingConfig_SimpleRef) {\n      Element result_9427_27 = new Element(\"mapping-node\");\n      String result_9427_28 = ((MappingConfig_SimpleRef) mappingRef).getModelUID();\n      result_9427_27.setAttribute(\"modelUID\", \"\" + result_9427_28);\n      String result_9427_29 = ((MappingConfig_SimpleRef) mappingRef).getNodeID();\n      result_9427_27.setAttribute(\"nodeID\", \"\" + result_9427_29);\n      result_9427_24.addContent(result_9427_27);\n    } else if (mappingRef instanceof MappingConfig_ExternalRef) {\n      Element result_9427_30 = new Element(\"generator\");\n      String result_9427_31 = ((MappingConfig_ExternalRef) mappingRef).getGenerator().toString();\n      result_9427_30.setAttribute(\"generatorUID\", \"\" + result_9427_31);\n      result_9427_24.addContent(result_9427_30);\n      Element result_9427_32 = new Element(\"external-mapping\");\n      saveGeneratorMappingConfigRef(((MappingConfig_ExternalRef) mappingRef).getMappingConfig(), result_9427_32);\n      result_9427_24.addContent(result_9427_32);\n    } else if (mappingRef instanceof MappingConfig_RefSet) {\n      Element result_9427_33 = new Element(\"mapping-set\");\n      for (MappingConfig_AbstractRef mappingRefInner : ListSequence.fromList(((MappingConfig_RefSet) mappingRef).getMappingConfigs())) {\n        Element result_9427_34 = new Element(\"mapping-set-element\");\n        saveGeneratorMappingConfigRef(mappingRefInner, result_9427_34);\n        result_9427_33.addContent(result_9427_34);\n      }\n      result_9427_24.addContent(result_9427_33);\n    }\n  }","id":88007,"modified_method":"private static void saveGeneratorMappingConfigRef(MappingConfig_AbstractRef mappingRef, Element parentElement) {\n    Element result_9427_23 = parentElement;\n    if (mappingRef instanceof MappingConfig_RefAllLocal) {\n      Element result_9427_24 = new Element(\"all-local-mappings\");\n      result_9427_23.addContent(result_9427_24);\n    } else if (mappingRef instanceof MappingConfig_RefAllGlobal) {\n      Element result_9427_25 = new Element(\"all-mappings\");\n      result_9427_23.addContent(result_9427_25);\n    } else if (mappingRef instanceof MappingConfig_SimpleRef) {\n      Element result_9427_26 = new Element(\"mapping-node\");\n      String result_9427_27 = ((MappingConfig_SimpleRef) mappingRef).getModelUID();\n      result_9427_26.setAttribute(\"modelUID\", \"\" + result_9427_27);\n      String result_9427_28 = ((MappingConfig_SimpleRef) mappingRef).getNodeID();\n      result_9427_26.setAttribute(\"nodeID\", \"\" + result_9427_28);\n      result_9427_23.addContent(result_9427_26);\n    } else if (mappingRef instanceof MappingConfig_ExternalRef) {\n      Element result_9427_29 = new Element(\"generator\");\n      String result_9427_30 = ((MappingConfig_ExternalRef) mappingRef).getGenerator().toString();\n      result_9427_29.setAttribute(\"generatorUID\", \"\" + result_9427_30);\n      result_9427_23.addContent(result_9427_29);\n      Element result_9427_31 = new Element(\"external-mapping\");\n      saveGeneratorMappingConfigRef(((MappingConfig_ExternalRef) mappingRef).getMappingConfig(), result_9427_31);\n      result_9427_23.addContent(result_9427_31);\n    } else if (mappingRef instanceof MappingConfig_RefSet) {\n      Element result_9427_32 = new Element(\"mapping-set\");\n      for (MappingConfig_AbstractRef mappingRefInner : ListSequence.fromList(((MappingConfig_RefSet) mappingRef).getMappingConfigs())) {\n        Element result_9427_33 = new Element(\"mapping-set-element\");\n        saveGeneratorMappingConfigRef(mappingRefInner, result_9427_33);\n        result_9427_32.addContent(result_9427_33);\n      }\n      result_9427_23.addContent(result_9427_32);\n    }\n  }","commit_id":"1acee04a5cdf3000385119c82da2881bd49cde60","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveGeneratorDescriptor(Element languageGeneratorsElement, GeneratorDescriptor descriptor, IFile file, Macros macros) {\n    Element result_9427_9 = languageGeneratorsElement;\n    Element result_9427_10 = new Element(\"generator\");\n    if (descriptor.getNamespace() != null) {\n      String result_9427_11 = descriptor.getNamespace();\n      result_9427_10.setAttribute(\"name\", \"\" + result_9427_11);\n    }\n    if (descriptor.getGeneratorUID() != null) {\n      String result_9427_12 = descriptor.getGeneratorUID();\n      result_9427_10.setAttribute(\"generatorUID\", \"\" + result_9427_12);\n    }\n    if (descriptor.getUUID() != null) {\n      String result_9427_13 = descriptor.getUUID();\n      result_9427_10.setAttribute(\"uuid\", \"\" + result_9427_13);\n    }\n\n    Element result_9427_14 = new Element(\"models\");\n    ModuleDescriptorPersistence.saveModelRoots(result_9427_14, descriptor.getModelRoots(), file, macros);\n    result_9427_10.addContent(result_9427_14);\n\n    if (!(descriptor.getStubModelEntries().isEmpty())) {\n      Element result_9427_15 = new Element(\"stubModelEntries\");\n      ModuleDescriptorPersistence.saveStubModelEntries(result_9427_15, descriptor.getStubModelEntries(), file, macros);\n      result_9427_10.addContent(result_9427_15);\n    }\n\n    // \"depends on\" generators \n    Element result_9427_16 = new Element(\"external-templates\");\n    for (ModuleReference generatorReference : ListSequence.fromList(descriptor.getDepGenerators())) {\n      Element result_9427_17 = new Element(\"generator\");\n      String result_9427_18 = generatorReference.toString();\n      result_9427_17.setAttribute(\"generatorUID\", \"\" + result_9427_18);\n      result_9427_16.addContent(result_9427_17);\n    }\n    result_9427_10.addContent(result_9427_16);\n\n    ModuleDescriptorPersistence.saveDependencies(result_9427_10, descriptor);\n\n    // mapping priority rules \n    Element result_9427_19 = new Element(\"mapping-priorities\");\n    for (MappingPriorityRule rule : ListSequence.fromList(descriptor.getPriorityRules())) {\n      Element result_9427_20 = new Element(\"mapping-priority-rule\");\n      String result_9427_21 = rule.getType().getName();\n      result_9427_20.setAttribute(\"kind\", \"\" + result_9427_21);\n      Element result_9427_22 = new Element(\"greater-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getLeft(), result_9427_22);\n      result_9427_20.addContent(result_9427_22);\n      Element result_9427_23 = new Element(\"lesser-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getRight(), result_9427_23);\n      result_9427_20.addContent(result_9427_23);\n      result_9427_19.addContent(result_9427_20);\n    }\n    result_9427_10.addContent(result_9427_19);\n\n    // Refresh was removed here, since this method is only called in \n    // LanguageDescriptorPersistence.saveLanguageDescriptor method, \n    // which does refresh at the en \n    result_9427_9.addContent(result_9427_10);\n  }","id":88008,"modified_method":"public static void saveGeneratorDescriptor(Element languageGeneratorsElement, GeneratorDescriptor descriptor, IFile file, Macros macros) {\n    Element result_9427_9 = languageGeneratorsElement;\n    Element result_9427_10 = new Element(\"generator\");\n    if (descriptor.getNamespace() != null) {\n      String result_9427_11 = descriptor.getNamespace();\n      result_9427_10.setAttribute(\"name\", \"\" + result_9427_11);\n    }\n    if (descriptor.getGeneratorUID() != null) {\n      String result_9427_12 = descriptor.getGeneratorUID();\n      result_9427_10.setAttribute(\"generatorUID\", \"\" + result_9427_12);\n    }\n    if (descriptor.getUUID() != null) {\n      String result_9427_13 = descriptor.getUUID();\n      result_9427_10.setAttribute(\"uuid\", \"\" + result_9427_13);\n    }\n\n    Element result_9427_14 = new Element(\"models\");\n    ModuleDescriptorPersistence.saveModelRoots(result_9427_14, descriptor.getModelRoots(), file, macros);\n    result_9427_10.addContent(result_9427_14);\n\n    // \"depends on\" generators \n    Element result_9427_15 = new Element(\"external-templates\");\n    for (ModuleReference generatorReference : ListSequence.fromList(descriptor.getDepGenerators())) {\n      Element result_9427_16 = new Element(\"generator\");\n      String result_9427_17 = generatorReference.toString();\n      result_9427_16.setAttribute(\"generatorUID\", \"\" + result_9427_17);\n      result_9427_15.addContent(result_9427_16);\n    }\n    result_9427_10.addContent(result_9427_15);\n\n    ModuleDescriptorPersistence.saveDependencies(result_9427_10, descriptor);\n\n    // mapping priority rules \n    Element result_9427_18 = new Element(\"mapping-priorities\");\n    for (MappingPriorityRule rule : ListSequence.fromList(descriptor.getPriorityRules())) {\n      Element result_9427_19 = new Element(\"mapping-priority-rule\");\n      String result_9427_20 = rule.getType().getName();\n      result_9427_19.setAttribute(\"kind\", \"\" + result_9427_20);\n      Element result_9427_21 = new Element(\"greater-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getLeft(), result_9427_21);\n      result_9427_19.addContent(result_9427_21);\n      Element result_9427_22 = new Element(\"lesser-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getRight(), result_9427_22);\n      result_9427_19.addContent(result_9427_22);\n      result_9427_18.addContent(result_9427_19);\n    }\n    result_9427_10.addContent(result_9427_18);\n\n    // Refresh was removed here, since this method is only called in \n    // LanguageDescriptorPersistence.saveLanguageDescriptor method, \n    // which does refresh at the en \n    result_9427_9.addContent(result_9427_10);\n  }","commit_id":"1acee04a5cdf3000385119c82da2881bd49cde60","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static LanguageDescriptor loadLanguageDescriptor(final IFile file) {\n    final Macros macros = Macros.languageDescriptor();\n    LanguageDescriptor descriptor;\n\n    try {\n      Document document = JDOMUtil.loadDocument(file);\n      final Element languageElement = ((Element) document.getRootElement());\n\n      descriptor = new _FunctionTypes._return_P0_E0<LanguageDescriptor>() {\n        public LanguageDescriptor invoke() {\n          LanguageDescriptor result_5080_0 = new LanguageDescriptor();\n          String result_5080_1 = languageElement.getAttributeValue(\"namespace\");\n          result_5080_0.setNamespace(result_5080_1);\n          if (languageElement.getAttributeValue(\"uuid\") != null) {\n            String result_5080_2 = languageElement.getAttributeValue(\"uuid\");\n            result_5080_0.setUUID(result_5080_2);\n          }\n          boolean result_5080_3 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"java-stubs-enabled\"), false);\n          result_5080_0.setEnableJavaStubs(result_5080_3);\n\n          if (languageElement.getAttributeValue(\"generatorOutputPath\") != null) {\n            String result_5080_4 = macros.expandPath(languageElement.getAttributeValue(\"generatorOutputPath\"), file);\n            result_5080_0.setGenPath(result_5080_4);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).isNotEmpty()) {\n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).first(), \"modelRoot\"), file, macros));\n          } else {\n            // old - for backwards compatibility \n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(languageElement, \"modelRoot\"), file, macros));\n          }\n\n          ModuleDescriptorPersistence.loadDependencies(result_5080_0, languageElement);\n\n          for (Element extendedLanguage : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"extendedLanguages\")).first(), \"extendedLanguage\"))) {\n            result_5080_0.getExtendedLanguages().add(ModuleReference.fromString(extendedLanguage.getText()));\n          }\n\n          Element autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"accessoryModels\")).first();\n          if (autoImports == null) {\n            // deprecated name \n            autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"library\")).first();\n          }\n          for (Element modelElement : ListSequence.fromList(AttributeUtils.elementChildren(autoImports, \"model\"))) {\n            result_5080_0.getAccessoryModels().add(SModelReference.fromString(modelElement.getAttributeValue(\"modelUID\")));\n          }\n\n          for (Element generatorElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"generators\")).first(), \"generator\"))) {\n            result_5080_0.getGenerators().add(GeneratorDescriptorPersistence.loadGeneratorDescriptor(generatorElement, file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"classPath\")).first(), \"entry\")).concat(ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"runtimeClassPath\")).first(), \"entry\")))) {\n            // runtimeClassPath was left for compatibility \n            ClassPathEntry result_5080_5 = new ClassPathEntry();\n            String result_5080_6 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_5.setPath(result_5080_6);\n            boolean result_5080_7 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_5.setIncludedInVCS(result_5080_7);\n            result_5080_0.getClassPaths().add(result_5080_5);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"stubModelEntries\")).isNotEmpty()) {\n            result_5080_0.getStubModelEntries().addAll(ModuleDescriptorPersistence.loadStubModelEntries(AttributeUtils.elementChildren(languageElement, \"stubModelEntries\"), file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"languageRuntimeClassPath\")).first(), \"entry\"))) {\n            StubModelsEntry result_5080_8 = new StubModelsEntry();\n            String result_5080_9 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_8.setPath(result_5080_9);\n            boolean result_5080_10 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_8.setIncludedInVCS(result_5080_10);\n            result_5080_0.getStubModelEntries().add(result_5080_8);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"sourcePath\")).first(), \"source\"))) {\n            result_5080_0.getSourcePaths().add(macros.expandPath(entryElement.getAttributeValue(\"path\"), file));\n          }\n\n          boolean result_5080_11 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"compileInMPS\"), false);\n          result_5080_0.setCompileInMPS(result_5080_11);\n          return result_5080_0;\n        }\n      }.invoke();\n    } catch (Exception e) {\n      throw new ModuleReadException(e);\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, false);\n    return descriptor;\n  }","id":88009,"modified_method":"public static LanguageDescriptor loadLanguageDescriptor(final IFile file) {\n    final Macros macros = Macros.languageDescriptor();\n    LanguageDescriptor descriptor;\n\n    try {\n      Document document = JDOMUtil.loadDocument(file);\n      final Element languageElement = ((Element) document.getRootElement());\n\n      descriptor = new _FunctionTypes._return_P0_E0<LanguageDescriptor>() {\n        public LanguageDescriptor invoke() {\n          LanguageDescriptor result_5080_0 = new LanguageDescriptor();\n          String result_5080_1 = languageElement.getAttributeValue(\"namespace\");\n          result_5080_0.setNamespace(result_5080_1);\n          if (languageElement.getAttributeValue(\"uuid\") != null) {\n            String result_5080_2 = languageElement.getAttributeValue(\"uuid\");\n            result_5080_0.setUUID(result_5080_2);\n          }\n          boolean result_5080_3 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"java-stubs-enabled\"), false);\n          result_5080_0.setEnableJavaStubs(result_5080_3);\n\n          if (languageElement.getAttributeValue(\"generatorOutputPath\") != null) {\n            String result_5080_4 = macros.expandPath(languageElement.getAttributeValue(\"generatorOutputPath\"), file);\n            result_5080_0.setGenPath(result_5080_4);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).isNotEmpty()) {\n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).first(), \"modelRoot\"), file, macros));\n          } else {\n            // old - for backwards compatibility \n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(languageElement, \"modelRoot\"), file, macros));\n          }\n\n          ModuleDescriptorPersistence.loadDependencies(result_5080_0, languageElement);\n\n          for (Element extendedLanguage : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"extendedLanguages\")).first(), \"extendedLanguage\"))) {\n            result_5080_0.getExtendedLanguages().add(ModuleReference.fromString(extendedLanguage.getText()));\n          }\n\n          Element autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"accessoryModels\")).first();\n          if (autoImports == null) {\n            // deprecated name \n            autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"library\")).first();\n          }\n          for (Element modelElement : ListSequence.fromList(AttributeUtils.elementChildren(autoImports, \"model\"))) {\n            result_5080_0.getAccessoryModels().add(SModelReference.fromString(modelElement.getAttributeValue(\"modelUID\")));\n          }\n\n          for (Element generatorElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"generators\")).first(), \"generator\"))) {\n            result_5080_0.getGenerators().add(GeneratorDescriptorPersistence.loadGeneratorDescriptor(generatorElement, file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"classPath\")).first(), \"entry\")).concat(ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"runtimeClassPath\")).first(), \"entry\")))) {\n            // runtimeClassPath was left for compatibility \n            ClassPathEntry result_5080_5 = new ClassPathEntry();\n            String result_5080_6 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_5.setPath(result_5080_6);\n            boolean result_5080_7 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_5.setIncludedInVCS(result_5080_7);\n            result_5080_0.getClassPaths().add(result_5080_5);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"stubModelEntries\")).isNotEmpty()) {\n            result_5080_0.getStubModelEntries().addAll(ModuleDescriptorPersistence.loadStubModelEntries(AttributeUtils.elementChildren(languageElement, \"stubModelEntries\"), file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"languageRuntimeClassPath\")).first(), \"entry\"))) {\n            ClassPathEntry result_5080_8 = new ClassPathEntry();\n            String result_5080_9 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_8.setPath(result_5080_9);\n            boolean result_5080_10 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_8.setIncludedInVCS(result_5080_10);\n            result_5080_0.getClassPaths().add(result_5080_8);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"sourcePath\")).first(), \"source\"))) {\n            result_5080_0.getSourcePaths().add(macros.expandPath(entryElement.getAttributeValue(\"path\"), file));\n          }\n\n          boolean result_5080_11 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"compileInMPS\"), false);\n          result_5080_0.setCompileInMPS(result_5080_11);\n          return result_5080_0;\n        }\n      }.invoke();\n    } catch (Exception e) {\n      throw new ModuleReadException(e);\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, false);\n    return descriptor;\n  }","commit_id":"1acee04a5cdf3000385119c82da2881bd49cde60","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveDevKitDescriptor(final DevkitDescriptor descriptor, final IFile file) {\n    Element root = new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element result_1953_7 = new Element(\"dev-kit\");\n        String result_1953_8 = descriptor.getNamespace();\n        result_1953_7.setAttribute(\"name\", \"\" + result_1953_8);\n\n        if (descriptor.getUUID() != null) {\n          String result_1953_9 = descriptor.getUUID();\n          result_1953_7.setAttribute(\"uuid\", \"\" + result_1953_9);\n        }\n\n        ModuleDescriptorPersistence.saveDependencies(result_1953_7, descriptor);\n\n        for (ModuleReference lang : ListSequence.fromList(descriptor.getExportedLanguages())) {\n          Element result_1953_10 = new Element(\"exported-language\");\n          String result_1953_11 = lang.toString();\n          result_1953_10.setAttribute(\"name\", \"\" + result_1953_11);\n          result_1953_7.addContent(result_1953_10);\n        }\n\n        if (!(descriptor.getExtendedDevkits().isEmpty())) {\n          Element result_1953_12 = new Element(\"extendedDevKits\");\n          for (ModuleReference ref : ListSequence.fromList(descriptor.getExtendedDevkits())) {\n            Element result_1953_13 = new Element(\"extendedDevKit\");\n            String result_1953_14 = ref.toString();\n            result_1953_13.setText(result_1953_14);\n            result_1953_12.addContent(result_1953_13);\n          }\n          result_1953_7.addContent(result_1953_12);\n        }\n\n        if (!(descriptor.getExportedSolutions().isEmpty())) {\n          Element result_1953_15 = new Element(\"exported-solutions\");\n          for (ModuleReference ref : ListSequence.fromList(descriptor.getExtendedDevkits())) {\n            Element result_1953_16 = new Element(\"exported-solution\");\n            String result_1953_17 = ref.toString();\n            result_1953_16.setText(result_1953_17);\n            result_1953_15.addContent(result_1953_16);\n          }\n          result_1953_7.addContent(result_1953_15);\n        }\n\n        Element result_1953_18 = new Element(\"classPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getClassPaths())) {\n          Element result_1953_19 = new Element(\"entry\");\n          String result_1953_20 = Macros.devkitMacros().shrinkPath(entry.getPath(), file);\n          result_1953_19.setAttribute(\"path\", \"\" + result_1953_20);\n          boolean result_1953_21 = entry.isIncludedInVCS();\n          result_1953_19.setAttribute(\"include\", \"\" + result_1953_21);\n          result_1953_18.addContent(result_1953_19);\n        }\n        result_1953_7.addContent(result_1953_18);\n\n        if (descriptor.getPlugin() != null) {\n          String result_1953_22 = descriptor.getPlugin();\n          result_1953_7.setAttribute(\"pluginClass\", \"\" + result_1953_22);\n        }\n        return result_1953_7;\n      }\n    }.invoke();\n\n    try {\n      OutputStream os = file.openOutputStream();\n      JDOMUtil.writeDocument(new Document(root), os);\n    } catch (Exception e) {\n      if (log.isErrorEnabled()) {\n        log.error(\"\", e);\n      }\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, true);\n  }","id":88010,"modified_method":"public static void saveDevKitDescriptor(final DevkitDescriptor descriptor, final IFile file) {\n    Element root = new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element result_1953_7 = new Element(\"dev-kit\");\n        String result_1953_8 = descriptor.getNamespace();\n        result_1953_7.setAttribute(\"name\", \"\" + result_1953_8);\n\n        if (descriptor.getUUID() != null) {\n          String result_1953_9 = descriptor.getUUID();\n          result_1953_7.setAttribute(\"uuid\", \"\" + result_1953_9);\n        }\n\n        ModuleDescriptorPersistence.saveDependencies(result_1953_7, descriptor);\n\n        for (ModuleReference lang : ListSequence.fromList(descriptor.getExportedLanguages())) {\n          Element result_1953_10 = new Element(\"exported-language\");\n          String result_1953_11 = lang.toString();\n          result_1953_10.setAttribute(\"name\", \"\" + result_1953_11);\n          result_1953_7.addContent(result_1953_10);\n        }\n\n        if (!(descriptor.getExtendedDevkits().isEmpty())) {\n          Element result_1953_12 = new Element(\"extendedDevKits\");\n          for (ModuleReference ref : ListSequence.fromList(descriptor.getExtendedDevkits())) {\n            Element result_1953_13 = new Element(\"extendedDevKit\");\n            String result_1953_14 = ref.toString();\n            result_1953_13.setText(result_1953_14);\n            result_1953_12.addContent(result_1953_13);\n          }\n          result_1953_7.addContent(result_1953_12);\n        }\n\n        if (!(descriptor.getExportedSolutions().isEmpty())) {\n          Element result_1953_15 = new Element(\"exported-solutions\");\n          for (ModuleReference ref : ListSequence.fromList(descriptor.getExtendedDevkits())) {\n            Element result_1953_16 = new Element(\"exported-solution\");\n            String result_1953_17 = ref.toString();\n            result_1953_16.setText(result_1953_17);\n            result_1953_15.addContent(result_1953_16);\n          }\n          result_1953_7.addContent(result_1953_15);\n        }\n\n        Element result_1953_18 = new Element(\"classPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getClassPaths())) {\n          Element result_1953_19 = new Element(\"stubModelEntry\");\n          String result_1953_20 = Macros.devkitMacros().shrinkPath(entry.getPath(), file);\n          result_1953_19.setAttribute(\"path\", \"\" + result_1953_20);\n          boolean result_1953_21 = entry.isIncludedInVCS();\n          result_1953_19.setAttribute(\"include\", \"\" + result_1953_21);\n          result_1953_18.addContent(result_1953_19);\n        }\n        result_1953_7.addContent(result_1953_18);\n\n        if (descriptor.getPlugin() != null) {\n          String result_1953_22 = descriptor.getPlugin();\n          result_1953_7.setAttribute(\"pluginClass\", \"\" + result_1953_22);\n        }\n        return result_1953_7;\n      }\n    }.invoke();\n\n    try {\n      OutputStream os = file.openOutputStream();\n      JDOMUtil.writeDocument(new Document(root), os);\n    } catch (Exception e) {\n      if (log.isErrorEnabled()) {\n        log.error(\"\", e);\n      }\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, true);\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveGeneratorDescriptor(Element languageGeneratorsElement, GeneratorDescriptor descriptor, IFile file, Macros macros) {\n    Element result_9427_9 = languageGeneratorsElement;\n    Element result_9427_10 = new Element(\"generator\");\n    if (descriptor.getNamespace() != null) {\n      String result_9427_11 = descriptor.getNamespace();\n      result_9427_10.setAttribute(\"name\", \"\" + result_9427_11);\n    }\n    if (descriptor.getGeneratorUID() != null) {\n      String result_9427_12 = descriptor.getGeneratorUID();\n      result_9427_10.setAttribute(\"generatorUID\", \"\" + result_9427_12);\n    }\n    if (descriptor.getUUID() != null) {\n      String result_9427_13 = descriptor.getUUID();\n      result_9427_10.setAttribute(\"uuid\", \"\" + result_9427_13);\n    }\n\n    Element result_9427_14 = new Element(\"models\");\n    ModuleDescriptorPersistence.saveModelRoots(result_9427_14, descriptor.getModelRoots(), file, macros);\n    result_9427_10.addContent(result_9427_14);\n\n    // \"depends on\" generators \n    Element result_9427_15 = new Element(\"external-templates\");\n    for (ModuleReference generatorReference : ListSequence.fromList(descriptor.getDepGenerators())) {\n      Element result_9427_16 = new Element(\"generator\");\n      String result_9427_17 = generatorReference.toString();\n      result_9427_16.setAttribute(\"generatorUID\", \"\" + result_9427_17);\n      result_9427_15.addContent(result_9427_16);\n    }\n    result_9427_10.addContent(result_9427_15);\n\n    ModuleDescriptorPersistence.saveDependencies(result_9427_10, descriptor);\n\n    // mapping priority rules \n    Element result_9427_18 = new Element(\"mapping-priorities\");\n    for (MappingPriorityRule rule : ListSequence.fromList(descriptor.getPriorityRules())) {\n      Element result_9427_19 = new Element(\"mapping-priority-rule\");\n      String result_9427_20 = rule.getType().getName();\n      result_9427_19.setAttribute(\"kind\", \"\" + result_9427_20);\n      Element result_9427_21 = new Element(\"greater-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getLeft(), result_9427_21);\n      result_9427_19.addContent(result_9427_21);\n      Element result_9427_22 = new Element(\"lesser-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getRight(), result_9427_22);\n      result_9427_19.addContent(result_9427_22);\n      result_9427_18.addContent(result_9427_19);\n    }\n    result_9427_10.addContent(result_9427_18);\n\n    // Refresh was removed here, since this method is only called in \n    // LanguageDescriptorPersistence.saveLanguageDescriptor method, \n    // which does refresh at the en \n    result_9427_9.addContent(result_9427_10);\n  }","id":88011,"modified_method":"public static void saveGeneratorDescriptor(Element languageGeneratorsElement, GeneratorDescriptor descriptor, IFile file, Macros macros) {\n    Element result_9427_9 = languageGeneratorsElement;\n    Element result_9427_10 = new Element(\"generator\");\n    if (descriptor.getNamespace() != null) {\n      String result_9427_11 = descriptor.getNamespace();\n      result_9427_10.setAttribute(\"name\", \"\" + result_9427_11);\n    }\n    if (descriptor.getGeneratorUID() != null) {\n      String result_9427_12 = descriptor.getGeneratorUID();\n      result_9427_10.setAttribute(\"generatorUID\", \"\" + result_9427_12);\n    }\n    if (descriptor.getUUID() != null) {\n      String result_9427_13 = descriptor.getUUID();\n      result_9427_10.setAttribute(\"uuid\", \"\" + result_9427_13);\n    }\n\n    Element result_9427_14 = new Element(\"models\");\n    ModuleDescriptorPersistence.saveModelRoots(result_9427_14, descriptor.getModelRoots(), file, macros);\n    result_9427_10.addContent(result_9427_14);\n\n    if (!(descriptor.getStubModelEntries().isEmpty())) {\n      Element result_9427_15 = new Element(\"stubModelEntries\");\n      ModuleDescriptorPersistence.saveStubModelEntries(result_9427_15, descriptor.getStubModelEntries(), file, macros);\n      result_9427_10.addContent(result_9427_15);\n    }\n\n    // \"depends on\" generators \n    Element result_9427_16 = new Element(\"external-templates\");\n    for (ModuleReference generatorReference : ListSequence.fromList(descriptor.getDepGenerators())) {\n      Element result_9427_17 = new Element(\"generator\");\n      String result_9427_18 = generatorReference.toString();\n      result_9427_17.setAttribute(\"generatorUID\", \"\" + result_9427_18);\n      result_9427_16.addContent(result_9427_17);\n    }\n    result_9427_10.addContent(result_9427_16);\n\n    ModuleDescriptorPersistence.saveDependencies(result_9427_10, descriptor);\n\n    // mapping priority rules \n    Element result_9427_19 = new Element(\"mapping-priorities\");\n    for (MappingPriorityRule rule : ListSequence.fromList(descriptor.getPriorityRules())) {\n      Element result_9427_20 = new Element(\"mapping-priority-rule\");\n      String result_9427_21 = rule.getType().getName();\n      result_9427_20.setAttribute(\"kind\", \"\" + result_9427_21);\n      Element result_9427_22 = new Element(\"greater-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getLeft(), result_9427_22);\n      result_9427_20.addContent(result_9427_22);\n      Element result_9427_23 = new Element(\"lesser-priority-mapping\");\n      saveGeneratorMappingConfigRef(rule.getRight(), result_9427_23);\n      result_9427_20.addContent(result_9427_23);\n      result_9427_19.addContent(result_9427_20);\n    }\n    result_9427_10.addContent(result_9427_19);\n\n    // Refresh was removed here, since this method is only called in \n    // LanguageDescriptorPersistence.saveLanguageDescriptor method, \n    // which does refresh at the en \n    result_9427_9.addContent(result_9427_10);\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void saveGeneratorMappingConfigRef(MappingConfig_AbstractRef mappingRef, Element parentElement) {\n    Element result_9427_23 = parentElement;\n    if (mappingRef instanceof MappingConfig_RefAllLocal) {\n      Element result_9427_24 = new Element(\"all-local-mappings\");\n      result_9427_23.addContent(result_9427_24);\n    } else if (mappingRef instanceof MappingConfig_RefAllGlobal) {\n      Element result_9427_25 = new Element(\"all-mappings\");\n      result_9427_23.addContent(result_9427_25);\n    } else if (mappingRef instanceof MappingConfig_SimpleRef) {\n      Element result_9427_26 = new Element(\"mapping-node\");\n      String result_9427_27 = ((MappingConfig_SimpleRef) mappingRef).getModelUID();\n      result_9427_26.setAttribute(\"modelUID\", \"\" + result_9427_27);\n      String result_9427_28 = ((MappingConfig_SimpleRef) mappingRef).getNodeID();\n      result_9427_26.setAttribute(\"nodeID\", \"\" + result_9427_28);\n      result_9427_23.addContent(result_9427_26);\n    } else if (mappingRef instanceof MappingConfig_ExternalRef) {\n      Element result_9427_29 = new Element(\"generator\");\n      String result_9427_30 = ((MappingConfig_ExternalRef) mappingRef).getGenerator().toString();\n      result_9427_29.setAttribute(\"generatorUID\", \"\" + result_9427_30);\n      result_9427_23.addContent(result_9427_29);\n      Element result_9427_31 = new Element(\"external-mapping\");\n      saveGeneratorMappingConfigRef(((MappingConfig_ExternalRef) mappingRef).getMappingConfig(), result_9427_31);\n      result_9427_23.addContent(result_9427_31);\n    } else if (mappingRef instanceof MappingConfig_RefSet) {\n      Element result_9427_32 = new Element(\"mapping-set\");\n      for (MappingConfig_AbstractRef mappingRefInner : ListSequence.fromList(((MappingConfig_RefSet) mappingRef).getMappingConfigs())) {\n        Element result_9427_33 = new Element(\"mapping-set-element\");\n        saveGeneratorMappingConfigRef(mappingRefInner, result_9427_33);\n        result_9427_32.addContent(result_9427_33);\n      }\n      result_9427_23.addContent(result_9427_32);\n    }\n  }","id":88012,"modified_method":"private static void saveGeneratorMappingConfigRef(MappingConfig_AbstractRef mappingRef, Element parentElement) {\n    Element result_9427_24 = parentElement;\n    if (mappingRef instanceof MappingConfig_RefAllLocal) {\n      Element result_9427_25 = new Element(\"all-local-mappings\");\n      result_9427_24.addContent(result_9427_25);\n    } else if (mappingRef instanceof MappingConfig_RefAllGlobal) {\n      Element result_9427_26 = new Element(\"all-mappings\");\n      result_9427_24.addContent(result_9427_26);\n    } else if (mappingRef instanceof MappingConfig_SimpleRef) {\n      Element result_9427_27 = new Element(\"mapping-node\");\n      String result_9427_28 = ((MappingConfig_SimpleRef) mappingRef).getModelUID();\n      result_9427_27.setAttribute(\"modelUID\", \"\" + result_9427_28);\n      String result_9427_29 = ((MappingConfig_SimpleRef) mappingRef).getNodeID();\n      result_9427_27.setAttribute(\"nodeID\", \"\" + result_9427_29);\n      result_9427_24.addContent(result_9427_27);\n    } else if (mappingRef instanceof MappingConfig_ExternalRef) {\n      Element result_9427_30 = new Element(\"generator\");\n      String result_9427_31 = ((MappingConfig_ExternalRef) mappingRef).getGenerator().toString();\n      result_9427_30.setAttribute(\"generatorUID\", \"\" + result_9427_31);\n      result_9427_24.addContent(result_9427_30);\n      Element result_9427_32 = new Element(\"external-mapping\");\n      saveGeneratorMappingConfigRef(((MappingConfig_ExternalRef) mappingRef).getMappingConfig(), result_9427_32);\n      result_9427_24.addContent(result_9427_32);\n    } else if (mappingRef instanceof MappingConfig_RefSet) {\n      Element result_9427_33 = new Element(\"mapping-set\");\n      for (MappingConfig_AbstractRef mappingRefInner : ListSequence.fromList(((MappingConfig_RefSet) mappingRef).getMappingConfigs())) {\n        Element result_9427_34 = new Element(\"mapping-set-element\");\n        saveGeneratorMappingConfigRef(mappingRefInner, result_9427_34);\n        result_9427_33.addContent(result_9427_34);\n      }\n      result_9427_24.addContent(result_9427_33);\n    }\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static MappingConfig_AbstractRef loadGeneratorMappingConfigRef(final Element parentElement, final String genUID, boolean childOfGen) {\n    if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-mappings\")).isNotEmpty()) {\n      return new MappingConfig_RefAllGlobal();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-local-mappings\")).isNotEmpty()) {\n      final MappingConfig_RefAllLocal local = new MappingConfig_RefAllLocal();\n      if (childOfGen) {\n        return local;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_34 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_35 = ModuleReference.fromString(genUID);\n          result_9427_34.setGenerator(result_9427_35);\n          MappingConfig_AbstractRef result_9427_36 = local;\n          result_9427_34.setMappingConfig(result_9427_36);\n          return result_9427_34;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).isNotEmpty()) {\n      final MappingConfig_RefSet mappingSet = new MappingConfig_RefSet();\n      for (Element mappingSetElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).first(), \"mapping-set-element\"))) {\n        mappingSet.getMappingConfigs().add(loadGeneratorMappingConfigRef(mappingSetElement, genUID, true));\n      }\n\n      if (childOfGen) {\n        return mappingSet;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_37 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_38 = ModuleReference.fromString(genUID);\n          result_9427_37.setGenerator(result_9427_38);\n          MappingConfig_AbstractRef result_9427_39 = mappingSet;\n          result_9427_37.setMappingConfig(result_9427_39);\n          return result_9427_37;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).isNotEmpty()) {\n      // external reference \n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_40 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_41 = ModuleReference.fromString(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"));\n          result_9427_40.setGenerator(result_9427_41);\n          MappingConfig_AbstractRef result_9427_42 = loadGeneratorMappingConfigRef(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"external-mapping\")).first(), ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"), true);\n          result_9427_40.setMappingConfig(result_9427_42);\n          return result_9427_40;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).isNotEmpty()) {\n      // simple reference \n      ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first();\n\n      final MappingConfig_SimpleRef mapping_SimpleRef = new MappingConfig_SimpleRef();\n      MappingConfig_SimpleRef result_9427_43 = mapping_SimpleRef;\n      String result_9427_44 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"modelUID\");\n      result_9427_43.setModelUID(result_9427_44);\n      String result_9427_45 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"nodeID\");\n      result_9427_43.setNodeID(result_9427_45);\n\n      if (childOfGen) {\n        return mapping_SimpleRef;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_46 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_47 = ModuleReference.fromString(genUID);\n          result_9427_46.setGenerator(result_9427_47);\n          MappingConfig_AbstractRef result_9427_48 = mapping_SimpleRef;\n          result_9427_46.setMappingConfig(result_9427_48);\n          return result_9427_46;\n        }\n      }.invoke();\n    }\n\n    // empty? \n    return new MappingConfig_AbstractRef();\n  }","id":88013,"modified_method":"public static MappingConfig_AbstractRef loadGeneratorMappingConfigRef(final Element parentElement, final String genUID, boolean childOfGen) {\n    if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-mappings\")).isNotEmpty()) {\n      return new MappingConfig_RefAllGlobal();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"all-local-mappings\")).isNotEmpty()) {\n      final MappingConfig_RefAllLocal local = new MappingConfig_RefAllLocal();\n      if (childOfGen) {\n        return local;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_35 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_36 = ModuleReference.fromString(genUID);\n          result_9427_35.setGenerator(result_9427_36);\n          MappingConfig_AbstractRef result_9427_37 = local;\n          result_9427_35.setMappingConfig(result_9427_37);\n          return result_9427_35;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).isNotEmpty()) {\n      final MappingConfig_RefSet mappingSet = new MappingConfig_RefSet();\n      for (Element mappingSetElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-set\")).first(), \"mapping-set-element\"))) {\n        mappingSet.getMappingConfigs().add(loadGeneratorMappingConfigRef(mappingSetElement, genUID, true));\n      }\n\n      if (childOfGen) {\n        return mappingSet;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_38 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_39 = ModuleReference.fromString(genUID);\n          result_9427_38.setGenerator(result_9427_39);\n          MappingConfig_AbstractRef result_9427_40 = mappingSet;\n          result_9427_38.setMappingConfig(result_9427_40);\n          return result_9427_38;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).isNotEmpty()) {\n      // external reference \n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_41 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_42 = ModuleReference.fromString(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"));\n          result_9427_41.setGenerator(result_9427_42);\n          MappingConfig_AbstractRef result_9427_43 = loadGeneratorMappingConfigRef(ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"external-mapping\")).first(), ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"generator\")).first().getAttributeValue(\"generatorUID\"), true);\n          result_9427_41.setMappingConfig(result_9427_43);\n          return result_9427_41;\n        }\n      }.invoke();\n    } else if (ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).isNotEmpty()) {\n      // simple reference \n      ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first();\n\n      final MappingConfig_SimpleRef mapping_SimpleRef = new MappingConfig_SimpleRef();\n      MappingConfig_SimpleRef result_9427_44 = mapping_SimpleRef;\n      String result_9427_45 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"modelUID\");\n      result_9427_44.setModelUID(result_9427_45);\n      String result_9427_46 = ListSequence.fromList(AttributeUtils.elementChildren(parentElement, \"mapping-node\")).first().getAttributeValue(\"nodeID\");\n      result_9427_44.setNodeID(result_9427_46);\n\n      if (childOfGen) {\n        return mapping_SimpleRef;\n      }\n\n      return new _FunctionTypes._return_P0_E0<MappingConfig_ExternalRef>() {\n        public MappingConfig_ExternalRef invoke() {\n          MappingConfig_ExternalRef result_9427_47 = new MappingConfig_ExternalRef();\n          ModuleReference result_9427_48 = ModuleReference.fromString(genUID);\n          result_9427_47.setGenerator(result_9427_48);\n          MappingConfig_AbstractRef result_9427_49 = mapping_SimpleRef;\n          result_9427_47.setMappingConfig(result_9427_49);\n          return result_9427_47;\n        }\n      }.invoke();\n    }\n\n    // empty? \n    return new MappingConfig_AbstractRef();\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static LanguageDescriptor loadLanguageDescriptor(final IFile file) {\n    final Macros macros = Macros.languageDescriptor();\n    LanguageDescriptor descriptor;\n\n    try {\n      Document document = JDOMUtil.loadDocument(file);\n      final Element languageElement = ((Element) document.getRootElement());\n\n      descriptor = new _FunctionTypes._return_P0_E0<LanguageDescriptor>() {\n        public LanguageDescriptor invoke() {\n          LanguageDescriptor result_5080_0 = new LanguageDescriptor();\n          String result_5080_1 = languageElement.getAttributeValue(\"namespace\");\n          result_5080_0.setNamespace(result_5080_1);\n          if (languageElement.getAttributeValue(\"uuid\") != null) {\n            String result_5080_2 = languageElement.getAttributeValue(\"uuid\");\n            result_5080_0.setUUID(result_5080_2);\n          }\n          boolean result_5080_3 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"java-stubs-enabled\"), false);\n          result_5080_0.setEnableJavaStubs(result_5080_3);\n\n          if (languageElement.getAttributeValue(\"generatorOutputPath\") != null) {\n            String result_5080_4 = macros.expandPath(languageElement.getAttributeValue(\"generatorOutputPath\"), file);\n            result_5080_0.setGenPath(result_5080_4);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).isNotEmpty()) {\n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).first(), \"modelRoot\"), file, macros));\n          } else {\n            // old - for backwards compatibility \n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(languageElement, \"modelRoot\"), file, macros));\n          }\n\n          ModuleDescriptorPersistence.loadDependencies(result_5080_0, languageElement);\n\n          for (Element extendedLanguage : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"extendedLanguages\")).first(), \"extendedLanguage\"))) {\n            result_5080_0.getExtendedLanguages().add(ModuleReference.fromString(extendedLanguage.getText()));\n          }\n\n          Element autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"accessoryModels\")).first();\n          if (autoImports == null) {\n            // deprecated name \n            autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"library\")).first();\n          }\n          for (Element modelElement : ListSequence.fromList(AttributeUtils.elementChildren(autoImports, \"model\"))) {\n            result_5080_0.getAccessoryModels().add(SModelReference.fromString(modelElement.getAttributeValue(\"modelUID\")));\n          }\n\n          for (Element generatorElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"generators\")).first(), \"generator\"))) {\n            result_5080_0.getGenerators().add(GeneratorDescriptorPersistence.loadGeneratorDescriptor(generatorElement, file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"classPath\")).first(), \"entry\")).concat(ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"runtimeClassPath\")).first(), \"entry\")))) {\n            // runtimeClassPath was left for compatibility \n            ClassPathEntry result_5080_5 = new ClassPathEntry();\n            String result_5080_6 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_5.setPath(result_5080_6);\n            boolean result_5080_7 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_5.setIncludedInVCS(result_5080_7);\n            result_5080_0.getClassPaths().add(result_5080_5);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"languageRuntimeClassPath\")).first(), \"entry\"))) {\n            ClassPathEntry result_5080_8 = new ClassPathEntry();\n            String result_5080_9 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_8.setPath(result_5080_9);\n            boolean result_5080_10 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_8.setIncludedInVCS(result_5080_10);\n            result_5080_0.getRuntimeClassPaths().add(result_5080_8);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"sourcePath\")).first(), \"source\"))) {\n            result_5080_0.getSourcePaths().add(macros.expandPath(entryElement.getAttributeValue(\"path\"), file));\n          }\n\n          boolean result_5080_11 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"compileInMPS\"), false);\n          result_5080_0.setCompileInMPS(result_5080_11);\n          return result_5080_0;\n        }\n      }.invoke();\n    } catch (Exception e) {\n      throw new ModuleReadException(e);\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, false);\n    return descriptor;\n  }","id":88014,"modified_method":"public static LanguageDescriptor loadLanguageDescriptor(final IFile file) {\n    final Macros macros = Macros.languageDescriptor();\n    LanguageDescriptor descriptor;\n\n    try {\n      Document document = JDOMUtil.loadDocument(file);\n      final Element languageElement = ((Element) document.getRootElement());\n\n      descriptor = new _FunctionTypes._return_P0_E0<LanguageDescriptor>() {\n        public LanguageDescriptor invoke() {\n          LanguageDescriptor result_5080_0 = new LanguageDescriptor();\n          String result_5080_1 = languageElement.getAttributeValue(\"namespace\");\n          result_5080_0.setNamespace(result_5080_1);\n          if (languageElement.getAttributeValue(\"uuid\") != null) {\n            String result_5080_2 = languageElement.getAttributeValue(\"uuid\");\n            result_5080_0.setUUID(result_5080_2);\n          }\n          boolean result_5080_3 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"java-stubs-enabled\"), false);\n          result_5080_0.setEnableJavaStubs(result_5080_3);\n\n          if (languageElement.getAttributeValue(\"generatorOutputPath\") != null) {\n            String result_5080_4 = macros.expandPath(languageElement.getAttributeValue(\"generatorOutputPath\"), file);\n            result_5080_0.setGenPath(result_5080_4);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).isNotEmpty()) {\n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"models\")).first(), \"modelRoot\"), file, macros));\n          } else {\n            // old - for backwards compatibility \n            result_5080_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(languageElement, \"modelRoot\"), file, macros));\n          }\n\n          ModuleDescriptorPersistence.loadDependencies(result_5080_0, languageElement);\n\n          for (Element extendedLanguage : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"extendedLanguages\")).first(), \"extendedLanguage\"))) {\n            result_5080_0.getExtendedLanguages().add(ModuleReference.fromString(extendedLanguage.getText()));\n          }\n\n          Element autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"accessoryModels\")).first();\n          if (autoImports == null) {\n            // deprecated name \n            autoImports = ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"library\")).first();\n          }\n          for (Element modelElement : ListSequence.fromList(AttributeUtils.elementChildren(autoImports, \"model\"))) {\n            result_5080_0.getAccessoryModels().add(SModelReference.fromString(modelElement.getAttributeValue(\"modelUID\")));\n          }\n\n          for (Element generatorElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"generators\")).first(), \"generator\"))) {\n            result_5080_0.getGenerators().add(GeneratorDescriptorPersistence.loadGeneratorDescriptor(generatorElement, file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"classPath\")).first(), \"stubModelEntry\")).concat(ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"runtimeClassPath\")).first(), \"stubModelEntry\")))) {\n            // runtimeClassPath was left for compatibility \n            ClassPathEntry result_5080_5 = new ClassPathEntry();\n            String result_5080_6 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_5.setPath(result_5080_6);\n            boolean result_5080_7 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_5.setIncludedInVCS(result_5080_7);\n            result_5080_0.getClassPaths().add(result_5080_5);\n          }\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"stubModelEntries\")).isNotEmpty()) {\n            result_5080_0.getStubModelEntries().addAll(ModuleDescriptorPersistence.loadStubModelEntries(AttributeUtils.elementChildren(languageElement, \"stubModelEntries\"), file, macros));\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"languageRuntimeClassPath\")).first(), \"stubModelEntry\"))) {\n            ClassPathEntry result_5080_8 = new ClassPathEntry();\n            String result_5080_9 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_5080_8.setPath(result_5080_9);\n            boolean result_5080_10 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_5080_8.setIncludedInVCS(result_5080_10);\n            result_5080_0.getRuntimeClassPaths().add(result_5080_8);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(languageElement, \"sourcePath\")).first(), \"source\"))) {\n            result_5080_0.getSourcePaths().add(macros.expandPath(entryElement.getAttributeValue(\"path\"), file));\n          }\n\n          boolean result_5080_11 = AttributeUtils.booleanWithDefault(languageElement.getAttributeValue(\"compileInMPS\"), false);\n          result_5080_0.setCompileInMPS(result_5080_11);\n          return result_5080_0;\n        }\n      }.invoke();\n    } catch (Exception e) {\n      throw new ModuleReadException(e);\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, false);\n    return descriptor;\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveLanguageDescriptor(final IFile file, final LanguageDescriptor descriptor) {\n    if (file.isReadOnly()) {\n      if (log.isErrorEnabled()) {\n        log.error(\"Cant't save \" + file.getPath());\n      }\n      return;\n    }\n\n    final Macros macros = Macros.languageDescriptor();\n    Element languageElement = new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element result_5080_12 = new Element(\"language\");\n        String result_5080_13 = descriptor.getNamespace();\n        result_5080_12.setAttribute(\"namespace\", \"\" + result_5080_13);\n        if (descriptor.getUUID() != null) {\n          String result_5080_14 = descriptor.getUUID();\n          result_5080_12.setAttribute(\"uuid\", \"\" + result_5080_14);\n        }\n        if (descriptor.getGenPath() != null) {\n          String result_5080_15 = macros.shrinkPath(descriptor.getGenPath(), file);\n          result_5080_12.setAttribute(\"generatorOutputPath\", \"\" + result_5080_15);\n        }\n        boolean result_5080_16 = descriptor.getEnableJavaStubs();\n        result_5080_12.setAttribute(\"java-stubs-enabled\", \"\" + result_5080_16);\n\n        Element result_5080_17 = new Element(\"models\");\n        ModuleDescriptorPersistence.saveModelRoots(result_5080_17, descriptor.getModelRoots(), file, macros);\n        result_5080_12.addContent(result_5080_17);\n\n        Element result_5080_18 = new Element(\"accessoryModels\");\n        for (SModelReference model : ListSequence.fromList(descriptor.getAccessoryModels())) {\n          Element result_5080_19 = new Element(\"model\");\n          String result_5080_20 = model.toString();\n          result_5080_19.setAttribute(\"modelUID\", \"\" + result_5080_20);\n          result_5080_18.addContent(result_5080_19);\n        }\n        result_5080_12.addContent(result_5080_18);\n\n        Element result_5080_21 = new Element(\"generators\");\n        for (GeneratorDescriptor generatorDescriptor : ListSequence.fromList(descriptor.getGenerators())) {\n          GeneratorDescriptorPersistence.saveGeneratorDescriptor(result_5080_21, generatorDescriptor, file, macros);\n        }\n        result_5080_12.addContent(result_5080_21);\n\n        Element result_5080_22 = new Element(\"classPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getClassPaths())) {\n          Element result_5080_23 = new Element(\"entry\");\n          String result_5080_24 = macros.shrinkPath(entry.getPath(), file);\n          result_5080_23.setAttribute(\"path\", \"\" + result_5080_24);\n          boolean result_5080_25 = entry.isIncludedInVCS();\n          result_5080_23.setAttribute(\"include\", \"\" + result_5080_25);\n          result_5080_22.addContent(result_5080_23);\n        }\n        result_5080_12.addContent(result_5080_22);\n\n        Element result_5080_26 = new Element(\"languageRuntimeClassPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getRuntimeClassPaths())) {\n          Element result_5080_27 = new Element(\"entry\");\n          String result_5080_28 = macros.shrinkPath(entry.getPath(), file);\n          result_5080_27.setAttribute(\"path\", \"\" + result_5080_28);\n          result_5080_26.addContent(result_5080_27);\n        }\n        result_5080_12.addContent(result_5080_26);\n\n        Element result_5080_29 = new Element(\"sourcePath\");\n        for (String p : ListSequence.fromList(descriptor.getSourcePaths())) {\n          Element result_5080_30 = new Element(\"source\");\n          String result_5080_31 = macros.shrinkPath(p, file);\n          result_5080_30.setAttribute(\"path\", \"\" + result_5080_31);\n          result_5080_29.addContent(result_5080_30);\n        }\n        result_5080_12.addContent(result_5080_29);\n\n        boolean result_5080_32 = descriptor.getCompileInMPS();\n        result_5080_12.setAttribute(\"compileInMPS\", \"\" + result_5080_32);\n\n        ModuleDescriptorPersistence.saveDependencies(result_5080_12, descriptor);\n\n        Element result_5080_33 = new Element(\"extendedLanguages\");\n        for (ModuleReference ref : ListSequence.fromList(descriptor.getExtendedLanguages())) {\n          Element result_5080_34 = new Element(\"extendedLanguage\");\n          String result_5080_35 = ref.toString();\n          result_5080_34.setText(result_5080_35);\n          result_5080_33.addContent(result_5080_34);\n        }\n        result_5080_12.addContent(result_5080_33);\n        return result_5080_12;\n      }\n    }.invoke();\n\n    try {\n      OutputStream os = file.openOutputStream();\n      JDOMUtil.writeDocument(new Document(languageElement), os);\n    } catch (Exception e) {\n      if (log.isErrorEnabled()) {\n        log.error(\"\", e);\n      }\n    }\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, true);\n  }","id":88015,"modified_method":"public static void saveLanguageDescriptor(final IFile file, final LanguageDescriptor descriptor) {\n    if (file.isReadOnly()) {\n      if (log.isErrorEnabled()) {\n        log.error(\"Cant't save \" + file.getPath());\n      }\n      return;\n    }\n\n    final Macros macros = Macros.languageDescriptor();\n    Element languageElement = new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element result_5080_12 = new Element(\"language\");\n        String result_5080_13 = descriptor.getNamespace();\n        result_5080_12.setAttribute(\"namespace\", \"\" + result_5080_13);\n        if (descriptor.getUUID() != null) {\n          String result_5080_14 = descriptor.getUUID();\n          result_5080_12.setAttribute(\"uuid\", \"\" + result_5080_14);\n        }\n        if (descriptor.getGenPath() != null) {\n          String result_5080_15 = macros.shrinkPath(descriptor.getGenPath(), file);\n          result_5080_12.setAttribute(\"generatorOutputPath\", \"\" + result_5080_15);\n        }\n        boolean result_5080_16 = descriptor.getEnableJavaStubs();\n        result_5080_12.setAttribute(\"java-stubs-enabled\", \"\" + result_5080_16);\n\n        Element result_5080_17 = new Element(\"models\");\n        ModuleDescriptorPersistence.saveModelRoots(result_5080_17, descriptor.getModelRoots(), file, macros);\n        result_5080_12.addContent(result_5080_17);\n\n        Element result_5080_18 = new Element(\"accessoryModels\");\n        for (SModelReference model : ListSequence.fromList(descriptor.getAccessoryModels())) {\n          Element result_5080_19 = new Element(\"model\");\n          String result_5080_20 = model.toString();\n          result_5080_19.setAttribute(\"modelUID\", \"\" + result_5080_20);\n          result_5080_18.addContent(result_5080_19);\n        }\n        result_5080_12.addContent(result_5080_18);\n\n        Element result_5080_21 = new Element(\"generators\");\n        for (GeneratorDescriptor generatorDescriptor : ListSequence.fromList(descriptor.getGenerators())) {\n          GeneratorDescriptorPersistence.saveGeneratorDescriptor(result_5080_21, generatorDescriptor, file, macros);\n        }\n        result_5080_12.addContent(result_5080_21);\n\n        Element result_5080_22 = new Element(\"classPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getClassPaths())) {\n          Element result_5080_23 = new Element(\"entry\");\n          String result_5080_24 = macros.shrinkPath(entry.getPath(), file);\n          result_5080_23.setAttribute(\"path\", \"\" + result_5080_24);\n          boolean result_5080_25 = entry.isIncludedInVCS();\n          result_5080_23.setAttribute(\"include\", \"\" + result_5080_25);\n          result_5080_22.addContent(result_5080_23);\n        }\n        result_5080_12.addContent(result_5080_22);\n\n        if (!(descriptor.getStubModelEntries().isEmpty())) {\n          Element result_5080_26 = new Element(\"stubModelEntries\");\n          ModuleDescriptorPersistence.saveStubModelEntries(result_5080_26, descriptor.getStubModelEntries(), file, macros);\n          result_5080_12.addContent(result_5080_26);\n        }\n\n        Element result_5080_27 = new Element(\"languageRuntimeClassPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getRuntimeClassPaths())) {\n          Element result_5080_28 = new Element(\"entry\");\n          String result_5080_29 = macros.shrinkPath(entry.getPath(), file);\n          result_5080_28.setAttribute(\"path\", \"\" + result_5080_29);\n          result_5080_27.addContent(result_5080_28);\n        }\n        result_5080_12.addContent(result_5080_27);\n\n        Element result_5080_30 = new Element(\"sourcePath\");\n        for (String p : ListSequence.fromList(descriptor.getSourcePaths())) {\n          Element result_5080_31 = new Element(\"source\");\n          String result_5080_32 = macros.shrinkPath(p, file);\n          result_5080_31.setAttribute(\"path\", \"\" + result_5080_32);\n          result_5080_30.addContent(result_5080_31);\n        }\n        result_5080_12.addContent(result_5080_30);\n\n        boolean result_5080_33 = descriptor.getCompileInMPS();\n        result_5080_12.setAttribute(\"compileInMPS\", \"\" + result_5080_33);\n\n        ModuleDescriptorPersistence.saveDependencies(result_5080_12, descriptor);\n\n        Element result_5080_34 = new Element(\"extendedLanguages\");\n        for (ModuleReference ref : ListSequence.fromList(descriptor.getExtendedLanguages())) {\n          Element result_5080_35 = new Element(\"extendedLanguage\");\n          String result_5080_36 = ref.toString();\n          result_5080_35.setText(result_5080_36);\n          result_5080_34.addContent(result_5080_35);\n        }\n        result_5080_12.addContent(result_5080_34);\n        return result_5080_12;\n      }\n    }.invoke();\n\n    try {\n      OutputStream os = file.openOutputStream();\n      JDOMUtil.writeDocument(new Document(languageElement), os);\n    } catch (Exception e) {\n      if (log.isErrorEnabled()) {\n        log.error(\"\", e);\n      }\n    }\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, true);\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModuleDescriptor() {\n    myModelRoots = new ArrayList<ModelRoot>();\n    myDependencies = new ArrayList<Dependency>();\n    myUsedLanguages = new ArrayList<ModuleReference>();\n    myUsedDevkits = new ArrayList<ModuleReference>();\n    myClassPaths = new ArrayList<ClassPathEntry>();\n    mySourcePaths = new ArrayList<String>();\n  }","id":88016,"modified_method":"public ModuleDescriptor() {\n    myModelRoots = new ArrayList<ModelRoot>();\n    myDependencies = new ArrayList<Dependency>();\n    myUsedLanguages = new ArrayList<ModuleReference>();\n    myUsedDevkits = new ArrayList<ModuleReference>();\n    myClassPaths = new ArrayList<ClassPathEntry>();\n    myStubModels = new ArrayList<StubModelsEntry>();\n    mySourcePaths = new ArrayList<String>();\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static ModelRoot loadModelRoot(final Element modelRootElement, final IFile file, final Macros macros) {\n    return new _FunctionTypes._return_P0_E0<ModelRoot>() {\n      public ModelRoot invoke() {\n        ModelRoot result_9364_17 = new ModelRoot();\n        String result_9364_18 = AttributeUtils.stringWithDefault(modelRootElement.getAttributeValue(\"namespacePrefix\"), \"\");\n        result_9364_17.setPrefix(result_9364_18);\n        if (modelRootElement.getAttributeValue(\"persistenceHandler\") != null) {\n          String result_9364_19 = modelRootElement.getAttributeValue(\"persistenceHandler\");\n          result_9364_17.setHandlerClass(result_9364_19);\n        }\n        String pathName = modelRootElement.getAttributeValue(\"path\");\n        if (pathName == null) {\n          // left for compatibility \n          pathName = AttributeUtils.stringWithDefault(modelRootElement.getAttributeValue(\"rootPath\"), \"\");\n        }\n        String result_9364_20 = macros.expandPath(pathName, file);\n        result_9364_17.setPath(result_9364_20);\n        if (ListSequence.fromList(AttributeUtils.elementChildren(modelRootElement, \"manager\")).isNotEmpty()) {\n          new _FunctionTypes._return_P0_E0<ModelRootManager>() {\n            public ModelRootManager invoke() {\n              ModelRootManager result_9364_21 = new ModelRootManager();\n              Element manager = ListSequence.fromList(AttributeUtils.elementChildren(modelRootElement, \"manager\")).first();\n              String result_9364_22 = AttributeUtils.stringWithDefault(manager.getAttributeValue(\"moduleId\"), \"\");\n              result_9364_21.setModuleId(result_9364_22);\n              String result_9364_23 = AttributeUtils.stringWithDefault(manager.getAttributeValue(\"className\"), \"\");\n              result_9364_21.setClassName(result_9364_23);\n              return result_9364_21;\n            }\n          }.invoke();\n        }\n        return result_9364_17;\n      }\n    }.invoke();\n  }","id":88017,"modified_method":"private static ModelRoot loadModelRoot(final Element modelRootElement, final IFile file, final Macros macros) {\n    return new _FunctionTypes._return_P0_E0<ModelRoot>() {\n      public ModelRoot invoke() {\n        ModelRoot result_9364_17 = new ModelRoot();\n        String result_9364_18 = AttributeUtils.stringWithDefault(modelRootElement.getAttributeValue(\"namespacePrefix\"), \"\");\n        result_9364_17.setPrefix(result_9364_18);\n        if (modelRootElement.getAttributeValue(\"persistenceHandler\") != null) {\n          String result_9364_19 = modelRootElement.getAttributeValue(\"persistenceHandler\");\n          result_9364_17.setHandlerClass(result_9364_19);\n        }\n        String pathName = modelRootElement.getAttributeValue(\"path\");\n        if (pathName == null) {\n          // left for compatibility \n          pathName = AttributeUtils.stringWithDefault(modelRootElement.getAttributeValue(\"rootPath\"), \"\");\n        }\n        String result_9364_20 = macros.expandPath(pathName, file);\n        result_9364_17.setPath(result_9364_20);\n        return result_9364_17;\n      }\n    }.invoke();\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveModelRoots(Element modelsElement, List<ModelRoot> modelRoots, IFile file, Macros macros) {\n    Element result_9364_24 = modelsElement;\n    for (ModelRoot root : ListSequence.fromList(modelRoots)) {\n      Element result_9364_25 = new Element(\"modelRoot\");\n      String result_9364_26 = macros.shrinkPath((root.getPath() == null ?\n        \"\" :\n        root.getPath()\n      ), file);\n      result_9364_25.setAttribute(\"path\", \"\" + result_9364_26);\n      String result_9364_27 = (root.getPrefix() == null ?\n        \"\" :\n        root.getPrefix()\n      );\n      result_9364_25.setAttribute(\"namespacePrefix\", \"\" + result_9364_27);\n      if (root.getHandlerClass() != null) {\n        String result_9364_28 = root.getHandlerClass();\n        result_9364_25.setAttribute(\"persistenceHandler\", \"\" + result_9364_28);\n      }\n      if (root.getManager() != null) {\n        Element result_9364_29 = new Element(\"manager\");\n        String result_9364_30 = root.getManager().getModuleId();\n        result_9364_29.setAttribute(\"moduleId\", \"\" + result_9364_30);\n        String result_9364_31 = root.getManager().getClassName();\n        result_9364_29.setAttribute(\"className\", \"\" + result_9364_31);\n        result_9364_25.addContent(result_9364_29);\n      }\n      result_9364_24.addContent(result_9364_25);\n    }\n  }","id":88018,"modified_method":"public static void saveModelRoots(Element modelsElement, List<ModelRoot> modelRoots, IFile file, Macros macros) {\n    Element result_9364_27 = modelsElement;\n    for (ModelRoot root : ListSequence.fromList(modelRoots)) {\n      Element result_9364_28 = new Element(\"modelRoot\");\n      String result_9364_29 = macros.shrinkPath((root.getPath() == null ?\n        \"\" :\n        root.getPath()\n      ), file);\n      result_9364_28.setAttribute(\"path\", \"\" + result_9364_29);\n      String result_9364_30 = (root.getPrefix() == null ?\n        \"\" :\n        root.getPrefix()\n      );\n      result_9364_28.setAttribute(\"namespacePrefix\", \"\" + result_9364_30);\n      if (root.getHandlerClass() != null) {\n        String result_9364_31 = root.getHandlerClass();\n        result_9364_28.setAttribute(\"persistenceHandler\", \"\" + result_9364_31);\n      }\n      result_9364_27.addContent(result_9364_28);\n    }\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SolutionDescriptor loadSolutionDescriptor(final IFile file) {\n    final Macros macros = Macros.solutionDescriptor();\n    SolutionDescriptor descriptor;\n    try {\n      Document document = JDOMUtil.loadDocument(file);\n      Element rootElement = document.getRootElement();\n      final Element solutionElement = (Element) rootElement;\n\n      assert solutionElement != null;\n\n      descriptor = new _FunctionTypes._return_P0_E0<SolutionDescriptor>() {\n        public SolutionDescriptor invoke() {\n          SolutionDescriptor result_3591_0 = new SolutionDescriptor();\n          String result_3591_1 = solutionElement.getAttributeValue(\"name\");\n          result_3591_0.setNamespace(result_3591_1);\n\n          if (solutionElement.getAttributeValue(\"uuid\") != null) {\n            String result_3591_2 = solutionElement.getAttributeValue(\"uuid\");\n            result_3591_0.setUUID(result_3591_2);\n          }\n\n          boolean result_3591_3 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"extenallyVisible\"), true);\n          result_3591_0.setExternallyVisible(result_3591_3);\n          boolean result_3591_4 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"dontLoadClasses\"), false);\n          result_3591_0.setDontLoadClasses(result_3591_4);\n          boolean result_3591_5 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"compileInMPS\"), false);\n          result_3591_0.setCompileInMPS(result_3591_5);\n          boolean result_3591_6 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"java-stubs-enabled\"), true);\n          result_3591_0.setEnableJavaStubs(result_3591_6);\n\n          if (StringUtils.isNotEmpty(solutionElement.getAttributeValue(\"generatorOutputPath\"))) {\n            String result_3591_7 = macros.expandPath(solutionElement.getAttributeValue(\"generatorOutputPath\"), file);\n            result_3591_0.setOutputPath(result_3591_7);\n          }\n\n          result_3591_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"models\")).first(), \"modelRoot\"), file, macros));\n\n          ModuleDescriptorPersistence.loadDependencies(result_3591_0, solutionElement);\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"classPath\")).first(), \"entry\")).concat(ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"runtimeClassPath\")).first(), \"entry\")))) {\n            // runtime classpath left for compatibility \n            ClassPathEntry result_3591_8 = new ClassPathEntry();\n            String result_3591_9 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_3591_8.setPath(result_3591_9);\n            boolean result_3591_10 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_3591_8.setIncludedInVCS(result_3591_10);\n            result_3591_0.getClassPaths().add(result_3591_8);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"sourcePath\")).first(), \"source\"))) {\n            result_3591_0.getSourcePaths().add(macros.expandPath(entryElement.getAttributeValue(\"path\"), file));\n          }\n          return result_3591_0;\n        }\n      }.invoke();\n    } catch (Exception e) {\n      throw new ModuleReadException(e);\n    }\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, false);\n    return descriptor;\n  }","id":88019,"modified_method":"public static SolutionDescriptor loadSolutionDescriptor(final IFile file) {\n    final Macros macros = Macros.solutionDescriptor();\n    SolutionDescriptor descriptor;\n    try {\n      Document document = JDOMUtil.loadDocument(file);\n      Element rootElement = document.getRootElement();\n      final Element solutionElement = (Element) rootElement;\n\n      assert solutionElement != null;\n\n      descriptor = new _FunctionTypes._return_P0_E0<SolutionDescriptor>() {\n        public SolutionDescriptor invoke() {\n          SolutionDescriptor result_3591_0 = new SolutionDescriptor();\n          String result_3591_1 = solutionElement.getAttributeValue(\"name\");\n          result_3591_0.setNamespace(result_3591_1);\n\n          if (solutionElement.getAttributeValue(\"uuid\") != null) {\n            String result_3591_2 = solutionElement.getAttributeValue(\"uuid\");\n            result_3591_0.setUUID(result_3591_2);\n          }\n\n          boolean result_3591_3 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"extenallyVisible\"), true);\n          result_3591_0.setExternallyVisible(result_3591_3);\n          boolean result_3591_4 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"dontLoadClasses\"), false);\n          result_3591_0.setDontLoadClasses(result_3591_4);\n          boolean result_3591_5 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"compileInMPS\"), false);\n          result_3591_0.setCompileInMPS(result_3591_5);\n          boolean result_3591_6 = AttributeUtils.booleanWithDefault(solutionElement.getAttributeValue(\"java-stubs-enabled\"), true);\n          result_3591_0.setEnableJavaStubs(result_3591_6);\n\n          if (StringUtils.isNotEmpty(solutionElement.getAttributeValue(\"generatorOutputPath\"))) {\n            String result_3591_7 = macros.expandPath(solutionElement.getAttributeValue(\"generatorOutputPath\"), file);\n            result_3591_0.setOutputPath(result_3591_7);\n          }\n\n          result_3591_0.getModelRoots().addAll(ModuleDescriptorPersistence.loadModelRoots(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"models\")).first(), \"modelRoot\"), file, macros));\n\n          if (ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"stubModelEntries\")).isNotEmpty()) {\n            result_3591_0.getStubModelEntries().addAll(ModuleDescriptorPersistence.loadStubModelEntries(AttributeUtils.elementChildren(solutionElement, \"stubModelEntries\"), file, macros));\n          }\n\n          ModuleDescriptorPersistence.loadDependencies(result_3591_0, solutionElement);\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"classPath\")).first(), \"entry\")).concat(ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"runtimeClassPath\")).first(), \"entry\")))) {\n            // runtime classpath left for compatibility \n            ClassPathEntry result_3591_8 = new ClassPathEntry();\n            String result_3591_9 = macros.expandPath(entryElement.getAttributeValue(\"path\"), file);\n            result_3591_8.setPath(result_3591_9);\n            boolean result_3591_10 = AttributeUtils.booleanWithDefault(entryElement.getAttributeValue(\"include\"), false);\n            result_3591_8.setIncludedInVCS(result_3591_10);\n            result_3591_0.getClassPaths().add(result_3591_8);\n          }\n\n          for (Element entryElement : ListSequence.fromList(AttributeUtils.elementChildren(ListSequence.fromList(AttributeUtils.elementChildren(solutionElement, \"sourcePath\")).first(), \"source\"))) {\n            result_3591_0.getSourcePaths().add(macros.expandPath(entryElement.getAttributeValue(\"path\"), file));\n          }\n          return result_3591_0;\n        }\n      }.invoke();\n    } catch (Exception e) {\n      throw new ModuleReadException(e);\n    }\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, false);\n    return descriptor;\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveSolutionDescriptor(final IFile file, final SolutionDescriptor descriptor) {\n    if (file.isReadOnly()) {\n      if (log.isErrorEnabled()) {\n        log.error(\"Can't save \" + file.getPath());\n      }\n      return;\n    }\n\n    final Macros macros = Macros.solutionDescriptor();\n    Element solElem = new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element result_3591_11 = new Element(\"solution\");\n        if (descriptor.getNamespace() != null) {\n          String result_3591_12 = descriptor.getNamespace();\n          result_3591_11.setAttribute(\"name\", \"\" + result_3591_12);\n        }\n        if (descriptor.getUUID() != null) {\n          String result_3591_13 = descriptor.getUUID();\n          result_3591_11.setAttribute(\"uuid\", \"\" + result_3591_13);\n        }\n        boolean result_3591_14 = descriptor.isExternallyVisible();\n        result_3591_11.setAttribute(\"extenallyVisible\", \"\" + result_3591_14);\n        if (descriptor.isDontLoadClasses()) {\n          boolean result_3591_15 = true;\n          result_3591_11.setAttribute(\"dontLoadClasses\", \"\" + result_3591_15);\n        }\n        boolean result_3591_16 = descriptor.getCompileInMPS();\n        result_3591_11.setAttribute(\"compileInMPS\", \"\" + result_3591_16);\n        boolean result_3591_17 = descriptor.getEnableJavaStubs();\n        result_3591_11.setAttribute(\"java-stubs-enabled\", \"\" + result_3591_17);\n        if (descriptor.getOutputPath() != null) {\n          String result_3591_18 = macros.shrinkPath(descriptor.getOutputPath(), file);\n          result_3591_11.setAttribute(\"generatorOutputPath\", \"\" + result_3591_18);\n        }\n\n        Element result_3591_19 = new Element(\"models\");\n        ModuleDescriptorPersistence.saveModelRoots(result_3591_19, descriptor.getModelRoots(), file, macros);\n        result_3591_11.addContent(result_3591_19);\n\n        Element result_3591_20 = new Element(\"classPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getClassPaths())) {\n          Element result_3591_21 = new Element(\"entry\");\n          String result_3591_22 = macros.shrinkPath(entry.getPath(), file);\n          result_3591_21.setAttribute(\"path\", \"\" + result_3591_22);\n          boolean result_3591_23 = entry.isIncludedInVCS();\n          result_3591_21.setAttribute(\"include\", \"\" + result_3591_23);\n          result_3591_20.addContent(result_3591_21);\n        }\n        result_3591_11.addContent(result_3591_20);\n\n        Element result_3591_24 = new Element(\"sourcePath\");\n        for (String p : ListSequence.fromList(descriptor.getSourcePaths())) {\n          Element result_3591_25 = new Element(\"source\");\n          String result_3591_26 = macros.shrinkPath(p, file);\n          result_3591_25.setAttribute(\"path\", \"\" + result_3591_26);\n          result_3591_24.addContent(result_3591_25);\n        }\n        result_3591_11.addContent(result_3591_24);\n\n        ModuleDescriptorPersistence.saveDependencies(result_3591_11, descriptor);\n        return result_3591_11;\n      }\n    }.invoke();\n\n    try {\n      OutputStream os = file.openOutputStream();\n      JDOMUtil.writeDocument(new Document(solElem), os);\n    } catch (Exception e) {\n      if (log.isErrorEnabled()) {\n        log.error(\"\", e);\n      }\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, true);\n  }","id":88020,"modified_method":"public static void saveSolutionDescriptor(final IFile file, final SolutionDescriptor descriptor) {\n    if (file.isReadOnly()) {\n      if (log.isErrorEnabled()) {\n        log.error(\"Can't save \" + file.getPath());\n      }\n      return;\n    }\n\n    final Macros macros = Macros.solutionDescriptor();\n    Element solElem = new _FunctionTypes._return_P0_E0<Element>() {\n      public Element invoke() {\n        Element result_3591_11 = new Element(\"solution\");\n        if (descriptor.getNamespace() != null) {\n          String result_3591_12 = descriptor.getNamespace();\n          result_3591_11.setAttribute(\"name\", \"\" + result_3591_12);\n        }\n        if (descriptor.getUUID() != null) {\n          String result_3591_13 = descriptor.getUUID();\n          result_3591_11.setAttribute(\"uuid\", \"\" + result_3591_13);\n        }\n        boolean result_3591_14 = descriptor.isExternallyVisible();\n        result_3591_11.setAttribute(\"extenallyVisible\", \"\" + result_3591_14);\n        if (descriptor.isDontLoadClasses()) {\n          boolean result_3591_15 = true;\n          result_3591_11.setAttribute(\"dontLoadClasses\", \"\" + result_3591_15);\n        }\n        boolean result_3591_16 = descriptor.getCompileInMPS();\n        result_3591_11.setAttribute(\"compileInMPS\", \"\" + result_3591_16);\n        boolean result_3591_17 = descriptor.getEnableJavaStubs();\n        result_3591_11.setAttribute(\"java-stubs-enabled\", \"\" + result_3591_17);\n        if (descriptor.getOutputPath() != null) {\n          String result_3591_18 = macros.shrinkPath(descriptor.getOutputPath(), file);\n          result_3591_11.setAttribute(\"generatorOutputPath\", \"\" + result_3591_18);\n        }\n\n        Element result_3591_19 = new Element(\"models\");\n        ModuleDescriptorPersistence.saveModelRoots(result_3591_19, descriptor.getModelRoots(), file, macros);\n        result_3591_11.addContent(result_3591_19);\n\n        if (!(descriptor.getStubModelEntries().isEmpty())) {\n          Element result_3591_20 = new Element(\"stubModelEntries\");\n          ModuleDescriptorPersistence.saveStubModelEntries(result_3591_20, descriptor.getStubModelEntries(), file, macros);\n          result_3591_11.addContent(result_3591_20);\n        }\n\n        Element result_3591_21 = new Element(\"classPath\");\n        for (ClassPathEntry entry : ListSequence.fromList(descriptor.getClassPaths())) {\n          Element result_3591_22 = new Element(\"entry\");\n          String result_3591_23 = macros.shrinkPath(entry.getPath(), file);\n          result_3591_22.setAttribute(\"path\", \"\" + result_3591_23);\n          boolean result_3591_24 = entry.isIncludedInVCS();\n          result_3591_22.setAttribute(\"include\", \"\" + result_3591_24);\n          result_3591_21.addContent(result_3591_22);\n        }\n        result_3591_11.addContent(result_3591_21);\n\n        Element result_3591_25 = new Element(\"sourcePath\");\n        for (String p : ListSequence.fromList(descriptor.getSourcePaths())) {\n          Element result_3591_26 = new Element(\"source\");\n          String result_3591_27 = macros.shrinkPath(p, file);\n          result_3591_26.setAttribute(\"path\", \"\" + result_3591_27);\n          result_3591_25.addContent(result_3591_26);\n        }\n        result_3591_11.addContent(result_3591_25);\n\n        ModuleDescriptorPersistence.saveDependencies(result_3591_11, descriptor);\n        return result_3591_11;\n      }\n    }.invoke();\n\n    try {\n      OutputStream os = file.openOutputStream();\n      JDOMUtil.writeDocument(new Document(solElem), os);\n    } catch (Exception e) {\n      if (log.isErrorEnabled()) {\n        log.error(\"\", e);\n      }\n    }\n\n    ModuleDescriptorPersistence.setTimestamp(descriptor, file, true);\n  }","commit_id":"9a00720d1d4eaf7c8a5d7e438080322c29a75288","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void variable(Map<Object, Object> args) {\n    if (args == null) return;\n\n    parseVariable(args);\n    myDeclarations.add(args);\n  }","id":88021,"modified_method":"public void variable(Map<Object, Object> args) {\n    if (args == null) return;\n\n    args = ContainerUtil.newLinkedHashMap(args);\n    parseVariable(args);\n    myDeclarations = myDeclarations.prepend(args);\n  }","commit_id":"a240a44fbbfc3a94824d933d72e809c38f52c587","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public CustomMembersHolder getMembersHolder() {\n    if (!myDeclarations.isEmpty()) {\n      addMemberHolder(new CustomMembersHolder() {\n        @Override\n        public boolean processMembers(GroovyClassDescriptor descriptor, PsiScopeProcessor processor, ResolveState state) {\n          return NonCodeMembersHolder.generateMembers(myDeclarations, descriptor.justGetPlaceFile()).processMembers(descriptor, processor, state);\n        }\n      });\n    }\n    return myDepot;\n  }","id":88022,"modified_method":"@Nullable\n  public CustomMembersHolder getMembersHolder() {\n    if (!myDeclarations.isEmpty()) {\n      addMemberHolder(new CustomMembersHolder() {\n        @Override\n        public boolean processMembers(GroovyClassDescriptor descriptor, PsiScopeProcessor processor, ResolveState state) {\n          return NonCodeMembersHolder.generateMembers(ContainerUtil.reverse(myDeclarations), descriptor.justGetPlaceFile()).processMembers(\n            descriptor, processor, state);\n        }\n      });\n    }\n    return myDepot;\n  }","commit_id":"a240a44fbbfc3a94824d933d72e809c38f52c587","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void method(Map<Object, Object> args) {\n    if (args == null) return;\n\n    parseMethod(args);\n    args.put(\"declarationType\", DeclarationType.METHOD);\n    myDeclarations.add(args);\n  }","id":88023,"modified_method":"public void method(Map<Object, Object> args) {\n    if (args == null) return;\n\n    args = ContainerUtil.newLinkedHashMap(args);\n    parseMethod(args);\n    args.put(\"declarationType\", DeclarationType.METHOD);\n    myDeclarations = myDeclarations.prepend(args);\n  }","commit_id":"a240a44fbbfc3a94824d933d72e809c38f52c587","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"UnusedDeclaration\")\n  public void closureInMethod(Map<Object, Object> args) {\n    if (args == null) return;\n\n    parseMethod(args);\n    final Object method = args.get(\"method\");\n    if (method instanceof Map) {\n      parseMethod((Map)method);\n    }\n    args.put(\"declarationType\", DeclarationType.CLOSURE);\n    myDeclarations.add(args);\n  }","id":88024,"modified_method":"@SuppressWarnings(\"UnusedDeclaration\")\n  public void closureInMethod(Map<Object, Object> args) {\n    if (args == null) return;\n\n    args = ContainerUtil.newLinkedHashMap(args);\n    parseMethod(args);\n    final Object method = args.get(\"method\");\n    if (method instanceof Map) {\n      parseMethod((Map)method);\n    }\n    args.put(\"declarationType\", DeclarationType.CLOSURE);\n    myDeclarations = myDeclarations.prepend(args);\n  }","commit_id":"a240a44fbbfc3a94824d933d72e809c38f52c587","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * <p>\n     * Install the plugin into the eclipse instance's /plugins directory\n     * <\/p>\n     * <ol>\n     * <li>Determine whether the plugin should be extracted into a directory or not<\/li>\n     * <li>If the plugin's target location exists, or overwrite is set to true:\n     * <ol type=\"a\">\n     * <li>if extract, ensure the plugin target location exists (mkdirs), and extract there.<\/li>\n     * <li>copy the plugin file from the local repository to the target location<\/li>\n     * <\/ol>\n     * <p>\n     * Warn whenever a plugin will overwrite an existing file or directory, and emit an INFO message whenever a plugin\n     * installation is skipped because of an existing file and overwrite == false.\n     * <\/p>\n     *\n     * @param artifact The plugin dependency as it has been resolved.\n     * @param project The project metadata for the accompanying plugin-dependency artifact, used to determine whether to\n     *            install as a jar or as a directory\n     * @throws MojoExecutionException In the event the plugin should be extracted but cannot, or the file copy fails (in\n     *             the event it should not be extracted)\n     * @throws MojoFailureException In the event that the plugins target directory (inside the Eclipse instance\n     *             directory) does not exist, or is not a directory.\n     */\n    private void install( Artifact artifact, MavenProject project )\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( pluginsDir == null )\n        {\n            pluginsDir = new File( eclipseDir, \"plugins\" );\n        }\n\n        if ( !pluginsDir.exists() || !pluginsDir.isDirectory() )\n        {\n            throw new MojoFailureException( \"Invalid Eclipse directory: \" + eclipseDir\n                + \" (plugins directory is missing or not a directory).\" );\n        }\n\n        boolean installAsJar = true;\n\n        Properties properties = project.getProperties();\n        if ( properties != null )\n        {\n            installAsJar = !Boolean.valueOf( properties.getProperty( PROP_UNPACK_PLUGIN, \"false\" ) ).booleanValue();\n        }\n\n        Attributes attributes = null;\n        try\n        {\n            // don't verify, plugins zipped by eclipse:make-artifacts could have a bad signature\n            JarFile jar = new JarFile( artifact.getFile(), false );\n            Manifest manifest = jar.getManifest();\n            if ( manifest == null )\n            {\n                getLog().debug(\n                                \"Ignoring \" + artifact.getArtifactId()\n                                    + \" as it is does not have a Manifest (and so is not an OSGi bundle)\" );\n                return;\n            }\n            attributes = manifest.getMainAttributes();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Unable to read manifest of plugin \"\n                + artifact.getFile().getAbsolutePath(), e );\n        }\n\n        String bundleVersion = attributes.getValue( \"Bundle-Version\" );\n        String pluginName = formatEclipsePluginName( artifact );\n\n        File pluginFile = new File( pluginsDir, pluginName + \".jar\" );\n        File pluginDir = new File( pluginsDir, pluginName );\n\n        boolean skipped = true;\n\n        /* check if artifact is an OSGi bundle and ignore if not */\n        Object bundleName = attributes.getValue( \"Bundle-Name\" );\n        if ( bundleName == null )\n        {\n            getLog().debug(\n                            \"Ignoring \" + artifact.getArtifactId()\n                                + \" as it is not an OSGi bundle (no Bundle-Name in manifest)\" );\n            return;\n        }\n\n        if ( overwrite )\n        {\n            if ( pluginFile.exists() || pluginDir.exists() )\n            {\n                getLog().warn( \"Overwriting old plugin with contents of: \" + artifact.getId() );\n\n                getLog().debug( \"Removing old plugin from both: \" + pluginFile + \" and: \" + pluginDir );\n\n                try\n                {\n                    FileUtils.forceDelete( pluginDir );\n                    FileUtils.forceDelete( pluginFile );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Failed to remove old plugin from: \" + pluginFile + \" or: \"\n                        + pluginDir, e );\n                }\n\n                getLog().debug( \"Removal of old plugin is complete; proceeding with plugin installation.\" );\n            }\n\n            performFileOperations( installAsJar, artifact, pluginFile, pluginDir );\n\n            skipped = false;\n        }\n        else if ( installAsJar && !pluginFile.exists() )\n        {\n            performFileOperations( installAsJar, artifact, pluginFile, pluginDir );\n\n            skipped = false;\n        }\n        else if ( !installAsJar && !pluginDir.exists() )\n        {\n            performFileOperations( installAsJar, artifact, pluginFile, pluginDir );\n\n            skipped = false;\n        }\n\n        if ( skipped )\n        {\n            if ( installAsJar )\n            {\n                getLog().info(\n                               \"Skipping plugin installation for: \" + artifact.getId() + \"; file: \" + pluginFile\n                                   + \" already exists. Set overwrite = true to override this.\" );\n            }\n            else if ( !installAsJar )\n            {\n                getLog().info(\n                               \"Skipping plugin installation for: \" + artifact.getId() + \"; directory: \" + pluginDir\n                                   + \" already exists. Set overwrite = true to override this.\" );\n            }\n        }\n    }","id":88025,"modified_method":"/**\n     * <p>\n     * Install the plugin into the eclipse instance's /plugins directory\n     * <\/p>\n     * <ol>\n     * <li>Determine whether the plugin should be extracted into a directory or not<\/li>\n     * <li>If the plugin's target location exists, or overwrite is set to true:\n     * <ol type=\"a\">\n     * <li>if extract, ensure the plugin target location exists (mkdirs), and extract there.<\/li>\n     * <li>copy the plugin file from the local repository to the target location<\/li>\n     * <\/ol>\n     * <p>\n     * Warn whenever a plugin will overwrite an existing file or directory, and emit an INFO message whenever a plugin\n     * installation is skipped because of an existing file and overwrite == false.\n     * <\/p>\n     * \n     * @param artifact The plugin dependency as it has been resolved.\n     * @param project The project metadata for the accompanying plugin-dependency artifact, used to determine whether to\n     *            install as a jar or as a directory\n     * @throws MojoExecutionException In the event the plugin should be extracted but cannot, or the file copy fails (in\n     *             the event it should not be extracted)\n     * @throws MojoFailureException In the event that the plugins target directory (inside the Eclipse instance\n     *             directory) does not exist, or is not a directory.\n     */\n    private void install( Artifact artifact, MavenProject project )\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( pluginsDir == null )\n        {\n            pluginsDir = new File( eclipseDir, \"plugins\" );\n        }\n\n        if ( !pluginsDir.exists() || !pluginsDir.isDirectory() )\n        {\n            throw new MojoFailureException( \"Invalid Eclipse directory: \" + eclipseDir\n                + \" (plugins directory is missing or not a directory).\" );\n        }\n\n        boolean installAsJar = true;\n\n        Properties properties = project.getProperties();\n        if ( properties != null )\n        {\n            installAsJar = !Boolean.valueOf( properties.getProperty( PROP_UNPACK_PLUGIN, \"false\" ) ).booleanValue();\n        }\n\n        Attributes attributes = null;\n        try\n        {\n            // don't verify, plugins zipped by eclipse:make-artifacts could have a bad signature\n            JarFile jar = new JarFile( artifact.getFile(), false );\n            Manifest manifest = jar.getManifest();\n            if ( manifest == null )\n            {\n                getLog().debug(\n                                \"Ignoring \" + artifact.getArtifactId()\n                                    + \" as it is does not have a Manifest (and so is not an OSGi bundle)\" );\n                return;\n            }\n            attributes = manifest.getMainAttributes();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Unable to read manifest of plugin \"\n                + artifact.getFile().getAbsolutePath(), e );\n        }\n\n        String pluginName = formatEclipsePluginName( artifact );\n\n        File pluginFile = new File( pluginsDir, pluginName + \".jar\" );\n        File pluginDir = new File( pluginsDir, pluginName );\n\n        boolean skipped = true;\n\n        /* check if artifact is an OSGi bundle and ignore if not */\n        Object bundleName = attributes.getValue( \"Bundle-Name\" );\n        Object bundleSymbolicName = attributes.getValue( \"Bundle-SymbolicName\" );\n        if ( bundleSymbolicName == null && bundleName == null )\n        {\n            getLog().debug(\n                            \"Ignoring \" + artifact.getArtifactId()\n                                + \" as it is not an OSGi bundle (no Bundle-SymbolicName or Bundle-Name in manifest)\" );\n            return;\n        }\n\n        if ( overwrite )\n        {\n            if ( pluginFile.exists() || pluginDir.exists() )\n            {\n                getLog().warn( \"Overwriting old plugin with contents of: \" + artifact.getId() );\n\n                getLog().debug( \"Removing old plugin from both: \" + pluginFile + \" and: \" + pluginDir );\n\n                try\n                {\n                    FileUtils.forceDelete( pluginDir );\n                    FileUtils.forceDelete( pluginFile );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Failed to remove old plugin from: \" + pluginFile + \" or: \"\n                        + pluginDir, e );\n                }\n\n                getLog().debug( \"Removal of old plugin is complete; proceeding with plugin installation.\" );\n            }\n\n            performFileOperations( installAsJar, artifact, pluginFile, pluginDir );\n\n            skipped = false;\n        }\n        else if ( installAsJar && !pluginFile.exists() )\n        {\n            performFileOperations( installAsJar, artifact, pluginFile, pluginDir );\n\n            skipped = false;\n        }\n        else if ( !installAsJar && !pluginDir.exists() )\n        {\n            performFileOperations( installAsJar, artifact, pluginFile, pluginDir );\n\n            skipped = false;\n        }\n\n        if ( skipped )\n        {\n            if ( installAsJar )\n            {\n                getLog().info(\n                               \"Skipping plugin installation for: \" + artifact.getId() + \"; file: \" + pluginFile\n                                   + \" already exists. Set overwrite = true to override this.\" );\n            }\n            else if ( !installAsJar )\n            {\n                getLog().info(\n                               \"Skipping plugin installation for: \" + artifact.getId() + \"; directory: \" + pluginDir\n                                   + \" already exists. Set overwrite = true to override this.\" );\n            }\n        }\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldInstallAsJarWhenPropertyIsTrue()\n        throws MojoExecutionException, MojoFailureException\n    {\n        File pluginsDir = performTestInstall( Boolean.TRUE, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertTrue( installedFile + \" should exist.\", installedFile.exists() );\n        assertFalse( installedDir + \" should not exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88026,"modified_method":"public void testShouldInstallAsJarWhenPropertyIsTrue()\n        throws MojoExecutionException, MojoFailureException\n    {\n        performTestInstall( Boolean.TRUE, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        assertInstalledFileExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldInstallAsJarWhenPropertyNotSpecified()\n        throws MojoExecutionException, MojoFailureException\n    {\n        File pluginsDir = performTestInstall( null, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertTrue( installedFile + \" should exist.\", installedFile.exists() );\n        assertFalse( installedDir + \" should not exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88027,"modified_method":"public void testShouldInstallAsJarWhenPropertyNotSpecified()\n        throws MojoExecutionException, MojoFailureException\n    {\n        performTestInstall( null, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        assertInstalledFileExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldRemoveOldDirectoryBeforeInstallingNewJarWhenOverwriteIsFalse()\n        throws MojoExecutionException, MojoFailureException\n    {\n        createPluginsDir();\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        installedDir.mkdir();\n\n        assertTrue( installedDir + \" should have been created prior to running the test.\", installedDir.exists() );\n\n        performTestInstall( Boolean.FALSE, true, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertFalse( installedFile + \" should not exist.\", installedFile.exists() );\n        assertTrue( installedDir + \" should still exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88028,"modified_method":"public void testShouldRemoveOldDirectoryBeforeInstallingNewJarWhenOverwriteIsFalse()\n        throws MojoExecutionException, MojoFailureException\n    {\n        createPluginsDir();\n\n        File installedDir = locateInstalledDir( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        installedDir.mkdir();\n        assertInstalledDirExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        performTestInstall( Boolean.FALSE, true, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        assertInstalledFileDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"private File locateInstalledDir( File pluginsDir, Artifact artifact )\n    {\n        return new File( pluginsDir, formatEclipsePluginName( artifact ) );\n    }","id":88029,"modified_method":"/**\n     * @param artifact\n     * @return the installed directory for the plugin (because it is an unpacked bundle)\n     */\n    private File locateInstalledDir( Artifact artifact )\n    {\n        return new File( pluginsDir, formatEclipsePluginName( artifact ) );\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldInstallAsDirWhenPropertyIsFalse()\n        throws MojoExecutionException, MojoFailureException\n    {\n        File pluginsDir =\n            performTestInstall( Boolean.FALSE, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertFalse( installedFile + \" should not exist.\", installedFile.exists() );\n        assertTrue( installedDir + \" should exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88030,"modified_method":"public void testShouldInstallAsDirWhenPropertyIsFalse()\n        throws MojoExecutionException, MojoFailureException\n    {\n        performTestInstall( Boolean.FALSE, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        assertInstalledFileDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldNotInstallWhenTypeNotContainedInPluginTypesList()\n        throws MojoExecutionException, MojoFailureException\n    {\n        File pluginsDir = performTestInstall( null, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"type-not-in-this-list\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertFalse( installedFile + \" should not exist.\", installedFile.exists() );\n        assertFalse( installedDir + \" should not exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88031,"modified_method":"public void testShouldNotInstallWhenTypeNotContainedInPluginTypesList()\n        throws MojoExecutionException, MojoFailureException\n    {\n        performTestInstall( null, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"type-not-in-this-list\" );\n\n        assertInstalledFileDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldInstallWhenTypeContainedInPluginTypesListWithMultipleValues()\n        throws MojoExecutionException, MojoFailureException\n    {\n        File pluginsDir =\n            performTestInstall( null, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"osgi-bundle,eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertTrue( installedFile + \" should exist.\", installedFile.exists() );\n        assertFalse( installedDir + \" should not exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88032,"modified_method":"public void testShouldInstallWhenTypeContainedInPluginTypesListWithMultipleValues()\n        throws MojoExecutionException, MojoFailureException\n    {\n        performTestInstall( null, false, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"osgi-bundle,eclipse-plugin\" );\n\n        assertInstalledFileExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Artifact createArtifact(String groupId, String artifactId, String version)\n    {\n        Artifact artifact = new DefaultArtifact( groupId, artifactId, VersionRange.createFromVersion( version ), \"scope-unused\",\n                             \"eclipse-plugin\", \"classifier-unused\", null );\n        artifact.setFile( locateArtifact( artifact ) );\n\n        return artifact;\n    }","id":88033,"modified_method":"/**\n     * @param groupId\n     * @param artifactId\n     * @param version\n     * @return an artifact with the specified values and configured for testing to the local m2repo\n     */\n    private Artifact createArtifact( String groupId, String artifactId, String version )\n    {\n        Artifact artifact =\n            new DefaultArtifact( groupId, artifactId, VersionRange.createFromVersion( version ), \"scope-unused\",\n                                 \"eclipse-plugin\", \"classifier-unused\", null );\n        artifact.setFile( locateArtifact( artifact ) );\n\n        return artifact;\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"private File locateInstalledFile( File pluginsDir, Artifact artifact )\n    {\n        return new File( pluginsDir, formatEclipsePluginName( artifact ) + \".jar\" );\n    }","id":88034,"modified_method":"/**\n     * @param artifact\n     * @return the installed file for the plugin bundle\n     */\n    private File locateInstalledFile( Artifact artifact )\n    {\n        return new File( pluginsDir, formatEclipsePluginName( artifact ) + \".jar\" );\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testShouldRemoveOldDirectoryBeforeInstallingNewJarWhenOverwriteIsTrue()\n        throws MojoExecutionException, MojoFailureException\n    {\n        createPluginsDir();\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        installedDir.mkdir();\n\n        assertTrue( installedDir + \" should have been created prior to running the test.\", installedDir.exists() );\n\n        performTestInstall( null, true, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertTrue( installedFile + \" should exist.\", installedFile.exists() );\n        assertFalse( installedDir + \" should not exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88035,"modified_method":"public void testShouldRemoveOldDirectoryBeforeInstallingNewJarWhenOverwriteIsTrue()\n        throws MojoExecutionException, MojoFailureException\n    {\n        createPluginsDir();\n\n        File installedDir = locateInstalledDir( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        installedDir.mkdir();\n        assertInstalledDirExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        performTestInstall( null, true, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME, \"eclipse-plugin\" );\n\n        assertInstalledFileExists( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n        assertInstalledDirDoesNotExist( ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"private File performTestInstall( Boolean installAsJar, boolean overwrite, Artifact artifact, String typeList )\n        throws MojoExecutionException, MojoFailureException\n    {\n        createPluginsDir();\n\n        String type = artifact.getType();\n        Artifact dep = createDependencyArtifact( artifact );\n\n        ArtifactRepository localRepo = createLocalRepository();\n        MavenProjectBuilder projectBuilder = createProjectBuilder( typeList.indexOf( type ) > -1, installAsJar );\n        ArchiverManager archiverManager = createArchiverManager( typeList.indexOf( type ) > -1, installAsJar );\n        InputHandler inputHandler = createInputHandler();\n\n        Log log = new SystemStreamLog();\n\n        mm.replayAll();\n\n        InstallPluginsMojo mojo =\n            new InstallPluginsMojo( eclipseDir, overwrite, Collections.singletonList( dep ), typeList, localRepo,\n                                    projectBuilder, archiverManager, inputHandler, log );\n        try\n        {\n            Field field = InstallPluginsMojo.class.getDeclaredField( \"maven2OsgiConverter\" );\n            field.setAccessible( true );\n            field.set( mojo, new DefaultMaven2OsgiConverter() );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Unable to configure maven2OsgiConverter\", e );\n        }\n\n        mojo.execute();\n\n        return pluginsDir;\n    }","id":88036,"modified_method":"private void performTestInstall( Boolean installAsJar, boolean overwrite, Artifact artifact, String typeList )\n        throws MojoExecutionException, MojoFailureException\n    {\n        createPluginsDir();\n\n        String type = artifact.getType();\n\n        ArtifactRepository localRepo = createLocalRepository();\n        MavenProjectBuilder projectBuilder = createProjectBuilder( typeList.indexOf( type ) > -1, installAsJar );\n        ArchiverManager archiverManager = createArchiverManager( typeList.indexOf( type ) > -1, installAsJar );\n        InputHandler inputHandler = createInputHandler();\n\n        Log log = new SystemStreamLog();\n\n        mm.replayAll();\n\n        InstallPluginsMojo mojo =\n            new InstallPluginsMojo( eclipseDir, overwrite, Collections.singletonList( artifact ), typeList, localRepo,\n                                    projectBuilder, archiverManager, inputHandler, log );\n        try\n        {\n            Field field = InstallPluginsMojo.class.getDeclaredField( \"maven2OsgiConverter\" );\n            field.setAccessible( true );\n            field.set( mojo, new DefaultMaven2OsgiConverter() );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Unable to configure maven2OsgiConverter\", e );\n        }\n\n        mojo.execute();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testJira488()\n        throws MojoExecutionException, MojoFailureException\n    {\n        Artifact jira488_missingManifest =\n            createArtifact(\"jira\", \"meclipse\", \"488\");\n\n        File pluginsDir = performTestInstall( null, false, jira488_missingManifest, \"eclipse-plugin\" );\n\n        File installedFile = locateInstalledFile( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        File installedDir = locateInstalledDir( pluginsDir, ARTIFACT_ORG_ECLIPSE_CORE_RUNTIME );\n\n        assertFalse( installedFile + \" should not exist as Jar has not Manifest.\", installedFile.exists() );\n        assertFalse( installedDir + \" should not exist.\", installedDir.exists() );\n\n        mm.verifyAll();\n    }","id":88037,"modified_method":"/**\n     * if a jar has no manifest, do not install plugin.\n     * \n     * @throws MojoExecutionException\n     * @throws MojoFailureException\n     */\n    public void testJira_MECLIPSE_488()\n        throws MojoExecutionException, MojoFailureException\n    {\n        Artifact jira488_missingManifest = createArtifact( \"jira\", \"meclipse_488\", \"1\" );\n\n        performTestInstall( null, false, jira488_missingManifest, \"eclipse-plugin\" );\n\n        assertInstalledFileDoesNotExist( jira488_missingManifest );\n        assertInstalledDirDoesNotExist( jira488_missingManifest );\n\n        mm.verifyAll();\n    }","commit_id":"ee854b8eb62031dae27084c112847b975a185bcd","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static List<DeleteInfo> doDelete(XFormsContainingDocument containingDocument, IndentedLogger indentedLogger,\n                                      List collectionToUpdate, int deleteIndex, boolean doDispatch) {\n\n        final boolean isEmptyNodesetBinding = collectionToUpdate == null || collectionToUpdate.size() == 0;\n\n        final List<DeleteInfo> deleteInfos;\n        if (isEmptyNodesetBinding) {\n            deleteInfos = Collections.emptyList();\n        } else if (deleteIndex == -1) {\n            // Delete the entire collection\n\n            deleteInfos = new ArrayList<DeleteInfo>(collectionToUpdate.size());\n            for (int i = 1; i <= collectionToUpdate.size(); i++) {\n                final DeleteInfo deletedInfo = doDeleteOne(indentedLogger, collectionToUpdate, i);\n                if (deletedInfo != null) {\n                    deleteInfos.add(deletedInfo);\n                }\n            }\n        } else {\n            // Find actual deletion point\n\n            final DeleteInfo deleteInfo = doDeleteOne(indentedLogger, collectionToUpdate, deleteIndex);\n            if (deleteInfo != null) {\n                deleteInfos = Collections.singletonList(deleteInfo);\n            } else {\n                deleteInfos = Collections.emptyList();\n            }\n        }\n\n        if (deleteInfos.size() == 0) {\n            if (indentedLogger.isDebugEnabled())\n                indentedLogger.logDebug(\"xforms:delete\", \"empty collection, terminating\");\n        } else {\n            // Identify the instance that actually changes\n            // NOTE: More than one instance may be modified. For now we look at the first one.\n            final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(deleteInfos.get(0).nodeInfo);\n\n            if (indentedLogger.isDebugEnabled())\n                indentedLogger.logDebug(\"xforms:delete\", \"removed nodes\",\n                        \"count\", Integer.toString(deleteInfos.size()), \"instance\",\n                                (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : null);\n\n            if (modifiedInstance != null) {\n                // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n                \n                // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                modifiedInstance.getModel(containingDocument).markStructuralChange(modifiedInstance);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                if (doDispatch)\n                    modifiedInstance.getXBLContainer(containingDocument).dispatchEvent(new XFormsDeleteEvent(containingDocument, modifiedInstance, deleteInfos, deleteIndex));\n            }\n        }\n\n        return deleteInfos;\n    }","id":88038,"modified_method":"public static List<DeleteInfo> doDelete(XFormsContainingDocument containingDocument, IndentedLogger indentedLogger,\n                                      List collectionToUpdate, int deleteIndex, boolean doDispatch) {\n\n        final boolean isEmptyNodesetBinding = collectionToUpdate == null || collectionToUpdate.size() == 0;\n\n        final List<DeleteInfo> deleteInfos;\n        if (isEmptyNodesetBinding) {\n            deleteInfos = Collections.emptyList();\n        } else if (deleteIndex == -1) {\n            // Delete the entire collection\n\n            deleteInfos = new ArrayList<DeleteInfo>(collectionToUpdate.size());\n            for (int i = 1; i <= collectionToUpdate.size(); i++) {\n                final DeleteInfo deletedInfo = doDeleteOne(indentedLogger, collectionToUpdate, i);\n                if (deletedInfo != null) {\n                    deleteInfos.add(deletedInfo);\n                }\n            }\n        } else {\n            // Find actual deletion point\n\n            final DeleteInfo deleteInfo = doDeleteOne(indentedLogger, collectionToUpdate, deleteIndex);\n            if (deleteInfo != null) {\n                deleteInfos = Collections.singletonList(deleteInfo);\n            } else {\n                deleteInfos = Collections.emptyList();\n            }\n        }\n\n        if (deleteInfos.size() == 0) {\n            if (indentedLogger != null && indentedLogger.isDebugEnabled())\n                indentedLogger.logDebug(\"xforms:delete\", \"empty collection, terminating\");\n        } else if (containingDocument != null) {\n            // Identify the instance that actually changes\n            // NOTE: More than one instance may be modified. For now we look at the first one.\n            final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(deleteInfos.get(0).nodeInfo);\n\n            if (indentedLogger != null && indentedLogger.isDebugEnabled())\n                indentedLogger.logDebug(\"xforms:delete\", \"removed nodes\",\n                        \"count\", Integer.toString(deleteInfos.size()), \"instance\",\n                                (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : null);\n\n            if (modifiedInstance != null) {\n                // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n                \n                // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                modifiedInstance.getModel(containingDocument).markStructuralChange(modifiedInstance);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                if (doDispatch)\n                    modifiedInstance.getXBLContainer(containingDocument).dispatchEvent(new XFormsDeleteEvent(containingDocument, modifiedInstance, deleteInfos, deleteIndex));\n            }\n        }\n\n        return deleteInfos;\n    }","commit_id":"e728fbd451a40817646083af8ae2f680a459831b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static List doInsert(XFormsContainingDocument containingDocument, IndentedLogger indentedLogger, String positionAttribute,\n                                List collectionToBeUpdated, NodeInfo insertContextNodeInfo, List originItems, int insertionIndex, boolean doClone, boolean doDispatch) {\n\n        final boolean isEmptyNodesetBinding = collectionToBeUpdated == null || collectionToBeUpdated.size() == 0;\n\n        // \"3. The origin node-set is determined.\"\n        // \"5. Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n        final List<Node> sourceNodes;\n        final List<Node> clonedNodes;\n        {\n            final List<Node> clonedNodesTemp;\n            if (originItems == null) {\n                // There are no explicitly specified origin objects, use node from Node Set Binding node-set\n\n                // \"If the origin attribute is not given and the Node Set Binding node-set is empty, then the origin\n                // node-set is the empty node-set. [...] The insert action is terminated with no effect if the\n                // origin node-set is the empty node-set.\"\n\n                if (isEmptyNodesetBinding) {\n                    if (indentedLogger.isDebugEnabled())\n                        indentedLogger.logDebug(\"xforms:insert\", \"origin node-set from node-set binding is empty, terminating\");\n                    return Collections.EMPTY_LIST;\n                }\n\n                // \"Otherwise, if the origin attribute is not given, then the origin node-set consists of the last\n                // node of the Node Set Binding node-set.\"\n                final Node singleSourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1), CANNOT_INSERT_READONLY_MESSAGE);\n                // TODO: check namespace handling might be incorrect. Should use copyElementCopyParentNamespaces() instead?\n                final Node singleClonedNode = Dom4jUtils.createCopy(singleSourceNode);\n\n                sourceNodes = Collections.singletonList(singleSourceNode);\n                clonedNodesTemp = Collections.singletonList(singleClonedNode);\n\n                originItems = null;\n            } else {\n                // There are explicitly specified origin objects\n\n                // \"The insert action is terminated with no effect if the origin node-set is the empty node-set.\"\n                if (originItems.size() == 0) {\n                    if (indentedLogger.isDebugEnabled())\n                        indentedLogger.logDebug(\"xforms:insert\", \"origin node-set is empty, terminating\");\n                    return Collections.EMPTY_LIST;\n                }\n\n                // \"Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n\n                sourceNodes = new ArrayList<Node>(originItems.size()); // set to max possible size\n                clonedNodesTemp = new ArrayList<Node>(originItems.size());\n\n                for (final Object currentObject: originItems) {\n                    if (currentObject instanceof NodeInfo) {\n                        // This is the regular case covered by XForms 1.1 / XPath 1.0\n\n                        // NOTE: Don't clone nodes if doClone == false\n                        final Node sourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) currentObject, CANNOT_INSERT_READONLY_MESSAGE);\n                        final Node clonedNode = doClone ? (sourceNode instanceof Element) ? ((Element) sourceNode).createCopy() : (Node) sourceNode.clone() : sourceNode;\n\n                        sourceNodes.add(sourceNode);\n                        clonedNodesTemp.add(clonedNode);\n\n                    } else {\n                        // This is an extension: support sequences containing other items\n\n                        // Convert the result to a text node\n                        final String stringValue = currentObject.toString(); // we get String, Long, etc.\n                        final Text textNode = Dom4jUtils.createText(stringValue);\n\n                        sourceNodes.add(null); // there is no source node for this cloned node, it's a source item\n                        clonedNodesTemp.add(textNode);\n                    }\n                }\n            }\n\n            // Remove instance data from cloned nodes and perform Document node adjustment\n            for (int i = 0; i < clonedNodesTemp.size(); i++) {\n                final Node clonedNodeTemp = clonedNodesTemp.get(i);\n\n                if (clonedNodeTemp instanceof Element) {\n                    // Element node\n                    InstanceData.remove(clonedNodeTemp);\n                    clonedNodeTemp.detach();\n                } else if (clonedNodeTemp instanceof Attribute) {\n                    // Attribute node\n                    InstanceData.remove(clonedNodeTemp);\n                    clonedNodeTemp.detach();\n                } else if (clonedNodeTemp instanceof Document) {\n                    // Document node\n                    final Element clonedNodeTempRootElement = clonedNodeTemp.getDocument().getRootElement();\n\n                    if (clonedNodeTempRootElement == null) {\n                        // Can be null in rare cases of documents without root element\n                        clonedNodesTemp.set(i, null); // we support having a null node further below, so set this to null\n                    } else {\n                        InstanceData.remove(clonedNodeTempRootElement);\n                        // We can never really insert a document into anything at this point, but we assume that this means the root element\n                        clonedNodesTemp.set(i, clonedNodeTempRootElement.detach());\n                    }\n                } else {\n                    // Other nodes\n                    clonedNodeTemp.detach();\n                }\n            }\n            clonedNodes = clonedNodesTemp;\n        }\n\n        // \"6. The target location of each cloned node or nodes is determined\"\n        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target location\n        // depending on their node type.\"\n\n        // Identify the instance that actually changes\n        final XFormsInstance modifiedInstance;\n        // Find actual insertion point and insert\n        final NodeInfo insertLocationNodeInfo;\n        final List<Node> insertedNodes;\n        final String beforeAfterInto;\n        if (isEmptyNodesetBinding) {\n            // Insert INTO a node\n\n            // \"If the Node Set Binding node-set is not specified or empty, the insert location node is the insert\n            // context node.\"\n\n            // \"a. If the Node Set Binding node-set is not specified or empty, the target location depends on the\n            // node type of the cloned node. If the cloned node is an attribute, then the target location is before\n            // the first attribute of the insert location node. If the cloned node is not an attribute, then the\n            // target location is before the first child of the insert location node.\"\n\n            modifiedInstance = containingDocument.getInstanceForNode(insertContextNodeInfo);\n            insertLocationNodeInfo = insertContextNodeInfo;\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertContextNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            insertedNodes = doInsert(insertLocationNode, clonedNodes);\n            beforeAfterInto = \"into\";\n\n            // Normalize text nodes if needed to respect XPath 1.0 constraint\n            {\n                boolean hasTextNode = false;\n                for (Node clonedNode: clonedNodes) {\n                    hasTextNode |= clonedNode != null && clonedNode.getNodeType() == Node.TEXT_NODE;\n                }\n                if (hasTextNode)\n                    Dom4jUtils.normalizeTextNodes(insertLocationNode);\n            }\n        } else {\n            // Insert BEFORE or AFTER a node\n            insertLocationNodeInfo = (NodeInfo) collectionToBeUpdated.get(insertionIndex - 1);\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertLocationNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            modifiedInstance = containingDocument.getInstanceForNode(insertLocationNodeInfo);\n\n            final Document insertLocationNodeDocument = insertLocationNode.getDocument();\n            if (insertLocationNodeDocument != null && insertLocationNodeDocument.getRootElement() == insertLocationNode) {\n\n                // \"c. if insert location node is the root element of an instance, then that instance root element\n                // location is the target location. If there is more than one cloned node to insert, only the\n                // first node that does not cause a conflict is considered.\"\n\n                insertedNodes = doInsert(insertLocationNode.getDocument(), clonedNodes);\n                beforeAfterInto = positionAttribute; // TODO: ideally normalize to \"into document node\"?\n\n                // NOTE: Don't need to normalize text nodes in this case, as no new text node is inserted\n            } else {\n                // \"d. Otherwise, the target location is immediately before or after the insert location\n                // node, based on the position attribute setting or its default.\"\n\n                if (insertLocationNode.getNodeType() == Node.ATTRIBUTE_NODE) {\n                    // Special case for \"next to an attribute\"\n\n                    // NOTE: In XML, attributes are unordered. dom4j handles them as a list so has order, but\n                    // the XForms spec shouldn't rely on attribute order. We could try to keep the order, but it\n                    // is harder as we have to deal with removing duplicate attributes and find a reasonable\n                    // insertion strategy.\n\n                    // TODO: Don't think we should even do this now in XForms 1.1\n                    insertedNodes = doInsert(insertLocationNode.getParent(), clonedNodes);\n\n                } else {\n                    // Other node types\n                    final Element parentNode = insertLocationNode.getParent();\n                    final List<Node> siblingElements = Dom4jUtils.content(parentNode);\n                    final int actualIndex = siblingElements.indexOf(insertLocationNode);\n\n                    // Prepare insertion of new element\n                    final int actualInsertionIndex;\n                    if (\"before\".equals(positionAttribute)) {\n                        actualInsertionIndex = actualIndex;\n                    } else {\n                        // \"after\"\n                        actualInsertionIndex = actualIndex + 1;\n                    }\n\n                    // \"7. The cloned node or nodes are inserted in the order they were cloned at their target\n                    // location depending on their node type.\"\n\n                    boolean hasTextNode = false;\n                    int addIndex = 0;\n                    insertedNodes = new ArrayList<Node>(clonedNodes.size());\n                    for (Node clonedNode: clonedNodes) {\n\n                        if (clonedNode != null) {// NOTE: we allow passing some null nodes so we check on null\n                            if (!(clonedNode instanceof Attribute || clonedNode instanceof Namespace)) {\n                                // Element, text, comment, processing instruction node\n                                siblingElements.add(actualInsertionIndex + addIndex, clonedNode);\n                                insertedNodes.add(clonedNode);\n                                hasTextNode |= clonedNode.getNodeType() == Node.TEXT_NODE;\n                                addIndex++;\n                            } else {\n                                // We never insert attributes or namespace nodes as siblings\n                                if (indentedLogger.isDebugEnabled())\n                                    indentedLogger.logDebug(\"xforms:insert\", \"skipping insertion of node as sibling in element content\",\n                                                    \"type\", clonedNode.getNodeTypeName(),\n                                                    \"node\", clonedNode instanceof Attribute ? Dom4jUtils.attributeToDebugString((Attribute) clonedNode) : clonedNode.toString()\n                                            );\n                            }\n                        }\n                    }\n\n                    // Normalize text nodes if needed to respect XPath 1.0 constraint\n                    if (hasTextNode)\n                        Dom4jUtils.normalizeTextNodes(parentNode);\n                }\n\n                beforeAfterInto = positionAttribute;\n            }\n        }\n\n        // Whether some nodes were inserted\n        final boolean didInsertNodes = insertedNodes != null && insertedNodes.size() > 0;\n\n        // Log stuff\n        if (indentedLogger.isDebugEnabled()) {\n            if (didInsertNodes)\n                indentedLogger.logDebug(\"xforms:insert\", \"inserted nodes\",\n                        \"count\", Integer.toString(insertedNodes.size()), \"instance\",\n                                (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : null);\n            else\n                indentedLogger.logDebug(\"xforms:insert\", \"no node inserted\");\n        }\n\n        // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n        if (didInsertNodes && modifiedInstance != null) {\n            // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n            modifiedInstance.getModel(containingDocument).markStructuralChange(modifiedInstance);\n        }\n\n        // Gather list of modified nodes\n        final List<Item> insertedNodeInfos;\n        if (didInsertNodes && modifiedInstance != null) {\n            // Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n            final DocumentWrapper documentWrapper = (DocumentWrapper) modifiedInstance.getDocumentInfo();\n            insertedNodeInfos = new ArrayList<Item>(insertedNodes.size());\n            for (Object insertedNode : insertedNodes)\n                insertedNodeInfos.add(documentWrapper.wrap(insertedNode));\n        } else {\n            insertedNodeInfos = Collections.EMPTY_LIST;\n        }\n\n        // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n        // XFormsInstance handles index and repeat items updates \n        if (doDispatch && modifiedInstance != null) {\n            modifiedInstance.getXBLContainer(containingDocument).dispatchEvent(\n                    new XFormsInsertEvent(containingDocument, modifiedInstance, insertedNodeInfos, originItems, insertLocationNodeInfo, beforeAfterInto));\n        }\n\n        return insertedNodeInfos;\n    }","id":88039,"modified_method":"public static List doInsert(XFormsContainingDocument containingDocument, IndentedLogger indentedLogger, String positionAttribute,\n                                List collectionToBeUpdated, NodeInfo insertContextNodeInfo, List originItems, int insertionIndex, boolean doClone, boolean doDispatch) {\n\n        final boolean isEmptyNodesetBinding = collectionToBeUpdated == null || collectionToBeUpdated.size() == 0;\n\n        // \"3. The origin node-set is determined.\"\n        // \"5. Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n        final List<Node> sourceNodes;\n        final List<Node> clonedNodes;\n        {\n            final List<Node> clonedNodesTemp;\n            if (originItems == null) {\n                // There are no explicitly specified origin objects, use node from Node Set Binding node-set\n\n                // \"If the origin attribute is not given and the Node Set Binding node-set is empty, then the origin\n                // node-set is the empty node-set. [...] The insert action is terminated with no effect if the\n                // origin node-set is the empty node-set.\"\n\n                if (isEmptyNodesetBinding) {\n                    if (indentedLogger != null && indentedLogger.isDebugEnabled())\n                        indentedLogger.logDebug(\"xforms:insert\", \"origin node-set from node-set binding is empty, terminating\");\n                    return Collections.EMPTY_LIST;\n                }\n\n                // \"Otherwise, if the origin attribute is not given, then the origin node-set consists of the last\n                // node of the Node Set Binding node-set.\"\n                final Node singleSourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1), CANNOT_INSERT_READONLY_MESSAGE);\n                // TODO: check namespace handling might be incorrect. Should use copyElementCopyParentNamespaces() instead?\n                final Node singleClonedNode = Dom4jUtils.createCopy(singleSourceNode);\n\n                sourceNodes = Collections.singletonList(singleSourceNode);\n                clonedNodesTemp = Collections.singletonList(singleClonedNode);\n\n                originItems = null;\n            } else {\n                // There are explicitly specified origin objects\n\n                // \"The insert action is terminated with no effect if the origin node-set is the empty node-set.\"\n                if (originItems.size() == 0) {\n                    if (indentedLogger != null && indentedLogger.isDebugEnabled())\n                        indentedLogger.logDebug(\"xforms:insert\", \"origin node-set is empty, terminating\");\n                    return Collections.EMPTY_LIST;\n                }\n\n                // \"Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n\n                sourceNodes = new ArrayList<Node>(originItems.size()); // set to max possible size\n                clonedNodesTemp = new ArrayList<Node>(originItems.size());\n\n                for (final Object currentObject: originItems) {\n                    if (currentObject instanceof NodeInfo) {\n                        // This is the regular case covered by XForms 1.1 / XPath 1.0\n\n                        // NOTE: Don't clone nodes if doClone == false\n                        final Node sourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) currentObject, CANNOT_INSERT_READONLY_MESSAGE);\n                        final Node clonedNode = doClone ? (sourceNode instanceof Element) ? ((Element) sourceNode).createCopy() : (Node) sourceNode.clone() : sourceNode;\n\n                        sourceNodes.add(sourceNode);\n                        clonedNodesTemp.add(clonedNode);\n\n                    } else {\n                        // This is an extension: support sequences containing other items\n\n                        // Convert the result to a text node\n                        final String stringValue = currentObject.toString(); // we get String, Long, etc.\n                        final Text textNode = Dom4jUtils.createText(stringValue);\n\n                        sourceNodes.add(null); // there is no source node for this cloned node, it's a source item\n                        clonedNodesTemp.add(textNode);\n                    }\n                }\n            }\n\n            // Remove instance data from cloned nodes and perform Document node adjustment\n            for (int i = 0; i < clonedNodesTemp.size(); i++) {\n                final Node clonedNodeTemp = clonedNodesTemp.get(i);\n\n                if (clonedNodeTemp instanceof Element) {\n                    // Element node\n                    InstanceData.remove(clonedNodeTemp);\n                    clonedNodeTemp.detach();\n                } else if (clonedNodeTemp instanceof Attribute) {\n                    // Attribute node\n                    InstanceData.remove(clonedNodeTemp);\n                    clonedNodeTemp.detach();\n                } else if (clonedNodeTemp instanceof Document) {\n                    // Document node\n                    final Element clonedNodeTempRootElement = clonedNodeTemp.getDocument().getRootElement();\n\n                    if (clonedNodeTempRootElement == null) {\n                        // Can be null in rare cases of documents without root element\n                        clonedNodesTemp.set(i, null); // we support having a null node further below, so set this to null\n                    } else {\n                        InstanceData.remove(clonedNodeTempRootElement);\n                        // We can never really insert a document into anything at this point, but we assume that this means the root element\n                        clonedNodesTemp.set(i, clonedNodeTempRootElement.detach());\n                    }\n                } else {\n                    // Other nodes\n                    clonedNodeTemp.detach();\n                }\n            }\n            clonedNodes = clonedNodesTemp;\n        }\n\n        // \"6. The target location of each cloned node or nodes is determined\"\n        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target location\n        // depending on their node type.\"\n\n        // Identify the instance that actually changes\n        final XFormsInstance modifiedInstance;\n        // Find actual insertion point and insert\n        final NodeInfo insertLocationNodeInfo;\n        final List<Node> insertedNodes;\n        final String beforeAfterInto;\n        if (isEmptyNodesetBinding) {\n            // Insert INTO a node\n\n            // \"If the Node Set Binding node-set is not specified or empty, the insert location node is the insert\n            // context node.\"\n\n            // \"a. If the Node Set Binding node-set is not specified or empty, the target location depends on the\n            // node type of the cloned node. If the cloned node is an attribute, then the target location is before\n            // the first attribute of the insert location node. If the cloned node is not an attribute, then the\n            // target location is before the first child of the insert location node.\"\n\n            modifiedInstance = (containingDocument != null) ? containingDocument.getInstanceForNode(insertContextNodeInfo) : null;\n            insertLocationNodeInfo = insertContextNodeInfo;\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertContextNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            insertedNodes = doInsert(insertLocationNode, clonedNodes);\n            beforeAfterInto = \"into\";\n\n            // Normalize text nodes if needed to respect XPath 1.0 constraint\n            {\n                boolean hasTextNode = false;\n                for (Node clonedNode: clonedNodes) {\n                    hasTextNode |= clonedNode != null && clonedNode.getNodeType() == Node.TEXT_NODE;\n                }\n                if (hasTextNode)\n                    Dom4jUtils.normalizeTextNodes(insertLocationNode);\n            }\n        } else {\n            // Insert BEFORE or AFTER a node\n            insertLocationNodeInfo = (NodeInfo) collectionToBeUpdated.get(insertionIndex - 1);\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertLocationNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            modifiedInstance = (containingDocument != null) ? containingDocument.getInstanceForNode(insertLocationNodeInfo) : null;\n\n            final Document insertLocationNodeDocument = insertLocationNode.getDocument();\n            if (insertLocationNodeDocument != null && insertLocationNodeDocument.getRootElement() == insertLocationNode) {\n\n                // \"c. if insert location node is the root element of an instance, then that instance root element\n                // location is the target location. If there is more than one cloned node to insert, only the\n                // first node that does not cause a conflict is considered.\"\n\n                insertedNodes = doInsert(insertLocationNode.getDocument(), clonedNodes);\n                beforeAfterInto = positionAttribute; // TODO: ideally normalize to \"into document node\"?\n\n                // NOTE: Don't need to normalize text nodes in this case, as no new text node is inserted\n            } else {\n                // \"d. Otherwise, the target location is immediately before or after the insert location\n                // node, based on the position attribute setting or its default.\"\n\n                if (insertLocationNode.getNodeType() == Node.ATTRIBUTE_NODE) {\n                    // Special case for \"next to an attribute\"\n\n                    // NOTE: In XML, attributes are unordered. dom4j handles them as a list so has order, but\n                    // the XForms spec shouldn't rely on attribute order. We could try to keep the order, but it\n                    // is harder as we have to deal with removing duplicate attributes and find a reasonable\n                    // insertion strategy.\n\n                    // TODO: Don't think we should even do this now in XForms 1.1\n                    insertedNodes = doInsert(insertLocationNode.getParent(), clonedNodes);\n\n                } else {\n                    // Other node types\n                    final Element parentNode = insertLocationNode.getParent();\n                    final List<Node> siblingElements = Dom4jUtils.content(parentNode);\n                    final int actualIndex = siblingElements.indexOf(insertLocationNode);\n\n                    // Prepare insertion of new element\n                    final int actualInsertionIndex;\n                    if (\"before\".equals(positionAttribute)) {\n                        actualInsertionIndex = actualIndex;\n                    } else {\n                        // \"after\"\n                        actualInsertionIndex = actualIndex + 1;\n                    }\n\n                    // \"7. The cloned node or nodes are inserted in the order they were cloned at their target\n                    // location depending on their node type.\"\n\n                    boolean hasTextNode = false;\n                    int addIndex = 0;\n                    insertedNodes = new ArrayList<Node>(clonedNodes.size());\n                    for (Node clonedNode: clonedNodes) {\n\n                        if (clonedNode != null) {// NOTE: we allow passing some null nodes so we check on null\n                            if (!(clonedNode instanceof Attribute || clonedNode instanceof Namespace)) {\n                                // Element, text, comment, processing instruction node\n                                siblingElements.add(actualInsertionIndex + addIndex, clonedNode);\n                                insertedNodes.add(clonedNode);\n                                hasTextNode |= clonedNode.getNodeType() == Node.TEXT_NODE;\n                                addIndex++;\n                            } else {\n                                // We never insert attributes or namespace nodes as siblings\n                                if (indentedLogger != null && indentedLogger.isDebugEnabled())\n                                    indentedLogger.logDebug(\"xforms:insert\", \"skipping insertion of node as sibling in element content\",\n                                                    \"type\", clonedNode.getNodeTypeName(),\n                                                    \"node\", clonedNode instanceof Attribute ? Dom4jUtils.attributeToDebugString((Attribute) clonedNode) : clonedNode.toString()\n                                            );\n                            }\n                        }\n                    }\n\n                    // Normalize text nodes if needed to respect XPath 1.0 constraint\n                    if (hasTextNode)\n                        Dom4jUtils.normalizeTextNodes(parentNode);\n                }\n\n                beforeAfterInto = positionAttribute;\n            }\n        }\n\n        // Whether some nodes were inserted\n        final boolean didInsertNodes = insertedNodes != null && insertedNodes.size() > 0;\n\n        // Log stuff\n        if (indentedLogger != null && indentedLogger.isDebugEnabled()) {\n            if (didInsertNodes)\n                indentedLogger.logDebug(\"xforms:insert\", \"inserted nodes\",\n                        \"count\", Integer.toString(insertedNodes.size()), \"instance\",\n                                (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : null);\n            else\n                indentedLogger.logDebug(\"xforms:insert\", \"no node inserted\");\n        }\n\n        // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n        if (didInsertNodes && modifiedInstance != null) {\n            // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n            modifiedInstance.getModel(containingDocument).markStructuralChange(modifiedInstance);\n        }\n\n        // Gather list of modified nodes\n        final List<Item> insertedNodeInfos;\n        if (didInsertNodes && modifiedInstance != null) {\n            // Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n            final DocumentWrapper documentWrapper = (DocumentWrapper) modifiedInstance.getDocumentInfo();\n            insertedNodeInfos = new ArrayList<Item>(insertedNodes.size());\n            for (Object insertedNode : insertedNodes)\n                insertedNodeInfos.add(documentWrapper.wrap(insertedNode));\n        } else {\n            insertedNodeInfos = Collections.EMPTY_LIST;\n        }\n\n        // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n        // XFormsInstance handles index and repeat items updates \n        if (doDispatch && modifiedInstance != null) {\n            modifiedInstance.getXBLContainer(containingDocument).dispatchEvent(\n                    new XFormsInsertEvent(containingDocument, modifiedInstance, insertedNodeInfos, originItems, insertLocationNodeInfo, beforeAfterInto));\n        }\n\n        return insertedNodeInfos;\n    }","commit_id":"e728fbd451a40817646083af8ae2f680a459831b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static boolean doSetValue(XFormsContainingDocument containingDocument,\n                                     IndentedLogger indentedLogger, XFormsEventTarget eventTarget, NodeInfo currentNode,\n                                     String valueToSet, String type, String source, boolean isCalculate) {\n\n        assert valueToSet != null;\n\n        final String currentValue = XFormsInstance.getValueForNodeInfo(currentNode);\n        final boolean changed = !currentValue.equals(valueToSet);\n\n        if (indentedLogger.isDebugEnabled()) {\n            final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n            indentedLogger.logDebug(\"xforms:setvalue\", \"setting instance value\", \"source\", source, \"value\", valueToSet,\n                    \"changed\", Boolean.toString(changed),\n                    \"instance\", (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : \"N/A\");\n        }\n\n        // We take the liberty of not requiring RRR and marking the instance dirty if the value hasn't actually changed\n        if (changed) {\n\n            // Actually set the value\n            XFormsInstance.setValueForNodeInfo(containingDocument, eventTarget, currentNode, valueToSet, type);\n\n            final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n            if (modifiedInstance != null) {// can be null if you set a value in a non-instance doc\n\n                // Tell the model about the value change\n                modifiedInstance.getModel(containingDocument).markValueChange(currentNode, isCalculate);\n\n                // Dispatch extension event to instance\n                final XBLContainer modifiedContainer = modifiedInstance.getXBLContainer(containingDocument);\n                modifiedContainer.dispatchEvent(new XXFormsValueChanged(containingDocument, modifiedInstance, currentNode, currentValue, valueToSet));\n            } else {\n                // NOTE: Is this the right thing to do if the value modified is not an instance value? Might not be needed!\n                containingDocument.getControls().markDirtySinceLastRequest(true);\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }","id":88040,"modified_method":"public static boolean doSetValue(XFormsContainingDocument containingDocument,\n                                     IndentedLogger indentedLogger, XFormsEventTarget eventTarget, NodeInfo currentNode,\n                                     String valueToSet, String type, String source, boolean isCalculate) {\n\n        assert valueToSet != null;\n\n        final String currentValue = XFormsInstance.getValueForNodeInfo(currentNode);\n        final boolean changed = !currentValue.equals(valueToSet);\n\n        if (indentedLogger != null && indentedLogger.isDebugEnabled()) {\n            final XFormsInstance modifiedInstance = (containingDocument != null) ? containingDocument.getInstanceForNode(currentNode) : null;\n            indentedLogger.logDebug(\"xforms:setvalue\", \"setting instance value\", \"source\", source, \"value\", valueToSet,\n                    \"changed\", Boolean.toString(changed),\n                    \"instance\", (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : \"N/A\");\n        }\n\n        // We take the liberty of not requiring RRR and marking the instance dirty if the value hasn't actually changed\n        if (changed) {\n\n            // Actually set the value\n            XFormsInstance.setValueForNodeInfo(containingDocument, eventTarget, currentNode, valueToSet, type);\n\n            if (containingDocument != null) {\n                final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n                if (modifiedInstance != null) {// can be null if you set a value in a non-instance doc\n\n                    // Tell the model about the value change\n                    modifiedInstance.getModel(containingDocument).markValueChange(currentNode, isCalculate);\n\n                    // Dispatch extension event to instance\n                    final XBLContainer modifiedContainer = modifiedInstance.getXBLContainer(containingDocument);\n                    modifiedContainer.dispatchEvent(new XXFormsValueChanged(containingDocument, modifiedInstance, currentNode, currentValue, valueToSet));\n                } else {\n                    // NOTE: Is this the right thing to do if the value modified is not an instance value? Might not be needed!\n                    containingDocument.getControls().markDirtySinceLastRequest(true);\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"e728fbd451a40817646083af8ae2f680a459831b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private boolean processRouteSegment(final RoutingContext ctx, boolean reverseWaySearch,\n\t\t\tPriorityQueue<RouteSegment> graphSegments, TLongObjectHashMap<RouteSegment> visitedSegments, int targetEndX, int targetEndY,\n            RouteSegment segment, TLongObjectHashMap<RouteSegment> oppositeSegments) throws IOException {\n\t\t// Always start from segmentStart (!), not from segmentEnd\n\t\t// It makes difference only for the first start segment\n\t\t// Middle point will always be skipped from observation considering already visited\n\t\tfinal RouteDataObject road = segment.road;\n\t\tfinal int middle = segment.segmentStart;\n\t\tint middlex = road.getPoint31XTile(middle);\n\t\tint middley = road.getPoint31YTile(middle);\n\t\tdouble obstaclePlusTime = 0;\n\t\tdouble obstacleMinusTime = 0;\n\n\t\t// 0. mark route segment as visited\n\t\tlong nt = (road.getId() << 8l) + middle;\n\t\t// avoid empty segments to connect but mark the point as visited\n\t\tvisitedSegments.put(nt, null);\n\n\t\tint oneway = ctx.getRouter().isOneWay(road);\n\t\tboolean minusAllowed;\n\t\tboolean plusAllowed; \n\t\tif(ctx.firstRoadId == nt) {\n\t\t\tminusAllowed = ctx.firstRoadDirection <= 0;\n\t\t\tplusAllowed = ctx.firstRoadDirection >= 0;\n\t\t} else if (!reverseWaySearch) {\n\t\t\tminusAllowed = oneway <= 0;\n\t\t\tplusAllowed = oneway >= 0;\n\t\t} else {\n\t\t\tminusAllowed = oneway >= 0;\n\t\t\tplusAllowed = oneway <= 0;\n\t\t}\n\n\t\t// +/- diff from middle point\n\t\tint d = plusAllowed ? 1 : -1;\n\t\tif(segment.parentRoute != null) {\n\t\t\tif(plusAllowed && middle < segment.getRoad().getPointsLength() - 1) {\n\t\t\t\tobstaclePlusTime = ctx.getRouter().calculateTurnTime(segment, segment.getRoad().getPointsLength() - 1,  \n\t\t\t\t\tsegment.parentRoute, segment.parentSegmentEnd);\n\t\t\t}\n\t\t\tif(minusAllowed && middle > 0) {\n\t\t\t\tobstacleMinusTime = ctx.getRouter().calculateTurnTime(segment, 0, \n\t\t\t\t\t\tsegment.parentRoute, segment.parentSegmentEnd);\n\t\t\t}\n\t\t}\n\t\t// Go through all point of the way and find ways to continue\n\t\t// ! Actually there is small bug when there is restriction to move forward on way (it doesn't take into account)\n\t\twhile (minusAllowed || plusAllowed) {\n\t\t\t// 1. calculate point not equal to middle\n\t\t\t// (algorithm should visit all point on way if it is not oneway)\n\t\t\tint segmentEnd = middle + d;\n\t\t\tif (!minusAllowed && d > 0) {\n\t\t\t\td++;\n\t\t\t} else if (!plusAllowed && d < 0) {\n\t\t\t\td--;\n\t\t\t} else {\n\t\t\t\tif (d <= 0) {\n\t\t\t\t\td = -d + 1;\n\t\t\t\t} else {\n\t\t\t\t\td = -d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (segmentEnd < 0) {\n\t\t\t\tminusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (segmentEnd >= road.getPointsLength()) {\n\t\t\t\tplusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if we found end point break cycle\n\t\t\tlong nts = (road.getId() << 8l) + segmentEnd;\n\t\t\tvisitedSegments.put(nts, segment);\n\n\t\t\t// 2. calculate point and try to load neighbor ways if they are not loaded\n\t\t\tint x = road.getPoint31XTile(segmentEnd);\n\t\t\tint y = road.getPoint31YTile(segmentEnd);\n\t\t\tRoutingTile tile = loadRoutes(ctx, x, y);\n\t\t\t\n\t\t\t// 2.1 calculate possible obstacle plus time\n\t\t\tif(d > 0){\n\t\t\t\tobstaclePlusTime +=  ctx.getRouter().defineObstacle(road, segmentEnd);\n\t\t\t} else if(d < 0) {\n\t\t\t\tobstacleMinusTime +=  ctx.getRouter().defineObstacle(road, segmentEnd);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tlong l = (((long) x) << 31) + (long) y;\n\t\t\tRouteSegment next = tile.routes.get(l);\n\t\t\t// 3. get intersected ways\n\t\t\tif (next != null) {\n\t\t\t\t// TO-DO U-Turn\n\t\t\t\tif((next == segment || next.road.id == road.id) && next.next == null) {\n\t\t\t\t\t// simplification if there is no real intersection\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Using A* routing algorithm\n\t\t\t\t// g(x) - calculate distance to that point and calculate time\n\t\t\t\tdouble distOnRoadToPass = squareRootDist(x, y, middlex, middley);\n\t\t\t\tdouble priority = ctx.getRouter().defineSpeedPriority(road);\n\t\t\t\tdouble speed = ctx.getRouter().defineSpeed(road) * priority;\n\t\t\t\tif (speed == 0) {\n\t\t\t\t\tspeed = ctx.getRouter().getMinDefaultSpeed() * priority;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble distStartObstacles = segment.distanceFromStart + ( d > 0? obstaclePlusTime : obstacleMinusTime) +\n\t\t\t\t\t\t distOnRoadToPass / speed;\n\t\t\t\t\n\t\t\t\tdouble distToFinalPoint = squareRootDist(x, y, targetEndX, targetEndY);\n\t\t\t\t\n\t\t\t\tboolean routeFound = processIntersections(ctx, graphSegments, visitedSegments, oppositeSegments,\n\t\t\t\t\t\tdistStartObstacles, distToFinalPoint, segment, segmentEnd, next, reverseWaySearch);\n\t\t\t\tif(routeFound){\n\t\t\t\t\treturn routeFound;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":88041,"modified_method":"private boolean processRouteSegment(final RoutingContext ctx, boolean reverseWaySearch,\n\t\t\tPriorityQueue<RouteSegment> graphSegments, TLongObjectHashMap<RouteSegment> visitedSegments, int targetEndX, int targetEndY,\n            RouteSegment segment, TLongObjectHashMap<RouteSegment> oppositeSegments) throws IOException {\n\t\t// Always start from segmentStart (!), not from segmentEnd\n\t\t// It makes difference only for the first start segment\n\t\t// Middle point will always be skipped from observation considering already visited\n\t\tfinal RouteDataObject road = segment.road;\n\t\tfinal int middle = segment.segmentStart;\n\t\tint middlex = road.getPoint31XTile(middle);\n\t\tint middley = road.getPoint31YTile(middle);\n\t\tdouble obstaclePlusTime = 0;\n\t\tdouble obstacleMinusTime = 0;\n\n\t\t// 0. mark route segment as visited\n\t\tlong nt = (road.getId() << 8l) + middle;\n\t\t// avoid empty segments to connect but mark the point as visited\n\t\tvisitedSegments.put(nt, null);\n\n\t\tint oneway = ctx.getRouter().isOneWay(road);\n\t\tboolean minusAllowed;\n\t\tboolean plusAllowed; \n\t\tif(ctx.firstRoadId == nt) {\n\t\t\tminusAllowed = ctx.firstRoadDirection <= 0;\n\t\t\tplusAllowed = ctx.firstRoadDirection >= 0;\n\t\t} else if (!reverseWaySearch) {\n\t\t\tminusAllowed = oneway <= 0;\n\t\t\tplusAllowed = oneway >= 0;\n\t\t} else {\n\t\t\tminusAllowed = oneway >= 0;\n\t\t\tplusAllowed = oneway <= 0;\n\t\t}\n\n\t\t// +/- diff from middle point\n\t\tint d = plusAllowed ? 1 : -1;\n\t\tif(segment.parentRoute != null) {\n\t\t\tif(plusAllowed && middle < segment.getRoad().getPointsLength() - 1) {\n\t\t\t\tobstaclePlusTime = ctx.getRouter().calculateTurnTime(segment, segment.getRoad().getPointsLength() - 1,  \n\t\t\t\t\tsegment.parentRoute, segment.parentSegmentEnd);\n\t\t\t}\n\t\t\tif(minusAllowed && middle > 0) {\n\t\t\t\tobstacleMinusTime = ctx.getRouter().calculateTurnTime(segment, 0, \n\t\t\t\t\t\tsegment.parentRoute, segment.parentSegmentEnd);\n\t\t\t}\n\t\t}\n\t\t// Go through all point of the way and find ways to continue\n\t\t// ! Actually there is small bug when there is restriction to move forward on way (it doesn't take into account)\n\t\twhile (minusAllowed || plusAllowed) {\n\t\t\t// 1. calculate point not equal to middle\n\t\t\t// (algorithm should visit all point on way if it is not oneway)\n\t\t\tint segmentEnd = middle + d;\n\t\t\tif (!minusAllowed && d > 0) {\n\t\t\t\td++;\n\t\t\t} else if (!plusAllowed && d < 0) {\n\t\t\t\td--;\n\t\t\t} else {\n\t\t\t\tif (d <= 0) {\n\t\t\t\t\td = -d + 1;\n\t\t\t\t} else {\n\t\t\t\t\td = -d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (segmentEnd < 0) {\n\t\t\t\tminusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (segmentEnd >= road.getPointsLength()) {\n\t\t\t\tplusAllowed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if we found end point break cycle\n\t\t\tlong nts = (road.getId() << 8l) + segmentEnd;\n\t\t\tvisitedSegments.put(nts, segment);\n\n\t\t\t// 2. calculate point and try to load neighbor ways if they are not loaded\n\t\t\tint x = road.getPoint31XTile(segmentEnd);\n\t\t\tint y = road.getPoint31YTile(segmentEnd);\n\t\t\tRoutingTile tile = loadRoutes(ctx, x, y);\n\t\t\t\n\t\t\t// 2.1 calculate possible obstacle plus time\n\t\t\tif(segmentEnd > middle){\n\t\t\t\tdouble obstacle = ctx.getRouter().defineObstacle(road, segmentEnd);\n\t\t\t\tif(obstacle < 0){\n\t\t\t\t\tplusAllowed = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobstaclePlusTime +=  obstacle;\n\t\t\t} else if(segmentEnd < middle) {\n\t\t\t\tdouble obstacle = ctx.getRouter().defineObstacle(road, segmentEnd);\n\t\t\t\tif(obstacle < 0){\n\t\t\t\t\tminusAllowed = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobstacleMinusTime +=  obstacle;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tlong l = (((long) x) << 31) + (long) y;\n\t\t\tRouteSegment next = tile.routes.get(l);\n\t\t\t// 3. get intersected ways\n\t\t\tif (next != null) {\n\t\t\t\t// TO-DO U-Turn\n\t\t\t\tif((next == segment || next.road.id == road.id) && next.next == null) {\n\t\t\t\t\t// simplification if there is no real intersection\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Using A* routing algorithm\n\t\t\t\t// g(x) - calculate distance to that point and calculate time\n\t\t\t\tdouble distOnRoadToPass = squareRootDist(x, y, middlex, middley);\n\t\t\t\tdouble priority = ctx.getRouter().defineSpeedPriority(road);\n\t\t\t\tdouble speed = ctx.getRouter().defineSpeed(road) * priority;\n\t\t\t\tif (speed == 0) {\n\t\t\t\t\tspeed = ctx.getRouter().getMinDefaultSpeed() * priority;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble distStartObstacles = segment.distanceFromStart + ( segmentEnd > middle? obstaclePlusTime : obstacleMinusTime) +\n\t\t\t\t\t\t distOnRoadToPass / speed;\n\t\t\t\t\n\t\t\t\tdouble distToFinalPoint = squareRootDist(x, y, targetEndX, targetEndY);\n\t\t\t\t\n\t\t\t\tboolean routeFound = processIntersections(ctx, graphSegments, visitedSegments, oppositeSegments,\n\t\t\t\t\t\tdistStartObstacles, distToFinalPoint, segment, segmentEnd, next, reverseWaySearch);\n\t\t\t\tif(routeFound){\n\t\t\t\t\treturn routeFound;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"0a2199f488095379246ac9c7b88eb4b79df3156d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * Helper method to prepare final result \n\t */\n\tprivate List<RouteSegmentResult> prepareResult(RoutingContext ctx, RouteSegment start, RouteSegment end, boolean leftside) {\n\t\tList<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();\n\n\t\tRouteSegment segment = ctx.finalReverseRoute;\n\t\tint parentSegmentStart = ctx.finalReverseEndSegment;\n\t\twhile (segment != null) {\n\t\t\tRouteSegmentResult res = new RouteSegmentResult(segment.road, parentSegmentStart, segment.segmentStart);\n\t\t\tparentSegmentStart = segment.parentSegmentEnd;\n\t\t\tsegment = segment.parentRoute;\n\t\t\tresult.add(res);\n\t\t}\n\t\tCollections.reverse(result);\n\n\t\tsegment = ctx.finalDirectRoute;\n\t\tint parentSegmentEnd = ctx.finalDirectEndSegment;\n\t\twhile (segment != null) {\n\t\t\tRouteSegmentResult res = new RouteSegmentResult(segment.road, segment.segmentStart, parentSegmentEnd);\n\t\t\tparentSegmentEnd = segment.parentSegmentEnd;\n\t\t\tsegment = segment.parentRoute;\n\t\t\tresult.add(res);\n\t\t}\n\t\tCollections.reverse(result);\n\n\t\t// calculate time\n\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\tRouteSegmentResult rr = result.get(i);\n\t\t\tRouteDataObject road = rr.getObject();\n\t\t\tdouble distOnRoadToPass = 0;\n\t\t\tdouble speed = ctx.getRouter().defineSpeed(road);\n\t\t\tif (speed == 0) {\n\t\t\t\tspeed = ctx.getRouter().getMinDefaultSpeed();\n\t\t\t}\n\t\t\tboolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();\n\t\t\tint next;\n\t\t\tdouble distance = 0;\n\t\t\tfor (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {\n\t\t\t\tnext = plus ? j + 1 : j - 1;\n\t\t\t\tif(j == rr.getStartPointIndex()) {\n\t\t\t\t\tattachRoadSegments(ctx, result, i, j, plus);\n\t\t\t\t}\n\t\t\t\tif(next != rr.getEndPointIndex()) {\n\t\t\t\t\tattachRoadSegments(ctx, result, i, next, plus);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble d = measuredDist(road.getPoint31XTile(j), road.getPoint31YTile(j), road.getPoint31XTile(next),\n\t\t\t\t\t\troad.getPoint31YTile(next));\n\t\t\t\tdistance += d;\n\t\t\t\tdistOnRoadToPass += d / speed + ctx.getRouter().defineObstacle(road, j);\n\t\t\t\t\n\t\t\t\tList<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(next);\n\t\t\t\tif (next != rr.getEndPointIndex() && !rr.getObject().roundabout() && attachedRoutes != null) {\n\t\t\t\t\tfloat before = rr.getBearing(next, !plus);\n\t\t\t\t\tfloat after = rr.getBearing(next, plus);\n\t\t\t\t\tboolean straight = Math.abs(MapUtils.degreesDiff(before + 180, after)) < 70;\n\t\t\t\t\tboolean split = false;\n\t\t\t\t\t// split if needed\n\t\t\t\t\tfor (RouteSegmentResult rs : attachedRoutes) {\n\t\t\t\t\t\tdouble diff = MapUtils.degreesDiff(before + 180, rs.getBearingBegin());\n\t\t\t\t\t\tif (Math.abs(diff) < 50) {\n\t\t\t\t\t\t\tsplit = true;\n\t\t\t\t\t\t} else if (!straight && Math.abs(diff) < 100) {\n\t\t\t\t\t\t\tsplit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (split) {\n\t\t\t\t\t\tint endPointIndex = rr.getEndPointIndex();\n\t\t\t\t\t\tRouteSegmentResult splitted = new RouteSegmentResult(rr.getObject(), next, endPointIndex);\n\t\t\t\t\t\trr.setSegmentTime((float) distOnRoadToPass);\n\t\t\t\t\t\trr.setSegmentSpeed((float) speed);\n\t\t\t\t\t\trr.setDistance((float) distance);\n\t\t\t\t\t\trr.setEndPointIndex(next);\n\n\t\t\t\t\t\tresult.add(i + 1, splitted);\n\t\t\t\t\t\t// switch current segment to the splitted\n\t\t\t\t\t\trr = splitted;\n\t\t\t\t\t\tdistOnRoadToPass = 0;\n\t\t\t\t\t\tdistance = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last point turn time can be added\n\t\t\t// if(i + 1 < result.size()) { distOnRoadToPass += ctx.getRouter().calculateTurnTime(); }\n\t\t\trr.setSegmentTime((float) distOnRoadToPass);\n\t\t\trr.setSegmentSpeed((float) speed);\n\t\t\trr.setDistance((float) distance);\n\n\t\t\t\n\t\t}\n\t\taddTurnInfo(leftside, result);\n\t\tfloat completeTime = 0;\n\t\tfloat completeDistance = 0;\n\t\tfor(RouteSegmentResult r : result) {\n\t\t\tcompleteTime += r.getSegmentTime();\n\t\t\tcompleteDistance += r.getDistance();\n\t\t}\n\n\t\tprintln(\"ROUTE : \");\n\t\tdouble startLat = MapUtils.get31LatitudeY(start.road.getPoint31YTile(start.segmentStart));\n\t\tdouble startLon = MapUtils.get31LongitudeX(start.road.getPoint31XTile(start.segmentStart));\n\t\tdouble endLat = MapUtils.get31LatitudeY(end.road.getPoint31YTile(end.segmentStart));\n\t\tdouble endLon = MapUtils.get31LongitudeX(end.road.getPoint31XTile(end.segmentStart));\n\t\tStringBuilder add = new StringBuilder();\n\t\tadd.append(\"loadedTiles = \\\"\").append(ctx.loadedTiles).append(\"\\\" \");\n\t\tadd.append(\"visitedSegments = \\\"\").append(ctx.visitedSegments).append(\"\\\" \");\n\t\tadd.append(\"complete_distance = \\\"\").append(completeDistance).append(\"\\\" \");\n\t\tprintln(MessageFormat.format(\"<test regions=\\\"\\\" description=\\\"\\\" best_percent=\\\"\\\" vehicle=\\\"{5}\\\" \\n\"\n\t\t\t\t+ \"    start_lat=\\\"{0}\\\" start_lon=\\\"{1}\\\" target_lat=\\\"{2}\\\" target_lon=\\\"{3}\\\" complete_time=\\\"{4}\\\" {6} >\", startLat\n\t\t\t\t+ \"\", startLon + \"\", endLat + \"\", endLon + \"\", completeTime + \"\", ctx.config.routerName, add.toString()));\n\t\tif (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {\n\t\t\tfor (RouteSegmentResult res : result) {\n\t\t\t\tString name = res.getObject().getName();\n\t\t\t\tString ref = res.getObject().getRef();\n\t\t\t\tif (name == null) {\n\t\t\t\t\tname = \"\";\n\t\t\t\t}\n\t\t\t\tif (ref != null) {\n\t\t\t\t\tname += \" (\" + ref + \") \";\n\t\t\t\t}\n\t\t\t\tStringBuilder additional = new StringBuilder();\n\t\t\t\tadditional.append(\"time = \\\"\").append(res.getSegmentTime()).append(\"\\\" \");\n\t\t\t\tadditional.append(\"name = \\\"\").append(name).append(\"\\\" \");\n\t\t\t\tadditional.append(\"distance = \\\"\").append(res.getDistance()).append(\"\\\" \");\n\t\t\t\tif (res.getTurnType() != null) {\n\t\t\t\t\tadditional.append(\"turn = \\\"\").append(res.getTurnType()).append(\"\\\" \");\n\t\t\t\t\tif (res.getTurnType().getLanes() != null) {\n\t\t\t\t\t\tadditional.append(\"lanes = \\\"\").append(Arrays.toString(res.getTurnType().getLanes())).append(\"\\\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadditional.append(\"start_bearing = \\\"\").append(res.getBearingBegin()).append(\"\\\" \");\n\t\t\t\tadditional.append(\"end_bearing = \\\"\").append(res.getBearingEnd()).append(\"\\\" \");\n\t\t\t\tadditional.append(\"description = \\\"\").append(res.getDescription()).append(\"\\\" \");\n\t\t\t\tprintln(MessageFormat.format(\"\\t<segment id=\\\"{0}\\\" start=\\\"{1}\\\" end=\\\"{2}\\\" {3}/>\", (res.getObject().getId()) + \"\",\n\t\t\t\t\t\tres.getStartPointIndex() + \"\", res.getEndPointIndex() + \"\", additional.toString()));\n\t\t\t}\n\t\t}\n\t\tprintln(\"<\/test>\");\n\t\treturn result;\n\t}","id":88042,"modified_method":"/**\n\t * Helper method to prepare final result \n\t */\n\tprivate List<RouteSegmentResult> prepareResult(RoutingContext ctx, RouteSegment start, RouteSegment end, boolean leftside) {\n\t\tList<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();\n\n\t\tRouteSegment segment = ctx.finalReverseRoute;\n\t\tint parentSegmentStart = ctx.finalReverseEndSegment;\n\t\twhile (segment != null) {\n\t\t\tRouteSegmentResult res = new RouteSegmentResult(segment.road, parentSegmentStart, segment.segmentStart);\n\t\t\tparentSegmentStart = segment.parentSegmentEnd;\n\t\t\tsegment = segment.parentRoute;\n\t\t\tresult.add(res);\n\t\t}\n\t\tCollections.reverse(result);\n\n\t\tsegment = ctx.finalDirectRoute;\n\t\tint parentSegmentEnd = ctx.finalDirectEndSegment;\n\t\twhile (segment != null) {\n\t\t\tRouteSegmentResult res = new RouteSegmentResult(segment.road, segment.segmentStart, parentSegmentEnd);\n\t\t\tparentSegmentEnd = segment.parentSegmentEnd;\n\t\t\tsegment = segment.parentRoute;\n\t\t\tresult.add(res);\n\t\t}\n\t\tCollections.reverse(result);\n\n\t\t// calculate time\n\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\tRouteSegmentResult rr = result.get(i);\n\t\t\tRouteDataObject road = rr.getObject();\n\t\t\tdouble distOnRoadToPass = 0;\n\t\t\tdouble speed = ctx.getRouter().defineSpeed(road);\n\t\t\tif (speed == 0) {\n\t\t\t\tspeed = ctx.getRouter().getMinDefaultSpeed();\n\t\t\t}\n\t\t\tboolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();\n\t\t\tint next;\n\t\t\tdouble distance = 0;\n\t\t\tfor (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {\n\t\t\t\tnext = plus ? j + 1 : j - 1;\n\t\t\t\tif(j == rr.getStartPointIndex()) {\n\t\t\t\t\tattachRoadSegments(ctx, result, i, j, plus);\n\t\t\t\t}\n\t\t\t\tif(next != rr.getEndPointIndex()) {\n\t\t\t\t\tattachRoadSegments(ctx, result, i, next, plus);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble d = measuredDist(road.getPoint31XTile(j), road.getPoint31YTile(j), road.getPoint31XTile(next),\n\t\t\t\t\t\troad.getPoint31YTile(next));\n\t\t\t\tdistance += d;\n\t\t\t\tdouble obstacle = ctx.getRouter().defineObstacle(road, j);\n\t\t\t\tif(obstacle >= 0) { \n\t\t\t\t\tdistOnRoadToPass += d / speed + obstacle;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Something completely wrong if we pass obstacle < 0 \" + Arrays.toString(road.getPointTypes(j)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tList<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(next);\n\t\t\t\tif (next != rr.getEndPointIndex() && !rr.getObject().roundabout() && attachedRoutes != null) {\n\t\t\t\t\tfloat before = rr.getBearing(next, !plus);\n\t\t\t\t\tfloat after = rr.getBearing(next, plus);\n\t\t\t\t\tboolean straight = Math.abs(MapUtils.degreesDiff(before + 180, after)) < 70;\n\t\t\t\t\tboolean split = false;\n\t\t\t\t\t// split if needed\n\t\t\t\t\tfor (RouteSegmentResult rs : attachedRoutes) {\n\t\t\t\t\t\tdouble diff = MapUtils.degreesDiff(before + 180, rs.getBearingBegin());\n\t\t\t\t\t\tif (Math.abs(diff) < 50) {\n\t\t\t\t\t\t\tsplit = true;\n\t\t\t\t\t\t} else if (!straight && Math.abs(diff) < 100) {\n\t\t\t\t\t\t\tsplit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (split) {\n\t\t\t\t\t\tint endPointIndex = rr.getEndPointIndex();\n\t\t\t\t\t\tRouteSegmentResult splitted = new RouteSegmentResult(rr.getObject(), next, endPointIndex);\n\t\t\t\t\t\trr.setSegmentTime((float) distOnRoadToPass);\n\t\t\t\t\t\trr.setSegmentSpeed((float) speed);\n\t\t\t\t\t\trr.setDistance((float) distance);\n\t\t\t\t\t\trr.setEndPointIndex(next);\n\n\t\t\t\t\t\tresult.add(i + 1, splitted);\n\t\t\t\t\t\t// switch current segment to the splitted\n\t\t\t\t\t\trr = splitted;\n\t\t\t\t\t\tdistOnRoadToPass = 0;\n\t\t\t\t\t\tdistance = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last point turn time can be added\n\t\t\t// if(i + 1 < result.size()) { distOnRoadToPass += ctx.getRouter().calculateTurnTime(); }\n\t\t\trr.setSegmentTime((float) distOnRoadToPass);\n\t\t\trr.setSegmentSpeed((float) speed);\n\t\t\trr.setDistance((float) distance);\n\n\t\t\t\n\t\t}\n\t\taddTurnInfo(leftside, result);\n\t\tfloat completeTime = 0;\n\t\tfloat completeDistance = 0;\n\t\tfor(RouteSegmentResult r : result) {\n\t\t\tcompleteTime += r.getSegmentTime();\n\t\t\tcompleteDistance += r.getDistance();\n\t\t}\n\n\t\tprintln(\"ROUTE : \");\n\t\tdouble startLat = MapUtils.get31LatitudeY(start.road.getPoint31YTile(start.segmentStart));\n\t\tdouble startLon = MapUtils.get31LongitudeX(start.road.getPoint31XTile(start.segmentStart));\n\t\tdouble endLat = MapUtils.get31LatitudeY(end.road.getPoint31YTile(end.segmentStart));\n\t\tdouble endLon = MapUtils.get31LongitudeX(end.road.getPoint31XTile(end.segmentStart));\n\t\tStringBuilder add = new StringBuilder();\n\t\tadd.append(\"loadedTiles = \\\"\").append(ctx.loadedTiles).append(\"\\\" \");\n\t\tadd.append(\"visitedSegments = \\\"\").append(ctx.visitedSegments).append(\"\\\" \");\n\t\tadd.append(\"complete_distance = \\\"\").append(completeDistance).append(\"\\\" \");\n\t\tprintln(MessageFormat.format(\"<test regions=\\\"\\\" description=\\\"\\\" best_percent=\\\"\\\" vehicle=\\\"{5}\\\" \\n\"\n\t\t\t\t+ \"    start_lat=\\\"{0}\\\" start_lon=\\\"{1}\\\" target_lat=\\\"{2}\\\" target_lon=\\\"{3}\\\" complete_time=\\\"{4}\\\" {6} >\", startLat\n\t\t\t\t+ \"\", startLon + \"\", endLat + \"\", endLon + \"\", completeTime + \"\", ctx.config.routerName, add.toString()));\n\t\tif (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {\n\t\t\tfor (RouteSegmentResult res : result) {\n\t\t\t\tString name = res.getObject().getName();\n\t\t\t\tString ref = res.getObject().getRef();\n\t\t\t\tif (name == null) {\n\t\t\t\t\tname = \"\";\n\t\t\t\t}\n\t\t\t\tif (ref != null) {\n\t\t\t\t\tname += \" (\" + ref + \") \";\n\t\t\t\t}\n\t\t\t\tStringBuilder additional = new StringBuilder();\n\t\t\t\tadditional.append(\"time = \\\"\").append(res.getSegmentTime()).append(\"\\\" \");\n\t\t\t\tadditional.append(\"name = \\\"\").append(name).append(\"\\\" \");\n\t\t\t\tadditional.append(\"distance = \\\"\").append(res.getDistance()).append(\"\\\" \");\n\t\t\t\tif (res.getTurnType() != null) {\n\t\t\t\t\tadditional.append(\"turn = \\\"\").append(res.getTurnType()).append(\"\\\" \");\n\t\t\t\t\tif (res.getTurnType().getLanes() != null) {\n\t\t\t\t\t\tadditional.append(\"lanes = \\\"\").append(Arrays.toString(res.getTurnType().getLanes())).append(\"\\\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadditional.append(\"start_bearing = \\\"\").append(res.getBearingBegin()).append(\"\\\" \");\n\t\t\t\tadditional.append(\"end_bearing = \\\"\").append(res.getBearingEnd()).append(\"\\\" \");\n\t\t\t\tadditional.append(\"description = \\\"\").append(res.getDescription()).append(\"\\\" \");\n\t\t\t\tprintln(MessageFormat.format(\"\\t<segment id=\\\"{0}\\\" start=\\\"{1}\\\" end=\\\"{2}\\\" {3}/>\", (res.getObject().getId()) + \"\",\n\t\t\t\t\t\tres.getStartPointIndex() + \"\", res.getEndPointIndex() + \"\", additional.toString()));\n\t\t\t}\n\t\t}\n\t\tprintln(\"<\/test>\");\n\t\treturn result;\n\t}","commit_id":"0a2199f488095379246ac9c7b88eb4b79df3156d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean acceptLine(RouteDataObject way) {\n\t\tif(!highwaySpeed.containsKey(way.getHighway())) {\n\t\t\treturn false;\n\t\t}\n\t\tint[] s = way.getTypes();\n\t\t\n\t\tfor(int i=0; i<s.length; i++) {\n\t\t\tRouteTypeRule r = way.region.quickGetEncodingRule(s[i]);\n\t\t\tString k = r.getTag() + \"$\" + r.getValue();\n\t\t\tif(avoidElements.containsKey(k)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":88043,"modified_method":"@Override\n\tpublic boolean acceptLine(RouteDataObject way) {\n\t\tif(!highwaySpeed.containsKey(way.getHighway())) {\n\t\t\treturn false;\n\t\t}\n\t\tint[] s = way.getTypes();\n\t\t\n\t\tfor(int i=0; i<s.length; i++) {\n\t\t\tRouteTypeRule r = way.region.quickGetEncodingRule(s[i]);\n\t\t\tString k = r.getTag() + \"$\" + r.getValue();\n\t\t\tif(avoid.containsKey(k)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"0a2199f488095379246ac9c7b88eb4b79df3156d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic double defineSpeed(RouteDataObject road) {\n\t\tif (followSpeedLimitations) {\n\t\t\tfloat m = road.getMaximumSpeed();\n\t\t\tif(m > 0) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\n\t\tDouble value = highwaySpeed.get(road.getHighway());\n\t\tif (value == null) {\n\t\t\tvalue = minDefaultSpeed;\n\t\t}\n\t\treturn value / 3.6d;\n\t}","id":88044,"modified_method":"@Override\n\tpublic double defineSpeed(RouteDataObject road) {\n\t\tif (followSpeedLimitations) {\n\t\t\tfloat m = road.getMaximumSpeed();\n\t\t\tif(m > 0) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDouble value = null;\n\t\tfor (int i = 0; i < road.types.length; i++) {\n\t\t\tRouteTypeRule r = road.region.quickGetEncodingRule(road.types[i]);\n\t\t\tString highway = r.highwayRoad();\n\t\t\tif (highway != null && highwaySpeed.containsKey(highway)) {\n\t\t\t\tvalue = highwaySpeed.get(highway);\n\t\t\t\tbreak;\n\t\t\t} else if(highwaySpeed.containsKey(r.getTag()+\"$\"+r.getValue())){\n\t\t\t\tvalue = highwaySpeed.get(r.getTag()+\"$\"+r.getValue());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == null) {\n\t\t\tvalue = minDefaultSpeed;\n\t\t}\n\t\treturn value / 3.6d;\n\t}","commit_id":"0a2199f488095379246ac9c7b88eb4b79df3156d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic double defineSpeedPriority(RouteDataObject road) {\n\t\tString highway = road.getHighway();\n\t\tdouble priority = highway != null && highwayPriorities.containsKey(highway) ? highwayPriorities.get(highway) : 1d;\n\t\treturn priority;\n\t}","id":88045,"modified_method":"@Override\n\tpublic double defineSpeedPriority(RouteDataObject road) {\n\t\tdouble priority = 1;\n\t\tfor (int i = 0; i < road.types.length; i++) {\n\t\t\tRouteTypeRule r = road.region.quickGetEncodingRule(road.types[i]);\n\t\t\tString highway = r.highwayRoad();\n\t\t\tif (highway != null && highwayPriorities.containsKey(highway)) {\n\t\t\t\tpriority *= highwayPriorities.get(highway);\n\t\t\t} else if(highwayPriorities.containsKey(r.getTag()+\"$\"+r.getValue())){\n\t\t\t\tpriority *= highwayPriorities.get(r.getTag()+\"$\"+r.getValue());\n\t\t\t}\n\t\t}\n\t\treturn priority;\n\t}","commit_id":"0a2199f488095379246ac9c7b88eb4b79df3156d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static RoutingConfiguration.Builder parseFromInputStream(InputStream is) throws SAXException, IOException {\n\t\ttry {\n\t\t\tfinal SAXParser parser = SAXParserFactory.newInstance().newSAXParser();\n\t\t\tfinal RoutingConfiguration.Builder config = new RoutingConfiguration.Builder();\n\t\t\tDefaultHandler handler = new DefaultHandler() {\n\t\t\t\tString currentSelectedRouter = null;\n\t\t\t\tGeneralRouter currentRouter = null;\n\t\t\t\t@Override\n\t\t\t\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n\t\t\t\t\tString name = parser.isNamespaceAware() ? localName : qName;\n\t\t\t\t\tif(\"osmand_routing_config\".equals(name)) {\n\t\t\t\t\t\tconfig.defaultRouter = attributes.getValue(\"defaultProfile\");\n\t\t\t\t\t} else if(\"attribute\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"name\");\n\t\t\t\t\t\tif(currentSelectedRouter != null) {\n\t\t\t\t\t\t\tkey = currentSelectedRouter +\"$\"+key;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconfig.attributes.put(key, attributes.getValue(\"value\"));\n\t\t\t\t\t} else if(\"routingProfile\".equals(name)) {\n\t\t\t\t\t\tcurrentSelectedRouter = attributes.getValue(\"name\");\n\t\t\t\t\t\tcurrentRouter = new GeneralRouter();\n\t\t\t\t\t\tcurrentRouter.profile = GeneralRouterProfile.valueOf(attributes.getValue(\"baseProfile\").toUpperCase());\n\t\t\t\t\t\tconfig.routers.put(currentSelectedRouter, currentRouter);\n\t\t\t\t\t\tcurrentRouter.restrictionsAware = parseSilentBoolean(attributes.getValue(\"restrictionsAware\"), \n\t\t\t\t\t\t\t\tcurrentRouter.restrictionsAware);\n\t\t\t\t\t\tcurrentRouter.followSpeedLimitations = parseSilentBoolean(attributes.getValue(\"followSpeedLimitations\"), \n\t\t\t\t\t\t\t\tcurrentRouter.followSpeedLimitations);\n\t\t\t\t\t\tcurrentRouter.onewayAware = parseSilentBoolean(attributes.getValue(\"onewayAware\"), \n\t\t\t\t\t\t\t\tcurrentRouter.onewayAware);\n\t\t\t\t\t\tcurrentRouter.minDefaultSpeed = parseSilentDouble(attributes.getValue(\"minDefaultSpeed\"), \n\t\t\t\t\t\t\t\tcurrentRouter.minDefaultSpeed);\n\t\t\t\t\t\tcurrentRouter.maxDefaultSpeed = parseSilentDouble(attributes.getValue(\"maxDefaultSpeed\"), \n\t\t\t\t\t\t\t\tcurrentRouter.maxDefaultSpeed);\n\t\t\t\t\t\tcurrentRouter.leftTurn = parseSilentDouble(attributes.getValue(\"leftTurn\"), \n\t\t\t\t\t\t\t\tcurrentRouter.leftTurn);\n\t\t\t\t\t\tcurrentRouter.rightTurn = parseSilentDouble(attributes.getValue(\"rightTurn\"), \n\t\t\t\t\t\t\t\tcurrentRouter.rightTurn);\n\t\t\t\t\t} else if(\"highway\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"value\");\n\t\t\t\t\t\tcurrentRouter.highwayPriorities.put(key, parseSilentDouble(attributes.getValue(\"priority\"), \n\t\t\t\t\t\t\t\t1));\n\t\t\t\t\t\tcurrentRouter.highwayFuturePriorities.put(key, parseSilentDouble(attributes.getValue(\"dynamicPriority\"), \n\t\t\t\t\t\t\t\t1));\n\t\t\t\t\t\tcurrentRouter.highwaySpeed.put(key, parseSilentDouble(attributes.getValue(\"speed\"), \n\t\t\t\t\t\t\t\tcurrentRouter.minDefaultSpeed));\n\t\t\t\t\t} else if(\"obstacle\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"tag\") + \"$\" + attributes.getValue(\"value\");\n\t\t\t\t\t\tcurrentRouter.obstacles.put(key, parseSilentDouble(attributes.getValue(\"penalty\"), \n\t\t\t\t\t\t\t\t0));\n\t\t\t\t\t} else if(\"avoid\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"tag\") + \"$\" + attributes.getValue(\"value\");\n\t\t\t\t\t\tcurrentRouter.avoidElements.put(key, parseSilentDouble(attributes.getValue(\"coefficient\"), \n\t\t\t\t\t\t\t\t0));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tparser.parse(is, handler);\n\t\t\treturn config;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new SAXException(e);\n\t\t}\n\t}","id":88046,"modified_method":"public static RoutingConfiguration.Builder parseFromInputStream(InputStream is) throws SAXException, IOException {\n\t\ttry {\n\t\t\tfinal SAXParser parser = SAXParserFactory.newInstance().newSAXParser();\n\t\t\tfinal RoutingConfiguration.Builder config = new RoutingConfiguration.Builder();\n\t\t\tDefaultHandler handler = new DefaultHandler() {\n\t\t\t\tString currentSelectedRouter = null;\n\t\t\t\tGeneralRouter currentRouter = null;\n\t\t\t\t@Override\n\t\t\t\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n\t\t\t\t\tString name = parser.isNamespaceAware() ? localName : qName;\n\t\t\t\t\tif(\"osmand_routing_config\".equals(name)) {\n\t\t\t\t\t\tconfig.defaultRouter = attributes.getValue(\"defaultProfile\");\n\t\t\t\t\t} else if(\"attribute\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"name\");\n\t\t\t\t\t\tif(currentSelectedRouter != null) {\n\t\t\t\t\t\t\tkey = currentSelectedRouter +\"$\"+key;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconfig.attributes.put(key, attributes.getValue(\"value\"));\n\t\t\t\t\t} else if(\"routingProfile\".equals(name)) {\n\t\t\t\t\t\tcurrentSelectedRouter = attributes.getValue(\"name\");\n\t\t\t\t\t\tcurrentRouter = new GeneralRouter();\n\t\t\t\t\t\tcurrentRouter.profile = GeneralRouterProfile.valueOf(attributes.getValue(\"baseProfile\").toUpperCase());\n\t\t\t\t\t\tconfig.routers.put(currentSelectedRouter, currentRouter);\n\t\t\t\t\t\tcurrentRouter.restrictionsAware = parseSilentBoolean(attributes.getValue(\"restrictionsAware\"), \n\t\t\t\t\t\t\t\tcurrentRouter.restrictionsAware);\n\t\t\t\t\t\tcurrentRouter.followSpeedLimitations = parseSilentBoolean(attributes.getValue(\"followSpeedLimitations\"), \n\t\t\t\t\t\t\t\tcurrentRouter.followSpeedLimitations);\n\t\t\t\t\t\tcurrentRouter.onewayAware = parseSilentBoolean(attributes.getValue(\"onewayAware\"), \n\t\t\t\t\t\t\t\tcurrentRouter.onewayAware);\n\t\t\t\t\t\tcurrentRouter.minDefaultSpeed = parseSilentDouble(attributes.getValue(\"minDefaultSpeed\"), \n\t\t\t\t\t\t\t\tcurrentRouter.minDefaultSpeed);\n\t\t\t\t\t\tcurrentRouter.maxDefaultSpeed = parseSilentDouble(attributes.getValue(\"maxDefaultSpeed\"), \n\t\t\t\t\t\t\t\tcurrentRouter.maxDefaultSpeed);\n\t\t\t\t\t\tcurrentRouter.leftTurn = parseSilentDouble(attributes.getValue(\"leftTurn\"), \n\t\t\t\t\t\t\t\tcurrentRouter.leftTurn);\n\t\t\t\t\t\tcurrentRouter.rightTurn = parseSilentDouble(attributes.getValue(\"rightTurn\"), \n\t\t\t\t\t\t\t\tcurrentRouter.rightTurn);\n\t\t\t\t\t} else if(\"highway\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"value\");\n\t\t\t\t\t\tcurrentRouter.highwayPriorities.put(key, parseSilentDouble(attributes.getValue(\"priority\"), \n\t\t\t\t\t\t\t\t1));\n\t\t\t\t\t\tcurrentRouter.highwayFuturePriorities.put(key, parseSilentDouble(attributes.getValue(\"dynamicPriority\"), \n\t\t\t\t\t\t\t\t1));\n\t\t\t\t\t\tcurrentRouter.highwaySpeed.put(key, parseSilentDouble(attributes.getValue(\"speed\"), \n\t\t\t\t\t\t\t\tcurrentRouter.minDefaultSpeed));\n\t\t\t\t\t} else if(\"obstacle\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"tag\") + \"$\" + attributes.getValue(\"value\");\n\t\t\t\t\t\tcurrentRouter.obstacles.put(key, parseSilentDouble(attributes.getValue(\"penalty\"), \n\t\t\t\t\t\t\t\t0));\n\t\t\t\t\t} else if(\"avoid\".equals(name)) {\n\t\t\t\t\t\tString key = attributes.getValue(\"tag\") + \"$\" + attributes.getValue(\"value\");\n\t\t\t\t\t\tdouble priority = parseSilentDouble(attributes.getValue(\"decreasedPriority\"), \n\t\t\t\t\t\t\t\t0);\n\t\t\t\t\t\tif(priority == 0) {\n\t\t\t\t\t\t\tcurrentRouter.avoid.put(key, priority);\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\tcurrentRouter.highwayPriorities.put(key, priority);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tparser.parse(is, handler);\n\t\t\treturn config;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new SAXException(e);\n\t\t}\n\t}","commit_id":"0a2199f488095379246ac9c7b88eb4b79df3156d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n   * Get tracked branch for the current branch\n   *\n   * @param project the project\n   * @param root    the vcs root\n   * @return the tracked branch\n   * @throws VcsException if there is a problem with accessing configuration file\n   */\n  @Nullable\n  public GitBranch tracked(Project project, VirtualFile root) throws VcsException {\n    final HashMap<String, String> result = new HashMap<String, String>();\n    GitConfigUtil.getValues(project, root, null, result);\n    String remote = result.get(trackedRemoteKey());\n    if (remote == null) {\n      return null;\n    }\n    String branch = result.get(trackedBranchKey());\n    if (branch == null) {\n      return null;\n    }\n    if (branch.startsWith(REFS_HEADS_PREFIX)) {\n      branch = branch.substring(REFS_HEADS_PREFIX.length());\n    }\n    boolean remoteFlag;\n    if (!\".\".equals(remote)) {\n      branch = remote + \"/\" + branch;\n      remoteFlag = true;\n    }\n    else {\n      remoteFlag = false;\n    }\n    return new GitBranch(branch, false, remoteFlag);\n  }","id":88047,"modified_method":"/**\n   * Get tracked branch for the current branch\n   *\n   * @param project the project\n   * @param root    the vcs root\n   * @return the tracked branch\n   * @throws VcsException if there is a problem with accessing configuration file\n   */\n  @Nullable\n  public GitBranch tracked(Project project, VirtualFile root) throws VcsException {\n    final HashMap<String, String> result = new HashMap<String, String>();\n    GitConfigUtil.getValues(project, root, null, result);\n    String remote = result.get(trackedRemoteKey());\n    if (remote == null) {\n      return null;\n    }\n    String branch = result.get(trackedBranchKey());\n    if (branch == null) {\n      return null;\n    }\n    if (branch.startsWith(REFS_HEADS_PREFIX)) {\n      branch = branch.substring(REFS_HEADS_PREFIX.length());\n    }\n    else if (branch.startsWith(REFS_REMOTES_PREFIX)) {\n      branch = branch.substring(REFS_REMOTES_PREFIX.length());\n    }\n    boolean remoteFlag;\n    if (!\".\".equals(remote)) {\n      branch = remote + \"/\" + branch;\n      remoteFlag = true;\n    }\n    else {\n      remoteFlag = false;\n    }\n    return new GitBranch(branch, false, remoteFlag);\n  }","commit_id":"384c4d2e5d5cf346c45316e154c97bb6263ea0f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static GitBranchTrackInfo convertBranchConfig(@Nullable BranchConfig branchConfig, @NotNull Collection<GitRemote> remotes) {\n    if (branchConfig == null) {\n      return null;\n    }\n    String branchName = branchConfig.getName();\n    String remoteName = branchConfig.getBean().getRemote();\n    String mergeName = branchConfig.getBean().getMerge();\n    String rebaseName = branchConfig.getBean().getRebase();\n\n    if (StringUtil.isEmptyOrSpaces(mergeName) && StringUtil.isEmptyOrSpaces(rebaseName)) {\n      LOG.info(\"No branch.\" + branchName + \".merge/rebase item in the .git/config\");\n      return null;\n    }\n    if (StringUtil.isEmptyOrSpaces(remoteName)) {\n      LOG.info(\"No branch.\" + branchName + \".remote item in the .git/config\");\n      return null;\n    }\n    boolean merge = mergeName != null;\n    final String remoteBranch = (merge ? mergeName : rebaseName);\n\n    GitRemote branchRemote = null;\n    for (GitRemote remote : remotes) {\n      if (remote.getName().equals(remoteName)) {\n        branchRemote = remote;\n        break;\n      }\n    }\n    if (branchRemote == null) {\n      LOG.info(\"No remote found with name \" + remoteName);\n      return null;\n    }\n\n    assert remoteBranch != null; // this is checked in StringUtil.isEmptyOrSpaces\n    return new GitBranchTrackInfo(branchName, branchRemote, remoteBranch, merge);\n  }","id":88048,"modified_method":"@Nullable\n  private static GitBranchTrackInfo convertBranchConfig(@Nullable BranchConfig branchConfig, @NotNull Collection<GitRemote> remotes) {\n    if (branchConfig == null) {\n      return null;\n    }\n    String branchName = branchConfig.getName();\n    String remoteName = branchConfig.getBean().getRemote();\n    String mergeName = branchConfig.getBean().getMerge();\n    String rebaseName = branchConfig.getBean().getRebase();\n\n    if (StringUtil.isEmptyOrSpaces(mergeName) && StringUtil.isEmptyOrSpaces(rebaseName)) {\n      LOG.info(\"No branch.\" + branchName + \".merge/rebase item in the .git/config\");\n      return null;\n    }\n    if (StringUtil.isEmptyOrSpaces(remoteName)) {\n      LOG.info(\"No branch.\" + branchName + \".remote item in the .git/config\");\n      return null;\n    }\n    boolean merge = mergeName != null;\n    final String remoteBranch = (merge ? mergeName : rebaseName);\n\n    GitRemote branchRemote = null;\n    if (DOT_REMOTE.equals(remoteName)) {\n      branchRemote = GitRemote.DOT;\n    }\n    else {\n      for (GitRemote remote : remotes) {\n        if (remote.getName().equals(remoteName)) {\n          branchRemote = remote;\n          break;\n        }\n      }\n      if (branchRemote == null) {\n        LOG.info(\"No remote found with name \" + remoteName);\n        return null;\n      }\n    }\n    assert remoteBranch != null; // this is checked in StringUtil.isEmptyOrSpaces\n    return new GitBranchTrackInfo(branchName, branchRemote, remoteBranch, merge);\n  }","commit_id":"384c4d2e5d5cf346c45316e154c97bb6263ea0f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Collection<GitRemote> parseRemotes(Ini ini, ClassLoader classLoader) {\n    Collection<Remote> remotes = new ArrayList<Remote>();\n    Collection<Url> urls = new ArrayList<Url>();\n    for (Map.Entry<String, Profile.Section> stringSectionEntry : ini.entrySet()) {\n      String sectionName = stringSectionEntry.getKey();\n      Profile.Section section = stringSectionEntry.getValue();\n\n      if (sectionName.startsWith(\"remote\")) {\n        Remote remote = parseRemoteSection(sectionName, section, classLoader);\n        if (remote != null) {\n          remotes.add(remote);\n        }\n      }\n      else if (sectionName.startsWith(\"url\")) {\n        Url url = parseUrlSection(sectionName, section, classLoader);\n        if (url != null) {\n          urls.add(url);\n        }\n      }\n    }\n\n    return makeGitRemotes(remotes, urls);\n  }","id":88049,"modified_method":"private static Collection<GitRemote> parseRemotes(Ini ini, ClassLoader classLoader) {\n    Collection<Remote> remotes = new ArrayList<Remote>();\n    Collection<Url> urls = new ArrayList<Url>();\n    for (Map.Entry<String, Profile.Section> stringSectionEntry : ini.entrySet()) {\n      String sectionName = stringSectionEntry.getKey();\n      Profile.Section section = stringSectionEntry.getValue();\n\n      if (sectionName.startsWith(\"remote\") || sectionName.startsWith(\"svn-remote\")) {\n        Remote remote = parseRemoteSection(sectionName, section, classLoader);\n        if (remote != null) {\n          remotes.add(remote);\n        }\n      }\n      else if (sectionName.startsWith(\"url\")) {\n        Url url = parseUrlSection(sectionName, section, classLoader);\n        if (url != null) {\n          urls.add(url);\n        }\n      }\n    }\n\n    return makeGitRemotes(remotes, urls);\n  }","commit_id":"384c4d2e5d5cf346c45316e154c97bb6263ea0f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GitRemote getRemote(String remoteString) {\n    String[] remoteInfo = remoteString.split(\" \");\n    return new GitRemote(getOrEmpty(remoteInfo, 0), Collections.singletonList(getOrEmpty(remoteInfo, 1)),\n                         Collections.singletonList(getOrEmpty(remoteInfo, 2)), Collections.singletonList(getOrEmpty(remoteInfo, 3)),\n                         Collections.singletonList(getOrEmpty(remoteInfo, 4)));\n  }","id":88050,"modified_method":"private static GitRemote getRemote(String remoteString) {\n    String[] remoteInfo = remoteString.split(\" \");\n    return new GitRemote(remoteInfo[0], getSingletonOrEmpty(remoteInfo, 1), getSingletonOrEmpty(remoteInfo, 2),\n                         getSingletonOrEmpty(remoteInfo, 3), getSingletonOrEmpty(remoteInfo, 4));\n  }","commit_id":"384c4d2e5d5cf346c45316e154c97bb6263ea0f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getOrEmpty(String[] array, int i) {\n    return array.length < i + 1 ? \"\" : array[i];\n  }","id":88051,"modified_method":"private static List<String> getSingletonOrEmpty(String[] array, int i) {\n    return array.length < i + 1 ? Collections.<String>emptyList() : Collections.singletonList(array[i]);\n  }","commit_id":"384c4d2e5d5cf346c45316e154c97bb6263ea0f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(64).append(super.getOuterAttrs());\n\t\tHTMLs.appendAttribute(sb, \"zk_fmt\", getFormat());\n\t\tif (!_lenient) sb.append(\" zk_lenient=\\\"false\\\"\");\n\t\tif (_compact) sb.append(\" zk_compact=\\\"true\\\"\");\n\t\treturn sb.toString();\n\t}","id":88052,"modified_method":"public String getOuterAttrs() {\n\t\tfinal String attrs = super.getOuterAttrs();\n\t\tif (_lenient && !_compact) return attrs;\n\n\t\tfinal StringBuffer sb = new StringBuffer(80).append(attrs);\n\t\tif (!_lenient) sb.append(\" zk_lenient=\\\"false\\\"\");\n\t\tif (_compact) sb.append(\" zk_compact=\\\"true\\\"\");\n\t\treturn sb.toString();\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the value (in Date).\n\t * @exception WrongValueException if value is wrong\n\t */\n\tpublic void setValue(Date value) throws WrongValueException {\n\t\tvalidate(value);\n\t\tif (setRawValue(value))\n\t\t\tsmartUpdate(\"value\", getText());\n\t}","id":88053,"modified_method":"/** Sets the value (in Date).\n\t * @exception WrongValueException if value is wrong\n\t */\n\tpublic void setValue(Date value) throws WrongValueException {\n\t\tvalidate(value);\n\t\tsetRawValue(value);\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"public void setFormat(String format) throws WrongValueException {\n\t\tif (format == null || format.length() == 0)\n\t\t\tformat = getDefaultFormat();\n\n\t\tif (!Objects.equals(getFormat(), format)) {\n\t\t\tsuper.setFormat(format);\n\t\t\tsmartUpdate(\"zk_fmt\", getFormat());\n\t\t}\n\t}","id":88054,"modified_method":"public void setFormat(String format) throws WrongValueException {\n\t\tif (format == null || format.length() == 0)\n\t\t\tformat = getDefaultFormat();\n\t\tsuper.setFormat(format);\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the value (in BigDecimal).\n\t * @exception WrongValueException if value is wrong\n\t */\n\tpublic void setValue(BigDecimal value) throws WrongValueException {\n\t\tvalidate(value);\n\t\tif (setRawValue(value))\n\t\t\tsmartUpdate(\"value\", getText());\n\t}","id":88055,"modified_method":"/** Sets the value (in BigDecimal).\n\t * @exception WrongValueException if value is wrong\n\t */\n\tpublic void setValue(BigDecimal value) throws WrongValueException {\n\t\tvalidate(value);\n\t\tsetRawValue(value);\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Filters out non digit characters, such comma and whitespace,\n\t * from the specified value.\n\t * It is used to parse a string to numeric data.\n\t * @see #formatNumber\n\t */\n\tprotected String toNumberOnly(String val) {\n\t\tif (val == null) return val;\n\n\t\tStringBuffer sb = null;\n\t\tfor (int j = 0, len = val.length(); j < len; ++j) {\n\t\t\tfinal char cc = val.charAt(j);\n\t\t\tif ((cc >= '0' && cc <= '9') || cc == '.'\n\t\t\t|| cc == '-' || cc == '+'){\n\t\t\t\tif (sb != null) sb.append(cc);\n\t\t\t} else {\n\t\t\t\tif (sb == null)\n\t\t\t\t\tsb = new StringBuffer(len).append(val.substring(0, j));\n\t\t\t}\n\t\t}\n\t\treturn sb != null ? sb.toString(): val;\n\t}","id":88056,"modified_method":"/** Filters out non digit characters, such comma and whitespace,\n\t * from the specified value.\n\t * It is used to parse a string to numeric data.\n\t * @see #formatNumber\n\t */\n\tprotected String toNumberOnly(String val) {\n\t\tif (val == null) return val;\n\n\t\tfinal String fmt = getFormat();\n\t\tStringBuffer sb = null;\n\t\tfor (int j = 0, len = val.length(); j < len; ++j) {\n\t\t\tfinal char cc = val.charAt(j);\n\n\t\t\t//We don't add if cc shall be ignored (not alphanum but in fmt)\n\t\t\tfinal boolean ignore = (cc < '0' || cc > '9')\n\t\t\t\t&& cc != '.' && cc != '-' && cc != '+' && cc != '%'\n\t\t\t\t&& (Character.isWhitespace(cc) || cc == ','\n\t\t\t\t\t|| (fmt != null && fmt.indexOf(cc) >= 0));\n\t\t\tif (ignore) {\n\t\t\t\tif (sb == null)\n\t\t\t\t\tsb = new StringBuffer(len).append(val.substring(0, j));\n\t\t\t} else {\n\t\t\t\tif (sb != null) sb.append(cc);\n\t\t\t}\n\t\t}\n\t\treturn sb != null ? sb.toString(): val;\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the format.\n\t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (!Objects.equals(_format, format)) {\n\t\t\tfinal String old = _format;\n\t\t\t_format = format;\n\t\t\ttry {\n\t\t\t\tsmartUpdate(\"value\", getText());\n\t\t\t\t//Yes, the value attribute is changed! (no format attr in client)\n\t\t\t} catch (WrongValueException ex) {\n\t\t\t\t//ignore it (safe because it will keep throwing exception)\n\t\t\t}\n\t\t}\n\t}","id":88057,"modified_method":"/** Sets the format.\n\t */\n\tpublic void setFormat(String format) throws WrongValueException {\n\t\tif (!Objects.equals(_format, format)) {\n\t\t\tfinal String old = _format;\n\t\t\t_format = format;\n\t\t\tsmartUpdate(\"zk_fmt\", getFormat());\n\n\t\t\ttry {\n\t\t\t\tsmartUpdate(\"value\", getText());\n\t\t\t\t//Yes, the value attribute is changed! (no format attr in client)\n\t\t\t} catch (WrongValueException ex) {\n\t\t\t\t//ignore it (safe because it will keep throwing exception)\n\t\t\t}\n\t\t}\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the row value directly. The caller must make sure the value\n\t * is correct, because there is no validation here.\n\t *\n\t * <p>If you feel confusing with setValue, such as {@link com.potix.zul.html.Textbox#setValue},\n\t * it is usually better to use setValue instead. After all, this method\n\t * doesn't do any validation.\n\t *\n\t * <p>In other words, it is possible to set an illegal value for\n\t * the input component, which might not be easy to debug.\n\t *\n\t * @return whether the new value differs from the previous one.\n\t */\n\tpublic boolean setRawValue(Object value) {\n\t\t_errmsg = null;\n\t\tif (!Objects.equals(_value, value)) {\n\t\t\t_value = value;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":88058,"modified_method":"/** Sets the row value directly. The caller must make sure the value\n\t * is correct (or intend to be incorrect), because this method\n\t * doesn't do any validation.\n\t *\n\t * <p>If you feel confusing with setValue, such as {@link com.potix.zul.html.Textbox#setValue},\n\t * it is usually better to use setValue instead. This method\n\t * is reserved for developer that really want to set an 'illegal'\n\t * value (such as an empty string to a textbox with no-empty contraint).\n\t *\n\t * <p>Like setValue, the result is returned back to the server\n\t * by calling {@link #getText}\n\t */\n\tpublic void setRawValue(Object value) {\n\t\t_errmsg = null;\n\t\tif (!Objects.equals(_value, value)) {\n\t\t\t_value = value;\n\t\t\tsmartUpdate(\"value\", coerceToString(_value));\n\t\t}\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the value in String.\n\t *\n\t * <p>It invokes {@link #checkUserError} to ensure no user error.\n\t *\n\t * <p>It invokes {@link #coerceToString} to convert the stored value\n\t * into a string.\n\t * @exception WrongValueException if user entered a wrong value\n\t */\n\tprotected String getText() throws WrongValueException {\n\t\tcheckUserError();\n\t\treturn getTextNCUE();\n\t}","id":88059,"modified_method":"/** Returns the value in String.\n\t *\n\t * <p>It invokes {@link #checkUserError} to ensure no user error.\n\t *\n\t * <p>It invokes {@link #coerceToString} to convert the stored value\n\t * into a string.\n\t *\n\t * <p>It cannot be overriden. Rather, override {@link #checkUserError}\n\t * or {@link #coerceToString}.\n\t *\n\t * @exception WrongValueException if user entered a wrong value\n\t */\n\tprotected final String getText() throws WrongValueException {\n\t\tcheckUserError();\n\t\treturn coerceToString(_value);\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the value.\n\t *\n\t * <p>It invokes {@link #coerceFromString} fisrt and then {@link #validate}.\n\t * Derives might override them for type conversion and special\n\t * validation.\n\t *\n\t * @param value the value; If null, it is considered as empty.\n\t */\n\tprotected void setText(String value) throws WrongValueException {\n\t\tObject val;\n\t\ttry {\n\t\t\tval = coerceFromString(value);\n\t\t\tvalidate(val);\n\t\t} catch (WrongValueException ex) {\n\t\t\tsmartUpdate(\"defaultValue\", \"zk_wrong!~-.zk_pha!6\");\n\t\t\t\t//a value to enforce client to send back request\n\t\t\t\t//If you changed it, remember to correct boot.js\n\t\t\tthrow ex;\n\t\t}\n\n\t\t_errmsg = null; //no error at all\n\t\t_valided = true;\n\n\t\tif (!Objects.equals(_value, val)) {\n\t\t\t_value = val;\n\n\t\t\tfinal String fmtval = getTextNCUE();\n\t\t\tif (_valByClient == null || !Objects.equals(_valByClient, fmtval))\n\t\t\t\tsmartUpdate(\"value\", fmtval);\n\t\t\t\t//Note: we have to disable the sending back of the value\n\t\t\t\t//Otherwise, it cause Bug 1488579's problem 3.\n\t\t\t\t//Reason: when user set a value to correct one and set\n\t\t\t\t//to an illegal one, then click the button cause both events\n\t\t\t\t//being sent back to the server.\n\t\t} else if (_valByClient != null) {\n\t\t\t//value equals but formatted result might differ because\n\t\t\t//our parse is more fault tolerant\n\t\t\tfinal String fmtval = getTextNCUE();\n\t\t\tif (!Objects.equals(_valByClient, fmtval))\n\t\t\t\tsmartUpdate(\"value\", fmtval);\n\t\t}\n\t}","id":88060,"modified_method":"/** Sets the value.\n\t *\n\t * <p>It invokes {@link #coerceFromString} fisrt and then {@link #validate}.\n\t * Derives might override them for type conversion and special\n\t * validation.\n\t *\n\t * @param value the value; If null, it is considered as empty.\n\t */\n\tprotected void setText(String value) throws WrongValueException {\n\t\tObject val;\n\t\ttry {\n\t\t\tval = coerceFromString(value);\n\t\t\tvalidate(val);\n\t\t} catch (WrongValueException ex) {\n\t\t\tsmartUpdate(\"defaultValue\", \"zk_wrong!~-.zk_pha!6\");\n\t\t\t\t//a value to enforce client to send back request\n\t\t\t\t//If you changed it, remember to correct boot.js\n\t\t\tthrow ex;\n\t\t}\n\n\t\t_errmsg = null; //no error at all\n\t\t_valided = true;\n\n\t\tif (!Objects.equals(_value, val)) {\n\t\t\t_value = val;\n\n\t\t\tfinal String fmtval = coerceToString(_value);\n\t\t\tif (_valByClient == null || !Objects.equals(_valByClient, fmtval))\n\t\t\t\tsmartUpdate(\"value\", fmtval);\n\t\t\t\t//Note: we have to disable the sending back of the value\n\t\t\t\t//Otherwise, it cause Bug 1488579's problem 3.\n\t\t\t\t//Reason: when user set a value to correct one and set\n\t\t\t\t//to an illegal one, then click the button cause both events\n\t\t\t\t//being sent back to the server.\n\t\t} else if (_valByClient != null) {\n\t\t\t//value equals but formatted result might differ because\n\t\t\t//our parse is more fault tolerant\n\t\t\tfinal String fmtval = coerceToString(_value);\n\t\t\tif (!Objects.equals(_valByClient, fmtval))\n\t\t\t\tsmartUpdate(\"value\", fmtval);\n\t\t}\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the text for HTML AREA (Internal Use Only).\n\t *\n\t * <p>Used only for component generation. Not for applications.\n\t */\n\tpublic final String getAreaText() {\n\t\treturn XMLs.encodeText(getTextNCUE());\n\t}","id":88061,"modified_method":"/** Returns the text for HTML AREA (Internal Use Only).\n\t *\n\t * <p>Used only for component generation. Not for applications.\n\t */\n\tpublic final String getAreaText() {\n\t\treturn XMLs.encodeText(coerceToString(_value));\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"public String getInnerAttrs() {\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(64).append(super.getInnerAttrs());\n\n\t\tif (isMultiline()) {\n\t\t\tif (_cols > 0)\n\t\t\t\tHTMLs.appendAttribute(sb, \"cols\",  _cols);\n\t\t} else {\n\t\t\tHTMLs.appendAttribute(sb, \"value\",  getTextNCUE());\n\t\t\tif (_cols > 0)\n\t\t\t\tHTMLs.appendAttribute(sb, \"size\",  _cols);\n\t\t\tif (_maxlength > 0)\n\t\t\t\tHTMLs.appendAttribute(sb, \"maxlength\",  _maxlength);\n\t\t\tHTMLs.appendAttribute(sb, \"type\", \n\t\t\t\t\"password\".equals(getType()) ? \"password\": \"text\");\n\t\t}\n\n\t\tHTMLs.appendAttribute(sb, \"name\", _name);\n\t\tif (isDisabled())\n\t\t\tHTMLs.appendAttribute(sb, \"disabled\",  \"disabled\");\n\t\tif (isReadonly())\n\t\t\tHTMLs.appendAttribute(sb, \"readonly\", \"readonly\");\n\t\treturn sb.toString();\n\t}","id":88062,"modified_method":"public String getInnerAttrs() {\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(64).append(super.getInnerAttrs());\n\n\t\tif (isMultiline()) {\n\t\t\tif (_cols > 0)\n\t\t\t\tHTMLs.appendAttribute(sb, \"cols\",  _cols);\n\t\t} else {\n\t\t\tHTMLs.appendAttribute(sb, \"value\",  coerceToString(_value));\n\t\t\tif (_cols > 0)\n\t\t\t\tHTMLs.appendAttribute(sb, \"size\",  _cols);\n\t\t\tif (_maxlength > 0)\n\t\t\t\tHTMLs.appendAttribute(sb, \"maxlength\",  _maxlength);\n\t\t\tHTMLs.appendAttribute(sb, \"type\", \n\t\t\t\t\"password\".equals(getType()) ? \"password\": \"text\");\n\t\t}\n\n\t\tHTMLs.appendAttribute(sb, \"name\", _name);\n\t\tif (isDisabled())\n\t\t\tHTMLs.appendAttribute(sb, \"disabled\",  \"disabled\");\n\t\tif (isReadonly())\n\t\t\tHTMLs.appendAttribute(sb, \"readonly\", \"readonly\");\n\t\treturn sb.toString();\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Checks whether user entered a wrong value (and not correct it yet).\n\t * Since user might enter a wrong value and moves on to other components,\n\t * this methid is called when {@link #getText} or {@link #getRawValue} is\n\t * called.\n\t *\n\t * <p>Derives rarely need to access this method if they use only\n\t * {@link #getText} and {@link #getRawValue}.\n\t */\n\tprotected void checkUserError() throws WrongValueException {\n\t\tif (_errmsg != null)\n\t\t\tthrow new WrongValueException(this, _errmsg);\n\t\tif (!_valided && _constr != null)\n\t\t\tsetText(getTextNCUE());\n\t}","id":88063,"modified_method":"/** Checks whether user entered a wrong value (and not correct it yet).\n\t * Since user might enter a wrong value and moves on to other components,\n\t * this methid is called when {@link #getText} or {@link #getRawValue} is\n\t * called.\n\t *\n\t * <p>Derives rarely need to access this method if they use only\n\t * {@link #getText} and {@link #getRawValue}.\n\t */\n\tprotected void checkUserError() throws WrongValueException {\n\t\tif (_errmsg != null)\n\t\t\tthrow new WrongValueException(this, _errmsg);\n\t\tif (!_valided && _constr != null)\n\t\t\tsetText(coerceToString(_value));\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets the value (in Date).\n\t * @exception WrongValueException if value is wrong\n\t */\n\tpublic void setValue(Integer value) throws WrongValueException {\n\t\tvalidate(value);\n\t\tif (setRawValue(value))\n\t\t\tsmartUpdate(\"value\", getText());\n\t}","id":88064,"modified_method":"/** Sets the value (in Date).\n\t * @exception WrongValueException if value is wrong\n\t */\n\tpublic void setValue(Integer value) throws WrongValueException {\n\t\tvalidate(value);\n\t\tsetRawValue(value);\n\t}","commit_id":"0648a578b47561d879766a0077bb989d8db44700","url":"https://github.com/zkoss/zk"},{"original_method":"public void stop() {\n        prot_adapter.pause();\n        if (corr != null) {\n            corr.stop();\n            corr = null;\n        }\n    }","id":88065,"modified_method":"public void stop() {\n        if (corr != null) {\n            corr.stop();\n            corr = null;\n        }\n    }","commit_id":"4737b1a38d9f53cd2c19a82cffea1d2d4005a5e4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() {\n        if (corr == null) {\n            if (transport_adapter != null) {\n                corr = new RequestCorrelator(\"MessageDispatcher\", transport_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            } else {\n                corr = new RequestCorrelator(\"MessageDispatcher\", prot_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            }\n            corr.start();\n        }\n        if (channel != null) {\n            Vector tmp_mbrs = channel.getView() != null ? channel.getView().getMembers() : null;\n            setMembers(tmp_mbrs);\n        }\n        prot_adapter.resume();\n    }","id":88066,"modified_method":"public void start() {\n        if (corr == null) {\n            if (transport_adapter != null) {\n                corr = new RequestCorrelator(\"MessageDispatcher\", transport_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            } else {\n                corr = new RequestCorrelator(\"MessageDispatcher\", prot_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            }\n            corr.start();\n        }\n        if (channel != null) {\n            Vector tmp_mbrs = channel.getView() != null ? channel.getView().getMembers() : null;\n            setMembers(tmp_mbrs);\n        }\n        if (null != prot_adapter) { //null if called from the constructor that uses PullPushAdapter\n            prot_adapter.resume();\n        }\n    }","commit_id":"4737b1a38d9f53cd2c19a82cffea1d2d4005a5e4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        prot_adapter.pause();\n        if (corr != null) {\n            corr.stop();\n            corr = null;\n        }\n    }","id":88067,"modified_method":"public void stop() {\n        if (corr != null) {\n            corr.stop();\n            corr = null;\n        }\n    }","commit_id":"92d7d3e6e61c3d0da9464600efcc6c16edd18e29","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() {\n        if (corr == null) {\n            if (transport_adapter != null) {\n                corr = new RequestCorrelator(\"MessageDispatcher\", transport_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            } else {\n                corr = new RequestCorrelator(\"MessageDispatcher\", prot_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            }\n            corr.start();\n        }\n        if (channel != null) {\n            Vector tmp_mbrs = channel.getView() != null ? channel.getView().getMembers() : null;\n            setMembers(tmp_mbrs);\n        }\n        prot_adapter.resume();\n    }","id":88068,"modified_method":"public void start() {\n        if (corr == null) {\n            if (transport_adapter != null) {\n                corr = new RequestCorrelator(\"MessageDispatcher\", transport_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            } else {\n                corr = new RequestCorrelator(\"MessageDispatcher\", prot_adapter,\n                                             this, deadlock_detection, local_addr, concurrent_processing);\n            }\n            corr.start();\n        }\n        if (channel != null) {\n            Vector tmp_mbrs = channel.getView() != null ? channel.getView().getMembers() : null;\n            setMembers(tmp_mbrs);\n        }\n        if (null != prot_adapter) { //null if called from the constructor that uses PullPushAdapter\n            prot_adapter.resume();\n        }\n    }","commit_id":"92d7d3e6e61c3d0da9464600efcc6c16edd18e29","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n\r\n        if (listener != null)\r\n            listener.resume(this);\r\n\r\n        if (graphics.view != null)\r\n            graphics.view.onResume();\r\n\r\n        audio.resume();\r\n    }","id":88069,"modified_method":"@Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n\r\n        if (listener != null)\r\n            listener.resume(this);\r\n\r\n        if ( graphics != null && graphics.view != null)\r\n            graphics.view.onResume();\r\n\r\n        if( audio != null )\r\n        \taudio.resume();\r\n    }","commit_id":"8a6b02c5353376999362f8ff178d38c36c0d17b4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n    protected void onPause() {\r\n        super.onPause();\r\n\r\n        if (isFinishing())\r\n            graphics.disposeRenderListener();\r\n\r\n        if (graphics.view != null)\r\n            graphics.view.onPause();\r\n\r\n        audio.pause();\r\n\r\n        if (listener != null)\r\n            listener.pause(this);\r\n    }","id":88070,"modified_method":"@Override\r\n    protected void onPause() {\r\n        super.onPause();\r\n\r\n        if (isFinishing())\r\n            graphics.disposeRenderListener();\r\n\r\n        if ( graphics != null && graphics.view != null)\r\n            graphics.view.onPause();\r\n\r\n        if( audio != null )\r\n        \taudio.pause();\r\n\r\n        if (listener != null)\r\n            listener.pause(this);\r\n    }","commit_id":"8a6b02c5353376999362f8ff178d38c36c0d17b4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Add another statistics information.\n     */\n    public synchronized void add(final StatisticsImpl other) {\n        synchronized ( other ) {\n            if ( other.lastActivated > this.lastActivated ) {\n                this.lastActivated = other.lastActivated;\n            }\n            if ( other.lastFinished > this.lastFinished ) {\n                this.lastFinished = other.lastFinished;\n            }\n            this.queuedJobs += other.queuedJobs;\n            this.waitingTime += other.waitingTime;\n            this.waitingCount += other.waitingCount;\n            this.averageWaitingTime = this.waitingTime / this.waitingCount;\n            this.processingTime += other.processingTime;\n            this.processingCount += other.processingCount;\n            this.averageProcessingTime = this.processingTime / this.processingCount;\n            this.finishedJobs += other.finishedJobs;\n            this.failedJobs += other.failedJobs;\n            this.cancelledJobs += other.cancelledJobs;\n            this.activeJobs += other.activeJobs;\n        }\n    }","id":88071,"modified_method":"/**\n     * Add another statistics information.\n     */\n    public synchronized void add(final StatisticsImpl other) {\n        synchronized ( other ) {\n            if ( other.lastActivated > this.lastActivated ) {\n                this.lastActivated = other.lastActivated;\n            }\n            if ( other.lastFinished > this.lastFinished ) {\n                this.lastFinished = other.lastFinished;\n            }\n            this.queuedJobs += other.queuedJobs;\n            this.waitingTime += other.waitingTime;\n            this.waitingCount += other.waitingCount;\n            if ( this.waitingCount > 0 ) {\n                this.averageWaitingTime = this.waitingTime / this.waitingCount;\n            }\n            this.processingTime += other.processingTime;\n            this.processingCount += other.processingCount;\n            if ( this.processingCount > 0 ) {\n                this.averageProcessingTime = this.processingTime / this.processingCount;\n            }\n            this.finishedJobs += other.finishedJobs;\n            this.failedJobs += other.failedJobs;\n            this.cancelledJobs += other.cancelledJobs;\n            this.activeJobs += other.activeJobs;\n        }\n    }","commit_id":"9a5ee39c91b547c747b9fc5b909fd2adb5f8ad74","url":"https://github.com/apache/sling"},{"original_method":"private Queue getQueue(final HttpServletRequest req) throws ServletException {\n        final String name = req.getParameter(PAR_QUEUE);\n        if ( name != null ) {\n            for(final Queue q : this.jobManager.getQueues()) {\n                if ( name.equals(q.getName()) ) {\n                    return q;\n                }\n            }\n        }\n        throw new ServletException(\"Wrong parameters\");\n    }","id":88072,"modified_method":"private Queue getQueue(final HttpServletRequest req) {\n        final String name = req.getParameter(PAR_QUEUE);\n        if ( name != null ) {\n            for(final Queue q : this.jobManager.getQueues()) {\n                if ( name.equals(q.getName()) ) {\n                    return q;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"9a5ee39c91b547c747b9fc5b909fd2adb5f8ad74","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doPost(final HttpServletRequest req, final HttpServletResponse resp)\n    throws ServletException, IOException {\n        final String cmd = req.getParameter(\"action\");\n        if ( \"suspend\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            q.suspend();\n        } else if ( \"resume\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            q.resume();\n        } else if ( \"clear\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            q.clear();\n        } else if ( \"reset\".equals(cmd) ) {\n            if ( req.getParameter(PAR_QUEUE) == null || req.getParameter(PAR_QUEUE).length() == 0 ) {\n                this.jobManager.getStatistics().reset();\n            } else {\n                final Queue q = this.getQueue(req);\n                q.getStatistics().reset();\n            }\n        } else if ( \"dropall\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            q.removeAll();\n        } else {\n            throw new ServletException(\"Unknown command\");\n        }\n        resp.sendRedirect(req.getContextPath() + req.getServletPath() + req.getPathInfo());\n    }","id":88073,"modified_method":"@Override\n    protected void doPost(final HttpServletRequest req, final HttpServletResponse resp)\n    throws ServletException, IOException {\n        String msg = null;\n        final String cmd = req.getParameter(\"action\");\n        if ( \"suspend\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            if ( q != null ) {\n                q.suspend();\n            } else {\n                msg = this.getQueueErrorMessage(req, \"suspend\");\n            }\n        } else if ( \"resume\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            if ( q != null ) {\n                q.resume();\n            } else {\n                msg = this.getQueueErrorMessage(req, \"resume\");\n            }\n        } else if ( \"clear\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            if ( q != null ) {\n                q.clear();\n            } else {\n                msg = this.getQueueErrorMessage(req, \"clear\");\n            }\n        } else if ( \"reset\".equals(cmd) ) {\n            if ( req.getParameter(PAR_QUEUE) == null || req.getParameter(PAR_QUEUE).length() == 0 ) {\n                this.jobManager.getStatistics().reset();\n            } else {\n                final Queue q = this.getQueue(req);\n                if ( q != null ) {\n                    q.getStatistics().reset();\n                } else {\n                    msg = this.getQueueErrorMessage(req, \"reset\");\n                }\n            }\n        } else if ( \"dropall\".equals(cmd) ) {\n            final Queue q = this.getQueue(req);\n            if ( q != null ) {\n                q.removeAll();\n            } else {\n                msg = this.getQueueErrorMessage(req, \"drop all\");\n            }\n        } else {\n            msg = \"Unknown command\";\n        }\n        final String path = req.getContextPath() + req.getServletPath() + req.getPathInfo();\n        final String redirectTo;\n        if ( msg == null ) {\n            redirectTo = path;\n        } else {\n            redirectTo = path + \"?message=\" + msg;\n        }\n        resp.sendRedirect(redirectTo);\n    }","commit_id":"9a5ee39c91b547c747b9fc5b909fd2adb5f8ad74","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doGet(final HttpServletRequest req, final HttpServletResponse res)\n     throws ServletException, IOException {\n        final PrintWriter pw = res.getWriter();\n\n        pw.println(\"<p class='statline ui-state-highlight'>Apache Sling Eventing<\/p>\");\n        pw.println(\"<div class='ui-widget-header ui-corner-top buttonGroup'>\");\n        pw.println(\"<span style='float: left; margin-left: 1em'>Apache Sling Eventing: Overall Statistics<\/span>\");\n        this.printForm(pw, null, \"Reset Stats\", \"reset\");\n        pw.println(\"<\/div>\");\n\n        pw.println(\"<table class='nicetable'><tbody>\");\n        Statistics s = this.jobManager.getStatistics();\n        pw.printf(\"<tr><td>Start Time<\/td><td>%s<\/td><\/tr>\", formatDate(s.getStartTime()));\n        pw.printf(\"<tr><td>Last Activated<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastActivatedJobTime()));\n        pw.printf(\"<tr><td>Last Finished<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastFinishedJobTime()));\n        pw.printf(\"<tr><td>Queued Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfQueuedJobs());\n        pw.printf(\"<tr><td>Active Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfActiveJobs());\n        pw.printf(\"<tr><td>Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfJobs());\n        pw.printf(\"<tr><td>Finished Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFinishedJobs());\n        pw.printf(\"<tr><td>Failed Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFailedJobs());\n        pw.printf(\"<tr><td>Cancelled Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfCancelledJobs());\n        pw.printf(\"<tr><td>Processed Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfProcessedJobs());\n        pw.printf(\"<tr><td>Average Processing Time<\/td><td>%s<\/td><\/tr>\", formatTime(s.getAverageProcessingTime()));\n        pw.printf(\"<tr><td>Average Waiting Time<\/td><td>%s<\/td><\/tr>\", formatTime(s.getAverageWaitingTime()));\n        pw.println(\"<\/tbody><\/table>\");\n        pw.println(\"<br/>\");\n\n        boolean isEmpty = true;\n        for(final Queue q : this.jobManager.getQueues()) {\n            isEmpty = false;\n            pw.println(\"<div class='ui-widget-header ui-corner-top buttonGroup'>\");\n            pw.printf(\"<span style='float: left; margin-left: 1em'>Active JobQueue: %s %s<\/span>\", escape(q.getName()),\n                    q.isSuspended() ? \"(SUSPENDED)\" : \"\");\n            this.printForm(pw, q, \"Reset Stats\", \"reset\");\n            if ( q.isSuspended() ) {\n                this.printForm(pw, q, \"Resume\", \"resume\");\n            } else {\n                this.printForm(pw, q, \"Suspend\", \"suspend\");\n            }\n            this.printForm(pw, q, \"Clear Queue\", \"clear\");\n            this.printForm(pw, q, \"Drop All\", \"dropall\");\n            pw.println(\"<\/div>\");\n            pw.println(\"<table class='nicetable'><tbody>\");\n\n            s = q.getStatistics();\n            final QueueConfiguration c = q.getConfiguration();\n            pw.println(\"<tr><th colspan='2'>Statistics<\/th><th colspan='2'>Configuration<\/th><\/tr>\");\n            pw.printf(\"<tr><td>Start Time<\/td><td>%s<\/td><td>Type<\/td><td>%s<\/td><\/tr>\", formatDate(s.getStartTime()), formatType(c.getType()));\n            pw.printf(\"<tr><td>Last Activated<\/td><td>%s<\/td><td>Topics<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastActivatedJobTime()), formatArray(c.getTopics()));\n            pw.printf(\"<tr><td>Last Finished<\/td><td>%s<\/td><td>Max Parallel<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastFinishedJobTime()), c.getMaxParallel());\n            pw.printf(\"<tr><td>Queued Jobs<\/td><td>%s<\/td><td>Max Retries<\/td><td>%s<\/td><\/tr>\", s.getNumberOfQueuedJobs(), c.getMaxRetries());\n            pw.printf(\"<tr><td>Active Jobs<\/td><td>%s<\/td><td>Retry Delay<\/td><td>%s ms<\/td><\/tr>\", s.getNumberOfActiveJobs(), c.getRetryDelayInMs());\n            pw.printf(\"<tr><td>Jobs<\/td><td>%s<\/td><td>Priority<\/td><td>%s<\/td><\/tr>\", s.getNumberOfJobs(), c.getPriority());\n            pw.printf(\"<tr><td>Finished Jobs<\/td><td>%s<\/td><td>Run Local<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFinishedJobs(), c.isLocalQueue());\n            pw.printf(\"<tr><td>Failed Jobs<\/td><td>%s<\/td><td>App Ids<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFailedJobs(), formatArray(c.getApplicationIds()));\n            pw.printf(\"<tr><td>Cancelled Jobs<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", s.getNumberOfCancelledJobs());\n            pw.printf(\"<tr><td>Processed Jobs<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", s.getNumberOfProcessedJobs());\n            pw.printf(\"<tr><td>Average Processing Time<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", formatTime(s.getAverageProcessingTime()));\n            pw.printf(\"<tr><td>Average Waiting Time<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", formatTime(s.getAverageWaitingTime()));\n            pw.printf(\"<tr><td>Status Info<\/td><td colspan='3'>%s<\/td><\/tr>\", escape(q.getStateInfo()));\n            pw.println(\"<\/tbody><\/table>\");\n            pw.println(\"<br/>\");\n        }\n        if ( isEmpty ) {\n            pw.println(\"<p>No active queues.<\/p>\");\n            pw.println(\"<br/>\");\n        }\n\n        for(final TopicStatistics ts : this.jobManager.getTopicStatistics()) {\n            pw.println(\"<table class='nicetable'><tbody>\");\n            pw.printf(\"<tr><th colspan='2'>Topic Statistics: %s<\/th><\/tr>\", escape(ts.getTopic()));\n\n            pw.printf(\"<tr><td>Last Activated<\/td><td>%s<\/td><\/tr>\", formatDate(ts.getLastActivatedJobTime()));\n            pw.printf(\"<tr><td>Last Finished<\/td><td>%s<\/td><\/tr>\", formatDate(ts.getLastFinishedJobTime()));\n            pw.printf(\"<tr><td>Finished Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfFinishedJobs());\n            pw.printf(\"<tr><td>Failed Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfFailedJobs());\n            pw.printf(\"<tr><td>Cancelled Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfCancelledJobs());\n            pw.printf(\"<tr><td>Processed Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfProcessedJobs());\n            pw.printf(\"<tr><td>Average Processing Time<\/td><td>%s<\/td><\/tr>\", formatTime(ts.getAverageProcessingTime()));\n            pw.printf(\"<tr><td>Average Waiting Time<\/td><td>%s<\/td><\/tr>\", formatTime(ts.getAverageWaitingTime()));\n            pw.println(\"<\/tbody><\/table>\");\n            pw.println(\"<br/>\");\n        }\n\n        pw.println(\"<p class='statline'>Apache Sling Eventing - Job Queue Configurations<\/p>\");\n        this.printQueueConfiguration(req, pw, ((DefaultJobManager)this.jobManager).getMainQueueConfiguration());\n        final InternalQueueConfiguration[] configs = this.queueConfigManager.getConfigurations();\n        for(final InternalQueueConfiguration c : configs ) {\n            this.printQueueConfiguration(req, pw, c);\n        }\n    }","id":88074,"modified_method":"@Override\n    protected void doGet(final HttpServletRequest req, final HttpServletResponse res)\n     throws ServletException, IOException {\n        final String msg = req.getParameter(\"message\");\n        final PrintWriter pw = res.getWriter();\n\n        pw.printf(\"<p class='statline ui-state-highlight'>Apache Sling Eventing%s%n<\/p>\", msg != null ? \" : \" + msg : \"\");\n        pw.println(\"<div class='ui-widget-header ui-corner-top buttonGroup'>\");\n        pw.println(\"<span style='float: left; margin-left: 1em'>Apache Sling Eventing: Overall Statistics<\/span>\");\n        this.printForm(pw, null, \"Reset Stats\", \"reset\");\n        pw.println(\"<\/div>\");\n\n        pw.println(\"<table class='nicetable'><tbody>\");\n        Statistics s = this.jobManager.getStatistics();\n        pw.printf(\"<tr><td>Start Time<\/td><td>%s<\/td><\/tr>\", formatDate(s.getStartTime()));\n        pw.printf(\"<tr><td>Last Activated<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastActivatedJobTime()));\n        pw.printf(\"<tr><td>Last Finished<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastFinishedJobTime()));\n        pw.printf(\"<tr><td>Queued Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfQueuedJobs());\n        pw.printf(\"<tr><td>Active Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfActiveJobs());\n        pw.printf(\"<tr><td>Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfJobs());\n        pw.printf(\"<tr><td>Finished Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFinishedJobs());\n        pw.printf(\"<tr><td>Failed Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFailedJobs());\n        pw.printf(\"<tr><td>Cancelled Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfCancelledJobs());\n        pw.printf(\"<tr><td>Processed Jobs<\/td><td>%s<\/td><\/tr>\", s.getNumberOfProcessedJobs());\n        pw.printf(\"<tr><td>Average Processing Time<\/td><td>%s<\/td><\/tr>\", formatTime(s.getAverageProcessingTime()));\n        pw.printf(\"<tr><td>Average Waiting Time<\/td><td>%s<\/td><\/tr>\", formatTime(s.getAverageWaitingTime()));\n        pw.println(\"<\/tbody><\/table>\");\n        pw.println(\"<br/>\");\n\n        boolean isEmpty = true;\n        for(final Queue q : this.jobManager.getQueues()) {\n            isEmpty = false;\n            pw.println(\"<div class='ui-widget-header ui-corner-top buttonGroup'>\");\n            pw.printf(\"<span style='float: left; margin-left: 1em'>Active JobQueue: %s %s<\/span>\", escape(q.getName()),\n                    q.isSuspended() ? \"(SUSPENDED)\" : \"\");\n            this.printForm(pw, q, \"Reset Stats\", \"reset\");\n            if ( q.isSuspended() ) {\n                this.printForm(pw, q, \"Resume\", \"resume\");\n            } else {\n                this.printForm(pw, q, \"Suspend\", \"suspend\");\n            }\n            this.printForm(pw, q, \"Clear Queue\", \"clear\");\n            this.printForm(pw, q, \"Drop All\", \"dropall\");\n            pw.println(\"<\/div>\");\n            pw.println(\"<table class='nicetable'><tbody>\");\n\n            s = q.getStatistics();\n            final QueueConfiguration c = q.getConfiguration();\n            pw.println(\"<tr><th colspan='2'>Statistics<\/th><th colspan='2'>Configuration<\/th><\/tr>\");\n            pw.printf(\"<tr><td>Start Time<\/td><td>%s<\/td><td>Type<\/td><td>%s<\/td><\/tr>\", formatDate(s.getStartTime()), formatType(c.getType()));\n            pw.printf(\"<tr><td>Last Activated<\/td><td>%s<\/td><td>Topics<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastActivatedJobTime()), formatArray(c.getTopics()));\n            pw.printf(\"<tr><td>Last Finished<\/td><td>%s<\/td><td>Max Parallel<\/td><td>%s<\/td><\/tr>\", formatDate(s.getLastFinishedJobTime()), c.getMaxParallel());\n            pw.printf(\"<tr><td>Queued Jobs<\/td><td>%s<\/td><td>Max Retries<\/td><td>%s<\/td><\/tr>\", s.getNumberOfQueuedJobs(), c.getMaxRetries());\n            pw.printf(\"<tr><td>Active Jobs<\/td><td>%s<\/td><td>Retry Delay<\/td><td>%s ms<\/td><\/tr>\", s.getNumberOfActiveJobs(), c.getRetryDelayInMs());\n            pw.printf(\"<tr><td>Jobs<\/td><td>%s<\/td><td>Priority<\/td><td>%s<\/td><\/tr>\", s.getNumberOfJobs(), c.getPriority());\n            pw.printf(\"<tr><td>Finished Jobs<\/td><td>%s<\/td><td>Run Local<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFinishedJobs(), c.isLocalQueue());\n            pw.printf(\"<tr><td>Failed Jobs<\/td><td>%s<\/td><td>App Ids<\/td><td>%s<\/td><\/tr>\", s.getNumberOfFailedJobs(), formatArray(c.getApplicationIds()));\n            pw.printf(\"<tr><td>Cancelled Jobs<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", s.getNumberOfCancelledJobs());\n            pw.printf(\"<tr><td>Processed Jobs<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", s.getNumberOfProcessedJobs());\n            pw.printf(\"<tr><td>Average Processing Time<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", formatTime(s.getAverageProcessingTime()));\n            pw.printf(\"<tr><td>Average Waiting Time<\/td><td>%s<\/td><td colspan='2'>&nbsp<\/td><\/tr>\", formatTime(s.getAverageWaitingTime()));\n            pw.printf(\"<tr><td>Status Info<\/td><td colspan='3'>%s<\/td><\/tr>\", escape(q.getStateInfo()));\n            pw.println(\"<\/tbody><\/table>\");\n            pw.println(\"<br/>\");\n        }\n        if ( isEmpty ) {\n            pw.println(\"<p>No active queues.<\/p>\");\n            pw.println(\"<br/>\");\n        }\n\n        for(final TopicStatistics ts : this.jobManager.getTopicStatistics()) {\n            pw.println(\"<table class='nicetable'><tbody>\");\n            pw.printf(\"<tr><th colspan='2'>Topic Statistics: %s<\/th><\/tr>\", escape(ts.getTopic()));\n\n            pw.printf(\"<tr><td>Last Activated<\/td><td>%s<\/td><\/tr>\", formatDate(ts.getLastActivatedJobTime()));\n            pw.printf(\"<tr><td>Last Finished<\/td><td>%s<\/td><\/tr>\", formatDate(ts.getLastFinishedJobTime()));\n            pw.printf(\"<tr><td>Finished Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfFinishedJobs());\n            pw.printf(\"<tr><td>Failed Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfFailedJobs());\n            pw.printf(\"<tr><td>Cancelled Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfCancelledJobs());\n            pw.printf(\"<tr><td>Processed Jobs<\/td><td>%s<\/td><\/tr>\", ts.getNumberOfProcessedJobs());\n            pw.printf(\"<tr><td>Average Processing Time<\/td><td>%s<\/td><\/tr>\", formatTime(ts.getAverageProcessingTime()));\n            pw.printf(\"<tr><td>Average Waiting Time<\/td><td>%s<\/td><\/tr>\", formatTime(ts.getAverageWaitingTime()));\n            pw.println(\"<\/tbody><\/table>\");\n            pw.println(\"<br/>\");\n        }\n\n        pw.println(\"<p class='statline'>Apache Sling Eventing - Job Queue Configurations<\/p>\");\n        this.printQueueConfiguration(req, pw, ((DefaultJobManager)this.jobManager).getMainQueueConfiguration());\n        final InternalQueueConfiguration[] configs = this.queueConfigManager.getConfigurations();\n        for(final InternalQueueConfiguration c : configs ) {\n            this.printQueueConfiguration(req, pw, c);\n        }\n    }","commit_id":"9a5ee39c91b547c747b9fc5b909fd2adb5f8ad74","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public boolean index(AbstractFile sourceFile, IngestJobContext context) throws IngesterException {\n        this.sourceFile = sourceFile;\n        numChunks = 0; //unknown until indexing is done\n\n        boolean success = false;\n        Reader reader = null;\n\n        final InputStream stream = new ReadContentInputStream(sourceFile);\n\n        try {\n            // Parse the stream with Jericho\n            JerichoParserWrapper jpw = new JerichoParserWrapper(stream);\n            jpw.parse();\n            reader = jpw.getReader();\n\n            // In case there is an exception or parse() isn't called\n            if (reader == null) {\n                logger.log(Level.WARNING, \"No reader available from HTML parser\"); //NON-NLS\n                return false;\n            }\n\n            success = true;\n            long readSize;\n            long totalRead = 0;\n            boolean eof = false;\n            //we read max 1024 chars at time, this seems to max what this Reader would return\n            while (!eof && (readSize = reader.read(textChunkBuf, 0, SINGLE_READ_CHARS)) != -1) {\n                totalRead += readSize;\n\n                //consume more bytes to fill entire chunk (leave EXTRA_CHARS to end the word)\n                while ((totalRead < MAX_EXTR_TEXT_CHARS - SINGLE_READ_CHARS - EXTRA_CHARS)\n                        && (readSize = reader.read(textChunkBuf, (int) totalRead, SINGLE_READ_CHARS)) != -1) {\n                    totalRead += readSize;\n                }\n                if (readSize == -1) {\n                    //this is the last chunk\n                    eof = true;\n                } else {\n                    //try to read until whitespace to not break words\n                    while ((totalRead < MAX_EXTR_TEXT_CHARS - 1)\n                            && !Character.isWhitespace(textChunkBuf[(int) totalRead - 1])\n                            && (readSize = reader.read(textChunkBuf, (int) totalRead, 1)) != -1) {\n                        totalRead += readSize;\n                    }\n                    if (readSize == -1) {\n                        //this is the last chunk\n                        eof = true;\n                    }\n                }\n\n                //logger.log(Level.INFO, \"TOTAL READ SIZE: \" + totalRead + \" file: \" + sourceFile.getName());\n                //encode to bytes to index as byte stream\n                String extracted;\n\n                //add BOM and trim the 0 bytes\n                //set initial size to chars read + bom - try to prevent from resizing\n                StringBuilder sb = new StringBuilder((int) totalRead + 1000);\n                //inject BOM here (saves byte buffer realloc later), will be converted to specific encoding BOM\n                //sb.append(UTF16BOM); disabled BOM, not needing as bypassing Tika\n                if (totalRead < MAX_EXTR_TEXT_CHARS) {\n                    sb.append(textChunkBuf, 0, (int) totalRead);\n                } else {\n                    sb.append(textChunkBuf);\n                }\n\n                //reset for next chunk\n                totalRead = 0;\n                extracted = sb.toString();\n\n                //converts BOM automatically to charSet encoding\n                byte[] encodedBytes = extracted.getBytes(outCharset);\n                AbstractFileChunk chunk = new AbstractFileChunk(this, this.numChunks + 1);\n                try {\n                    chunk.index(ingester, encodedBytes, encodedBytes.length, outCharset);\n                    ++this.numChunks;\n                } catch (Ingester.IngesterException ingEx) {\n                    success = false;\n                    logger.log(Level.WARNING, \"Ingester had a problem with extracted HTML from file '\" //NON-NLS\n                            + sourceFile.getName() + \"' (id: \" + sourceFile.getId() + \").\", ingEx); //NON-NLS\n                    throw ingEx; //need to rethrow/return to signal error and move on\n                }\n            }\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Unable to read content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(), ex); //NON-NLS\n            success = false;\n        } catch (Exception ex) {\n            logger.log(Level.WARNING, \"Unexpected error, can't read content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(), ex); //NON-NLS\n            success = false;\n        } finally {\n            try {\n                stream.close();\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close content stream from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close content reader from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n        }\n\n        //after all chunks, ingest the parent file without content itself, and store numChunks\n        ingester.ingest(this);\n\n        return success;\n    }","id":88075,"modified_method":"@Override\n    public boolean index(AbstractFile sourceFile, IngestJobContext context) throws IngesterException {\n        this.sourceFile = sourceFile;\n        numChunks = 0; //unknown until indexing is done\n\n        boolean success = false;\n        Reader reader = null;\n\n        final InputStream stream = new ReadContentInputStream(sourceFile);\n\n        try {\n            // Parse the stream with Jericho\n            JerichoParserWrapper jpw = new JerichoParserWrapper(stream);\n            jpw.parse();\n            reader = jpw.getReader();\n\n            // In case there is an exception or parse() isn't called\n            if (reader == null) {\n                logger.log(Level.WARNING, \"No reader available from HTML parser\"); //NON-NLS\n                return false;\n            }\n\n            success = true;\n            long readSize;\n            long totalRead = 0;\n            boolean eof = false;\n            //we read max 1024 chars at time, this seems to max what this Reader would return\n            while (!eof && (readSize = reader.read(textChunkBuf, 0, SINGLE_READ_CHARS)) != -1) {\n                if (context.fileIngestIsCancelled()) {\n                    try {\n                        stream.close();\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Unable to close content stream from \" + sourceFile.getId(), ex); //NON-NLS\n                    }\n                    try {\n                        if (reader != null) {\n                            reader.close();\n                        }\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Unable to close content reader from \" + sourceFile.getId(), ex); //NON-NLS\n                    }\n                    return false;\n                }\n                totalRead += readSize;\n\n                //consume more bytes to fill entire chunk (leave EXTRA_CHARS to end the word)\n                while ((totalRead < MAX_EXTR_TEXT_CHARS - SINGLE_READ_CHARS - EXTRA_CHARS)\n                        && (readSize = reader.read(textChunkBuf, (int) totalRead, SINGLE_READ_CHARS)) != -1) {\n                    totalRead += readSize;\n                }\n                if (readSize == -1) {\n                    //this is the last chunk\n                    eof = true;\n                } else {\n                    //try to read until whitespace to not break words\n                    while ((totalRead < MAX_EXTR_TEXT_CHARS - 1)\n                            && !Character.isWhitespace(textChunkBuf[(int) totalRead - 1])\n                            && (readSize = reader.read(textChunkBuf, (int) totalRead, 1)) != -1) {\n                        totalRead += readSize;\n                    }\n                    if (readSize == -1) {\n                        //this is the last chunk\n                        eof = true;\n                    }\n                }\n\n                //logger.log(Level.INFO, \"TOTAL READ SIZE: \" + totalRead + \" file: \" + sourceFile.getName());\n                //encode to bytes to index as byte stream\n                String extracted;\n\n                //add BOM and trim the 0 bytes\n                //set initial size to chars read + bom - try to prevent from resizing\n                StringBuilder sb = new StringBuilder((int) totalRead + 1000);\n                //inject BOM here (saves byte buffer realloc later), will be converted to specific encoding BOM\n                //sb.append(UTF16BOM); disabled BOM, not needing as bypassing Tika\n                if (totalRead < MAX_EXTR_TEXT_CHARS) {\n                    sb.append(textChunkBuf, 0, (int) totalRead);\n                } else {\n                    sb.append(textChunkBuf);\n                }\n\n                //reset for next chunk\n                totalRead = 0;\n                extracted = sb.toString();\n\n                //converts BOM automatically to charSet encoding\n                byte[] encodedBytes = extracted.getBytes(outCharset);\n                AbstractFileChunk chunk = new AbstractFileChunk(this, this.numChunks + 1);\n                try {\n                    chunk.index(ingester, encodedBytes, encodedBytes.length, outCharset);\n                    ++this.numChunks;\n                } catch (Ingester.IngesterException ingEx) {\n                    success = false;\n                    logger.log(Level.WARNING, \"Ingester had a problem with extracted HTML from file '\" //NON-NLS\n                            + sourceFile.getName() + \"' (id: \" + sourceFile.getId() + \").\", ingEx); //NON-NLS\n                    throw ingEx; //need to rethrow/return to signal error and move on\n                }\n            }\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Unable to read content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(), ex); //NON-NLS\n            success = false;\n        } catch (Exception ex) {\n            logger.log(Level.WARNING, \"Unexpected error, can't read content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(), ex); //NON-NLS\n            success = false;\n        } finally {\n            try {\n                stream.close();\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close content stream from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close content reader from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n        }\n\n        //after all chunks, ingest the parent file without content itself, and store numChunks\n        if (!context.fileIngestIsCancelled()) {\n            ingester.ingest(this);\n        }\n        return success;\n    }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Adds the file to the index. Detects file type, calls extractors, etc.\n         *\n         * @param aFile        File to analyze\n         * @param indexContent False if only metadata should be text_ingested.\n         *                     True if content and metadata should be index.\n         */\n        private void indexFile(AbstractFile aFile, boolean indexContent) {\n            //logger.log(Level.INFO, \"Processing AbstractFile: \" + abstractFile.getName());\n\n            TskData.TSK_DB_FILES_TYPE_ENUM aType = aFile.getType();\n\n            // unallocated and unused blocks can only have strings extracted from them. \n            if ((aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) || aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS))) {\n                extractStringsAndIndex(aFile);\n                return;\n            }\n\n            final long size = aFile.getSize();\n            //if not to index content, or a dir, or 0 content, index meta data only\n            if ((indexContent == false || aFile.isDir() || size == 0)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            String fileType;\n            try {\n                fileType = fileTypeDetector.getFileType(aFile);\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, String.format(\"Could not detect format using fileTypeDetector for file: %s\", aFile), ex); //NON-NLS\n                return;\n            }\n\n            // we skip archive formats that are opened by the archive module. \n            // @@@ We could have a check here to see if the archive module was enabled though...\n            if (TextExtractor.ARCHIVE_MIME_TYPES.contains(fileType)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            boolean wasTextAdded = false;\n            if (isTextExtractSupported(aFile, fileType)) {\n                //extract text with one of the extractors, divide into chunks and index with Solr\n                try {\n                    //logger.log(Level.INFO, \"indexing: \" + aFile.getName());\n                    if (!extractTextAndIndex(aFile, fileType)) {\n                        logger.log(Level.WARNING, \"Failed to extract text and ingest, file ''{0}'' (id: {1}).\", new Object[]{aFile.getName(), aFile.getId()}); //NON-NLS\n                        putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                    } else {\n                        putIngestStatus(jobId, aFile.getId(), IngestStatus.TEXT_INGESTED);\n                        wasTextAdded = true;\n                    }\n\n                } catch (IngesterException e) {\n                    logger.log(Level.INFO, \"Could not extract text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                            + aFile.getName(), e);\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Error extracting text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                            + aFile.getName(), e);\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                }\n            }\n\n            // if it wasn't supported or had an error, default to strings\n            if (wasTextAdded == false) {\n                extractStringsAndIndex(aFile);\n            }\n        }","id":88076,"modified_method":"/**\n         * Adds the file to the index. Detects file type, calls extractors, etc.\n         *\n         * @param aFile        File to analyze\n         * @param indexContent False if only metadata should be text_ingested.\n         *                     True if content and metadata should be index.\n         */\n        private void indexFile(AbstractFile aFile, boolean indexContent) {\n            //logger.log(Level.INFO, \"Processing AbstractFile: \" + abstractFile.getName());\n\n            TskData.TSK_DB_FILES_TYPE_ENUM aType = aFile.getType();\n\n            // unallocated and unused blocks can only have strings extracted from them. \n            if ((aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) || aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS))) {\n                extractStringsAndIndex(aFile);\n                return;\n            }\n\n            final long size = aFile.getSize();\n            //if not to index content, or a dir, or 0 content, index meta data only\n            if (context.fileIngestIsCancelled()) {\n                return;\n            }\n            if ((indexContent == false || aFile.isDir() || size == 0)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            String fileType;\n            try {\n                fileType = fileTypeDetector.getFileType(aFile);\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, String.format(\"Could not detect format using fileTypeDetector for file: %s\", aFile), ex); //NON-NLS\n                return;\n            }\n            if (context.fileIngestIsCancelled()) {\n                return;\n            }\n\n            // we skip archive formats that are opened by the archive module. \n            // @@@ We could have a check here to see if the archive module was enabled though...\n            if (TextExtractor.ARCHIVE_MIME_TYPES.contains(fileType)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            boolean wasTextAdded = false;\n\n            //extract text with one of the extractors, divide into chunks and index with Solr\n            try {\n                //logger.log(Level.INFO, \"indexing: \" + aFile.getName());\n                if (!extractTextAndIndex(aFile, fileType)) {\n                    logger.log(Level.WARNING, \"Failed to extract text and ingest, file ''{0}'' (id: {1}).\", new Object[]{aFile.getName(), aFile.getId()}); //NON-NLS\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                } else {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.TEXT_INGESTED);\n                    wasTextAdded = true;\n                }\n\n            } catch (IngesterException e) {\n                logger.log(Level.INFO, \"Could not extract text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                        + aFile.getName(), e);\n                putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error extracting text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                        + aFile.getName(), e);\n                putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n            }\n\n            // if it wasn't supported or had an error, default to strings\n            if (wasTextAdded == false) {\n                extractStringsAndIndex(aFile);\n            }\n        }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public ProcessResult process(AbstractFile abstractFile) {\n        if (initialized == false) //error initializing indexing/Solr\n        {\n            logger.log(Level.WARNING, \"Skipping processing, module not initialized, file: {0}\", abstractFile.getName());  //NON-NLS\n            putIngestStatus(jobId, abstractFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n            return ProcessResult.OK;\n        }\n\n        if (abstractFile.getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR)) {\n            //skip indexing of virtual dirs (no content, no real name) - will index children files\n            return ProcessResult.OK;\n        }\n\n        if (KeywordSearchSettings.getSkipKnown() && abstractFile.getKnown().equals(FileKnown.KNOWN)) {\n            //index meta-data only\n            indexer.indexFile(abstractFile, false);\n            return ProcessResult.OK;\n        }\n\n        //index the file and content (if the content is supported)\n        indexer.indexFile(abstractFile, true);\n\n        // Start searching if it hasn't started already\n        if (!startedSearching) {\n            List<String> keywordListNames = settings.getNamesOfEnabledKeyWordLists();\n            SearchRunner.getInstance().startJob(jobId, dataSourceId, keywordListNames);\n            startedSearching = true;\n        }\n\n        return ProcessResult.OK;\n    }","id":88077,"modified_method":"@Override\n    public ProcessResult process(AbstractFile abstractFile) {\n        if (initialized == false) //error initializing indexing/Solr\n        {\n            logger.log(Level.WARNING, \"Skipping processing, module not initialized, file: {0}\", abstractFile.getName());  //NON-NLS\n            putIngestStatus(jobId, abstractFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n            return ProcessResult.OK;\n        }\n\n        if (abstractFile.getType().equals(TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR)) {\n            //skip indexing of virtual dirs (no content, no real name) - will index children files\n            return ProcessResult.OK;\n        }\n\n        if (KeywordSearchSettings.getSkipKnown() && abstractFile.getKnown().equals(FileKnown.KNOWN)) {\n            //index meta-data only\n            indexer.indexFile(abstractFile, false);\n            return ProcessResult.OK;\n        }\n\n        //index the file and content (if the content is supported)\n        indexer.indexFile(abstractFile, true);\n\n        // Start searching if it hasn't started already\n        if (!startedSearching) {\n            if (context.fileIngestIsCancelled()) {\n                return ProcessResult.OK;\n            }\n            List<String> keywordListNames = settings.getNamesOfEnabledKeyWordLists();\n            SearchRunner.getInstance().startJob(jobId, dataSourceId, keywordListNames);\n            startedSearching = true;\n        }\n\n        return ProcessResult.OK;\n    }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public IngestModule.ProcessResult process(AbstractFile file) {\n        // Skip everything except unallocated space files.\n        if (file.getType() != TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) {\n            return IngestModule.ProcessResult.OK;\n        }\n\n        // Safely get a reference to the totalsForIngestJobs object\n        IngestJobTotals totals = getTotalsForIngestJobs(jobId);\n\n        Path tempFilePath = null;\n        try {\n            long id = getRootId(file);\n            // make sure we have a valid systemID\n            if (id == -1) {\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Verify initialization succeeded.\n            if (null == this.executableFile) {\n                logger.log(Level.SEVERE, \"PhotoRec carver called after failed start up\");  // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Check that we have roughly enough disk space left to complete the operation\n            // Some network drives always return -1 for free disk space. \n            // In this case, expect enough space and move on.\n            long freeDiskSpace = IngestServices.getInstance().getFreeDiskSpace();\n            if ((freeDiskSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN) && ((file.getSize() * 1.2) > freeDiskSpace)) {\n                logger.log(Level.SEVERE, \"PhotoRec error processing {0} with {1} Not enough space on primary disk to save unallocated space.\", // NON-NLS\n                        new Object[]{file.getName(), PhotoRecCarverIngestModuleFactory.getModuleName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.UnableToCarve\", file.getName()),\n                        NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.NotEnoughDiskSpace\"));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Write the file to disk.\n            long writestart = System.currentTimeMillis();\n            WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.get(this.jobId);\n            tempFilePath = Paths.get(paths.getTempDirPath().toString(), file.getName());\n            ContentUtils.writeToFile(file, tempFilePath.toFile());\n\n            // Create a subdirectory for this file.\n            Path outputDirPath = Paths.get(paths.getOutputDirPath().toString(), file.getName());\n            Files.createDirectory(outputDirPath);\n            File log = new File(Paths.get(outputDirPath.toString(), LOG_FILE).toString()); //NON-NLS\n\n            // Scan the file with Unallocated Carver.\n            ProcessBuilder processAndSettings = new ProcessBuilder(\n                    \"\\\"\" + executableFile + \"\\\"\",\n                    \"/d\", // NON-NLS\n                    \"\\\"\" + outputDirPath.toAbsolutePath() + File.separator + PHOTOREC_RESULTS_BASE + \"\\\"\",\n                    \"/cmd\", // NON-NLS\n                    \"\\\"\" + tempFilePath.toFile() + \"\\\"\",\n                    \"search\");  // NON-NLS\n\n            // Add environment variable to force PhotoRec to run with the same permissions Autopsy uses\n            processAndSettings.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\"); //NON-NLS\n            processAndSettings.redirectErrorStream(true);\n            processAndSettings.redirectOutput(Redirect.appendTo(log));\n\n            FileIngestModuleProcessTerminator terminator = new FileIngestModuleProcessTerminator(this.context, true);\n            int exitValue = ExecUtil.execute(processAndSettings, terminator);\n\n            if (this.context.fileIngestIsCancelled() == true) {\n                // if it was cancelled by the user, result is OK\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.INFO, \"PhotoRec cancelled by user\"); // NON-NLS\n                MessageNotifyUtil.Notify.info(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.cancelledByUser\"));\n                return IngestModule.ProcessResult.OK;\n            } else if (terminator.getTerminationCode() == ProcTerminationCode.TIME_OUT) {\n                cleanup(outputDirPath, tempFilePath);\n                String msg = NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.processTerminated\") + file.getName(); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.moduleError\"), msg); // NON-NLS                \n                logger.log(Level.SEVERE, msg);\n                return IngestModule.ProcessResult.ERROR;\n            } else if (0 != exitValue) {\n                // if it failed or was cancelled by timeout, result is ERROR\n                cleanup(outputDirPath, tempFilePath);\n                totals.totalItemsWithErrors.incrementAndGet();\n                logger.log(Level.SEVERE, \"PhotoRec carver returned error exit value = {0} when scanning {1}\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.exitValue\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Move carver log file to avoid placement into Autopsy results. PhotoRec appends \".1\" to the folder name.\n            java.io.File oldAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_RESULTS_EXTENDED, PHOTOREC_REPORT).toString()); //NON-NLS\n            java.io.File newAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_REPORT).toString()); //NON-NLS\n            oldAuditFile.renameTo(newAuditFile);\n\n            Path pathToRemove = Paths.get(outputDirPath.toAbsolutePath().toString());\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(pathToRemove)) {\n                for (Path entry : stream) {\n                    if (Files.isDirectory(entry)) {\n                        FileUtil.deleteDir(new File(entry.toString()));\n                    }\n                }\n            }\n            long writedelta = (System.currentTimeMillis() - writestart);\n            totals.totalWritetime.addAndGet(writedelta);\n\n            // Now that we've cleaned up the folders and data files, parse the xml output file to add carved items into the database\n            long calcstart = System.currentTimeMillis();\n            PhotoRecCarverOutputParser parser = new PhotoRecCarverOutputParser(outputDirPath);\n            List<LayoutFile> carvedItems = parser.parse(newAuditFile, id, file);\n            long calcdelta = (System.currentTimeMillis() - calcstart);\n            totals.totalParsetime.addAndGet(calcdelta);\n            if (carvedItems != null) { // if there were any results from carving, add the unallocated carving event to the reports list.\n                totals.totalItemsRecovered.addAndGet(carvedItems.size());\n                context.addFilesToJob(new ArrayList<>(carvedItems));\n                services.fireModuleContentEvent(new ModuleContentEvent(carvedItems.get(0))); // fire an event to update the tree\n            }\n        } catch (IOException ex) {\n            totals.totalItemsWithErrors.incrementAndGet();\n            logger.log(Level.SEVERE, \"Error processing \" + file.getName() + \" with PhotoRec carver\", ex); // NON-NLS\n            MessageNotifyUtil.Notify.error(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.msg\", file.getName()));\n            return IngestModule.ProcessResult.ERROR;\n        } finally {\n            if (null != tempFilePath && Files.exists(tempFilePath)) {\n                // Get rid of the unallocated space file.\n                tempFilePath.toFile().delete();\n            }\n        }\n        return IngestModule.ProcessResult.OK;\n\n    }","id":88078,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public IngestModule.ProcessResult process(AbstractFile file) {\n        // Skip everything except unallocated space files.\n        if (file.getType() != TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) {\n            return IngestModule.ProcessResult.OK;\n        }\n\n        // Safely get a reference to the totalsForIngestJobs object\n        IngestJobTotals totals = getTotalsForIngestJobs(jobId);\n\n        Path tempFilePath = null;\n        try {\n            long id = getRootId(file);\n            // make sure we have a valid systemID\n            if (id == -1) {\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Verify initialization succeeded.\n            if (null == this.executableFile) {\n                logger.log(Level.SEVERE, \"PhotoRec carver called after failed start up\");  // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Check that we have roughly enough disk space left to complete the operation\n            // Some network drives always return -1 for free disk space. \n            // In this case, expect enough space and move on.\n            long freeDiskSpace = IngestServices.getInstance().getFreeDiskSpace();\n            if ((freeDiskSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN) && ((file.getSize() * 1.2) > freeDiskSpace)) {\n                logger.log(Level.SEVERE, \"PhotoRec error processing {0} with {1} Not enough space on primary disk to save unallocated space.\", // NON-NLS\n                        new Object[]{file.getName(), PhotoRecCarverIngestModuleFactory.getModuleName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.UnableToCarve\", file.getName()),\n                        NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.NotEnoughDiskSpace\"));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Write the file to disk.\n            long writestart = System.currentTimeMillis();\n            WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.get(this.jobId);\n            tempFilePath = Paths.get(paths.getTempDirPath().toString(), file.getName());\n            ContentUtils.writeToFile(file, tempFilePath.toFile());\n\n            // Create a subdirectory for this file.\n            Path outputDirPath = Paths.get(paths.getOutputDirPath().toString(), file.getName());\n            Files.createDirectory(outputDirPath);\n            File log = new File(Paths.get(outputDirPath.toString(), LOG_FILE).toString()); //NON-NLS\n\n            // Scan the file with Unallocated Carver.\n            ProcessBuilder processAndSettings = new ProcessBuilder(\n                    \"\\\"\" + executableFile + \"\\\"\",\n                    \"/d\", // NON-NLS\n                    \"\\\"\" + outputDirPath.toAbsolutePath() + File.separator + PHOTOREC_RESULTS_BASE + \"\\\"\",\n                    \"/cmd\", // NON-NLS\n                    \"\\\"\" + tempFilePath.toFile() + \"\\\"\",\n                    \"search\");  // NON-NLS\n\n            // Add environment variable to force PhotoRec to run with the same permissions Autopsy uses\n            processAndSettings.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\"); //NON-NLS\n            processAndSettings.redirectErrorStream(true);\n            processAndSettings.redirectOutput(Redirect.appendTo(log));\n\n            FileIngestModuleProcessTerminator terminator = new FileIngestModuleProcessTerminator(this.context, true);\n            int exitValue = ExecUtil.execute(processAndSettings, terminator);\n\n            if (this.context.fileIngestIsCancelled() == true) {\n                // if it was cancelled by the user, result is OK\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.INFO, \"PhotoRec cancelled by user\"); // NON-NLS\n                MessageNotifyUtil.Notify.info(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.cancelledByUser\"));\n                return IngestModule.ProcessResult.OK;\n            } else if (terminator.getTerminationCode() == ProcTerminationCode.TIME_OUT) {\n                cleanup(outputDirPath, tempFilePath);\n                String msg = NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.processTerminated\") + file.getName(); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.moduleError\"), msg); // NON-NLS                \n                logger.log(Level.SEVERE, msg);\n                return IngestModule.ProcessResult.ERROR;\n            } else if (0 != exitValue) {\n                // if it failed or was cancelled by timeout, result is ERROR\n                cleanup(outputDirPath, tempFilePath);\n                totals.totalItemsWithErrors.incrementAndGet();\n                logger.log(Level.SEVERE, \"PhotoRec carver returned error exit value = {0} when scanning {1}\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.exitValue\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Move carver log file to avoid placement into Autopsy results. PhotoRec appends \".1\" to the folder name.\n            java.io.File oldAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_RESULTS_EXTENDED, PHOTOREC_REPORT).toString()); //NON-NLS\n            java.io.File newAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_REPORT).toString()); //NON-NLS\n            oldAuditFile.renameTo(newAuditFile);\n\n            Path pathToRemove = Paths.get(outputDirPath.toAbsolutePath().toString());\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(pathToRemove)) {\n                for (Path entry : stream) {\n                    if (Files.isDirectory(entry)) {\n                        FileUtil.deleteDir(new File(entry.toString()));\n                    }\n                }\n            }\n            long writedelta = (System.currentTimeMillis() - writestart);\n            totals.totalWritetime.addAndGet(writedelta);\n\n            // Now that we've cleaned up the folders and data files, parse the xml output file to add carved items into the database\n            long calcstart = System.currentTimeMillis();\n            PhotoRecCarverOutputParser parser = new PhotoRecCarverOutputParser(outputDirPath);\n            List<LayoutFile> carvedItems = parser.parse(newAuditFile, id, file, this.context);\n            long calcdelta = (System.currentTimeMillis() - calcstart);\n            totals.totalParsetime.addAndGet(calcdelta);\n            if (carvedItems != null) { // if there were any results from carving, add the unallocated carving event to the reports list.\n                totals.totalItemsRecovered.addAndGet(carvedItems.size());\n                context.addFilesToJob(new ArrayList<>(carvedItems));\n                services.fireModuleContentEvent(new ModuleContentEvent(carvedItems.get(0))); // fire an event to update the tree\n            }\n        } catch (IOException ex) {\n            totals.totalItemsWithErrors.incrementAndGet();\n            logger.log(Level.SEVERE, \"Error processing \" + file.getName() + \" with PhotoRec carver\", ex); // NON-NLS\n            MessageNotifyUtil.Notify.error(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.msg\", file.getName()));\n            return IngestModule.ProcessResult.ERROR;\n        } finally {\n            if (null != tempFilePath && Files.exists(tempFilePath)) {\n                // Get rid of the unallocated space file.\n                tempFilePath.toFile().delete();\n            }\n        }\n        return IngestModule.ProcessResult.OK;\n\n    }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Parses the given report.xml file, creating a List<LayoutFile> to return.\n     * Uses FileManager to add all carved files that it finds to the TSK\n     * database as $CarvedFiles under the passed-in parent id.\n     *\n     * @param xmlInputFile The XML file we are trying to read and parse\n     * @param id           The parent id of the unallocated space we are\n     *                     parsing.\n     * @param af           The AbstractFile representing the unallocated space\n     *                     we are parsing.\n     *\n     * @return A List<LayoutFile> containing all the files added into the\n     *         database\n     *\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    List<LayoutFile> parse(File xmlInputFile, long id, AbstractFile af) throws FileNotFoundException, IOException {\n        try {\n            final Document doc = XMLUtil.loadDoc(PhotoRecCarverOutputParser.class, xmlInputFile.toString());\n            if (doc == null) {\n                return null;\n            }\n\n            Element root = doc.getDocumentElement();\n            if (root == null) {\n                logger.log(Level.SEVERE, \"Error loading config file: invalid file format (bad root).\"); //NON-NLS\n                return null;\n            }\n\n            NodeList fileObjects = root.getElementsByTagName(\"fileobject\"); //NON-NLS\n            final int numberOfFiles = fileObjects.getLength();\n\n            if (numberOfFiles == 0) {\n                return null;\n            }\n            String fileName;\n            Long fileSize;\n            NodeList fileNames;\n            NodeList fileSizes;\n            NodeList fileRanges;\n            Element entry;\n            Path filePath;\n            FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n\n            // create and initialize the list to put into the database\n            List<CarvedFileContainer> carvedFileContainer = new ArrayList<>();\n\n            for (int fileIndex = 0; fileIndex < numberOfFiles; ++fileIndex) {\n                entry = (Element) fileObjects.item(fileIndex);\n                fileNames = entry.getElementsByTagName(\"filename\"); //NON-NLS\n                fileSizes = entry.getElementsByTagName(\"filesize\"); //NON-NLS\n                fileRanges = entry.getElementsByTagName(\"byte_run\"); //NON-NLS\n\n                fileSize = Long.parseLong(fileSizes.item(0).getTextContent());\n                fileName = fileNames.item(0).getTextContent();\n                filePath = Paths.get(fileName);\n                if (filePath.startsWith(basePath)) {\n                    fileName = filePath.getFileName().toString();\n                }\n\n                List<TskFileRange> tskRanges = new ArrayList<>();\n                for (int rangeIndex = 0; rangeIndex < fileRanges.getLength(); ++rangeIndex) {\n\n                    Long img_offset = Long.parseLong(((Element) fileRanges.item(rangeIndex)).getAttribute(\"img_offset\")); //NON-NLS\n                    Long len = Long.parseLong(((Element) fileRanges.item(rangeIndex)).getAttribute(\"len\")); //NON-NLS\n\n                    // Verify PhotoRec's output\n                    long fileByteStart = af.convertToImgOffset(img_offset);\n                    if (fileByteStart == -1) {\n                        // This better never happen... Data for this file is corrupted. Skip it.\n                        logger.log(Level.INFO, \"Error while parsing PhotoRec output for file {0}\", fileName); //NON-NLS\n                        continue;\n                    }\n\n                    // check that carved file is within unalloc block\n                    long fileByteEnd = img_offset + len;\n                    if (fileByteEnd > af.getSize()) {\n                        long overshoot = fileByteEnd - af.getSize();\n                        if (fileSize > overshoot) {\n                            fileSize = fileSize - overshoot;\n                        } else {\n                            // This better never happen... Data for this file is corrupted. Skip it.\n                            continue;\n                        }\n                    }\n\n                    tskRanges.add(new TskFileRange(fileByteStart, len, rangeIndex));\n                }\n\n                if (!tskRanges.isEmpty()) {\n                    carvedFileContainer.add(new CarvedFileContainer(fileName, fileSize, id, tskRanges));\n                }\n            }\n            return fileManager.addCarvedFiles(carvedFileContainer);\n        } catch (NumberFormatException | TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Error parsing PhotoRec output and inserting it into the database: {0}\", ex); //NON-NLS\n        }\n\n        List<LayoutFile> empty = Collections.emptyList();\n        return empty;\n    }","id":88079,"modified_method":"/**\n     * Parses the given report.xml file, creating a List<LayoutFile> to return.\n     * Uses FileManager to add all carved files that it finds to the TSK\n     * database as $CarvedFiles under the passed-in parent id.\n     *\n     * @param xmlInputFile The XML file we are trying to read and parse\n     * @param id           The parent id of the unallocated space we are\n     *                     parsing.\n     * @param af           The AbstractFile representing the unallocated space\n     *                     we are parsing.\n     *\n     * @return A List<LayoutFile> containing all the files added into the\n     *         database\n     *\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    List<LayoutFile> parse(File xmlInputFile, long id, AbstractFile af, IngestJobContext context) throws FileNotFoundException, IOException {\n        try {\n            final Document doc = XMLUtil.loadDoc(PhotoRecCarverOutputParser.class, xmlInputFile.toString());\n            if (doc == null) {\n                return null;\n            }\n\n            Element root = doc.getDocumentElement();\n            if (root == null) {\n                logger.log(Level.SEVERE, \"Error loading config file: invalid file format (bad root).\"); //NON-NLS\n                return null;\n            }\n\n            NodeList fileObjects = root.getElementsByTagName(\"fileobject\"); //NON-NLS\n            final int numberOfFiles = fileObjects.getLength();\n\n            if (numberOfFiles == 0) {\n                return null;\n            }\n            String fileName;\n            Long fileSize;\n            NodeList fileNames;\n            NodeList fileSizes;\n            NodeList fileRanges;\n            Element entry;\n            Path filePath;\n            FileManager fileManager = Case.getCurrentCase().getServices().getFileManager();\n\n            // create and initialize the list to put into the database\n            List<CarvedFileContainer> carvedFileContainer = new ArrayList<>();\n\n            for (int fileIndex = 0; fileIndex < numberOfFiles; ++fileIndex) {\n                if (context.fileIngestIsCancelled()) {\n                    return fileManager.addCarvedFiles(carvedFileContainer);\n                }\n                entry = (Element) fileObjects.item(fileIndex);\n                fileNames = entry.getElementsByTagName(\"filename\"); //NON-NLS\n                fileSizes = entry.getElementsByTagName(\"filesize\"); //NON-NLS\n                fileRanges = entry.getElementsByTagName(\"byte_run\"); //NON-NLS\n\n                fileSize = Long.parseLong(fileSizes.item(0).getTextContent());\n                fileName = fileNames.item(0).getTextContent();\n                filePath = Paths.get(fileName);\n                if (filePath.startsWith(basePath)) {\n                    fileName = filePath.getFileName().toString();\n                }\n\n                List<TskFileRange> tskRanges = new ArrayList<>();\n                for (int rangeIndex = 0; rangeIndex < fileRanges.getLength(); ++rangeIndex) {\n\n                    Long img_offset = Long.parseLong(((Element) fileRanges.item(rangeIndex)).getAttribute(\"img_offset\")); //NON-NLS\n                    Long len = Long.parseLong(((Element) fileRanges.item(rangeIndex)).getAttribute(\"len\")); //NON-NLS\n\n                    // Verify PhotoRec's output\n                    long fileByteStart = af.convertToImgOffset(img_offset);\n                    if (fileByteStart == -1) {\n                        // This better never happen... Data for this file is corrupted. Skip it.\n                        logger.log(Level.INFO, \"Error while parsing PhotoRec output for file {0}\", fileName); //NON-NLS\n                        continue;\n                    }\n\n                    // check that carved file is within unalloc block\n                    long fileByteEnd = img_offset + len;\n                    if (fileByteEnd > af.getSize()) {\n                        long overshoot = fileByteEnd - af.getSize();\n                        if (fileSize > overshoot) {\n                            fileSize = fileSize - overshoot;\n                        } else {\n                            // This better never happen... Data for this file is corrupted. Skip it.\n                            continue;\n                        }\n                    }\n\n                    tskRanges.add(new TskFileRange(fileByteStart, len, rangeIndex));\n                }\n\n                if (!tskRanges.isEmpty()) {\n                    carvedFileContainer.add(new CarvedFileContainer(fileName, fileSize, id, tskRanges));\n                }\n            }\n            return fileManager.addCarvedFiles(carvedFileContainer);\n        } catch (NumberFormatException | TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Error parsing PhotoRec output and inserting it into the database: {0}\", ex); //NON-NLS\n        }\n\n        List<LayoutFile> empty = Collections.emptyList();\n        return empty;\n    }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public boolean index(AbstractFile sourceFile, IngestJobContext context) throws IngesterException {\n        this.sourceFile = sourceFile;\n        this.numChunks = 0; //unknown until indexing is done\n        boolean success = false;\n\n        final boolean extractUTF8\n                = Boolean.parseBoolean(extractOptions.get(TextExtractor.ExtractOptions.EXTRACT_UTF8.toString()));\n\n        final boolean extractUTF16\n                = Boolean.parseBoolean(extractOptions.get(TextExtractor.ExtractOptions.EXTRACT_UTF16.toString()));\n\n        if (extractUTF8 == false && extractUTF16 == false) {\n            //nothing to do\n            return true;\n        }\n\n        InputStream stringStream;\n        //check which extract stream to use\n        if (extractScripts.size() == 1 && extractScripts.get(0).equals(SCRIPT.LATIN_1)) {\n            //optimal for english, english only\n            stringStream = new AbstractFileStringStream(sourceFile, INDEX_CHARSET);\n        } else {\n            stringStream = new AbstractFileStringIntStream(\n                    sourceFile, extractScripts, extractUTF8, extractUTF16, INDEX_CHARSET);\n        }\n\n        try {\n            success = true;\n            //break input stream into chunks \n\n            final byte[] stringChunkBuf = new byte[(int) MAX_STRING_CHUNK_SIZE];\n            long readSize;\n            while ((readSize = stringStream.read(stringChunkBuf, BOM_LEN, (int) MAX_STRING_CHUNK_SIZE - BOM_LEN)) != -1) {\n                if (context.fileIngestIsCancelled()) {\n                    try {\n                        stringStream.close();\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Error closing input stream stream, file: \" + sourceFile.getName(), ex); //NON-NLS\n                    }\n                    return false;\n                }\n                //FileOutputStream debug = new FileOutputStream(\"c:\\\\temp\\\\\" + sourceFile.getName() + Integer.toString(this.numChunks+1));\n                //debug.write(stringChunkBuf, 0, (int)readSize);\n\n                AbstractFileChunk chunk = new AbstractFileChunk(this, this.numChunks + 1);\n\n                try {\n                    chunk.index(ingester, stringChunkBuf, readSize + BOM_LEN, INDEX_CHARSET);\n                    ++this.numChunks;\n                } catch (IngesterException ingEx) {\n                    success = false;\n                    logger.log(Level.WARNING, \"Ingester had a problem with extracted strings from file '\" + sourceFile.getName() + \"' (id: \" + sourceFile.getId() + \").\", ingEx); //NON-NLS\n                    throw ingEx; //need to rethrow/return to signal error and move on\n                }\n\n                //debug.close();    \n            }\n\n            //after all chunks, ingest the parent file without content itself, and store numChunks\n            ingester.ingest(this);\n\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Unable to read input stream to divide and send to Solr, file: \" + sourceFile.getName(), ex); //NON-NLS\n            success = false;\n        } finally {\n            try {\n                stringStream.close();\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Error closing input stream stream, file: \" + sourceFile.getName(), ex); //NON-NLS\n            }\n        }\n\n        return success;\n    }","id":88080,"modified_method":"@Override\n    public boolean index(AbstractFile sourceFile, IngestJobContext context) throws IngesterException {\n        this.sourceFile = sourceFile;\n        this.numChunks = 0; //unknown until indexing is done\n        boolean success = false;\n\n        final boolean extractUTF8\n                = Boolean.parseBoolean(extractOptions.get(TextExtractor.ExtractOptions.EXTRACT_UTF8.toString()));\n\n        final boolean extractUTF16\n                = Boolean.parseBoolean(extractOptions.get(TextExtractor.ExtractOptions.EXTRACT_UTF16.toString()));\n\n        if (extractUTF8 == false && extractUTF16 == false) {\n            //nothing to do\n            return true;\n        }\n\n        InputStream stringStream;\n        //check which extract stream to use\n        if (extractScripts.size() == 1 && extractScripts.get(0).equals(SCRIPT.LATIN_1)) {\n            //optimal for english, english only\n            stringStream = new AbstractFileStringStream(sourceFile, INDEX_CHARSET);\n        } else {\n            stringStream = new AbstractFileStringIntStream(\n                    sourceFile, extractScripts, extractUTF8, extractUTF16, INDEX_CHARSET);\n        }\n\n        try {\n            success = true;\n            //break input stream into chunks \n\n            final byte[] stringChunkBuf = new byte[(int) MAX_STRING_CHUNK_SIZE];\n            long readSize;\n            while ((readSize = stringStream.read(stringChunkBuf, BOM_LEN, (int) MAX_STRING_CHUNK_SIZE - BOM_LEN)) != -1) {\n                if (context.fileIngestIsCancelled()) {\n                    try {\n                        stringStream.close();\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Error closing input stream stream, file: \" + sourceFile.getName(), ex); //NON-NLS\n                    }\n                    return false;\n                }\n                //FileOutputStream debug = new FileOutputStream(\"c:\\\\temp\\\\\" + sourceFile.getName() + Integer.toString(this.numChunks+1));\n                //debug.write(stringChunkBuf, 0, (int)readSize);\n\n                AbstractFileChunk chunk = new AbstractFileChunk(this, this.numChunks + 1);\n\n                try {\n                    chunk.index(ingester, stringChunkBuf, readSize + BOM_LEN, INDEX_CHARSET);\n                    ++this.numChunks;\n                } catch (IngesterException ingEx) {\n                    success = false;\n                    logger.log(Level.WARNING, \"Ingester had a problem with extracted strings from file '\" + sourceFile.getName() + \"' (id: \" + sourceFile.getId() + \").\", ingEx); //NON-NLS\n                    throw ingEx; //need to rethrow/return to signal error and move on\n                }\n\n                //debug.close();    \n            }\n\n            if (!context.fileIngestIsCancelled()) {\n                //after all chunks, ingest the parent file without content itself, and store numChunks\n                ingester.ingest(this);\n            }\n\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Unable to read input stream to divide and send to Solr, file: \" + sourceFile.getName(), ex); //NON-NLS\n            success = false;\n        } finally {\n            try {\n                stringStream.close();\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Error closing input stream stream, file: \" + sourceFile.getName(), ex); //NON-NLS\n            }\n        }\n\n        return success;\n    }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public boolean index(AbstractFile sourceFile, IngestJobContext context) throws Ingester.IngesterException {\n        this.sourceFile = sourceFile;\n        numChunks = 0; //unknown until indexing is done\n\n        boolean success = false;\n        Reader reader = null;\n        final InputStream stream = new ReadContentInputStream(sourceFile);\n        try {\n            Metadata meta = new Metadata();\n\n            //Parse the file in a task\n            Tika tika = new Tika(); //new tika instance for every file, to workaround tika memory issues\n            ParseRequestTask parseTask = new ParseRequestTask(tika, stream, meta, sourceFile);\n            final Future<?> future = tikaParseExecutor.submit(parseTask);\n            try {\n                future.get(Ingester.getTimeout(sourceFile.getSize()), TimeUnit.SECONDS);\n            } catch (TimeoutException te) {\n                final String msg = NbBundle.getMessage(this.getClass(),\n                        \"AbstractFileTikaTextExtract.index.tikaParseTimeout.text\",\n                        sourceFile.getId(), sourceFile.getName());\n                KeywordSearch.getTikaLogger().log(Level.WARNING, msg, te);\n                logger.log(Level.WARNING, msg);\n                throw new IngesterException(msg);\n            } catch (Exception ex) {\n                final String msg = NbBundle.getMessage(this.getClass(),\n                        \"AbstractFileTikaTextExtract.index.exception.tikaParse.msg\",\n                        sourceFile.getId(), sourceFile.getName());\n                KeywordSearch.getTikaLogger().log(Level.WARNING, msg, ex);\n                logger.log(Level.WARNING, msg);\n                throw new IngesterException(msg);\n            }\n\n            // get the reader with the results\n            reader = parseTask.getReader();\n            if (reader == null) {\n                //likely due to exception in parse()\n                logger.log(Level.WARNING, \"No reader available from Tika parse\"); //NON-NLS\n                return false;\n            }\n\n            // break the results into chunks and index\n            success = true;\n            long readSize;\n            long totalRead = 0;\n            boolean eof = false;\n            //we read max 1024 chars at time, this seems to max what this Reader would return\n            while (!eof) {\n                readSize = reader.read(textChunkBuf, 0, SINGLE_READ_CHARS);\n                if (readSize == -1) {\n                    eof = true;\n                } else {\n                    totalRead += readSize;\n                }\n                //consume more bytes to fill entire chunk (leave EXTRA_CHARS to end the word)\n                while (!eof && (totalRead < MAX_EXTR_TEXT_CHARS - SINGLE_READ_CHARS - EXTRA_CHARS)\n                        && (readSize = reader.read(textChunkBuf, (int) totalRead, SINGLE_READ_CHARS)) != -1) {\n                    totalRead += readSize;\n                }\n                if (readSize == -1) {\n                    //this is the last chunk\n                    eof = true;\n                } else {\n                    //try to read char-by-char until whitespace to not break words\n                    while ((totalRead < MAX_EXTR_TEXT_CHARS - 1)\n                            && !Character.isWhitespace(textChunkBuf[(int) totalRead - 1])\n                            && (readSize = reader.read(textChunkBuf, (int) totalRead, 1)) != -1) {\n                        totalRead += readSize;\n                    }\n                    if (readSize == -1) {\n                        //this is the last chunk\n                        eof = true;\n                    }\n                }\n\n                // Sanitize by replacing non-UTF-8 characters with caret '^'\n                for (int i = 0; i < totalRead; ++i) {\n                    if (!isValidSolrUTF8(textChunkBuf[i])) {\n                        textChunkBuf[i] = '^';\n                    }\n                }\n\n                StringBuilder sb = new StringBuilder((int) totalRead + 1000);\n                sb.append(textChunkBuf, 0, (int) totalRead);\n\n                //reset for next chunk\n                totalRead = 0;\n\n                //append meta data if last chunk\n                if (eof) {\n                    //sort meta data keys\n                    List<String> sortedKeyList = Arrays.asList(meta.names());\n                    Collections.sort(sortedKeyList);\n                    sb.append(\"\\n\\n------------------------------METADATA------------------------------\\n\\n\"); //NON-NLS\n                    for (String key : sortedKeyList) {\n                        String value = meta.get(key);\n                        sb.append(key).append(\": \").append(value).append(\"\\n\");\n                    }\n                }\n\n                // Encode from UTF-8 charset to bytes\n                byte[] encodedBytes = sb.toString().getBytes(OUTPUT_CHARSET);\n                AbstractFileChunk chunk = new AbstractFileChunk(this, this.numChunks + 1);\n                try {\n                    chunk.index(ingester, encodedBytes, encodedBytes.length, OUTPUT_CHARSET);\n                    ++this.numChunks;\n                } catch (Ingester.IngesterException ingEx) {\n                    success = false;\n                    logger.log(Level.WARNING, \"Ingester had a problem with extracted strings from file '\" //NON-NLS\n                            + sourceFile.getName() + \"' (id: \" + sourceFile.getId() + \").\", ingEx); //NON-NLS\n                    throw ingEx; //need to rethrow/return to signal error and move on\n                }\n            }\n        } catch (IOException ex) {\n            final String msg = \"Exception: Unable to read Tika content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(); //NON-NLS\n            KeywordSearch.getTikaLogger().log(Level.WARNING, msg, ex);\n            logger.log(Level.WARNING, msg);\n            success = false;\n        } catch (Exception ex) {\n            final String msg = \"Exception: Unexpected error, can't read Tika content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(); //NON-NLS\n            KeywordSearch.getTikaLogger().log(Level.WARNING, msg, ex);\n            logger.log(Level.WARNING, msg);\n            success = false;\n        } finally {\n            try {\n                stream.close();\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close Tika content stream from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close content reader from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n        }\n\n        //after all chunks, ingest the parent file without content itself, and store numChunks\n        ingester.ingest(this);\n\n        return success;\n    }","id":88081,"modified_method":"@Override\n    public boolean index(AbstractFile sourceFile, IngestJobContext context) throws Ingester.IngesterException {\n        this.sourceFile = sourceFile;\n        numChunks = 0; //unknown until indexing is done\n\n        boolean success = false;\n        Reader reader = null;\n        final InputStream stream = new ReadContentInputStream(sourceFile);\n        try {\n            Metadata meta = new Metadata();\n\n            //Parse the file in a task\n            Tika tika = new Tika(); //new tika instance for every file, to workaround tika memory issues\n            ParseRequestTask parseTask = new ParseRequestTask(tika, stream, meta, sourceFile);\n            final Future<?> future = tikaParseExecutor.submit(parseTask);\n            try {\n                future.get(Ingester.getTimeout(sourceFile.getSize()), TimeUnit.SECONDS);\n            } catch (TimeoutException te) {\n                final String msg = NbBundle.getMessage(this.getClass(),\n                        \"AbstractFileTikaTextExtract.index.tikaParseTimeout.text\",\n                        sourceFile.getId(), sourceFile.getName());\n                KeywordSearch.getTikaLogger().log(Level.WARNING, msg, te);\n                logger.log(Level.WARNING, msg);\n                throw new IngesterException(msg);\n            } catch (Exception ex) {\n                final String msg = NbBundle.getMessage(this.getClass(),\n                        \"AbstractFileTikaTextExtract.index.exception.tikaParse.msg\",\n                        sourceFile.getId(), sourceFile.getName());\n                KeywordSearch.getTikaLogger().log(Level.WARNING, msg, ex);\n                logger.log(Level.WARNING, msg);\n                throw new IngesterException(msg);\n            }\n\n            // get the reader with the results\n            reader = parseTask.getReader();\n            if (reader == null) {\n                //likely due to exception in parse()\n                logger.log(Level.WARNING, \"No reader available from Tika parse\"); //NON-NLS\n                return false;\n            }\n\n            // break the results into chunks and index\n            success = true;\n            long readSize;\n            long totalRead = 0;\n            boolean eof = false;\n            //we read max 1024 chars at time, this seems to max what this Reader would return\n            while (!eof) {\n                if (context.fileIngestIsCancelled()) {\n                    try {\n                        stream.close();\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Unable to close Tika content stream from \" + sourceFile.getId(), ex); //NON-NLS\n                    }\n                    try {\n                        if (reader != null) {\n                            reader.close();\n                        }\n                    } catch (IOException ex) {\n                        logger.log(Level.WARNING, \"Unable to close content reader from \" + sourceFile.getId(), ex); //NON-NLS\n                    }\n                }\n                readSize = reader.read(textChunkBuf, 0, SINGLE_READ_CHARS);\n                if (readSize == -1) {\n                    eof = true;\n                } else {\n                    totalRead += readSize;\n                }\n                //consume more bytes to fill entire chunk (leave EXTRA_CHARS to end the word)\n                while (!eof && (totalRead < MAX_EXTR_TEXT_CHARS - SINGLE_READ_CHARS - EXTRA_CHARS)\n                        && (readSize = reader.read(textChunkBuf, (int) totalRead, SINGLE_READ_CHARS)) != -1) {\n                    totalRead += readSize;\n                }\n                if (readSize == -1) {\n                    //this is the last chunk\n                    eof = true;\n                } else {\n                    //try to read char-by-char until whitespace to not break words\n                    while ((totalRead < MAX_EXTR_TEXT_CHARS - 1)\n                            && !Character.isWhitespace(textChunkBuf[(int) totalRead - 1])\n                            && (readSize = reader.read(textChunkBuf, (int) totalRead, 1)) != -1) {\n                        totalRead += readSize;\n                    }\n                    if (readSize == -1) {\n                        //this is the last chunk\n                        eof = true;\n                    }\n                }\n\n                // Sanitize by replacing non-UTF-8 characters with caret '^'\n                for (int i = 0; i < totalRead; ++i) {\n                    if (!isValidSolrUTF8(textChunkBuf[i])) {\n                        textChunkBuf[i] = '^';\n                    }\n                }\n\n                StringBuilder sb = new StringBuilder((int) totalRead + 1000);\n                sb.append(textChunkBuf, 0, (int) totalRead);\n\n                //reset for next chunk\n                totalRead = 0;\n\n                //append meta data if last chunk\n                if (eof) {\n                    //sort meta data keys\n                    List<String> sortedKeyList = Arrays.asList(meta.names());\n                    Collections.sort(sortedKeyList);\n                    sb.append(\"\\n\\n------------------------------METADATA------------------------------\\n\\n\"); //NON-NLS\n                    for (String key : sortedKeyList) {\n                        String value = meta.get(key);\n                        sb.append(key).append(\": \").append(value).append(\"\\n\");\n                    }\n                }\n\n                // Encode from UTF-8 charset to bytes\n                byte[] encodedBytes = sb.toString().getBytes(OUTPUT_CHARSET);\n                AbstractFileChunk chunk = new AbstractFileChunk(this, this.numChunks + 1);\n                try {\n                    chunk.index(ingester, encodedBytes, encodedBytes.length, OUTPUT_CHARSET);\n                    ++this.numChunks;\n                } catch (Ingester.IngesterException ingEx) {\n                    success = false;\n                    logger.log(Level.WARNING, \"Ingester had a problem with extracted strings from file '\" //NON-NLS\n                            + sourceFile.getName() + \"' (id: \" + sourceFile.getId() + \").\", ingEx); //NON-NLS\n                    throw ingEx; //need to rethrow/return to signal error and move on\n                }\n            }\n        } catch (IOException ex) {\n            final String msg = \"Exception: Unable to read Tika content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(); //NON-NLS\n            KeywordSearch.getTikaLogger().log(Level.WARNING, msg, ex);\n            logger.log(Level.WARNING, msg);\n            success = false;\n        } catch (Exception ex) {\n            final String msg = \"Exception: Unexpected error, can't read Tika content stream from \" + sourceFile.getId() + \": \" + sourceFile.getName(); //NON-NLS\n            KeywordSearch.getTikaLogger().log(Level.WARNING, msg, ex);\n            logger.log(Level.WARNING, msg);\n            success = false;\n        } finally {\n            try {\n                stream.close();\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close Tika content stream from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n            try {\n                if (reader != null) {\n                    reader.close();\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Unable to close content reader from \" + sourceFile.getId(), ex); //NON-NLS\n            }\n        }\n\n        //after all chunks, ingest the parent file without content itself, and store numChunks\n        if (!context.fileIngestIsCancelled()) {\n            ingester.ingest(this);\n        }\n\n        return success;\n    }","commit_id":"c04183b41ffc324bf27aeb41cd00e2f3cd5961a0","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void dispatch(MethodInvocation invocation) {\n        List<Throwable> failures = new ArrayList<Throwable>();\n        for (Dispatch<MethodInvocation> handler : getHandlers()) {\n            try {\n                handler.dispatch(invocation);\n            } catch (UncheckedException e) {\n                failures.add(e.getCause());\n            } catch (Throwable t) {\n                failures.add(t);\n            }\n        }\n        if (failures.size() == 1 && failures.get(0) instanceof RuntimeException) {\n            throw (RuntimeException) failures.get(0);\n        }\n        if (!failures.isEmpty()) {\n            throw new ListenerNotificationException(getErrorMessage(), failures);\n        }\n    }","id":88082,"modified_method":"protected void dispatch(MethodInvocation invocation, Iterator<? extends Dispatch<MethodInvocation>> handlers) {\n        List<Throwable> failures = new ArrayList<Throwable>();\n        while (handlers.hasNext()) {\n            Dispatch<MethodInvocation> handler = handlers.next();\n            try {\n                handler.dispatch(invocation);\n            } catch (UncheckedException e) {\n                failures.add(e.getCause());\n            } catch (Throwable t) {\n                failures.add(t);\n            }\n        }\n        if (failures.size() == 1 && failures.get(0) instanceof RuntimeException) {\n            throw (RuntimeException) failures.get(0);\n        }\n        if (!failures.isEmpty()) {\n            throw new ListenerNotificationException(getErrorMessage(), failures);\n        }\n    }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"public void useLogger(Object logger) {\n        synchronized (lock) {\n            if (allLoggers.add(logger)) {\n                for (EventBroadcast<?> broadcaster : broadcasters.values()) {\n                    broadcaster.maybeSetLogger(logger);\n                }\n            }\n        }\n    }","id":88083,"modified_method":"public void useLogger(Object logger) {\n        synchronized (lock) {\n            if (!allLoggers.containsKey(logger)) {\n                ListenerDetails details = new ListenerDetails(logger);\n                allLoggers.put(logger, details);\n                for (EventBroadcast<?> broadcaster : broadcasters.values()) {\n                    broadcaster.maybeSetLogger(details);\n                }\n            }\n        }\n    }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n            public void dispatch(MethodInvocation invocation) {\n                synchronized (lock) {\n                    super.dispatch(invocation);\n                }\n            }","id":88084,"modified_method":"@Override\n            public void dispatch(MethodInvocation invocation) {\n                Iterator<Dispatch<MethodInvocation>> dispatchers = startNotification(includeLogger);\n                try {\n                    dispatch(invocation, dispatchers);\n                } finally {\n                    endNotification();\n                }\n            }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"public void removeListener(Object listener) {\n        synchronized (lock) {\n            if (allListeners.remove(listener)) {\n                for (EventBroadcast<?> broadcaster : broadcasters.values()) {\n                    broadcaster.maybeRemove(listener);\n                }\n            }\n        }\n    }","id":88085,"modified_method":"public void removeListener(Object listener) {\n        synchronized (lock) {\n            ListenerDetails details = allListeners.remove(listener);\n            if (details != null) {\n                details.remove();\n                for (EventBroadcast<?> broadcaster : broadcasters.values()) {\n                    broadcaster.maybeRemove(details);\n                }\n            }\n        }\n    }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"EventBroadcast(Class<T> type) {\n            this.type = type;\n            dispatch = new ListenerDispatch(type, dispatchers);\n            dispatchNoLogger = new ListenerDispatch(type, dispatchersNoLogger);\n            if (parent != null) {\n                parentDispatch = parent.getBroadcasterInternal(type).getDispatch(true);\n            }\n            rebuild();\n            source = new ProxyDispatchAdapter<T>(dispatch, type);\n        }","id":88086,"modified_method":"EventBroadcast(Class<T> type) {\n            this.type = type;\n            dispatch = new ListenerDispatch(type, true);\n            dispatchNoLogger = new ListenerDispatch(type, false);\n            if (parent != null) {\n                parentDispatch = parent.getBroadcasterInternal(type).getDispatch(true);\n            }\n            source = new ProxyDispatchAdapter<T>(dispatch, type);\n        }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"public void addListener(Object listener) {\n        synchronized (lock) {\n            if (allListeners.add(listener)) {\n                for (EventBroadcast<?> broadcaster : broadcasters.values()) {\n                    broadcaster.maybeAdd(listener);\n                }\n            }\n        }\n    }","id":88087,"modified_method":"public void addListener(Object listener) {\n        synchronized (lock) {\n            if (!allListeners.containsKey(listener)) {\n                ListenerDetails details = new ListenerDetails(listener);\n                allListeners.put(listener, details);\n                for (EventBroadcast<?> broadcaster : broadcasters.values()) {\n                    broadcaster.maybeAdd(details);\n                }\n            }\n        }\n    }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> EventBroadcast<T> getBroadcasterInternal(Class<T> listenerClass) {\n        synchronized (lock) {\n            EventBroadcast<T> broadcaster = broadcasters.get(listenerClass);\n            if (broadcaster == null) {\n                broadcaster = new EventBroadcast<T>(listenerClass);\n                broadcasters.put(listenerClass, broadcaster);\n                for (Object listener : allListeners) {\n                    broadcaster.maybeAdd(listener);\n                }\n                for (Object logger : allLoggers) {\n                    broadcaster.maybeSetLogger(logger);\n                }\n            }\n            return broadcaster;\n        }\n    }","id":88088,"modified_method":"private <T> EventBroadcast<T> getBroadcasterInternal(Class<T> listenerClass) {\n        synchronized (lock) {\n            EventBroadcast<T> broadcaster = broadcasters.get(listenerClass);\n            if (broadcaster == null) {\n                broadcaster = new EventBroadcast<T>(listenerClass);\n                broadcasters.put(listenerClass, broadcaster);\n                for (ListenerDetails listener : allListeners.values()) {\n                    broadcaster.maybeAdd(listener);\n                }\n                for (ListenerDetails logger : allLoggers.values()) {\n                    broadcaster.maybeSetLogger(logger);\n                }\n            }\n            return broadcaster;\n        }\n    }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"public ListenerDispatch(Class<T> type, List<Dispatch<MethodInvocation>> dispatchers) {\n                super(type);\n                this.dispatchers = dispatchers;\n            }","id":88089,"modified_method":"public ListenerDispatch(Class<T> type, boolean includeLogger) {\n                super(type);\n                this.includeLogger = includeLogger;\n            }","commit_id":"14fa807164b09bdc642155f2b5c97546c0f648af","url":"https://github.com/gradle/gradle"},{"original_method":"public void validate(ProblemReporter problemReporter) {\n\t\t// An @Bean method may only be overloaded through inheritance. No single\n\t\t// @Configuration class may declare two @Bean methods with the same name.\n\t\tfinal char hashDelim = '#';\n\t\tMap<String, Integer> methodNameCounts = new HashMap<String, Integer>();\n\t\tfor (BeanMethod beanMethod : beanMethods) {\n\t\t\tString dClassName = beanMethod.getMetadata().getDeclaringClassName();\n\t\t\tString methodName = beanMethod.getMetadata().getMethodName();\n\t\t\tString fqMethodName = dClassName + hashDelim + methodName;\n\t\t\tInteger currentCount = methodNameCounts.get(fqMethodName);\n\t\t\tint newCount = currentCount != null ? currentCount + 1 : 1;\n\t\t\tmethodNameCounts.put(fqMethodName, newCount);\n\t\t}\n\n\t\tfor (String methodName : methodNameCounts.keySet()) {\n\t\t\tint count = methodNameCounts.get(methodName);\n\t\t\tif (count > 1) {\n\t\t\t\tString shortMethodName = methodName.substring(methodName.indexOf(hashDelim)+1);\n\t\t\t\tproblemReporter.error(new BeanMethodOverloadingProblem(shortMethodName, count));\n\t\t\t}\n\t\t}\n\n\t\t// A configuration class may not be final (CGLIB limitation)\n\t\tif (getMetadata().isAnnotated(Configuration.class.getName())) {\n\t\t\tif (getMetadata().isFinal()) {\n\t\t\t\tproblemReporter.error(new FinalConfigurationProblem());\n\t\t\t}\n\t\t}\n\n\t\tfor (BeanMethod beanMethod : this.beanMethods) {\n\t\t\tbeanMethod.validate(problemReporter);\n\t\t}\n\t}","id":88090,"modified_method":"public void validate(ProblemReporter problemReporter) {\n\t\t// A configuration class may not be final (CGLIB limitation)\n\t\tif (getMetadata().isAnnotated(Configuration.class.getName())) {\n\t\t\tif (getMetadata().isFinal()) {\n\t\t\t\tproblemReporter.error(new FinalConfigurationProblem());\n\t\t\t}\n\t\t}\n\n\t\t// An @Bean method may only be overloaded through inheritance. No single\n\t\t// @Configuration class may declare two @Bean methods with the same name.\n\t\tMap<String, Integer> methodNameCounts = new HashMap<String, Integer>();\n\t\tfor (BeanMethod beanMethod : this.beanMethods) {\n\t\t\tString fqMethodName = beanMethod.getFullyQualifiedMethodName();\n\t\t\tInteger currentCount = methodNameCounts.get(fqMethodName);\n\t\t\tint newCount = currentCount != null ? currentCount + 1 : 1;\n\t\t\tmethodNameCounts.put(fqMethodName, newCount);\n\t\t}\n\t\tfor (String fqMethodName : methodNameCounts.keySet()) {\n\t\t\tint count = methodNameCounts.get(fqMethodName);\n\t\t\tif (count > 1) {\n\t\t\t\tString shortMethodName = ConfigurationMethod.getShortMethodName(fqMethodName);\n\t\t\t\tproblemReporter.error(new BeanMethodOverloadingProblem(shortMethodName, count));\n\t\t\t}\n\t\t}\n\n\t\tfor (BeanMethod beanMethod : this.beanMethods) {\n\t\t\tbeanMethod.validate(problemReporter);\n\t\t}\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create a new {@link ConfigurationClass} with the given name.\n\t * @param clazz the underlying {@link Class} to represent\n\t * @param beanName name of the {@code @Configuration} class bean\n\t * @throws IllegalArgumentException if beanName is null (as of Spring 3.1.1)\n\t * @see ConfigurationClass#ConfigurationClass(Class, ConfigurationClass)\n\t */\n\tpublic ConfigurationClass(Class<?> clazz, String beanName) {\n\t\tAssert.hasText(beanName, \"bean name must not be null\");\n\t\tthis.metadata = new StandardAnnotationMetadata(clazz, true);\n\t\tthis.resource = new DescriptiveResource(clazz.toString());\n\t\tthis.beanName = beanName;\n\t\tthis.importedBy = null;\n\t}","id":88091,"modified_method":"/**\n\t * Create a new {@link ConfigurationClass} with the given name.\n\t * @param clazz the underlying {@link Class} to represent\n\t * @param beanName name of the {@code @Configuration} class bean\n\t * @throws IllegalArgumentException if beanName is null (as of Spring 3.1.1)\n\t * @see ConfigurationClass#ConfigurationClass(Class, ConfigurationClass)\n\t */\n\tpublic ConfigurationClass(Class<?> clazz, String beanName) {\n\t\tAssert.hasText(beanName, \"Bean name must not be null\");\n\t\tthis.metadata = new StandardAnnotationMetadata(clazz, true);\n\t\tthis.resource = new DescriptiveResource(clazz.toString());\n\t\tthis.beanName = beanName;\n\t\tthis.importedBy = null;\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Parse the specified {@link Configuration @Configuration} class.\n\t * @param clazz the Class to parse\n\t * @param beanName must not be null (as of Spring 3.1.1)\n\t */\n\tprotected void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName));\n\t}","id":88092,"modified_method":"/**\n\t * Parse the specified {@link Configuration @Configuration} class.\n\t * @param clazz the Class to parse\n\t * @param beanName must not be null (as of Spring 3.1.1)\n\t */\n\tpublic void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName));\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ImportRegistry getImportRegistry() {\n\t\treturn this.importStack;\n\t}","id":88093,"modified_method":"ImportRegistry getImportRegistry() {\n\t\treturn this.importStack;\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ConfigurationClass getConfigurationClass() {\n\t\t\treturn configurationClass;\n\t\t}","id":88094,"modified_method":"public ConfigurationClass getConfigurationClass() {\n\t\t\treturn this.configurationClass;\n\t\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public DeferredImportSelector getImportSelector() {\n\t\t\treturn importSelector;\n\t\t}","id":88095,"modified_method":"public DeferredImportSelector getImportSelector() {\n\t\t\treturn this.importSelector;\n\t\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {\n\t\tAnnotationMetadata metadata = configClass.getMetadata();\n\n\t\tif (ConditionalAnnotationHelper.shouldSkip(configClass, this.registry,\n\t\t\t\tthis.environment, this.beanNameGenerator)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// recursively process the configuration class and its superclass hierarchy\n\t\tdo {\n\t\t\tmetadata = doProcessConfigurationClass(configClass, metadata);\n\t\t}\n\t\twhile (metadata != null);\n\n\t\tif (this.configurationClasses.contains(configClass) && configClass.getBeanName() != null) {\n\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t// Let's remove the old one and go with the new one.\n\t\t\tthis.configurationClasses.remove(configClass);\n\t\t}\n\n\t\tthis.configurationClasses.add(configClass);\n\t}","id":88096,"modified_method":"protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {\n\t\tif (ConditionalAnnotationHelper.shouldSkip(configClass, this.registry, this.environment, this.beanNameGenerator)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.configurationClasses.contains(configClass) && configClass.getBeanName() != null) {\n\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t// Let's remove the old one and go with the new one.\n\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\tfor (Iterator<ConfigurationClass> it = this.knownSuperclasses.values().iterator(); it.hasNext();) {\n\t\t\t\tif (configClass.equals(it.next())) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tAnnotationMetadata metadata = configClass.getMetadata();\n\t\tdo {\n\t\t\tmetadata = doProcessConfigurationClass(configClass, metadata);\n\t\t}\n\t\twhile (metadata != null);\n\n\t\tthis.configurationClasses.add(configClass);\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void processDeferredImportSelectors() {\n\t\tCollections.sort(this.deferredImportSelectors, DEFERRED_IMPORT_COMPARATOR);\n\t\tfor (DeferredImportSelectorHolder deferredImport : this.deferredImportSelectors) {\n\t\t\ttry {\n\t\t\t\tConfigurationClass configClass = deferredImport.getConfigurationClass();\n\t\t\t\tString[] imports = deferredImport.getImportSelector().selectImports(configClass.getMetadata());\n\t\t\t\tprocessImport(configClass, Arrays.asList(imports), false);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \", ex);\n\t\t\t}\n\t\t}\n\t\tdeferredImportSelectors.clear();\n\t}","id":88097,"modified_method":"private void processDeferredImportSelectors() {\n\t\tCollections.sort(this.deferredImportSelectors, DEFERRED_IMPORT_COMPARATOR);\n\t\tfor (DeferredImportSelectorHolder deferredImport : this.deferredImportSelectors) {\n\t\t\ttry {\n\t\t\t\tConfigurationClass configClass = deferredImport.getConfigurationClass();\n\t\t\t\tString[] imports = deferredImport.getImportSelector().selectImports(configClass.getMetadata());\n\t\t\t\tprocessImport(configClass, Arrays.asList(imports), false);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \", ex);\n\t\t\t}\n\t\t}\n\t\tthis.deferredImportSelectors.clear();\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * @return annotation metadata of superclass, null if none found or previously processed\n\t */\n\tprotected AnnotationMetadata doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n\n\t\t// recursively process any member (nested) classes first\n\t\tprocessMemberClasses(configClass, metadata);\n\n\t\t// process any @PropertySource annotations\n\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n\t\tif (propertySource != null) {\n\t\t\tprocessPropertySource(propertySource);\n\t\t}\n\n\t\t// process any @ComponentScan annotions\n\t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n\t\tif (componentScan != null) {\n\t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n\n\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// process any @Import annotations\n\n\t\tSet<Object> imports = new LinkedHashSet<Object>();\n\t\tSet<Object> visited = new LinkedHashSet<Object>();\n\t\tcollectImports(metadata, imports, visited);\n\t\tif (!imports.isEmpty()) {\n\t\t\tprocessImport(configClass, imports, true);\n\t\t}\n\n\t\t// process any @ImportResource annotations\n\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n\t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n\t\t\tString[] resources = importResource.getStringArray(\"value\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// process superclass, if any\n\t\tif (metadata.hasSuperClass()) {\n\t\t\tString superclass = metadata.getSuperClassName();\n\t\t\tif (this.knownSuperclasses.add(superclass)) {\n\t\t\t\t// superclass found, return its annotation metadata and recurse\n\t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n\t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n\t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n\t\t\t\t}\n\t\t\t\telse if (superclass.startsWith(\"java\")) {\n\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n\t\t\t\t\treturn reader.getAnnotationMetadata();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// no superclass, processing is complete\n\t\treturn null;\n\t}","id":88098,"modified_method":"/**\n\t * @return annotation metadata of superclass, {@code null} if none found or previously processed\n\t */\n\tprotected AnnotationMetadata doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n\n\t\t// recursively process any member (nested) classes first\n\t\tprocessMemberClasses(configClass, metadata);\n\n\t\t// process any @PropertySource annotations\n\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n\t\tif (propertySource != null) {\n\t\t\tprocessPropertySource(propertySource);\n\t\t}\n\n\t\t// process any @ComponentScan annotations\n\t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n\t\tif (componentScan != null) {\n\t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n\n\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// process any @Import annotations\n\t\tSet<Object> imports = new LinkedHashSet<Object>();\n\t\tSet<Object> visited = new LinkedHashSet<Object>();\n\t\tcollectImports(metadata, imports, visited);\n\t\tif (!imports.isEmpty()) {\n\t\t\tprocessImport(configClass, imports, true);\n\t\t}\n\n\t\t// process any @ImportResource annotations\n\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n\t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n\t\t\tString[] resources = importResource.getStringArray(\"value\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// process superclass, if any\n\t\tif (metadata.hasSuperClass()) {\n\t\t\tString superclass = metadata.getSuperClassName();\n\t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// superclass found, return its annotation metadata and recurse\n\t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n\t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n\t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n\t\t\t\t}\n\t\t\t\telse if (superclass.startsWith(\"java\")) {\n\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n\t\t\t\t\treturn reader.getAnnotationMetadata();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// no superclass, processing is complete\n\t\treturn null;\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic String toString() {\n\t\treturn String.format(\"[%s:name=%s,declaringClass=%s]\",\n\t\t\t\tthis.getClass().getSimpleName(), this.getMetadata().getMethodName(), this.getMetadata().getDeclaringClassName());\n\t}","id":88099,"modified_method":"@Override\n\tpublic String toString() {\n\t\treturn String.format(\"[%s:name=%s,declaringClass=%s]\",\n\t\t\t\tgetClass().getSimpleName(), getMetadata().getMethodName(), getMetadata().getDeclaringClassName());\n\t}","commit_id":"3f7007f73a3b8d660e9ff0224f1d87483650d2c2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n  public String toString() {\n    if (StringUtils.equals(mode, PastSnapshotFinderByVersion.MODE)) {\n      return String.format(\"Compare to version %s (%s)\", modeParameter, DateUtils.formatDate(getTargetDate()));\n    }\n    if (StringUtils.equals(mode, PastSnapshotFinderByDays.MODE)) {\n      String label = String.format(\"Compare over %s days (%s\", modeParameter, DateUtils.formatDate(getTargetDate()));\n      if (isRelatedToSnapshot()) {\n        label += \", analysis of \" + getDate();\n      }\n      label+=\")\";\n      return label;\n    }\n    if (StringUtils.equals(mode, CoreProperties.TIMEMACHINE_MODE_PREVIOUS_ANALYSIS)) {\n      return String.format(\"Compare to previous analysis  (%s)\", DateUtils.formatDate(getDate()));\n    }\n    if (StringUtils.equals(mode, PastSnapshotFinderByDate.MODE)) {\n      String label = \"Compare to date \" + DateUtils.formatDate(getTargetDate());\n      if (isRelatedToSnapshot()) {\n        label += String.format(\"(analysis of %s)\", DateUtils.formatDate(getDate()));\n      }\n      return label;\n    }\n    return ReflectionToStringBuilder.toString(this);\n  }","id":88100,"modified_method":"@Override\n  public String toString() {\n    if (StringUtils.equals(mode, PastSnapshotFinderByVersion.MODE)) {\n      return String.format(\"Compare to version %s (%s)\", modeParameter, DateUtils.formatDate(getTargetDate()));\n    }\n    if (StringUtils.equals(mode, PastSnapshotFinderByDays.MODE)) {\n      String label = String.format(\"Compare over %s days (%s\", modeParameter, DateUtils.formatDate(getTargetDate()));\n      if (isRelatedToSnapshot()) {\n        label += \", analysis of \" + getDate();\n      }\n      label += \")\";\n      return label;\n    }\n    if (StringUtils.equals(mode, CoreProperties.TIMEMACHINE_MODE_PREVIOUS_ANALYSIS)) {\n      String label = \"Compare to previous analysis\";\n      if (isRelatedToSnapshot()) {\n        label += String.format(\" (%s)\", DateUtils.formatDate(getDate()));\n      }\n      return label;\n    }\n    if (StringUtils.equals(mode, PastSnapshotFinderByDate.MODE)) {\n      String label = \"Compare to date \" + DateUtils.formatDate(getTargetDate());\n      if (isRelatedToSnapshot()) {\n        label += String.format(\" (analysis of %s)\", DateUtils.formatDate(getDate()));\n      }\n      return label;\n    }\n    return ReflectionToStringBuilder.toString(this);\n  }","commit_id":"86c4e9f9605139802806dbda3dd2714949c98684","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"PastSnapshot findByPreviousAnalysis(Snapshot projectSnapshot) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where createdAt<:date AND resourceId=:resourceId AND status=:status and last=:last and qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"date\", projectSnapshot.getCreatedAt())\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"last\", true)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    if (snapshots.isEmpty()) {\n      return null;\n    }\n    Snapshot snapshot = snapshots.get(0);\n    SimpleDateFormat format = new SimpleDateFormat(DateUtils.DATE_FORMAT);\n    return new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_ANALYSIS, snapshot.getCreatedAt(), snapshot).setModeParameter(format.format(snapshot.getCreatedAt()));\n  }","id":88101,"modified_method":"/**\n   * See SONAR-2428 : even if past snapshot does not exist, we should perform comparison.\n   * In this case as a value for target date we use moment just before current snapshot\n   * to be able to perform strict comparison of dates.\n   * Also note that ruby side (resource viewer) has precision in one minute.\n   */\n  PastSnapshot findByPreviousAnalysis(Snapshot projectSnapshot) {\n    String hql = \"from \" + Snapshot.class.getSimpleName()\n        + \" where createdAt<:date AND resourceId=:resourceId AND status=:status and last=:last and qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"date\", projectSnapshot.getCreatedAt())\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"last\", true)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    Snapshot snapshot;\n    Date targetDate;\n    if (snapshots.isEmpty()) {\n      snapshot = null;\n      targetDate = new Date(projectSnapshot.getCreatedAt().getTime() - 1000 * 60);\n    } else {\n      snapshot = snapshots.get(0);\n      targetDate = snapshot.getCreatedAt();\n    }\n    SimpleDateFormat format = new SimpleDateFormat(DateUtils.DATE_FORMAT);\n    return new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_ANALYSIS, targetDate, snapshot).setModeParameter(format.format(targetDate));\n  }","commit_id":"86c4e9f9605139802806dbda3dd2714949c98684","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotFindPreviousAnalysis() throws ParseException {\n    setupData(\"shouldNotFindPreviousAnalysis\");\n\n    Snapshot projectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshotFinderByPreviousAnalysis finder = new PastSnapshotFinderByPreviousAnalysis(getSession());\n\n    assertNull(finder.findByPreviousAnalysis(projectSnapshot));\n  }","id":88102,"modified_method":"@Test\n  public void shouldReturnPastSnapshotEvenWhenNoPreviousAnalysis() throws ParseException {\n    setupData(\"shouldNotFindPreviousAnalysis\");\n\n    Snapshot projectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshotFinderByPreviousAnalysis finder = new PastSnapshotFinderByPreviousAnalysis(getSession());\n\n    PastSnapshot pastSnapshot = finder.findByPreviousAnalysis(projectSnapshot);\n    assertThat(pastSnapshot.isRelatedToSnapshot(), is(false));\n    assertThat(pastSnapshot.getProjectSnapshot(), nullValue());\n    assertThat(projectSnapshot.getCreatedAt().getTime() - pastSnapshot.getTargetDate().getTime(), is(1000L * 60));\n  }","commit_id":"86c4e9f9605139802806dbda3dd2714949c98684","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"PastSnapshot findByVersion(Snapshot projectSnapshot, String version) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where version=:version AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", version)\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    if (snapshots.isEmpty()) {\n      return null;\n    }\n    Snapshot snapshot = snapshots.get(0);\n    return new PastSnapshot(MODE, snapshot.getCreatedAt(), snapshot).setModeParameter(snapshot.getVersion());\n  }","id":88103,"modified_method":"/**\n   * See comments in {@link PastSnapshotFinderByPreviousAnalysis#findByPreviousAnalysis(Snapshot)}\n   */\n  PastSnapshot findByVersion(Snapshot projectSnapshot, String version) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where version=:version AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", version)\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    Snapshot snapshot;\n    Date targetDate;\n    if (snapshots.isEmpty()) {\n      snapshot = null;\n      targetDate = new Date(projectSnapshot.getCreatedAt().getTime() - 1000 * 60);\n    } else {\n      snapshot = snapshots.get(0);\n      targetDate = snapshot.getCreatedAt();\n    }\n    return new PastSnapshot(MODE, targetDate, snapshot).setModeParameter(version);\n  }","commit_id":"86c4e9f9605139802806dbda3dd2714949c98684","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static boolean processAssignmentTarget(PsiElement element, SliceUsage parent, Processor<SliceUsage> processor) {\n    PsiElement target = getAssignmentTarget(element);\n    if (target != null) {\n      SliceUsage usage = SliceUtil.createSliceUsage(element, parent, parent.getSubstitutor());\n      return processor.process(usage);\n    }\n    return true;\n  }","id":88104,"modified_method":"private static boolean processAssignmentTarget(PsiElement element, final SliceUsage parent, final Processor<SliceUsage> processor) {\n    Pair<PsiElement, PsiSubstitutor> pair = getAssignmentTarget(element, parent);\n    if (pair != null) {\n      SliceUsage usage = SliceUtil.createSliceUsage(element, parent, pair.getSecond());\n      return processor.process(usage);\n    }\n    return true;\n  }","commit_id":"f102ef0025e244e82a33c5bf2323fbc5ca497996","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean processAssignedFrom(final PsiElement from, final PsiElement context, final SliceUsage parent,\n                                                 final Processor<SliceUsage> processor) {\n    if (from instanceof PsiLocalVariable) {\n      return ReferencesSearch.search(from).forEach(new Processor<PsiReference>() {\n        public boolean process(PsiReference reference) {\n          PsiElement element = reference.getElement();\n          if (element.getTextOffset() < context.getTextOffset()) return true;\n\n          return processAssignmentTarget(element, parent, processor);\n        }\n      });\n    }\n    if (from instanceof PsiParameter) {\n      PsiParameter parameter = (PsiParameter)from;\n      PsiElement scope = parameter.getDeclarationScope();\n      Collection<PsiParameter> parametersToAnalyze = new THashSet<PsiParameter>();\n      if (scope instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)scope;\n        int index = method.getParameterList().getParameterIndex(parameter);\n\n        Collection<PsiMethod> superMethods = new THashSet<PsiMethod>(Arrays.asList(method.findDeepestSuperMethods()));\n        superMethods.add(method);\n        for (Iterator<PsiMethod> iterator = superMethods.iterator(); iterator.hasNext(); ) {\n          SliceManager.getInstance(method.getProject()).checkCanceled();\n          PsiMethod superMethod = iterator.next();\n          if (superMethod instanceof PsiCompiledElement) {\n            iterator.remove();\n          }\n        }\n\n        final THashSet<PsiMethod> implementors = new THashSet<PsiMethod>(superMethods);\n        for (PsiMethod superMethod : superMethods) {\n          SliceManager.getInstance(method.getProject()).checkCanceled();\n          if (!OverridingMethodsSearch.search(superMethod, parent.getScope().toSearchScope(), true).forEach(new Processor<PsiMethod>() {\n            public boolean process(PsiMethod sub) {\n              SliceManager.getInstance(method.getProject()).checkCanceled();\n              implementors.add(sub);\n              return true;\n            }\n          })) return false;\n        }\n        for (PsiMethod implementor : implementors) {\n          SliceManager.getInstance(method.getProject()).checkCanceled();\n          PsiParameter[] parameters = implementor.getParameterList().getParameters();\n          if (index != -1 && index < parameters.length) {\n            parametersToAnalyze.add(parameters[index]);\n          }\n        }\n      }\n      else {\n        parametersToAnalyze.add(parameter);\n      }\n      for (final PsiParameter psiParameter : parametersToAnalyze) {\n        SliceManager.getInstance(from.getProject()).checkCanceled();\n\n        if (!ReferencesSearch.search(psiParameter).forEach(new Processor<PsiReference>() {\n          public boolean process(PsiReference reference) {\n            SliceManager.getInstance(from.getProject()).checkCanceled();\n            PsiElement element = reference.getElement();\n\n            return processAssignmentTarget(element, parent, processor);\n          }\n        })) return false;\n      }\n      return true;\n    }\n    if (from instanceof PsiField) {\n      return ReferencesSearch.search(from).forEach(new Processor<PsiReference>() {\n        public boolean process(PsiReference reference) {\n          SliceManager.getInstance(from.getProject()).checkCanceled();\n          PsiElement element = reference.getElement();\n          return processAssignmentTarget(element, parent, processor);\n        }\n      });\n    }\n\n    if (from instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)from;\n\n      Collection<PsiMethod> superMethods = new THashSet<PsiMethod>(Arrays.asList(method.findDeepestSuperMethods()));\n      superMethods.add(method);\n      final Set<PsiReference> processed = new THashSet<PsiReference>(); //usages of super method and overridden method can overlap\n      for (final PsiMethod containingMethod : superMethods) {\n        if (!MethodReferencesSearch.search(containingMethod, parent.getScope().toSearchScope(), true).forEach(new Processor<PsiReference>() {\n            public boolean process(final PsiReference reference) {\n              SliceManager.getInstance(from.getProject()).checkCanceled();\n              synchronized (processed) {\n                if (!processed.add(reference)) return true;\n              }\n              PsiElement element = reference.getElement().getParent();\n              if (element instanceof PsiCompiledElement) return true;\n\n              return processAssignmentTarget(element, parent, processor);\n            }\n          })) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","id":88105,"modified_method":"private static boolean processAssignedFrom(final PsiElement from, final PsiElement context, final SliceUsage parent,\n                                                 final Processor<SliceUsage> processor) {\n    if (from instanceof PsiLocalVariable) {\n      return searchReferencesAndProcessAssignmentTarget(from, context, parent, processor);\n    }\n    if (from instanceof PsiParameter) {\n      PsiParameter parameter = (PsiParameter)from;\n      PsiElement scope = parameter.getDeclarationScope();\n      Collection<PsiParameter> parametersToAnalyze = new THashSet<PsiParameter>();\n      if (scope instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)scope;\n        int index = method.getParameterList().getParameterIndex(parameter);\n\n        Collection<PsiMethod> superMethods = new THashSet<PsiMethod>(Arrays.asList(method.findDeepestSuperMethods()));\n        superMethods.add(method);\n        for (Iterator<PsiMethod> iterator = superMethods.iterator(); iterator.hasNext(); ) {\n          SliceManager.getInstance(method.getProject()).checkCanceled();\n          PsiMethod superMethod = iterator.next();\n          if (superMethod instanceof PsiCompiledElement) {\n            iterator.remove();\n          }\n        }\n\n        final THashSet<PsiMethod> implementors = new THashSet<PsiMethod>(superMethods);\n        for (PsiMethod superMethod : superMethods) {\n          SliceManager.getInstance(method.getProject()).checkCanceled();\n          if (!OverridingMethodsSearch.search(superMethod, parent.getScope().toSearchScope(), true).forEach(new Processor<PsiMethod>() {\n            public boolean process(PsiMethod sub) {\n              SliceManager.getInstance(method.getProject()).checkCanceled();\n              implementors.add(sub);\n              return true;\n            }\n          })) return false;\n        }\n        for (PsiMethod implementor : implementors) {\n          SliceManager.getInstance(method.getProject()).checkCanceled();\n          PsiParameter[] parameters = implementor.getParameterList().getParameters();\n          if (index != -1 && index < parameters.length) {\n            parametersToAnalyze.add(parameters[index]);\n          }\n        }\n      }\n      else {\n        parametersToAnalyze.add(parameter);\n      }\n      for (final PsiParameter psiParameter : parametersToAnalyze) {\n        SliceManager.getInstance(from.getProject()).checkCanceled();\n\n        if (!searchReferencesAndProcessAssignmentTarget(psiParameter, null, parent, processor)) return false;\n      }\n      return true;\n    }\n    if (from instanceof PsiField) {\n      return searchReferencesAndProcessAssignmentTarget(from, null, parent, processor);\n    }\n\n    if (from instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)from;\n\n      Collection<PsiMethod> superMethods = new THashSet<PsiMethod>(Arrays.asList(method.findDeepestSuperMethods()));\n      superMethods.add(method);\n      final Set<PsiReference> processed = new THashSet<PsiReference>(); //usages of super method and overridden method can overlap\n      for (final PsiMethod containingMethod : superMethods) {\n        if (!MethodReferencesSearch.search(containingMethod, parent.getScope().toSearchScope(), true).forEach(new Processor<PsiReference>() {\n            public boolean process(final PsiReference reference) {\n              SliceManager.getInstance(from.getProject()).checkCanceled();\n              synchronized (processed) {\n                if (!processed.add(reference)) return true;\n              }\n              PsiElement element = reference.getElement().getParent();\n\n              return processAssignmentTarget(element, parent, processor);\n            }\n          })) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","commit_id":"f102ef0025e244e82a33c5bf2323fbc5ca497996","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiElement getAssignmentTarget(PsiElement element) {\n    element = complexify(element);\n    PsiElement target = null;\n    //assignment\n    PsiElement parent = element.getParent();\n    if (parent instanceof PsiAssignmentExpression) {\n      PsiAssignmentExpression assignment = (PsiAssignmentExpression)parent;\n      if (element.equals(assignment.getRExpression())) {\n        PsiElement left = assignment.getLExpression();\n        if (left instanceof PsiReferenceExpression) {\n          target = ((PsiReferenceExpression)left).resolve();\n        }\n      }\n    }\n    else if (parent instanceof PsiVariable) {\n      PsiVariable variable = (PsiVariable)parent;\n\n      PsiElement initializer = variable.getInitializer();\n      if (element.equals(initializer)) {\n        target = variable;\n      }\n    }\n    //method call\n    else if (parent instanceof PsiExpressionList && parent.getParent() instanceof PsiCallExpression) {\n      PsiExpression[] expressions = ((PsiExpressionList)parent).getExpressions();\n      int index = ArrayUtil.find(expressions, element);\n      PsiCallExpression methodCall = (PsiCallExpression)parent.getParent();\n      PsiMethod method = methodCall.resolveMethod();\n      if (index != -1 && method != null) {\n        PsiParameter[] parameters = method.getParameterList().getParameters();\n        if (index < parameters.length) {\n          target = parameters[index];\n        }\n      }\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiReturnStatement statement = (PsiReturnStatement)parent;\n      if (element.equals(statement.getReturnValue())) {\n        target = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n      }\n    }\n    if (target instanceof PsiCompiledElement) {\n      target = null;\n    }\n    return target;\n  }","id":88106,"modified_method":"private static Pair<PsiElement,PsiSubstitutor> getAssignmentTarget(PsiElement element, SliceUsage parentUsage) {\n    element = complexify(element);\n    PsiElement target = null;\n    PsiSubstitutor substitutor = parentUsage.getSubstitutor();\n    //assignment\n    PsiElement parent = element.getParent();\n    if (parent instanceof PsiAssignmentExpression) {\n      PsiAssignmentExpression assignment = (PsiAssignmentExpression)parent;\n      if (element.equals(assignment.getRExpression())) {\n        PsiElement left = assignment.getLExpression();\n        if (left instanceof PsiReferenceExpression) {\n          JavaResolveResult result = ((PsiReferenceExpression)left).advancedResolve(false);\n          target = result.getElement();\n          substitutor = result.getSubstitutor();\n        }\n      }\n    }\n    else if (parent instanceof PsiVariable) {\n      PsiVariable variable = (PsiVariable)parent;\n\n      PsiElement initializer = variable.getInitializer();\n      if (element.equals(initializer)) {\n        target = variable;\n      }\n    }\n    //method call\n    else if (parent instanceof PsiExpressionList && parent.getParent() instanceof PsiCallExpression) {\n      PsiExpression[] expressions = ((PsiExpressionList)parent).getExpressions();\n      int index = ArrayUtil.find(expressions, element);\n      PsiCallExpression methodCall = (PsiCallExpression)parent.getParent();\n      JavaResolveResult result = methodCall.resolveMethodGenerics();\n      PsiMethod method = (PsiMethod)result.getElement();\n      if (index != -1 && method != null) {\n        PsiParameter[] parameters = method.getParameterList().getParameters();\n        if (index < parameters.length) {\n          target = parameters[index];\n          substitutor = result.getSubstitutor();\n        }\n      }\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiReturnStatement statement = (PsiReturnStatement)parent;\n      if (element.equals(statement.getReturnValue())) {\n        target = PsiTreeUtil.getParentOfType(statement, PsiMethod.class);\n      }\n    }\n\n    return target == null ? null : Pair.create(target, substitutor);\n  }","commit_id":"f102ef0025e244e82a33c5bf2323fbc5ca497996","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processUsagesFlownFromThe(@NotNull PsiElement element, @NotNull Processor<SliceUsage> processor, @NotNull SliceUsage parent) {\n    PsiElement target = getAssignmentTarget(element);\n    if (target != null) {\n      SliceUsage usage = SliceUtil.createSliceUsage(target, parent, parent.getSubstitutor());\n      return processor.process(usage);\n    }\n\n    if (element instanceof PsiReferenceExpression) {\n      PsiReferenceExpression ref = (PsiReferenceExpression)element;\n      PsiElement resolved = ref.resolve();\n      if (!(resolved instanceof PsiVariable)) return true;\n      final PsiVariable variable = (PsiVariable)resolved;\n      return processAssignedFrom(variable, ref, parent, processor);\n    }\n    if (element instanceof PsiVariable) {\n      return processAssignedFrom(element, element, parent, processor);\n    }\n    if (element instanceof PsiMethod) {\n      return processAssignedFrom(element, element, parent, processor);\n    }\n    return true;\n  }","id":88107,"modified_method":"public static boolean processUsagesFlownFromThe(@NotNull PsiElement element, @NotNull final Processor<SliceUsage> processor, @NotNull final SliceUsage parent) {\n    Pair<PsiElement, PsiSubstitutor> pair = getAssignmentTarget(element, parent);\n    if (pair != null) {\n      PsiElement target = pair.getFirst();\n      final PsiSubstitutor substitutor = pair.getSecond();\n      if (target instanceof PsiParameter) {\n        PsiParameter parameter = (PsiParameter)target;\n        PsiElement declarationScope = parameter.getDeclarationScope();\n        if (declarationScope instanceof PsiMethod) {\n          final PsiMethod method = (PsiMethod)declarationScope;\n          final int parameterIndex = method.getParameterList().getParameterIndex(parameter);\n\n          Processor<PsiMethod> myProcessor = new Processor<PsiMethod>() {\n            public boolean process(PsiMethod override) {\n              if (!parent.getScope().contains(override)) return true;\n              final PsiSubstitutor superSubstitutor = method == override\n                                                      ? substitutor\n                                                      : MethodSignatureUtil.getSuperMethodSignatureSubstitutor(method.getSignature(substitutor),\n                                                                                            override.getSignature(substitutor));\n\n              PsiParameter[] parameters = override.getParameterList().getParameters();\n              if (parameters.length <= parameterIndex) return true;\n              PsiParameter actualParam = parameters[parameterIndex];\n\n              SliceUsage usage = SliceUtil.createSliceUsage(actualParam, parent, superSubstitutor);\n              return processor.process(usage);\n            }\n          };\n          if (!myProcessor.process(method)) return false;\n          return OverridingMethodsSearch.search(method, parent.getScope().toSearchScope(), true).forEach(myProcessor);\n        }\n      }\n\n      SliceUsage usage = SliceUtil.createSliceUsage(target, parent, parent.getSubstitutor());\n      return processor.process(usage);\n    }\n\n    if (element instanceof PsiReferenceExpression) {\n      PsiReferenceExpression ref = (PsiReferenceExpression)element;\n      PsiElement resolved = ref.resolve();\n      if (!(resolved instanceof PsiVariable)) return true;\n      final PsiVariable variable = (PsiVariable)resolved;\n      return processAssignedFrom(variable, ref, parent, processor);\n    }\n    if (element instanceof PsiVariable) {\n      return processAssignedFrom(element, element, parent, processor);\n    }\n    if (element instanceof PsiMethod) {\n      return processAssignedFrom(element, element, parent, processor);\n    }\n    return true;\n  }","commit_id":"f102ef0025e244e82a33c5bf2323fbc5ca497996","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void registerQuickFixActions(PsiMethodCallExpression methodCall, PsiExpressionList list, HighlightInfo highlightInfo) {\n    PsiMethod method = (PsiMethod)methodCall.getMethodExpression().resolve();\n    PsiExpression[] expressions = list.getExpressions();\n    if (method == null || method.getParameterList().getParametersCount() != expressions.length) return;\n    for (int i = 0; i < expressions.length; i++) {\n      PsiExpression expression = expressions[i];\n      PsiParameter parameter = method.getParameterList().getParameters()[i];\n      PsiType expressionType = expression.getType();\n      PsiType parameterType = parameter.getType();\n      if (expressionType == null || expressionType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(expressionType) || expressionType instanceof PsiArrayType ) continue;\n      if (parameterType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(parameterType) || parameterType instanceof PsiArrayType ) continue;\n      if (parameterType.isAssignableFrom(expressionType)) continue;\n      PsiClass parameterClass = PsiUtil.resolveClassInType(parameterType);\n      PsiClass expressionClass = PsiUtil.resolveClassInType(expressionType);\n      if (parameterClass == null || expressionClass == null) continue;\n      if (parameterClass.isInheritor(expressionClass, true)) continue;\n      QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeParameterClassFix(expressionClass, (PsiClassType)parameterType));\n    }\n  }","id":88108,"modified_method":"public static void registerQuickFixActions(PsiMethodCallExpression methodCall, PsiExpressionList list, HighlightInfo highlightInfo) {\n    final JavaResolveResult result = methodCall.getMethodExpression().advancedResolve(false);\n    PsiMethod method = (PsiMethod) result.getElement();\n    final PsiSubstitutor substitutor = result.getSubstitutor();\n    PsiExpression[] expressions = list.getExpressions();\n    if (method == null || method.getParameterList().getParametersCount() != expressions.length) return;\n    for (int i = 0; i < expressions.length; i++) {\n      PsiExpression expression = expressions[i];\n      PsiParameter parameter = method.getParameterList().getParameters()[i];\n      PsiType expressionType = expression.getType();\n      PsiType parameterType = substitutor.substitute(parameter.getType());\n      if (expressionType == null || expressionType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(expressionType) || expressionType instanceof PsiArrayType ) continue;\n      if (parameterType instanceof PsiPrimitiveType || TypeConversionUtil.isNullType(parameterType) || parameterType instanceof PsiArrayType ) continue;\n      if (parameterType.isAssignableFrom(expressionType)) continue;\n      PsiClass parameterClass = PsiUtil.resolveClassInType(parameterType);\n      PsiClass expressionClass = PsiUtil.resolveClassInType(expressionType);\n      if (parameterClass == null || expressionClass == null) continue;\n      if (parameterClass.isInheritor(expressionClass, true)) continue;\n      QuickFixAction.registerQuickFixAction(highlightInfo, new ChangeParameterClassFix(expressionClass, (PsiClassType)parameterType));\n    }\n  }","commit_id":"f21951fd01581ad1012b5d786c47ddd3b57197a4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private NamesByExprInfo suggestVariableNameByExpressionPlace(PsiExpression expr, final VariableKind variableKind) {\n    if (expr.getParent() instanceof PsiExpressionList) {\n      PsiExpressionList list = (PsiExpressionList)expr.getParent();\n      PsiElement listParent = list.getParent();\n      PsiMethod method = null;\n      if (listParent instanceof PsiMethodCallExpression) {\n        method = (PsiMethod)((PsiMethodCallExpression)listParent).getMethodExpression().resolve();\n      }\n      else {\n        if (listParent instanceof PsiAnonymousClass) {\n          listParent = listParent.getParent();\n        }\n        if (listParent instanceof PsiNewExpression) {\n          method = ((PsiNewExpression)listParent).resolveConstructor();\n        }\n      }\n\n      if (method != null) {\n        final PsiElement navElement = method.getNavigationElement();\n        if (navElement instanceof PsiMethod) {\n          method = (PsiMethod)navElement;\n        }\n        PsiExpression[] expressions = list.getExpressions();\n        int index = -1;\n        for (int i = 0; i < expressions.length; i++) {\n          if (expressions[i] == expr) {\n            index = i;\n            break;\n          }\n        }\n        PsiParameter[] parms = method.getParameterList().getParameters();\n        if (index < parms.length) {\n          PsiIdentifier identifier = parms[index].getNameIdentifier();\n          if (identifier != null) {\n            String name = identifier.getText();\n            if (name != null) {\n              if (TypeConversionUtil.areTypesAssignmentCompatible(parms[index].getType(), expr)) {\n                name = variableNameToPropertyName(name, VariableKind.PARAMETER);\n                String[] names = getSuggestionsByName(name, variableKind, false);\n                if (expressions.length == 1) {\n                  final String methodName = method.getName();\n                  String[] words = NameUtil.nameToWords(methodName);\n                  if (words.length > 0) {\n                    final String firstWord = words[0];\n                    if (SET_PREFIX.equals(firstWord)) {\n                      final String propertyName = methodName.substring(firstWord.length());\n                      final String[] setterNames = getSuggestionsByName(propertyName, variableKind, false);\n                      names = ArrayUtil.mergeArrays(names, setterNames, String.class);\n                    }\n                  }\n                }\n                return new NamesByExprInfo(name, names);\n              }\n            }\n          }\n        }\n      }\n    }\n    else if (expr.getParent() instanceof PsiAssignmentExpression && variableKind == VariableKind.PARAMETER) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)expr.getParent();\n      if (expr == assignmentExpression.getRExpression()) {\n        final PsiExpression leftExpression = assignmentExpression.getLExpression();\n        if (leftExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) leftExpression).getQualifier() == null) {\n          String name = leftExpression.getText();\n          if (name != null) {\n            final PsiElement resolve = ((PsiReferenceExpression)leftExpression).resolve();\n            if (resolve instanceof PsiVariable) {\n              name = variableNameToPropertyName(name, getVariableKind((PsiVariable)resolve));\n            }\n            String[] names = getSuggestionsByName(name, variableKind, false);\n            return new NamesByExprInfo(name, names);\n          }\n        }\n      }\n    }\n\n    return new NamesByExprInfo(null, ArrayUtil.EMPTY_STRING_ARRAY);\n  }","id":88109,"modified_method":"private NamesByExprInfo suggestVariableNameByExpressionPlace(PsiExpression expr, final VariableKind variableKind) {\n    if (expr.getParent() instanceof PsiExpressionList) {\n      PsiExpressionList list = (PsiExpressionList)expr.getParent();\n      PsiElement listParent = list.getParent();\n      PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n      PsiMethod method = null;\n      if (listParent instanceof PsiMethodCallExpression) {\n        final JavaResolveResult resolveResult = ((PsiMethodCallExpression)listParent).getMethodExpression().advancedResolve(false);\n        method = (PsiMethod)resolveResult.getElement();\n        subst = resolveResult.getSubstitutor();\n      }\n      else {\n        if (listParent instanceof PsiAnonymousClass) {\n          listParent = listParent.getParent();\n        }\n        if (listParent instanceof PsiNewExpression) {\n          method = ((PsiNewExpression)listParent).resolveConstructor();\n        }\n      }\n\n      if (method != null) {\n        final PsiElement navElement = method.getNavigationElement();\n        if (navElement instanceof PsiMethod) {\n          method = (PsiMethod)navElement;\n        }\n        PsiExpression[] expressions = list.getExpressions();\n        int index = -1;\n        for (int i = 0; i < expressions.length; i++) {\n          if (expressions[i] == expr) {\n            index = i;\n            break;\n          }\n        }\n        PsiParameter[] parms = method.getParameterList().getParameters();\n        if (index < parms.length) {\n          String name = parms[index].getName();\n          if (name != null && TypeConversionUtil.areTypesAssignmentCompatible(subst.substitute(parms[index].getType()), expr)) {\n            name = variableNameToPropertyName(name, VariableKind.PARAMETER);\n            String[] names = getSuggestionsByName(name, variableKind, false);\n            if (expressions.length == 1) {\n              final String methodName = method.getName();\n              String[] words = NameUtil.nameToWords(methodName);\n              if (words.length > 0) {\n                final String firstWord = words[0];\n                if (SET_PREFIX.equals(firstWord)) {\n                  final String propertyName = methodName.substring(firstWord.length());\n                  final String[] setterNames = getSuggestionsByName(propertyName, variableKind, false);\n                  names = ArrayUtil.mergeArrays(names, setterNames, String.class);\n                }\n              }\n            }\n            return new NamesByExprInfo(name, names);\n          }\n        }\n      }\n    }\n    else if (expr.getParent() instanceof PsiAssignmentExpression && variableKind == VariableKind.PARAMETER) {\n      final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)expr.getParent();\n      if (expr == assignmentExpression.getRExpression()) {\n        final PsiExpression leftExpression = assignmentExpression.getLExpression();\n        if (leftExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) leftExpression).getQualifier() == null) {\n          String name = leftExpression.getText();\n          if (name != null) {\n            final PsiElement resolve = ((PsiReferenceExpression)leftExpression).resolve();\n            if (resolve instanceof PsiVariable) {\n              name = variableNameToPropertyName(name, getVariableKind((PsiVariable)resolve));\n            }\n            String[] names = getSuggestionsByName(name, variableKind, false);\n            return new NamesByExprInfo(name, names);\n          }\n        }\n      }\n    }\n\n    return new NamesByExprInfo(null, ArrayUtil.EMPTY_STRING_ARRAY);\n  }","commit_id":"2969f70f1b338ef6feaea5b1603de804ca74e1c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#getStringValue(Command)\n     */\n    public String getStringValue(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return null;\n        }\n        widget.setFocus(true);\n        return executable.getParameter(widget.getElement());\n    }","id":88110,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#getStringValue(Command)\n     */\n    public String getStringValue(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return null;\n        }\n        focusWidget();\n        return executable.getParameter(widget.getElement());\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DefaultCommandManager(FocusWidget widget, Map<Command, Executable> executables)\n    {\n        this.widget = widget;\n        this.executables = new HashMap<Command, Executable>(executables);\n    }","id":88111,"modified_method":"public DefaultCommandManager(FocusWidget widget, Map<Command, Executable> executables)\n    {\n        this.widget = widget;\n        widget.addFocusListener(this);\n\n        this.executables = new HashMap<Command, Executable>(executables);\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#isSupported(Command)\n     */\n    public boolean isSupported(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        widget.setFocus(true);\n        return executable.isSupported(widget.getElement());\n    }","id":88112,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#isSupported(Command)\n     */\n    public boolean isSupported(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        focusWidget();\n        return executable.isSupported(widget.getElement());\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#isEnabled(Command)\n     */\n    public boolean isEnabled(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        widget.setFocus(true);\n        return executable.isEnabled(widget.getElement());\n    }","id":88113,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#isEnabled(Command)\n     */\n    public boolean isEnabled(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        focusWidget();\n        return executable.isEnabled(widget.getElement());\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#execute(Command, String)\n     */\n    public boolean execute(Command cmd, String param)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        widget.setFocus(true);\n        boolean success = executable.execute(widget.getElement(), param);\n        if (success) {\n            commandListeners.fireCommand(this, cmd, param);\n        }\n        return success;\n    }","id":88114,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#execute(Command, String)\n     */\n    public boolean execute(Command cmd, String param)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        focusWidget();\n        boolean success = executable.execute(widget.getElement(), param);\n        if (success) {\n            commandListeners.fireCommand(this, cmd, param);\n        }\n        return success;\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#isExecuted(Command)\n     */\n    public boolean isExecuted(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        widget.setFocus(true);\n        return executable.isExecuted(widget.getElement());\n    }","id":88115,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandManager#isExecuted(Command)\n     */\n    public boolean isExecuted(Command cmd)\n    {\n        Executable executable = executables.get(cmd);\n        if (executable == null) {\n            return false;\n        }\n        focusWidget();\n        return executable.isExecuted(widget.getElement());\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void addStyle(Text text, int beginIndex, int endIndex)\n    {\n        if (beginIndex > 0) {\n            String leftData = text.getData().substring(0, beginIndex);\n            Text left = text.getOwnerDocument().createTextNode(leftData);\n            text.getParentNode().insertBefore(left, text);\n            text.setData(text.getData().substring(beginIndex));\n            endIndex -= beginIndex;\n            beginIndex = 0;\n        }\n\n        if (endIndex < text.getLength()) {\n            String rightData = text.getData().substring(endIndex);\n            Text right = text.getOwnerDocument().createTextNode(rightData);\n            if (text.getNextSibling() != null) {\n                text.getParentNode().insertBefore(right, text.getNextSibling());\n            } else {\n                text.getParentNode().appendChild(right);\n            }\n            text.setData(text.getData().substring(beginIndex, endIndex));\n        }\n\n        com.google.gwt.dom.client.Element styleElement = text.getOwnerDocument().createElement(tagName);\n        if (className != null) {\n            styleElement.setClassName(className);\n        }\n\n        Node ancestor = text;\n        while (ancestor.getParentNode() != null && ancestor.getPreviousSibling() == null\n            && ancestor.getNextSibling() == null && isInline(ancestor.getParentNode())) {\n            ancestor = ancestor.getParentNode();\n        }\n        ancestor.getParentNode().replaceChild(styleElement, ancestor);\n        styleElement.appendChild(ancestor);\n    }","id":88116,"modified_method":"protected void addStyle(Text text, int beginIndex, int endIndex)\n    {\n        if (beginIndex > 0) {\n            String leftData = text.getData().substring(0, beginIndex);\n            Text left = text.getOwnerDocument().createTextNode(leftData);\n            text.getParentNode().insertBefore(left, text);\n            text.setData(text.getData().substring(beginIndex));\n            endIndex -= beginIndex;\n            beginIndex = 0;\n        }\n\n        if (endIndex < text.getLength()) {\n            String rightData = text.getData().substring(endIndex);\n            Text right = text.getOwnerDocument().createTextNode(rightData);\n            if (text.getNextSibling() != null) {\n                text.getParentNode().insertBefore(right, text.getNextSibling());\n            } else {\n                text.getParentNode().appendChild(right);\n            }\n            text.setData(text.getData().substring(beginIndex, endIndex));\n        }\n\n        com.google.gwt.dom.client.Element styleElement = text.getOwnerDocument().createElement(tagName);\n        if (className != null) {\n            styleElement.setClassName(className);\n        }\n\n        Node ancestor = text;\n        while (ancestor.getParentNode() != null && ancestor.getPreviousSibling() == null\n            && ancestor.getNextSibling() == null && DOMUtils.getInstance().isInline(ancestor.getParentNode())) {\n            ancestor = ancestor.getParentNode();\n        }\n        ancestor.getParentNode().replaceChild(styleElement, ancestor);\n        styleElement.appendChild(ancestor);\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void removeStyle(Text text, int beginIndex, int endIndex)\n    {\n        if (beginIndex > 0) {\n            String leftData = text.getData().substring(0, beginIndex);\n            Text left = text.getOwnerDocument().createTextNode(leftData);\n            text.getParentNode().insertBefore(left, text);\n            text.setData(text.getData().substring(beginIndex));\n            endIndex -= beginIndex;\n            beginIndex = 0;\n        }\n\n        if (endIndex < text.getLength()) {\n            String rightData = text.getData().substring(endIndex);\n            Text right = text.getOwnerDocument().createTextNode(rightData);\n            if (text.getNextSibling() != null) {\n                text.getParentNode().insertBefore(right, text.getNextSibling());\n            } else {\n                text.getParentNode().appendChild(right);\n            }\n            text.setData(text.getData().substring(beginIndex, endIndex));\n        }\n\n        Node child = text;\n        Node parent = child.getParentNode();\n        while (parent != null && matchesStyle(parent) && isInline(parent) && split(parent, child)) {\n            child = child.getParentNode();\n            parent = child.getParentNode();\n        }\n    }","id":88117,"modified_method":"protected void removeStyle(Text text, int beginIndex, int endIndex)\n    {\n        if (beginIndex > 0) {\n            String leftData = text.getData().substring(0, beginIndex);\n            Text left = text.getOwnerDocument().createTextNode(leftData);\n            text.getParentNode().insertBefore(left, text);\n            text.setData(text.getData().substring(beginIndex));\n            endIndex -= beginIndex;\n            beginIndex = 0;\n        }\n\n        if (endIndex < text.getLength()) {\n            String rightData = text.getData().substring(endIndex);\n            Text right = text.getOwnerDocument().createTextNode(rightData);\n            if (text.getNextSibling() != null) {\n                text.getParentNode().insertBefore(right, text.getNextSibling());\n            } else {\n                text.getParentNode().appendChild(right);\n            }\n            text.setData(text.getData().substring(beginIndex, endIndex));\n        }\n\n        Node child = text;\n        Node parent = child.getParentNode();\n        while (parent != null && matchesStyle(parent) && DOMUtils.getInstance().isInline(parent)\n            && split(parent, child)) {\n            child = child.getParentNode();\n            parent = child.getParentNode();\n        }\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see PopupListener#onPopupClosed(SourcesPopupEvents, boolean)\n     */\n    public void onPopupClosed(SourcesPopupEvents sender, boolean autoHide)\n    {\n        if (sender == symbolPicker && !autoHide) {\n            onSymbols(false);\n        }\n    }","id":88118,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see PopupListener#onPopupClosed(SourcesPopupEvents, boolean)\n     */\n    public void onPopupClosed(SourcesPopupEvents sender, boolean autoHide)\n    {\n        if (sender == getSymbolPicker() && !autoHide) {\n            onSymbols(false);\n        }\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, XRichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_HTML)) {\n            symbolButton = new PushButton(Images.INSTANCE.charmap().createImage(), this);\n            symbolButton.setTitle(Strings.INSTANCE.charmap());\n\n            toolBarExtension.addFeature(\"symbol\", symbolButton);\n\n            symbolPicker = new SymbolPicker();\n            symbolPicker.addPopupListener(this);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getUIExtensionList().add(toolBarExtension);\n        }\n    }","id":88119,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, XRichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_HTML)) {\n            symbolButton = new PushButton(Images.INSTANCE.charmap().createImage(), this);\n            symbolButton.setTitle(Strings.INSTANCE.charmap());\n\n            toolBarExtension.addFeature(\"symbol\", symbolButton);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getUIExtensionList().add(toolBarExtension);\n        }\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void onSymbols(boolean show)\n    {\n        if (show) {\n            symbolPicker.center();\n        } else {\n            String character = symbolPicker.getSymbol();\n            if (character != null) {\n                getTextArea().getCommandManager().execute(Command.INSERT_HTML, character);\n            } else {\n                // We get here if the symbol picker has been closed by clicking the close button.\n                // In this case we return the focus to the text area.\n                getTextArea().setFocus(true);\n            }\n        }\n    }","id":88120,"modified_method":"public void onSymbols(boolean show)\n    {\n        if (show) {\n            getSymbolPicker().center();\n        } else {\n            String character = getSymbolPicker().getSymbol();\n            if (character != null) {\n                getTextArea().getCommandManager().execute(Command.INSERT_HTML, character);\n            } else {\n                // We get here if the symbol picker has been closed by clicking the close button.\n                // In this case we return the focus to the text area.\n                getTextArea().setFocus(true);\n            }\n        }\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#destroy()\n     */\n    public void destroy()\n    {\n        if (symbolButton != null) {\n            symbolButton.removeFromParent();\n            symbolButton.removeClickListener(this);\n            symbolButton = null;\n\n            symbolPicker.hide();\n            symbolPicker.removeFromParent();\n            symbolPicker.removePopupListener(this);\n            symbolPicker = null;\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            toolBarExtension.clearFeatures();\n        }\n\n        super.destroy();\n    }","id":88121,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#destroy()\n     */\n    public void destroy()\n    {\n        if (symbolButton != null) {\n            symbolButton.removeFromParent();\n            symbolButton.removeClickListener(this);\n            symbolButton = null;\n\n            if (symbolPicker != null) {\n                symbolPicker.hide();\n                symbolPicker.removeFromParent();\n                symbolPicker.removePopupListener(this);\n                symbolPicker = null;\n            }\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            toolBarExtension.clearFeatures();\n        }\n\n        super.destroy();\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void loadUI()\r\n    {\r\n        setName(\"Wysiwyg\");\r\n        for (final Config config : getConfigs()) {\r\n            String hookId = config.getParameter(\"hookId\");\r\n            if (hookId == null) {\r\n                continue;\r\n            }\r\n\r\n            Element hook = DOM.getElementById(hookId);\r\n            if (hook == null) {\r\n                continue;\r\n            }\r\n\r\n            // Extract info from DOM\r\n            String name = hook.getAttribute(\"name\");\r\n            String value = hook.getPropertyString(\"value\");\r\n            if (value == null) {\r\n                value = hook.getInnerHTML();\r\n            }\r\n            String height = String.valueOf(Math.max(hook.getOffsetHeight(), 100)) + \"px\";\r\n\r\n            // Prepare the DOM\r\n            Element container = DOM.createDiv();\r\n            final String containerId = hookId + \"_container\";\r\n            container.setId(containerId);\r\n            hook.getParentElement().replaceChild(container, hook);\r\n\r\n            // Create the WYSIWYG Editor\r\n            final XWysiwygEditor editor = XWysiwygEditorFactory.getInstance().newEditor(config, this);\r\n            editor.getUI().getTextArea().setHTML(value);\r\n            editor.getUI().getTextArea().setHeight(height);\r\n            if (name != null) {\r\n                editor.getUI().getTextArea().setName(name);\r\n            }\r\n\r\n            // Insert the WYSIWYG Editor\r\n            if (\"true\".equals(config.getParameter(\"debug\", \"false\"))) {\r\n                RootPanel.get(containerId).add(new XWysiwygEditorDebugger(editor));\r\n            } else {\r\n                RootPanel.get(containerId).add(editor.getUI());\r\n            }\r\n        }\r\n    }","id":88122,"modified_method":"private void loadUI()\r\n    {\r\n        setName(\"Wysiwyg\");\r\n        for (final Config config : getConfigs()) {\r\n            String hookId = config.getParameter(\"hookId\");\r\n            if (hookId == null) {\r\n                continue;\r\n            }\r\n\r\n            Element hook = DOM.getElementById(hookId);\r\n            if (hook == null) {\r\n                continue;\r\n            }\r\n\r\n            Element input = hook;\r\n            String inputId = config.getParameter(\"inputId\");\r\n            if (inputId != null) {\r\n                input = DOM.getElementById(inputId);\r\n                input = input == null ? hook : input;\r\n            }\r\n\r\n            // Extract info from DOM\r\n            String name = hook.getAttribute(\"name\");\r\n            String value = input.getPropertyString(\"value\");\r\n            if (value == null) {\r\n                value = input.getInnerHTML();\r\n            }\r\n            String height = String.valueOf(Math.max(hook.getOffsetHeight(), 100)) + \"px\";\r\n\r\n            // Prepare the DOM\r\n            Element container = DOM.createDiv();\r\n            final String containerId = hookId + \"_container\";\r\n            container.setId(containerId);\r\n            hook.getParentElement().replaceChild(container, hook);\r\n\r\n            // Create the WYSIWYG Editor\r\n            final XWysiwygEditor editor = XWysiwygEditorFactory.getInstance().newEditor(config, this);\r\n            editor.getUI().getTextArea().setHTML(value);\r\n            editor.getUI().getTextArea().setHeight(height);\r\n            if (name != null) {\r\n                editor.getUI().getTextArea().setName(name);\r\n            }\r\n\r\n            // Insert the WYSIWYG Editor\r\n            if (\"true\".equals(config.getParameter(\"debug\", \"false\"))) {\r\n                RootPanel.get(containerId).add(new XWysiwygEditorDebugger(editor));\r\n            } else {\r\n                RootPanel.get(containerId).add(editor.getUI());\r\n            }\r\n        }\r\n    }","commit_id":"e249ef9d0d853ebeba684286b9756c83ae79b47d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void vanish() {\n      hide();\n    }","id":88123,"modified_method":"public void vanish() {\n      if (myCurrentBalloon != null) {\n        myCurrentBalloon.hide();\n        myCurrentBalloon = null;\n      }\n    }","commit_id":"688d22deed609de3c7c1fbde107eb16b6c1e929e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ErrorTextHighlighter() {\n      super();\n      myLabel.setIcon(IconLoader.getIcon(\"/ide/dnd/error.png\"));\n    }","id":88124,"modified_method":"public ErrorTextHighlighter() {\n      super(MessageType.ERROR);\n    }","commit_id":"688d22deed609de3c7c1fbde107eb16b6c1e929e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseTextHighlighter() {\n      myLabel = new JLabel(\"\", JLabel.CENTER) {\n        protected void paintComponent(Graphics g) {\n          BaseTextHighlighter.this.paintComponent(g);\n          super.paintComponent(g);\n        }\n      };\n      myLabel.setFont(myLabel.getFont().deriveFont(Font.BOLD));\n      myLabel.setForeground(UIUtil.getToolTipForeground());\n\n      setFocusable(false);\n\n      getContentPane().setLayout(new BorderLayout());\n      getContentPane().add(myLabel, BorderLayout.CENTER);\n    }","id":88125,"modified_method":"public BaseTextHighlighter(MessageType type) {\n      myMessageType = type;\n    }","commit_id":"688d22deed609de3c7c1fbde107eb16b6c1e929e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void show(JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n      myLabel.setText(aEvent.getExpectedDropResult());\n      final Dimension prefSize = getPreferredSize();\n      prefSize.width += 10;\n      prefSize.height += 4;\n\n      int centerX = aRectangle.x + aRectangle.width / 2;\n      final Rectangle newBounds = new Rectangle(centerX - prefSize.width / 2, aRectangle.y - prefSize.height - 5, prefSize.width, prefSize.height);\n      newBounds.y = newBounds.y < 0 ? 0 : newBounds.y;\n\n      Point location = newBounds.getLocation();\n      SwingUtilities.convertPointToScreen(location, aPane);\n      newBounds.setLocation(location);\n\n      setBounds(newBounds);\n      show();\n      if (SystemInfo.isUnix) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            toFront();\n          }\n        });\n      }\n    }","id":88126,"modified_method":"public void show(JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n      if (!Registry.is(\"ide.dnd.textHints\")) return;\n\n      final String result = aEvent.getExpectedDropResult();\n      if (result != null && result.length() > 0) {\n        RelativePoint point  = null;\n        for (DropTargetHighlighter each : ourHightlighters) {\n          if (each instanceof AbstractComponentHighlighter) {\n            Rectangle rec = ((AbstractComponentHighlighter)each).getBounds();\n            point = new RelativePoint(aPane, new Point(rec.x + rec.width, rec.y + rec.height / 2));\n            break;\n          }\n        }\n\n        if (point == null) {\n          point = new RelativePoint(aPane, new Point(aRectangle.x + aRectangle.width, aRectangle.y + aRectangle.height / 2));\n        }\n        \n        myCurrentBalloon = JBPopupFactory.getInstance().createHtmlTextBalloonBuilder(result, myMessageType, null).createBalloon();\n        myCurrentBalloon.show(point, Balloon.Position.atRight);\n      }\n    }","commit_id":"688d22deed609de3c7c1fbde107eb16b6c1e929e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void show(int aType, JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n    List<DropTargetHighlighter> toShow = new ArrayList<DropTargetHighlighter>();\n    for (Accessible ourHightlighter : ourHightlighters) {\n      DropTargetHighlighter each = (DropTargetHighlighter)ourHightlighter;\n      if ((each.getMask() & aType) != 0) {\n        toShow.add(each);\n      }\n    }\n\n    for (int i = 0; i < toShow.size(); i++) {\n      DropTargetHighlighter each = toShow.get(i);\n      each.show(aPane, aRectangle, aEvent);\n    }\n    ourCurrentHighlighters.addAll(toShow);\n  }","id":88127,"modified_method":"static void show(int aType, JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n    List<DropTargetHighlighter> toShow = new ArrayList<DropTargetHighlighter>();\n    for (DropTargetHighlighter ourHightlighter : ourHightlighters) {\n      DropTargetHighlighter each = (DropTargetHighlighter)ourHightlighter;\n      if ((each.getMask() & aType) != 0) {\n        toShow.add(each);\n      }\n    }\n\n    for (int i = 0; i < toShow.size(); i++) {\n      DropTargetHighlighter each = toShow.get(i);\n      each.show(aPane, aRectangle, aEvent);\n    }\n    ourCurrentHighlighters.addAll(toShow);\n  }","commit_id":"688d22deed609de3c7c1fbde107eb16b6c1e929e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void show(int aType, JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n    List<DropTargetHighlighter> toShow = new ArrayList<DropTargetHighlighter>();\n    for (Accessible ourHightlighter : ourHightlighters) {\n      DropTargetHighlighter each = (DropTargetHighlighter)ourHightlighter;\n      if ((each.getMask() & aType) != 0) {\n        toShow.add(each);\n      }\n    }\n\n    for (int i = 0; i < toShow.size(); i++) {\n      DropTargetHighlighter each = toShow.get(i);\n      each.show(aPane, aRectangle, aEvent);\n    }\n    ourCurrentHighlighters.addAll(toShow);\n  }","id":88128,"modified_method":"static void show(int aType, JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n    List<DropTargetHighlighter> toShow = new ArrayList<DropTargetHighlighter>();\n    for (DropTargetHighlighter ourHightlighter : ourHightlighters) {\n      DropTargetHighlighter each = (DropTargetHighlighter)ourHightlighter;\n      if ((each.getMask() & aType) != 0) {\n        toShow.add(each);\n      }\n    }\n\n    for (int i = 0; i < toShow.size(); i++) {\n      DropTargetHighlighter each = toShow.get(i);\n      each.show(aPane, aRectangle, aEvent);\n    }\n    ourCurrentHighlighters.addAll(toShow);\n  }","commit_id":"8a955209e8ead30910b06881c2ce85d04b7dfbfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseTextHighlighter() {\n      myLabel = new JLabel(\"\", JLabel.CENTER) {\n        protected void paintComponent(Graphics g) {\n          BaseTextHighlighter.this.paintComponent(g);\n          super.paintComponent(g);\n        }\n      };\n      myLabel.setFont(myLabel.getFont().deriveFont(Font.BOLD));\n      myLabel.setForeground(UIUtil.getToolTipForeground());\n\n      setFocusable(false);\n\n      getContentPane().setLayout(new BorderLayout());\n      getContentPane().add(myLabel, BorderLayout.CENTER);\n    }","id":88129,"modified_method":"public BaseTextHighlighter(MessageType type) {\n      myMessageType = type;\n    }","commit_id":"8a955209e8ead30910b06881c2ce85d04b7dfbfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void show(JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n      myLabel.setText(aEvent.getExpectedDropResult());\n      final Dimension prefSize = getPreferredSize();\n      prefSize.width += 10;\n      prefSize.height += 4;\n\n      int centerX = aRectangle.x + aRectangle.width / 2;\n      final Rectangle newBounds = new Rectangle(centerX - prefSize.width / 2, aRectangle.y - prefSize.height - 5, prefSize.width, prefSize.height);\n      newBounds.y = newBounds.y < 0 ? 0 : newBounds.y;\n\n      Point location = newBounds.getLocation();\n      SwingUtilities.convertPointToScreen(location, aPane);\n      newBounds.setLocation(location);\n\n      setBounds(newBounds);\n      show();\n      if (SystemInfo.isUnix) {\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            toFront();\n          }\n        });\n      }\n    }","id":88130,"modified_method":"public void show(JLayeredPane aPane, Rectangle aRectangle, DnDEvent aEvent) {\n      if (!Registry.is(\"ide.dnd.textHints\")) return;\n\n      final String result = aEvent.getExpectedDropResult();\n      if (result != null && result.length() > 0) {\n        RelativePoint point  = null;\n        for (DropTargetHighlighter each : ourHightlighters) {\n          if (each instanceof AbstractComponentHighlighter) {\n            Rectangle rec = ((AbstractComponentHighlighter)each).getBounds();\n            point = new RelativePoint(aPane, new Point(rec.x + rec.width, rec.y + rec.height / 2));\n            break;\n          }\n        }\n\n        if (point == null) {\n          point = new RelativePoint(aPane, new Point(aRectangle.x + aRectangle.width, aRectangle.y + aRectangle.height / 2));\n        }\n        \n        myCurrentBalloon = JBPopupFactory.getInstance().createHtmlTextBalloonBuilder(result, myMessageType, null).createBalloon();\n        myCurrentBalloon.show(point, Balloon.Position.atRight);\n      }\n    }","commit_id":"8a955209e8ead30910b06881c2ce85d04b7dfbfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ErrorTextHighlighter() {\n      super();\n      myLabel.setIcon(IconLoader.getIcon(\"/ide/dnd/error.png\"));\n    }","id":88131,"modified_method":"public ErrorTextHighlighter() {\n      super(MessageType.ERROR);\n    }","commit_id":"8a955209e8ead30910b06881c2ce85d04b7dfbfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void vanish() {\n      hide();\n    }","id":88132,"modified_method":"public void vanish() {\n      if (myCurrentBalloon != null) {\n        myCurrentBalloon.hide();\n        myCurrentBalloon = null;\n      }\n    }","commit_id":"8a955209e8ead30910b06881c2ce85d04b7dfbfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OSGiCamelContextProvider(BundleContext context) {\n        factory = new CamelContextFactory();\n        factory.setBundleContext(context);\n    }","id":88133,"modified_method":"public OSGiCamelContextProvider(BundleContext context) {\n        // In this we can support to run this provider with or without OSGI\n        if (context != null) {\n            factory = new CamelContextFactory();\n            factory.setBundleContext(context);\n        } else {\n            factory = null;\n        }\n    }","commit_id":"bc40acc88fcef665590074c33c74cd1728b24427","url":"https://github.com/apache/camel"},{"original_method":"public CamelContext get() {\n        DefaultCamelContext camelContext = factory.createContext();\n        if (routeBuilders != null) {\n            for (RoutesBuilder builder : routeBuilders) {\n                try {\n                    camelContext.addRoutes(builder);\n                } catch (Exception e) {\n                    throw new ProvisionException(\"Failed to add the router. Reason: \" + e, e);\n                }\n            }\n        }\n        updateRegistry(camelContext);        \n        return camelContext;\n    }","id":88134,"modified_method":"public CamelContext get() {\n        DefaultCamelContext camelContext;\n        if (factory != null) {\n            camelContext = factory.createContext();\n        } else {\n            camelContext = new DefaultCamelContext();\n        }\n        if (routeBuilders != null) {\n            for (RoutesBuilder builder : routeBuilders) {\n                try {\n                    camelContext.addRoutes(builder);\n                } catch (Exception e) {\n                    throw new ProvisionException(\"Failed to add the router. Reason: \" + e, e);\n                }\n            }\n        }\n        updateRegistry(camelContext);        \n        return camelContext;\n    }","commit_id":"bc40acc88fcef665590074c33c74cd1728b24427","url":"https://github.com/apache/camel"},{"original_method":"protected void loadComponents() throws ContainerException {\n        if (embedded == null) {\n            throw new ContainerException(\"Cannot load web applications without Embedded instance!\");\n        }\n\n        // load the applications\n        Collection componentConfigs = ComponentConfig.getAllComponents();\n        if (componentConfigs != null) {\n            Iterator components = componentConfigs.iterator();\n            while (components.hasNext()) {\n                ComponentConfig component = (ComponentConfig) components.next();\n                Iterator appInfos = component.getWebappInfos().iterator();\n                while (appInfos.hasNext()) {\n                    ComponentConfig.WebappInfo appInfo = (ComponentConfig.WebappInfo) appInfos.next();\n                    createContext(appInfo);\n                }\n            }\n        }\n\n    }","id":88135,"modified_method":"protected void loadComponents() throws ContainerException {\n        if (embedded == null) {\n            throw new ContainerException(\"Cannot load web applications without Embedded instance!\");\n        }\n\n        // load the applications\n        List webResourceInfos = ComponentConfig.getAllWebappResourceInfos();\n        List loadedMounts = FastList.newInstance();\n        if (webResourceInfos != null) {\n            for (int i = webResourceInfos.size(); i > 0; i--) {\n                ComponentConfig.WebappInfo appInfo = (ComponentConfig.WebappInfo) webResourceInfos.get(i - 1);\n                String mount = appInfo.getContextRoot();\n                if (!loadedMounts.contains(mount)) {\n                    createContext(appInfo);\n                    loadedMounts.add(mount);\n                } else {\n                    Debug.logInfo(\"Duplicate webapp mount; not loading : \" + appInfo.getName() + \" / \" + appInfo.getLocation(), module);\n                }\n            }\n        }        \n    }","commit_id":"4924cb6ea236a23d5c96dc46612cf58b1df14383","url":"https://github.com/apache/ofbiz"},{"original_method":"@Override\n    public void write(String message) throws IOException\n    {\n        if (message == null)\n        {\n            // nothing to write\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(String->{})\",message);\n        }\n        write(new TextFrame(message));\n    }","id":88136,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(String message) throws IOException\n    {\n        if (message == null)\n        {\n            // nothing to write\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(String->{})\",message);\n        }\n        write(new TextFrame(message));\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * For terminating connections forcefully.\n     * \n     * @param statusCode\n     *            the WebSocket status code.\n     * @param reason\n     *            the (optiona) reason string. (null is allowed)\n     * @see StatusCode\n     */\n    private void terminateConnection(short statusCode, String reason)\n    {\n        CloseFrame close = new CloseFrame(statusCode,reason);\n\n        // fire and forget -> close frame\n        ByteBuffer buf = bufferPool.acquire(policy.getBufferSize(),false);\n        generator.generate(buf,close);\n        getEndPoint().write(null,new WebSocketCloseCallback(this,buf),buf);\n    }","id":88137,"modified_method":"/**\n     * For terminating connections forcefully.\n     * \n     * @param statusCode\n     *            the WebSocket status code.\n     * @param reason\n     *            the (optional) reason string. (null is allowed)\n     * @see StatusCode\n     */\n    private void terminateConnection(int statusCode, String reason)\n    {\n        CloseFrame close = new CloseFrame(statusCode,reason);\n\n        // fire and forget -> close frame\n        ByteBuffer buf = bufferPool.acquire(policy.getBufferSize(),false);\n        BufferUtil.clearToFill(buf);\n        generator.generate(buf,close);\n        BufferUtil.flipToFlush(buf,0);\n        getEndPoint().write(null,new WebSocketCloseCallback(this,buf),buf);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public <C> void write(C context, Callback<C> callback, ByteBuffer... buffers) throws IOException\n    {\n        int len = buffers.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},ByteBuffers->{})\",callback,buffers.length);\n        }\n        ByteBuffer raw[] = new ByteBuffer[len];\n        for (int i = 0; i < len; i++)\n        {\n            raw[i] = bufferPool.acquire(buffers[i].remaining() + FrameGenerator.OVERHEAD,false);\n            BufferUtil.clearToFill(raw[i]);\n            BinaryFrame frame = new BinaryFrame(buffers[i]);\n            generator.generate(raw[i],frame);\n            BufferUtil.flipToFlush(raw[i],0);\n        }\n        getEndPoint().write(context,callback,raw);\n    }","id":88138,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, ByteBuffer... buffers) throws IOException\n    {\n        int len = buffers.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},ByteBuffers->{})\",callback,buffers.length);\n        }\n        ByteBuffer raw[] = new ByteBuffer[len];\n        for (int i = 0; i < len; i++)\n        {\n            raw[i] = bufferPool.acquire(buffers[i].remaining() + FrameGenerator.OVERHEAD,false);\n            BufferUtil.clearToFill(raw[i]);\n            BinaryFrame frame = new BinaryFrame(buffers[i]);\n            generator.generate(raw[i],frame);\n            BufferUtil.flipToFlush(raw[i],0);\n        }\n        getEndPoint().write(context,callback,raw);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void write(BaseFrame frame) throws IOException\n    {\n        if (frame == null)\n        {\n            // nothing to write\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(BaseFrame->{})\",frame);\n        }\n\n        ByteBuffer raw = bufferPool.acquire(frame.getPayloadLength() + FrameGenerator.OVERHEAD,false);\n        BufferUtil.clearToFill(raw);\n        generator.generate(raw,frame);\n        BufferUtil.flipToFlush(raw,0);\n        Callback<Void> nop = new FutureCallback<>(); // TODO: add buffer release callback?\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"Raw Buffer: {}\",BufferUtil.toDetailString(raw));\n        }\n        getEndPoint().write(null,nop,raw);\n    }","id":88139,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(BaseFrame frame) throws IOException\n    {\n        if (frame == null)\n        {\n            // nothing to write\n            return;\n        }\n\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(BaseFrame->{})\",frame);\n        }\n\n        ByteBuffer raw = bufferPool.acquire(frame.getPayloadLength() + FrameGenerator.OVERHEAD,false);\n        BufferUtil.clearToFill(raw);\n        generator.generate(raw,frame);\n        BufferUtil.flipToFlush(raw,0);\n        Callback<Void> nop = new FutureCallback<>(); // TODO: add buffer release callback?\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"Raw Buffer: {}\",BufferUtil.toDetailString(raw));\n        }\n        getEndPoint().write(null,nop,raw);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public <C> void write(C context, Callback<C> callback, String... messages) throws IOException\n    {\n        int len = messages.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},Strings->{})\",callback,messages.length);\n        }\n        TextFrame frames[] = new TextFrame[len];\n        for (int i = 0; i < len; i++)\n        {\n            frames[i] = new TextFrame(messages[i]);\n        }\n        write(context,callback,frames);\n    }","id":88140,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, String... messages) throws IOException\n    {\n        int len = messages.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},Strings->{})\",callback,messages.length);\n        }\n        TextFrame frames[] = new TextFrame[len];\n        for (int i = 0; i < len; i++)\n        {\n            frames[i] = new TextFrame(messages[i]);\n        }\n        write(context,callback,frames);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void write(ByteBuffer... buffers) throws IOException\n    {\n        int len = buffers.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(ByteBuffers->{})\",buffers.length);\n        }\n        ByteBuffer raw[] = new ByteBuffer[len];\n        for (int i = 0; i < len; i++)\n        {\n            raw[i] = bufferPool.acquire(buffers[i].remaining() + FrameGenerator.OVERHEAD,false);\n            BufferUtil.clearToFill(raw[i]);\n            BinaryFrame frame = new BinaryFrame(buffers[i]);\n            generator.generate(raw[i],frame);\n            BufferUtil.flipToFlush(raw[i],0);\n        }\n        Callback<Void> nop = new FutureCallback<>(); // TODO: add buffer release callback?\n        getEndPoint().write(null,nop,raw);\n    }","id":88141,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(ByteBuffer... buffers) throws IOException\n    {\n        int len = buffers.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(ByteBuffers->{})\",buffers.length);\n        }\n        ByteBuffer raw[] = new ByteBuffer[len];\n        for (int i = 0; i < len; i++)\n        {\n            raw[i] = bufferPool.acquire(buffers[i].remaining() + FrameGenerator.OVERHEAD,false);\n            BufferUtil.clearToFill(raw[i]);\n            BinaryFrame frame = new BinaryFrame(buffers[i]);\n            generator.generate(raw[i],frame);\n            BufferUtil.flipToFlush(raw[i],0);\n        }\n        Callback<Void> nop = new FutureCallback<>(); // TODO: add buffer release callback?\n        getEndPoint().write(null,nop,raw);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void close(int statusCode, String reason) throws IOException\n    {\n        write(new CloseFrame(statusCode,reason));\n    }","id":88142,"modified_method":"@Override\n    public void close(int statusCode, String reason) throws IOException\n    {\n        terminateConnection(statusCode,reason);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public <C> void write(C context, Callback<C> callback, BaseFrame... frames) throws IOException\n    {\n        int len = frames.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},BaseFrames->{})\",callback,frames.length);\n        }\n        ByteBuffer raw[] = new ByteBuffer[len];\n        for (int i = 0; i < len; i++)\n        {\n            raw[i] = bufferPool.acquire(frames[i].getPayloadLength() + FrameGenerator.OVERHEAD,false);\n            BufferUtil.clearToFill(raw[i]);\n            generator.generate(raw[i],frames[i]);\n            BufferUtil.flipToFlush(raw[i],0);\n        }\n        getEndPoint().write(context,callback,raw);\n    }","id":88143,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public <C> void write(C context, Callback<C> callback, BaseFrame... frames) throws IOException\n    {\n        int len = frames.length;\n        if (len == 0)\n        {\n            // nothing to write\n            return;\n        }\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(context,{},BaseFrames->{})\",callback,frames.length);\n        }\n        ByteBuffer raw[] = new ByteBuffer[len];\n        for (int i = 0; i < len; i++)\n        {\n            raw[i] = bufferPool.acquire(frames[i].getPayloadLength() + FrameGenerator.OVERHEAD,false);\n            BufferUtil.clearToFill(raw[i]);\n            generator.generate(raw[i],frames[i]);\n            BufferUtil.flipToFlush(raw[i],0);\n        }\n        getEndPoint().write(context,callback,raw);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void close() throws IOException\n    {\n        write(new CloseFrame(StatusCode.NORMAL));\n    }","id":88144,"modified_method":"@Override\n    public void close() throws IOException\n    {\n        terminateConnection(StatusCode.NORMAL,null);\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void write(byte[] data, int offset, int length) throws IOException\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(byte[]->{})\",data);\n        }\n        write(new BinaryFrame(data,offset,length));\n    }","id":88145,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(byte[] data, int offset, int length) throws IOException\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"write(byte[]->{})\",data);\n        }\n        write(new BinaryFrame(data,offset,length));\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void sendStandardRequest() throws IOException\n    {\n        StringBuilder req = new StringBuilder();\n        req.append(\"GET /chat HTTP/1.1\\r\\n\");\n        req.append(\"Host: \").append(destWebsocketURI.getHost());\n        if (destWebsocketURI.getPort() > 0)\n        {\n            req.append(':').append(destWebsocketURI.getPort());\n        }\n        req.append(\"\\r\\n\");\n        req.append(\"Upgrade: websocket\\r\\n\");\n        req.append(\"Connection: Upgrade\\r\\n\");\n        req.append(\"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\");\n        req.append(\"Sec-WebSocket-Origin: \").append(destWebsocketURI.toASCIIString()).append(\"\\r\\n\");\n        if (StringUtil.isNotBlank(protocols))\n        {\n            req.append(\"Sec-WebSocket-Protocol: \").append(protocols).append(\"\\r\\n\");\n        }\n        if (StringUtil.isNotBlank(extensions))\n        {\n            req.append(\"Sec-WebSocket-Extensions: \").append(extensions).append(\"\\r\\n\");\n        }\n        req.append(\"Sec-WebSocket-Version: \").append(version).append(\"\\r\\n\");\n        req.append(\"\\r\\n\");\n        write(req.toString());\n    }","id":88146,"modified_method":"public void sendStandardRequest() throws IOException\n    {\n        StringBuilder req = new StringBuilder();\n        req.append(\"GET /chat HTTP/1.1\\r\\n\");\n        req.append(\"Host: \").append(destWebsocketURI.getHost());\n        if (destWebsocketURI.getPort() > 0)\n        {\n            req.append(':').append(destWebsocketURI.getPort());\n        }\n        req.append(\"\\r\\n\");\n        req.append(\"Upgrade: websocket\\r\\n\");\n        req.append(\"Connection: Upgrade\\r\\n\");\n        req.append(\"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\");\n        req.append(\"Sec-WebSocket-Origin: \").append(destWebsocketURI.toASCIIString()).append(\"\\r\\n\");\n        if (StringUtil.isNotBlank(protocols))\n        {\n            req.append(\"Sec-WebSocket-Protocol: \").append(protocols).append(\"\\r\\n\");\n        }\n        if (StringUtil.isNotBlank(extensions))\n        {\n            req.append(\"Sec-WebSocket-Extensions: \").append(extensions).append(\"\\r\\n\");\n        }\n        req.append(\"Sec-WebSocket-Version: \").append(version).append(\"\\r\\n\");\n        req.append(\"\\r\\n\");\n        writeRaw(req.toString());\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void write(BaseFrame frame) throws IOException\n    {\n        LOG.debug(\"write(BaseFrame->{})\",frame);\n        ByteBuffer buf = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            BufferUtil.flipToFill(buf);\n            generator.generate(buf,frame);\n            BufferUtil.flipToFlush(buf,0);\n            out.write(BufferUtil.toArray(buf));\n        }\n        finally\n        {\n            bufferPool.release(buf);\n        }\n    }","id":88147,"modified_method":"public void write(BaseFrame frame) throws IOException\n    {\n        LOG.debug(\"write(BaseFrame->{})\",frame);\n        ByteBuffer buf = bufferPool.acquire(policy.getBufferSize(),false);\n        try\n        {\n            BufferUtil.flipToFill(buf);\n            generator.generate(buf,frame);\n            BufferUtil.flipToFlush(buf,0);\n            BufferUtil.writeTo(buf,out);\n        }\n        finally\n        {\n            bufferPool.release(buf);\n        }\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void write(String str) throws IOException\n    {\n        LOG.debug(\"write(String->{})\",str);\n        out.write(StringUtil.getBytes(str,StringUtil.__ISO_8859_1));\n    }","id":88148,"modified_method":"public void writeRaw(String str) throws IOException\n    {\n        LOG.debug(\"write(String->{})\",str);\n        out.write(StringUtil.getBytes(str,StringUtil.__ISO_8859_1));\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void call(Object obj, Object... args)\n    {\n        if ((this.pojo == null) || (this.method == null))\n        {\n            LOG.warn(\"Cannot execute call: pojo={}, method={}\",pojo,method);\n            return; // no call event method determined\n        }\n        if (obj == null)\n        {\n            LOG.warn(\"Cannot call {} on null object\",this.method);\n            return;\n        }\n        if (args.length > paramTypes.length)\n        {\n            Object trimArgs[] = dropFirstArg(args);\n            call(obj,trimArgs);\n            return;\n        }\n        if (args.length < paramTypes.length)\n        {\n            throw new IllegalArgumentException(\"Call arguments length [\" + args.length + \"] must always be greater than or equal to captured args length [\"\n                    + paramTypes.length + \"]\");\n        }\n        try\n        {\n            this.method.invoke(obj,args);\n        }\n        catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e)\n        {\n            LOG.warn(\"Cannot call method {} on {} with {}\",method,pojo,args);\n            LOG.warn(e);\n        }\n    }","id":88149,"modified_method":"public void call(Object obj, Object... args)\n    {\n        if ((this.pojo == null) || (this.method == null))\n        {\n            LOG.warn(\"Cannot execute call: pojo={}, method={}\",pojo,method);\n            return; // no call event method determined\n        }\n        if (obj == null)\n        {\n            LOG.warn(\"Cannot call {} on null object\",this.method);\n            return;\n        }\n        if (args.length > paramTypes.length)\n        {\n            Object trimArgs[] = dropFirstArg(args);\n            call(obj,trimArgs);\n            return;\n        }\n        if (args.length < paramTypes.length)\n        {\n            throw new IllegalArgumentException(\"Call arguments length [\" + args.length + \"] must always be greater than or equal to captured args length [\"\n                    + paramTypes.length + \"]\");\n        }\n        try\n        {\n            this.method.invoke(obj,args);\n        }\n        catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e)\n        {\n            String err = String.format(\"Cannot call method %s on %s with args: %s\",method,pojo,args);\n            throw new WebSocketException(err,e);\n        }\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void notifyFrame(final BaseFrame f)\n    {\n        LOG.debug(\"Notify Frame: {}\",f);\n        for (Listener listener : listeners)\n        {\n            try\n            {\n                listener.onFrame(f);\n            }\n            catch (Throwable t)\n            {\n                LOG.warn(t);\n            }\n        }\n    }","id":88150,"modified_method":"protected void notifyFrame(final BaseFrame f)\n    {\n        LOG.debug(\"Notify Frame: {}\",f);\n        for (Listener listener : listeners)\n        {\n            try\n            {\n                listener.onFrame(f);\n            }\n            catch (WebSocketException e)\n            {\n                notifyWebSocketException(e);\n            }\n            catch (Throwable t)\n            {\n                LOG.warn(t);\n                notifyWebSocketException(new WebSocketException(t));\n            }\n        }\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void parse(ByteBuffer buffer)\n    {\n        try\n        {\n            LOG.debug(\"Parsing {} bytes\",buffer.remaining());\n            while (buffer.hasRemaining())\n            {\n                switch (state)\n                {\n                    case FINOP:\n                    {\n                        // peek at byte\n                        byte b = buffer.get();\n                        boolean fin = ((b & 0x80) != 0);\n                        boolean rsv1 = ((b & 0x40) != 0);\n                        boolean rsv2 = ((b & 0x20) != 0);\n                        boolean rsv3 = ((b & 0x10) != 0);\n                        byte opc = (byte)(b & 0x0F);\n                        OpCode opcode = OpCode.from(opc);\n\n                        if (opcode == null)\n                        {\n                            throw new WebSocketException(\"Unknown opcode: \" + opc);\n                        }\n\n                        if (opcode.isControlFrame() && !fin)\n                        {\n                            throw new WebSocketException(\"Fragmented Control Frame [\" + opcode.name() + \"]\");\n                        }\n\n                        if (opcode == OpCode.CONTINUATION)\n                        {\n                            if (parser == null)\n                            {\n                                throw new WebSocketException(\"Fragment continuation frame without prior !FIN\");\n                            }\n                        }\n\n                        if (parser == null)\n                        {\n                            // Establish specific type parser and hand off to them.\n                            parser = parsers.get(opcode);\n                        }\n                        parser.reset();\n                        parser.initFrame(fin,rsv1,rsv2,rsv3,opcode);\n\n                        state = State.BASE_FRAMING;\n                        break;\n                    }\n                    case BASE_FRAMING:\n                    {\n                        if (parser.parseBaseFraming(buffer))\n                        {\n                            state = State.PAYLOAD;\n                        }\n                        break;\n                    }\n                    case PAYLOAD:\n                    {\n                        if (parser.parsePayload(buffer))\n                        {\n                            notifyFrame(parser.getFrame());\n                            parser.reset();\n                            if (parser.getFrame().isFin())\n                            {\n                                reset();\n                            }\n                            state = State.FINOP;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * if the payload was empty we could end up in this state\n             * because there was no remaining bits to process\n             */\n            if ( state == State.PAYLOAD )\n            {\n                notifyFrame( parser.getFrame() );\n                parser.reset();\n                if (parser.getFrame().isFin())\n                {\n                    reset();\n                }\n                state = State.FINOP;\n            }\n\n        }\n        catch (WebSocketException e)\n        {\n            notifyWebSocketException(e);\n        }\n        catch (Throwable t)\n        {\n            notifyWebSocketException(new WebSocketException(t));\n        }\n        finally\n        {\n            // Be sure to consume after exceptions\n            buffer.position(buffer.limit());\n        }\n    }","id":88151,"modified_method":"public void parse(ByteBuffer buffer)\n    {\n        try\n        {\n            LOG.debug(\"Parsing {} bytes\",buffer.remaining());\n            while (buffer.hasRemaining())\n            {\n                switch (state)\n                {\n                    case FINOP:\n                    {\n                        // peek at byte\n                        byte b = buffer.get();\n                        boolean fin = ((b & 0x80) != 0);\n                        boolean rsv1 = ((b & 0x40) != 0);\n                        boolean rsv2 = ((b & 0x20) != 0);\n                        boolean rsv3 = ((b & 0x10) != 0);\n                        byte opc = (byte)(b & 0x0F);\n                        OpCode opcode = OpCode.from(opc);\n\n                        if (opcode == null)\n                        {\n                            throw new WebSocketException(\"Unknown opcode: \" + opc);\n                        }\n\n                        LOG.debug(\"OpCode {}, fin={}\",opcode.name(),fin);\n\n                        if (opcode.isControlFrame() && !fin)\n                        {\n                            throw new WebSocketException(\"Fragmented Control Frame [\" + opcode.name() + \"]\");\n                        }\n\n                        if (opcode == OpCode.CONTINUATION)\n                        {\n                            if (parser == null)\n                            {\n                                throw new WebSocketException(\"Fragment continuation frame without prior !FIN\");\n                            }\n                        }\n\n                        if (parser == null)\n                        {\n                            // Establish specific type parser and hand off to them.\n                            parser = parsers.get(opcode);\n                        }\n                        parser.reset();\n                        parser.initFrame(fin,rsv1,rsv2,rsv3,opcode);\n\n                        state = State.BASE_FRAMING;\n                        break;\n                    }\n                    case BASE_FRAMING:\n                    {\n                        if (parser.parseBaseFraming(buffer))\n                        {\n                            state = State.PAYLOAD;\n                        }\n                        break;\n                    }\n                    case PAYLOAD:\n                    {\n                        if (parser.parsePayload(buffer))\n                        {\n                            notifyFrame(parser.getFrame());\n                            parser.reset();\n                            if (parser.getFrame().isFin())\n                            {\n                                reset();\n                            }\n                            state = State.FINOP;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * if the payload was empty we could end up in this state\n             * because there was no remaining bits to process\n             */\n            if ( state == State.PAYLOAD )\n            {\n                notifyFrame( parser.getFrame() );\n                parser.reset();\n                if (parser.getFrame().isFin())\n                {\n                    reset();\n                }\n                state = State.FINOP;\n            }\n\n        }\n        catch (WebSocketException e)\n        {\n            notifyWebSocketException(e);\n        }\n        catch (Throwable t)\n        {\n            notifyWebSocketException(new WebSocketException(t));\n        }\n        finally\n        {\n            // Be sure to consume after exceptions\n            buffer.position(buffer.limit());\n        }\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void completed(Void context)\n    {\n        // release buffer\n        this.conn.getBufferPool().release(buf);\n        this.conn.getEndPoint().close();\n    }","id":88152,"modified_method":"@Override\n    public void completed(Void context)\n    {\n        if (buf != null)\n        {\n            // release buffer\n            this.conn.getBufferPool().release(buf);\n        }\n        this.conn.getEndPoint().close();\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void failed(Void context, Throwable cause)\n    {\n        this.conn.getBufferPool().release(buf);\n        this.conn.getEndPoint().close();\n    }","id":88153,"modified_method":"@Override\n    public void failed(Void context, Throwable cause)\n    {\n        if (buf != null)\n        {\n            // release buffer\n            this.conn.getBufferPool().release(buf);\n        }\n        this.conn.getEndPoint().close();\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Internal entry point for incoming frames\n     * \n     * @param frame\n     *            the frame that appeared\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void onFrame(BaseFrame frame)\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"{}.onFrame({})\",websocket.getClass().getSimpleName(),frame);\n        }\n\n        // Specified Close Case\n        if ((frame instanceof CloseFrame) && (events.onClose != null))\n        {\n            CloseFrame close = (CloseFrame)frame;\n            events.onClose.call(websocket,connection,close.getStatusCode(),close.getReason());\n            return;\n        }\n\n        // Specified Text Case\n        if ((frame instanceof TextFrame) && (events.onText != null))\n        {\n            TextFrame text = (TextFrame)frame;\n            events.onText.call(websocket,connection,text.getPayloadUTF8());\n            return;\n        }\n\n        // Specified Binary Case\n        if ((frame instanceof BinaryFrame) && (events.onBinary != null))\n        {\n            BinaryFrame bin = (BinaryFrame)frame;\n\n            if (events.onBinary.isParameterPresent(ByteBuffer.class))\n            {\n                // Byte buffer approach\n                events.onBinary.call(websocket,connection,bin.getPayload());\n            }\n            else\n            {\n                // Byte array approach\n                byte buf[] = BufferUtil.toArray(bin.getPayload());\n                events.onBinary.call(websocket,connection,buf,0,buf.length);\n            }\n\n            return;\n        }\n\n        // Basic Hierarchy Case\n        Class<? extends BaseFrame> frameType = frame.getClass();\n        while (true)\n        {\n            EventMethod event = events.getOnFrame(frameType);\n            if (event != null)\n            {\n                event.call(websocket,connection,frame);\n                return;\n            }\n\n            if (!BaseFrame.class.isAssignableFrom(frameType.getSuperclass()))\n            {\n                // not assignable\n                return;\n            }\n            frameType = (Class<? extends BaseFrame>)frameType.getSuperclass();\n        }\n    }","id":88154,"modified_method":"/**\n     * Internal entry point for incoming frames\n     * \n     * @param frame\n     *            the frame that appeared\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void onFrame(BaseFrame frame)\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(\"{}.onFrame({})\",websocket.getClass().getSimpleName(),frame);\n        }\n\n        // Specified Close Case\n        if ((frame instanceof CloseFrame) && (events.onClose != null))\n        {\n            CloseFrame close = (CloseFrame)frame;\n            events.onClose.call(websocket,connection,close.getStatusCode(),close.getReason());\n            return;\n        }\n\n        try\n        {\n            // Specified Text Case\n            if ((frame instanceof TextFrame) && (events.onText != null))\n            {\n                TextFrame text = (TextFrame)frame;\n                events.onText.call(websocket,connection,text.getPayloadUTF8());\n                return;\n            }\n\n            // Specified Binary Case\n            if ((frame instanceof BinaryFrame) && (events.onBinary != null))\n            {\n                BinaryFrame bin = (BinaryFrame)frame;\n\n                if (events.onBinary.isParameterPresent(ByteBuffer.class))\n                {\n                    // Byte buffer approach\n                    events.onBinary.call(websocket,connection,bin.getPayload());\n                }\n                else\n                {\n                    // Byte array approach\n                    byte buf[] = BufferUtil.toArray(bin.getPayload());\n                    events.onBinary.call(websocket,connection,buf,0,buf.length);\n                }\n\n                return;\n            }\n\n            // Basic Hierarchy Case\n            Class<? extends BaseFrame> frameType = frame.getClass();\n            while (true)\n            {\n                EventMethod event = events.getOnFrame(frameType);\n                if (event != null)\n                {\n                    event.call(websocket,connection,frame);\n                    return;\n                }\n\n                if (!BaseFrame.class.isAssignableFrom(frameType.getSuperclass()))\n                {\n                    // not assignable\n                    return;\n                }\n                frameType = (Class<? extends BaseFrame>)frameType.getSuperclass();\n            }\n        }\n        catch (Throwable t)\n        {\n            unhandled(t);\n        }\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Test the requirement of responding with server terminated close code 1011 when there is an unhandled (internal server error) being produced by the\n     * extended WebSocketServlet.\n     */\n    @Test\n    @Ignore(\"temporary, want to focus on onFillable first\")\n    public void testInternalError() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            // Generate text frame\n            client.write(new TextFrame(\"CRASH\"));\n\n            // Read frame (hopefully close frame)\n            Queue<BaseFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            CloseFrame cf = (CloseFrame)frames.remove();\n            Assert.assertThat(\"Close Frame.status code\",cf.getStatusCode(),is((int)StatusCode.SERVER_ERROR));\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":88155,"modified_method":"/**\n     * Test the requirement of responding with server terminated close code 1011 when there is an unhandled (internal server error) being produced by the\n     * WebSocket POJO.\n     */\n    @Test\n    public void testInternalError() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            // Generate text frame\n            client.write(new TextFrame(\"CRASH\"));\n\n            // Read frame (hopefully close frame)\n            Queue<BaseFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            CloseFrame cf = (CloseFrame)frames.remove();\n            Assert.assertThat(\"Close Frame.status code\",cf.getStatusCode(),is((int)StatusCode.SERVER_ERROR));\n        }\n        finally\n        {\n            client.close();\n        }\n    }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void onWebSocketText(String message)\n        {\n            LOG.debug(\"onWebSocketText({})\",message);\n            // Test the RFC 6455 close code 1011 that should close\n            // trigger a WebSocket server terminated close.\n            if (message.equals(\"CRASH\"))\n            {\n                System.out.printf(\"Got OnTextMessage\");\n                throw new RuntimeException(\"Something bad happened\");\n            }\n\n            // echo the message back.\n            try\n            {\n                getConnection().write(message);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace(System.err);\n            }\n        }","id":88156,"modified_method":"@Override\n        public void onWebSocketText(String message)\n        {\n            LOG.debug(\"onWebSocketText({})\",message);\n            // Test the RFC 6455 close code 1011 that should close\n            // trigger a WebSocket server terminated close.\n            if (message.equals(\"CRASH\"))\n            {\n                throw new RuntimeException(\"Something bad happened\");\n            }\n\n            // echo the message back.\n            try\n            {\n                getConnection().write(message);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace(System.err);\n            }\n        }","commit_id":"0a301b153e8959239941bc7e574a3fa8e4a18ff6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void exchangeTerminated(HttpExchange exchange, Result result)\n    {\n        super.exchangeTerminated(exchange, result);\n\n        Response response = result.getResponse();\n        HttpFields responseHeaders = response.getHeaders();\n        boolean close = result.isFailed() || receiver.isShutdown();\n\n        if (!close)\n        {\n            if (response.getVersion().compareTo(HttpVersion.HTTP_1_1) < 0)\n            {\n                // HTTP 1.0 must close the connection unless it has an explicit keep alive.\n                close = !responseHeaders.contains(HttpHeader.CONNECTION, HttpHeaderValue.KEEP_ALIVE.asString());\n            }\n            else\n            {\n                // HTTP 1.1 or greater closes only if it has an explicit close.\n                close = responseHeaders.contains(HttpHeader.CONNECTION, HttpHeaderValue.CLOSE.asString());\n            }\n        }\n\n        if (close)\n            connection.close();\n        else\n            release();\n    }","id":88157,"modified_method":"@Override\n    public void exchangeTerminated(HttpExchange exchange, Result result)\n    {\n        super.exchangeTerminated(exchange, result);\n\n        Response response = result.getResponse();\n        HttpFields responseHeaders = response.getHeaders();\n\n        String closeReason = null;\n        if (result.isFailed())\n            closeReason = \"failure\";\n        else if (receiver.isShutdown())\n            closeReason = \"server close\";\n\n        if (closeReason == null)\n        {\n            if (response.getVersion().compareTo(HttpVersion.HTTP_1_1) < 0)\n            {\n                // HTTP 1.0 must close the connection unless it has\n                // an explicit keep alive or it's a CONNECT method.\n                boolean keepAlive = responseHeaders.contains(HttpHeader.CONNECTION, HttpHeaderValue.KEEP_ALIVE.asString());\n                boolean connect = HttpMethod.CONNECT.is(exchange.getRequest().getMethod());\n                if (!keepAlive && !connect)\n                    closeReason = \"http/1.0\";\n            }\n            else\n            {\n                // HTTP 1.1 or greater closes only if it has an explicit close.\n                if (responseHeaders.contains(HttpHeader.CONNECTION, HttpHeaderValue.CLOSE.asString()))\n                    closeReason = \"http/1.1\";\n            }\n        }\n\n        if (closeReason != null)\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Closing, reason: {} - {}\", closeReason, connection);\n            connection.close();\n        }\n        else\n        {\n            release();\n        }\n    }","commit_id":"c24aa25dfb4a8f7bad765b07f1511e5c3ed46eff","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_POST_WithContent_NotifiesRequestContentListener() throws Exception\n    {\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                consume(request.getInputStream());\n            }\n        });\n\n        final byte[] content = {0, 1, 2, 3};\n        ContentResponse response = client.POST(scheme + \"://localhost:\" + connector.getLocalPort())\n                .onRequestContent(new Request.ContentListener()\n                {\n                    @Override\n                    public void onContent(Request request, ByteBuffer buffer)\n                    {\n                        byte[] bytes = new byte[buffer.remaining()];\n                        buffer.get(bytes);\n                        if (!Arrays.equals(content, bytes))\n                            request.abort(new Exception());\n                    }\n                })\n                .content(new BytesContentProvider(content))\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n    }","id":88158,"modified_method":"@Test\n    public void test_POST_WithContent_NotifiesRequestContentListener() throws Exception\n    {\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                consume(request.getInputStream(), true);\n            }\n        });\n\n        final byte[] content = {0, 1, 2, 3};\n        ContentResponse response = client.POST(scheme + \"://localhost:\" + connector.getLocalPort())\n                .onRequestContent(new Request.ContentListener()\n                {\n                    @Override\n                    public void onContent(Request request, ByteBuffer buffer)\n                    {\n                        byte[] bytes = new byte[buffer.remaining()];\n                        buffer.get(bytes);\n                        if (!Arrays.equals(content, bytes))\n                            request.abort(new Exception());\n                    }\n                })\n                .content(new BytesContentProvider(content))\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n    }","commit_id":"c24aa25dfb4a8f7bad765b07f1511e5c3ed46eff","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_POST_WithContent_TracksProgress() throws Exception\n    {\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                consume(request.getInputStream());\n            }\n        });\n\n        final AtomicInteger progress = new AtomicInteger();\n        ContentResponse response = client.POST(scheme + \"://localhost:\" + connector.getLocalPort())\n                .onRequestContent(new Request.ContentListener()\n                {\n                    @Override\n                    public void onContent(Request request, ByteBuffer buffer)\n                    {\n                        byte[] bytes = new byte[buffer.remaining()];\n                        Assert.assertEquals(1, bytes.length);\n                        buffer.get(bytes);\n                        Assert.assertEquals(bytes[0], progress.getAndIncrement());\n                    }\n                })\n                .content(new BytesContentProvider(new byte[]{0}, new byte[]{1}, new byte[]{2}, new byte[]{3}, new byte[]{4}))\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertEquals(5, progress.get());\n    }","id":88159,"modified_method":"@Test\n    public void test_POST_WithContent_TracksProgress() throws Exception\n    {\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                consume(request.getInputStream(), true);\n            }\n        });\n\n        final AtomicInteger progress = new AtomicInteger();\n        ContentResponse response = client.POST(scheme + \"://localhost:\" + connector.getLocalPort())\n                .onRequestContent(new Request.ContentListener()\n                {\n                    @Override\n                    public void onContent(Request request, ByteBuffer buffer)\n                    {\n                        byte[] bytes = new byte[buffer.remaining()];\n                        Assert.assertEquals(1, bytes.length);\n                        buffer.get(bytes);\n                        Assert.assertEquals(bytes[0], progress.getAndIncrement());\n                    }\n                })\n                .content(new BytesContentProvider(new byte[]{0}, new byte[]{1}, new byte[]{2}, new byte[]{3}, new byte[]{4}))\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertEquals(5, progress.get());\n    }","commit_id":"c24aa25dfb4a8f7bad765b07f1511e5c3ed46eff","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void consume(InputStream input) throws IOException\n    {\n        while (true)\n        {\n            if (input.read() < 0)\n                break;\n        }\n    }","id":88160,"modified_method":"private void consume(InputStream input, boolean eof) throws IOException\n    {\n        int crlfs = 0;\n        while (true)\n        {\n            int read = input.read();\n            if (read == '\\r' || read == '\\n')\n                ++crlfs;\n            else\n                crlfs = 0;\n            if (!eof && crlfs == 4)\n                break;\n            if (read < 0)\n                break;\n        }\n    }","commit_id":"c24aa25dfb4a8f7bad765b07f1511e5c3ed46eff","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_POST_WithParameters_WithContent() throws Exception\n    {\n        final byte[] content = {0, 1, 2, 3};\n        final String paramName = \"a\";\n        final String paramValue = \"\\u20AC\";\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                consume(request.getInputStream());\n                String value = request.getParameter(paramName);\n                if (paramValue.equals(value))\n                {\n                    response.setCharacterEncoding(\"UTF-8\");\n                    response.setContentType(\"text/plain\");\n                    response.getOutputStream().write(content);\n                }\n            }\n        });\n\n        ContentResponse response = client.POST(scheme + \"://localhost:\" + connector.getLocalPort() + \"/?b=1\")\n                .param(paramName, paramValue)\n                .content(new BytesContentProvider(content))\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertArrayEquals(content, response.getContent());\n    }","id":88161,"modified_method":"@Test\n    public void test_POST_WithParameters_WithContent() throws Exception\n    {\n        final byte[] content = {0, 1, 2, 3};\n        final String paramName = \"a\";\n        final String paramValue = \"\\u20AC\";\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                baseRequest.setHandled(true);\n                consume(request.getInputStream(), true);\n                String value = request.getParameter(paramName);\n                if (paramValue.equals(value))\n                {\n                    response.setCharacterEncoding(\"UTF-8\");\n                    response.setContentType(\"text/plain\");\n                    response.getOutputStream().write(content);\n                }\n            }\n        });\n\n        ContentResponse response = client.POST(scheme + \"://localhost:\" + connector.getLocalPort() + \"/?b=1\")\n                .param(paramName, paramValue)\n                .content(new BytesContentProvider(content))\n                .timeout(5, TimeUnit.SECONDS)\n                .send();\n\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertArrayEquals(content, response.getContent());\n    }","commit_id":"c24aa25dfb4a8f7bad765b07f1511e5c3ed46eff","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestRetries() throws Exception\n    {\n        final int maxRetries = 3;\n        final AtomicInteger requests = new AtomicInteger();\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                int count = requests.incrementAndGet();\n                if (count == maxRetries)\n                    baseRequest.setHandled(true);\n                consume(request.getInputStream());\n            }\n        });\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        new RetryListener(client, scheme, \"localhost\", connector.getLocalPort(), maxRetries)\n        {\n            @Override\n            protected void completed(Result result)\n            {\n                latch.countDown();\n            }\n        }.perform();\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":88162,"modified_method":"@Test\n    public void testRequestRetries() throws Exception\n    {\n        final int maxRetries = 3;\n        final AtomicInteger requests = new AtomicInteger();\n        start(new AbstractHandler()\n        {\n            @Override\n            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                int count = requests.incrementAndGet();\n                if (count == maxRetries)\n                    baseRequest.setHandled(true);\n                consume(request.getInputStream(), true);\n            }\n        });\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        new RetryListener(client, scheme, \"localhost\", connector.getLocalPort(), maxRetries)\n        {\n            @Override\n            protected void completed(Result result)\n            {\n                latch.countDown();\n            }\n        }.perform();\n\n        Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","commit_id":"c24aa25dfb4a8f7bad765b07f1511e5c3ed46eff","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    checkOpeness();\r\n\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    final ODatabaseDocumentPool localCopy = ownerPool;\r\n    ownerPool = null;\r\n    localCopy.release(this);\r\n  }","id":88163,"modified_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    checkOpeness();\r\n\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    if (ownerPool != null) {\r\n      final ODatabaseDocumentPool localCopy = ownerPool;\r\n      ownerPool = null;\r\n      localCopy.release(this);\r\n    }\r\n  }","commit_id":"dafc3c0ee64c6e918eab671e3830f6ae890a8336","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    objects2Records.clear();\r\n    records2Objects.clear();\r\n    rid2Records.clear();\r\n\r\n    checkOpeness();\r\n\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    final ODatabaseObjectPool localCopy = ownerPool;\r\n    ownerPool = null;\r\n    localCopy.release(this);\r\n  }","id":88164,"modified_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    objects2Records.clear();\r\n    records2Objects.clear();\r\n    rid2Records.clear();\r\n\r\n    checkOpeness();\r\n\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    if (ownerPool != null) {\r\n      final ODatabaseObjectPool localCopy = ownerPool;\r\n      ownerPool = null;\r\n      localCopy.release(this);\r\n    }\r\n  }","commit_id":"dafc3c0ee64c6e918eab671e3830f6ae890a8336","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    vertexBaseClass = null;\r\n    edgeBaseClass = null;\r\n\r\n    checkOpeness();\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    final OGraphDatabasePool pool = ownerPool;\r\n    ownerPool = null;\r\n    pool.release(this);\r\n  }","id":88165,"modified_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    vertexBaseClass = null;\r\n    edgeBaseClass = null;\r\n\r\n    checkOpeness();\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    if (ownerPool != null) {\r\n      final OGraphDatabasePool pool = ownerPool;\r\n      ownerPool = null;\r\n      pool.release(this);\r\n    }\r\n  }","commit_id":"dafc3c0ee64c6e918eab671e3830f6ae890a8336","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    objects2Records.clear();\r\n    records2Objects.clear();\r\n    rid2Records.clear();\r\n\r\n    checkOpeness();\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    final OObjectDatabasePool localCopy = ownerPool;\r\n    ownerPool = null;\r\n    localCopy.release(this);\r\n  }","id":88166,"modified_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    objects2Records.clear();\r\n    records2Objects.clear();\r\n    rid2Records.clear();\r\n\r\n    checkOpeness();\r\n    try {\r\n      rollback();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    try {\r\n      ODatabase current = underlying;\r\n      while (!(current instanceof ODatabaseRaw) && ((ODatabaseComplex<?>) current).getUnderlying() != null)\r\n        current = ((ODatabaseComplex<?>) current).getUnderlying();\r\n      ((ODatabaseRaw) current).callOnCloseListeners();\r\n    } catch (Exception e) {\r\n      OLogManager.instance().error(this, \"Error on releasing database '%s' in pool\", e, getName());\r\n    }\r\n\r\n    getLevel1Cache().clear();\r\n\r\n    if (ownerPool != null) {\r\n      final OObjectDatabasePool localCopy = ownerPool;\r\n      ownerPool = null;\r\n      localCopy.release(this);\r\n    }\r\n  }","commit_id":"dafc3c0ee64c6e918eab671e3830f6ae890a8336","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void release(final DB iDatabase) {\r\n\t\tdbPool.release(iDatabase);\r\n\t}","id":88167,"modified_method":"/**\r\n\t * Don't call it directly but use database.close().\r\n\t * \r\n\t * @param iDatabase\r\n\t */\r\n\tpublic void release(final DB iDatabase) {\r\n\t\tif (dbPool != null)\r\n\t\t\tdbPool.release(iDatabase);\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Map<String, OResourcePool<String, DB>> getPools() {\r\n\t\treturn dbPool.getPools();\r\n\t}","id":88168,"modified_method":"/**\r\n\t * Returns all the configured pools.\r\n\t * \r\n\t */\r\n\tpublic Map<String, OResourcePool<String, DB>> getPools() {\r\n\t\treturn dbPool.getPools();\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public DB acquire(final String iName, final String iUserName, final String iUserPassword,\r\n\t\t\tfinal Map<String, Object> iOptionalParams) {\r\n\t\tsetup();\r\n\t\treturn dbPool.acquire(iName, iUserName, iUserPassword, iOptionalParams);\r\n\t}","id":88169,"modified_method":"/**\r\n\t * Acquires a connection from the pool specifying options. If the pool is empty, then the caller thread will wait for it.\r\n\t * \r\n\t * @param iName\r\n\t *          Database name\r\n\t * @param iUserName\r\n\t *          User name\r\n\t * @param iUserPassword\r\n\t *          User password\r\n\t * @return A pooled database instance\r\n\t */\r\n\tpublic DB acquire(final String iName, final String iUserName, final String iUserPassword,\r\n\t\t\tfinal Map<String, Object> iOptionalParams) {\r\n\t\tsetup();\r\n\t\treturn dbPool.acquire(iName, iUserName, iUserPassword, iOptionalParams);\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void close() {\r\n\t\tif (dbPool != null){\r\n\t\t\tdbPool.close();\r\n\t\t\tdbPool = null;\r\n\t\t}\r\n\t}","id":88170,"modified_method":"/**\r\n\t * Closes the entire pool freeing all the connections.\r\n\t */\r\n\tpublic void close() {\r\n\t\tif (dbPool != null) {\r\n\t\t\tdbPool.close();\r\n\t\t\tdbPool = null;\r\n\t\t}\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public DB acquire(final String iName, final String iUserName, final String iUserPassword) {\r\n\t\tsetup();\r\n\t\treturn dbPool.acquire(iName, iUserName, iUserPassword);\r\n\t}","id":88171,"modified_method":"/**\r\n\t * Acquires a connection from the pool. If the pool is empty, then the caller thread will wait for it.\r\n\t * \r\n\t * @param iName\r\n\t *          Database name\r\n\t * @param iUserName\r\n\t *          User name\r\n\t * @param iUserPassword\r\n\t *          User password\r\n\t * @return A pooled database instance\r\n\t */\r\n\tpublic DB acquire(final String iName, final String iUserName, final String iUserPassword) {\r\n\t\tsetup();\r\n\t\treturn dbPool.acquire(iName, iUserName, iUserPassword);\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void remove(final String iName, final String iUser) {\r\n\t\tdbPool.remove(iName, iUser);\r\n\t}","id":88172,"modified_method":"/**\r\n\t * Removes a pool by name/user\r\n\t * \r\n\t */\r\n\tpublic void remove(final String iName, final String iUser) {\r\n\t\tdbPool.remove(iName, iUser);\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int getMaxSize() {\r\n\t\tsetup();\r\n\t\treturn dbPool.getMaxSize();\r\n\t}","id":88173,"modified_method":"/**\r\n\t * Returns the maximum size of the pool\r\n\t * \r\n\t */\r\n\tpublic int getMaxSize() {\r\n\t\tsetup();\r\n\t\treturn dbPool.getMaxSize();\r\n\t}","commit_id":"5c4c0a2e9680df584329d5d6d4277d763e03da0d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void doPost(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException\n\t{\t\n\t\tHttpServletRequest request = null;\n\n\t\t//For POST request, If we are logging the requests we must wrap HttpServletRequest in HttpServletRequestWrapper\n\t\t//otherwise we cannot access the POST parameters from the content body of the request!!! - deliriumsky\n\t\tDescriptor descriptor = Descriptor.getDescriptorSingleton();\n\t\tif(descriptor != null)\n\t\t{\n\t\t\tif(descriptor.allowRequestLogging())\n\t\t\t{\n\t\t\t\trequest = new HttpServletRequestWrapper(req, formEncoding);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest = req;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trequest = req;\n\t\t}\n\t\t\n\t\t//first, adjust the path\n\t\tString path = request.getPathInfo();\n\t\tif(path == null)\n\t\t{\n\t\t\tpath = \"\";\n\t\t}\n\t\telse\n\t\t{\n            path = adjustPath(request);\n\t\t}\n\t\t\n\t\t//second, perform descriptor actions\n    \tif(descriptor != null)\n    \t{\n    \t\t//logs the request if specified in the descriptor\n    \t\tdescriptor.doLogRequestInReplayLog(request);\n    \t\t\n    \t\t//map's the path if a mapping is specified in the descriptor\n    \t\tpath = descriptor.mapPath(path);\n    \t}\n\t\t\n    \t//third, authenticate the user\n\t\tUser user = authenticate(request,response);\n\t\tif (user == null) {\n                        // You now get a challenge if there is no user\n\t\t\t//response.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t//\t\t\"Permission denied: unknown user \" + \"or password\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//fouth, process the request\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(user);\n\n\t\t\t//Route the request\n\t\t\tif(path.indexOf(SOAPServer.WEBSERVICE_MODULE_EXTENSION) > -1)\n\t\t\t{\n\t\t\t\t//SOAP Server\n\t\t\t\tsrvSOAP.doPost(broker, request, response, path);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//REST Server\n\t\t\t\tsrvREST.doPost(broker, request, response, path);\n\t\t\t}\n\t\t} catch (PermissionDeniedException e) {\n\t\t\tresponse\n\t\t\t.sendError(HttpServletResponse.SC_FORBIDDEN, e.getMessage());\n\t\t} catch (EXistException e) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e\n\t\t\t\t\t.getMessage());\n\t\t} catch (BadRequestException e) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":88174,"modified_method":"protected void doPost(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException\n\t{\t\n\t\tHttpServletRequest request = null;\n\n\t\t//For POST request, If we are logging the requests we must wrap HttpServletRequest in HttpServletRequestWrapper\n\t\t//otherwise we cannot access the POST parameters from the content body of the request!!! - deliriumsky\n\t\tDescriptor descriptor = Descriptor.getDescriptorSingleton();\n\t\tif(descriptor != null)\n\t\t{\n\t\t\tif(descriptor.allowRequestLogging())\n\t\t\t{\n\t\t\t\trequest = new HttpServletRequestWrapper(req, formEncoding);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trequest = req;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trequest = req;\n\t\t}\n\t\t\n\t\t//first, adjust the path\n\t\tString path = request.getPathInfo();\n\t\tif(path == null)\n\t\t{\n\t\t\tpath = \"\";\n\t\t}\n\t\telse\n\t\t{\n            path = adjustPath(request);\n\t\t}\n\t\t\n\t\t//second, perform descriptor actions\n    \tif(descriptor != null)\n    \t{\n    \t\t//logs the request if specified in the descriptor\n    \t\tdescriptor.doLogRequestInReplayLog(request);\n    \t\t\n    \t\t//map's the path if a mapping is specified in the descriptor\n    \t\tpath = descriptor.mapPath(path);\n    \t}\n\t\t\n    \t//third, authenticate the user\n\t\tUser user = authenticate(request,response);\n\t\tif (user == null) {\n                        // You now get a challenge if there is no user\n\t\t\t//response.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t//\t\t\"Permission denied: unknown user \" + \"or password\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//fouth, process the request\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(user);\n\n\t\t\t//Route the request\n\t\t\tif(path.indexOf(SOAPServer.WEBSERVICE_MODULE_EXTENSION) > -1)\n\t\t\t{\n\t\t\t\t//SOAP Server\n\t\t\t\tsrvSOAP.doPost(broker, request, response, path);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//REST Server\n\t\t\t\tsrvREST.doPost(broker, request, response, path);\n\t\t\t}\n\t\t} catch (PermissionDeniedException e) {\n\t\t\tresponse\n\t\t\t.sendError(HttpServletResponse.SC_FORBIDDEN, e.getMessage());\n\t\t} catch (EXistException e) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e\n\t\t\t\t\t.getMessage());\n\t\t} catch (BadRequestException e) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n\t\t} catch (NotFoundException e) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, e.getMessage());\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n         * Gets XQWS file from the db\n         * \n         * @param broker \tThe Database Broker to use\n         * @param path\t\tThe Path to the XQWS\n         * \n         * @return\tThe XQWS BinaryDocument\n         */\n        private BinaryDocument getXQWS(DBBroker broker, String path) throws PermissionDeniedException\n        {\n            XmldbURI pathUri = XmldbURI.create(path);        \n            BinaryDocument docXQWS = (BinaryDocument) broker.getXMLResource(pathUri, Lock.READ_LOCK);\n            \n            //close the XQWS Document and release the read lock\n            docXQWS.getUpdateLock().release();\n            \n            return docXQWS;\n        }","id":88175,"modified_method":"/**\r\n         * Gets XQWS file from the db\r\n         * \r\n         * @param broker \tThe Database Broker to use\r\n         * @param path\t\tThe Path to the XQWS\r\n         * \r\n         * @return\tThe XQWS BinaryDocument\r\n         */\r\n        private BinaryDocument getXQWS(DBBroker broker, String path) throws PermissionDeniedException\r\n        {\r\n            XmldbURI pathUri = XmldbURI.create(path);        \r\n            BinaryDocument docXQWS = (BinaryDocument) broker.getXMLResource(pathUri, Lock.READ_LOCK);\r\n            \r\n            //close the XQWS Document and release the read lock\r\n\t    if(docXQWS!=null) {\r\n\t            docXQWS.getUpdateLock().release();\r\n            }\r\n\t                \r\n            return docXQWS;\r\n        }","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n    \t * Describes an XQWS function by building an XML node representation of the function signature\n    \t * \n    \t * \t<function>\n    \t * \t\t<name/>\n    \t * \t\t<description/>\n    \t * \t\t<parameters>\n    \t * \t\t\t<parameter>\t{ unbounded }\n    \t * \t\t\t\t<name/>\n    \t * \t\t\t\t<type/>\n    \t * \t\t\t\t<cardinality/>\n    \t * \t\t\t<\/parameter>\n    \t * \t\t<\/parameters>\n    \t * \t\t<return>\n    \t * \t\t\t<type/>\n    \t * \t\t\t<cardinality/>\n    \t * \t\t\t<result>\t\t{ Only displayed if this is after the function has been executed }\n    \t * \t\t\t\teither {\n    \t * \t\t\t\t\t<value/> or\n    \t * \t\t\t\t\t<sequence>\n    \t * \t\t\t\t\t\t<value/> { unbounded }\n    \t * \t\t\t\t\t<\/sequence>\n    \t * \t\t\t\t}\n    \t * \t\t\t<\/result>\n    \t * \t\t<\/return>\n    \t * \t<\/function>\n    \t * \n    \t * @param signature\tThe function signature to describe\n    \t * @param builderFunction\tThe MemTreeBuilder to write the description to\n    \t * @param functionResult\tA Sequence containing the function results or null if the function has not yet been executed\n    \t */\n    \tprivate void describeWebServiceFunction(FunctionSignature signature, MemTreeBuilder builderFunction, Sequence functionResult) throws XPathException\n    \t{\n    \t\t//Generate an XML snippet for each function\n        \tbuilderFunction.startElement(new QName(\"function\", null, null), null);\n        \tbuilderFunction.startElement(new QName(\"name\", null, null), null);\n        \tbuilderFunction.characters(signature.getName().getLocalName());\n        \tbuilderFunction.endElement();\n        \tif(signature.getDescription() != null)\n        \t{\n        \t\tbuilderFunction.startElement(new QName(\"description\", null, null), null);\n        \t\tbuilderFunction.characters(signature.getDescription());\n        \t\tbuilderFunction.endElement();\n        \t}\n        \tSequenceType[] xqwsArguments = signature.getArgumentTypes();\n        \tbuilderFunction.startElement(new QName(\"parameters\", null, null), null);\n        \tfor(int a = 0; a < xqwsArguments.length; a++)\n        \t{\n        \t\tbuilderFunction.startElement(new QName(\"parameter\",null, null), null);\n        \t\tbuilderFunction.startElement(new QName(\"name\",null, null), null);\n        \t\t//builderFunction.characters(xqwsArguments[a].getNodeName().getLocalName()); //TODO: how to get parameter name?\n        \t\tbuilderFunction.endElement();\n        \t\tbuilderFunction.startElement(new QName(\"type\",null, null), null);\n        \t\tbuilderFunction.characters(Type.getTypeName(xqwsArguments[a].getPrimaryType()));\n        \t\tbuilderFunction.endElement();\n        \t\tbuilderFunction.startElement(new QName(\"cardinality\",null, null), null);\n        \t\tbuilderFunction.characters(Integer.toString(xqwsArguments[a].getCardinality()));\n        \t\tbuilderFunction.endElement();\n        \t\tbuilderFunction.endElement();\n        \t}\n        \tbuilderFunction.endElement();\n        \tbuilderFunction.startElement(new QName(\"return\",null, null), null);\n        \tbuilderFunction.startElement(new QName(\"type\",null, null), null);\n        \tbuilderFunction.characters(Type.getTypeName(signature.getReturnType().getPrimaryType()));\n        \tbuilderFunction.endElement();\n        \tint iReturnCardinality = signature.getReturnType().getCardinality();\n        \tbuilderFunction.startElement(new QName(\"cardinality\",null, null), null);\n        \tbuilderFunction.characters(Integer.toString(iReturnCardinality));\n        \tbuilderFunction.endElement();\n        \tif(functionResult != null)\n        \t{\n        \t\tbuilderFunction.startElement(new QName(\"result\", null, null), null);\n        \t\t\n        \t\t//determine result cardinality\n        \t\tif(iReturnCardinality >= Cardinality.MANY)\n        \t\t{\n        \t\t\t//sequence of values\n        \t\t\tbuilderFunction.startElement(new QName(\"sequence\", null, null), null);\n        \t\t\t\n        \t\t\tfor(int i=0; i < functionResult.getLength(); i++)\n        \t\t\t{\n            \t\t\tbuilderFunction.startElement(new QName(\"value\", null, null), null);\n            \t\t\tbuilderFunction.characters(functionResult.itemAt(i).getStringValue());\n            \t\t\tbuilderFunction.endElement();\n        \t\t\t}\n        \t\t\t\n        \t\t\tbuilderFunction.endElement();\n        \t\t}\n        \t\telse\n        \t\t{\n        \t\t\t//atomic value\n        \t\t\tbuilderFunction.startElement(new QName(\"value\", null, null), null);\n        \t\t\tbuilderFunction.characters(functionResult.itemAt(0).getStringValue());\n        \t\t\tbuilderFunction.endElement();\n        \t\t}\n        \t\t\n        \t\tbuilderFunction.endElement();\n        \t}\n        \tbuilderFunction.endElement();\n        \tbuilderFunction.endElement();\n    \t}","id":88176,"modified_method":"/**\r\n    \t * Describes an XQWS function by building an XML node representation of the function signature\r\n    \t * \r\n    \t * \t<function>\r\n    \t * \t\t<name/>\r\n    \t * \t\t<description/>\r\n    \t * \t\t<parameters>\r\n    \t * \t\t\t<parameter>\t{ unbounded }\r\n    \t * \t\t\t\t<name/>\r\n    \t * \t\t\t\t<type/>\r\n    \t * \t\t\t\t<cardinality/>\r\n    \t * \t\t\t<\/parameter>\r\n    \t * \t\t<\/parameters>\r\n    \t * \t\t<return>\r\n    \t * \t\t\t<type/>\r\n    \t * \t\t\t<cardinality/>\r\n    \t * \t\t\t<result>\t\t{ Only displayed if this is after the function has been executed }\r\n    \t * \t\t\t\teither {\r\n    \t * \t\t\t\t\t<value/> or\r\n    \t * \t\t\t\t\t<sequence>\r\n    \t * \t\t\t\t\t\t<value/> { unbounded }\r\n    \t * \t\t\t\t\t<\/sequence>\r\n    \t * \t\t\t\t}\r\n    \t * \t\t\t<\/result>\r\n    \t * \t\t<\/return>\r\n    \t * \t<\/function>\r\n    \t * \r\n    \t * @param signature\tThe function signature to describe\r\n    \t * @param builderFunction\tThe MemTreeBuilder to write the description to\r\n    \t * @param functionResult\tA Sequence containing the function results or null if the function has not yet been executed\r\n    \t */\r\n    \tprivate void describeWebServiceFunction(FunctionSignature signature, MemTreeBuilder builderFunction, Sequence functionResult) throws XPathException,SAXException\r\n    \t{\r\n    \t\t//Generate an XML snippet for each function\r\n        \tbuilderFunction.startElement(new QName(\"function\", null, null), null);\r\n        \tbuilderFunction.startElement(new QName(\"name\", null, null), null);\r\n        \tbuilderFunction.characters(signature.getName().getLocalName());\r\n        \tbuilderFunction.endElement();\r\n        \tif(signature.getDescription() != null)\r\n        \t{\r\n        \t\tbuilderFunction.startElement(new QName(\"description\", null, null), null);\r\n        \t\tbuilderFunction.characters(signature.getDescription());\r\n        \t\tbuilderFunction.endElement();\r\n        \t}\r\n        \tSequenceType[] xqwsArguments = signature.getArgumentTypes();\r\n        \tbuilderFunction.startElement(new QName(\"parameters\", null, null), null);\r\n        \tfor(int a = 0; a < xqwsArguments.length; a++)\r\n        \t{\r\n        \t\tbuilderFunction.startElement(new QName(\"parameter\",null, null), null);\r\n        \t\tbuilderFunction.startElement(new QName(\"name\",null, null), null);\r\n        \t\t//builderFunction.characters(xqwsArguments[a].getNodeName().getLocalName()); //TODO: how to get parameter name?\r\n        \t\tbuilderFunction.endElement();\r\n        \t\tbuilderFunction.startElement(new QName(\"type\",null, null), null);\r\n        \t\tbuilderFunction.characters(Type.getTypeName(xqwsArguments[a].getPrimaryType()));\r\n        \t\tbuilderFunction.endElement();\r\n        \t\tbuilderFunction.startElement(new QName(\"cardinality\",null, null), null);\r\n        \t\tbuilderFunction.characters(Integer.toString(xqwsArguments[a].getCardinality()));\r\n        \t\tbuilderFunction.endElement();\r\n        \t\tbuilderFunction.endElement();\r\n        \t}\r\n        \tbuilderFunction.endElement();\r\n        \tbuilderFunction.startElement(new QName(\"return\",null, null), null);\r\n        \tbuilderFunction.startElement(new QName(\"type\",null, null), null);\r\n        \tbuilderFunction.characters(Type.getTypeName(signature.getReturnType().getPrimaryType()));\r\n        \tbuilderFunction.endElement();\r\n        \tint iReturnCardinality = signature.getReturnType().getCardinality();\r\n        \tbuilderFunction.startElement(new QName(\"cardinality\",null, null), null);\r\n        \tbuilderFunction.characters(Integer.toString(iReturnCardinality));\r\n        \tbuilderFunction.endElement();\r\n        \tif(functionResult != null)\r\n        \t{\r\n        \t\tbuilderFunction.startElement(new QName(\"result\", null, null), null);\r\n        \t\t\r\n        \t\t//determine result cardinality\r\n\t\t\tDocumentBuilderReceiver receiver = new DocumentBuilderReceiver(builderFunction);\r\n        \t\tif(iReturnCardinality >= Cardinality.MANY)\r\n        \t\t{\r\n        \t\t\t//sequence of values\r\n        \t\t\tbuilderFunction.startElement(new QName(\"sequence\", null, null), null);\r\n        \t\t\t\r\n        \t\t\tfor(int i=0; i < functionResult.getLength(); i++)\r\n        \t\t\t{\r\n            \t\t\tbuilderFunction.startElement(new QName(\"value\", null, null), null);\r\n\t\t\t\tfunctionResult.itemAt(i).copyTo(broker, receiver);\r\n            \t\t\t//builderFunction.characters(functionResult.itemAt(i).getStringValue());\r\n            \t\t\tbuilderFunction.endElement();\r\n        \t\t\t}\r\n        \t\t\t\r\n        \t\t\tbuilderFunction.endElement();\r\n        \t\t}\r\n        \t\telse\r\n        \t\t{\r\n        \t\t\t//atomic value\r\n        \t\t\tbuilderFunction.startElement(new QName(\"value\", null, null), null);\r\n        \t\t\tbuilderFunction.characters(functionResult.itemAt(0).getStringValue());\r\n        \t\t\tbuilderFunction.endElement();\r\n        \t\t}\r\n        \t\t\r\n        \t\tbuilderFunction.endElement();\r\n        \t}\r\n        \tbuilderFunction.endElement();\r\n        \tbuilderFunction.endElement();\r\n    \t}","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Writes a parameter for an XQuery function call\n     * \n     * @param paramType\tThe type of the Parameter (from the internal description of the XQWS)\n     * @param paramCardinality The cardinality of the Parameter (from the internal description of the XQWS)\n     * @param SOAPParam\tThe Node from the SOAP request for the Paremeter of the Function call from the Http Request \n     * \n     * @return A String representation of the parameter, suitable for use in the function call \n     */\n    private String writeXQueryFunctionParameter(String paramType, int paramCardinality, Node nSOAPParam) throws XPathException\n    {\n    \tString prefix = new String();\n    \tString postfix = new String();\n    \t\n    \t//determine the type of the parameter\n    \tint type = Type.getType(paramType);\n    \t\n    \tswitch(type)\n    \t{\n    \t\tcase Type.BASE64_BINARY:\n    \t\t\tprefix =\"xs:base64Binary(\\\"\";\n    \t\t\tpostfix = \"\\\")\";\n    \t\tbreak;\n    \t\t\n    \t\tcase Type.STRING:\n    \t\t\tprefix = \"\\\"\";\n    \t\t\tpostfix = \"\\\"\";\n    \t\tbreak;\n    \t\t\n    \t\tcase Type.DATE:\n    \t\t\tprefix = \"xs:date(\\\"\";\n    \t\t\tpostfix = \"\\\")\";\n    \t\tbreak;\n    \t\t\n    \t\tcase Type.DATE_TIME:\n    \t\t\tprefix = \"xs:dateTime(\\\"\";\n    \t\t\tpostfix = \"\\\")\";\n    \t\tbreak;\n    \t\t\n    \t\tdefault:\n    \t}\n    \n    \t//determine the cardinality of the parameter\n    \tif(paramCardinality >= Cardinality.MANY)\n    \t{\n    \t\t//sequence\n    \t\tStringBuffer param = new StringBuffer();\n    \t\t\n    \t\tparam.append(\"(\");\n    \t\t\n    \t\tNodeList nlParamSequenceItems = nSOAPParam.getChildNodes();\n    \t\tfor(int i=0; i < nlParamSequenceItems.getLength(); i++)\n    \t\t{\n    \t\t\tNode nParamSeqItem = nlParamSequenceItems.item(i);\n    \t\t\tif(nParamSeqItem.getNodeType() == Node.ELEMENT_NODE)\n    \t\t\t{\n    \t\t\t\tparam.append(prefix);\n    \t\t\t\tparam.append(nParamSeqItem.getFirstChild().getNodeValue());\n    \t\t\t\tparam.append(postfix);\n    \t        \t\n\t        \t\tparam.append(\",\");\t//seperator for next item in sequence\n    \t        \t\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\t//remove last superflurous seperator\n    \t\tif(param.charAt(param.length()-1) == ',')\n    \t\t{\n    \t\t\tparam.deleteCharAt(param.length()-1);\n    \t\t}\n    \t\t\n    \t\tparam.append(\")\");\n    \t\t\n    \t\treturn param.toString();\n    \t}\n    \telse\n    \t{\n    \t\t//atomic value\n    \t\treturn prefix +  nSOAPParam.getFirstChild().getNodeValue() + postfix;\n    \t}\n    }","id":88177,"modified_method":"/**\r\n     * Writes a parameter for an XQuery function call\r\n     * \r\n     * @param paramType\tThe type of the Parameter (from the internal description of the XQWS)\r\n     * @param paramCardinality The cardinality of the Parameter (from the internal description of the XQWS)\r\n     * @param SOAPParam\tThe Node from the SOAP request for the Paremeter of the Function call from the Http Request \r\n     * \r\n     * @return A String representation of the parameter, suitable for use in the function call \r\n     */\r\n    private StringBuffer writeXQueryFunctionParameter(String paramType, int paramCardinality, Node nSOAPParam) throws XPathException\r\n    {\r\n    \tString prefix = new String();\r\n    \tString postfix = prefix;\r\n    \t\r\n    \t//determine the type of the parameter\r\n    \tint type = Type.getType(paramType);\r\n\tint isAtomic=(Type.subTypeOf(type,Type.ATOMIC))?1:((Type.subTypeOf(type,Type.NODE))?-1:0);\r\n    \t\r\n\tif(isAtomic>=0) {\r\n\t\tif(isAtomic>0 && type!=Type.STRING) {\r\n\t\t\tString typeName=Type.getTypeName(type);\r\n\t\t\tif(typeName!=null) {\r\n\t\t\t\tprefix=typeName+\"(\\\"\";\r\n\t\t\t\tpostfix = \"\\\")\";\r\n\t\t\t}\r\n\t\t} else {\r\n    \t\t\tprefix = \"\\\"\";\r\n    \t\t\tpostfix = prefix;\r\n\t\t}\r\n\t}\r\n    \r\n\tStringBuffer param = new StringBuffer();\r\n    \t//determine the cardinality of the parameter\r\n    \tif(paramCardinality >= Cardinality.MANY)\r\n    \t{\r\n    \t\t//sequence\r\n    \t\t\r\n    \t\tparam.append(\"(\");\r\n    \t\t\r\n    \t\tNodeList nlParamSequenceItems = nSOAPParam.getChildNodes();\r\n    \t\tfor(int i=0; i < nlParamSequenceItems.getLength(); i++)\r\n    \t\t{\r\n    \t\t\tNode nParamSeqItem = nlParamSequenceItems.item(i);\r\n    \t\t\tif(nParamSeqItem.getNodeType() == Node.ELEMENT_NODE)\r\n    \t\t\t{\r\n\t\t\t\tprocessParameterValue(param,nParamSeqItem,prefix,postfix,isAtomic);\r\n\t\t\t\t\r\n\t        \t\tparam.append(\",\");\t//seperator for next item in sequence\r\n    \t        \t\r\n\t\t\t}\r\n    \t\t}\r\n    \t\t\r\n    \t\t//remove last superflurous seperator\r\n    \t\tif(param.charAt(param.length()-1) == ',')\r\n    \t\t{\r\n    \t\t\tparam.deleteCharAt(param.length()-1);\r\n    \t\t}\r\n    \t\t\r\n    \t\tparam.append(\")\");\r\n    \t}\r\n    \telse\r\n    \t{\r\n\t\tprocessParameterValue(param,nSOAPParam,prefix,postfix,isAtomic);\r\n    \t}\r\n\t\r\n\treturn param;\r\n    }","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Creates an XQuery to call an XQWS function from a SOAP Request\n     * \n     * @param broker\tThe Database Broker to use\n     * @param xqwsFileUri\tThe XmldbURI of the XQWS file\n     * @param xqwsNamespace\tThe namespace of the xqws\n     * @param xqwsCollectionUri\tThe XmldbUri of the collection where the XQWS resides\n     * @param xqwsSOAPFunction\tThe Node from the SOAP request for the Function call from the Http Request\n     * @param xqwsDescription\tThe internal description of the XQWS\n     * @param request\tThe Http Servlet Request\n     * @param response The Http Servlet Response\n     * \n     * @return The compiled XQuery\n     */\n    private CompiledXQuery XQueryExecuteXQWSFunction(DBBroker broker, Node xqwsSOAPFunction, XQWSDescription xqwsDescription, HttpServletRequest request, HttpServletResponse response) throws XPathException\n    {\t\n    \tStringBuffer query = new StringBuffer();\n    \tquery.append(\"xquery version \\\"1.0\\\";\" + SEPERATOR);\n    \tquery.append(SEPERATOR);\n        query.append(\"import module namespace \" + xqwsDescription.getNamespace().getLocalName() + \"=\\\"\" + xqwsDescription.getNamespace().getNamespaceURI() + \"\\\" at \\\"\" + xqwsDescription.getFileURI().toString() + \"\\\";\" + SEPERATOR);\n        query.append(SEPERATOR);\n        \n        //add the function call to the xquery\n        String functionName = xqwsSOAPFunction.getNodeName();\n        query.append(xqwsDescription.getNamespace().getLocalName() + \":\" + functionName + \"(\");\n        \n        //add the arguments for the function call if any\n        NodeList xqwsSOAPFunctionParams = xqwsSOAPFunction.getChildNodes();\n        Node nInternalFunction = xqwsDescription.getFunction(functionName);\n        NodeList nlInternalFunctionParams = xqwsDescription.getFunctionParameters(nInternalFunction);\n        \n        int j = 0;\n        for(int i = 0; i < xqwsSOAPFunctionParams.getLength(); i++)\n        {\n        \tNode nSOAPFunctionParam = xqwsSOAPFunctionParams.item(i);\n        \tif(nSOAPFunctionParam.getNodeType() == Node.ELEMENT_NODE)\n        \t{\n\t        \tquery.append(writeXQueryFunctionParameter(xqwsDescription.getFunctionParameterType(nlInternalFunctionParams.item(j)), xqwsDescription.getFunctionParameterCardinality(nlInternalFunctionParams.item(j)), nSOAPFunctionParam));\n        \t\tquery.append(\",\"); //add function seperator\n\t        \t\n\t        \tj++;\n        \t}\n        }\n        \n        //remove last superflurous seperator\n\t\tif(query.charAt(query.length()-1) == ',')\n\t\t{\n\t\t\tquery.deleteCharAt(query.length()-1);\n\t\t}\n        \n        query.append(\")\");\n        \n        //compile the query\n        return compileXQuery(broker, new StringSource(query.toString()), new XmldbURI[] { xqwsDescription.getCollectionURI() }, xqwsDescription.getCollectionURI(), request, response);\n    }","id":88178,"modified_method":"/**\r\n     * Creates an XQuery to call an XQWS function from a SOAP Request\r\n     * \r\n     * @param broker\tThe Database Broker to use\r\n     * @param xqwsFileUri\tThe XmldbURI of the XQWS file\r\n     * @param xqwsNamespace\tThe namespace of the xqws\r\n     * @param xqwsCollectionUri\tThe XmldbUri of the collection where the XQWS resides\r\n     * @param xqwsSOAPFunction\tThe Node from the SOAP request for the Function call from the Http Request\r\n     * @param xqwsDescription\tThe internal description of the XQWS\r\n     * @param request\tThe Http Servlet Request\r\n     * @param response The Http Servlet Response\r\n     * \r\n     * @return The compiled XQuery\r\n     */\r\n    private CompiledXQuery XQueryExecuteXQWSFunction(DBBroker broker, Node xqwsSOAPFunction, XQWSDescription xqwsDescription, HttpServletRequest request, HttpServletResponse response) throws XPathException\r\n    {\t\r\n    \tStringBuffer query = new StringBuffer();\r\n    \tquery.append(\"xquery version \\\"1.0\\\";\" + SEPERATOR);\r\n    \tquery.append(SEPERATOR);\r\n        query.append(\"import module namespace \" + xqwsDescription.getNamespace().getLocalName() + \"=\\\"\" + xqwsDescription.getNamespace().getNamespaceURI() + \"\\\" at \\\"\" + xqwsDescription.getFileURI().toString() + \"\\\";\" + SEPERATOR);\r\n        query.append(SEPERATOR);\r\n        \r\n        //add the function call to the xquery\r\n        String functionName = xqwsSOAPFunction.getLocalName();\r\n\tif(functionName==null) {\r\n\t\tfunctionName=xqwsSOAPFunction.getNodeName();\r\n\t}\r\n        query.append(xqwsDescription.getNamespace().getLocalName() + \":\" + functionName + \"(\");\r\n        \r\n        //add the arguments for the function call if any\r\n        NodeList xqwsSOAPFunctionParams = xqwsSOAPFunction.getChildNodes();\r\n        Node nInternalFunction = xqwsDescription.getFunction(functionName);\r\n        NodeList nlInternalFunctionParams = xqwsDescription.getFunctionParameters(nInternalFunction);\r\n        \r\n        int j = 0;\r\n        for(int i = 0; i < xqwsSOAPFunctionParams.getLength(); i++)\r\n        {\r\n        \tNode nSOAPFunctionParam = xqwsSOAPFunctionParams.item(i);\r\n        \tif(nSOAPFunctionParam.getNodeType() == Node.ELEMENT_NODE)\r\n        \t{\r\n\t        \tquery.append(writeXQueryFunctionParameter(xqwsDescription.getFunctionParameterType(nlInternalFunctionParams.item(j)), xqwsDescription.getFunctionParameterCardinality(nlInternalFunctionParams.item(j)), nSOAPFunctionParam));\r\n        \t\tquery.append(\",\"); //add function seperator\r\n\t        \t\r\n\t        \tj++;\r\n        \t}\r\n        }\r\n        \r\n        //remove last superflurous seperator\r\n\t\tif(query.charAt(query.length()-1) == ',')\r\n\t\t{\r\n\t\t\tquery.deleteCharAt(query.length()-1);\r\n\t\t}\r\n        \r\n        query.append(\")\");\r\n        \r\n        //compile the query\r\n        return compileXQuery(broker, new StringSource(query.toString()), new XmldbURI[] { xqwsDescription.getCollectionURI() }, xqwsDescription.getCollectionURI(), request, response);\r\n    }","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n    \t * Creates the internal Description of the XQWS\n    \t * \n    \t * @param request The HttpServletRequest for which the description should be created\n    \t */\n    \tprivate void createInternalDescription(HttpServletRequest request) throws XPathException, PermissionDeniedException\n    \t{\n    \t\t// 1) Get the XQWS\n    \t\tBinaryDocument docXQWS = getXQWS(broker, XQWSPath);\n    \t\txqwsFileURI = docXQWS.getFileURI();\n    \t\txqwsCollectionURI = docXQWS.getCollection().getURI();\n    \t\tbyte[] xqwsData = getXQWSData(broker, docXQWS);\n            \n    \t\t// 2) Store last modified date\n    \t\tlastModifiedXQWS = docXQWS.getMetadata().getLastModified();\n    \t\t\n            // 3) Get the XQWS Namespace\n            xqwsNamespace = getXQWSNamespace(xqwsData);\n            \n            // 4) Compile a Simple XQuery to access the module\n            CompiledXQuery compiled = XQueryIncludeXQWS(broker, docXQWS.getFileURI(), xqwsNamespace, docXQWS.getCollection().getURI());\n            \n            // 5) Inspect the XQWS and its function signatures and create a small XML document to represent it\n            modXQWS = compiled.getContext().getModule(xqwsNamespace.getNamespaceURI());\n            docXQWSDescription = describeWebService(modXQWS, xqwsFileURI, request, XQWSPath, null, null);\n    \t}","id":88179,"modified_method":"/**\r\n    \t * Creates the internal Description of the XQWS\r\n    \t * \r\n    \t * @param request The HttpServletRequest for which the description should be created\r\n    \t */\r\n    \tprivate void createInternalDescription(HttpServletRequest request) throws XPathException, SAXException, PermissionDeniedException, NotFoundException\r\n    \t{\r\n    \t\t// 1) Get the XQWS\r\n    \t\tBinaryDocument docXQWS = getXQWS(broker, XQWSPath);\r\n\t\t\r\n\t\tif(docXQWS==null)  throw new NotFoundException(\"Resource \"+request.getRequestURL().toString()+\" not found\");\r\n\t\t\r\n    \t\txqwsFileURI = docXQWS.getFileURI();\r\n    \t\txqwsCollectionURI = docXQWS.getCollection().getURI();\r\n    \t\tbyte[] xqwsData = getXQWSData(broker, docXQWS);\r\n            \r\n    \t\t// 2) Store last modified date\r\n    \t\tlastModifiedXQWS = docXQWS.getMetadata().getLastModified();\r\n    \t\t\r\n            // 3) Get the XQWS Namespace\r\n            xqwsNamespace = getXQWSNamespace(xqwsData);\r\n            \r\n            // 4) Compile a Simple XQuery to access the module\r\n            CompiledXQuery compiled = XQueryIncludeXQWS(broker, docXQWS.getFileURI(), xqwsNamespace, docXQWS.getCollection().getURI());\r\n            \r\n            // 5) Inspect the XQWS and its function signatures and create a small XML document to represent it\r\n            modXQWS = compiled.getContext().getModule(xqwsNamespace.getNamespaceURI());\r\n            docXQWSDescription = describeWebService(modXQWS, xqwsFileURI, request, XQWSPath, null, null);\r\n    \t}","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"public void doPost(DBBroker broker, HttpServletRequest request, HttpServletResponse response, String path) throws BadRequestException, PermissionDeniedException, IOException\n    {\t\n\t\t/*\n\t\t * Example incoming SOAP Request\n\t\t * \n\t\t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">\n    \t\t\t<SOAP-ENV:Header/>\n    \t\t\t<SOAP-ENV:Body>\n        \t\t\t<echo xmlns=\"http://localhost:8080/exist/servlet/db/echo.xqws\">\n            \t\t\t<arg1>adam<\/arg1>\n        \t\t\t<\/echo>\n    \t\t\t<\/SOAP-ENV:Body>\n\t\t\t<\/SOAP-ENV:Envelope>\n\t\t */\n\t\t\n\t\t// 1) Read the incoming SOAP request\n\t\tInputStream is = request.getInputStream();\n\t\tbyte[] buf = new byte[request.getContentLength()];\n\t\tint bytes = 0;\n\t\tint offset = 0;\n\t\tint max = 4096;\n\t    while((bytes = is.read(buf, offset, max)) != -1)\n\t    {\n\t\t\toffset += bytes;\n\t    }\n\t\t\n\t\t// 2) Create an XML Document from the SOAP Request\n\t    Document soapRequest = null;\n\t\ttry\n\t\t{\n\t\t\tsoapRequest = BuildXMLDocument(buf);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\twriteResponse(response, formatXPathException(null, path, new XPathException(null, \"Unable to construct an XML document from the SOAP Request, probably an invalid request: \" + e.getMessage(), e)), \"text/html\", ENCODING);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// 3) Validate the SOAP Request \n\t\t//TODO: validate the SOAP Request\n\t\t\n\t\t// 4) Extract the function call from the SOAP Request\n\t\t//NodeList nlBody = soapRequest.getElementsByTagNameNS(\"http://schemas.xmlsoap.org/soap/envelope/\", \"Body\");\n\t\tNodeList nlBody = soapRequest.getElementsByTagName(\"SOAP-ENV:Body\");\n\t\tNode nSOAPBody = nlBody.item(0);\n\t\tNodeList nlBodyChildren = nSOAPBody.getChildNodes();\n\t\tNode nSOAPFunction = null;\n\t\tfor(int i = 0; i < nlBodyChildren.getLength(); i++)\n\t\t{\n\t\t\tNode bodyChild = nlBodyChildren.item(i);\n\t\t\tif(bodyChild.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t{\n\t\t\t\tnSOAPFunction = bodyChild;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check the namespace for the function in the SOAP document is the same as the request path?\n\t\tNamedNodeMap attrsSOAPFunction = nSOAPFunction.getAttributes();\n\t\tString funcNamespace =  null;\n\t\tfor(int i = 0; i < attrsSOAPFunction.getLength(); i++)\n\t\t{\n\t\t\tNode attr = attrsSOAPFunction.item(i);\n\t\t\tif(attr.getNodeName().equals(\"xmlns:\"))\n\t\t\t{\n\t\t\t\tfuncNamespace = attr.getNodeValue();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(funcNamespace != null)\n\t\t{\n\t\t\tif(!funcNamespace.equals(request.getRequestURL().toString()))\n\t\t\t{\n\t\t\t\t//function in SOAP request has an invalid namespace\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\t\twriteResponse(response, \"SOAP Function call has invalid namespace, got: \" + funcNamespace + \" but expected: \" + request.getRequestURL().toString(), \"text/html\", ENCODING);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//function in SOAP request has no namespace\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\twriteResponse(response, \"SOAP Function call has no namespace, expected: \" + request.getRequestURL().toString(), \"text/html\", ENCODING);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// 5) Execute the XQWS function indicated by the SOAP request  \n\t\ttry\n\t\t{\n\t\t\t//Get the internal description for the function requested by SOAP (should be in the cache)\n\t\t\tXQWSDescription description = getXQWSDescription(broker, path, request);\n\t\t\t\n\t\t\t//Create an XQuery to call the XQWS function\n\t\t\tCompiledXQuery xqCallXQWS = XQueryExecuteXQWSFunction(broker, nSOAPFunction, description, request, response);\n\t\t\t\n\t\t\t//xqCallXQWS\n\t\t\tXQuery xqueryService = broker.getXQueryService();\n\t\t\tSequence xqwsResult = xqueryService.execute(xqCallXQWS, null);\n\t\t\t\n\t\t\t// 6) Create a SOAP Response describing the Result\n        \tbyte[] result = description.getSOAPResponse(nSOAPFunction.getNodeName(), xqwsResult, request);\n\n        \t// 7) Send the SOAP Response to the http servlet response\n        \tresponse.setContentType(\"text/xml\");\n\t\t\tServletOutputStream os = response.getOutputStream();\n\t\t\tBufferedOutputStream bos = new BufferedOutputStream(os);\n\t\t\tbos.write(result);\n\t\t\tbos.close();\n\t\t\tos.close();\n\t\t}\n\t\tcatch(XPathException xpe)\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\twriteResponse(response, formatXPathException(null, path, xpe), \"text/html\", ENCODING);\n\t\t}\n\t\tcatch(SAXException saxe)\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\twriteResponse(response, formatXPathException(null, path, new XPathException(null, \"SAX exception while transforming node: \" + saxe.getMessage(), saxe)), \"text/html\", ENCODING);\n\t\t}\n\t\tcatch(TransformerConfigurationException tce)\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\twriteResponse(response, formatXPathException(null, path, new XPathException(null, \"SAX exception while transforming node: \" + tce.getMessage(), tce)), \"text/html\", ENCODING);\n\t\t}\n    }","id":88180,"modified_method":"public void doPost(DBBroker broker, HttpServletRequest request, HttpServletResponse response, String path) throws BadRequestException, PermissionDeniedException, NotFoundException, IOException\r\n    {\t\r\n\t\t/*\r\n\t\t * Example incoming SOAP Request\r\n\t\t * \r\n\t\t\t<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">\r\n    \t\t\t<SOAP-ENV:Header/>\r\n    \t\t\t<SOAP-ENV:Body>\r\n        \t\t\t<echo xmlns=\"http://localhost:8080/exist/servlet/db/echo.xqws\">\r\n            \t\t\t<arg1>adam<\/arg1>\r\n        \t\t\t<\/echo>\r\n    \t\t\t<\/SOAP-ENV:Body>\r\n\t\t\t<\/SOAP-ENV:Envelope>\r\n\t\t */\r\n\t\t\r\n\t\t// 1) Read the incoming SOAP request\r\n\t\tInputStream is = request.getInputStream();\r\n\t\tbyte[] buf = new byte[request.getContentLength()];\r\n\t\tint bytes = 0;\r\n\t\tint offset = 0;\r\n\t\tint max = 4096;\r\n\t    while((bytes = is.read(buf, offset, max)) != -1)\r\n\t    {\r\n\t\t\toffset += bytes;\r\n\t    }\r\n\t\t\r\n\t\t// 2) Create an XML Document from the SOAP Request\r\n\t    Document soapRequest = null;\r\n\t\ttry\r\n\t\t{\r\n\t\t\tsoapRequest = BuildXMLDocument(buf);\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\r\n\t\t\twriteResponse(response, formatXPathException(null, path, new XPathException(null, \"Unable to construct an XML document from the SOAP Request, probably an invalid request: \" + e.getMessage(), e)), \"text/html\", ENCODING);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// 3) Validate the SOAP Request \r\n\t\t//TODO: validate the SOAP Request\r\n\t\t\r\n\t\t// 4) Extract the function call from the SOAP Request\r\n\t\tNodeList nlBody = soapRequest.getDocumentElement().getElementsByTagNameNS(\"http://schemas.xmlsoap.org/soap/envelope/\", \"Body\");\r\n\t\t//NodeList nlBody = soapRequest.getElementsByTagName(\"SOAP-ENV:Body\");\r\n\t\tNode nSOAPBody = nlBody.item(0);\r\n\t\tNodeList nlBodyChildren = nSOAPBody.getChildNodes();\r\n\t\tNode nSOAPFunction = null;\r\n\t\tfor(int i = 0; i < nlBodyChildren.getLength(); i++)\r\n\t\t{\r\n\t\t\tNode bodyChild = nlBodyChildren.item(i);\r\n\t\t\tif(bodyChild.getNodeType() == Node.ELEMENT_NODE)\r\n\t\t\t{\r\n\t\t\t\tnSOAPFunction = bodyChild;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Check the namespace for the function in the SOAP document is the same as the request path?\r\n\t\tString funcNamespace =  nSOAPFunction.getNamespaceURI();\r\n\t\t\r\n\t\tif(funcNamespace != null)\r\n\t\t{\r\n\t\t\tif(!funcNamespace.equals(request.getRequestURL().toString()))\r\n\t\t\t{\r\n\t\t\t\t//function in SOAP request has an invalid namespace\r\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\r\n\t\t\t\twriteResponse(response, \"SOAP Function call has invalid namespace, got: \" + funcNamespace + \" but expected: \" + request.getRequestURL().toString(), \"text/html\", ENCODING);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//function in SOAP request has no namespace\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\r\n\t\t\twriteResponse(response, \"SOAP Function call has no namespace, expected: \" + request.getRequestURL().toString(), \"text/html\", ENCODING);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// 5) Execute the XQWS function indicated by the SOAP request  \r\n\t\ttry\r\n\t\t{\r\n\t\t\t//Get the internal description for the function requested by SOAP (should be in the cache)\r\n\t\t\tXQWSDescription description = getXQWSDescription(broker, path, request);\r\n\t\t\t\r\n\t\t\t//Create an XQuery to call the XQWS function\r\n\t\t\tCompiledXQuery xqCallXQWS = XQueryExecuteXQWSFunction(broker, nSOAPFunction, description, request, response);\r\n\t\t\t\r\n\t\t\t//xqCallXQWS\r\n\t\t\tXQuery xqueryService = broker.getXQueryService();\r\n\t\t\tSequence xqwsResult = xqueryService.execute(xqCallXQWS, null);\r\n\t\t\t\r\n\t\t\t// 6) Create a SOAP Response describing the Result\r\n\t\tString funcName=nSOAPFunction.getLocalName();\r\n\t\tif(funcName==null) {\r\n\t\t\tfuncName=nSOAPFunction.getNodeName();\r\n\t\t}\r\n        \tbyte[] result = description.getSOAPResponse(funcName, xqwsResult, request);\r\n\r\n        \t// 7) Send the SOAP Response to the http servlet response\r\n        \tresponse.setContentType(\"text/xml\");\r\n\t\t\tServletOutputStream os = response.getOutputStream();\r\n\t\t\tBufferedOutputStream bos = new BufferedOutputStream(os);\r\n\t\t\tbos.write(result);\r\n\t\t\tbos.close();\r\n\t\t\tos.close();\r\n\t\t}\r\n\t\tcatch(XPathException xpe)\r\n\t\t{\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\r\n\t\t\twriteResponse(response, formatXPathException(null, path, xpe), \"text/html\", ENCODING);\r\n\t\t}\r\n\t\tcatch(SAXException saxe)\r\n\t\t{\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\r\n\t\t\twriteResponse(response, formatXPathException(null, path, new XPathException(null, \"SAX exception while transforming node: \" + saxe.getMessage(), saxe)), \"text/html\", ENCODING);\r\n\t\t}\r\n\t\tcatch(TransformerConfigurationException tce)\r\n\t\t{\r\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\r\n\t\t\twriteResponse(response, formatXPathException(null, path, new XPathException(null, \"SAX exception while transforming node: \" + tce.getMessage(), tce)), \"text/html\", ENCODING);\r\n\t\t}\r\n    }","commit_id":"a8a9c0373ce955c1d30c069ff02437ddc5be4188","url":"https://github.com/eXist-db/exist"},{"original_method":"public MetaData parse(ByteBuffer buffer, int blockLength)\n    {\n        // We must wait for the all the bytes of the header block to arrive.\n        // If they are not all available, accumulate them.\n        // When all are available, decode them.\n\n        int accumulated = blockBuffer == null ? 0 : blockBuffer.position();\n        int remaining = blockLength - accumulated;\n\n        if (buffer.remaining() < remaining)\n        {\n            if (blockBuffer == null)\n            {\n                blockBuffer = byteBufferPool.acquire(blockLength, false);\n                BufferUtil.clearToFill(blockBuffer);\n            }\n            blockBuffer.put(buffer);\n            return null;\n        }\n        else\n        {\n            int limit = buffer.limit();\n            buffer.limit(buffer.position() + remaining);\n            ByteBuffer toDecode;\n            if (blockBuffer != null)\n            {\n                blockBuffer.put(buffer);\n                BufferUtil.flipToFlush(blockBuffer, 0);\n                toDecode = blockBuffer;\n            }\n            else\n            {\n                toDecode = buffer;\n            }\n\n            MetaData result = hpackDecoder.decode(toDecode);\n\n            buffer.limit(limit);\n            byteBufferPool.release(blockBuffer);\n\n            return result;\n        }\n    }","id":88181,"modified_method":"public MetaData parse(ByteBuffer buffer, int blockLength)\n    {\n        // We must wait for the all the bytes of the header block to arrive.\n        // If they are not all available, accumulate them.\n        // When all are available, decode them.\n\n        int accumulated = blockBuffer == null ? 0 : blockBuffer.position();\n        int remaining = blockLength - accumulated;\n\n        if (buffer.remaining() < remaining)\n        {\n            if (blockBuffer == null)\n            {\n                blockBuffer = byteBufferPool.acquire(blockLength, false);\n                BufferUtil.clearToFill(blockBuffer);\n            }\n            blockBuffer.put(buffer);\n            return null;\n        }\n        else\n        {\n            int limit = buffer.limit();\n            buffer.limit(buffer.position() + remaining);\n            ByteBuffer toDecode;\n            if (blockBuffer != null)\n            {\n                blockBuffer.put(buffer);\n                BufferUtil.flipToFlush(blockBuffer, 0);\n                toDecode = blockBuffer;\n            }\n            else\n            {\n                toDecode = buffer;\n            }\n\n            MetaData result = hpackDecoder.decode(toDecode);\n\n            buffer.limit(limit);\n\n            if (blockBuffer != null)\n            {\n                byteBufferPool.release(blockBuffer);\n                blockBuffer = null;\n            }\n\n            return result;\n        }\n    }","commit_id":"35da4a3c54ee82b9e902b37d7ad67d3fc4bdd18f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        HeadersGenerator generator = new HeadersGenerator(new HeaderGenerator(), new HpackEncoder());\n\n        final List<HeadersFrame> frames = new ArrayList<>();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public void onHeaders(HeadersFrame frame)\n            {\n                frames.add(frame);\n            }\n        }, 4096, 8192);\n\n        int streamId = 13;\n        HttpFields fields = new HttpFields();\n        fields.put(\"Accept\", \"text/html\");\n        fields.put(\"User-Agent\", \"Jetty\");\n        MetaData.Request metaData = new MetaData.Request(\"GET\", HttpScheme.HTTP, new HostPortHttpField(\"localhost:8080\"), \"/path\", HttpVersion.HTTP_2, fields);\n\n        ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n        PriorityFrame priorityFrame = new PriorityFrame(streamId, 3 * streamId, 200, true);\n        generator.generateHeaders(lease, streamId, metaData, priorityFrame, true);\n\n        for (ByteBuffer buffer : lease.getByteBuffers())\n        {\n            while (buffer.hasRemaining())\n            {\n                parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n            }\n        }\n\n        Assert.assertEquals(1, frames.size());\n        HeadersFrame frame = frames.get(0);\n        Assert.assertEquals(streamId, frame.getStreamId());\n        Assert.assertTrue(frame.isEndStream());\n        MetaData.Request request = (MetaData.Request)frame.getMetaData();\n        Assert.assertEquals(metaData.getMethod(), request.getMethod());\n        Assert.assertEquals(metaData.getURI(), request.getURI());\n        for (int j = 0; j < fields.size(); ++j)\n        {\n            HttpField field = fields.getField(j);\n            Assert.assertTrue(request.getFields().contains(field));\n        }\n        PriorityFrame priority = frame.getPriority();\n        Assert.assertNotNull(priority);\n        Assert.assertEquals(priorityFrame.getStreamId(), priority.getStreamId());\n        Assert.assertEquals(priorityFrame.getParentStreamId(), priority.getParentStreamId());\n        Assert.assertEquals(priorityFrame.getWeight(), priority.getWeight());\n        Assert.assertEquals(priorityFrame.isExclusive(), priority.isExclusive());\n    }","id":88182,"modified_method":"@Test\n    public void testGenerateParseOneByteAtATime() throws Exception\n    {\n        HeadersGenerator generator = new HeadersGenerator(new HeaderGenerator(), new HpackEncoder());\n\n        final List<HeadersFrame> frames = new ArrayList<>();\n        Parser parser = new Parser(byteBufferPool, new Parser.Listener.Adapter()\n        {\n            @Override\n            public void onHeaders(HeadersFrame frame)\n            {\n                frames.add(frame);\n            }\n        }, 4096, 8192);\n\n        // Iterate a few times to be sure generator and parser are properly reset.\n        for (int i = 0; i < 2; ++i)\n        {\n            int streamId = 13;\n            HttpFields fields = new HttpFields();\n            fields.put(\"Accept\", \"text/html\");\n            fields.put(\"User-Agent\", \"Jetty\");\n            MetaData.Request metaData = new MetaData.Request(\"GET\", HttpScheme.HTTP, new HostPortHttpField(\"localhost:8080\"), \"/path\", HttpVersion.HTTP_2, fields);\n\n            ByteBufferPool.Lease lease = new ByteBufferPool.Lease(byteBufferPool);\n            PriorityFrame priorityFrame = new PriorityFrame(streamId, 3 * streamId, 200, true);\n            generator.generateHeaders(lease, streamId, metaData, priorityFrame, true);\n\n            frames.clear();\n            for (ByteBuffer buffer : lease.getByteBuffers())\n            {\n                buffer = buffer.slice();\n                while (buffer.hasRemaining())\n                {\n                    parser.parse(ByteBuffer.wrap(new byte[]{buffer.get()}));\n                }\n            }\n\n            Assert.assertEquals(1, frames.size());\n            HeadersFrame frame = frames.get(0);\n            Assert.assertEquals(streamId, frame.getStreamId());\n            Assert.assertTrue(frame.isEndStream());\n            MetaData.Request request = (MetaData.Request)frame.getMetaData();\n            Assert.assertEquals(metaData.getMethod(), request.getMethod());\n            Assert.assertEquals(metaData.getURI(), request.getURI());\n            for (int j = 0; j < fields.size(); ++j)\n            {\n                HttpField field = fields.getField(j);\n                Assert.assertTrue(request.getFields().contains(field));\n            }\n            PriorityFrame priority = frame.getPriority();\n            Assert.assertNotNull(priority);\n            Assert.assertEquals(priorityFrame.getStreamId(), priority.getStreamId());\n            Assert.assertEquals(priorityFrame.getParentStreamId(), priority.getParentStreamId());\n            Assert.assertEquals(priorityFrame.getWeight(), priority.getWeight());\n            Assert.assertEquals(priorityFrame.isExclusive(), priority.isExclusive());\n        }\n    }","commit_id":"35da4a3c54ee82b9e902b37d7ad67d3fc4bdd18f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Check if given sstable is worth dropping tombstones at gcBefore.\n     * Check is skipped if tombstone_compaction_interval time does not elapse since sstable creation and returns false.\n     *\n     * @param sstable SSTable to check\n     * @param gcBefore time to drop tombstones\n     * @return true if given sstable's tombstones are expected to be removed\n     */\n    protected boolean worthDroppingTombstones(SSTableReader sstable, int gcBefore)\n    {\n        if (disableTombstoneCompactions)\n            return false;\n        // since we use estimations to calculate, there is a chance that compaction will not drop tombstones actually.\n        // if that happens we will end up in infinite compaction loop, so first we check enough if enough time has\n        // elapsed since SSTable created.\n        if (System.currentTimeMillis() < sstable.getCreationTimeFor(Component.DATA) + tombstoneCompactionInterval * 1000)\n           return false;\n\n        double droppableRatio = sstable.getEstimatedDroppableTombstoneRatio(gcBefore);\n        if (droppableRatio <= tombstoneThreshold)\n            return false;\n\n        //sstable range overlap check is disabled. See CASSANDRA-6563.\n        if (uncheckedTombstoneCompaction)\n            return true;\n\n        Collection<SSTableReader> overlaps = cfs.getOverlappingSSTables(Collections.singleton(sstable));\n        if (overlaps.isEmpty())\n        {\n            // there is no overlap, tombstones are safely droppable\n            return true;\n        }\n        else if (CompactionController.getFullyExpiredSSTables(cfs, Collections.singleton(sstable), overlaps, gcBefore).size() > 0)\n        {\n            return true;\n        }\n        else\n        {\n            // what percentage of columns do we expect to compact outside of overlap?\n            if (sstable.getIndexSummarySize() < 2)\n            {\n                // we have too few samples to estimate correct percentage\n                return false;\n            }\n            // first, calculate estimated keys that do not overlap\n            long keys = sstable.estimatedKeys();\n            Set<Range<Token>> ranges = new HashSet<Range<Token>>(overlaps.size());\n            for (SSTableReader overlap : overlaps)\n                ranges.add(new Range<Token>(overlap.first.getToken(), overlap.last.getToken(), overlap.partitioner));\n            long remainingKeys = keys - sstable.estimatedKeysForRanges(ranges);\n            // next, calculate what percentage of columns we have within those keys\n            long columns = sstable.getEstimatedColumnCount().mean() * remainingKeys;\n            double remainingColumnsRatio = ((double) columns) / (sstable.getEstimatedColumnCount().count() * sstable.getEstimatedColumnCount().mean());\n\n            // return if we still expect to have droppable tombstones in rest of columns\n            return remainingColumnsRatio * droppableRatio > tombstoneThreshold;\n        }\n    }","id":88183,"modified_method":"/**\n     * Check if given sstable is worth dropping tombstones at gcBefore.\n     * Check is skipped if tombstone_compaction_interval time does not elapse since sstable creation and returns false.\n     *\n     * @param sstable SSTable to check\n     * @param gcBefore time to drop tombstones\n     * @return true if given sstable's tombstones are expected to be removed\n     */\n    protected boolean worthDroppingTombstones(SSTableReader sstable, int gcBefore)\n    {\n        if (disableTombstoneCompactions || CompactionController.NEVER_PURGE_TOMBSTONES)\n            return false;\n        // since we use estimations to calculate, there is a chance that compaction will not drop tombstones actually.\n        // if that happens we will end up in infinite compaction loop, so first we check enough if enough time has\n        // elapsed since SSTable created.\n        if (System.currentTimeMillis() < sstable.getCreationTimeFor(Component.DATA) + tombstoneCompactionInterval * 1000)\n           return false;\n\n        double droppableRatio = sstable.getEstimatedDroppableTombstoneRatio(gcBefore);\n        if (droppableRatio <= tombstoneThreshold)\n            return false;\n\n        //sstable range overlap check is disabled. See CASSANDRA-6563.\n        if (uncheckedTombstoneCompaction)\n            return true;\n\n        Collection<SSTableReader> overlaps = cfs.getOverlappingSSTables(Collections.singleton(sstable));\n        if (overlaps.isEmpty())\n        {\n            // there is no overlap, tombstones are safely droppable\n            return true;\n        }\n        else if (CompactionController.getFullyExpiredSSTables(cfs, Collections.singleton(sstable), overlaps, gcBefore).size() > 0)\n        {\n            return true;\n        }\n        else\n        {\n            // what percentage of columns do we expect to compact outside of overlap?\n            if (sstable.getIndexSummarySize() < 2)\n            {\n                // we have too few samples to estimate correct percentage\n                return false;\n            }\n            // first, calculate estimated keys that do not overlap\n            long keys = sstable.estimatedKeys();\n            Set<Range<Token>> ranges = new HashSet<Range<Token>>(overlaps.size());\n            for (SSTableReader overlap : overlaps)\n                ranges.add(new Range<Token>(overlap.first.getToken(), overlap.last.getToken(), overlap.partitioner));\n            long remainingKeys = keys - sstable.estimatedKeysForRanges(ranges);\n            // next, calculate what percentage of columns we have within those keys\n            long columns = sstable.getEstimatedColumnCount().mean() * remainingKeys;\n            double remainingColumnsRatio = ((double) columns) / (sstable.getEstimatedColumnCount().count() * sstable.getEstimatedColumnCount().mean());\n\n            // return if we still expect to have droppable tombstones in rest of columns\n            return remainingColumnsRatio * droppableRatio > tombstoneThreshold;\n        }\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Finds expired sstables\n     *\n     * works something like this;\n     * 1. find \"global\" minTimestamp of overlapping sstables and compacting sstables containing any non-expired data\n     * 2. build a list of fully expired candidates\n     * 3. check if the candidates to be dropped actually can be dropped (maxTimestamp < global minTimestamp)\n     *    - if not droppable, remove from candidates\n     * 4. return candidates.\n     *\n     * @param cfStore\n     * @param compacting we take the drop-candidates from this set, it is usually the sstables included in the compaction\n     * @param overlapping the sstables that overlap the ones in compacting.\n     * @param gcBefore\n     * @return\n     */\n    public static Set<SSTableReader> getFullyExpiredSSTables(ColumnFamilyStore cfStore, Iterable<SSTableReader> compacting, Iterable<SSTableReader> overlapping, int gcBefore)\n    {\n        logger.debug(\"Checking droppable sstables in {}\", cfStore);\n\n        if (compacting == null)\n            return Collections.<SSTableReader>emptySet();\n\n        List<SSTableReader> candidates = new ArrayList<SSTableReader>();\n\n        long minTimestamp = Long.MAX_VALUE;\n\n        for (SSTableReader sstable : overlapping)\n        {\n            // Overlapping might include fully expired sstables. What we care about here is\n            // the min timestamp of the overlapping sstables that actually contain live data.\n            if (sstable.getSSTableMetadata().maxLocalDeletionTime >= gcBefore)\n                minTimestamp = Math.min(minTimestamp, sstable.getMinTimestamp());\n        }\n\n        for (SSTableReader candidate : compacting)\n        {\n            if (candidate.getSSTableMetadata().maxLocalDeletionTime < gcBefore)\n                candidates.add(candidate);\n            else\n                minTimestamp = Math.min(minTimestamp, candidate.getMinTimestamp());\n        }\n\n        // At this point, minTimestamp denotes the lowest timestamp of any relevant\n        // SSTable that contains a constructive value. candidates contains all the\n        // candidates with no constructive values. The ones out of these that have\n        // (getMaxTimestamp() < minTimestamp) serve no purpose anymore.\n\n        Iterator<SSTableReader> iterator = candidates.iterator();\n        while (iterator.hasNext())\n        {\n            SSTableReader candidate = iterator.next();\n            if (candidate.getMaxTimestamp() >= minTimestamp)\n            {\n                iterator.remove();\n            }\n            else\n            {\n               logger.debug(\"Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})\",\n                        candidate, candidate.getSSTableMetadata().maxLocalDeletionTime, gcBefore);\n            }\n        }\n        return new HashSet<>(candidates);\n    }","id":88184,"modified_method":"/**\n     * Finds expired sstables\n     *\n     * works something like this;\n     * 1. find \"global\" minTimestamp of overlapping sstables and compacting sstables containing any non-expired data\n     * 2. build a list of fully expired candidates\n     * 3. check if the candidates to be dropped actually can be dropped (maxTimestamp < global minTimestamp)\n     *    - if not droppable, remove from candidates\n     * 4. return candidates.\n     *\n     * @param cfStore\n     * @param compacting we take the drop-candidates from this set, it is usually the sstables included in the compaction\n     * @param overlapping the sstables that overlap the ones in compacting.\n     * @param gcBefore\n     * @return\n     */\n    public static Set<SSTableReader> getFullyExpiredSSTables(ColumnFamilyStore cfStore, Iterable<SSTableReader> compacting, Iterable<SSTableReader> overlapping, int gcBefore)\n    {\n        logger.debug(\"Checking droppable sstables in {}\", cfStore);\n\n        if (compacting == null || NEVER_PURGE_TOMBSTONES)\n            return Collections.<SSTableReader>emptySet();\n\n        List<SSTableReader> candidates = new ArrayList<SSTableReader>();\n\n        long minTimestamp = Long.MAX_VALUE;\n\n        for (SSTableReader sstable : overlapping)\n        {\n            // Overlapping might include fully expired sstables. What we care about here is\n            // the min timestamp of the overlapping sstables that actually contain live data.\n            if (sstable.getSSTableMetadata().maxLocalDeletionTime >= gcBefore)\n                minTimestamp = Math.min(minTimestamp, sstable.getMinTimestamp());\n        }\n\n        for (SSTableReader candidate : compacting)\n        {\n            if (candidate.getSSTableMetadata().maxLocalDeletionTime < gcBefore)\n                candidates.add(candidate);\n            else\n                minTimestamp = Math.min(minTimestamp, candidate.getMinTimestamp());\n        }\n\n        // At this point, minTimestamp denotes the lowest timestamp of any relevant\n        // SSTable that contains a constructive value. candidates contains all the\n        // candidates with no constructive values. The ones out of these that have\n        // (getMaxTimestamp() < minTimestamp) serve no purpose anymore.\n\n        Iterator<SSTableReader> iterator = candidates.iterator();\n        while (iterator.hasNext())\n        {\n            SSTableReader candidate = iterator.next();\n            if (candidate.getMaxTimestamp() >= minTimestamp)\n            {\n                iterator.remove();\n            }\n            else\n            {\n               logger.debug(\"Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})\",\n                        candidate, candidate.getSSTableMetadata().maxLocalDeletionTime, gcBefore);\n            }\n        }\n        return new HashSet<>(candidates);\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * @return the largest timestamp before which it's okay to drop tombstones for the given partition;\n     * i.e., after the maxPurgeableTimestamp there may exist newer data that still needs to be suppressed\n     * in other sstables.  This returns the minimum timestamp for any SSTable that contains this partition and is not\n     * participating in this compaction, or LONG.MAX_VALUE if no such SSTable exists.\n     */\n    public long maxPurgeableTimestamp(DecoratedKey key)\n    {\n        List<SSTableReader> filteredSSTables = overlappingTree.search(key);\n        long min = Long.MAX_VALUE;\n        for (SSTableReader sstable : filteredSSTables)\n        {\n            // if we don't have bloom filter(bf_fp_chance=1.0 or filter file is missing),\n            // we check index file instead.\n            if (sstable.getBloomFilter() instanceof AlwaysPresentFilter && sstable.getPosition(key, SSTableReader.Operator.EQ, false) != null)\n                min = Math.min(min, sstable.getMinTimestamp());\n            else if (sstable.getBloomFilter().isPresent(key.getKey()))\n                min = Math.min(min, sstable.getMinTimestamp());\n        }\n        return min;\n    }","id":88185,"modified_method":"/**\n     * @return the largest timestamp before which it's okay to drop tombstones for the given partition;\n     * i.e., after the maxPurgeableTimestamp there may exist newer data that still needs to be suppressed\n     * in other sstables.  This returns the minimum timestamp for any SSTable that contains this partition and is not\n     * participating in this compaction, or LONG.MAX_VALUE if no such SSTable exists.\n     */\n    public long maxPurgeableTimestamp(DecoratedKey key)\n    {\n        if (NEVER_PURGE_TOMBSTONES)\n            return Long.MIN_VALUE;\n\n        List<SSTableReader> filteredSSTables = overlappingTree.search(key);\n        long min = Long.MAX_VALUE;\n        for (SSTableReader sstable : filteredSSTables)\n        {\n            // if we don't have bloom filter(bf_fp_chance=1.0 or filter file is missing),\n            // we check index file instead.\n            if (sstable.getBloomFilter() instanceof AlwaysPresentFilter && sstable.getPosition(key, SSTableReader.Operator.EQ, false) != null)\n                min = Math.min(min, sstable.getMinTimestamp());\n            else if (sstable.getBloomFilter().isPresent(key.getKey()))\n                min = Math.min(min, sstable.getMinTimestamp());\n        }\n        return min;\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"public CompactionController(ColumnFamilyStore cfs, Set<SSTableReader> compacting,  int gcBefore)\n    {\n        assert cfs != null;\n        this.cfs = cfs;\n        this.gcBefore = gcBefore;\n        this.compacting = compacting;\n        refreshOverlaps();\n    }","id":88186,"modified_method":"public CompactionController(ColumnFamilyStore cfs, Set<SSTableReader> compacting, int gcBefore)\n    {\n        assert cfs != null;\n        this.cfs = cfs;\n        this.gcBefore = gcBefore;\n        this.compacting = compacting;\n        refreshOverlaps();\n        if (NEVER_PURGE_TOMBSTONES)\n            logger.warn(\"You are running with -Dcassandra.never_purge_tombstones=true, this is dangerous!\");\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"public void close()\n    {\n        overlappingSSTables.release();\n    }","id":88187,"modified_method":"public void close()\n    {\n        if (overlappingSSTables != null)\n            overlappingSSTables.release();\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"private void refreshOverlaps()\n    {\n        if (this.overlappingSSTables != null)\n            overlappingSSTables.release();\n\n        if (compacting == null)\n            overlappingSSTables = Refs.tryRef(Collections.<SSTableReader>emptyList());\n        else\n            overlappingSSTables = cfs.getAndReferenceOverlappingSSTables(compacting);\n        this.overlappingTree = DataTracker.buildIntervalTree(overlappingSSTables);\n    }","id":88188,"modified_method":"private void refreshOverlaps()\n    {\n        if (NEVER_PURGE_TOMBSTONES)\n            return;\n\n        if (this.overlappingSSTables != null)\n            overlappingSSTables.release();\n\n        if (compacting == null)\n            overlappingSSTables = Refs.tryRef(Collections.<SSTableReader>emptyList());\n        else\n            overlappingSSTables = cfs.getAndReferenceOverlappingSSTables(compacting);\n        this.overlappingTree = DataTracker.buildIntervalTree(overlappingSSTables);\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"void maybeRefreshOverlaps()\n    {\n        for (SSTableReader reader : overlappingSSTables)\n        {\n            if (reader.isMarkedCompacted())\n            {\n                refreshOverlaps();\n                return;\n            }\n        }\n    }","id":88189,"modified_method":"void maybeRefreshOverlaps()\n    {\n        if (NEVER_PURGE_TOMBSTONES)\n        {\n            logger.debug(\"not refreshing overlaps - running with -Dcassandra.never_purge_tombstones=true\");\n            return;\n        }\n\n        for (SSTableReader reader : overlappingSSTables)\n        {\n            if (reader.isMarkedCompacted())\n            {\n                refreshOverlaps();\n                return;\n            }\n        }\n    }","commit_id":"5dc741497046c5c5b92ad2441db3865b90dc035e","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     *  Get document from database.\n     *\n     * @param isBinary      Indicate wether resource is binary.\n     * @param documentPath  Path to the resource.\n     * @return              Byte array of resource, null if not found.\n     */\n    public byte[] getGrammar(boolean isBinary, String documentPath){\n        \n        byte[] data = null;\n        \n        logger.debug(\"Get resource '\"+documentPath + \"' binary=\"+ isBinary);\n        \n        DBBroker broker = null;\n        try {\n            broker = brokerPool.get(SecurityManager.SYSTEM_USER);\n            \n            if(isBinary){\n                BinaryDocument binDoc = (BinaryDocument) broker.openDocument(documentPath, Lock.READ_LOCK);\n                data = broker.getBinaryResourceData(binDoc);\n                binDoc.getUpdateLock().release(Lock.READ_LOCK);\n                \n            } else {\n                \n                DocumentImpl doc = broker.openDocument(documentPath, Lock.READ_LOCK);\n                Serializer serializer = broker.getSerializer();\n                serializer.reset();\n                \n                // if document is not present, null is returned\n                if(doc != null){\n                    data = serializer.serialize(doc).getBytes();\n                } else {\n                    throw new EXistException(\"Document '\"+documentPath+\" does not exist.\");\n                }\n                \n                doc.getUpdateLock().release(Lock.READ_LOCK);\n            }\n        } catch (PermissionDeniedException ex){\n            logger.error(\"Error opening document\", ex);\n        } catch (SAXException ex){\n            logger.error(\"Error serializing document\", ex);\n        }  catch (EXistException ex){\n            logger.error(ex);\n        } finally {\n            if(brokerPool!=null){\n                brokerPool.release(broker);\n            }\n        }\n        \n        return data;\n    }","id":88190,"modified_method":"/**\n     *  Get document from database.\n     *\n     * @param isBinary      Indicate wether resource is binary.\n     * @param documentPath  Path to the resource.\n     * @return              Byte array of resource, null if not found.\n     */\n    public byte[] getGrammar(boolean isBinary, String documentPath){\n        \n        byte[] data = null;\n        \n        logger.debug(\"Get resource '\"+documentPath + \"' binary=\"+ isBinary);\n        \n        DBBroker broker = null;\n        try {\n            broker = brokerPool.get(SecurityManager.SYSTEM_USER);\n            \n            if(isBinary){\n                BinaryDocument binDoc = (BinaryDocument) broker\n                        .openDocument(documentPath, Lock.READ_LOCK);\n                \n                // if document is not present, null is returned\n                if(binDoc == null){\n                    logger.error(\"Binary document '\"\n                            + documentPath + \" does not exist.\");\n                } else {\n                    data = broker.getBinaryResourceData(binDoc);\n                    binDoc.getUpdateLock().release(Lock.READ_LOCK);\n                }\n                \n            } else {\n                \n                DocumentImpl doc = broker\n                                    .openDocument(documentPath, Lock.READ_LOCK);\n                \n                // if document is not present, null is returned\n                if(doc == null){\n                    logger.error(\"Xml document '\"\n                                + documentPath + \" does not exist.\");\n                } else {\n                    Serializer serializer = broker.getSerializer();\n                    serializer.reset();\n                    data = serializer.serialize(doc).getBytes();\n                    doc.getUpdateLock().release(Lock.READ_LOCK);   \n                }\n            }\n        } catch (PermissionDeniedException ex){\n            logger.error(\"Error opening document\", ex);\n        } catch (SAXException ex){\n            logger.error(\"Error serializing document\", ex);\n        }  catch (EXistException ex){\n            logger.error(ex);\n        } finally {\n            if(brokerPool!=null){\n                brokerPool.release(broker);\n            }\n        }\n        \n        return data;\n    }","commit_id":"bc2a19192786b5ca20f84a61eefd1433320ce29a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n        public List<? extends Option> options()\n        {\n            final List<Option> options = new ArrayList<>();\n            options.addAll(parent.options());\n            options.add(add);\n            return options;\n        }","id":88191,"modified_method":"@Override\n        public List<? extends Option> options()\n        {\n            return merge(parent.options(), Arrays.asList(add, keysize));\n        }","commit_id":"73b2dcc165155fd90ecc978c7281276e536d317d","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public List<? extends Option> options()\n        {\n            final List<Option> options = new ArrayList<>();\n            options.add(clustering);\n            options.add(probabilities);\n            options.addAll(super.options());\n            return options;\n        }","id":88192,"modified_method":"@Override\n        public List<? extends Option> options()\n        {\n            return merge(Arrays.asList(clustering, probabilities), super.options());\n        }","commit_id":"73b2dcc165155fd90ecc978c7281276e536d317d","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n        public List<? extends Option> options()\n        {\n            return ImmutableList.<Option>builder().add(ops, clustering, profile).addAll(parent.options()).build();\n        }","id":88193,"modified_method":"@Override\n        public List<? extends Option> options()\n        {\n            return merge(Arrays.asList(ops, profile, clustering), parent.options());\n        }","commit_id":"73b2dcc165155fd90ecc978c7281276e536d317d","url":"https://github.com/apache/cassandra"},{"original_method":"public static boolean strandTest(char ref, LocusContext context, int allele1, int allele2, double threshold, StringBuffer out) {\n        int[][] table = getContingencyTable(context, allele1, allele2);\n        if ( !variantIsHet(table) )\n            return false;\n\n        double pCutoff = computePValue(table);\n        //printTable(table, pCutoff);\n\n        double pValue = 0.0;\n        while (rotateTable(table)) {\n            double pValuePiece = computePValue(table);\n\n            //printTable(table, pValuePiece);\n\n            if (pValuePiece <= pCutoff) {\n                pValue += pValuePiece;\n            }\n        }\n\n        table = getContingencyTable(context, allele1, allele2);\n\n        while (unrotateTable(table)) {\n            double pValuePiece = computePValue(table);\n\n            //printTable(table, pValuePiece);\n\n            if (pValuePiece <= pCutoff) {\n                pValue += pValuePiece;\n            }\n        }\n\n        //System.out.printf(\"P-cutoff: %f\\n\", pCutoff);\n        //System.out.printf(\"P-value: %f\\n\\n\", pValue);\n\n        // optionally print out the pvalue and the alternate allele counts\n        if ( out != null ) {\n            int refBase = BaseUtils.simpleBaseToBaseIndex(ref);\n            table = getContingencyTable(context, allele1, allele2);\n            if ( allele1 != refBase )\n                out.append(pValue + \"\\t\" + table[0][0] + \"\\t\" + table[0][1] + \"\\t\");\n            else\n                out.append(pValue + \"\\t\" + table[1][0] + \"\\t\" + table[1][1] + \"\\t\");\n        }\n\n        return pValue < threshold;\n    }","id":88194,"modified_method":"public boolean strandTest(char ref, LocusContext context, int allele1, int allele2, double threshold, StringBuffer out) {\n        int[][] table = getContingencyTable(context, allele1, allele2);\n        if ( !variantIsHet(table) )\n            return false;\n\n        updateFactorials(table);\n\n        double pCutoff = computePValue(table);\n        //printTable(table, pCutoff);\n\n        double pValue = pCutoff;\n        while (rotateTable(table)) {\n            double pValuePiece = computePValue(table);\n\n            //printTable(table, pValuePiece);\n\n            if (pValuePiece <= pCutoff) {\n                pValue += pValuePiece;\n            }\n        }\n\n        table = getContingencyTable(context, allele1, allele2);\n\n        while (unrotateTable(table)) {\n            double pValuePiece = computePValue(table);\n\n            //printTable(table, pValuePiece);\n\n            if (pValuePiece <= pCutoff) {\n                pValue += pValuePiece;\n            }\n        }\n\n        //System.out.printf(\"P-cutoff: %f\\n\", pCutoff);\n        //System.out.printf(\"P-value: %f\\n\\n\", pValue);\n\n        // optionally print out the pvalue and the alternate allele counts\n        if ( out != null ) {\n            int refBase = BaseUtils.simpleBaseToBaseIndex(ref);\n            table = getContingencyTable(context, allele1, allele2);\n            if ( allele1 != refBase )\n                out.append(pValue + \"\\t\" + table[0][0] + \"\\t\" + table[0][1] + \"\\t\");\n            else\n                out.append(pValue + \"\\t\" + table[1][0] + \"\\t\" + table[1][1] + \"\\t\");\n        }\n\n        return pValue < threshold;\n    }","commit_id":"b282635b05569763173220bf74805d0b20e6d085","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize(String arguments) {\n        if (arguments != null && !arguments.isEmpty()) {\n            pvalueLimit = Double.valueOf(arguments);\n        }\n    }","id":88195,"modified_method":"public void initialize(String arguments) {\n        if (arguments != null && !arguments.isEmpty()) {\n            pvalueLimit = Double.valueOf(arguments);\n        }\n        factorials.add(0.0);  // add fact(0)\n    }","commit_id":"b282635b05569763173220bf74805d0b20e6d085","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static double computePValue(int[][] table) {\n        double pCutoff = 1.0;\n\n        int[] rowSums = { sumRow(table, 0), sumRow(table, 1) };\n        int[] colSums = { sumColumn(table, 0), sumColumn(table, 1) };\n        int N = rowSums[0] + rowSums[1];\n\n        pCutoff *= (double) Arithmetic.factorial(rowSums[0]);\n        pCutoff *= (double) Arithmetic.factorial(rowSums[1]);\n        pCutoff *= (double) Arithmetic.factorial(colSums[0]);\n        pCutoff *= (double) Arithmetic.factorial(colSums[1]);\n        pCutoff /= (double) Arithmetic.factorial(N);\n\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                pCutoff /= (double) Arithmetic.factorial(table[i][j]);\n            }\n        }\n        return pCutoff;\n    }","id":88196,"modified_method":"private double computePValue(int[][] table) {\n\n        int[] rowSums = { sumRow(table, 0), sumRow(table, 1) };\n        int[] colSums = { sumColumn(table, 0), sumColumn(table, 1) };\n        int N = rowSums[0] + rowSums[1];\n\n        // calculate in log space so we don't die with high numbers\n        double pCutoff = factorials.get(rowSums[0])\n                         + factorials.get(rowSums[1])\n                         + factorials.get(colSums[0])\n                         + factorials.get(colSums[1])\n                         - factorials.get(table[0][0])\n                         - factorials.get(table[0][1])\n                         - factorials.get(table[1][0])\n                         - factorials.get(table[1][1])\n                         - factorials.get(N);\n        return Math.exp(pCutoff);\n\n        //pCutoff *= (double) Arithmetic.factorial(rowSums[0]);\n        //pCutoff *= (double) Arithmetic.factorial(rowSums[1]);\n        //pCutoff *= (double) Arithmetic.factorial(colSums[0]);\n        //pCutoff *= (double) Arithmetic.factorial(colSums[1]);\n        //pCutoff /= (double) Arithmetic.factorial(N);\n        //\n        //for (int i = 0; i < 2; i++) {\n        //    for (int j = 0; j < 2; j++) {\n        //        pCutoff /= (double) Arithmetic.factorial(table[i][j]);\n        //    }\n        //}\n        //\n        //return pCutoff;\n    }","commit_id":"b282635b05569763173220bf74805d0b20e6d085","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n  public boolean supportsNamedGroupRefSyntax(RegExpNamedGroupRef ref) {\n    if (ref.isNamedGroupRef()) {\n      final JavaSdkVersion version = getJavaVersion(ref);\n      return version != null && version.isAtLeast(JavaSdkVersion.JDK_1_7);\n    }\n    return false;\n  }","id":88197,"modified_method":"@Override\n  public boolean supportsNamedGroupRefSyntax(RegExpNamedGroupRef ref) {\n    return ref.isNamedGroupRef() && hasAtLeastJdkVersion(ref, JavaSdkVersion.JDK_1_7);\n  }","commit_id":"52ef7e5357a5394cd1549683c16cbd4c55e0fa6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean supportsExtendedHexCharacter(RegExpChar regExpChar) {\n    final JavaSdkVersion version = getJavaVersion(regExpChar);\n    return version != null && version.isAtLeast(JavaSdkVersion.JDK_1_7);\n  }","id":88198,"modified_method":"@Override\n  public boolean supportsExtendedHexCharacter(RegExpChar regExpChar) {\n    return hasAtLeastJdkVersion(regExpChar, JavaSdkVersion.JDK_1_7);\n  }","commit_id":"52ef7e5357a5394cd1549683c16cbd4c55e0fa6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static JavaSdkVersion getJavaVersion(PsiElement element) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return JavaSdkVersion.JDK_1_9;\n    }\n    final Module module = ModuleUtilCore.findModuleForPsiElement(element);\n    if (module != null) {\n      final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n      if (sdk != null && sdk.getSdkType() instanceof JavaSdk) {\n        return JavaSdk.getInstance().getVersion(sdk);\n      }\n    }\n    final Sdk sdk = ProjectRootManager.getInstance(element.getProject()).getProjectSdk();\n    if (sdk != null && sdk.getSdkType() instanceof JavaSdk) {\n      return JavaSdk.getInstance().getVersion(sdk);\n    }\n    return null;\n  }","id":88199,"modified_method":"@Nullable\n  private static JavaSdkVersion getJavaVersion(PsiElement element) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return JavaSdkVersion.JDK_1_9;\n    }\n    final Module module = ModuleUtilCore.findModuleForPsiElement(element);\n    if (module != null) {\n      final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n      if (sdk != null && sdk.getSdkType() instanceof JavaSdk) {\n        final JavaSdkVersion version = JavaSdk.getInstance().getVersion(sdk);\n        if (version != null) {\n          return version;\n        }\n      }\n    }\n    final Sdk sdk = ProjectRootManager.getInstance(element.getProject()).getProjectSdk();\n    if (sdk != null && sdk.getSdkType() instanceof JavaSdk) {\n      return JavaSdk.getInstance().getVersion(sdk);\n    }\n    return null;\n  }","commit_id":"52ef7e5357a5394cd1549683c16cbd4c55e0fa6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean supportsNamedGroupSyntax(RegExpGroup group) {\n    if (group.isNamedGroup()) {\n      final JavaSdkVersion version = getJavaVersion(group);\n      return version != null && version.isAtLeast(JavaSdkVersion.JDK_1_7);\n    }\n    return false;\n  }","id":88200,"modified_method":"@Override\n  public boolean supportsNamedGroupSyntax(RegExpGroup group) {\n    return group.isNamedGroup() && hasAtLeastJdkVersion(group, JavaSdkVersion.JDK_1_7);\n  }","commit_id":"52ef7e5357a5394cd1549683c16cbd4c55e0fa6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doBackSlashVariantsTest() throws Throwable {\n        java.util.List<String> nameList = new ArrayList<String>(Arrays.asList(\"d\", \"D\", \"s\", \"S\", \"w\", \"W\", \"b\", \"B\", \"A\", \"G\", \"Z\", \"z\", \"Q\", \"E\",\n                \"t\", \"n\", \"r\", \"f\", \"a\", \"e\", \"h\", \"H\", \"v\", \"V\"));\n        for (String[] stringArray : DefaultRegExpPropertiesProvider.getInstance().getAllKnownProperties()) {\n            nameList.add(\"p{\" + stringArray[0] + \"}\");\n        }\n        myFixture.testCompletionVariants(getInputDataFileName(getTestName(true)), ArrayUtil.toStringArray(nameList));\n    }","id":88201,"modified_method":"private void doBackSlashVariantsTest() throws Throwable {\n        java.util.List<String> nameList = new ArrayList<String>(Arrays.asList(\"d\", \"D\", \"s\", \"S\", \"w\", \"W\", \"b\", \"B\", \"A\", \"G\", \"Z\", \"z\", \"Q\", \"E\",\n                \"t\", \"n\", \"r\", \"f\", \"a\", \"e\", \"h\", \"H\", \"v\", \"V\", \"R\"));\n        for (String[] stringArray : DefaultRegExpPropertiesProvider.getInstance().getAllKnownProperties()) {\n            nameList.add(\"p{\" + stringArray[0] + \"}\");\n        }\n        myFixture.testCompletionVariants(getInputDataFileName(getTestName(true)), ArrayUtil.toStringArray(nameList));\n    }","commit_id":"52ef7e5357a5394cd1549683c16cbd4c55e0fa6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public Kind getKind() {\n        final String s = getUnescapedText();\n        if (s.equals(\".\")) {\n            return Kind.ANY;\n        } else if (s.equals(\"\\\\d\")) {\n            return Kind.DIGIT;\n        } else if (s.equals(\"\\\\D\")) {\n            return Kind.NON_DIGIT;\n        } else if (s.equals(\"\\\\w\")) {\n            return Kind.WORD;\n        } else if (s.equals(\"\\\\W\")) {\n            return Kind.NON_WORD;\n        } else if (s.equals(\"\\\\s\")) {\n            return Kind.SPACE;\n        } else if (s.equals(\"\\\\S\")) {\n            return Kind.NON_SPACE;\n        }\n        assert false;\n        return null;\n    }","id":88202,"modified_method":"@Override\n    @NotNull\n    public Kind getKind() {\n        switch (getUnescapedText()) {\n            case \".\": return Kind.ANY;\n            case \"\\\\d\": return Kind.DIGIT;\n            case \"\\\\D\": return Kind.NON_DIGIT;\n            case \"\\\\w\": return Kind.WORD;\n            case \"\\\\W\": return Kind.NON_WORD;\n            case \"\\\\s\": return Kind.SPACE;\n            case \"\\\\S\": return Kind.NON_SPACE;\n            case \"\\\\h\": return Kind.HORIZONTAL_SPACE;\n            case \"\\\\H\": return Kind.NON_HORIZONTAL_SPACE;\n            case \"\\\\v\": return Kind.VERTICAL_SPACE;\n            case \"\\\\V\": return Kind.NON_VERTICAL_SPACE;\n            case \"\\\\i\": return Kind.XML_NAME_START;\n            case \"\\\\I\": return Kind.NON_XML_NAME_START;\n            case \"\\\\c\": return Kind.XML_NAME_PART;\n            case \"\\\\C\": return Kind.NON_XML_NAME_PART;\n            case \"\\\\X\": return Kind.UNICODE_GRAPHEME;\n            case \"\\\\R\": return Kind.UNICODE_LINEBREAK;\n            default: assert false; return null;\n        }\n    }","commit_id":"52ef7e5357a5394cd1549683c16cbd4c55e0fa6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Tests adding a series of Mutations and BatchMutations, including a\n   * delete mutation.  Also tests data retrieval, and getting back multiple\n   * versions.\n   *\n   * @throws Exception\n   */\n  public void doTestTableMutations() throws Exception {\n    // Setup\n    ThriftServer.HBaseHandler handler =\n      new ThriftServer.HBaseHandler(UTIL.getConfiguration());\n    handler.createTable(tableAname, getColumnDescriptors());\n\n    // Apply a few Mutations to rowA\n    //     mutations.add(new Mutation(false, columnAname, valueAname));\n    //     mutations.add(new Mutation(false, columnBname, valueBname));\n    handler.mutateRow(tableAname, rowAname, getMutations());\n\n    // Assert that the changes were made\n    assertEquals(valueAname,\n      handler.get(tableAname, rowAname, columnAname).get(0).value);\n    TRowResult rowResult1 = handler.getRow(tableAname, rowAname).get(0);\n    assertEquals(rowAname, rowResult1.row);\n    assertEquals(valueBname,\n      rowResult1.columns.get(columnBname).value);\n\n    // Apply a few BatchMutations for rowA and rowB\n    // rowAmutations.add(new Mutation(true, columnAname, null));\n    // rowAmutations.add(new Mutation(false, columnBname, valueCname));\n    // batchMutations.add(new BatchMutation(rowAname, rowAmutations));\n    // Mutations to rowB\n    // rowBmutations.add(new Mutation(false, columnAname, valueCname));\n    // rowBmutations.add(new Mutation(false, columnBname, valueDname));\n    // batchMutations.add(new BatchMutation(rowBname, rowBmutations));\n    handler.mutateRows(tableAname, getBatchMutations());\n\n    // Assert that changes were made to rowA\n    List<TCell> cells = handler.get(tableAname, rowAname, columnAname);\n    assertFalse(cells.size() > 0);\n    assertEquals(valueCname, handler.get(tableAname, rowAname, columnBname).get(0).value);\n    List<TCell> versions = handler.getVer(tableAname, rowAname, columnBname, MAXVERSIONS);\n    assertEquals(valueCname, versions.get(0).value);\n    assertEquals(valueBname, versions.get(1).value);\n\n    // Assert that changes were made to rowB\n    TRowResult rowResult2 = handler.getRow(tableAname, rowBname).get(0);\n    assertEquals(rowBname, rowResult2.row);\n    assertEquals(valueCname, rowResult2.columns.get(columnAname).value);\n\t  assertEquals(valueDname, rowResult2.columns.get(columnBname).value);\n\n    // Apply some deletes\n    handler.deleteAll(tableAname, rowAname, columnBname);\n    handler.deleteAllRow(tableAname, rowBname);\n\n    // Assert that the deletes were applied\n    int size = handler.get(tableAname, rowAname, columnBname).size();\n    assertEquals(0, size);\n    size = handler.getRow(tableAname, rowBname).size();\n    assertEquals(0, size);\n\n    // Teardown\n    handler.disableTable(tableAname);\n    handler.deleteTable(tableAname);\n  }","id":88203,"modified_method":"/**\n   * Tests adding a series of Mutations and BatchMutations, including a\n   * delete mutation.  Also tests data retrieval, and getting back multiple\n   * versions.\n   *\n   * @throws Exception\n   */\n  public void doTestTableMutations() throws Exception {\n    // Setup\n    ThriftServer.HBaseHandler handler =\n      new ThriftServer.HBaseHandler(UTIL.getConfiguration());\n    handler.createTable(tableAname, getColumnDescriptors());\n\n    // Apply a few Mutations to rowA\n    //     mutations.add(new Mutation(false, columnAname, valueAname));\n    //     mutations.add(new Mutation(false, columnBname, valueBname));\n    handler.mutateRow(tableAname, rowAname, getMutations());\n\n    // Assert that the changes were made\n    assertEquals(valueAname,\n      handler.get(tableAname, rowAname, columnAname).get(0).value);\n    TRowResult rowResult1 = handler.getRow(tableAname, rowAname).get(0);\n    assertEquals(rowAname, rowResult1.row);\n    assertEquals(valueBname,\n      rowResult1.columns.get(columnBname).value);\n\n    // Apply a few BatchMutations for rowA and rowB\n    // rowAmutations.add(new Mutation(true, columnAname, null));\n    // rowAmutations.add(new Mutation(false, columnBname, valueCname));\n    // batchMutations.add(new BatchMutation(rowAname, rowAmutations));\n    // Mutations to rowB\n    // rowBmutations.add(new Mutation(false, columnAname, valueCname));\n    // rowBmutations.add(new Mutation(false, columnBname, valueDname));\n    // batchMutations.add(new BatchMutation(rowBname, rowBmutations));\n    handler.mutateRows(tableAname, getBatchMutations());\n\n    // Assert that changes were made to rowA\n    List<TCell> cells = handler.get(tableAname, rowAname, columnAname);\n    assertFalse(cells.size() > 0);\n    assertEquals(valueCname, handler.get(tableAname, rowAname, columnBname).get(0).value);\n    List<TCell> versions = handler.getVer(tableAname, rowAname, columnBname, MAXVERSIONS);\n    assertEquals(valueCname, versions.get(0).value);\n    assertEquals(valueBname, versions.get(1).value);\n\n    // Assert that changes were made to rowB\n    TRowResult rowResult2 = handler.getRow(tableAname, rowBname).get(0);\n    assertEquals(rowBname, rowResult2.row);\n    assertEquals(valueCname, rowResult2.columns.get(columnAname).value);\n\t  assertEquals(valueDname, rowResult2.columns.get(columnBname).value);\n\n    // Apply some deletes\n    handler.deleteAll(tableAname, rowAname, columnBname);\n    handler.deleteAllRow(tableAname, rowBname);\n\n    // Assert that the deletes were applied\n    int size = handler.get(tableAname, rowAname, columnBname).size();\n    assertEquals(0, size);\n    size = handler.getRow(tableAname, rowBname).size();\n    assertEquals(0, size);\n\n    // Try null mutation\n    List<Mutation> mutations = new ArrayList<Mutation>();\n    mutations.add(new Mutation(false, columnAname, null));\n    handler.mutateRow(tableAname, rowAname, mutations);\n    TRowResult rowResult3 = handler.getRow(tableAname, rowAname).get(0);\n    assertEquals(rowAname, rowResult3.row);\n    assertEquals(0, rowResult3.columns.get(columnAname).value.array().length);\n\n    // Teardown\n    handler.disableTable(tableAname);\n    handler.deleteTable(tableAname);\n  }","commit_id":"0e83d7445db057476a2ac3263ba61f9f540bfcae","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void mutateRowTs(ByteBuffer tableName, ByteBuffer row,\n        List<Mutation> mutations, long timestamp) throws IOError, IllegalArgument {\n      HTable table = null;\n      try {\n        table = getTable(tableName);\n        Put put = new Put(getBytes(row), timestamp, null);\n\n        Delete delete = new Delete(getBytes(row));\n\n        // I apologize for all this mess :)\n        for (Mutation m : mutations) {\n          byte[][] famAndQf = KeyValue.parseColumn(getBytes(m.column));\n          if (m.isDelete) {\n            if (famAndQf.length == 1) {\n              delete.deleteFamily(famAndQf[0], timestamp);\n            } else {\n              delete.deleteColumns(famAndQf[0], famAndQf[1], timestamp);\n            }\n          } else {\n            if(famAndQf.length == 1) {\n              put.add(famAndQf[0], new byte[0], getBytes(m.value));\n            } else {\n              put.add(famAndQf[0], famAndQf[1], getBytes(m.value));\n            }\n          }\n        }\n        if (!delete.isEmpty())\n          table.delete(delete);\n        if (!put.isEmpty())\n          table.put(put);\n      } catch (IOException e) {\n        throw new IOError(e.getMessage());\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgument(e.getMessage());\n      }\n    }","id":88204,"modified_method":"@Override\n    public void mutateRowTs(ByteBuffer tableName, ByteBuffer row,\n        List<Mutation> mutations, long timestamp) throws IOError, IllegalArgument {\n      HTable table = null;\n      try {\n        table = getTable(tableName);\n        Put put = new Put(getBytes(row), timestamp, null);\n\n        Delete delete = new Delete(getBytes(row));\n\n        // I apologize for all this mess :)\n        for (Mutation m : mutations) {\n          byte[][] famAndQf = KeyValue.parseColumn(getBytes(m.column));\n          if (m.isDelete) {\n            if (famAndQf.length == 1) {\n              delete.deleteFamily(famAndQf[0], timestamp);\n            } else {\n              delete.deleteColumns(famAndQf[0], famAndQf[1], timestamp);\n            }\n          } else {\n            if(famAndQf.length == 1) {\n              put.add(famAndQf[0], HConstants.EMPTY_BYTE_ARRAY,\n                  m.value != null ? m.value.array()\n                      : HConstants.EMPTY_BYTE_ARRAY);\n            } else {\n              put.add(famAndQf[0], famAndQf[1],\n                  m.value != null ? m.value.array()\n                      : HConstants.EMPTY_BYTE_ARRAY);\n            }\n          }\n        }\n        if (!delete.isEmpty())\n          table.delete(delete);\n        if (!put.isEmpty())\n          table.put(put);\n      } catch (IOException e) {\n        throw new IOError(e.getMessage());\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgument(e.getMessage());\n      }\n    }","commit_id":"0e83d7445db057476a2ac3263ba61f9f540bfcae","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp)\n        throws IOError, IllegalArgument, TException {\n      List<Put> puts = new ArrayList<Put>();\n      List<Delete> deletes = new ArrayList<Delete>();\n\n      for (BatchMutation batch : rowBatches) {\n        byte[] row = getBytes(batch.row);\n        List<Mutation> mutations = batch.mutations;\n        Delete delete = new Delete(row);\n        Put put = new Put(row, timestamp, null);\n        for (Mutation m : mutations) {\n          byte[][] famAndQf = KeyValue.parseColumn(getBytes(m.column));\n          if (m.isDelete) {\n            // no qualifier, family only.\n            if (famAndQf.length == 1) {\n              delete.deleteFamily(famAndQf[0], timestamp);\n            } else {\n              delete.deleteColumns(famAndQf[0], famAndQf[1], timestamp);\n            }\n          } else {\n            if(famAndQf.length == 1) {\n              put.add(famAndQf[0], new byte[0], getBytes(m.value));\n            } else {\n              put.add(famAndQf[0], famAndQf[1], getBytes(m.value));\n            }\n          }\n        }\n        if (!delete.isEmpty())\n          deletes.add(delete);\n        if (!put.isEmpty())\n          puts.add(put);\n      }\n\n      HTable table = null;\n      try {\n        table = getTable(tableName);\n        if (!puts.isEmpty())\n          table.put(puts);\n        for (Delete del : deletes) {\n          table.delete(del);\n        }\n      } catch (IOException e) {\n        throw new IOError(e.getMessage());\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgument(e.getMessage());\n      }\n    }","id":88205,"modified_method":"@Override\n    public void mutateRowsTs(ByteBuffer tableName, List<BatchMutation> rowBatches, long timestamp)\n        throws IOError, IllegalArgument, TException {\n      List<Put> puts = new ArrayList<Put>();\n      List<Delete> deletes = new ArrayList<Delete>();\n\n      for (BatchMutation batch : rowBatches) {\n        byte[] row = getBytes(batch.row);\n        List<Mutation> mutations = batch.mutations;\n        Delete delete = new Delete(row);\n        Put put = new Put(row, timestamp, null);\n        for (Mutation m : mutations) {\n          byte[][] famAndQf = KeyValue.parseColumn(getBytes(m.column));\n          if (m.isDelete) {\n            // no qualifier, family only.\n            if (famAndQf.length == 1) {\n              delete.deleteFamily(famAndQf[0], timestamp);\n            } else {\n              delete.deleteColumns(famAndQf[0], famAndQf[1], timestamp);\n            }\n          } else {\n            if(famAndQf.length == 1) {\n              put.add(famAndQf[0], HConstants.EMPTY_BYTE_ARRAY,\n                  m.value != null ? m.value.array()\n                      : HConstants.EMPTY_BYTE_ARRAY);\n            } else {\n              put.add(famAndQf[0], famAndQf[1],\n                  m.value != null ? m.value.array()\n                      : HConstants.EMPTY_BYTE_ARRAY);\n            }\n          }\n        }\n        if (!delete.isEmpty())\n          deletes.add(delete);\n        if (!put.isEmpty())\n          puts.add(put);\n      }\n\n      HTable table = null;\n      try {\n        table = getTable(tableName);\n        if (!puts.isEmpty())\n          table.put(puts);\n        for (Delete del : deletes) {\n          table.delete(del);\n        }\n      } catch (IOException e) {\n        throw new IOError(e.getMessage());\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgument(e.getMessage());\n      }\n    }","commit_id":"0e83d7445db057476a2ac3263ba61f9f540bfcae","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Rewinds {@code buf} and writes first 4 header fields. {@code buf} position\n   * is modified as side-effect.\n   */\n  private void overwriteHeader() {\n    buf.rewind();\n    blockType.write(buf);\n    buf.putInt(onDiskSizeWithoutHeader);\n    buf.putInt(uncompressedSizeWithoutHeader);\n    buf.putLong(prevBlockOffset);\n  }","id":88206,"modified_method":"/**\n   * Rewinds {@code buf} and writes first 4 header fields. {@code buf} position\n   * is modified as side-effect.\n   */\n  private void overwriteHeader() {\n    buf.rewind();\n    blockType.write(buf);\n    buf.putInt(onDiskSizeWithoutHeader);\n    buf.putInt(uncompressedSizeWithoutHeader);\n    buf.putLong(prevBlockOffset);\n    if (this.fileContext.isUseHBaseChecksum()) {\n      buf.put(fileContext.getChecksumType().getCode());\n      buf.putInt(fileContext.getBytesPerChecksum());\n      buf.putInt(onDiskDataSizeWithHeader);\n    }\n  }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Creates a new HFileBlock. Checksums have already been validated, so\n     * the byte buffer passed into the constructor of this newly created\n     * block does not have checksum data even though the header minor\n     * version is MINOR_VERSION_WITH_CHECKSUM. This is indicated by setting a\n     * 0 value in bytesPerChecksum.\n     */\n    public HFileBlock getBlockForCaching(CacheConfig cacheConf) {\n      HFileContext newContext = new HFileContextBuilder()\n                                .withBlockSize(fileContext.getBlocksize())\n                                .withBytesPerCheckSum(0)\n                                .withChecksumType(ChecksumType.NULL) // no checksums in cached data\n                                .withCompression(fileContext.getCompression())\n                                .withDataBlockEncoding(fileContext.getDataBlockEncoding())\n                                .withHBaseCheckSum(fileContext.isUseHBaseChecksum())\n                                .withCompressTags(fileContext.isCompressTags())\n                                .withIncludesMvcc(fileContext.isIncludesMvcc())\n                                .withIncludesTags(fileContext.isIncludesTags())\n                                .build();\n      return new HFileBlock(blockType, getOnDiskSizeWithoutHeader(),\n          getUncompressedSizeWithoutHeader(), prevOffset,\n          cacheConf.shouldCacheCompressed(blockType.getCategory()) ?\n            getOnDiskBufferWithHeader() :\n            getUncompressedBufferWithHeader(),\n          DONT_FILL_HEADER, startOffset,\n          onDiskBytesWithHeader.length + onDiskChecksum.length, newContext);\n    }","id":88207,"modified_method":"/**\n     * Creates a new HFileBlock. Checksums have already been validated, so\n     * the byte buffer passed into the constructor of this newly created\n     * block does not have checksum data even though the header minor\n     * version is MINOR_VERSION_WITH_CHECKSUM. This is indicated by setting a\n     * 0 value in bytesPerChecksum.\n     */\n    public HFileBlock getBlockForCaching(CacheConfig cacheConf) {\n      HFileContext newContext = new HFileContextBuilder()\n                                .withBlockSize(fileContext.getBlocksize())\n                                .withBytesPerCheckSum(0)\n                                .withChecksumType(ChecksumType.NULL) // no checksums in cached data\n                                .withCompression(fileContext.getCompression())\n                                .withDataBlockEncoding(fileContext.getDataBlockEncoding())\n                                .withHBaseCheckSum(fileContext.isUseHBaseChecksum())\n                                .withCompressTags(fileContext.isCompressTags())\n                                .withIncludesMvcc(fileContext.isIncludesMvcc())\n                                .withIncludesTags(fileContext.isIncludesTags())\n                                .build();\n      return new HFileBlock(blockType, getOnDiskSizeWithoutHeader(),\n          getUncompressedSizeWithoutHeader(), prevOffset,\n          cacheConf.shouldCacheCompressed(blockType.getCategory()) ?\n            getOnDiskBufferWithHeader() :\n            getUncompressedBufferWithHeader(),\n          FILL_HEADER, startOffset,\n          onDiskBytesWithHeader.length + onDiskChecksum.length, newContext);\n    }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Creates a new {@link HFile} block from the given fields. This constructor\n   * is mostly used when the block data has already been read and uncompressed,\n   * and is sitting in a byte buffer.\n   *\n   * @param blockType the type of this block, see {@link BlockType}\n   * @param onDiskSizeWithoutHeader see {@link #onDiskSizeWithoutHeader}\n   * @param uncompressedSizeWithoutHeader see {@link #uncompressedSizeWithoutHeader}\n   * @param prevBlockOffset see {@link #prevBlockOffset}\n   * @param buf block header ({@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes) followed by\n   *          uncompressed data. This\n   * @param fillHeader when true, parse {@code buf} and override the first 4 header fields.\n   * @param offset the file offset the block was read from\n   * @param onDiskDataSizeWithHeader see {@link #onDiskDataSizeWithHeader}\n   * @param fileContext HFile meta data\n   */\n  HFileBlock(BlockType blockType, int onDiskSizeWithoutHeader, int uncompressedSizeWithoutHeader,\n      long prevBlockOffset, ByteBuffer buf, boolean fillHeader, long offset,\n      int onDiskDataSizeWithHeader, HFileContext fileContext) {\n    this.blockType = blockType;\n    this.onDiskSizeWithoutHeader = onDiskSizeWithoutHeader;\n    this.uncompressedSizeWithoutHeader = uncompressedSizeWithoutHeader;\n    this.prevBlockOffset = prevBlockOffset;\n    this.buf = buf;\n    if (fillHeader)\n      overwriteHeader();\n    this.offset = offset;\n    this.onDiskDataSizeWithHeader = onDiskDataSizeWithHeader;\n    this.fileContext = fileContext;\n    this.buf.rewind();\n  }","id":88208,"modified_method":"/**\n   * Creates a new {@link HFile} block from the given fields. This constructor\n   * is mostly used when the block data has already been read and uncompressed,\n   * and is sitting in a byte buffer.\n   *\n   * @param blockType the type of this block, see {@link BlockType}\n   * @param onDiskSizeWithoutHeader see {@link #onDiskSizeWithoutHeader}\n   * @param uncompressedSizeWithoutHeader see {@link #uncompressedSizeWithoutHeader}\n   * @param prevBlockOffset see {@link #prevBlockOffset}\n   * @param buf block header ({@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes) followed by\n   *          uncompressed data. This\n   * @param fillHeader when true, parse {@code buf} and override the first 4 header fields.\n   * @param offset the file offset the block was read from\n   * @param onDiskDataSizeWithHeader see {@link #onDiskDataSizeWithHeader}\n   * @param fileContext HFile meta data\n   */\n  HFileBlock(BlockType blockType, int onDiskSizeWithoutHeader, int uncompressedSizeWithoutHeader,\n      long prevBlockOffset, ByteBuffer buf, boolean fillHeader, long offset,\n      int onDiskDataSizeWithHeader, HFileContext fileContext) {\n    this.blockType = blockType;\n    this.onDiskSizeWithoutHeader = onDiskSizeWithoutHeader;\n    this.uncompressedSizeWithoutHeader = uncompressedSizeWithoutHeader;\n    this.prevBlockOffset = prevBlockOffset;\n    this.buf = buf;\n    this.offset = offset;\n    this.onDiskDataSizeWithHeader = onDiskDataSizeWithHeader;\n    this.fileContext = fileContext;\n    if (fillHeader)\n      overwriteHeader();\n    this.buf.rewind();\n  }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"@Parameters\n  public static Collection<Object[]> getParameters() {\n    List<Object[]> cowTypes = new ArrayList<Object[]>();\n    for (CacheOnWriteType cowType : CacheOnWriteType.values()) {\n      for (Compression.Algorithm compress :\n           HBaseTestingUtility.COMPRESSION_ALGORITHMS) {\n        for (BlockEncoderTestType encoderType :\n             BlockEncoderTestType.values()) {\n          for (boolean cacheCompressedData : new boolean[] { false, true }) {\n            cowTypes.add(new Object[] { cowType, compress, encoderType, cacheCompressedData });\n          }\n        }\n      }\n    }\n    return cowTypes;\n  }","id":88209,"modified_method":"@Parameters\n  public static Collection<Object[]> getParameters() throws IOException {\n    List<Object[]> cowTypes = new ArrayList<Object[]>();\n    for (BlockCache blockache : getBlockCaches()) {\n      for (CacheOnWriteType cowType : CacheOnWriteType.values()) {\n        for (Compression.Algorithm compress : HBaseTestingUtility.COMPRESSION_ALGORITHMS) {\n          for (BlockEncoderTestType encoderType : BlockEncoderTestType.values()) {\n            for (boolean cacheCompressedData : new boolean[] { false, true }) {\n              cowTypes.add(new Object[] { cowType, compress, encoderType, cacheCompressedData, blockache});\n            }\n          }\n        }\n      }\n    }\n    return cowTypes;\n  }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"@Before\n  public void setUp() throws IOException {\n    conf = TEST_UTIL.getConfiguration();\n    this.conf.set(\"dfs.datanode.data.dir.perm\", \"700\");\n    conf.setInt(HFile.FORMAT_VERSION_KEY, HFile.MAX_FORMAT_VERSION);\n    conf.setInt(HFileBlockIndex.MAX_CHUNK_SIZE_KEY, INDEX_BLOCK_SIZE);\n    conf.setInt(BloomFilterFactory.IO_STOREFILE_BLOOM_BLOCK_SIZE,\n        BLOOM_BLOCK_SIZE);\n    conf.setBoolean(CacheConfig.CACHE_BLOCKS_ON_WRITE_KEY,\n      cowType.shouldBeCached(BlockType.DATA));\n    conf.setBoolean(CacheConfig.CACHE_INDEX_BLOCKS_ON_WRITE_KEY,\n        cowType.shouldBeCached(BlockType.LEAF_INDEX));\n    conf.setBoolean(CacheConfig.CACHE_BLOOM_BLOCKS_ON_WRITE_KEY,\n        cowType.shouldBeCached(BlockType.BLOOM_CHUNK));\n    conf.setBoolean(CacheConfig.CACHE_DATA_BLOCKS_COMPRESSED_KEY, cacheCompressedData);\n    cowType.modifyConf(conf);\n    fs = HFileSystem.get(conf);\n    cacheConf = new CacheConfig(conf);\n    blockCache = cacheConf.getBlockCache();\n  }","id":88210,"modified_method":"@Before\n  public void setUp() throws IOException {\n    conf = TEST_UTIL.getConfiguration();\n    this.conf.set(\"dfs.datanode.data.dir.perm\", \"700\");\n    conf.setInt(HFile.FORMAT_VERSION_KEY, HFile.MAX_FORMAT_VERSION);\n    conf.setInt(HFileBlockIndex.MAX_CHUNK_SIZE_KEY, INDEX_BLOCK_SIZE);\n    conf.setInt(BloomFilterFactory.IO_STOREFILE_BLOOM_BLOCK_SIZE,\n        BLOOM_BLOCK_SIZE);\n    conf.setBoolean(CacheConfig.CACHE_DATA_BLOCKS_COMPRESSED_KEY, cacheCompressedData);\n    cowType.modifyConf(conf);\n    fs = HFileSystem.get(conf);\n    cacheConf =\n        new CacheConfig(blockCache, true, true, cowType.shouldBeCached(BlockType.DATA),\n        cowType.shouldBeCached(BlockType.LEAF_INDEX),\n        cowType.shouldBeCached(BlockType.BLOOM_CHUNK), false, cacheCompressedData, true, false);\n  }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"public TestCacheOnWrite(CacheOnWriteType cowType, Compression.Algorithm compress,\n      BlockEncoderTestType encoderType, boolean cacheCompressedData) {\n    this.cowType = cowType;\n    this.compress = compress;\n    this.encoderType = encoderType;\n    this.encoder = encoderType.getEncoder();\n    this.cacheCompressedData = cacheCompressedData;\n    testDescription = \"[cacheOnWrite=\" + cowType + \", compress=\" + compress +\n        \", encoderType=\" + encoderType + \", cacheCompressedData=\" + cacheCompressedData + \"]\";\n    System.out.println(testDescription);\n  }","id":88211,"modified_method":"public TestCacheOnWrite(CacheOnWriteType cowType, Compression.Algorithm compress,\n      BlockEncoderTestType encoderType, boolean cacheCompressedData, BlockCache blockCache) {\n    this.cowType = cowType;\n    this.compress = compress;\n    this.encoderType = encoderType;\n    this.encoder = encoderType.getEncoder();\n    this.cacheCompressedData = cacheCompressedData;\n    this.blockCache = blockCache;\n    testDescription = \"[cacheOnWrite=\" + cowType + \", compress=\" + compress +\n        \", encoderType=\" + encoderType + \", cacheCompressedData=\" + cacheCompressedData + \"]\";\n    System.out.println(testDescription);\n  }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"private void readStoreFile(boolean useTags) throws IOException {\n    AbstractHFileReader reader;\n    if (useTags) {\n        reader = (HFileReaderV3) HFile.createReader(fs, storeFilePath, cacheConf, conf);\n    } else {\n        reader = (HFileReaderV2) HFile.createReader(fs, storeFilePath, cacheConf, conf);\n    }\n    LOG.info(\"HFile information: \" + reader);\n    HFileContext meta = new HFileContextBuilder().withCompression(compress)\n      .withBytesPerCheckSum(CKBYTES).withChecksumType(ChecksumType.NULL)\n      .withBlockSize(DATA_BLOCK_SIZE).withDataBlockEncoding(encoder.getDataBlockEncoding())\n      .withIncludesTags(useTags).build();\n    final boolean cacheBlocks = false;\n    final boolean pread = false;\n    HFileScanner scanner = reader.getScanner(cacheBlocks, pread);\n    assertTrue(testDescription, scanner.seekTo());\n\n    long offset = 0;\n    HFileBlock prevBlock = null;\n    EnumMap<BlockType, Integer> blockCountByType =\n        new EnumMap<BlockType, Integer>(BlockType.class);\n\n    DataBlockEncoding encodingInCache =\n        encoderType.getEncoder().getDataBlockEncoding();\n    while (offset < reader.getTrailer().getLoadOnOpenDataOffset()) {\n      long onDiskSize = -1;\n      if (prevBlock != null) {\n         onDiskSize = prevBlock.getNextBlockOnDiskSizeWithHeader();\n      }\n      // Flags: don't cache the block, use pread, this is not a compaction.\n      // Also, pass null for expected block type to avoid checking it.\n      HFileBlock block = reader.readBlock(offset, onDiskSize, false, true,\n        false, true, null, encodingInCache);\n      BlockCacheKey blockCacheKey = new BlockCacheKey(reader.getName(),\n          offset);\n      HFileBlock fromCache = (HFileBlock) blockCache.getBlock(blockCacheKey, true, false, true);\n      boolean isCached = fromCache != null;\n      boolean shouldBeCached = cowType.shouldBeCached(block.getBlockType());\n      assertTrue(\"shouldBeCached: \" + shouldBeCached+ \"\\n\" +\n          \"isCached: \" + isCached + \"\\n\" +\n          \"Test description: \" + testDescription + \"\\n\" +\n          \"block: \" + block + \"\\n\" +\n          \"encodingInCache: \" + encodingInCache + \"\\n\" +\n          \"blockCacheKey: \" + blockCacheKey,\n        shouldBeCached == isCached);\n      if (isCached) {\n        if (cacheConf.shouldCacheCompressed(fromCache.getBlockType().getCategory())) {\n          if (compress != Compression.Algorithm.NONE) {\n            assertFalse(fromCache.isUnpacked());\n          }\n          fromCache = fromCache.unpack(meta, reader.getUncachedBlockReader());\n        } else {\n          assertTrue(fromCache.isUnpacked());\n        }\n        // block we cached at write-time and block read from file should be identical\n        assertEquals(block.getChecksumType(), fromCache.getChecksumType());\n        assertEquals(block.getBlockType(), fromCache.getBlockType());\n        if (block.getBlockType() == BlockType.ENCODED_DATA) {\n          assertEquals(block.getDataBlockEncodingId(), fromCache.getDataBlockEncodingId());\n          assertEquals(block.getDataBlockEncoding(), fromCache.getDataBlockEncoding());\n        }\n        assertEquals(block.getOnDiskSizeWithHeader(), fromCache.getOnDiskSizeWithHeader());\n        assertEquals(block.getOnDiskSizeWithoutHeader(), fromCache.getOnDiskSizeWithoutHeader());\n        assertEquals(\n          block.getUncompressedSizeWithoutHeader(), fromCache.getUncompressedSizeWithoutHeader());\n      }\n      prevBlock = block;\n      offset += block.getOnDiskSizeWithHeader();\n      BlockType bt = block.getBlockType();\n      Integer count = blockCountByType.get(bt);\n      blockCountByType.put(bt, (count == null ? 0 : count) + 1);\n    }\n\n    LOG.info(\"Block count by type: \" + blockCountByType);\n    String countByType = blockCountByType.toString();\n    BlockType cachedDataBlockType =\n        encoderType.encode ? BlockType.ENCODED_DATA : BlockType.DATA;\n    if (useTags) {\n      assertEquals(\"{\" + cachedDataBlockType\n          + \"=1550, LEAF_INDEX=173, BLOOM_CHUNK=9, INTERMEDIATE_INDEX=20}\", countByType);\n    } else {\n      assertEquals(\"{\" + cachedDataBlockType\n          + \"=1379, LEAF_INDEX=154, BLOOM_CHUNK=9, INTERMEDIATE_INDEX=18}\", countByType);\n    }\n    reader.close();\n  }","id":88212,"modified_method":"private void readStoreFile(boolean useTags) throws IOException {\n    AbstractHFileReader reader;\n    if (useTags) {\n        reader = (HFileReaderV3) HFile.createReader(fs, storeFilePath, cacheConf, conf);\n    } else {\n        reader = (HFileReaderV2) HFile.createReader(fs, storeFilePath, cacheConf, conf);\n    }\n    LOG.info(\"HFile information: \" + reader);\n    HFileContext meta = new HFileContextBuilder().withCompression(compress)\n      .withBytesPerCheckSum(CKBYTES).withChecksumType(ChecksumType.NULL)\n      .withBlockSize(DATA_BLOCK_SIZE).withDataBlockEncoding(encoder.getDataBlockEncoding())\n      .withIncludesTags(useTags).build();\n    final boolean cacheBlocks = false;\n    final boolean pread = false;\n    HFileScanner scanner = reader.getScanner(cacheBlocks, pread);\n    assertTrue(testDescription, scanner.seekTo());\n\n    long offset = 0;\n    HFileBlock prevBlock = null;\n    EnumMap<BlockType, Integer> blockCountByType =\n        new EnumMap<BlockType, Integer>(BlockType.class);\n\n    DataBlockEncoding encodingInCache =\n        encoderType.getEncoder().getDataBlockEncoding();\n    while (offset < reader.getTrailer().getLoadOnOpenDataOffset()) {\n      long onDiskSize = -1;\n      if (prevBlock != null) {\n         onDiskSize = prevBlock.getNextBlockOnDiskSizeWithHeader();\n      }\n      // Flags: don't cache the block, use pread, this is not a compaction.\n      // Also, pass null for expected block type to avoid checking it.\n      HFileBlock block = reader.readBlock(offset, onDiskSize, false, true,\n        false, true, null, encodingInCache);\n      BlockCacheKey blockCacheKey = new BlockCacheKey(reader.getName(),\n          offset);\n      HFileBlock fromCache = (HFileBlock) blockCache.getBlock(blockCacheKey, true, false, true);\n      boolean isCached = fromCache != null;\n      boolean shouldBeCached = cowType.shouldBeCached(block.getBlockType());\n      assertTrue(\"shouldBeCached: \" + shouldBeCached+ \"\\n\" +\n          \"isCached: \" + isCached + \"\\n\" +\n          \"Test description: \" + testDescription + \"\\n\" +\n          \"block: \" + block + \"\\n\" +\n          \"encodingInCache: \" + encodingInCache + \"\\n\" +\n          \"blockCacheKey: \" + blockCacheKey,\n        shouldBeCached == isCached);\n      if (isCached) {\n        if (cacheConf.shouldCacheCompressed(fromCache.getBlockType().getCategory())) {\n          if (compress != Compression.Algorithm.NONE) {\n            assertFalse(fromCache.isUnpacked());\n          }\n          fromCache = fromCache.unpack(meta, reader.getUncachedBlockReader());\n        } else {\n          assertTrue(fromCache.isUnpacked());\n        }\n        // block we cached at write-time and block read from file should be identical\n        assertEquals(block.getChecksumType(), fromCache.getChecksumType());\n        assertEquals(block.getBlockType(), fromCache.getBlockType());\n        if (block.getBlockType() == BlockType.ENCODED_DATA) {\n          assertEquals(block.getDataBlockEncodingId(), fromCache.getDataBlockEncodingId());\n          assertEquals(block.getDataBlockEncoding(), fromCache.getDataBlockEncoding());\n        }\n        assertEquals(block.getOnDiskSizeWithHeader(), fromCache.getOnDiskSizeWithHeader());\n        assertEquals(block.getOnDiskSizeWithoutHeader(), fromCache.getOnDiskSizeWithoutHeader());\n        assertEquals(\n          block.getUncompressedSizeWithoutHeader(), fromCache.getUncompressedSizeWithoutHeader());\n      }\n      prevBlock = block;\n      offset += block.getOnDiskSizeWithHeader();\n      BlockType bt = block.getBlockType();\n      Integer count = blockCountByType.get(bt);\n      blockCountByType.put(bt, (count == null ? 0 : count) + 1);\n    }\n\n    LOG.info(\"Block count by type: \" + blockCountByType);\n    String countByType = blockCountByType.toString();\n    BlockType cachedDataBlockType =\n        encoderType.encode ? BlockType.ENCODED_DATA : BlockType.DATA;\n    if (useTags) {\n      assertEquals(\"{\" + cachedDataBlockType\n          + \"=1550, LEAF_INDEX=173, BLOOM_CHUNK=9, INTERMEDIATE_INDEX=20}\", countByType);\n    } else {\n      assertEquals(\"{\" + cachedDataBlockType\n          + \"=1379, LEAF_INDEX=154, BLOOM_CHUNK=9, INTERMEDIATE_INDEX=18}\", countByType);\n    }\n\n    // iterate all the keyvalue from hfile\n    while (scanner.next()) {\n      Cell cell = scanner.getKeyValue();\n    }\n    reader.close();\n  }","commit_id":"305267b8e2c68b6103eb389587394d19d2be3e82","url":"https://github.com/apache/hbase"},{"original_method":"public static boolean isLambdaFullyInferred(PsiLambdaExpression expression, PsiType functionalInterfaceType) {\n    if (expression.getParameterList().getParametersCount() > 0 || getFunctionalInterfaceReturnType(functionalInterfaceType) != PsiType.VOID) {   //todo check that void lambdas without params check\n      return !dependsOnTypeParams(functionalInterfaceType, expression);\n    }\n    return true;\n  }","id":88213,"modified_method":"public static boolean isLambdaFullyInferred(PsiLambdaExpression expression, PsiType functionalInterfaceType) {\n    if (expression.getParameterList().getParametersCount() > 0 || getFunctionalInterfaceReturnType(functionalInterfaceType) != PsiType.VOID) {   //todo check that void lambdas without params check\n      if (functionalInterfaceType instanceof PsiClassType && ((PsiClassType)functionalInterfaceType).isRaw()) return false;\n      return !dependsOnTypeParams(functionalInterfaceType, expression);\n    }\n    return true;\n  }","commit_id":"b199a1b76ca7608b0e61d728249a9e4d8e62ab6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isAcceptable(PsiLambdaExpression lambdaExpression, final PsiType leftType) {\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(leftType);\n    final PsiClass psiClass = resolveResult.getElement();\n    final MethodSignature methodSignature = getFunction(psiClass);\n    if (methodSignature == null) return false;\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    final PsiType[] parameterTypes = methodSignature.getParameterTypes();\n    if (lambdaParameters.length != parameterTypes.length) return false;\n    for (int lambdaParamIdx = 0, length = lambdaParameters.length; lambdaParamIdx < length; lambdaParamIdx++) {\n      PsiParameter parameter = lambdaParameters[lambdaParamIdx];\n      final PsiTypeElement typeElement = parameter.getTypeElement();\n      if (typeElement != null) {\n        final PsiType lambdaFormalType = typeElement.getType();\n        final PsiType methodParameterType = parameterTypes[lambdaParamIdx];\n        if (lambdaFormalType instanceof PsiPrimitiveType) {\n          if (methodParameterType instanceof PsiPrimitiveType) return methodParameterType.equals(lambdaFormalType);\n          return false;\n        }\n\n        if (!lambdaFormalType\n          .isAssignableFrom(GenericsUtil.eliminateWildcards(resolveResult.getSubstitutor().substitute(methodSignature.getSubstitutor().substitute(methodParameterType))))) {\n          return false;\n        }\n      }\n    }\n    LOG.assertTrue(psiClass != null);\n    PsiType methodReturnType = getReturnType(psiClass, methodSignature);\n    if (methodReturnType != null) {\n      methodReturnType = resolveResult.getSubstitutor().substitute(methodSignature.getSubstitutor().substitute(methodReturnType));\n      return checkReturnTypeCompatible(lambdaExpression, methodReturnType) == null;\n    }\n    return true;\n  }","id":88214,"modified_method":"public static boolean isAcceptable(PsiLambdaExpression lambdaExpression, final PsiType leftType) {\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(leftType);\n    final PsiClass psiClass = resolveResult.getElement();\n    final MethodSignature methodSignature = getFunction(psiClass);\n    if (methodSignature == null) return false;\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    final PsiType[] parameterTypes = methodSignature.getParameterTypes();\n    if (lambdaParameters.length != parameterTypes.length) return false;\n    for (int lambdaParamIdx = 0, length = lambdaParameters.length; lambdaParamIdx < length; lambdaParamIdx++) {\n      PsiParameter parameter = lambdaParameters[lambdaParamIdx];\n      final PsiTypeElement typeElement = parameter.getTypeElement();\n      if (typeElement != null) {\n        final PsiType lambdaFormalType = typeElement.getType();\n        final PsiType methodParameterType = parameterTypes[lambdaParamIdx];\n        if (lambdaFormalType instanceof PsiPrimitiveType) {\n          if (methodParameterType instanceof PsiPrimitiveType) return methodParameterType.equals(lambdaFormalType);\n          return false;\n        }\n\n        if (!TypeConversionUtil.erasure(lambdaFormalType)\n          .isAssignableFrom(TypeConversionUtil.erasure(GenericsUtil.eliminateWildcards(resolveResult.getSubstitutor().substitute(methodSignature.getSubstitutor().substitute(methodParameterType)))))) {\n          return false;\n        }\n      }\n    }\n    LOG.assertTrue(psiClass != null);\n    PsiType methodReturnType = getReturnType(psiClass, methodSignature);\n    if (methodReturnType != null) {\n      methodReturnType = resolveResult.getSubstitutor().substitute(methodSignature.getSubstitutor().substitute(methodReturnType));\n      return checkReturnTypeCompatible(lambdaExpression, methodReturnType) == null;\n    }\n    return true;\n  }","commit_id":"b199a1b76ca7608b0e61d728249a9e4d8e62ab6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TypeParamsChecker(PsiLambdaExpression expression) {\n      myClass = PsiUtil.resolveGenericsClassInType(getFunctionalInterfaceType(expression, false)).getElement();\n      PsiElement parent = expression.getParent();\n      while (parent instanceof PsiParenthesizedExpression) {\n        parent = parent.getParent();\n      }\n      if (parent instanceof PsiExpressionList) {\n        final PsiElement gParent = parent.getParent();\n        if (gParent instanceof PsiCallExpression) {\n          myMethod = ((PsiCallExpression)gParent).resolveMethod();\n        }\n      }\n    }","id":88215,"modified_method":"public TypeParamsChecker(PsiLambdaExpression expression) {\n      myClass = PsiUtil.resolveGenericsClassInType(getFunctionalInterfaceType(expression, false)).getElement();\n      PsiElement parent = expression.getParent();\n      while (parent instanceof PsiParenthesizedExpression) {\n        parent = parent.getParent();\n      }\n      if (parent instanceof PsiExpressionList) {\n        final PsiElement gParent = parent.getParent();\n        if (gParent instanceof PsiCallExpression) {\n          myMethod = ((PsiCallExpression)gParent).resolveMethod();\n          if (myMethod != null && PsiTreeUtil.isAncestor(myMethod, expression, false)) {\n            myMethod = null;\n          }\n        }\n      }\n    }","commit_id":"b199a1b76ca7608b0e61d728249a9e4d8e62ab6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Pair<PsiType, ConstraintType> inferTypeForMethodTypeParameterInner(final PsiTypeParameter typeParameter,\n                                                                                    final PsiType[] paramTypes,\n                                                                                    PsiType[] argTypes,\n                                                                                    PsiSubstitutor partialSubstitutor,\n                                                                                    @Nullable PsiElement parent,\n                                                                                    final ParameterTypeInferencePolicy policy) {\n    PsiWildcardType wildcardToCapture = null;\n    PsiType lowerBound = PsiType.NULL;\n    PsiType upperBound = PsiType.NULL;\n    if (paramTypes.length > 0) {\n      sortLambdaExpressionsLast(paramTypes, argTypes);\n      for (int j = 0; j < argTypes.length; j++) {\n        PsiType argumentType = argTypes[j];\n        if (argumentType == null) continue;\n        if (j >= paramTypes.length) break;\n\n        PsiType parameterType = paramTypes[j];\n        if (parameterType == null) break;\n\n        if (parameterType instanceof PsiEllipsisType) {\n          parameterType = ((PsiEllipsisType)parameterType).getComponentType();\n          if (argTypes.length == paramTypes.length && argumentType instanceof PsiArrayType && !(((PsiArrayType)argumentType).getComponentType() instanceof PsiPrimitiveType)) {\n            argumentType = ((PsiArrayType)argumentType).getComponentType();\n          }\n        }\n        final Pair<PsiType,ConstraintType> currentSubstitution;\n        if (argumentType instanceof PsiLambdaExpressionType) {\n          currentSubstitution = inferSubstitutionFromLambda(typeParameter, (PsiLambdaExpressionType)argumentType, lowerBound);\n        } else {\n          currentSubstitution = getSubstitutionForTypeParameterConstraint(typeParameter, parameterType,\n                                                                          argumentType, true, PsiUtil.getLanguageLevel(typeParameter));\n        }\n        if (currentSubstitution == null) continue;\n        if (currentSubstitution == FAILED_INFERENCE) {\n          return getFailedInferenceConstraint(typeParameter);\n        }\n\n        final ConstraintType constraintType = currentSubstitution.getSecond();\n        final PsiType type = currentSubstitution.getFirst();\n        if (type == null) return new Pair<PsiType, ConstraintType>(null, ConstraintType.EQUALS);\n        switch(constraintType) {\n          case EQUALS:\n            if (!(type instanceof PsiWildcardType)) return currentSubstitution;\n            if (wildcardToCapture != null) return getFailedInferenceConstraint(typeParameter);\n            wildcardToCapture = (PsiWildcardType) type;\n            break;\n          case SUPERTYPE:\n            if (PsiType.NULL.equals(lowerBound)) {\n              lowerBound = type;\n            }\n            else if (!lowerBound.equals(type)) {\n              lowerBound = GenericsUtil.getLeastUpperBound(lowerBound, type, typeParameter.getManager());\n              if (lowerBound == null) return getFailedInferenceConstraint(typeParameter);\n            }\n            break;\n          case SUBTYPE:\n            if (PsiType.NULL.equals(upperBound) || TypeConversionUtil.isAssignable(upperBound, type)) {\n              upperBound = type;\n            }\n        }\n      }\n    }\n\n    if (wildcardToCapture != null) {\n      if (lowerBound != PsiType.NULL) {\n        if (!wildcardToCapture.isAssignableFrom(lowerBound)) return getFailedInferenceConstraint(typeParameter);\n        if (wildcardToCapture.isSuper()) {\n          return new Pair<PsiType, ConstraintType>(wildcardToCapture, ConstraintType.SUPERTYPE);\n        }\n        lowerBound = GenericsUtil.getLeastUpperBound(lowerBound, wildcardToCapture, typeParameter.getManager());\n      }\n      else {\n        if (upperBound != PsiType.NULL && !upperBound.isAssignableFrom(wildcardToCapture)) return getFailedInferenceConstraint(typeParameter);\n        return new Pair<PsiType, ConstraintType>(wildcardToCapture, ConstraintType.EQUALS);\n      }\n    }\n\n    if (lowerBound != PsiType.NULL) return new Pair<PsiType, ConstraintType>(lowerBound, ConstraintType.EQUALS);\n\n    if (parent != null) {\n      final Pair<PsiType, ConstraintType> constraint =\n        inferMethodTypeParameterFromParent(typeParameter, partialSubstitutor, parent, policy);\n      if (constraint != null) {\n        if (constraint.getSecond() != ConstraintType.SUBTYPE) {\n          return constraint;\n        }\n\n        if (upperBound != PsiType.NULL) {\n          return new Pair<PsiType, ConstraintType>(upperBound, ConstraintType.SUBTYPE);\n        }\n\n        return constraint;\n      }\n    }\n\n    if (upperBound != PsiType.NULL) return new Pair<PsiType, ConstraintType>(upperBound, ConstraintType.SUBTYPE);\n    return null;\n  }","id":88216,"modified_method":"private static Pair<PsiType, ConstraintType> inferTypeForMethodTypeParameterInner(final PsiTypeParameter typeParameter,\n                                                                                    final PsiType[] paramTypes,\n                                                                                    PsiType[] argTypes,\n                                                                                    PsiSubstitutor partialSubstitutor,\n                                                                                    @Nullable PsiElement parent,\n                                                                                    final ParameterTypeInferencePolicy policy) {\n    PsiWildcardType wildcardToCapture = null;\n    PsiType lowerBound = PsiType.NULL;\n    PsiType upperBound = PsiType.NULL;\n    if (paramTypes.length > 0) {\n      sortLambdaExpressionsLast(paramTypes, argTypes);\n      boolean rawType = false;\n      boolean nullPassed = false;\n      for (int j = 0; j < argTypes.length; j++) {\n        PsiType argumentType = argTypes[j];\n        if (argumentType == null) continue;\n        if (j >= paramTypes.length) break;\n\n        PsiType parameterType = paramTypes[j];\n        if (parameterType == null) break;\n        rawType |= parameterType instanceof PsiClassType && ((PsiClassType)parameterType).isRaw();\n        nullPassed |= argumentType == PsiType.NULL;\n\n        if (parameterType instanceof PsiEllipsisType) {\n          parameterType = ((PsiEllipsisType)parameterType).getComponentType();\n          if (argTypes.length == paramTypes.length && argumentType instanceof PsiArrayType && !(((PsiArrayType)argumentType).getComponentType() instanceof PsiPrimitiveType)) {\n            argumentType = ((PsiArrayType)argumentType).getComponentType();\n          }\n        }\n        final Pair<PsiType,ConstraintType> currentSubstitution;\n        if (argumentType instanceof PsiLambdaExpressionType) {\n          currentSubstitution = inferSubstitutionFromLambda(typeParameter, (PsiLambdaExpressionType)argumentType, lowerBound);\n          if (rawType && currentSubstitution == FAILED_INFERENCE || nullPassed && currentSubstitution == null) return new Pair<PsiType, ConstraintType>(null, ConstraintType.EQUALS);\n        } else {\n          currentSubstitution = getSubstitutionForTypeParameterConstraint(typeParameter, parameterType,\n                                                                          argumentType, true, PsiUtil.getLanguageLevel(typeParameter));\n        }\n        if (currentSubstitution == null) continue;\n        if (currentSubstitution == FAILED_INFERENCE) {\n          return getFailedInferenceConstraint(typeParameter);\n        }\n\n        final ConstraintType constraintType = currentSubstitution.getSecond();\n        final PsiType type = currentSubstitution.getFirst();\n        if (type == null) return new Pair<PsiType, ConstraintType>(null, ConstraintType.EQUALS);\n        switch(constraintType) {\n          case EQUALS:\n            if (!(type instanceof PsiWildcardType)) return currentSubstitution;\n            if (wildcardToCapture != null) return getFailedInferenceConstraint(typeParameter);\n            wildcardToCapture = (PsiWildcardType) type;\n            break;\n          case SUPERTYPE:\n            if (PsiType.NULL.equals(lowerBound)) {\n              lowerBound = type;\n            }\n            else if (!lowerBound.equals(type)) {\n              lowerBound = GenericsUtil.getLeastUpperBound(lowerBound, type, typeParameter.getManager());\n              if (lowerBound == null) return getFailedInferenceConstraint(typeParameter);\n            }\n            break;\n          case SUBTYPE:\n            if (PsiType.NULL.equals(upperBound) || TypeConversionUtil.isAssignable(upperBound, type)) {\n              upperBound = type;\n            }\n        }\n      }\n    }\n\n    if (wildcardToCapture != null) {\n      if (lowerBound != PsiType.NULL) {\n        if (!wildcardToCapture.isAssignableFrom(lowerBound)) return getFailedInferenceConstraint(typeParameter);\n        if (wildcardToCapture.isSuper()) {\n          return new Pair<PsiType, ConstraintType>(wildcardToCapture, ConstraintType.SUPERTYPE);\n        }\n        lowerBound = GenericsUtil.getLeastUpperBound(lowerBound, wildcardToCapture, typeParameter.getManager());\n      }\n      else {\n        if (upperBound != PsiType.NULL && !upperBound.isAssignableFrom(wildcardToCapture)) return getFailedInferenceConstraint(typeParameter);\n        return new Pair<PsiType, ConstraintType>(wildcardToCapture, ConstraintType.EQUALS);\n      }\n    }\n\n    if (lowerBound != PsiType.NULL) return new Pair<PsiType, ConstraintType>(lowerBound, ConstraintType.EQUALS);\n\n    if (parent != null) {\n      final Pair<PsiType, ConstraintType> constraint =\n        inferMethodTypeParameterFromParent(typeParameter, partialSubstitutor, parent, policy);\n      if (constraint != null) {\n        if (constraint.getSecond() != ConstraintType.SUBTYPE) {\n          return constraint;\n        }\n\n        if (upperBound != PsiType.NULL) {\n          return new Pair<PsiType, ConstraintType>(upperBound, ConstraintType.SUBTYPE);\n        }\n\n        return constraint;\n      }\n    }\n\n    if (upperBound != PsiType.NULL) return new Pair<PsiType, ConstraintType>(upperBound, ConstraintType.SUBTYPE);\n    return null;\n  }","commit_id":"b199a1b76ca7608b0e61d728249a9e4d8e62ab6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Pair<PsiType, ConstraintType> inferMethodTypeParameterFromParent(PsiElement parent,\n                                                                                  PsiCallExpression methodCall,\n                                                                                  final PsiTypeParameter typeParameter,\n                                                                                  PsiSubstitutor substitutor,\n                                                                                  ParameterTypeInferencePolicy policy) {\n    Pair<PsiType, ConstraintType> constraint = null;\n    PsiType expectedType = null;\n\n    if (parent instanceof PsiVariable) {\n      if (methodCall.equals(skipParenthesizedExprDown(((PsiVariable)parent).getInitializer()))) {\n        expectedType = ((PsiVariable)parent).getType();\n      }\n    }\n    else if (parent instanceof PsiAssignmentExpression) {\n      if (methodCall.equals(skipParenthesizedExprDown(((PsiAssignmentExpression)parent).getRExpression()))) {\n        expectedType = ((PsiAssignmentExpression)parent).getLExpression().getType();\n      }\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiMethod method = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (method != null) {\n        expectedType = method.getReturnType();\n      }\n    }\n    else if (parent instanceof PsiExpressionList) {\n      final PsiElement pParent = parent.getParent();\n      if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {\n        constraint = policy.inferTypeConstraintFromCallContext(methodCall, (PsiExpressionList)parent, (PsiCallExpression)pParent,\n                                                               typeParameter);\n      }\n    } else if (parent instanceof PsiLambdaExpression) {\n      expectedType = LambdaUtil.getFunctionalInterfaceReturnType(((PsiLambdaExpression)parent).getFunctionalInterfaceType());\n      if (expectedType == null) {\n        return getFailedInferenceConstraint(typeParameter);\n      }\n    }\n\n    final PsiManager manager = typeParameter.getManager();\n    final GlobalSearchScope scope = parent.getResolveScope();\n    PsiType returnType = null;\n    if (constraint == null) {\n      if (expectedType == null) {\n        expectedType = policy.getDefaultExpectedType(methodCall);\n      }\n\n      returnType = ((PsiMethod)typeParameter.getOwner()).getReturnType();\n\n      constraint =\n        getSubstitutionForTypeParameterConstraint(typeParameter, returnType, expectedType, false, PsiUtil.getLanguageLevel(parent));\n\n      if (constraint != null) {\n        PsiType guess = constraint.getFirst();\n        if (guess != null &&\n            !guess.equals(PsiType.NULL) &&\n            constraint.getSecond() == ConstraintType.SUPERTYPE &&\n            guess instanceof PsiIntersectionType) {\n          for (PsiType conjuct : ((PsiIntersectionType)guess).getConjuncts()) {\n            if (!conjuct.isAssignableFrom(expectedType)) {\n              return FAILED_INFERENCE;\n            }\n          }\n        }\n      }\n    }\n\n    final Pair<PsiType, ConstraintType> result;\n    if (constraint == null) {\n\n      final PsiExpressionList argumentList = methodCall.getArgumentList();\n      if (argumentList != null && PsiUtil.getLanguageLevel(argumentList).isAtLeast(LanguageLevel.JDK_1_8)) {\n        for (PsiExpression expression : argumentList.getExpressions()) {\n          if (expression instanceof PsiLambdaExpression) {\n            final PsiType functionalInterfaceType = LambdaUtil.getFunctionalInterfaceType((PsiLambdaExpression)expression, false);\n            if (functionalInterfaceType == null || PsiUtil.resolveClassInType(functionalInterfaceType) == typeParameter){\n              return getFailedInferenceConstraint(typeParameter);\n            }\n            final PsiMethod method = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n            if (method == null || methodParamsDependOnTypeParams((PsiLambdaExpression)expression, method.getParameterList().getParameters(), \n                                                                 PsiUtil.resolveGenericsClassInType(functionalInterfaceType).getSubstitutor(), typeParameter)) {\n              return getFailedInferenceConstraint(typeParameter);\n            }\n          }\n        }\n      }\n\n      final PsiSubstitutor finalSubstitutor = substitutor.put(typeParameter, null);\n      PsiClassType[] superTypes = typeParameter.getSuperTypes();\n      if (superTypes.length == 0) return null;\n      PsiType superType = finalSubstitutor.substitute(superTypes[0]);\n      if (superType == null) superType = PsiType.getJavaLangObject(manager, scope);\n      if (superType == null) return null;\n      return policy.getInferredTypeWithNoConstraint(manager, superType);\n    }\n    else {\n      PsiType guess = constraint.getFirst();\n      guess = policy.adjustInferredType(manager, guess, constraint.getSecond());\n\n      //The following code is the result of deep thought, do not shit it out before discussing with [ven]\n      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {\n        PsiClassType[] extendsTypes = typeParameter.getExtendsListTypes();\n        PsiSubstitutor newSubstitutor = substitutor.put(typeParameter, guess);\n        for (PsiClassType extendsType1 : extendsTypes) {\n          PsiType extendsType = newSubstitutor.substitute(extendsType1);\n          if (guess != null && !extendsType.isAssignableFrom(guess)) {\n            if (guess.isAssignableFrom(extendsType)) {\n              guess = extendsType;\n              newSubstitutor = substitutor.put(typeParameter, guess);\n            }\n            else {\n              break;\n            }\n          }\n        }\n      }\n\n      result = new Pair<PsiType, ConstraintType>(guess, constraint.getSecond());\n    }\n    return result;\n  }","id":88217,"modified_method":"private static Pair<PsiType, ConstraintType> inferMethodTypeParameterFromParent(PsiElement parent,\n                                                                                  PsiCallExpression methodCall,\n                                                                                  final PsiTypeParameter typeParameter,\n                                                                                  PsiSubstitutor substitutor,\n                                                                                  ParameterTypeInferencePolicy policy) {\n    Pair<PsiType, ConstraintType> constraint = null;\n    PsiType expectedType = null;\n\n    if (parent instanceof PsiVariable) {\n      if (methodCall.equals(skipParenthesizedExprDown(((PsiVariable)parent).getInitializer()))) {\n        expectedType = ((PsiVariable)parent).getType();\n      }\n    }\n    else if (parent instanceof PsiAssignmentExpression) {\n      if (methodCall.equals(skipParenthesizedExprDown(((PsiAssignmentExpression)parent).getRExpression()))) {\n        expectedType = ((PsiAssignmentExpression)parent).getLExpression().getType();\n      }\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiMethod method = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (method != null) {\n        expectedType = method.getReturnType();\n      }\n    }\n    else if (parent instanceof PsiExpressionList) {\n      final PsiElement pParent = parent.getParent();\n      if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {\n        constraint = policy.inferTypeConstraintFromCallContext(methodCall, (PsiExpressionList)parent, (PsiCallExpression)pParent,\n                                                               typeParameter);\n      }\n    } else if (parent instanceof PsiLambdaExpression) {\n      expectedType = LambdaUtil.getFunctionalInterfaceReturnType(((PsiLambdaExpression)parent).getFunctionalInterfaceType());\n      if (expectedType == null) {\n        return getFailedInferenceConstraint(typeParameter);\n      }\n    }\n\n    final PsiManager manager = typeParameter.getManager();\n    final GlobalSearchScope scope = parent.getResolveScope();\n    PsiType returnType = null;\n    if (constraint == null) {\n      if (expectedType == null) {\n        expectedType = policy.getDefaultExpectedType(methodCall);\n      }\n\n      returnType = ((PsiMethod)typeParameter.getOwner()).getReturnType();\n\n      constraint =\n        getSubstitutionForTypeParameterConstraint(typeParameter, returnType, expectedType, false, PsiUtil.getLanguageLevel(parent));\n\n      if (constraint != null) {\n        PsiType guess = constraint.getFirst();\n        if (guess != null &&\n            !guess.equals(PsiType.NULL) &&\n            constraint.getSecond() == ConstraintType.SUPERTYPE &&\n            guess instanceof PsiIntersectionType) {\n          for (PsiType conjuct : ((PsiIntersectionType)guess).getConjuncts()) {\n            if (!conjuct.isAssignableFrom(expectedType)) {\n              return FAILED_INFERENCE;\n            }\n          }\n        }\n      }\n    }\n\n    final Pair<PsiType, ConstraintType> result;\n    if (constraint == null) {\n\n      final PsiExpressionList argumentList = methodCall.getArgumentList();\n      if (argumentList != null && PsiUtil.getLanguageLevel(argumentList).isAtLeast(LanguageLevel.JDK_1_8)) {\n        for (PsiExpression expression : argumentList.getExpressions()) {\n          if (expression instanceof PsiLambdaExpression) {\n            final PsiType functionalInterfaceType = LambdaUtil.getFunctionalInterfaceType((PsiLambdaExpression)expression, false);\n            if (functionalInterfaceType == null || PsiUtil.resolveClassInType(functionalInterfaceType) == typeParameter){\n              return getFailedInferenceConstraint(typeParameter);\n            }\n            final PsiMethod method = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n\n            final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n            if (method == null || methodParamsDependOnTypeParams((PsiLambdaExpression)expression, method.getParameterList().getParameters(),\n                                                                 TypeConversionUtil.getSuperClassSubstitutor(method.getContainingClass(), resolveResult.getElement(), resolveResult.getSubstitutor()), typeParameter)) {\n              return getFailedInferenceConstraint(typeParameter);\n            }\n          }\n        }\n      }\n\n      final PsiSubstitutor finalSubstitutor = substitutor.put(typeParameter, null);\n      PsiClassType[] superTypes = typeParameter.getSuperTypes();\n      if (superTypes.length == 0) return null;\n      PsiType superType = finalSubstitutor.substitute(superTypes[0]);\n      if (superType == null) superType = PsiType.getJavaLangObject(manager, scope);\n      if (superType == null) return null;\n      return policy.getInferredTypeWithNoConstraint(manager, superType);\n    }\n    else {\n      PsiType guess = constraint.getFirst();\n      guess = policy.adjustInferredType(manager, guess, constraint.getSecond());\n\n      //The following code is the result of deep thought, do not shit it out before discussing with [ven]\n      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {\n        PsiClassType[] extendsTypes = typeParameter.getExtendsListTypes();\n        PsiSubstitutor newSubstitutor = substitutor.put(typeParameter, guess);\n        for (PsiClassType extendsType1 : extendsTypes) {\n          PsiType extendsType = newSubstitutor.substitute(extendsType1);\n          if (guess != null && !extendsType.isAssignableFrom(guess)) {\n            if (guess.isAssignableFrom(extendsType)) {\n              guess = extendsType;\n              newSubstitutor = substitutor.put(typeParameter, guess);\n            }\n            else {\n              break;\n            }\n          }\n        }\n      }\n\n      result = new Pair<PsiType, ConstraintType>(guess, constraint.getSecond());\n    }\n    return result;\n  }","commit_id":"b199a1b76ca7608b0e61d728249a9e4d8e62ab6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Pair<PsiType, ConstraintType> inferConstraintFromFunctionalInterfaceMethod(PsiTypeParameter typeParam,\n                                                                                            final PsiLambdaExpression lambdaExpression,\n                                                                                            final PsiType functionalInterfaceType,\n                                                                                            PsiType lowerBound) {\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final PsiMethod method = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    if (method != null) {\n      final Pair<PsiType, ConstraintType> constraintFromFormalParams = inferConstraintFromLambdaFormalParams(typeParam, resolveResult, method, lambdaExpression);\n      if (constraintFromFormalParams != null) return constraintFromFormalParams;\n\n      final PsiParameter[] methodParameters = method.getParameterList().getParameters();\n      final PsiSubstitutor subst = resolveResult.getSubstitutor();\n      final boolean methodParamsDependOnTypeParams = methodParamsDependOnTypeParams(lambdaExpression, methodParameters, subst, typeParam);\n      final PsiType returnType = subst.substitute(method.getReturnType());\n      if (returnType != null && returnType != PsiType.VOID) {\n        Pair<PsiType, ConstraintType> constraint = null;\n        final List<PsiExpression> expressions = lambdaExpression.getReturnExpressions();\n        for (final PsiExpression expression : expressions) {\n          final boolean independent = LambdaUtil.isFreeFromTypeInferenceArgs(methodParameters, lambdaExpression, expression);\n          if (independent && methodParamsDependOnTypeParams) return FAILED_INFERENCE;\n          if (!independent) {\n            if (lowerBound != PsiType.NULL) {\n              return null;\n            }\n            continue;\n          }\n          PsiType exprType = expression.getType();\n          if (exprType instanceof PsiLambdaParameterType) {\n            final PsiParameter parameter = ((PsiLambdaParameterType)exprType).getParameter();\n            final int parameterIndex = lambdaExpression.getParameterList().getParameterIndex(parameter);\n            if (parameterIndex > -1) {\n              exprType = subst.substitute(methodParameters[parameterIndex].getType());\n            }\n          } else if (exprType instanceof PsiLambdaExpressionType) {\n            return inferConstraintFromFunctionalInterfaceMethod(typeParam, ((PsiLambdaExpressionType)exprType).getExpression(), returnType,\n                                                                lowerBound);\n          }\n\n          if (exprType == null){\n            return FAILED_INFERENCE;\n          }\n\n          final Pair<PsiType, ConstraintType> returnExprConstraint =\n            getSubstitutionForTypeParameterConstraint(typeParam, returnType, exprType, false, PsiUtil.getLanguageLevel(method));\n          if (returnExprConstraint != null) {\n            if (returnExprConstraint == FAILED_INFERENCE) return returnExprConstraint;\n            if (constraint != null) {\n              final PsiType leastUpperBound = GenericsUtil.getLeastUpperBound(constraint.getFirst(), returnExprConstraint.getFirst(), typeParam.getManager());\n              constraint = new Pair<PsiType, ConstraintType>(leastUpperBound, ConstraintType.SUPERTYPE);\n            } else {\n              constraint = returnExprConstraint;\n            }\n          }\n        }\n        if (constraint != null) return constraint;\n      }\n      if (methodParamsDependOnTypeParams) return getFailedInferenceConstraint(typeParam);\n    }\n    return null;\n  }","id":88218,"modified_method":"@Nullable\n  private static Pair<PsiType, ConstraintType> inferConstraintFromFunctionalInterfaceMethod(PsiTypeParameter typeParam,\n                                                                                            final PsiLambdaExpression lambdaExpression,\n                                                                                            final PsiType functionalInterfaceType,\n                                                                                            PsiType lowerBound) {\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final PsiMethod method = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    if (method != null) {\n      final Pair<PsiType, ConstraintType> constraintFromFormalParams = inferConstraintFromLambdaFormalParams(typeParam, resolveResult, method, lambdaExpression);\n      if (constraintFromFormalParams != null) return constraintFromFormalParams;\n\n      final PsiParameter[] methodParameters = method.getParameterList().getParameters();\n      final PsiSubstitutor subst = \n        TypeConversionUtil.getSuperClassSubstitutor(method.getContainingClass(), resolveResult.getElement(), resolveResult.getSubstitutor());\n      final boolean methodParamsDependOnTypeParams = methodParamsDependOnTypeParams(lambdaExpression, methodParameters, subst, typeParam);\n      final PsiType returnType = subst.substitute(method.getReturnType());\n      if (returnType != null && returnType != PsiType.VOID) {\n        Pair<PsiType, ConstraintType> constraint = null;\n        final List<PsiExpression> expressions = lambdaExpression.getReturnExpressions();\n        for (final PsiExpression expression : expressions) {\n          final boolean independent = LambdaUtil.isFreeFromTypeInferenceArgs(methodParameters, lambdaExpression, expression);\n          if (independent && methodParamsDependOnTypeParams) return FAILED_INFERENCE;\n          if (!independent) {\n            if (lowerBound != PsiType.NULL) {\n              return null;\n            }\n            continue;\n          }\n          PsiType exprType = expression.getType();\n          if (exprType instanceof PsiLambdaParameterType) {\n            final PsiParameter parameter = ((PsiLambdaParameterType)exprType).getParameter();\n            final int parameterIndex = lambdaExpression.getParameterList().getParameterIndex(parameter);\n            if (parameterIndex > -1) {\n              exprType = subst.substitute(methodParameters[parameterIndex].getType());\n            }\n          } else if (exprType instanceof PsiLambdaExpressionType) {\n            return inferConstraintFromFunctionalInterfaceMethod(typeParam, ((PsiLambdaExpressionType)exprType).getExpression(), returnType,\n                                                                lowerBound);\n          }\n\n          if (exprType == null){\n            return FAILED_INFERENCE;\n          }\n\n          final Pair<PsiType, ConstraintType> returnExprConstraint =\n            getSubstitutionForTypeParameterConstraint(typeParam, returnType, exprType, false, PsiUtil.getLanguageLevel(method));\n          if (returnExprConstraint != null) {\n            if (returnExprConstraint == FAILED_INFERENCE) return returnExprConstraint;\n            if (constraint != null) {\n              final PsiType leastUpperBound = GenericsUtil.getLeastUpperBound(constraint.getFirst(), returnExprConstraint.getFirst(), typeParam.getManager());\n              constraint = new Pair<PsiType, ConstraintType>(leastUpperBound, ConstraintType.SUPERTYPE);\n            } else {\n              constraint = returnExprConstraint;\n            }\n          }\n        }\n        if (constraint != null) return constraint;\n      }\n      if (methodParamsDependOnTypeParams) return getFailedInferenceConstraint(typeParam);\n    }\n    return null;\n  }","commit_id":"b199a1b76ca7608b0e61d728249a9e4d8e62ab6b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean hasArtifactId(String groupId, String artifactId) {\n    return hasValue(myData.groupWithArtifactToVersionMap, groupId + \":\" + artifactId);\n  }","id":88219,"modified_method":"public synchronized boolean hasArtifactId(String groupId, String artifactId) {\n    return hasValue(myData.groupWithArtifactToVersionMap, myData.hasArtifactCache, groupId + \":\" + artifactId);\n  }","commit_id":"bd022b2c5da1c990bd689be5eaaf5919277e5573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean hasVersion(final String groupId, final String artifactId, final String version) {\n    return doIndexTask(new IndexTask<Boolean>() {\n      @Override\n      public Boolean doTask() throws Exception {\n        Set<String> set = myData.groupWithArtifactToVersionMap.get(groupId + \":\" + artifactId);\n        return set != null && set.contains(version);\n      }\n    }, false);\n  }","id":88220,"modified_method":"public synchronized boolean hasVersion(String groupId, String artifactId, final String version) {\n    final String groupWithArtifactWithVersion = groupId + \":\" + artifactId + ':' + version;\n\n    Boolean res = myData.hasVersionCache.get(groupWithArtifactWithVersion);\n    if (res == null) {\n      res = doIndexTask(new IndexTask<Boolean>() {\n        @Override\n        public Boolean doTask() throws Exception {\n          String groupWithVersion = groupWithArtifactWithVersion.substring(0, groupWithArtifactWithVersion.length() - version.length() - 1);\n          Set<String> set = myData.groupWithArtifactToVersionMap.get(groupWithVersion);\n          return set != null && set.contains(version);\n        }\n      }, false);\n\n      myData.hasVersionCache.put(groupWithArtifactWithVersion, res);\n    }\n\n    return res;\n  }","commit_id":"bd022b2c5da1c990bd689be5eaaf5919277e5573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean hasGroupId(String groupId) {\n    return hasValue(myData.groupToArtifactMap, groupId);\n  }","id":88221,"modified_method":"public synchronized boolean hasGroupId(String groupId) {\n    return hasValue(myData.groupToArtifactMap, myData.hasGroupCache, groupId);\n  }","commit_id":"bd022b2c5da1c990bd689be5eaaf5919277e5573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addArtifact(final File artifactFile) {\n    doIndexTask(new IndexTask<Object>() {\n      public Object doTask() throws Exception {\n        MavenId id = myData.addArtifact(artifactFile);\n\n        String groupId = id.getGroupId();\n        String artifactId = id.getArtifactId();\n        String version = id.getVersion();\n\n        addToCache(myData.groupToArtifactMap, groupId, artifactId);\n        addToCache(myData.groupWithArtifactToVersionMap, groupId + \":\" + artifactId, version);\n        myData.flush();\n\n        return null;\n      }\n    }, null);\n  }","id":88222,"modified_method":"public synchronized void addArtifact(final File artifactFile) {\n    doIndexTask(new IndexTask<Object>() {\n      public Object doTask() throws Exception {\n        MavenId id = myData.addArtifact(artifactFile);\n\n        String groupId = id.getGroupId();\n        String artifactId = id.getArtifactId();\n        String version = id.getVersion();\n\n        myData.hasGroupCache.put(groupId, true);\n\n        String groupWithArtifact = groupId + \":\" + artifactId;\n\n        myData.hasArtifactCache.put(groupWithArtifact, true);\n        myData.hasVersionCache.put(groupWithArtifact + ':' + version, true);\n\n        addToCache(myData.groupToArtifactMap, groupId, artifactId);\n        addToCache(myData.groupWithArtifactToVersionMap, groupWithArtifact, version);\n        myData.flush();\n\n        return null;\n      }\n    }, null);\n  }","commit_id":"bd022b2c5da1c990bd689be5eaaf5919277e5573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean hasValue(final PersistentHashMap<String, ?> map, final String value) {\n    return doIndexTask(new IndexTask<Boolean>() {\n      public Boolean doTask() throws Exception {\n        return map.tryEnumerate(value) != 0;\n      }\n    }, false).booleanValue();\n  }","id":88223,"modified_method":"private boolean hasValue(final PersistentHashMap<String, ?> map, Map<String, Boolean> cache, final String value) {\n    Boolean res = cache.get(value);\n    if (res == null) {\n      res = doIndexTask(new IndexTask<Boolean>() {\n        public Boolean doTask() throws Exception {\n          return map.tryEnumerate(value) != 0;\n        }\n      }, false).booleanValue();\n\n      cache.put(value, res);\n    }\n\n    return res;\n  }","commit_id":"bd022b2c5da1c990bd689be5eaaf5919277e5573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"boolean setValueAtRow(final int row, final Object newValue) {\n      final Property property=myProperties.get(row);\n\n      // Optimization: do nothing if value doesn't change\n      final Object oldValue=getSelectionValue(property);\n      if(Comparing.equal(oldValue,newValue)){\n        return true;\n      }\n      if (!myEditor.ensureEditable()) {\n        return false;\n      }\n      final Ref<Boolean> result = new Ref<Boolean>(Boolean.FALSE);\n      CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n        public void run() {\n          result.set(setSelectionValue(property, newValue));\n\n          myEditor.refreshAndSave(false);\n        }\n      }, UIDesignerBundle.message(\"command.set.property.value\"), null);\n      return result.get().booleanValue();\n    }","id":88224,"modified_method":"boolean setValueAtRow(final int row, final Object newValue) {\n      final Property property=myProperties.get(row);\n\n      // Optimization: do nothing if value doesn't change\n      final Object oldValue=getSelectionValue(property);\n      boolean retVal = true;\n      if(!Comparing.equal(oldValue,newValue)){\n        if (!myEditor.ensureEditable()) {\n          return false;\n        }\n        final Ref<Boolean> result = new Ref<Boolean>(Boolean.FALSE);\n        CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n          public void run() {\n            result.set(setSelectionValue(property, newValue));\n\n            myEditor.refreshAndSave(false);\n          }\n        }, UIDesignerBundle.message(\"command.set.property.value\"), null);\n\n        retVal = result.get().booleanValue();\n      }\n      if (property.needRefreshPropertyList()) {\n        synchWithTree(true);\n      }\n      return retVal;\n    }","commit_id":"48ecd520c0547d8a234e04da03bbe9782e654331","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\n    props.setLook( shell );\n    setShellImage( shell, input );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        input.setChanged();\n      }\n    };\n\n    changed = input.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"SSHDialog.Shell.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Stepname line\n    wlStepname = new Label( shell, SWT.RIGHT );\n    wlStepname.setText( BaseMessages.getString( PKG, \"SSHDialog.Stepname.Label\" ) );\n    props.setLook( wlStepname );\n    fdlStepname = new FormData();\n    fdlStepname.left = new FormAttachment( 0, 0 );\n    fdlStepname.right = new FormAttachment( middle, -margin );\n    fdlStepname.top = new FormAttachment( 0, margin );\n    wlStepname.setLayoutData( fdlStepname );\n    wStepname = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wStepname.setText( stepname );\n    props.setLook( wStepname );\n    wStepname.addModifyListener( lsMod );\n    fdStepname = new FormData();\n    fdStepname.left = new FormAttachment( middle, 0 );\n    fdStepname.top = new FormAttachment( 0, margin );\n    fdStepname.right = new FormAttachment( 100, 0 );\n    wStepname.setLayoutData( fdStepname );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, PropsUI.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"SSHDialog.General.Tab\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout fileLayout = new FormLayout();\n    fileLayout.marginWidth = 3;\n    fileLayout.marginHeight = 3;\n    wGeneralComp.setLayout( fileLayout );\n\n    // ///////////////////////////////\n    // START OF Settings GROUP //\n    // ///////////////////////////////\n\n    wSettingsGroup = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wSettingsGroup );\n    wSettingsGroup.setText( BaseMessages.getString( PKG, \"SSHDialog.wSettingsGroup.Label\" ) );\n\n    FormLayout settingGroupLayout = new FormLayout();\n    settingGroupLayout.marginWidth = 10;\n    settingGroupLayout.marginHeight = 10;\n    wSettingsGroup.setLayout( settingGroupLayout );\n\n    // Server port line\n    wServerName =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Server.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Server.Tooltip\" ) );\n    props.setLook( wServerName );\n    wServerName.addModifyListener( lsMod );\n    fdServerName = new FormData();\n    fdServerName.left = new FormAttachment( 0, 0 );\n    fdServerName.top = new FormAttachment( wStepname, margin );\n    fdServerName.right = new FormAttachment( 100, 0 );\n    wServerName.setLayoutData( fdServerName );\n\n    // Server port line\n    wPort =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Port.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Port.Tooltip\" ) );\n    props.setLook( wPort );\n    wPort.addModifyListener( lsMod );\n    fdPort = new FormData();\n    fdPort.left = new FormAttachment( 0, 0 );\n    fdPort.top = new FormAttachment( wServerName, margin );\n    fdPort.right = new FormAttachment( 100, 0 );\n    wPort.setLayoutData( fdPort );\n\n    // Server TimeOut line\n    wTimeOut =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.TimeOut.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.TimeOut.Tooltip\" ) );\n    props.setLook( wTimeOut );\n    wTimeOut.addModifyListener( lsMod );\n    fdTimeOut = new FormData();\n    fdTimeOut.left = new FormAttachment( 0, 0 );\n    fdTimeOut.top = new FormAttachment( wPort, margin );\n    fdTimeOut.right = new FormAttachment( 100, 0 );\n    wTimeOut.setLayoutData( fdTimeOut );\n\n    // Usernameline\n    wUserName =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.UserName.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.UserName.Tooltip\" ) );\n    props.setLook( wUserName );\n    wUserName.addModifyListener( lsMod );\n    fdUserName = new FormData();\n    fdUserName.left = new FormAttachment( 0, 0 );\n    fdUserName.top = new FormAttachment( wTimeOut, margin );\n    fdUserName.right = new FormAttachment( 100, 0 );\n    wUserName.setLayoutData( fdUserName );\n\n    // Passwordline\n    wPassword =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Password.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Password.Tooltip\" ) );\n    props.setLook( wPassword );\n    wPassword.addModifyListener( lsMod );\n    fdPassword = new FormData();\n    fdPassword.left = new FormAttachment( 0, 0 );\n    fdPassword.top = new FormAttachment( wUserName, margin );\n    fdPassword.right = new FormAttachment( 100, 0 );\n    wPassword.setLayoutData( fdPassword );\n    wPassword.setEchoChar( '*' );\n\n    // Use key?\n    wlUseKey = new Label( wSettingsGroup, SWT.RIGHT );\n    wlUseKey.setText( BaseMessages.getString( PKG, \"SSHDialog.UseKey.Label\" ) );\n    props.setLook( wlUseKey );\n    fdlUseKey = new FormData();\n    fdlUseKey.left = new FormAttachment( 0, 0 );\n    fdlUseKey.top = new FormAttachment( wPassword, margin );\n    fdlUseKey.right = new FormAttachment( middle, -margin );\n    wlUseKey.setLayoutData( fdlUseKey );\n    wUseKey = new Button( wSettingsGroup, SWT.CHECK );\n    props.setLook( wUseKey );\n    wUseKey.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.UseKey.Tooltip\" ) );\n    fdUseKey = new FormData();\n    fdUseKey.left = new FormAttachment( middle, margin );\n    fdUseKey.top = new FormAttachment( wPassword, margin );\n    fdUseKey.right = new FormAttachment( 100, 0 );\n    wUseKey.setLayoutData( fdUseKey );\n    wUseKey.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        activateKey();\n      }\n    } );\n\n    wbFilename = new Button( wSettingsGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbFilename );\n    wbFilename.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbFilename = new FormData();\n    fdbFilename.right = new FormAttachment( 100, -margin );\n    fdbFilename.top = new FormAttachment( wUseKey, margin );\n    wbFilename.setLayoutData( fdbFilename );\n    wbFilename.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.SAVE );\n        dialog.setFilterExtensions( new String[] { \"*.pem\", \"*\" } );\n        if ( wPrivateKey.getText() != null ) {\n          dialog.setFileName( transMeta.environmentSubstitute( wPrivateKey.getText() ) );\n        }\n        dialog.setFilterNames( new String[] {\n          BaseMessages.getString( PKG, \"System.FileType.PEMFiles\" ),\n          BaseMessages.getString( PKG, \"System.FileType.AllFiles\" ) } );\n        if ( dialog.open() != null ) {\n          wPrivateKey.setText( dialog.getFilterPath()\n            + System.getProperty( \"file.separator\" ) + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Private key\n    wPrivateKey =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.PrivateKey.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.PrivateKey.Tooltip\" ) );\n    props.setLook( wPassword );\n    wPrivateKey.addModifyListener( lsMod );\n    fdPrivateKey = new FormData();\n    fdPrivateKey.left = new FormAttachment( 0, 5 * margin );\n    fdPrivateKey.top = new FormAttachment( wUseKey, margin );\n    fdPrivateKey.right = new FormAttachment( wbFilename, -margin );\n    wPrivateKey.setLayoutData( fdPrivateKey );\n\n    // Passphraseline\n    wPassphrase =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Passphrase.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Passphrase.Tooltip\" ) );\n    props.setLook( wPassphrase );\n    wPassphrase.addModifyListener( lsMod );\n    fdPassphrase = new FormData();\n    fdPassphrase.left = new FormAttachment( 0, 0 );\n    fdPassphrase.top = new FormAttachment( wbFilename, margin );\n    fdPassphrase.right = new FormAttachment( 100, 0 );\n    wPassphrase.setLayoutData( fdPassphrase );\n\n    // ProxyHostline\n    wProxyHost =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyHost.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ProxyHost.Tooltip\" ) );\n    props.setLook( wProxyHost );\n    wProxyHost.addModifyListener( lsMod );\n    fdProxyHost = new FormData();\n    fdProxyHost.left = new FormAttachment( 0, 0 );\n    fdProxyHost.top = new FormAttachment( wPassphrase, 2 * margin );\n    fdProxyHost.right = new FormAttachment( 100, 0 );\n    wProxyHost.setLayoutData( fdProxyHost );\n\n    // ProxyPortline\n    wProxyPort =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyPort.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ProxyPort.Tooltip\" ) );\n    props.setLook( wProxyPort );\n    wProxyPort.addModifyListener( lsMod );\n    fdProxyPort = new FormData();\n    fdProxyPort.left = new FormAttachment( 0, 0 );\n    fdProxyPort.top = new FormAttachment( wProxyHost, margin );\n    fdProxyPort.right = new FormAttachment( 100, 0 );\n    wProxyPort.setLayoutData( fdProxyPort );\n\n    // ProxyUsernameline\n    wProxyUsername =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyUsername.Label\" ),\n        BaseMessages.getString( PKG, \"SSHDialog.ProxyUsername.Tooltip\" ) );\n    props.setLook( wProxyUsername );\n    wProxyUsername.addModifyListener( lsMod );\n    fdProxyUsername = new FormData();\n    fdProxyUsername.left = new FormAttachment( 0, 0 );\n    fdProxyUsername.top = new FormAttachment( wProxyPort, margin );\n    fdProxyUsername.right = new FormAttachment( 100, 0 );\n    wProxyUsername.setLayoutData( fdProxyUsername );\n\n    // ProxyUsernameline\n    wProxyPassword =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyPassword.Label\" ),\n        BaseMessages.getString( PKG, \"SSHDialog.ProxyPassword.Tooltip\" ) );\n    props.setLook( wProxyUsername );\n    wProxyPassword.addModifyListener( lsMod );\n    fdProxyPassword = new FormData();\n    fdProxyPassword.left = new FormAttachment( 0, 0 );\n    fdProxyPassword.top = new FormAttachment( wProxyUsername, margin );\n    fdProxyPassword.right = new FormAttachment( 100, 0 );\n    wProxyPassword.setLayoutData( fdProxyPassword );\n    wProxyPassword.setEchoChar( '*' );\n\n    // Test connection button\n    wTest = new Button( wSettingsGroup, SWT.PUSH );\n    wTest.setText( BaseMessages.getString( PKG, \"SSHDialog.TestConnection.Label\" ) );\n    props.setLook( wTest );\n    fdTest = new FormData();\n    wTest.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.TestConnection.Tooltip\" ) );\n    fdTest.top = new FormAttachment( wProxyPassword, 2 * margin );\n    fdTest.right = new FormAttachment( 100, 0 );\n    wTest.setLayoutData( fdTest );\n\n    fdSettingsGroup = new FormData();\n    fdSettingsGroup.left = new FormAttachment( 0, margin );\n    fdSettingsGroup.top = new FormAttachment( wStepname, margin );\n    fdSettingsGroup.right = new FormAttachment( 100, -margin );\n    wSettingsGroup.setLayoutData( fdSettingsGroup );\n\n    // ///////////////////////////////\n    // END OF Settings Fields GROUP //\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Settings TAB///\n    // /\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"SSHDialog.Settings.Tab\" ) );\n\n    FormLayout SettingsLayout = new FormLayout();\n    SettingsLayout.marginWidth = 3;\n    SettingsLayout.marginHeight = 3;\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n    wSettingsComp.setLayout( SettingsLayout );\n\n    // ///////////////////////////////\n    // START OF Output GROUP //\n    // ///////////////////////////////\n\n    wOutput = new Group( wSettingsComp, SWT.SHADOW_NONE );\n    props.setLook( wOutput );\n    wOutput.setText( BaseMessages.getString( PKG, \"SSHDialog.wOutput.Label\" ) );\n\n    FormLayout outputGroupLayout = new FormLayout();\n    outputGroupLayout.marginWidth = 10;\n    outputGroupLayout.marginHeight = 10;\n    wOutput.setLayout( outputGroupLayout );\n\n    // ResultOutFieldNameline\n    wResultOutFieldName =\n      new LabelTextVar(\n        transMeta, wOutput, BaseMessages.getString( PKG, \"SSHDialog.ResultOutFieldName.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ResultOutFieldName.Tooltip\" ) );\n    props.setLook( wResultOutFieldName );\n    wResultOutFieldName.addModifyListener( lsMod );\n    fdResultOutFieldName = new FormData();\n    fdResultOutFieldName.left = new FormAttachment( 0, 0 );\n    fdResultOutFieldName.top = new FormAttachment( wStepname, margin );\n    fdResultOutFieldName.right = new FormAttachment( 100, 0 );\n    wResultOutFieldName.setLayoutData( fdResultOutFieldName );\n\n    // ResultErrFieldNameline\n    wResultErrFieldName =\n      new LabelTextVar(\n        transMeta, wOutput, BaseMessages.getString( PKG, \"SSHDialog.ResultErrFieldName.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ResultErrFieldName.Tooltip\" ) );\n    props.setLook( wResultErrFieldName );\n    wResultErrFieldName.addModifyListener( lsMod );\n    fdResultErrFieldName = new FormData();\n    fdResultErrFieldName.left = new FormAttachment( 0, 0 );\n    fdResultErrFieldName.top = new FormAttachment( wResultOutFieldName, margin );\n    fdResultErrFieldName.right = new FormAttachment( 100, 0 );\n    wResultErrFieldName.setLayoutData( fdResultErrFieldName );\n\n    fdOutput = new FormData();\n    fdOutput.left = new FormAttachment( 0, margin );\n    fdOutput.top = new FormAttachment( wStepname, margin );\n    fdOutput.right = new FormAttachment( 100, -margin );\n    wOutput.setLayoutData( fdOutput );\n\n    // ///////////////////////////////\n    // END OF Output Fields GROUP //\n\n    // ////////////////////////\n    // START OF Commands SETTINGS GROUP///\n    // /\n    wCommands = new Group( wSettingsComp, SWT.SHADOW_NONE );\n    props.setLook( wCommands );\n    wCommands.setText( BaseMessages.getString( PKG, \"SSHDialog.LogSettings.Group.Label\" ) );\n\n    FormLayout LogSettingsgroupLayout = new FormLayout();\n    LogSettingsgroupLayout.marginWidth = 10;\n    LogSettingsgroupLayout.marginHeight = 10;\n\n    wCommands.setLayout( LogSettingsgroupLayout );\n\n    // Is command defined in a Field\n    wldynamicCommand = new Label( wCommands, SWT.RIGHT );\n    wldynamicCommand.setText( BaseMessages.getString( PKG, \"SSHDialog.dynamicCommand.Label\" ) );\n    props.setLook( wldynamicCommand );\n    fdlynamicBase = new FormData();\n    fdlynamicBase.left = new FormAttachment( 0, margin );\n    fdlynamicBase.top = new FormAttachment( wOutput, margin );\n    fdlynamicBase.right = new FormAttachment( middle, -margin );\n    wldynamicCommand.setLayoutData( fdlynamicBase );\n\n    wdynamicCommand = new Button( wCommands, SWT.CHECK );\n    props.setLook( wdynamicCommand );\n    wdynamicCommand.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.dynamicCommand.Tooltip\" ) );\n    fdynamicCommand = new FormData();\n    fdynamicCommand.left = new FormAttachment( middle, margin );\n    fdynamicCommand.top = new FormAttachment( wOutput, margin );\n    wdynamicCommand.setLayoutData( fdynamicCommand );\n    SelectionAdapter ldynamicCommand = new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        activateDynamicCommand();\n        input.setChanged();\n      }\n    };\n    wdynamicCommand.addSelectionListener( ldynamicCommand );\n\n    // CommandField field\n    wlCommandField = new Label( wCommands, SWT.RIGHT );\n    wlCommandField.setText( BaseMessages.getString( PKG, \"SSHDialog.MessageNameField.Label\" ) );\n    props.setLook( wlCommandField );\n    fdlCommandField = new FormData();\n    fdlCommandField.left = new FormAttachment( 0, margin );\n    fdlCommandField.right = new FormAttachment( middle, -margin );\n    fdlCommandField.top = new FormAttachment( wdynamicCommand, margin );\n    wlCommandField.setLayoutData( fdlCommandField );\n\n    wCommandField = new CCombo( wCommands, SWT.BORDER | SWT.READ_ONLY );\n    props.setLook( wCommandField );\n    wCommandField.setEditable( true );\n    wCommandField.addModifyListener( lsMod );\n    fdCommandField = new FormData();\n    fdCommandField.left = new FormAttachment( middle, margin );\n    fdCommandField.top = new FormAttachment( wdynamicCommand, margin );\n    fdCommandField.right = new FormAttachment( 100, 0 );\n    wCommandField.setLayoutData( fdCommandField );\n    wCommandField.addFocusListener( new FocusListener() {\n      public void focusLost( org.eclipse.swt.events.FocusEvent e ) {\n      }\n\n      public void focusGained( org.eclipse.swt.events.FocusEvent e ) {\n        get();\n      }\n    } );\n\n    // Command String\n    wlCommand = new Label( wCommands, SWT.RIGHT );\n    wlCommand.setText( BaseMessages.getString( PKG, \"SSHDialog.Command.Label\" ) );\n    props.setLook( wlCommand );\n    fdlCommand = new FormData();\n    fdlCommand.left = new FormAttachment( 0, margin );\n    fdlCommand.top = new FormAttachment( wCommandField, margin );\n    fdlCommand.right = new FormAttachment( middle, -2 * margin );\n    wlCommand.setLayoutData( fdlCommand );\n\n    wCommand =\n      new StyledTextComp(\n        transMeta, wCommands, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\" );\n    wCommand.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.Command.Tooltip\" ) );\n    props.setLook( wCommand );\n    wCommand.addModifyListener( lsMod );\n    fdCommand = new FormData();\n    fdCommand.left = new FormAttachment( middle, margin );\n    fdCommand.top = new FormAttachment( wCommandField, margin );\n    fdCommand.right = new FormAttachment( 100, -2 * margin );\n    fdCommand.bottom = new FormAttachment( 100, -margin );\n    wCommand.setLayoutData( fdCommand );\n\n    fdLogSettings = new FormData();\n    fdLogSettings.left = new FormAttachment( 0, margin );\n    fdLogSettings.top = new FormAttachment( wOutput, margin );\n    fdLogSettings.right = new FormAttachment( 100, -margin );\n    fdLogSettings.bottom = new FormAttachment( 100, -margin );\n    wCommands.setLayoutData( fdLogSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Log SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Settings TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wStepname, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    // THE BUTTONS\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wPreview = new Button( shell, SWT.PUSH );\n    wPreview.setText( BaseMessages.getString( PKG, \"SSHDialog.Button.PreviewRows\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    setButtonPositions( new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n    lsPreview = new Listener() {\n      public void handleEvent( Event e ) {\n        preview();\n      }\n    };\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsTest = new Listener() {\n      public void handleEvent( Event e ) {\n        test();\n      }\n    };\n\n    wOK.addListener( SWT.Selection, lsOK );\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wPreview.addListener( SWT.Selection, lsPreview );\n    wTest.addListener( SWT.Selection, lsTest );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wStepname.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n    wTabFolder.setSelection( 0 );\n    // Set the shell size, based upon previous time...\n    setSize();\n    getData();\n    activateKey();\n    activateDynamicCommand();\n    input.setChanged( changed );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return stepname;\n  }","id":88225,"modified_method":"public String open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\n    props.setLook( shell );\n    setShellImage( shell, input );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        input.setChanged();\n      }\n    };\n\n    changed = input.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"SSHDialog.Shell.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Stepname line\n    wlStepname = new Label( shell, SWT.RIGHT );\n    wlStepname.setText( BaseMessages.getString( PKG, \"SSHDialog.Stepname.Label\" ) );\n    props.setLook( wlStepname );\n    fdlStepname = new FormData();\n    fdlStepname.left = new FormAttachment( 0, 0 );\n    fdlStepname.right = new FormAttachment( middle, -margin );\n    fdlStepname.top = new FormAttachment( 0, margin );\n    wlStepname.setLayoutData( fdlStepname );\n    wStepname = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wStepname.setText( stepname );\n    props.setLook( wStepname );\n    wStepname.addModifyListener( lsMod );\n    fdStepname = new FormData();\n    fdStepname.left = new FormAttachment( middle, 0 );\n    fdStepname.top = new FormAttachment( 0, margin );\n    fdStepname.right = new FormAttachment( 100, 0 );\n    wStepname.setLayoutData( fdStepname );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, PropsUI.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"SSHDialog.General.Tab\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout fileLayout = new FormLayout();\n    fileLayout.marginWidth = 3;\n    fileLayout.marginHeight = 3;\n    wGeneralComp.setLayout( fileLayout );\n\n    // ///////////////////////////////\n    // START OF Settings GROUP //\n    // ///////////////////////////////\n\n    wSettingsGroup = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wSettingsGroup );\n    wSettingsGroup.setText( BaseMessages.getString( PKG, \"SSHDialog.wSettingsGroup.Label\" ) );\n\n    FormLayout settingGroupLayout = new FormLayout();\n    settingGroupLayout.marginWidth = 10;\n    settingGroupLayout.marginHeight = 10;\n    wSettingsGroup.setLayout( settingGroupLayout );\n\n    // Server port line\n    wServerName =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Server.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Server.Tooltip\" ) );\n    props.setLook( wServerName );\n    wServerName.addModifyListener( lsMod );\n    fdServerName = new FormData();\n    fdServerName.left = new FormAttachment( 0, 0 );\n    fdServerName.top = new FormAttachment( wStepname, margin );\n    fdServerName.right = new FormAttachment( 100, 0 );\n    wServerName.setLayoutData( fdServerName );\n\n    // Server port line\n    wPort =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Port.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Port.Tooltip\" ) );\n    props.setLook( wPort );\n    wPort.addModifyListener( lsMod );\n    fdPort = new FormData();\n    fdPort.left = new FormAttachment( 0, 0 );\n    fdPort.top = new FormAttachment( wServerName, margin );\n    fdPort.right = new FormAttachment( 100, 0 );\n    wPort.setLayoutData( fdPort );\n\n    // Server TimeOut line\n    wTimeOut =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.TimeOut.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.TimeOut.Tooltip\" ) );\n    props.setLook( wTimeOut );\n    wTimeOut.addModifyListener( lsMod );\n    fdTimeOut = new FormData();\n    fdTimeOut.left = new FormAttachment( 0, 0 );\n    fdTimeOut.top = new FormAttachment( wPort, margin );\n    fdTimeOut.right = new FormAttachment( 100, 0 );\n    wTimeOut.setLayoutData( fdTimeOut );\n\n    // Usernameline\n    wUserName =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.UserName.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.UserName.Tooltip\" ) );\n    props.setLook( wUserName );\n    wUserName.addModifyListener( lsMod );\n    fdUserName = new FormData();\n    fdUserName.left = new FormAttachment( 0, 0 );\n    fdUserName.top = new FormAttachment( wTimeOut, margin );\n    fdUserName.right = new FormAttachment( 100, 0 );\n    wUserName.setLayoutData( fdUserName );\n\n    // Passwordline\n    wPassword =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Password.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Password.Tooltip\" ) );\n    props.setLook( wPassword );\n    wPassword.addModifyListener( lsMod );\n    fdPassword = new FormData();\n    fdPassword.left = new FormAttachment( 0, 0 );\n    fdPassword.top = new FormAttachment( wUserName, margin );\n    fdPassword.right = new FormAttachment( 100, 0 );\n    wPassword.setLayoutData( fdPassword );\n    wPassword.setEchoChar( '*' );\n\n    // Use key?\n    wlUseKey = new Label( wSettingsGroup, SWT.RIGHT );\n    wlUseKey.setText( BaseMessages.getString( PKG, \"SSHDialog.UseKey.Label\" ) );\n    props.setLook( wlUseKey );\n    fdlUseKey = new FormData();\n    fdlUseKey.left = new FormAttachment( 0, 0 );\n    fdlUseKey.top = new FormAttachment( wPassword, margin );\n    fdlUseKey.right = new FormAttachment( middle, -margin );\n    wlUseKey.setLayoutData( fdlUseKey );\n    wUseKey = new Button( wSettingsGroup, SWT.CHECK );\n    props.setLook( wUseKey );\n    wUseKey.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.UseKey.Tooltip\" ) );\n    fdUseKey = new FormData();\n    fdUseKey.left = new FormAttachment( middle, margin );\n    fdUseKey.top = new FormAttachment( wPassword, margin );\n    fdUseKey.right = new FormAttachment( 100, 0 );\n    wUseKey.setLayoutData( fdUseKey );\n    wUseKey.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        activateKey();\n      }\n    } );\n\n    wbFilename = new Button( wSettingsGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbFilename );\n    wbFilename.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbFilename = new FormData();\n    fdbFilename.right = new FormAttachment( 100, -margin );\n    fdbFilename.top = new FormAttachment( wUseKey, margin );\n    wbFilename.setLayoutData( fdbFilename );\n    wbFilename.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.SAVE );\n        dialog.setFilterExtensions( new String[] { \"*.pem\", \"*\" } );\n        if ( wPrivateKey.getText() != null ) {\n          dialog.setFileName( transMeta.environmentSubstitute( wPrivateKey.getText() ) );\n        }\n        dialog.setFilterNames( new String[] {\n          BaseMessages.getString( PKG, \"System.FileType.PEMFiles\" ),\n          BaseMessages.getString( PKG, \"System.FileType.AllFiles\" ) } );\n        if ( dialog.open() != null ) {\n          wPrivateKey.setText( dialog.getFilterPath()\n            + System.getProperty( \"file.separator\" ) + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Private key\n    wPrivateKey =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.PrivateKey.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.PrivateKey.Tooltip\" ) );\n    props.setLook( wPassword );\n    wPrivateKey.addModifyListener( lsMod );\n    fdPrivateKey = new FormData();\n    fdPrivateKey.left = new FormAttachment( 0, 5 * margin );\n    fdPrivateKey.top = new FormAttachment( wUseKey, margin );\n    fdPrivateKey.right = new FormAttachment( wbFilename, -margin );\n    wPrivateKey.setLayoutData( fdPrivateKey );\n\n    // Passphraseline\n    wPassphrase =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.Passphrase.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.Passphrase.Tooltip\" ) );\n    props.setLook( wPassphrase );\n    wPassphrase.addModifyListener( lsMod );\n    fdPassphrase = new FormData();\n    fdPassphrase.left = new FormAttachment( 0, 0 );\n    fdPassphrase.top = new FormAttachment( wbFilename, margin );\n    fdPassphrase.right = new FormAttachment( 100, 0 );\n    wPassphrase.setLayoutData( fdPassphrase );\n    wPassphrase.setEchoChar( '*' );\n\n    // ProxyHostline\n    wProxyHost =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyHost.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ProxyHost.Tooltip\" ) );\n    props.setLook( wProxyHost );\n    wProxyHost.addModifyListener( lsMod );\n    fdProxyHost = new FormData();\n    fdProxyHost.left = new FormAttachment( 0, 0 );\n    fdProxyHost.top = new FormAttachment( wPassphrase, 2 * margin );\n    fdProxyHost.right = new FormAttachment( 100, 0 );\n    wProxyHost.setLayoutData( fdProxyHost );\n\n    // ProxyPortline\n    wProxyPort =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyPort.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ProxyPort.Tooltip\" ) );\n    props.setLook( wProxyPort );\n    wProxyPort.addModifyListener( lsMod );\n    fdProxyPort = new FormData();\n    fdProxyPort.left = new FormAttachment( 0, 0 );\n    fdProxyPort.top = new FormAttachment( wProxyHost, margin );\n    fdProxyPort.right = new FormAttachment( 100, 0 );\n    wProxyPort.setLayoutData( fdProxyPort );\n\n    // ProxyUsernameline\n    wProxyUsername =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyUsername.Label\" ),\n        BaseMessages.getString( PKG, \"SSHDialog.ProxyUsername.Tooltip\" ) );\n    props.setLook( wProxyUsername );\n    wProxyUsername.addModifyListener( lsMod );\n    fdProxyUsername = new FormData();\n    fdProxyUsername.left = new FormAttachment( 0, 0 );\n    fdProxyUsername.top = new FormAttachment( wProxyPort, margin );\n    fdProxyUsername.right = new FormAttachment( 100, 0 );\n    wProxyUsername.setLayoutData( fdProxyUsername );\n\n    // ProxyUsernameline\n    wProxyPassword =\n      new LabelTextVar(\n        transMeta, wSettingsGroup, BaseMessages.getString( PKG, \"SSHDialog.ProxyPassword.Label\" ),\n        BaseMessages.getString( PKG, \"SSHDialog.ProxyPassword.Tooltip\" ) );\n    props.setLook( wProxyUsername );\n    wProxyPassword.addModifyListener( lsMod );\n    fdProxyPassword = new FormData();\n    fdProxyPassword.left = new FormAttachment( 0, 0 );\n    fdProxyPassword.top = new FormAttachment( wProxyUsername, margin );\n    fdProxyPassword.right = new FormAttachment( 100, 0 );\n    wProxyPassword.setLayoutData( fdProxyPassword );\n    wProxyPassword.setEchoChar( '*' );\n\n    // Test connection button\n    wTest = new Button( wSettingsGroup, SWT.PUSH );\n    wTest.setText( BaseMessages.getString( PKG, \"SSHDialog.TestConnection.Label\" ) );\n    props.setLook( wTest );\n    fdTest = new FormData();\n    wTest.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.TestConnection.Tooltip\" ) );\n    fdTest.top = new FormAttachment( wProxyPassword, 2 * margin );\n    fdTest.right = new FormAttachment( 100, 0 );\n    wTest.setLayoutData( fdTest );\n\n    fdSettingsGroup = new FormData();\n    fdSettingsGroup.left = new FormAttachment( 0, margin );\n    fdSettingsGroup.top = new FormAttachment( wStepname, margin );\n    fdSettingsGroup.right = new FormAttachment( 100, -margin );\n    wSettingsGroup.setLayoutData( fdSettingsGroup );\n\n    // ///////////////////////////////\n    // END OF Settings Fields GROUP //\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////\n    // START OF Settings TAB///\n    // /\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"SSHDialog.Settings.Tab\" ) );\n\n    FormLayout SettingsLayout = new FormLayout();\n    SettingsLayout.marginWidth = 3;\n    SettingsLayout.marginHeight = 3;\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n    wSettingsComp.setLayout( SettingsLayout );\n\n    // ///////////////////////////////\n    // START OF Output GROUP //\n    // ///////////////////////////////\n\n    wOutput = new Group( wSettingsComp, SWT.SHADOW_NONE );\n    props.setLook( wOutput );\n    wOutput.setText( BaseMessages.getString( PKG, \"SSHDialog.wOutput.Label\" ) );\n\n    FormLayout outputGroupLayout = new FormLayout();\n    outputGroupLayout.marginWidth = 10;\n    outputGroupLayout.marginHeight = 10;\n    wOutput.setLayout( outputGroupLayout );\n\n    // ResultOutFieldNameline\n    wResultOutFieldName =\n      new LabelTextVar(\n        transMeta, wOutput, BaseMessages.getString( PKG, \"SSHDialog.ResultOutFieldName.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ResultOutFieldName.Tooltip\" ) );\n    props.setLook( wResultOutFieldName );\n    wResultOutFieldName.addModifyListener( lsMod );\n    fdResultOutFieldName = new FormData();\n    fdResultOutFieldName.left = new FormAttachment( 0, 0 );\n    fdResultOutFieldName.top = new FormAttachment( wStepname, margin );\n    fdResultOutFieldName.right = new FormAttachment( 100, 0 );\n    wResultOutFieldName.setLayoutData( fdResultOutFieldName );\n\n    // ResultErrFieldNameline\n    wResultErrFieldName =\n      new LabelTextVar(\n        transMeta, wOutput, BaseMessages.getString( PKG, \"SSHDialog.ResultErrFieldName.Label\" ), BaseMessages\n          .getString( PKG, \"SSHDialog.ResultErrFieldName.Tooltip\" ) );\n    props.setLook( wResultErrFieldName );\n    wResultErrFieldName.addModifyListener( lsMod );\n    fdResultErrFieldName = new FormData();\n    fdResultErrFieldName.left = new FormAttachment( 0, 0 );\n    fdResultErrFieldName.top = new FormAttachment( wResultOutFieldName, margin );\n    fdResultErrFieldName.right = new FormAttachment( 100, 0 );\n    wResultErrFieldName.setLayoutData( fdResultErrFieldName );\n\n    fdOutput = new FormData();\n    fdOutput.left = new FormAttachment( 0, margin );\n    fdOutput.top = new FormAttachment( wStepname, margin );\n    fdOutput.right = new FormAttachment( 100, -margin );\n    wOutput.setLayoutData( fdOutput );\n\n    // ///////////////////////////////\n    // END OF Output Fields GROUP //\n\n    // ////////////////////////\n    // START OF Commands SETTINGS GROUP///\n    // /\n    wCommands = new Group( wSettingsComp, SWT.SHADOW_NONE );\n    props.setLook( wCommands );\n    wCommands.setText( BaseMessages.getString( PKG, \"SSHDialog.LogSettings.Group.Label\" ) );\n\n    FormLayout LogSettingsgroupLayout = new FormLayout();\n    LogSettingsgroupLayout.marginWidth = 10;\n    LogSettingsgroupLayout.marginHeight = 10;\n\n    wCommands.setLayout( LogSettingsgroupLayout );\n\n    // Is command defined in a Field\n    wldynamicCommand = new Label( wCommands, SWT.RIGHT );\n    wldynamicCommand.setText( BaseMessages.getString( PKG, \"SSHDialog.dynamicCommand.Label\" ) );\n    props.setLook( wldynamicCommand );\n    fdlynamicBase = new FormData();\n    fdlynamicBase.left = new FormAttachment( 0, margin );\n    fdlynamicBase.top = new FormAttachment( wOutput, margin );\n    fdlynamicBase.right = new FormAttachment( middle, -margin );\n    wldynamicCommand.setLayoutData( fdlynamicBase );\n\n    wdynamicCommand = new Button( wCommands, SWT.CHECK );\n    props.setLook( wdynamicCommand );\n    wdynamicCommand.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.dynamicCommand.Tooltip\" ) );\n    fdynamicCommand = new FormData();\n    fdynamicCommand.left = new FormAttachment( middle, margin );\n    fdynamicCommand.top = new FormAttachment( wOutput, margin );\n    wdynamicCommand.setLayoutData( fdynamicCommand );\n    SelectionAdapter ldynamicCommand = new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        activateDynamicCommand();\n        input.setChanged();\n      }\n    };\n    wdynamicCommand.addSelectionListener( ldynamicCommand );\n\n    // CommandField field\n    wlCommandField = new Label( wCommands, SWT.RIGHT );\n    wlCommandField.setText( BaseMessages.getString( PKG, \"SSHDialog.MessageNameField.Label\" ) );\n    props.setLook( wlCommandField );\n    fdlCommandField = new FormData();\n    fdlCommandField.left = new FormAttachment( 0, margin );\n    fdlCommandField.right = new FormAttachment( middle, -margin );\n    fdlCommandField.top = new FormAttachment( wdynamicCommand, margin );\n    wlCommandField.setLayoutData( fdlCommandField );\n\n    wCommandField = new CCombo( wCommands, SWT.BORDER | SWT.READ_ONLY );\n    props.setLook( wCommandField );\n    wCommandField.setEditable( true );\n    wCommandField.addModifyListener( lsMod );\n    fdCommandField = new FormData();\n    fdCommandField.left = new FormAttachment( middle, margin );\n    fdCommandField.top = new FormAttachment( wdynamicCommand, margin );\n    fdCommandField.right = new FormAttachment( 100, 0 );\n    wCommandField.setLayoutData( fdCommandField );\n    wCommandField.addFocusListener( new FocusListener() {\n      public void focusLost( org.eclipse.swt.events.FocusEvent e ) {\n      }\n\n      public void focusGained( org.eclipse.swt.events.FocusEvent e ) {\n        get();\n      }\n    } );\n\n    // Command String\n    wlCommand = new Label( wCommands, SWT.RIGHT );\n    wlCommand.setText( BaseMessages.getString( PKG, \"SSHDialog.Command.Label\" ) );\n    props.setLook( wlCommand );\n    fdlCommand = new FormData();\n    fdlCommand.left = new FormAttachment( 0, margin );\n    fdlCommand.top = new FormAttachment( wCommandField, margin );\n    fdlCommand.right = new FormAttachment( middle, -2 * margin );\n    wlCommand.setLayoutData( fdlCommand );\n\n    wCommand =\n      new StyledTextComp(\n        transMeta, wCommands, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\" );\n    wCommand.setToolTipText( BaseMessages.getString( PKG, \"SSHDialog.Command.Tooltip\" ) );\n    props.setLook( wCommand );\n    wCommand.addModifyListener( lsMod );\n    fdCommand = new FormData();\n    fdCommand.left = new FormAttachment( middle, margin );\n    fdCommand.top = new FormAttachment( wCommandField, margin );\n    fdCommand.right = new FormAttachment( 100, -2 * margin );\n    fdCommand.bottom = new FormAttachment( 100, -margin );\n    wCommand.setLayoutData( fdCommand );\n\n    fdLogSettings = new FormData();\n    fdLogSettings.left = new FormAttachment( 0, margin );\n    fdLogSettings.top = new FormAttachment( wOutput, margin );\n    fdLogSettings.right = new FormAttachment( 100, -margin );\n    fdLogSettings.bottom = new FormAttachment( 100, -margin );\n    wCommands.setLayoutData( fdLogSettings );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Log SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF Settings TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wStepname, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    // THE BUTTONS\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wPreview = new Button( shell, SWT.PUSH );\n    wPreview.setText( BaseMessages.getString( PKG, \"SSHDialog.Button.PreviewRows\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    setButtonPositions( new Button[] { wOK, wPreview, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n    lsPreview = new Listener() {\n      public void handleEvent( Event e ) {\n        preview();\n      }\n    };\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsTest = new Listener() {\n      public void handleEvent( Event e ) {\n        test();\n      }\n    };\n\n    wOK.addListener( SWT.Selection, lsOK );\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wPreview.addListener( SWT.Selection, lsPreview );\n    wTest.addListener( SWT.Selection, lsTest );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wStepname.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n    wTabFolder.setSelection( 0 );\n    // Set the shell size, based upon previous time...\n    setSize();\n    getData();\n    activateKey();\n    activateDynamicCommand();\n    input.setChanged( changed );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return stepname;\n  }","commit_id":"04cbe648e048aa4ebd7b4c0408e0ec8c98eea2fe","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() {\n    StringBuffer retval = new StringBuffer();\n\n    retval.append( \"    \" + XMLHandler.addTagValue( \"dynamicCommandField\", dynamicCommandField ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"command\", command ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"commandfieldname\", commandfieldname ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"port\", port ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"servername\", serverName ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"userName\", userName ) );\n    retval.append( \"    \" ).append(\n      XMLHandler.addTagValue( \"password\", Encr.encryptPasswordIfNotUsingVariables( password ) ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"usePrivateKey\", usePrivateKey ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"keyFileName\", keyFileName ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"passPhrase\", passPhrase ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"stdOutFieldName\", stdOutFieldName ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"stdErrFieldName\", stdErrFieldName ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"timeOut\", timeOut ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"proxyHost\", proxyHost ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"proxyPort\", proxyPort ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"proxyUsername\", proxyUsername ) );\n    retval.append( \"    \" ).append(\n      XMLHandler.addTagValue( \"proxyPassword\", Encr.encryptPasswordIfNotUsingVariables( proxyPassword ) ) );\n    return retval.toString();\n  }","id":88226,"modified_method":"public String getXML() {\n    StringBuffer retval = new StringBuffer();\n\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"dynamicCommandField\", dynamicCommandField ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"command\", command ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"commandfieldname\", commandfieldname ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"port\", port ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"servername\", serverName ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"userName\", userName ) );\n    retval.append( \"    \" ).append(\n      XMLHandler.addTagValue( \"password\", Encr.encryptPasswordIfNotUsingVariables( password ) ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"usePrivateKey\", usePrivateKey ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"keyFileName\", keyFileName ) );\n    retval.append( \"    \" ).append(\n      XMLHandler.addTagValue( \"passPhrase\", Encr.encryptPasswordIfNotUsingVariables( passPhrase ) ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"stdOutFieldName\", stdOutFieldName ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"stdErrFieldName\", stdErrFieldName ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"timeOut\", timeOut ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"proxyHost\", proxyHost ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"proxyPort\", proxyPort ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"proxyUsername\", proxyUsername ) );\n    retval.append( \"    \" ).append(\n      XMLHandler.addTagValue( \"proxyPassword\", Encr.encryptPasswordIfNotUsingVariables( proxyPassword ) ) );\n    return retval.toString();\n  }","commit_id":"04cbe648e048aa4ebd7b4c0408e0ec8c98eea2fe","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n\n    try {\n      dynamicCommandField = rep.getStepAttributeBoolean( id_step, \"dynamicCommandField\" );\n      command = rep.getStepAttributeString( id_step, \"command\" );\n      commandfieldname = rep.getStepAttributeString( id_step, \"commandfieldname\" );\n      serverName = rep.getStepAttributeString( id_step, \"servername\" );\n      port = rep.getStepAttributeString( id_step, \"port\" );\n      userName = rep.getStepAttributeString( id_step, \"userName\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString( id_step, \"password\" ) );\n\n      usePrivateKey = rep.getStepAttributeBoolean( id_step, \"usePrivateKey\" );\n      keyFileName = rep.getStepAttributeString( id_step, \"keyFileName\" );\n      passPhrase = rep.getStepAttributeString( id_step, \"passPhrase\" );\n      stdOutFieldName = rep.getStepAttributeString( id_step, \"stdOutFieldName\" );\n      stdErrFieldName = rep.getStepAttributeString( id_step, \"stdErrFieldName\" );\n      timeOut = rep.getStepAttributeString( id_step, \"timeOut\" );\n      proxyHost = rep.getStepAttributeString( id_step, \"proxyHost\" );\n      proxyPort = rep.getStepAttributeString( id_step, \"proxyPort\" );\n      proxyUsername = rep.getStepAttributeString( id_step, \"proxyUsername\" );\n      proxyPassword =\n        Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString( id_step, \"proxyPassword\" ) );\n\n    } catch ( Exception e ) {\n      throw new KettleException(\n        BaseMessages.getString( PKG, \"SSHMeta.Exception.UnexpectedErrorReadingStepInfo\" ), e );\n    }\n  }","id":88227,"modified_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n\n    try {\n      dynamicCommandField = rep.getStepAttributeBoolean( id_step, \"dynamicCommandField\" );\n      command = rep.getStepAttributeString( id_step, \"command\" );\n      commandfieldname = rep.getStepAttributeString( id_step, \"commandfieldname\" );\n      serverName = rep.getStepAttributeString( id_step, \"servername\" );\n      port = rep.getStepAttributeString( id_step, \"port\" );\n      userName = rep.getStepAttributeString( id_step, \"userName\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString( id_step, \"password\" ) );\n\n      usePrivateKey = rep.getStepAttributeBoolean( id_step, \"usePrivateKey\" );\n      keyFileName = rep.getStepAttributeString( id_step, \"keyFileName\" );\n      passPhrase =\n        Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString( id_step, \"passPhrase\" ) );\n      stdOutFieldName = rep.getStepAttributeString( id_step, \"stdOutFieldName\" );\n      stdErrFieldName = rep.getStepAttributeString( id_step, \"stdErrFieldName\" );\n      timeOut = rep.getStepAttributeString( id_step, \"timeOut\" );\n      proxyHost = rep.getStepAttributeString( id_step, \"proxyHost\" );\n      proxyPort = rep.getStepAttributeString( id_step, \"proxyPort\" );\n      proxyUsername = rep.getStepAttributeString( id_step, \"proxyUsername\" );\n      proxyPassword =\n        Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString( id_step, \"proxyPassword\" ) );\n\n    } catch ( Exception e ) {\n      throw new KettleException(\n        BaseMessages.getString( PKG, \"SSHMeta.Exception.UnexpectedErrorReadingStepInfo\" ), e );\n    }\n  }","commit_id":"04cbe648e048aa4ebd7b4c0408e0ec8c98eea2fe","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData( Node stepnode ) throws KettleXMLException {\n    try {\n      dynamicCommandField = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"dynamicCommandField\" ) );\n      command = XMLHandler.getTagValue( stepnode, \"command\" );\n      commandfieldname = XMLHandler.getTagValue( stepnode, \"commandfieldname\" );\n      port = XMLHandler.getTagValue( stepnode, \"port\" );\n      serverName = XMLHandler.getTagValue( stepnode, \"servername\" );\n      userName = XMLHandler.getTagValue( stepnode, \"userName\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( stepnode, \"password\" ) );\n\n      usePrivateKey = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"usePrivateKey\" ) );\n      keyFileName = XMLHandler.getTagValue( stepnode, \"keyFileName\" );\n      passPhrase = XMLHandler.getTagValue( stepnode, \"passPhrase\" );\n      stdOutFieldName = XMLHandler.getTagValue( stepnode, \"stdOutFieldName\" );\n      stdErrFieldName = XMLHandler.getTagValue( stepnode, \"stdErrFieldName\" );\n      timeOut = XMLHandler.getTagValue( stepnode, \"timeOut\" );\n      proxyHost = XMLHandler.getTagValue( stepnode, \"proxyHost\" );\n      proxyPort = XMLHandler.getTagValue( stepnode, \"proxyPort\" );\n      proxyUsername = XMLHandler.getTagValue( stepnode, \"proxyUsername\" );\n      proxyPassword =\n        Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( stepnode, \"proxyPassword\" ) );\n\n    } catch ( Exception e ) {\n      throw new KettleXMLException( BaseMessages.getString( PKG, \"SSHMeta.Exception.UnableToReadStepInfo\" ), e );\n    }\n  }","id":88228,"modified_method":"private void readData( Node stepnode ) throws KettleXMLException {\n    try {\n      dynamicCommandField = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"dynamicCommandField\" ) );\n      command = XMLHandler.getTagValue( stepnode, \"command\" );\n      commandfieldname = XMLHandler.getTagValue( stepnode, \"commandfieldname\" );\n      port = XMLHandler.getTagValue( stepnode, \"port\" );\n      serverName = XMLHandler.getTagValue( stepnode, \"servername\" );\n      userName = XMLHandler.getTagValue( stepnode, \"userName\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( stepnode, \"password\" ) );\n\n      usePrivateKey = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue( stepnode, \"usePrivateKey\" ) );\n      keyFileName = XMLHandler.getTagValue( stepnode, \"keyFileName\" );\n      passPhrase =\n        Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( stepnode, \"passPhrase\" ) );\n      stdOutFieldName = XMLHandler.getTagValue( stepnode, \"stdOutFieldName\" );\n      stdErrFieldName = XMLHandler.getTagValue( stepnode, \"stdErrFieldName\" );\n      timeOut = XMLHandler.getTagValue( stepnode, \"timeOut\" );\n      proxyHost = XMLHandler.getTagValue( stepnode, \"proxyHost\" );\n      proxyPort = XMLHandler.getTagValue( stepnode, \"proxyPort\" );\n      proxyUsername = XMLHandler.getTagValue( stepnode, \"proxyUsername\" );\n      proxyPassword =\n        Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( stepnode, \"proxyPassword\" ) );\n\n    } catch ( Exception e ) {\n      throw new KettleXMLException( BaseMessages.getString( PKG, \"SSHMeta.Exception.UnableToReadStepInfo\" ), e );\n    }\n  }","commit_id":"04cbe648e048aa4ebd7b4c0408e0ec8c98eea2fe","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step ) throws KettleException {\n    try {\n      rep.saveStepAttribute( id_transformation, id_step, \"dynamicCommandField\", dynamicCommandField );\n      rep.saveStepAttribute( id_transformation, id_step, \"command\", command );\n      rep.saveStepAttribute( id_transformation, id_step, \"commandfieldname\", commandfieldname );\n      rep.saveStepAttribute( id_transformation, id_step, \"port\", port );\n      rep.saveStepAttribute( id_transformation, id_step, \"servername\", serverName );\n      rep.saveStepAttribute( id_transformation, id_step, \"userName\", userName );\n      rep.saveStepAttribute( id_transformation, id_step, \"password\", Encr\n        .encryptPasswordIfNotUsingVariables( password ) );\n\n      rep.saveStepAttribute( id_transformation, id_step, \"usePrivateKey\", usePrivateKey );\n      rep.saveStepAttribute( id_transformation, id_step, \"keyFileName\", keyFileName );\n      rep.saveStepAttribute( id_transformation, id_step, \"passPhrase\", passPhrase );\n      rep.saveStepAttribute( id_transformation, id_step, \"stdOutFieldName\", stdOutFieldName );\n      rep.saveStepAttribute( id_transformation, id_step, \"stdErrFieldName\", stdErrFieldName );\n      rep.saveStepAttribute( id_transformation, id_step, \"timeOut\", timeOut );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyHost\", proxyHost );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyPort\", proxyPort );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyUsername\", proxyUsername );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyPassword\", Encr\n        .encryptPasswordIfNotUsingVariables( proxyPassword ) );\n\n    } catch ( Exception e ) {\n      throw new KettleException(\n        BaseMessages.getString( PKG, \"SSHMeta.Exception.UnableToSaveStepInfo\" ) + id_step, e );\n    }\n  }","id":88229,"modified_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step ) throws KettleException {\n    try {\n      rep.saveStepAttribute( id_transformation, id_step, \"dynamicCommandField\", dynamicCommandField );\n      rep.saveStepAttribute( id_transformation, id_step, \"command\", command );\n      rep.saveStepAttribute( id_transformation, id_step, \"commandfieldname\", commandfieldname );\n      rep.saveStepAttribute( id_transformation, id_step, \"port\", port );\n      rep.saveStepAttribute( id_transformation, id_step, \"servername\", serverName );\n      rep.saveStepAttribute( id_transformation, id_step, \"userName\", userName );\n      rep.saveStepAttribute( id_transformation, id_step, \"password\", Encr\n        .encryptPasswordIfNotUsingVariables( password ) );\n\n      rep.saveStepAttribute( id_transformation, id_step, \"usePrivateKey\", usePrivateKey );\n      rep.saveStepAttribute( id_transformation, id_step, \"keyFileName\", keyFileName );\n      rep.saveStepAttribute( id_transformation, id_step, \"passPhrase\", Encr\n        .encryptPasswordIfNotUsingVariables( passPhrase ) );\n      rep.saveStepAttribute( id_transformation, id_step, \"stdOutFieldName\", stdOutFieldName );\n      rep.saveStepAttribute( id_transformation, id_step, \"stdErrFieldName\", stdErrFieldName );\n      rep.saveStepAttribute( id_transformation, id_step, \"timeOut\", timeOut );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyHost\", proxyHost );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyPort\", proxyPort );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyUsername\", proxyUsername );\n      rep.saveStepAttribute( id_transformation, id_step, \"proxyPassword\", Encr\n        .encryptPasswordIfNotUsingVariables( proxyPassword ) );\n\n    } catch ( Exception e ) {\n      throw new KettleException(\n        BaseMessages.getString( PKG, \"SSHMeta.Exception.UnableToSaveStepInfo\" ) + id_step, e );\n    }\n  }","commit_id":"04cbe648e048aa4ebd7b4c0408e0ec8c98eea2fe","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData( Node stepnode, List<? extends SharedObjectInterface> databases ) throws KettleXMLException {\n    try {\n      olap4jUrl = XMLHandler.getTagValue( stepnode, \"url\" );\n      username = XMLHandler.getTagValue( stepnode, \"username\" );\n      password = XMLHandler.getTagValue( stepnode, \"password\" );\n      catalog = XMLHandler.getTagValue( stepnode, \"catalog\" );\n      mdx = XMLHandler.getTagValue( stepnode, \"mdx\" );\n\n      variableReplacementActive = \"Y\".equals( XMLHandler.getTagValue( stepnode, \"variables_active\" ) );\n    } catch ( Exception e ) {\n      throw new KettleXMLException( \"Unable to load step info from XML\", e );\n    }\n  }","id":88230,"modified_method":"private void readData( Node stepnode, List<? extends SharedObjectInterface> databases ) throws KettleXMLException {\n    try {\n      olap4jUrl = XMLHandler.getTagValue( stepnode, \"url\" );\n      username = XMLHandler.getTagValue( stepnode, \"username\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( XMLHandler.getTagValue( stepnode, \"password\" ) );\n      catalog = XMLHandler.getTagValue( stepnode, \"catalog\" );\n      mdx = XMLHandler.getTagValue( stepnode, \"mdx\" );\n\n      variableReplacementActive = \"Y\".equals( XMLHandler.getTagValue( stepnode, \"variables_active\" ) );\n    } catch ( Exception e ) {\n      throw new KettleXMLException( \"Unable to load step info from XML\", e );\n    }\n  }","commit_id":"47efe16f2b4e5a1746c89e97e8c59992108b0cd1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() {\n    StringBuffer retval = new StringBuffer();\n\n    retval.append( \"    \" + XMLHandler.addTagValue( \"url\", olap4jUrl ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"username\", username ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"password\", password ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"mdx\", mdx ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"catalog\", catalog ) );\n    retval.append( \"    \" + XMLHandler.addTagValue( \"variables_active\", variableReplacementActive ) );\n\n    return retval.toString();\n  }","id":88231,"modified_method":"public String getXML() {\n    StringBuffer retval = new StringBuffer();\n\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"url\", olap4jUrl ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"username\", username ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"password\",\n      Encr.encryptPasswordIfNotUsingVariables( password ) ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"mdx\", mdx ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"catalog\", catalog ) );\n    retval.append( \"    \" ).append( XMLHandler.addTagValue( \"variables_active\", variableReplacementActive ) );\n\n    return retval.toString();\n  }","commit_id":"47efe16f2b4e5a1746c89e97e8c59992108b0cd1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step ) throws KettleException {\n    try {\n\n      rep.saveStepAttribute( id_transformation, id_step, \"url\", olap4jUrl );\n      rep.saveStepAttribute( id_transformation, id_step, \"username\", username );\n      rep.saveStepAttribute( id_transformation, id_step, \"password\", password );\n      rep.saveStepAttribute( id_transformation, id_step, \"catalog\", catalog );\n      rep.saveStepAttribute( id_transformation, id_step, \"mdx\", mdx );\n      rep.saveStepAttribute( id_transformation, id_step, \"variables_active\", variableReplacementActive );\n\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unable to save step information to the repository for id_step=\" + id_step, e );\n    }\n  }","id":88232,"modified_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step ) throws KettleException {\n    try {\n\n      rep.saveStepAttribute( id_transformation, id_step, \"url\", olap4jUrl );\n      rep.saveStepAttribute( id_transformation, id_step, \"username\", username );\n      rep.saveStepAttribute( id_transformation, id_step, \"password\",\n        Encr.encryptPasswordIfNotUsingVariables( password ) );\n      rep.saveStepAttribute( id_transformation, id_step, \"catalog\", catalog );\n      rep.saveStepAttribute( id_transformation, id_step, \"mdx\", mdx );\n      rep.saveStepAttribute( id_transformation, id_step, \"variables_active\", variableReplacementActive );\n\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unable to save step information to the repository for id_step=\" + id_step, e );\n    }\n  }","commit_id":"47efe16f2b4e5a1746c89e97e8c59992108b0cd1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n    try {\n      olap4jUrl = rep.getStepAttributeString( id_step, \"url\" );\n      username = rep.getStepAttributeString( id_step, \"username\" );\n      password = rep.getStepAttributeString( id_step, \"password\" );\n      mdx = rep.getStepAttributeString( id_step, \"mdx\" );\n      catalog = rep.getStepAttributeString( id_step, \"catalog\" );\n      variableReplacementActive = rep.getStepAttributeBoolean( id_step, \"variables_active\" );\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unexpected error reading step information from the repository\", e );\n    }\n  }","id":88233,"modified_method":"public void readRep( Repository rep, IMetaStore metaStore, ObjectId id_step, List<DatabaseMeta> databases ) throws KettleException {\n    try {\n      olap4jUrl = rep.getStepAttributeString( id_step, \"url\" );\n      username = rep.getStepAttributeString( id_step, \"username\" );\n      password = Encr.decryptPasswordOptionallyEncrypted( rep.getStepAttributeString( id_step, \"password\" ) );\n      mdx = rep.getStepAttributeString( id_step, \"mdx\" );\n      catalog = rep.getStepAttributeString( id_step, \"catalog\" );\n      variableReplacementActive = rep.getStepAttributeBoolean( id_step, \"variables_active\" );\n    } catch ( Exception e ) {\n      throw new KettleException( \"Unexpected error reading step information from the repository\", e );\n    }\n  }","commit_id":"47efe16f2b4e5a1746c89e97e8c59992108b0cd1","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private static void addTempForDoubleInitialization(PsiField field, @NonNls StringBuilder buffer) {\n    buffer.append(\" = \");\n    buffer.append(field.getName());\n    buffer.append(\" != +0.0d ? Double.doubleToLongBits(\");\n    buffer.append(field.getName());\n    buffer.append(\") : 0L;\\n\");\n  }","id":88234,"modified_method":"private static void addTempForDoubleInitialization(PsiField field, @NonNls StringBuilder buffer) {\n    buffer.append(\" = \");\n    buffer.append(\"Double.doubleToLongBits(\");\n    buffer.append(field.getName());\n    buffer.append(\");\\n\");\n  }","commit_id":"b3eb62d36ef956def4a7cb211705f19e7a5b6159","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n        final long temp = d != +0.0d ? Double.doubleToLongBits(d) : 0L;\n        return (int) (temp ^ (temp >>> 32));\n    }","id":88235,"modified_method":"public int hashCode() {\n        final long temp = Double.doubleToLongBits(d);\n        return (int) (temp ^ (temp >>> 32));\n    }","commit_id":"b3eb62d36ef956def4a7cb211705f19e7a5b6159","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n        int result;\n        long temp;\n        result = i;\n        result = 31 * result + a.hashCode();\n        result = 31 * result + (b != null ? b.hashCode() : 0);\n        temp = c != +0.0d ? Double.doubleToLongBits(c) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }","id":88236,"modified_method":"public int hashCode() {\n        int result;\n        long temp;\n        result = i;\n        result = 31 * result + a.hashCode();\n        result = 31 * result + (b != null ? b.hashCode() : 0);\n        temp = Double.doubleToLongBits(c);\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }","commit_id":"b3eb62d36ef956def4a7cb211705f19e7a5b6159","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setShowContextAssistant(boolean showContextAssistant) {\n    myState.myShowContextAssistant = showContextAssistant;\n  }","id":88237,"modified_method":"public void setShowContextAssistant(boolean showContextAssistant) {\n    myState.showContextAssistant = showContextAssistant;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setUseBraces(boolean newUseBraces) {\n    myState.myUseBraces = newUseBraces;\n  }","id":88238,"modified_method":"public void setUseBraces(boolean newUseBraces) {\n    myState.useBraces = newUseBraces;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setUseAntialiasing(boolean useAntialiasing) {\n    myState.myUseAntialiasing = useAntialiasing;\n  }","id":88239,"modified_method":"public void setUseAntialiasing(boolean useAntialiasing) {\n    myState.useAntialiasing = useAntialiasing;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isUseAntialiasing() {\n    return myState.myUseAntialiasing;\n  }","id":88240,"modified_method":"public boolean isUseAntialiasing() {\n    return myState.useAntialiasing;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setIndentSize(int indentSize) {\n    myState.myIndentSize = indentSize;\n  }","id":88241,"modified_method":"public void setIndentSize(int indentSize) {\n    myState.indentSize = indentSize;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean useBraces() {\n    return myState.myUseBraces;\n  }","id":88242,"modified_method":"public boolean useBraces() {\n    return myState.useBraces;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int getIndentSize() {\n    return myState.myIndentSize;\n  }","id":88243,"modified_method":"public int getIndentSize() {\n    return myState.indentSize;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void registerUIListener(UISettings uiSettings) {\n    uiSettings.addUISettingsListener(new UISettingsListener() {\n      @Override\n      public void uiSettingsChanged(UISettings source) {\n        if (myPresentationMode == source.PRESENTATION_MODE && myPresentationModeFontSize == source.PRESENTATION_MODE_FONT_SIZE) {\n          return;\n        }\n        myPresentationMode = source.PRESENTATION_MODE;\n        myPresentationModeFontSize = source.PRESENTATION_MODE_FONT_SIZE;\n        updateCachedValue();\n        fireEditorSettingsChanged();\n      }\n    }, ApplicationManager.getApplication());\n  }","id":88244,"modified_method":"private void registerUIListener(UISettings uiSettings) {\n    uiSettings.addUISettingsListener(source -> {\n      if (myPresentationMode == source.PRESENTATION_MODE && myPresentationModeFontSize == source.PRESENTATION_MODE_FONT_SIZE) {\n        return;\n      }\n      myPresentationMode = source.PRESENTATION_MODE;\n      myPresentationModeFontSize = source.PRESENTATION_MODE_FONT_SIZE;\n      updateCachedValue();\n      fireEditorSettingsChanged();\n    }, ApplicationManager.getApplication());\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public double getLineSpacing() {\n    return myState.myLineSpacing;\n  }","id":88245,"modified_method":"public double getLineSpacing() {\n    return myState.lineSpacing;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Font getDefaultEditorFont() {\n    if (myDefaultEditorFont == null) {\n      myDefaultEditorFont = FontRegistry.getInstance().getFont(myState.myFontFamily, 0, getFontSize());\n    }\n    return myDefaultEditorFont;\n  }","id":88246,"modified_method":"public Font getDefaultEditorFont() {\n    if (myDefaultEditorFont == null) {\n      myDefaultEditorFont = FontRegistry.getInstance().getFont(myState.fontFamily, 0, getFontSize());\n    }\n    return myDefaultEditorFont;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isShowContextAssistant() {\n    return myState.myShowContextAssistant;\n  }","id":88247,"modified_method":"public boolean isShowContextAssistant() {\n    return myState.showContextAssistant;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getFontFamily() {\n    return myState.myFontFamily;\n  }","id":88248,"modified_method":"public String getFontFamily() {\n    return myState.fontFamily;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int getCaretBlinkPeriod() {\n    return myState.myCaretBlinkPeriod;\n  }","id":88249,"modified_method":"public int getCaretBlinkPeriod() {\n    return myState.caretBlinkPeriod;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int getFontSize() {\n    return myPresentationMode ? myPresentationModeFontSize : myState.myFontSize;\n  }","id":88250,"modified_method":"public int getFontSize() {\n    return myPresentationMode ? myPresentationModeFontSize : myState.fontSize;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public int hashCode() {\n      int result;\n      long temp;\n      result = myFontFamily != null ? myFontFamily.hashCode() : 0;\n      result = 31 * result + myFontSize;\n      temp = myLineSpacing != +0.0d ? Double.doubleToLongBits(myLineSpacing) : 0L;\n      result = 31 * result + (int) (temp ^ (temp >>> 32));\n      result = 31 * result + myTextWidth;\n      result = 31 * result + myIndentSize;\n      result = 31 * result + myVerticalBound;\n      result = 31 * result + (myAutoQuickFix ? 1 : 0);\n      result = 31 * result + (myUseAntialiasing ? 1 : 0);\n      result = 31 * result + (myUseBraces ? 1 : 0);\n      result = 31 * result + (myShowContextAssistant ? 1 : 0);\n      result = 31 * result + myCaretBlinkPeriod;\n      return result;\n    }","id":88251,"modified_method":"@Override\n    public int hashCode() {\n      int result;\n      long temp;\n      result = fontFamily != null ? fontFamily.hashCode() : 0;\n      result = 31 * result + fontSize;\n      temp = Double.doubleToLongBits(lineSpacing);\n      result = 31 * result + (int) (temp ^ (temp >>> 32));\n      result = 31 * result + textWidth;\n      result = 31 * result + (useAntialiasing ? 1 : 0);\n      result = 31 * result + (useBraces ? 1 : 0);\n      result = 31 * result + indentSize;\n      result = 31 * result + verticalBound;\n      result = 31 * result + (autoQuickFix ? 1 : 0);\n      result = 31 * result + (showPlain ? 1 : 0);\n      result = 31 * result + (showGrayed ? 1 : 0);\n      result = 31 * result + (show ? 1 : 0);\n      result = 31 * result + (showContextAssistant ? 1 : 0);\n      result = 31 * result + caretBlinkPeriod;\n      return result;\n    }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setDefaultEditorFont(Font newFont) {\n    myState.myFontFamily = newFont.getFamily();\n    myState.myFontSize = newFont.getSize();\n  }","id":88252,"modified_method":"public void setDefaultEditorFont(Font newFont) {\n    myState.fontFamily = newFont.getFamily();\n    myState.fontSize = newFont.getSize();\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setAutoQuickFix(boolean autoQuickFix) {\n    myState.myAutoQuickFix = autoQuickFix;\n  }","id":88253,"modified_method":"public void setAutoQuickFix(boolean autoQuickFix) {\n    myState.autoQuickFix = autoQuickFix;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      MyState otherState = (MyState) o;\n\n      if (myFontSize != otherState.myFontSize) {\n        return false;\n      }\n      if (Double.compare(otherState.myLineSpacing, myLineSpacing) != 0) {\n        return false;\n      }\n      if (myTextWidth != otherState.myTextWidth) {\n        return false;\n      }\n      if (myUseAntialiasing != otherState.myUseAntialiasing) {\n        return false;\n      }\n      if (myUseBraces != otherState.myUseBraces) {\n        return false;\n      }\n      if (myFontFamily != null ? !myFontFamily.equals(otherState.myFontFamily) : otherState.myFontFamily != null) {\n        return false;\n      }\n      if (myIndentSize != otherState.myIndentSize) {\n        return false;\n      }\n      if (myVerticalBound != otherState.myVerticalBound) {\n        return false;\n      }\n      if (myAutoQuickFix != otherState.myAutoQuickFix) {\n        return false;\n      }\n      if (myShowContextAssistant != otherState.myShowContextAssistant) {\n        return false;\n      }\n      if (myCaretBlinkPeriod != otherState.myCaretBlinkPeriod) {\n        return false;\n      }\n\n      return true;\n    }","id":88254,"modified_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n\n      MyState myState = (MyState) o;\n\n      if (fontSize != myState.fontSize) {\n        return false;\n      }\n      if (Double.compare(myState.lineSpacing, lineSpacing) != 0) {\n        return false;\n      }\n      if (textWidth != myState.textWidth) {\n        return false;\n      }\n      if (useAntialiasing != myState.useAntialiasing) {\n        return false;\n      }\n      if (useBraces != myState.useBraces) {\n        return false;\n      }\n      if (indentSize != myState.indentSize) {\n        return false;\n      }\n      if (verticalBound != myState.verticalBound) {\n        return false;\n      }\n      if (autoQuickFix != myState.autoQuickFix) {\n        return false;\n      }\n      if (showPlain != myState.showPlain) {\n        return false;\n      }\n      if (showGrayed != myState.showGrayed) {\n        return false;\n      }\n      if (show != myState.show) {\n        return false;\n      }\n      if (showContextAssistant != myState.showContextAssistant) {\n        return false;\n      }\n      if (caretBlinkPeriod != myState.caretBlinkPeriod) {\n        return false;\n      }\n      return fontFamily != null ? fontFamily.equals(myState.fontFamily) : myState.fontFamily == null;\n    }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isAutoQuickFix() {\n    return myState.myAutoQuickFix;\n  }","id":88255,"modified_method":"public boolean isAutoQuickFix() {\n    return myState.autoQuickFix;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int getVerticalBound() {\n    return myState.myVerticalBound;\n  }","id":88256,"modified_method":"public int getVerticalBound() {\n    return myState.verticalBound;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"void fireEditorSettingsChanged() {\n    for (EditorSettingsListener l : new ArrayList<EditorSettingsListener>(myListeners)) {\n      try {\n        l.settingsChanged();\n      } catch (Throwable t) {\n        LOG.error(null, t);\n      }\n    }\n  }","id":88257,"modified_method":"void fireEditorSettingsChanged() {\n    for (EditorSettingsListener l : new ArrayList<>(myListeners)) {\n      try {\n        l.settingsChanged();\n      } catch (Throwable t) {\n        LOG.error(null, t);\n      }\n    }\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setCaretBlinkPeriod(int rate) {\n    myState.myCaretBlinkPeriod = rate;\n  }","id":88258,"modified_method":"public void setCaretBlinkPeriod(int rate) {\n    myState.caretBlinkPeriod = rate;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setVerticalBound(int verticalBound) {\n    myState.myVerticalBound = verticalBound;\n  }","id":88259,"modified_method":"public void setVerticalBound(int verticalBound) {\n    myState.verticalBound = verticalBound;\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void commit() {\n    String fontName = myFontsComboBox.getFontName();\n    int fontSize = mySettings.getState().getFontSize();\n    try {\n      fontSize = Integer.parseInt(myFontSizesComboBox.getSelectedItem().toString());\n    } catch (NumberFormatException e) {\n      // ignore wrong formatted value and reset combo box\n      myFontSizesComboBox.setSelectedItem(Integer.toString(fontSize));\n    }\n\n    Font newFont = new Font(fontName, Font.PLAIN, fontSize);\n    mySettings.setDefaultEditorFont(newFont);\n\n    mySettings.setVerticalBound((Integer) myRightMargin.getModel().getValue());\n\n    mySettings.setIndentSize((Integer) myIndentSize.getModel().getValue());\n\n    mySettings.setCaretBlinkPeriod((Integer) myCaretBlinkPeriod.getModel().getValue());\n\n    mySettings.setUseAntialiasing(myAntialiasingCheckBox.isSelected());\n    mySettings.setUseBraces(myUseBraces.isSelected());\n    mySettings.setShowContextAssistant(myShowContextAssistant.isSelected());\n\n    mySettings.setPowerSaveMode(myPowerSaveModeCheckBox.isSelected());\n    mySettings.setAutoQuickFix(myAutoQuickFixCheckBox.isSelected());\n\n    mySettings.getState().setLineSpacing((Double) myLineSpacing.getModel().getValue());\n\n    mySettings.getState().setShow(myTabPerAspect.isSelected() || myTabPerNode.isSelected() || myAllTabs.isSelected());\n    mySettings.getState().setShowPlain(myTabPerNode.isSelected() || myAllTabs.isSelected());\n    mySettings.getState().setShowGrayed(myAllTabs.isSelected());\n    applyState();\n\n    mySettings.updateCachedValue();\n    mySettings.updateGlobalScheme();\n    mySettings.fireEditorSettingsChanged();\n  }","id":88260,"modified_method":"public void commit() {\n    String fontName = myFontsComboBox.getFontName();\n    int fontSize = mySettings.getSpecifiedFontSize();\n    try {\n      fontSize = Integer.parseInt(myFontSizesComboBox.getSelectedItem().toString());\n    } catch (NumberFormatException e) {\n      // ignore wrong formatted value and reset combo box\n      myFontSizesComboBox.setSelectedItem(Integer.toString(fontSize));\n    }\n\n    Font newFont = new Font(fontName, Font.PLAIN, fontSize);\n    mySettings.setDefaultEditorFont(newFont);\n\n    mySettings.setVerticalBound((Integer) myRightMargin.getModel().getValue());\n\n    mySettings.setIndentSize((Integer) myIndentSize.getModel().getValue());\n\n    mySettings.setCaretBlinkPeriod((Integer) myCaretBlinkPeriod.getModel().getValue());\n\n    mySettings.setUseAntialiasing(myAntialiasingCheckBox.isSelected());\n    mySettings.setUseBraces(myUseBraces.isSelected());\n    mySettings.setShowContextAssistant(myShowContextAssistant.isSelected());\n\n    mySettings.setPowerSaveMode(myPowerSaveModeCheckBox.isSelected());\n    mySettings.setAutoQuickFix(myAutoQuickFixCheckBox.isSelected());\n\n    mySettings.setLineSpacing((Double) myLineSpacing.getModel().getValue());\n\n    mySettings.setShow(myTabPerAspect.isSelected() || myTabPerNode.isSelected() || myAllTabs.isSelected());\n    mySettings.setShowPlain(myTabPerNode.isSelected() || myAllTabs.isSelected());\n    mySettings.setShowGrayed(myAllTabs.isSelected());\n    applyState();\n\n    mySettings.updateCachedValue();\n    mySettings.updateGlobalScheme();\n    mySettings.fireEditorSettingsChanged();\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void reset() {\n    myRightMargin.setValue(mySettings.getVerticalBound());\n\n    myIndentSize.setValue(mySettings.getIndentSize());\n\n    myAntialiasingCheckBox.setSelected(mySettings.isUseAntialiasing());\n\n    myUseBraces.setSelected(mySettings.useBraces());\n\n    myPowerSaveModeCheckBox.setSelected(mySettings.isPowerSaveMode());\n\n    myAutoQuickFixCheckBox.setSelected(mySettings.isAutoQuickFix());\n\n    myShowContextAssistant.setSelected(mySettings.isShowContextAssistant());\n\n    myFontSizesComboBox.setSelectedItem(Integer.toString(mySettings.getState().getFontSize()));\n\n    myFontsComboBox.setFontName(mySettings.getState().getFontFamily());\n\n    myLineSpacing.setValue(mySettings.getState().getLineSpacing());\n\n    myCaretBlinkPeriod.setValue(mySettings.getCaretBlinkPeriod());\n\n    applyState();\n    myFirstSelection.setSelected(true);\n  }","id":88261,"modified_method":"public void reset() {\n    myRightMargin.setValue(mySettings.getVerticalBound());\n\n    myIndentSize.setValue(mySettings.getIndentSize());\n\n    myAntialiasingCheckBox.setSelected(mySettings.isUseAntialiasing());\n\n    myUseBraces.setSelected(mySettings.useBraces());\n\n    myPowerSaveModeCheckBox.setSelected(mySettings.isPowerSaveMode());\n\n    myAutoQuickFixCheckBox.setSelected(mySettings.isAutoQuickFix());\n\n    myShowContextAssistant.setSelected(mySettings.isShowContextAssistant());\n\n    myFontSizesComboBox.setSelectedItem(Integer.toString(mySettings.getSpecifiedFontSize()));\n\n    myFontsComboBox.setFontName(mySettings.getFontFamily());\n\n    myLineSpacing.setValue(mySettings.getLineSpacing());\n\n    myCaretBlinkPeriod.setValue(mySettings.getCaretBlinkPeriod());\n\n    applyState();\n    myFirstSelection.setSelected(true);\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void applyState() {\n    if (!mySettings.getState().isShow()) {\n      myFirstSelection = myDontShow;\n    } else if (!mySettings.getState().isShowPlain()) {\n      myFirstSelection = myTabPerAspect;\n    } else if (!mySettings.getState().isShowGrayed()) {\n      myFirstSelection = myTabPerNode;\n    } else {\n      myFirstSelection = myAllTabs;\n    }\n  }","id":88262,"modified_method":"private void applyState() {\n    if (!mySettings.isShow()) {\n      myFirstSelection = myDontShow;\n    } else if (!mySettings.isShowPlain()) {\n      myFirstSelection = myTabPerAspect;\n    } else if (!mySettings.isShowGrayed()) {\n      myFirstSelection = myTabPerNode;\n    } else {\n      myFirstSelection = myAllTabs;\n    }\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isModified() {\n    boolean sameTextWidth = myRightMargin.getModel().getValue().equals(mySettings.getVerticalBound());\n    boolean sameIndentSize = myIndentSize.getModel().getValue().equals(mySettings.getIndentSize());\n    boolean sameAntialiasing = myAntialiasingCheckBox.isSelected() == mySettings.isUseAntialiasing();\n    boolean sameUseBraces = myUseBraces.isSelected() == mySettings.useBraces();\n    boolean samePowerSaveMode = myPowerSaveModeCheckBox.isSelected() == mySettings.isPowerSaveMode();\n    boolean sameAutoQuickFix = myAutoQuickFixCheckBox.isSelected() == mySettings.isAutoQuickFix();\n    boolean sameFontSize = myFontSizesComboBox.getSelectedItem().equals(Integer.toString(mySettings.getState().getFontSize()));\n    boolean sameFontFamily = myFontsComboBox.getFontName().equals(mySettings.getState().getFontFamily());\n    boolean sameLineSpacing = myLineSpacing.getModel().getValue().equals(mySettings.getState().getLineSpacing());\n    boolean sameBlinkingRate = myCaretBlinkPeriod.getModel().getValue().equals(mySettings.getCaretBlinkPeriod());\n    boolean sameTabs = myFirstSelection.isSelected();\n    boolean sameUseContextAssistant = myShowContextAssistant.isSelected() == mySettings.isShowContextAssistant();\n\n    return !(sameTextWidth && sameIndentSize && sameAntialiasing && sameUseBraces && samePowerSaveMode\n        && sameAutoQuickFix && sameFontSize && sameFontFamily && sameLineSpacing && sameBlinkingRate && sameTabs && sameUseContextAssistant);\n  }","id":88263,"modified_method":"public boolean isModified() {\n    boolean sameTextWidth = myRightMargin.getModel().getValue().equals(mySettings.getVerticalBound());\n    boolean sameIndentSize = myIndentSize.getModel().getValue().equals(mySettings.getIndentSize());\n    boolean sameAntialiasing = myAntialiasingCheckBox.isSelected() == mySettings.isUseAntialiasing();\n    boolean sameUseBraces = myUseBraces.isSelected() == mySettings.useBraces();\n    boolean samePowerSaveMode = myPowerSaveModeCheckBox.isSelected() == mySettings.isPowerSaveMode();\n    boolean sameAutoQuickFix = myAutoQuickFixCheckBox.isSelected() == mySettings.isAutoQuickFix();\n    boolean sameFontSize = myFontSizesComboBox.getSelectedItem().equals(Integer.toString(mySettings.getSpecifiedFontSize()));\n    boolean sameFontFamily = myFontsComboBox.getFontName().equals(mySettings.getFontFamily());\n    boolean sameLineSpacing = myLineSpacing.getModel().getValue().equals(mySettings.getLineSpacing());\n    boolean sameBlinkingRate = myCaretBlinkPeriod.getModel().getValue().equals(mySettings.getCaretBlinkPeriod());\n    boolean sameTabs = myFirstSelection.isSelected();\n    boolean sameUseContextAssistant = myShowContextAssistant.isSelected() == mySettings.isShowContextAssistant();\n\n    return !(sameTextWidth && sameIndentSize && sameAntialiasing && sameUseBraces && samePowerSaveMode\n        && sameAutoQuickFix && sameFontSize && sameFontFamily && sameLineSpacing && sameBlinkingRate && sameTabs && sameUseContextAssistant);\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static TabsComponent createTabsComponent(final SNodeReference baseNode, final Set<RelationDescriptor> possibleTabs, JComponent component, NodeChangeCallback callback, CreateModeCallback createModeCallback, Project project) {\n    MyState state = ApplicationManager.getApplication().getComponent(EditorSettings.class).getState();\n    if (!state.isShow()) {\n      return new EmptyTabsComponent(baseNode, callback, ProjectHelper.fromIdeaProject(project));\n    }\n\n    if (state.isShowPlain()) {\n      return new PlainTabsComponent(baseNode, possibleTabs, component, callback, state.isShowGrayed(), createModeCallback, project);\n    } else {\n      return new ButtonTabsComponent(baseNode, possibleTabs, component, callback, state.isShowGrayed(), project);\n    }\n  }","id":88264,"modified_method":"public static TabsComponent createTabsComponent(final SNodeReference baseNode, final Set<RelationDescriptor> possibleTabs, JComponent component,\n      NodeChangeCallback callback, CreateModeCallback createModeCallback, Project project) {\n    EditorSettings editorSettings = ApplicationManager.getApplication().getComponent(EditorSettings.class);\n    if (!editorSettings.isShow()) {\n      return new EmptyTabsComponent(baseNode, callback, ProjectHelper.fromIdeaProject(project));\n    }\n\n    if (editorSettings.isShowPlain()) {\n      return new PlainTabsComponent(baseNode, possibleTabs, component, callback, editorSettings.isShowGrayed(), createModeCallback, project);\n    } else {\n      return new ButtonTabsComponent(baseNode, possibleTabs, component, callback, editorSettings.isShowGrayed(), project);\n    }\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isUseTabs() {\n    return myEditorSettings.getState().isShow();\n  }","id":88265,"modified_method":"private boolean isUseTabs() {\n    return myEditorSettings.isShow();\n  }","commit_id":"8d7c6f872458b74e484f6449f36eec79d06b6d90","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n\tpublic void testBoolean2() {\n\t\t_converter.convertType(ExpandoColumnConstants.BOOLEAN, \"false\");\n\t}","id":88266,"modified_method":"@Test\n\tpublic void testBoolean2() {\n\t\tBoolean convertedBooolean =\n\t\t\t_converter.convertType(ExpandoColumnConstants.BOOLEAN, \"false\");\n\n\t\tAssert.assertFalse(convertedBooolean);\n\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = ClassCastException.class)\n\tpublic void testDateArray10() {\n\t\tint[] dates = new int[] {1376510136, 1376510136};\n\n\t\t_converter.convertType(ExpandoColumnConstants.DATE_ARRAY, dates);\n\t}","id":88267,"modified_method":"@Test(expected = ClassCastException.class)\n\tpublic void testDateArray10() {\n\t\tint[] times = new int[] {1376510136, 1376510136};\n\n\t\t_converter.convertType(ExpandoColumnConstants.DATE_ARRAY, times);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = TypeConversionException.class)\n\tpublic void testInteger3() {\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER, \"13.4\");\n\t}","id":88268,"modified_method":"@Test(expected = TypeConversionException.class)\n\tpublic void testInteger3() {\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER, \"13.6\");\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumber2() {\n\t\t_converter.convertType(ExpandoColumnConstants.NUMBER, \"-345\");\n\t}","id":88269,"modified_method":"@Test\n\tpublic void testNumber2() {\n\t\tNumber negativeNumber = -345;\n\n\t\tNumber convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER, negativeNumber);\n\n\t\tAssert.assertEquals(\n\t\t\tnegativeNumber.intValue(), convertedNumber.intValue());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloat1() {\n\t\t_converter.convertType(ExpandoColumnConstants.FLOAT, \"-456.23\");\n\t}","id":88270,"modified_method":"@Test\n\tpublic void testFloat1() {\n\t\tFloat negativeFloat = -456.23f;\n\n\t\tFloat convertedFloat =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.FLOAT, negativeFloat.toString());\n\n\t\tAssert.assertEquals(negativeFloat, convertedFloat);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDateArray9() {\n\t\tlong[] dates = new long[] {1376510136750L, 1376510136560L};\n\n\t\t_converter.convertType(ExpandoColumnConstants.DATE_ARRAY, dates);\n\t}","id":88271,"modified_method":"@Test\n\tpublic void testDateArray9() {\n\t\tlong[] times = new long[] {1376510136750L, 1376510136560L};\n\n\t\tDate[] datesConverted =\n\t\t\t_converter.convertType(ExpandoColumnConstants.DATE_ARRAY, times);\n\n\t\tAssert.assertEquals(2, datesConverted.length);\n\t\tAssert.assertEquals(times[0], datesConverted[0].getTime());\n\t\tAssert.assertEquals(times[1], datesConverted[1].getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBooleanArray1() {\n\t\t_converter.convertType(ExpandoColumnConstants.BOOLEAN_ARRAY, \"true\");\n\t}","id":88272,"modified_method":"@Test\n\tpublic void testBooleanArray1() {\n\t\tboolean[] convertedBoooleans  =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"true\");\n\n\t\tAssert.assertEquals(1, convertedBoooleans.length);\n\t\tAssert.assertTrue(convertedBoooleans[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLongArray4() {\n\t\t_converter.convertType(ExpandoColumnConstants.LONG_ARRAY, \"[56,1]\");\n\t}","id":88273,"modified_method":"@Test\n\tpublic void testLongArray4() {\n\t\tLong long1 = 56L;\n\t\tLong long2 = 1L;\n\n\t\tlong[] convertedLongs =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.LONG_ARRAY,\n\t\t\t\t\"[\" + long1 + \", \" + long2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedLongs.length);\n\t\tAssert.assertEquals(long1.longValue(), convertedLongs[0]);\n\t\tAssert.assertEquals(long2.longValue(), convertedLongs[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShortArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.SHORT_ARRAY, \"[\\\"34\\\",12]\");\n\t}","id":88274,"modified_method":"@Test\n\tpublic void testShortArray6() {\n\t\tShort short1 = 34;\n\t\tShort short2 = 12;\n\n\t\tshort[] convertedShorts =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.SHORT_ARRAY,\n\t\t\t\t\"[\\\"\" + short1 + \"\\\", \" + short2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedShorts.length);\n\t\tAssert.assertEquals(short1.shortValue(), convertedShorts[0]);\n\t\tAssert.assertEquals(short2.shortValue(), convertedShorts[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumberArray1() {\n\t\t_converter.convertType(ExpandoColumnConstants.NUMBER_ARRAY, \"13\");\n\t}","id":88275,"modified_method":"@Test\n\tpublic void testNumberArray1() {\n\t\tNumber positiveNumber = 13;\n\n\t\tNumber[] convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER_ARRAY, positiveNumber.toString());\n\n\t\tAssert.assertEquals(1, convertedNumber.length);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(positiveNumber.intValue()), convertedNumber[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDouble2() {\n\t\t_converter.convertType(ExpandoColumnConstants.DOUBLE, \"345.4\");\n\t}","id":88276,"modified_method":"@Test\n\tpublic void testDouble2() {\n\t\tDouble positiveDouble = 345.4;\n\n\t\tDouble doubleConverted =_converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE, positiveDouble.toString());\n\n\t\tAssert.assertEquals(positiveDouble, doubleConverted);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLong1() {\n\t\t_converter.convertType(ExpandoColumnConstants.LONG, \"456\");\n\t}","id":88277,"modified_method":"@Test\n\tpublic void testLong1() {\n\t\tLong positiveLong = 456L;\n\n\t\tLong convertedLong =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.LONG, positiveLong.toString());\n\n\t\tAssert.assertEquals(positiveLong, convertedLong);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDateArray4() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DATE_ARRAY,\n\t\t\t\"[1376510136750, 1376510136751]\");\n\t}","id":88278,"modified_method":"@Test\n\tpublic void testDateArray4() {\n\t\tlong time1 = 1376510136750L;\n\t\tlong time2 = 1376510136751L;\n\n\t\tDate[] convertedDates =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.DATE_ARRAY,\n\t\t\t\t\"[\" + String.valueOf(time1) + \", \" + String.valueOf(time2) + \"]\");\n\n\t\tAssert.assertEquals(2, convertedDates.length);\n\t\tAssert.assertEquals(time1, convertedDates[0].getTime());\n\t\tAssert.assertEquals(time2, convertedDates[1].getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLongArray1() {\n\t\t_converter.convertType(ExpandoColumnConstants.LONG_ARRAY, \"13\");\n\t}","id":88279,"modified_method":"@Test\n\tpublic void testLongArray1() {\n\t\tLong longValue = 13L;\n\n\t\tlong[] convertedLongs =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.LONG_ARRAY, longValue.toString());\n\n\t\tAssert.assertEquals(1, convertedLongs.length);\n\t\tAssert.assertEquals(longValue.longValue(), convertedLongs[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumberArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.NUMBER_ARRAY, \"[\\\"34\\\",12]\");\n\t}","id":88280,"modified_method":"@Test\n\tpublic void testNumberArray6() {\n\t\tNumber number1 = 34;\n\t\tNumber number2 = 12;\n\n\t\tNumber[] convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER_ARRAY,\n\t\t\t\t\"[\\\"\" + number1 + \"\\\", \" + number2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedNumber.length);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(number1.intValue()), convertedNumber[0]);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(number2.intValue()), convertedNumber[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBooleanArray4() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"[false,true]\");\n\t}","id":88281,"modified_method":"@Test\n\tpublic void testBooleanArray4() {\n\t\tboolean[] convertedBoooleans  =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"[false,true]\");\n\n\t\tAssert.assertEquals(2, convertedBoooleans.length);\n\t\tAssert.assertTrue(convertedBoooleans[1]);\n\t\tAssert.assertFalse(convertedBoooleans[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIntegerArray8() {\n\t\tCollection<String> ints = new ArrayList<String>();\n\n\t\tints.add(\"-345\");\n\t\tints.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER_ARRAY, ints);\n\t}","id":88282,"modified_method":"@Test\n\tpublic void testIntegerArray8() {\n\t\tCollection<String> ints = new ArrayList<String>();\n\n\t\tints.add(String.valueOf(Integer.MIN_VALUE));\n\t\tints.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\tint[] convertedIntegers =\n\t\t\t_converter.convertType(ExpandoColumnConstants.INTEGER_ARRAY, ints);\n\n\t\tAssert.assertEquals(2, convertedIntegers.length);\n\t\tAssert.assertEquals(Integer.MIN_VALUE, convertedIntegers[0]);\n\t\tAssert.assertEquals(Integer.MAX_VALUE, convertedIntegers[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDouble1() {\n\t\t_converter.convertType(ExpandoColumnConstants.DOUBLE, \"-456.23\");\n\t}","id":88283,"modified_method":"@Test\n\tpublic void testDouble1() {\n\t\tDouble negativeDouble = -456.23;\n\n\t\tDouble doubleConverted =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.DOUBLE,negativeDouble.toString());\n\n\t\tAssert.assertEquals(negativeDouble, doubleConverted);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShortArray1() {\n\t\t_converter.convertType(ExpandoColumnConstants.SHORT_ARRAY, \"13\");\n\t}","id":88284,"modified_method":"@Test\n\tpublic void testShortArray1() {\n\t\tShort positiveShort = 13;\n\n\t\tshort[] convertedShorts =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.SHORT_ARRAY, positiveShort.toString());\n\n\t\tAssert.assertEquals(1, convertedShorts.length);\n\t\tAssert.assertEquals(positiveShort.shortValue(), convertedShorts[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloatArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY, \"[\\\"34.67\\\",12.45]\");\n\t}","id":88285,"modified_method":"@Test\n\tpublic void testFloatArray6() {\n\t\tfloat float1 = 34.67f;\n\t\tfloat float2 = 12.45f;\n\n\t\tfloat[] convertedFloats = _converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY,\n\t\t\t\"[\\\"\" + float1 + \"\\\", \" + float2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedFloats.length);\n\t\tAssert.assertEquals(float1, convertedFloats[0], 0);\n\t\tAssert.assertEquals(float2, convertedFloats[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDoubleArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE_ARRAY, \"[\\\"34.67\\\",12.45]\");\n\t}","id":88286,"modified_method":"@Test\n\tpublic void testDoubleArray6() {\n\t\tdouble double1 = 34.67;\n\t\tdouble double2 = 12.45;\n\n\t\tdouble[] doublesConverted = _converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE_ARRAY,\n\t\t\t\"[\\\"\" + double1 + \"\\\",\" + double2 + \"]\");\n\n\t\tAssert.assertEquals(2, doublesConverted.length);\n\t\tAssert.assertEquals(double1, doublesConverted[0], 0);\n\t\tAssert.assertEquals(double2, doublesConverted[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloatArray1() {\n\t\t_converter.convertType(ExpandoColumnConstants.FLOAT_ARRAY, \"13.4\");\n\t}","id":88287,"modified_method":"@Test\n\tpublic void testFloatArray1() {\n\t\tFloat floatValue = 13.4f;\n\n\t\tfloat[] convertedFloats = _converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY, floatValue.toString());\n\n\t\tAssert.assertEquals(1, convertedFloats.length);\n\t\tAssert.assertEquals(floatValue, convertedFloats[0], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDoubleArray4() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE_ARRAY, \"[56.6567,0.0000345]\");\n\t}","id":88288,"modified_method":"@Test\n\tpublic void testDoubleArray4() {\n\t\tdouble double1 = 56.6567;\n\t\tdouble double2 = 0.0000345;\n\n\t\tdouble[] doublesConverted =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.DOUBLE_ARRAY,\n\t\t\t\t\"[\" + double1 + \", \" + double2 + \"]\");\n\n\t\tAssert.assertEquals(2, doublesConverted.length);\n\t\tAssert.assertEquals(double1, doublesConverted[0], 0);\n\t\tAssert.assertEquals(double2, doublesConverted[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumberArray2() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.NUMBER_ARRAY, \"345,56\");\n\t}","id":88289,"modified_method":"@Test\n\tpublic void testNumberArray2() {\n\t\tNumber number1 = 345;\n\t\tNumber number2 = 56;\n\n\t\tNumber[] convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER_ARRAY, number1 + \", \" + number2);\n\n\t\tAssert.assertEquals(2, convertedNumber.length);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(number1.intValue()), convertedNumber[0]);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(number2.intValue()), convertedNumber[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLongArray2() {\n\t\t_converter.convertType(ExpandoColumnConstants.LONG_ARRAY, \"345,56\");\n\t}","id":88290,"modified_method":"@Test\n\tpublic void testLongArray2() {\n\t\tLong long1 = 345L;\n\t\tLong long2 = 56L;\n\n\t\tlong[] convertedLongs =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.LONG_ARRAY,\n\t\t\t\tlong1.longValue() + \", \" + long2.longValue());\n\n\t\tAssert.assertEquals(2, convertedLongs.length);\n\t\tAssert.assertEquals(long1.longValue(), convertedLongs[0]);\n\t\tAssert.assertEquals(long2.longValue(), convertedLongs[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumberArray4() {\n\t\t_converter.convertType(ExpandoColumnConstants.NUMBER_ARRAY, \"[56,1]\");\n\t}","id":88291,"modified_method":"@Test\n\tpublic void testNumberArray4() {\n\t\tNumber number1 = 56;\n\t\tNumber number2 = 1;\n\n\t\tNumber[] convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER_ARRAY,\n\t\t\t\t\"[\" + number1 + \", \" + number2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedNumber.length);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(number1.intValue()), convertedNumber[0]);\n\t\tAssert.assertEquals(\n\t\t\tnew BigDecimal(number2.intValue()), convertedNumber[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInteger1() {\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER, \"456\");\n\t}","id":88292,"modified_method":"@Test\n\tpublic void testInteger1() {\n\t\tInteger positiveInteger = 456;\n\n\t\tInteger convertedInteger =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.INTEGER, positiveInteger.toString());\n\n\t\tAssert.assertEquals(positiveInteger, convertedInteger);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDate1() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DATE, System.currentTimeMillis());\n\t}","id":88293,"modified_method":"@Test\n\tpublic void testDate1() {\n\t\tlong time = System.currentTimeMillis();\n\n\t\tDate convertedDate = _converter.convertType(\n\t\t\tExpandoColumnConstants.DATE, time);\n\n\t\tAssert.assertEquals(time, convertedDate.getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLongArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.LONG_ARRAY, \"[\\\"34\\\",12]\");\n\t}","id":88294,"modified_method":"@Test\n\tpublic void testLongArray6() {\n\t\tLong long1 = 34L;\n\t\tLong long2 = 12L;\n\n\t\tlong[] convertedLongs =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.LONG_ARRAY,\n\t\t\t\t\"[\\\"\" + long1 + \"\\\", \" + long2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedLongs.length);\n\t\tAssert.assertEquals(long1.longValue(), convertedLongs[0]);\n\t\tAssert.assertEquals(long2.longValue(), convertedLongs[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShortArray4() {\n\t\t_converter.convertType(ExpandoColumnConstants.SHORT_ARRAY, \"[56,1]\");\n\t}","id":88295,"modified_method":"@Test\n\tpublic void testShortArray4() {\n\t\tShort short1 = 56;\n\t\tShort short2 = 1;\n\n\t\tshort[] convertedShorts =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.SHORT_ARRAY,\n\t\t\t\t\"[\" + short1 + \", \" + short2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedShorts.length);\n\t\tAssert.assertEquals(short1.shortValue(), convertedShorts[0]);\n\t\tAssert.assertEquals(short2.shortValue(), convertedShorts[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumberArray9() {\n\t\tCollection<String> numbers = new ArrayList<String>();\n\n\t\tnumbers.add(String.valueOf(Double.MAX_VALUE));\n\t\tnumbers.add(String.valueOf(Long.MAX_VALUE));\n\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.NUMBER_ARRAY, numbers);\n\t}","id":88296,"modified_method":"@Test\n\tpublic void testNumberArray9() {\n\t\tCollection<String> numbers = new ArrayList<String>();\n\n\t\tnumbers.add(String.valueOf(Double.MAX_VALUE));\n\t\tnumbers.add(String.valueOf(Long.MAX_VALUE));\n\n\t\tNumber[] convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER_ARRAY, numbers);\n\n\t\tAssert.assertEquals(2, convertedNumber.length);\n\t\tAssert.assertEquals(Double.MAX_VALUE, convertedNumber[0].doubleValue(), 0);\n\t\tAssert.assertEquals(Long.MAX_VALUE, convertedNumber[1].doubleValue(), 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloatArray2() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY, \"345.67,56\");\n\t}","id":88297,"modified_method":"@Test\n\tpublic void testFloatArray2() {\n\t\tfloat float1 = 345.67f;\n\t\tint float2 = 56;\n\n\t\tfloat[] convertedFloats = _converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY, float1 + \", \" + float2);\n\n\t\tAssert.assertEquals(2, convertedFloats.length);\n\t\tAssert.assertEquals(float1, convertedFloats[0], 0);\n\t\tAssert.assertEquals(float2, convertedFloats[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBooleanArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"[\\\"false\\\",true]\");\n\t}","id":88298,"modified_method":"@Test\n\tpublic void testBooleanArray6() {\n\t\tboolean[] convertedBoooleans =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"[\\\"false\\\",true]\");\n\n\t\tAssert.assertEquals(2, convertedBoooleans.length);\n\t\tAssert.assertTrue(convertedBoooleans[1]);\n\t\tAssert.assertFalse(convertedBoooleans[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDateArray1() {\n\t\tString[] dates = new String[] {\n\t\t\tString.valueOf(System.currentTimeMillis()),\n\t\t\tString.valueOf(System.currentTimeMillis())\n\t\t};\n\n\t\t_converter.convertType(ExpandoColumnConstants.DATE_ARRAY, dates);\n\t}","id":88299,"modified_method":"@Test\n\tpublic void testDateArray1() {\n\t\tlong time1 = System.currentTimeMillis();\n\t\tlong time2 = System.currentTimeMillis();\n\n\t\tString[] dates = new String[] {\n\t\t\tString.valueOf(time1),\n\t\t\tString.valueOf(time2)\n\t\t};\n\n\t\tDate[] convertedDates =\n\t\t\t_converter.convertType(ExpandoColumnConstants.DATE_ARRAY, dates);\n\n\t\tAssert.assertEquals(2, convertedDates.length);\n\t\tAssert.assertEquals(time1, convertedDates[0].getTime());\n\t\tAssert.assertEquals(time2, convertedDates[1].getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShort2() {\n\t\t_converter.convertType(ExpandoColumnConstants.SHORT, \"-345\");\n\t}","id":88300,"modified_method":"@Test\n\tpublic void testShort2() {\n\t\tShort negativeShort = -345;\n\n\t\tShort convertedShort =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.SHORT, negativeShort.toString());\n\n\t\tAssert.assertEquals(\n\t\t\tnegativeShort, convertedShort);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBooleanArray2() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"false,true\");\n\t}","id":88301,"modified_method":"@Test\n\tpublic void testBooleanArray2() {\n\t\tboolean[] convertedBoooleans  =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, \"false,true\");\n\n\t\tAssert.assertEquals(2, convertedBoooleans.length);\n\t\tAssert.assertTrue(convertedBoooleans[1]);\n\t\tAssert.assertFalse(convertedBoooleans[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShort1() {\n\t\t_converter.convertType(ExpandoColumnConstants.SHORT, \"456\");\n\t}","id":88302,"modified_method":"@Test\n\tpublic void testShort1() {\n\t\tShort positiveShort = 456;\n\n\t\tShort convertedShort =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.SHORT, positiveShort.toString());\n\n\t\tAssert.assertEquals(\n\t\t\tpositiveShort, convertedShort);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInteger2() {\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER, \"-345\");\n\t}","id":88303,"modified_method":"@Test\n\tpublic void testInteger2() {\n\t\tInteger negativeInteger = -345;\n\n\t\tInteger convertedInteger =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.INTEGER, negativeInteger.toString());\n\n\t\tAssert.assertEquals(negativeInteger, convertedInteger);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBoolean1() {\n\t\t_converter.convertType(ExpandoColumnConstants.BOOLEAN, \"true\");\n\t}","id":88304,"modified_method":"@Test\n\tpublic void testBoolean1() {\n\t\tBoolean convertedBooolean =\n\t\t\t_converter.convertType(ExpandoColumnConstants.BOOLEAN, \"true\");\n\n\t\tAssert.assertTrue(convertedBooolean);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShortArray2() {\n\t\t_converter.convertType(ExpandoColumnConstants.SHORT_ARRAY, \"345,56\");\n\t}","id":88305,"modified_method":"@Test\n\tpublic void testShortArray2() {\n\t\tShort short1 = 345;\n\t\tShort short2 = 56;\n\n\t\tshort[] convertedShorts =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.SHORT_ARRAY,\n\t\t\t\tshort1 + \", \" + short2);\n\n\t\tAssert.assertEquals(2, convertedShorts.length);\n\t\tAssert.assertEquals(short1.shortValue(), convertedShorts[0]);\n\t\tAssert.assertEquals(short2.shortValue(), convertedShorts[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloat2() {\n\t\t_converter.convertType(ExpandoColumnConstants.FLOAT, \"345.4\");\n\t}","id":88306,"modified_method":"@Test\n\tpublic void testFloat2() {\n\t\tFloat positiveFloat = 345.4f;\n\n\t\tFloat convertedFloat =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.FLOAT, positiveFloat.toString());\n\n\t\tAssert.assertEquals(positiveFloat, convertedFloat);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIntegerArray2() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.INTEGER_ARRAY, \"345,56\");\n\t}","id":88307,"modified_method":"@Test\n\tpublic void testIntegerArray2() {\n\t\tInteger integer1 = 345;\n\t\tInteger integer2 = 56;\n\n\t\tint[] convertedIntegers =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.INTEGER_ARRAY,\n\t\t\t\tinteger1 + \", \" + integer2);\n\n\t\tAssert.assertEquals(2, convertedIntegers.length);\n\t\tAssert.assertEquals(integer1.intValue(), convertedIntegers[0]);\n\t\tAssert.assertEquals(integer2.intValue(), convertedIntegers[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumber1() {\n\t\t_converter.convertType(ExpandoColumnConstants.NUMBER, \"456\");\n\t}","id":88308,"modified_method":"@Test\n\tpublic void testNumber1() {\n\t\tNumber positiveNumber = 456;\n\n\t\tNumber convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER, positiveNumber.toString());\n\n\t\tAssert.assertEquals(\n\t\t\tpositiveNumber.intValue(), convertedNumber.intValue());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDateArray2() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DATE_ARRAY, \"1376510136750\");\n\t}","id":88309,"modified_method":"@Test\n\tpublic void testDateArray2() {\n\t\tlong time = 1376510136750L;\n\n\t\tDate[] convertedDates = _converter.convertType(\n\t\t\tExpandoColumnConstants.DATE_ARRAY, String.valueOf(time));\n\n\t\tAssert.assertEquals(1, convertedDates.length);\n\t\tAssert.assertEquals(time, convertedDates[0].getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDoubleArray2() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE_ARRAY, \"345.67,56\");\n\t}","id":88310,"modified_method":"@Test\n\tpublic void testDoubleArray2() {\n\t\tdouble double1 = 345.4;\n\t\tint double2 = 56;\n\n\t\tdouble[] doublesConverted =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.DOUBLE_ARRAY,\n\t\t\t\tdouble1 + \", \" + double2);\n\n\t\tAssert.assertEquals(2, doublesConverted.length);\n\t\tAssert.assertEquals(double1, doublesConverted[0], 0);\n\t\tAssert.assertEquals(double2, doublesConverted[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDateArray3() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DATE_ARRAY,\n\t\t\t\"1376510136750, 1376510136751\");\n\t}","id":88311,"modified_method":"@Test\n\tpublic void testDateArray3() {\n\t\tlong time1 = 1376510136750L;\n\t\tlong time2 = 1376510136751L;\n\n\t\tDate[] convertedDates =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.DATE_ARRAY,\n\t\t\t\tString.valueOf(time1) + \", \" + String.valueOf(time2));\n\n\t\tAssert.assertEquals(2, convertedDates.length);\n\t\tAssert.assertEquals(time1, convertedDates[0].getTime());\n\t\tAssert.assertEquals(time2, convertedDates[1].getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDateArray8() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DATE_ARRAY, 1376510136750L);\n\t}","id":88312,"modified_method":"@Test\n\tpublic void testDateArray8() {\n\t\tlong time = 1376510136750L;\n\n\t\tDate[] datesConverted =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.DATE_ARRAY, time);\n\n\t\tAssert.assertEquals(1, datesConverted.length);\n\t\tAssert.assertEquals(time, datesConverted[0].getTime());\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testBooleanArray8() {\n\t\tCollection<String> booleans = new ArrayList<String>();\n\n\t\tbooleans.add(\"true\");\n\t\tbooleans.add(\"false\");\n\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, booleans);\n\t}","id":88313,"modified_method":"@Test\n\tpublic void testBooleanArray8() {\n\t\tCollection<String> booleans = new ArrayList<String>();\n\n\t\tbooleans.add(\"true\");\n\t\tbooleans.add(\"false\");\n\n\t\tboolean[] convertedBoooleans =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.BOOLEAN_ARRAY, booleans);\n\n\t\tAssert.assertEquals(2, convertedBoooleans.length);\n\t\tAssert.assertTrue(convertedBoooleans[0]);\n\t\tAssert.assertFalse(convertedBoooleans[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIntegerArray4() {\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER_ARRAY, \"[56,1]\");\n\t}","id":88314,"modified_method":"@Test\n\tpublic void testIntegerArray4() {\n\t\tInteger integer1 = 56;\n\t\tInteger integer2 = 1;\n\n\t\tint[] convertedIntegers =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.INTEGER_ARRAY,\n\t\t\t\t\"[\" + integer1 + \", \" + integer2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedIntegers.length);\n\t\tAssert.assertEquals(integer1.intValue(), convertedIntegers[0]);\n\t\tAssert.assertEquals(integer2.intValue(), convertedIntegers[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLongArray8() {\n\t\tCollection<String> longs = new ArrayList<String>();\n\n\t\tlongs.add(\"-345\");\n\t\tlongs.add(String.valueOf(Long.MAX_VALUE));\n\n\t\t_converter.convertType(ExpandoColumnConstants.LONG_ARRAY, longs);\n\t}","id":88315,"modified_method":"@Test\n\tpublic void testLongArray8() {\n\t\tCollection<String> longs = new ArrayList<String>();\n\n\t\tlongs.add(String.valueOf(Long.MIN_VALUE));\n\t\tlongs.add(String.valueOf(Long.MAX_VALUE));\n\n\t\tlong[] convertedLongs =\n\t\t\t_converter.convertType(ExpandoColumnConstants.LONG_ARRAY, longs);\n\n\t\tAssert.assertEquals(2, convertedLongs.length);\n\t\tAssert.assertEquals(Long.MIN_VALUE, convertedLongs[0]);\n\t\tAssert.assertEquals(Long.MAX_VALUE, convertedLongs[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloatArray8() {\n\t\tCollection<String> floats = new ArrayList<String>();\n\n\t\tfloats.add(String.valueOf(Float.MAX_VALUE));\n\t\tfloats.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\t_converter.convertType(ExpandoColumnConstants.FLOAT_ARRAY, floats);\n\t}","id":88316,"modified_method":"@Test\n\tpublic void testFloatArray8() {\n\t\tCollection<String> floats = new ArrayList<String>();\n\n\t\tfloats.add(String.valueOf(Float.MAX_VALUE));\n\t\tfloats.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\tfloat[] convertedFloats =\n\t\t\t_converter.convertType(ExpandoColumnConstants.FLOAT_ARRAY, floats);\n\n\t\tAssert.assertEquals(2, convertedFloats.length);\n\t\tAssert.assertEquals(Float.MAX_VALUE, convertedFloats[0], 0);\n\t\tAssert.assertEquals(Integer.MAX_VALUE, convertedFloats[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIntegerArray6() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.INTEGER_ARRAY, \"[\\\"34\\\",12]\");\n\t}","id":88317,"modified_method":"@Test\n\tpublic void testIntegerArray6() {\n\t\tInteger integer1 = 34;\n\t\tInteger integer2 = 12;\n\n\t\tint[] convertedIntegers =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.INTEGER_ARRAY,\n\t\t\t\t\"[\\\"\" + integer1 + \"\\\",\" + integer2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedIntegers.length);\n\t\tAssert.assertEquals(integer1.intValue(), convertedIntegers[0]);\n\t\tAssert.assertEquals(integer2.intValue(), convertedIntegers[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIntegerArray1() {\n\t\t_converter.convertType(ExpandoColumnConstants.INTEGER_ARRAY, \"13\");\n\t}","id":88318,"modified_method":"@Test\n\tpublic void testIntegerArray1() {\n\t\tInteger integer = 13;\n\n\t\tint[] convertedIntegers =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.INTEGER_ARRAY, integer.toString());\n\n\t\tAssert.assertEquals(1, convertedIntegers.length);\n\t\tAssert.assertEquals(integer.intValue(), convertedIntegers[0]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloatArray4() {\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY, \"[56.6567,0.0000345]\");\n\t}","id":88319,"modified_method":"@Test\n\tpublic void testFloatArray4() {\n\t\tfloat float1 = 56.6567f;\n\t\tfloat float2 = 0.0000345f;\n\n\t\tfloat[] convertedFloats = _converter.convertType(\n\t\t\tExpandoColumnConstants.FLOAT_ARRAY,\n\t\t\t\"[\" + float1 + \", \" + float2 + \"]\");\n\n\t\tAssert.assertEquals(2, convertedFloats.length);\n\t\tAssert.assertEquals(float1, convertedFloats[0], 0);\n\t\tAssert.assertEquals(float2, convertedFloats[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testShortArray8() {\n\t\tCollection<String> shorts = new ArrayList<String>();\n\n\t\tshorts.add(\"-345\");\n\t\tshorts.add(String.valueOf(Short.MAX_VALUE));\n\n\t\t_converter.convertType(ExpandoColumnConstants.SHORT_ARRAY, shorts);\n\t}","id":88320,"modified_method":"@Test\n\tpublic void testShortArray8() {\n\t\tCollection<String> shorts = new ArrayList<String>();\n\n\t\tshorts.add(String.valueOf(Short.MIN_VALUE));\n\t\tshorts.add(String.valueOf(Short.MAX_VALUE));\n\n\t\tshort[] convertedShorts =\n\t\t\t_converter.convertType(ExpandoColumnConstants.SHORT_ARRAY, shorts);\n\n\t\tAssert.assertEquals(2, convertedShorts.length);\n\t\tAssert.assertEquals(Short.MIN_VALUE, convertedShorts[0]);\n\t\tAssert.assertEquals(Short.MAX_VALUE, convertedShorts[1]);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testNumberArray8() {\n\t\tCollection<String> numbers = new ArrayList<String>();\n\n\t\tnumbers.add(\"-345\");\n\t\tnumbers.add(String.valueOf(Double.MAX_VALUE));\n\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.NUMBER_ARRAY, numbers);\n\t}","id":88321,"modified_method":"@Test\n\tpublic void testNumberArray8() {\n\t\tCollection<String> numbers = new ArrayList<String>();\n\n\t\tnumbers.add(String.valueOf(Double.MIN_VALUE));\n\t\tnumbers.add(String.valueOf(Double.MAX_VALUE));\n\n\t\tNumber[] convertedNumber =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.NUMBER_ARRAY, numbers);\n\n\t\tAssert.assertEquals(2, convertedNumber.length);\n\t\tAssert.assertEquals(Double.MIN_VALUE, convertedNumber[0].doubleValue(), 0);\n\t\tAssert.assertEquals(Double.MAX_VALUE, convertedNumber[1].doubleValue(), 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testFloatArray9() {\n\t\tCollection<String> floats = new ArrayList<String>();\n\n\t\tfloats.add(String.valueOf(Double.MAX_VALUE));\n\t\tfloats.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\t_converter.convertType(ExpandoColumnConstants.FLOAT_ARRAY, floats);\n\t}","id":88322,"modified_method":"@Test\n\tpublic void testFloatArray9() {\n\t\tCollection<String> floats = new ArrayList<String>();\n\n\t\tfloats.add(String.valueOf(Double.MAX_VALUE));\n\t\tfloats.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\tfloat[] convertedFloats =\n\t\t\t_converter.convertType(ExpandoColumnConstants.FLOAT_ARRAY, floats);\n\n\t\tAssert.assertEquals(2, convertedFloats.length);\n\t\tAssert.assertEquals(Float.POSITIVE_INFINITY, convertedFloats[0], 0);\n\t\tAssert.assertEquals(Integer.MAX_VALUE, convertedFloats[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testLong2() {\n\t\t_converter.convertType(ExpandoColumnConstants.LONG, \"-345\");\n\t}","id":88323,"modified_method":"@Test\n\tpublic void testLong2() {\n\t\tLong negativeLong = -345L;\n\n\t\tLong convertedLong =\n\t\t\t_converter.convertType(\n\t\t\t\tExpandoColumnConstants.LONG, negativeLong.toString());\n\n\t\tAssert.assertEquals(negativeLong, convertedLong);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testDoubleArray8() {\n\t\tCollection<String> doubles = new ArrayList<String>();\n\n\t\tdoubles.add(String.valueOf(Double.MAX_VALUE));\n\t\tdoubles.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\t_converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE_ARRAY, doubles);\n\t}","id":88324,"modified_method":"@Test\n\tpublic void testDoubleArray8() {\n\t\tCollection<String> doubles = new ArrayList<String>();\n\n\t\tdoubles.add(String.valueOf(Double.MAX_VALUE));\n\t\tdoubles.add(String.valueOf(Integer.MAX_VALUE));\n\n\t\tdouble[] doublesConverted = _converter.convertType(\n\t\t\tExpandoColumnConstants.DOUBLE_ARRAY, doubles);\n\n\t\tAssert.assertEquals(2, doublesConverted.length);\n\t\tAssert.assertEquals(Double.MAX_VALUE, doublesConverted[0], 0);\n\t\tAssert.assertEquals(Integer.MAX_VALUE, doublesConverted[1], 0);\n\t}","commit_id":"66c762d52c82660655c2185cb1df263a73d43c30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Create the widgets for the header panel which is visible when the\n   * library panel is not clicked.\n   */\n  private void addPaneComponents() {\n    setLayout(new BorderLayout());\n\n    descriptionPane = new JTextPane();\n    descriptionPane.setInheritsPopupMenu(true);\n    descriptionPane.setEditable(false);  // why would this ever be true?\n    Insets margin = descriptionPane.getMargin();\n    margin.bottom = 0;\n    descriptionPane.setMargin(margin);\n    descriptionPane.setContentType(\"text/html\");\n    setTextStyle(descriptionPane);\n    descriptionPane.setOpaque(false);\n    if (UIManager.getLookAndFeel().getID().equals(\"Nimbus\")) {\n      descriptionPane.setBackground(new Color(0, 0, 0, 0));\n    }\n//    stripTextSelectionListeners(descriptionBlock);\n\n    descriptionPane.setBorder(new EmptyBorder(4, 7, 7, 7));\n    descriptionPane.setHighlighter(null);\n    add(descriptionPane, BorderLayout.CENTER);\n\n    JPanel updateBox = new JPanel();  //new BoxLayout(filterPanel, BoxLayout.X_AXIS)\n    updateBox.setLayout(new BorderLayout());\n\n    notificationLabel = new JLabel();\n    notificationLabel.setInheritsPopupMenu(true);\n    notificationLabel.setVisible(false);\n    notificationLabel.setOpaque(false);\n    // not needed after changing to JLabel\n//    notificationBlock.setContentType(\"text/html\");\n//    notificationBlock.setHighlighter(null);\n//    setTextStyle(notificationBlock);\n//    notificationLabel.setFont(new Font(\"Verdana\", Font.ITALIC, 10));\n    notificationLabel.setFont(Toolkit.getSansFont(12, Font.PLAIN));\n//    stripTextSelectionListeners(notificationBlock);\n\n    updateButton = new JButton(\"Update\");\n    updateButton.setInheritsPopupMenu(true);\n    Dimension dim = updateButton.getPreferredSize();\n    dim.width = BUTTON_WIDTH;\n    updateButton.setMinimumSize(dim);\n    updateButton.setPreferredSize(dim);\n    updateButton.setOpaque(false);\n    updateButton.setVisible(false);\n\n    updateButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        update();\n      }\n    });\n\n    updateBox.add(updateButton, BorderLayout.EAST);\n    updateBox.add(notificationLabel, BorderLayout.WEST);\n    updateBox.setBorder(new EmptyBorder(4, 7, 7, 7));\n    updateBox.setOpaque(false);\n    add(updateBox, BorderLayout.SOUTH);\n\n    JPanel rightPane = new JPanel();\n    rightPane.setInheritsPopupMenu(true);\n    rightPane.setOpaque(false);\n    rightPane.setLayout(new BoxLayout(rightPane, BoxLayout.Y_AXIS));\n    rightPane.setMinimumSize(new Dimension(ContributionPanel.BUTTON_WIDTH, 1));\n    add(rightPane, BorderLayout.EAST);\n\n    barButtonCardPane.setLayout(new CardLayout());\n    barButtonCardPane.setInheritsPopupMenu(true);\n    barButtonCardPane.setOpaque(false);\n    barButtonCardPane.setMinimumSize(new Dimension(ContributionPanel.BUTTON_WIDTH, 1));\n\n    installProgressBar = new JProgressBar();\n    installProgressBar.setInheritsPopupMenu(true);\n    installProgressBar.setStringPainted(true);\n    resetInstallProgressBarState();\n    Dimension d = installProgressBar.getPreferredSize();\n    d.width = ContributionPanel.BUTTON_WIDTH;\n    installProgressBar.setPreferredSize(d);\n    installProgressBar.setMaximumSize(d);\n    installProgressBar.setMinimumSize(d);\n    installProgressBar.setOpaque(false);\n    installProgressBar.setAlignmentX(CENTER_ALIGNMENT);\n\n    installRemoveButton = new JButton(\" \");\n    installRemoveButton.setInheritsPopupMenu(true);\n\n    Dimension installButtonDimensions = installRemoveButton.getPreferredSize();\n    installButtonDimensions.width = ContributionPanel.BUTTON_WIDTH;\n    installRemoveButton.setPreferredSize(installButtonDimensions);\n    installRemoveButton.setMaximumSize(installButtonDimensions);\n    installRemoveButton.setMinimumSize(installButtonDimensions);\n    installRemoveButton.setOpaque(false);\n    installRemoveButton.setAlignmentX(CENTER_ALIGNMENT);\n\n    JPanel barPane = new JPanel();\n    barPane.setOpaque(false);\n//    barPane.add(installProgressBar);\n\n    JPanel buttonPane = new JPanel();\n    buttonPane.setOpaque(false);\n    buttonPane.add(installRemoveButton);\n\n    barButtonCardPane.add(buttonPane, BUTTON_CONSTRAINT);\n    barButtonCardPane.add(barPane, PROGRESS_BAR_CONSTRAINT);\n\n    ((CardLayout) barButtonCardPane.getLayout()).show(barButtonCardPane, BUTTON_CONSTRAINT);\n\n    rightPane.add(barButtonCardPane);\n\n    // Set the minimum size of this pane to be the sum of the height of the\n    // progress bar and install button\n    d = installProgressBar.getPreferredSize();\n    Dimension d2 = installRemoveButton.getPreferredSize();\n    d.width = ContributionPanel.BUTTON_WIDTH;\n    d.height = d2.height;//d.height+d2.height;\n    rightPane.setMinimumSize(d);\n    rightPane.setPreferredSize(d);\n  }","id":88325,"modified_method":"/**\n   * Create the widgets for the header panel which is visible when the\n   * library panel is not clicked.\n   */\n  private void addPaneComponents() {\n    setLayout(new BorderLayout());\n\n    descriptionPane = new JTextPane();\n    descriptionPane.setInheritsPopupMenu(true);\n    descriptionPane.setEditable(false);  // why would this ever be true?\n    Insets margin = descriptionPane.getMargin();\n    margin.bottom = 0;\n    descriptionPane.setMargin(margin);\n    descriptionPane.setContentType(\"text/html\");\n    setTextStyle(descriptionPane);\n    descriptionPane.setOpaque(false);\n    if (UIManager.getLookAndFeel().getID().equals(\"Nimbus\")) {\n      descriptionPane.setBackground(new Color(0, 0, 0, 0));\n    }\n//    stripTextSelectionListeners(descriptionBlock);\n\n    descriptionPane.setBorder(new EmptyBorder(4, 7, 7, 7));\n    descriptionPane.setHighlighter(null);\n    add(descriptionPane, BorderLayout.CENTER);\n\n    JPanel updateBox = new JPanel();  //new BoxLayout(filterPanel, BoxLayout.X_AXIS)\n    updateBox.setLayout(new BorderLayout());\n\n    notificationLabel = new JLabel();\n    notificationLabel.setInheritsPopupMenu(true);\n    notificationLabel.setVisible(false);\n    notificationLabel.setOpaque(false);\n    // not needed after changing to JLabel\n//    notificationBlock.setContentType(\"text/html\");\n//    notificationBlock.setHighlighter(null);\n//    setTextStyle(notificationBlock);\n//    notificationLabel.setFont(new Font(\"Verdana\", Font.ITALIC, 10));\n    notificationLabel.setFont(Toolkit.getSansFont(12, Font.PLAIN));\n//    stripTextSelectionListeners(notificationBlock);\n\n    {\n      updateButton = new JButton(\"Update\");\n      updateButton.setInheritsPopupMenu(true);\n      Dimension dim =\n        new Dimension(BUTTON_WIDTH, updateButton.getPreferredSize().height);\n      updateButton.setMinimumSize(dim);\n      updateButton.setPreferredSize(dim);\n      updateButton.setOpaque(false);\n      updateButton.setVisible(false);\n\n      updateButton.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          update();\n        }\n      });\n    }\n\n    updateBox.add(updateButton, BorderLayout.EAST);\n    updateBox.add(notificationLabel, BorderLayout.WEST);\n    updateBox.setBorder(new EmptyBorder(4, 7, 7, 7));\n    updateBox.setOpaque(false);\n    add(updateBox, BorderLayout.SOUTH);\n\n    JPanel rightPane = new JPanel();\n    rightPane.setInheritsPopupMenu(true);\n    rightPane.setOpaque(false);\n    rightPane.setLayout(new BoxLayout(rightPane, BoxLayout.Y_AXIS));\n    rightPane.setMinimumSize(new Dimension(ContributionPanel.BUTTON_WIDTH, 1));\n    add(rightPane, BorderLayout.EAST);\n\n    barButtonCardPane.setLayout(new CardLayout());\n    barButtonCardPane.setInheritsPopupMenu(true);\n    barButtonCardPane.setOpaque(false);\n    barButtonCardPane.setMinimumSize(new Dimension(ContributionPanel.BUTTON_WIDTH, 1));\n\n    {\n      installProgressBar = new JProgressBar();\n      installProgressBar.setInheritsPopupMenu(true);\n      installProgressBar.setStringPainted(true);\n      resetInstallProgressBarState();\n      Dimension dim =\n        new Dimension(ContributionPanel.BUTTON_WIDTH,\n                      installProgressBar.getPreferredSize().height);\n      installProgressBar.setPreferredSize(dim);\n      installProgressBar.setMaximumSize(dim);\n      installProgressBar.setMinimumSize(dim);\n      installProgressBar.setOpaque(false);\n      installProgressBar.setAlignmentX(CENTER_ALIGNMENT);\n    }\n\n    installRemoveButton = new JButton(\" \");\n    installRemoveButton.setInheritsPopupMenu(true);\n\n    Dimension installButtonDimensions = installRemoveButton.getPreferredSize();\n    installButtonDimensions.width = ContributionPanel.BUTTON_WIDTH;\n    installRemoveButton.setPreferredSize(installButtonDimensions);\n    installRemoveButton.setMaximumSize(installButtonDimensions);\n    installRemoveButton.setMinimumSize(installButtonDimensions);\n    installRemoveButton.setOpaque(false);\n    installRemoveButton.setAlignmentX(CENTER_ALIGNMENT);\n\n    JPanel barPane = new JPanel();\n    barPane.setOpaque(false);\n//    barPane.add(installProgressBar);\n\n    JPanel buttonPane = new JPanel();\n    buttonPane.setOpaque(false);\n    buttonPane.add(installRemoveButton);\n\n    barButtonCardPane.add(buttonPane, BUTTON_CONSTRAINT);\n    barButtonCardPane.add(barPane, PROGRESS_BAR_CONSTRAINT);\n\n    ((CardLayout) barButtonCardPane.getLayout()).show(barButtonCardPane, BUTTON_CONSTRAINT);\n\n    rightPane.add(barButtonCardPane);\n\n    // Set the minimum size of this pane to be the sum of the height of the\n    // progress bar and install button\n    Dimension dim =\n      new Dimension(ContributionPanel.BUTTON_WIDTH,\n                    installRemoveButton.getPreferredSize().height);\n    rightPane.setMinimumSize(dim);\n    rightPane.setPreferredSize(dim);\n  }","commit_id":"ae70e0299d93c0651161e2ad5488dae1f9398eea","url":"https://github.com/processing/processing"},{"original_method":"@NotNull\n    public FunctionDescriptorImpl resolveFunctionDescriptor(DeclarationDescriptor containingDescriptor, final JetScope scope, final JetNamedFunction function) {\n        final FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(\n                containingDescriptor,\n                annotationResolver.resolveAnnotations(scope, function.getModifierList()),\n                JetPsiUtil.safeName(function.getName())\n        );\n        WritableScope innerScope = new WritableScopeImpl(scope, functionDescriptor, trace.getErrorHandler()).setDebugName(\"Function descriptor header scope\");\n        innerScope.addLabeledDeclaration(functionDescriptor);\n\n        List<TypeParameterDescriptor> typeParameterDescriptors = resolveTypeParameters(functionDescriptor, innerScope, function.getTypeParameters());\n        resolveGenericBounds(function, innerScope, typeParameterDescriptors);\n\n        JetType receiverType = null;\n        JetTypeReference receiverTypeRef = function.getReceiverTypeRef();\n        if (receiverTypeRef != null) {\n            JetScope scopeForReceiver =\n                    function.hasTypeParameterListBeforeFunctionName()\n                            ? innerScope\n                            : scope;\n            receiverType = typeResolver.resolveType(scopeForReceiver, receiverTypeRef);\n        }\n\n        List<ValueParameterDescriptor> valueParameterDescriptors = resolveValueParameters(functionDescriptor, innerScope, function.getValueParameters());\n\n        JetTypeReference returnTypeRef = function.getReturnTypeRef();\n        JetType returnType;\n        if (returnTypeRef != null) {\n            returnType = typeResolver.resolveType(innerScope, returnTypeRef);\n        }\n        else if (function.hasBlockBody()) {\n            returnType = JetStandardClasses.getUnitType();\n        }\n        else {\n            final JetExpression bodyExpression = function.getBodyExpression();\n            if (bodyExpression != null) {\n                returnType = new DeferredType(new LazyValue<JetType>() {\n                    @Override\n                    protected JetType compute() {\n                        JetFlowInformationProvider flowInformationProvider = computeFlowData(function, bodyExpression);\n                        return semanticServices.getTypeInferrerServices(trace, flowInformationProvider).inferFunctionReturnType(scope, function, functionDescriptor);\n                    }\n                });\n            }\n            else {\n                trace.getErrorHandler().genericError(function.asElement().getNode(), \"This function must either declare a return type or have a body element\");\n                returnType = ErrorUtils.createErrorType(\"No type, no body\");\n            }\n        }\n\n        functionDescriptor.initialize(\n                receiverType,\n                typeParameterDescriptors,\n                valueParameterDescriptors,\n                returnType,\n                resolveMemberModifiers(function.getModifierList()));\n\n        trace.record(BindingContext.FUNCTION, function, functionDescriptor);\n        return functionDescriptor;\n    }","id":88326,"modified_method":"@NotNull\n    public FunctionDescriptorImpl resolveFunctionDescriptor(DeclarationDescriptor containingDescriptor, final JetScope scope, final JetNamedFunction function) {\n        final FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(\n                containingDescriptor,\n                annotationResolver.resolveAnnotations(scope, function.getModifierList()),\n                JetPsiUtil.safeName(function.getName())\n        );\n        WritableScope innerScope = new WritableScopeImpl(scope, functionDescriptor, trace.getErrorHandler()).setDebugName(\"Function descriptor header scope\");\n        innerScope.addLabeledDeclaration(functionDescriptor);\n\n        List<TypeParameterDescriptor> typeParameterDescriptors = resolveTypeParameters(functionDescriptor, innerScope, function.getTypeParameters());\n        resolveGenericBounds(function, innerScope, typeParameterDescriptors);\n\n        JetType receiverType = null;\n        JetTypeReference receiverTypeRef = function.getReceiverTypeRef();\n        if (receiverTypeRef != null) {\n            JetScope scopeForReceiver =\n                    function.hasTypeParameterListBeforeFunctionName()\n                            ? innerScope\n                            : scope;\n            receiverType = typeResolver.resolveType(scopeForReceiver, receiverTypeRef);\n        }\n\n        List<ValueParameterDescriptor> valueParameterDescriptors = resolveValueParameters(functionDescriptor, innerScope, function.getValueParameters());\n\n        JetTypeReference returnTypeRef = function.getReturnTypeRef();\n        JetType returnType;\n        if (returnTypeRef != null) {\n            returnType = typeResolver.resolveType(innerScope, returnTypeRef);\n        }\n        else if (function.hasBlockBody()) {\n            returnType = JetStandardClasses.getUnitType();\n        }\n        else {\n            final JetExpression bodyExpression = function.getBodyExpression();\n            if (bodyExpression != null) {\n                returnType = new DeferredType(new LazyValue<JetType>() {\n                    @Override\n                    protected JetType compute() {\n                        JetFlowInformationProvider flowInformationProvider = computeFlowData(function, bodyExpression);\n                        return semanticServices.getTypeInferrerServices(trace, flowInformationProvider).inferFunctionReturnType(scope, function, functionDescriptor);\n                    }\n                });\n            }\n            else {\n                trace.getErrorHandler().genericError(function.asElement().getNode(), \"This function must either declare a return type or have a body element\");\n                returnType = ErrorUtils.createErrorType(\"No type, no body\");\n            }\n        }\n        MemberModifiers defaultModifiers;\n        if (containingDescriptor instanceof ClassDescriptor) {\n            boolean isDefinitelyAbstract = ((ClassDescriptor) containingDescriptor).getModifiers().isTrait() && function.getBodyExpression() == null;\n            defaultModifiers = new MemberModifiers(isDefinitelyAbstract, isDefinitelyAbstract, false);\n        } else {\n            defaultModifiers = MemberModifiers.DEFAULT_MODIFIERS;\n        }\n        MemberModifiers memberModifiers = resolveMemberModifiers(function.getModifierList(), defaultModifiers);\n\n        functionDescriptor.initialize(\n                receiverType,\n                typeParameterDescriptors,\n                valueParameterDescriptors,\n                returnType,\n                memberModifiers);\n\n        trace.record(BindingContext.FUNCTION, function, functionDescriptor);\n        return functionDescriptor;\n    }","commit_id":"c798503c81d3de73f8d4c4244f125cb314697db3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private MemberModifiers resolveMemberModifiers(@Nullable JetModifierList modifierList, @NotNull MemberModifiers defaultModifiers) {\n        if (modifierList == null) return defaultModifiers;\n        return new MemberModifiers(\n                modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD),\n                modifierList.hasModifier(JetTokens.VIRTUAL_KEYWORD),\n                modifierList.hasModifier(JetTokens.OVERRIDE_KEYWORD)\n        );\n    }","id":88327,"modified_method":"@NotNull\n    private MemberModifiers resolveMemberModifiers(@Nullable JetModifierList modifierList, @NotNull MemberModifiers defaultModifiers) {\n        if (modifierList == null) return defaultModifiers;\n        boolean abstractModifier = modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD);\n        boolean virtualModifier = modifierList.hasModifier(JetTokens.VIRTUAL_KEYWORD);\n        boolean overrideModifier = modifierList.hasModifier(JetTokens.OVERRIDE_KEYWORD);\n        return new MemberModifiers(\n                abstractModifier || defaultModifiers.isAbstract(),\n                virtualModifier || abstractModifier || overrideModifier || defaultModifiers.isVirtual(),\n                overrideModifier || defaultModifiers.isOverride()\n        );\n    }","commit_id":"c798503c81d3de73f8d4c4244f125cb314697db3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static ClassModifiers resolveClassModifiers(@Nullable JetModifierList modifierList) {\n        if (modifierList == null) return ClassModifiers.DEFAULT_MODIFIERS;\n        boolean abstractModifier = modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD);\n        boolean traitModifier = modifierList.hasModifier(JetTokens.TRAIT_KEYWORD);\n        boolean enumModifier = modifierList.hasModifier(JetTokens.ENUM_KEYWORD);\n        return new ClassModifiers(\n                abstractModifier || traitModifier,\n                modifierList.hasModifier(JetTokens.OPEN_KEYWORD) || abstractModifier || traitModifier,\n                traitModifier,\n                enumModifier\n        );\n    }","id":88328,"modified_method":"private static ClassModifiers resolveClassModifiers(@Nullable JetModifierList modifierList) {\n        if (modifierList == null) return ClassModifiers.DEFAULT_MODIFIERS;\n        boolean abstractModifier = modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD);\n        boolean traitModifier = modifierList.hasModifier(JetTokens.TRAIT_KEYWORD);\n        boolean enumModifier = modifierList.hasModifier(JetTokens.ENUM_KEYWORD);\n        boolean openModifier = modifierList.hasModifier(JetTokens.OPEN_KEYWORD);\n        return new ClassModifiers(\n                abstractModifier || traitModifier,\n                openModifier || abstractModifier || traitModifier,\n                traitModifier,\n                enumModifier\n        );\n    }","commit_id":"c798503c81d3de73f8d4c4244f125cb314697db3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public FunctionDescriptor resolveMethodToFunctionDescriptor(DeclarationDescriptor owner, PsiClass psiClass, TypeSubstitutor typeSubstitutorForGenericSuperclasses, PsiMethod method) {\n        PsiType returnType = method.getReturnType();\n        if (returnType == null) {\n            return null;\n        }\n        FunctionDescriptor functionDescriptor = methodDescriptorCache.get(method);\n        if (functionDescriptor != null) {\n            if (method.getContainingClass() != psiClass) {\n                functionDescriptor = functionDescriptor.substitute(typeSubstitutorForGenericSuperclasses);\n            }\n            return functionDescriptor;\n        }\n        PsiParameter[] parameters = method.getParameterList().getParameters();\n        FunctionDescriptorImpl functionDescriptorImpl = new FunctionDescriptorImpl(\n                owner,\n                Collections.<AnnotationDescriptor>emptyList(), // TODO\n                method.getName()\n        );\n        methodDescriptorCache.put(method, functionDescriptorImpl);\n        functionDescriptorImpl.initialize(\n                null,\n                resolveTypeParameters(functionDescriptorImpl, method.getTypeParameters()),\n                semanticServices.getDescriptorResolver().resolveParameterDescriptors(functionDescriptorImpl, parameters),\n                semanticServices.getTypeTransformer().transformToType(returnType),\n                MemberModifiers.DEFAULT_MODIFIERS //TODO\n        );\n        semanticServices.getTrace().record(BindingContext.FUNCTION, method, functionDescriptorImpl);\n        FunctionDescriptor substitutedFunctionDescriptor = functionDescriptorImpl;\n        if (method.getContainingClass() != psiClass) {\n            substitutedFunctionDescriptor = functionDescriptorImpl.substitute(typeSubstitutorForGenericSuperclasses);\n        }\n        return substitutedFunctionDescriptor;\n    }","id":88329,"modified_method":"@Nullable\n    public FunctionDescriptor resolveMethodToFunctionDescriptor(DeclarationDescriptor owner, PsiClass psiClass, TypeSubstitutor typeSubstitutorForGenericSuperclasses, PsiMethod method) {\n        PsiType returnType = method.getReturnType();\n        if (returnType == null) {\n            return null;\n        }\n        FunctionDescriptor functionDescriptor = methodDescriptorCache.get(method);\n        if (functionDescriptor != null) {\n            if (method.getContainingClass() != psiClass) {\n                functionDescriptor = functionDescriptor.substitute(typeSubstitutorForGenericSuperclasses);\n            }\n            return functionDescriptor;\n        }\n        PsiParameter[] parameters = method.getParameterList().getParameters();\n        FunctionDescriptorImpl functionDescriptorImpl = new FunctionDescriptorImpl(\n                owner,\n                Collections.<AnnotationDescriptor>emptyList(), // TODO\n                method.getName()\n        );\n        methodDescriptorCache.put(method, functionDescriptorImpl);\n        functionDescriptorImpl.initialize(\n                null,\n                resolveTypeParameters(functionDescriptorImpl, method.getTypeParameters()),\n                semanticServices.getDescriptorResolver().resolveParameterDescriptors(functionDescriptorImpl, parameters),\n                semanticServices.getTypeTransformer().transformToType(returnType),\n                new MemberModifiers(method.hasModifierProperty(PsiModifier.ABSTRACT), !method.hasModifierProperty(PsiModifier.FINAL), false)\n        );\n        semanticServices.getTrace().record(BindingContext.FUNCTION, method, functionDescriptorImpl);\n        FunctionDescriptor substitutedFunctionDescriptor = functionDescriptorImpl;\n        if (method.getContainingClass() != psiClass) {\n            substitutedFunctionDescriptor = functionDescriptorImpl.substitute(typeSubstitutorForGenericSuperclasses);\n        }\n        return substitutedFunctionDescriptor;\n    }","commit_id":"c798503c81d3de73f8d4c4244f125cb314697db3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void bindOverridesInAClass(MutableClassDescriptor classDescriptor) {\n\n        for (FunctionDescriptor declaredFunction : classDescriptor.getFunctions()) {\n//            JetFunction function = (JetFunction) trace.get(BindingContext.DESCRIPTOR_TO_DECLARATION, declaredFunction);\n//            boolean isOverride = declaredFunction.getModifiers().isOverride();\n            for (JetType supertype : classDescriptor.getTypeConstructor().getSupertypes()) {\n                FunctionDescriptor overridden = findFunctionOverridableBy(declaredFunction, supertype);\n                if (overridden != null) {\n//                    if (isOverride && !overridden.getModifiers().isOverridable()) {\n//                        trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.OVERRIDE_KEYWORD),\n//                                                             \"Method \" + overridden.getName() + \" in \" + overridden.getContainingDeclaration().getName() + \" is final and can not be overridden\");\n//                        isOverride = false;\n//                    }\n                    ((FunctionDescriptorImpl) declaredFunction).addOverriddenFunction(overridden);\n                }\n            }\n//            if (declaredFunction.getModifiers().isOverride() && declaredFunction.getOverriddenDescriptors().size() == 0) {\n//                trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.OVERRIDE_KEYWORD),\n//                                                     \"Method \" + declaredFunction.getName() + \" overrides nothing\");\n            }\n//            if (!declaredFunction.getModifiers().isOverride() && declaredFunction.getOverriddenDescriptors().size() > 0) {\n//                FunctionDescriptor overriddenMethod = declaredFunction.getOverriddenDescriptors().iterator().next();\n//                trace.getErrorHandler().genericError(function.getNameIdentifier().getNode(),\n//                                                     \"Method \" + declaredFunction.getName() + \" overrides method \" + overriddenMethod.getName() + \" in class \" +\n//                                                     overriddenMethod.getContainingDeclaration().getName() + \" and needs 'override' modifier\");\n            }","id":88330,"modified_method":"protected void bindOverridesInAClass(MutableClassDescriptor classDescriptor) {\n\n        for (FunctionDescriptor declaredFunction : classDescriptor.getFunctions()) {\n            JetFunction function = (JetFunction) trace.get(BindingContext.DESCRIPTOR_TO_DECLARATION, declaredFunction);\n            assert function != null;\n            JetModifierList modifierList = function.getModifierList();\n            ASTNode overrideNode = modifierList != null ? modifierList.getModifierNode(JetTokens.OVERRIDE_KEYWORD) : null;\n            boolean hasOverrideModifier = overrideNode != null;\n            boolean foundError = false;\n            for (JetType supertype : classDescriptor.getTypeConstructor().getSupertypes()) {\n                FunctionDescriptor overridden = findFunctionOverridableBy(declaredFunction, supertype);\n                if (overridden != null) {\n                    if (hasOverrideModifier && !overridden.getModifiers().isVirtual() && !foundError) {\n                        trace.getErrorHandler().genericError(overrideNode, \"Method \" + overridden.getName() + \" in \" + overridden.getContainingDeclaration().getName() + \" is final and can not be overridden\");\n                        foundError = true;\n                    }\n                    ((FunctionDescriptorImpl) declaredFunction).addOverriddenFunction(overridden);\n                }\n            }\n            if (hasOverrideModifier && declaredFunction.getOverriddenDescriptors().size() == 0) {\n                trace.getErrorHandler().genericError(overrideNode, \"Method \" + declaredFunction.getName() + \" overrides nothing\");\n            }\n            PsiElement nameIdentifier = function.getNameIdentifier();\n            if (!hasOverrideModifier && declaredFunction.getOverriddenDescriptors().size() > 0 && nameIdentifier != null) {\n                FunctionDescriptor overriddenMethod = declaredFunction.getOverriddenDescriptors().iterator().next();\n                trace.getErrorHandler().genericError(nameIdentifier.getNode(),\n                                                     \"Method \" + declaredFunction.getName() + \" overrides method \" + overriddenMethod.getName() + \" in class \" +\n                                                     overriddenMethod.getContainingDeclaration().getName() + \" and needs 'override' modifier\");\n            }\n        }\n    }","commit_id":"c798503c81d3de73f8d4c4244f125cb314697db3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void checkFunction(JetNamedFunction function, FunctionDescriptor functionDescriptor, DeclarationDescriptor containingDescriptor) {\n        PsiElement nameIdentifier = function.getNameIdentifier();\n        boolean isAbstract = functionDescriptor.getModifiers().isAbstract();\n        if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) containingDescriptor;\n            boolean inTrait = classDescriptor.getModifiers().isTrait();\n            boolean inEnum = classDescriptor.getModifiers().isEnum();\n            boolean inAbstractClass = classDescriptor.getModifiers().isAbstract();\n            if (isAbstract && !inAbstractClass && !inTrait && !inEnum) {\n                trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                     \"Abstract method \" + function.getName() + \" in non-abstract class \" + classDescriptor.getName());\n            }\n            if (isAbstract && inTrait) {\n                trace.getErrorHandler().genericWarning(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                     \"Abstract modifier is not necessary in traits\");\n            }\n            if (function.getBodyExpression() != null && isAbstract) {\n                trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                     \"Method \" + function.getName() + \" with body can not be abstract\");\n            }\n            if (function.getBodyExpression() == null && !isAbstract && !inTrait && nameIdentifier != null) {\n                trace.getErrorHandler().genericError(nameIdentifier.getNode(), \"Method \" + function.getName() + \" without body must be abstract\");\n            }\n            return;\n        }\n        if (isAbstract) {\n            trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                 \"Global function \" + function.getName() + \" can not be abstract\");\n        }\n        if (function.getBodyExpression() == null && !isAbstract && nameIdentifier != null) {\n            trace.getErrorHandler().genericError(nameIdentifier.getNode(), \"Global function \" + function.getName() + \" must have body\");\n        }\n    }","id":88331,"modified_method":"protected void checkFunction(JetNamedFunction function, FunctionDescriptor functionDescriptor, DeclarationDescriptor containingDescriptor) {\n        PsiElement nameIdentifier = function.getNameIdentifier();\n        JetModifierList modifierList = function.getModifierList();\n        ASTNode abstractNode = modifierList != null ? modifierList.getModifierNode(JetTokens.ABSTRACT_KEYWORD) : null;\n        boolean hasAbstractModifier = abstractNode != null;\n        if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) containingDescriptor;\n            boolean inTrait = classDescriptor.getModifiers().isTrait();\n            boolean inEnum = classDescriptor.getModifiers().isEnum();\n            boolean inAbstractClass = classDescriptor.getModifiers().isAbstract();\n            if (hasAbstractModifier && !inAbstractClass && !inTrait && !inEnum) {\n                trace.getErrorHandler().genericError(abstractNode, \"Abstract method \" + function.getName() + \" in non-abstract class \" + classDescriptor.getName());\n            }\n            if (hasAbstractModifier && inTrait) {\n                trace.getErrorHandler().genericWarning(abstractNode, \"Abstract modifier is not necessary in traits\");\n            }\n            if (function.getBodyExpression() != null && hasAbstractModifier) {\n                trace.getErrorHandler().genericError(abstractNode, \"Method \" + function.getName() + \" with body can not be abstract\");\n            }\n            if (function.getBodyExpression() == null && !hasAbstractModifier && !inTrait && nameIdentifier != null) {\n                trace.getErrorHandler().genericError(nameIdentifier.getNode(), \"Method \" + function.getName() + \" without body must be abstract\");\n            }\n            return;\n        }\n        if (hasAbstractModifier) {\n            trace.getErrorHandler().genericError(abstractNode, \"Function \" + function.getName() + \" can not be abstract\");\n        }\n        if (function.getBodyExpression() == null && !hasAbstractModifier && nameIdentifier != null) {\n            trace.getErrorHandler().genericError(nameIdentifier.getNode(), \"Function \" + function.getName() + \" must have body\");\n        }\n    }","commit_id":"c798503c81d3de73f8d4c4244f125cb314697db3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initialize(ExtensionContext context) {\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WebDefinition.INSTANCE);\n        registration.registerOperationHandler(DESCRIBE, GenericSubsystemDescribeHandler.INSTANCE, GenericSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerXMLElementWriter(WebSubsystemParser.getInstance());\n\n        // connectors\n        final ManagementResourceRegistration connectors = registration.registerSubModel(WebConnectorDefinition.INSTANCE);\n\n        final ManagementResourceRegistration ssl = connectors.registerSubModel(WebSSLDefinition.INSTANCE);\n\n        //hosts\n        final ManagementResourceRegistration hosts = registration.registerSubModel(WebVirtualHostDefinition.INSTANCE);\n\n        // access-log.\n        final ManagementResourceRegistration accesslog = hosts.registerSubModel(WebAccessLogDefinition.INSTANCE);\n\n        // access-log.\n        // the directory needs one level more\n        accesslog.registerSubModel(WebAccessLogDirectoryDefinition.INSTANCE);\n\n        // sso valve.\n        hosts.registerSubModel(WebSSODefinition.INSTANCE);\n\n        // rewrite valve.\n        final ManagementResourceRegistration rewrite = hosts.registerSubModel(WebReWriteDefinition.INSTANCE);\n\n        // the condition needs one level more\n        rewrite.registerSubModel(WebReWriteConditionDefinition.INSTANCE);\n\n        // configuration=jsp\n        registration.registerSubModel(WebJSPDefinition.INSTANCE);\n\n        // configuration=resources\n        registration.registerSubModel(WebStaticResources.INSTANCE);\n\n        // configuration=container\n        registration.registerSubModel(WebContainerDefinition.INSTANCE);\n\n        //deployment\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(WebDeploymentDefinition.INSTANCE);\n        deployments.registerSubModel(WebDeploymentServletDefinition.INSTANCE);\n    }","id":88332,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initialize(ExtensionContext context) {\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WebDefinition.INSTANCE);\n        registration.registerOperationHandler(DESCRIBE, GenericSubsystemDescribeHandler.INSTANCE, GenericSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerXMLElementWriter(WebSubsystemParser.getInstance());\n\n        // connectors\n        final ManagementResourceRegistration connectors = registration.registerSubModel(WebConnectorDefinition.INSTANCE);\n\n        final ManagementResourceRegistration ssl = connectors.registerSubModel(WebSSLDefinition.INSTANCE);\n        connectors.registerAlias(SSL_ALIAS, new StandardWebExtensionAliasEntry(ssl));\n\n        //hosts\n        final ManagementResourceRegistration hosts = registration.registerSubModel(WebVirtualHostDefinition.INSTANCE);\n\n        // access-log.\n        final ManagementResourceRegistration accesslog = hosts.registerSubModel(WebAccessLogDefinition.INSTANCE);\n        hosts.registerAlias(ACCESS_LOG_ALIAS, new StandardWebExtensionAliasEntry(accesslog));\n\n        // access-log.\n        // the directory needs one level more\n        final ManagementResourceRegistration accessLogDir = accesslog.registerSubModel(WebAccessLogDirectoryDefinition.INSTANCE);\n        accesslog.registerAlias(DIRECTORY_ALIAS, new StandardWebExtensionAliasEntry(accessLogDir));\n\n        // sso valve.\n        final ManagementResourceRegistration sso = hosts.registerSubModel(WebSSODefinition.INSTANCE);\n        hosts.registerAlias(SSO_ALIAS, new StandardWebExtensionAliasEntry(sso));\n\n        // rewrite valve.\n        final ManagementResourceRegistration rewrite = hosts.registerSubModel(WebReWriteDefinition.INSTANCE);\n\n        // the condition needs one level more\n        rewrite.registerSubModel(WebReWriteConditionDefinition.INSTANCE);\n\n        // configuration=jsp\n        registration.registerSubModel(WebJSPDefinition.INSTANCE);\n\n        // configuration=resources\n        registration.registerSubModel(WebStaticResources.INSTANCE);\n\n        // configuration=container\n        registration.registerSubModel(WebContainerDefinition.INSTANCE);\n\n        //deployment\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(WebDeploymentDefinition.INSTANCE);\n        deployments.registerSubModel(WebDeploymentServletDefinition.INSTANCE);\n    }","commit_id":"7565c97701ab7668649a20c077d5bbedcc2bbb18","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerChildren(ManagementResourceRegistration resourceRegistration) {\n        super.registerChildren(resourceRegistration);\n        resourceRegistration.registerSubModel(new LoginModuleResourceDefinition(Constants.LOGIN_MODULE));\n    }","id":88333,"modified_method":"@Override\n    public void registerChildren(ManagementResourceRegistration resourceRegistration) {\n        super.registerChildren(resourceRegistration);\n        ManagementResourceRegistration moduleReg = resourceRegistration.registerSubModel(new LoginModuleResourceDefinition(Constants.ACL_MODULE));\n\n        //https://issues.jboss.org/browse/WFLY-2474 acl-module was wrongly called login-module in 7.2.0\n        resourceRegistration.registerAlias(\n                PathElement.pathElement(Constants.LOGIN_MODULE),\n                new AliasEntry(moduleReg) {\n                    @Override\n                    public PathAddress convertToTargetAddress(PathAddress address) {\n                        PathElement element = address.getLastElement();\n                        element = PathElement.pathElement(Constants.ACL_MODULE, element.getValue());\n                        return address.subAddress(0, address.size() -1).append(element);\n                    }\n                });\n\n    }","commit_id":"1879feb245313753100d3585aa149efdc3ab261d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testTransformers_1_2_x(ModelTestControllerVersion controllerVersion, int micro) throws Exception {\n        ModelVersion modelVersion = ModelVersion.create(1, 2, micro);\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT);\n\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-security:\" + controllerVersion.getMavenGavVersion())\n                .dontPersistXml();\n\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        Assert.assertTrue(mainServices.getLegacyServices(modelVersion).isSuccessfulBoot());\n        ModelTestUtils.checkFailedTransformedBootOperations(\n                mainServices,\n                modelVersion,\n                builder.parseXml(readResource(\"transformers.xml\")),\n                new FailedOperationTransformationConfig()\n        );\n\n        ModelNode composite = Util.createEmptyOperation(\"composite\", null);\n        ModelNode steps = composite.get(STEPS);\n\n        PathAddress secDomAddr = getSecurityDomainAddress(\"modules\");\n        steps.add(Util.createEmptyOperation(\"add\", secDomAddr));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUDIT, Constants.CLASSIC)), Constants.PROVIDER_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUTHENTICATION, Constants.CLASSIC)), Constants.LOGIN_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUTHENTICATION, Constants.JASPI)), Constants.AUTH_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUTHORIZATION, Constants.CLASSIC)), Constants.POLICY_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.IDENTITY_TRUST, Constants.CLASSIC)), Constants.TRUST_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.MAPPING, Constants.CLASSIC)), Constants.MAPPING_MODULES));\n\n        ModelTestUtils.checkOutcome(mainServices.executeOperation(composite));\n        ModelTestUtils.checkOutcome(mainServices.executeOperation(modelVersion, mainServices.transformOperation(modelVersion, composite)));\n\n        checkSubsystemModelTransformation(mainServices, modelVersion);\n    }","id":88334,"modified_method":"private void testTransformers_1_2_x(ModelTestControllerVersion controllerVersion, int micro) throws Exception {\n        ModelVersion modelVersion = ModelVersion.create(1, 2, micro);\n        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)\n                .setSubsystemXmlResource(\"transformers.xml\");\n\n\n        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)\n                .addMavenResourceURL(\"org.jboss.as:jboss-as-security:\" + controllerVersion.getMavenGavVersion())\n                .dontPersistXml();\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        Assert.assertTrue(mainServices.getLegacyServices(modelVersion).isSuccessfulBoot());\n//        ModelTestUtils.checkFailedTransformedBootOperations(\n//                mainServices,\n//                modelVersion,\n//                builder.parseXml(readResource(\"transformers.xml\")),\n//                new FailedOperationTransformationConfig()\n//        );\n        checkSubsystemModelTransformation(mainServices, modelVersion, new ModelFixer() {\n            @Override\n            public ModelNode fixModel(ModelNode modelNode) {\n                //https://issues.jboss.org/browse/WFLY-2474 acl-module was wrongly called login-module in 7.2.0\n                ModelNode node = modelNode.get(\"security-domain\", \"other\", \"acl\", \"classic\").get(\"login-module\");\n                modelNode.get(\"security-domain\", \"other\", \"acl\", \"classic\", \"acl-modules\").add(node.get(\"AclThingy\"));\n                return modelNode;\n            }});\n\n        ModelNode composite = Util.createEmptyOperation(\"composite\", null);\n        ModelNode steps = composite.get(STEPS);\n\n        PathAddress secDomAddr = getSecurityDomainAddress(\"modules\");\n        steps.add(Util.createEmptyOperation(\"add\", secDomAddr));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUDIT, Constants.CLASSIC)), Constants.PROVIDER_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUTHENTICATION, Constants.CLASSIC)), Constants.LOGIN_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUTHENTICATION, Constants.JASPI)), Constants.AUTH_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.AUTHORIZATION, Constants.CLASSIC)), Constants.POLICY_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.IDENTITY_TRUST, Constants.CLASSIC)), Constants.TRUST_MODULES));\n        steps.add(getSecurityDomainComponentAdd(secDomAddr.append(PathElement.pathElement(Constants.MAPPING, Constants.CLASSIC)), Constants.MAPPING_MODULES));\n\n        ModelTestUtils.checkOutcome(mainServices.executeOperation(composite));\n        ModelTestUtils.checkOutcome(mainServices.executeOperation(modelVersion, mainServices.transformOperation(modelVersion, composite)));\n\n    }","commit_id":"1879feb245313753100d3585aa149efdc3ab261d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecuritySubsystemRootResourceDefinition.DEEP_COPY_SUBJECT_MODE);\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecurityDomainResourceDefinition.CACHE_TYPE).end();\n\n\n        ModulesToAttributeTransformer loginModule = new ModulesToAttributeTransformer(Constants.LOGIN_MODULE, Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, loginModule);\n        final ModulesToAttributeTransformer policyModule = new ModulesToAttributeTransformer(Constants.POLICY_MODULE, Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule);\n        final ModulesToAttributeTransformer mappingModule = new ModulesToAttributeTransformer(Constants.MAPPING_MODULE, Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule);\n        final ModulesToAttributeTransformer providerModule = new ModulesToAttributeTransformer(Constants.PROVIDER_MODULE, Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule);\n        final ModulesToAttributeTransformer identityTrustModule = new ModulesToAttributeTransformer(Constants.TRUST_MODULE, Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule);\n        final ModulesToAttributeTransformer authModule = new ModulesToAttributeTransformer(Constants.AUTH_MODULE, Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule);\n\n        //todo check if there are cases when child is created before authentication=jaspi\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, loginModule);\n\n        //reject expressions\n        builder.addChildResource(VAULT_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, VaultResourceDefinition.OPTIONS)\n                .end();\n        securityDomain.addChildResource(JSSE_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, JSSEResourceDefinition.ADDITIONAL_PROPERTIES)\n                /*.addRejectCheck(new RejectAttributeChecker.ObjectFieldsRejectAttributeChecker(\n                        Collections.singletonMap(JSSEResourceDefinition.ADDITIONAL_PROPERTIES.getName(), RejectAttributeChecker.SIMPLE_EXPRESSIONS))\n                        , JSSEResourceDefinition.ADDITIONAL_PROPERTIES)*/\n                .end();\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));\n    }","id":88335,"modified_method":"private void registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecuritySubsystemRootResourceDefinition.DEEP_COPY_SUBJECT_MODE);\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecurityDomainResourceDefinition.CACHE_TYPE).end();\n\n\n        ModulesToAttributeTransformer loginModule = new ModulesToAttributeTransformer(Constants.LOGIN_MODULE, Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, loginModule);\n        final ModulesToAttributeTransformer policyModule = new ModulesToAttributeTransformer(Constants.POLICY_MODULE, Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule);\n        final ModulesToAttributeTransformer mappingModule = new ModulesToAttributeTransformer(Constants.MAPPING_MODULE, Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule);\n        final ModulesToAttributeTransformer providerModule = new ModulesToAttributeTransformer(Constants.PROVIDER_MODULE, Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule);\n        final ModulesToAttributeTransformer identityTrustModule = new ModulesToAttributeTransformer(Constants.TRUST_MODULE, Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule);\n        final ModulesToAttributeTransformer aclModule = new ModulesToAttributeTransformer(Constants.ACL_MODULE, Constants.ACL_MODULES);\n        registerModuleTransformer(securityDomain, ACL_PATH, aclModule);\n\n        final ModulesToAttributeTransformer authModule = new ModulesToAttributeTransformer(Constants.AUTH_MODULE, Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule);\n\n        //todo check if there are cases when child is created before authentication=jaspi\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, loginModule);\n\n        //reject expressions\n        builder.addChildResource(VAULT_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, VaultResourceDefinition.OPTIONS)\n                .end();\n        securityDomain.addChildResource(JSSE_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, JSSEResourceDefinition.ADDITIONAL_PROPERTIES)\n                /*.addRejectCheck(new RejectAttributeChecker.ObjectFieldsRejectAttributeChecker(\n                        Collections.singletonMap(JSSEResourceDefinition.ADDITIONAL_PROPERTIES.getName(), RejectAttributeChecker.SIMPLE_EXPRESSIONS))\n                        , JSSEResourceDefinition.ADDITIONAL_PROPERTIES)*/\n                .end();\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));\n    }","commit_id":"1879feb245313753100d3585aa149efdc3ab261d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_2_0(SubsystemRegistration subsystemRegistration) {\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n\n        // Transform any add op that includes the module list attribute into a compsosite of an add w/o that + write-attribute\n        AttributeToModulesTransformer loginModule = new AttributeToModulesTransformer(Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, loginModule);\n        AttributeToModulesTransformer policyModule = new AttributeToModulesTransformer(Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule);\n        AttributeToModulesTransformer mappingModule = new AttributeToModulesTransformer(Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule);\n        AttributeToModulesTransformer providerModule = new AttributeToModulesTransformer(Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule);\n        final AttributeToModulesTransformer identityTrustModule = new AttributeToModulesTransformer(Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule);\n\n        AttributeToModulesTransformer authModule = new AttributeToModulesTransformer(Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule);\n\n        // the module attribute is not recognized in the 1.2.0 version of the subsystem.\n        jaspiReg.addChildResource(PathElement.pathElement(Constants.AUTH_MODULE)).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, Constants.MODULE)\n                .end();\n\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, loginModule);\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 2, 0));\n    }","id":88336,"modified_method":"private void registerTransformers_1_2_0(SubsystemRegistration subsystemRegistration) {\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n\n        // Transform any add op that includes the module list attribute into a compsosite of an add w/o that + write-attribute\n        AttributeToModulesTransformer loginModule = new AttributeToModulesTransformer(Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, loginModule);\n        AttributeToModulesTransformer policyModule = new AttributeToModulesTransformer(Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule);\n        AttributeToModulesTransformer mappingModule = new AttributeToModulesTransformer(Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule);\n        AttributeToModulesTransformer providerModule = new AttributeToModulesTransformer(Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule);\n        final AttributeToModulesTransformer identityTrustModule = new AttributeToModulesTransformer(Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule);\n        final AttributeToModulesTransformer aclModule = new AttributeToModulesTransformer(Constants.ACL_MODULES);\n        ResourceTransformationDescriptionBuilder aclBuilder = registerModuleTransformer(securityDomain, ACL_PATH, aclModule);\n        //https://issues.jboss.org/browse/WFLY-2474 acl-module was wrongly called login-module in 7.2.0\n        aclBuilder.addChildRedirection(PathElement.pathElement(Constants.ACL_MODULE), PathElement.pathElement(Constants.LOGIN_MODULE));\n\n        AttributeToModulesTransformer authModule = new AttributeToModulesTransformer(Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule);\n\n        // the module attribute is not recognized in the 1.2.0 version of the subsystem.\n        jaspiReg.addChildResource(PathElement.pathElement(Constants.AUTH_MODULE)).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, Constants.MODULE)\n                .end();\n\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, loginModule);\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 2, 0));\n    }","commit_id":"1879feb245313753100d3585aa149efdc3ab261d","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeACL(XMLExtendedStreamWriter writer, ModelNode modelNode) throws XMLStreamException {\n        if (modelNode.isDefined() && modelNode.asInt() > 0) {\n            writer.writeStartElement(Element.ACL.getLocalName());\n            writeLoginModule(writer, modelNode, Constants.ACL_MODULE);\n            writer.writeEndElement();\n        }\n    }","id":88337,"modified_method":"private void writeACL(XMLExtendedStreamWriter writer, ModelNode modelNode) throws XMLStreamException {\n        if (modelNode.isDefined() && modelNode.asInt() > 0) {\n            writer.writeStartElement(Element.ACL.getLocalName());\n            writeLoginModule(writer, modelNode, Constants.ACL_MODULE, Element.ACL_MODULE.getLocalName());\n            writer.writeEndElement();\n        }\n    }","commit_id":"1879feb245313753100d3585aa149efdc3ab261d","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Entry<String,List<String>> bug345449() {\n    Entry<String,List<String>> _xblockexpression = null;\n    {\n      ArrayList<Entry<String,List<String>>> _newArrayList = CollectionLiterals.<Entry<String,List<String>>>newArrayList();\n      final ArrayList<Entry<String,List<String>>> result = _newArrayList;\n      Entry<String,List<String>> _head = IterableExtensions.<Entry<String,List<String>>>head(result);\n      _xblockexpression = (_head);\n    }\n    return _xblockexpression;\n  }","id":88338,"modified_method":"public Entry<String,List<String>> bug345449() {\n    Entry<String,List<String>> _xblockexpression = null;\n    {\n      ArrayList<Entry<String,List<String>>> _newArrayList = CollectionLiterals.<Entry<String,List<String>>>newArrayList();\n      final ArrayList<Entry<String,List<String>>> result = _newArrayList;\n      Entry<String,List<String>> _head = result==null?(Entry<String,List<String>>)null:IterableExtensions.<Entry<String,List<String>>>head(result);\n      _xblockexpression = (_head);\n    }\n    return _xblockexpression;\n  }","commit_id":"3aad49dc42f0535044536ec3aa369a0fb749d06b","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmType getProcessorType(final JvmAnnotationType it) {\n    EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n    final Function1<JvmAnnotationReference,Boolean> _function = new Function1<JvmAnnotationReference,Boolean>() {\n        public Boolean apply(final JvmAnnotationReference it) {\n          JvmAnnotationType _annotation = it.getAnnotation();\n          String _identifier = null;\n          if (_annotation!=null) {\n            _identifier=_annotation.getIdentifier();\n          }\n          String _name = Active.class.getName();\n          boolean _equals = Objects.equal(_identifier, _name);\n          return Boolean.valueOf(_equals);\n        }\n      };\n    final JvmAnnotationReference activeAnnotation = IterableExtensions.<JvmAnnotationReference>findFirst(_annotations, _function);\n    EList<JvmAnnotationValue> _values = activeAnnotation.getValues();\n    final Function1<JvmAnnotationValue,Boolean> _function_1 = new Function1<JvmAnnotationValue,Boolean>() {\n        public Boolean apply(final JvmAnnotationValue it) {\n          boolean _or = false;\n          JvmOperation _operation = it.getOperation();\n          boolean _equals = Objects.equal(_operation, null);\n          if (_equals) {\n            _or = true;\n          } else {\n            JvmOperation _operation_1 = it.getOperation();\n            String _simpleName = _operation_1.getSimpleName();\n            boolean _equals_1 = Objects.equal(_simpleName, \"value\");\n            _or = (_equals || _equals_1);\n          }\n          return Boolean.valueOf(_or);\n        }\n      };\n    final JvmAnnotationValue annoVal = IterableExtensions.<JvmAnnotationValue>findFirst(_values, _function_1);\n    boolean _matched = false;\n    if (!_matched) {\n      if (annoVal instanceof JvmTypeAnnotationValue) {\n        final JvmTypeAnnotationValue _jvmTypeAnnotationValue = (JvmTypeAnnotationValue)annoVal;\n        _matched=true;\n        EList<JvmTypeReference> _values_1 = _jvmTypeAnnotationValue.getValues();\n        JvmTypeReference _head = IterableExtensions.<JvmTypeReference>head(_values_1);\n        return _head.getType();\n      }\n    }\n    if (!_matched) {\n      if (annoVal instanceof JvmCustomAnnotationValue) {\n        final JvmCustomAnnotationValue _jvmCustomAnnotationValue = (JvmCustomAnnotationValue)annoVal;\n        _matched=true;\n        EList<Object> _values_1 = _jvmCustomAnnotationValue.getValues();\n        Object _head = IterableExtensions.<Object>head(_values_1);\n        return ((XTypeLiteral) _head).getType();\n      }\n    }\n    return null;\n  }","id":88339,"modified_method":"public JvmType getProcessorType(final JvmAnnotationType it) {\n    EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n    final Function1<JvmAnnotationReference,Boolean> _function = new Function1<JvmAnnotationReference,Boolean>() {\n        public Boolean apply(final JvmAnnotationReference it) {\n          JvmAnnotationType _annotation = it.getAnnotation();\n          String _identifier = null;\n          if (_annotation!=null) {\n            _identifier=_annotation.getIdentifier();\n          }\n          String _name = Active.class.getName();\n          boolean _equals = Objects.equal(_identifier, _name);\n          return Boolean.valueOf(_equals);\n        }\n      };\n    final JvmAnnotationReference activeAnnotation = IterableExtensions.<JvmAnnotationReference>findFirst(_annotations, _function);\n    EList<JvmAnnotationValue> _values = activeAnnotation.getValues();\n    final Function1<JvmAnnotationValue,Boolean> _function_1 = new Function1<JvmAnnotationValue,Boolean>() {\n        public Boolean apply(final JvmAnnotationValue it) {\n          boolean _or = false;\n          JvmOperation _operation = it.getOperation();\n          boolean _equals = Objects.equal(_operation, null);\n          if (_equals) {\n            _or = true;\n          } else {\n            JvmOperation _operation_1 = it.getOperation();\n            String _simpleName = _operation_1.getSimpleName();\n            boolean _equals_1 = Objects.equal(_simpleName, \"value\");\n            _or = (_equals || _equals_1);\n          }\n          return Boolean.valueOf(_or);\n        }\n      };\n    final JvmAnnotationValue annoVal = IterableExtensions.<JvmAnnotationValue>findFirst(_values, _function_1);\n    boolean _matched = false;\n    if (!_matched) {\n      if (annoVal instanceof JvmTypeAnnotationValue) {\n        final JvmTypeAnnotationValue _jvmTypeAnnotationValue = (JvmTypeAnnotationValue)annoVal;\n        _matched=true;\n        EList<JvmTypeReference> _values_1 = _jvmTypeAnnotationValue.getValues();\n        JvmTypeReference _head = IterableExtensions.<JvmTypeReference>head(_values_1);\n        JvmType _type = null;\n        if (_head!=null) {\n          _type=_head.getType();\n        }\n        return _type;\n      }\n    }\n    if (!_matched) {\n      if (annoVal instanceof JvmCustomAnnotationValue) {\n        final JvmCustomAnnotationValue _jvmCustomAnnotationValue = (JvmCustomAnnotationValue)annoVal;\n        _matched=true;\n        Object _head = null;\n        EList<Object> _values_1 = _jvmCustomAnnotationValue.getValues();\n        if (_values_1!=null) {\n          _head=IterableExtensions.<Object>head(_values_1);\n        }\n        final Object customAnnoVal = _head;\n        boolean _matched_1 = false;\n        if (!_matched_1) {\n          if (customAnnoVal instanceof XTypeLiteral) {\n            final XTypeLiteral _xTypeLiteral = (XTypeLiteral)customAnnoVal;\n            _matched_1=true;\n            return _xTypeLiteral.getType();\n          }\n        }\n        if (!_matched_1) {\n          if (customAnnoVal instanceof XFeatureCall) {\n            final XFeatureCall _xFeatureCall = (XFeatureCall)customAnnoVal;\n            _matched_1=true;\n            JvmIdentifiableElement _feature = _xFeatureCall.getFeature();\n            final JvmIdentifiableElement feature = _feature;\n            boolean _matched_2 = false;\n            if (!_matched_2) {\n              if (feature instanceof JvmType) {\n                final JvmType _jvmType = (JvmType)feature;\n                _matched_2=true;\n                return _jvmType;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"7c60a3b377850a42e9984b77f816dd3f482856da","url":"https://github.com/eclipse/xtext"},{"original_method":"public Entry<String,List<String>> bug345449() {\n    Entry<String,List<String>> _xblockexpression = null;\n    {\n      ArrayList<Entry<String,List<String>>> _newArrayList = CollectionLiterals.<Entry<String,List<String>>>newArrayList();\n      final ArrayList<Entry<String,List<String>>> result = _newArrayList;\n      Entry<String,List<String>> _head = IterableExtensions.<Entry<String,List<String>>>head(result);\n      _xblockexpression = (_head);\n    }\n    return _xblockexpression;\n  }","id":88340,"modified_method":"public Entry<String,List<String>> bug345449() {\n    Entry<String,List<String>> _xblockexpression = null;\n    {\n      ArrayList<Entry<String,List<String>>> _newArrayList = CollectionLiterals.<Entry<String,List<String>>>newArrayList();\n      final ArrayList<Entry<String,List<String>>> result = _newArrayList;\n      Entry<String,List<String>> _head = result==null?(Entry<String,List<String>>)null:IterableExtensions.<Entry<String,List<String>>>head(result);\n      _xblockexpression = (_head);\n    }\n    return _xblockexpression;\n  }","commit_id":"a278dc1b0ca85894b1621595abb18938fbfca4d5","url":"https://github.com/eclipse/xtext"},{"original_method":"DatabaseImporter( String[] args, Config config ) throws IncorrectUsage\n    {\n        Args parsedArgs = Args.parse( args );\n        String database;\n\n        try\n        {\n            database = parsedArgs.interpretOption( \"database\", Converters.mandatory(), s -> s );\n            this.from = parsedArgs.interpretOption( \"from\", Converters.mandatory(), Converters.toFile(),\n                    Validators.CONTAINS_EXISTING_DATABASE );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new IncorrectUsage( e.getMessage() );\n        }\n\n        this.config = config.with( stringMap( DatabaseManagementSystemSettings.active_database.name(), database ) );\n    }","id":88341,"modified_method":"DatabaseImporter( String[] args, Config config ) throws IncorrectUsage\n    {\n        this.config = config;\n        Args parsedArgs = Args.parse( args );\n\n        try\n        {\n            this.from = parsedArgs.interpretOption( \"from\", Converters.mandatory(), Converters.toFile(),\n                    Validators.CONTAINS_EXISTING_DATABASE );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new IncorrectUsage( e.getMessage() );\n        }\n    }","commit_id":"4c2e990d0f07def36731973abf2599d3e19b447a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Config loadNeo4jConfig( Path homeDir, Path configDir )\n    {\n        ConfigLoader configLoader = new ConfigLoader( settings() );\n\n        return configLoader.loadConfig( Optional.of( homeDir.toFile() ),\n                Optional.of( configDir.resolve( \"neo4j.conf\" ).toFile() ) );\n    }","id":88342,"modified_method":"private static Config loadNeo4jConfig( Path homeDir, Path configDir, String databaseName,\n            Map<String,String> additionalConfig )\n    {\n        ConfigLoader configLoader = new ConfigLoader( settings() );\n        Config config = configLoader.loadConfig( Optional.of( homeDir.toFile() ),\n                Optional.of( configDir.resolve( \"neo4j.conf\" ).toFile() ) );\n        additionalConfig.put( DatabaseManagementSystemSettings.active_database.name(), databaseName );\n        return config.with( additionalConfig );\n    }","commit_id":"4c2e990d0f07def36731973abf2599d3e19b447a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void execute( String[] args ) throws IncorrectUsage, CommandFailed\n    {\n        Args parsedArgs = Args.parse( args );\n        String mode;\n\n        try\n        {\n            mode = parsedArgs\n                    .interpretOption( \"mode\", Converters.mandatory(), s -> s, Validators.inList( allowedModes ) );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new IncorrectUsage( e.getMessage() );\n        }\n\n        try\n        {\n            Config config = loadNeo4jConfig( homeDir, configDir );\n            Importer importer;\n\n            switch ( mode )\n            {\n            case \"database\":\n                importer = new DatabaseImporter( args, config );\n                break;\n            case \"csv\":\n                importer = new CsvImporter( args, config );\n                break;\n            default:\n                throw new CommandFailed( \"Invalid mode specified.\" ); // This won't happen because mode is mandatory.\n            }\n\n            importer.doImport();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":88343,"modified_method":"@Override\n    public void execute( String[] args ) throws IncorrectUsage, CommandFailed\n    {\n        Args parsedArgs = Args.parse( args );\n        String mode;\n        File additionalConfigFile;\n\n        try\n        {\n            mode = parsedArgs\n                    .interpretOption( \"mode\", Converters.mandatory(), s -> s, Validators.inList( allowedModes ) );\n            this.database = parsedArgs.interpretOption( \"database\", Converters.mandatory(), s -> s );\n            additionalConfigFile =\n                    parsedArgs.interpretOption( \"additional-config\", Converters.optional(), Converters.toFile() );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new IncorrectUsage( e.getMessage() );\n        }\n\n        try\n        {\n            Config config =\n                    loadNeo4jConfig( homeDir, configDir, this.database, loadAdditionalConfig( additionalConfigFile ) );\n            Importer importer;\n\n            switch ( mode )\n            {\n            case \"database\":\n                importer = new DatabaseImporter( args, config );\n                break;\n            case \"csv\":\n                importer = new CsvImporter( args, config );\n                break;\n            default:\n                throw new CommandFailed( \"Invalid mode specified.\" ); // This won't happen because mode is mandatory.\n            }\n\n            importer.doImport();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"4c2e990d0f07def36731973abf2599d3e19b447a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public Optional<String> arguments()\n        {\n            return Optional.of( \"--mode=<mode> --database=<database-name> --from=<source-directory>\" );\n        }","id":88344,"modified_method":"@Override\n        public Optional<String> arguments()\n        {\n            return Optional.of( \"--mode=<mode> --database=<database-name> --from=<source>\" );\n        }","commit_id":"4c2e990d0f07def36731973abf2599d3e19b447a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static List<Class<?>> settings()\n    {\n        List<Class<?>> settings = new ArrayList<>();\n        settings.add( GraphDatabaseSettings.class );\n        settings.add( DatabaseManagementSystemSettings.class );\n        return settings;\n    }","id":88345,"modified_method":"private static List<Class<?>> settings()\n    {\n        return Arrays.asList( GraphDatabaseSettings.class, DatabaseManagementSystemSettings.class );\n    }","commit_id":"4c2e990d0f07def36731973abf2599d3e19b447a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void makeSureCoreClusterCanBeRestoredFromABackup() throws Throwable\n    {\n        // given\n        CoreGraphDatabase db = createSomeData( cluster );\n        DbRepresentation beforeBackup = DbRepresentation.of( db );\n        String[] args = backupArguments(backupAddress(db), backupPath.getPath() );\n        assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode( args ) );\n\n        // when we shutdown the cluster we lose the number of core servers so we won't go through the for loop unless\n        // we capture the count beforehand\n        List<String> dbPaths = cluster.coreServers().stream().map( GraphDatabaseFacade::getStoreDir ).collect( toList() );\n        int numberOfCoreServers = dbPaths.size();\n\n        cluster.shutdown();\n        assertAllStoresHaveTheSameStoreId( dbPaths, fs );\n        TestStoreId storeId = TestStoreId.readStoreId( dbPaths.get( 0 ), fs );\n\n        // when\n        File initialStoreDir = cluster.coreServerStoreDirectory( 0 );\n        restoreDatabase( backupPath, initialStoreDir );\n        String conversionMetadata = new GenerateClusterSeedCommand().generate( initialStoreDir).getConversionId();\n\n        ConvertClassicStoreCommand convertClassicStoreCommand = new ConvertClassicStoreCommand( new ConversionVerifier() );\n        for ( int i = 0; i < numberOfCoreServers; i++ )\n        {\n            File coreStoreDir = cluster.coreServerStoreDirectory( i );\n            restoreDatabase( backupPath, coreStoreDir );\n            convertClassicStoreCommand.convert( coreStoreDir, StandardV3_0.NAME , conversionMetadata );\n        }\n\n        cluster.start();\n\n        // then\n        Collection<CoreGraphDatabase> coreGraphDatabases = cluster.coreServers();\n        Stream<DbRepresentation> dbRepresentations = coreGraphDatabases.stream().map( DbRepresentation::of );\n        dbRepresentations.forEach( afterReSeed -> assertEquals( beforeBackup, afterReSeed ) );\n\n        List<String> afterRestoreDbPaths = coreGraphDatabases.stream().map( GraphDatabaseFacade::getStoreDir ).collect( toList() );\n        cluster.shutdown();\n\n        assertAllStoresHaveTheSameStoreId( afterRestoreDbPaths, fs );\n        TestStoreId afterRestoreStoreId = TestStoreId.readStoreId( afterRestoreDbPaths.get( 0 ), fs );\n        assertNotEquals( storeId, afterRestoreStoreId );\n    }","id":88346,"modified_method":"@Test\n    public void makeSureCoreClusterCanBeRestoredFromABackup() throws Throwable\n    {\n        // given\n        CoreGraphDatabase db = createSomeData( cluster );\n        DbRepresentation beforeBackup = DbRepresentation.of( db );\n        String[] args = backupArguments(backupAddress(db), backupPath.getPath() );\n        assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode( args ) );\n\n        // when we shutdown the cluster we lose the number of core servers so we won't go through the for loop unless\n        // we capture the count beforehand\n        List<String> dbPaths = cluster.coreServers().stream().map( GraphDatabaseFacade::getStoreDir ).collect( toList() );\n        int numberOfCoreServers = dbPaths.size();\n\n        cluster.shutdown();\n        assertAllStoresHaveTheSameStoreId( dbPaths, fs );\n        TestStoreId storeId = TestStoreId.readStoreId( dbPaths.get( 0 ), fs );\n\n        // when\n        StringBuilder output = RestoreClusterUtils.execute( () -> RestoreNewClusterCli.main( toArray( args()\n                .homeDir( cluster.homeDir( 0 ) ).config( cluster.homeDir( 0 ) ).from( backupPath )\n                .database( \"graph.db\" ).force().build() ) ) );\n\n        String seed = RestoreClusterCliTest.extractSeed( output );\n\n        for ( int i = 1; i < numberOfCoreServers; i++ )\n        {\n            File homeDir = cluster.homeDir( i );\n            RestoreClusterUtils.execute( () -> RestoreExistingClusterCli.main( toArray( args().homeDir( homeDir )\n                    .config( homeDir ).from( backupPath ).database( \"graph.db\" ).seed( seed ).force().build() ) ) );\n        }\n\n        cluster.start();\n\n        // then\n        Collection<CoreGraphDatabase> coreGraphDatabases = cluster.coreServers();\n        Stream<DbRepresentation> dbRepresentations = coreGraphDatabases.stream().map( DbRepresentation::of );\n        dbRepresentations.forEach( afterReSeed -> assertEquals( beforeBackup, afterReSeed ) );\n\n        List<String> afterRestoreDbPaths = coreGraphDatabases.stream().map( GraphDatabaseFacade::getStoreDir ).collect( toList() );\n        cluster.shutdown();\n\n        assertAllStoresHaveTheSameStoreId( afterRestoreDbPaths, fs );\n        TestStoreId afterRestoreStoreId = TestStoreId.readStoreId( afterRestoreDbPaths.get( 0 ), fs );\n        assertNotEquals( storeId, afterRestoreStoreId );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public File coreServerStoreDirectory( int serverId )\n    {\n        return coreServerStoreDirectory( parentDir, serverId );\n    }","id":88347,"modified_method":"public File coreServerStoreDirectory( int serverId )\n    {\n        return coreServerStoreDirectory( homeDir( serverId ) );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static File coreServerStoreDirectory( File parentDir, int serverId )\n    {\n        return new File( parentDir, \"server-core-\" + serverId );\n    }","id":88348,"modified_method":"public static File coreServerStoreDirectory( File neo4jHome )\n    {\n        return new File( new File( new File( neo4jHome, \"data\" ), \"databases\" ), \"graph.db\" );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private CoreGraphDatabase startCoreServer( int serverId, int clusterSize, List<AdvertisedSocketAddress> addresses,\n                                               Map<String, String> extraParams,\n                                               Map<String, IntFunction<String>> instanceExtraParams,\n                                               String recordFormat )\n    {\n        int clusterPort = 5000 + serverId;\n        int txPort = 6000 + serverId;\n        int raftPort = 7000 + serverId;\n        int boltPort = 8000 + serverId;\n\n        String initialHosts = addresses.stream().map( AdvertisedSocketAddress::toString ).collect( joining( \",\" ) );\n\n        final Map<String, String> params = serverParams( \"CORE\", serverId, initialHosts );\n\n        params.put( GraphDatabaseSettings.record_format.name(), recordFormat );\n\n        params.put( CoreEdgeClusterSettings.cluster_listen_address.name(), \"localhost:\" + clusterPort );\n\n        params.put( CoreEdgeClusterSettings.transaction_advertised_address.name(), \"localhost:\" + txPort );\n        params.put( CoreEdgeClusterSettings.transaction_listen_address.name(), \"127.0.0.1:\" + txPort );\n        params.put( CoreEdgeClusterSettings.raft_advertised_address.name(), \"localhost:\" + raftPort );\n        params.put( CoreEdgeClusterSettings.raft_listen_address.name(), \"127.0.0.1:\" + raftPort );\n\n        params.put( new GraphDatabaseSettings.BoltConnector( \"bolt\" ).type.name(), \"BOLT\" );\n        params.put( new GraphDatabaseSettings.BoltConnector( \"bolt\" ).enabled.name(), \"true\" );\n        params.put( new GraphDatabaseSettings.BoltConnector( \"bolt\" ).address.name(), \"0.0.0.0:\" + boltPort );\n\n        params.put( GraphDatabaseSettings.bolt_advertised_address.name(), \"127.0.0.1:\" + boltPort );\n\n        params.put( CoreEdgeClusterSettings.expected_core_cluster_size.name(), String.valueOf( clusterSize ) );\n        params.put( GraphDatabaseSettings.pagecache_memory.name(), \"8m\" );\n        params.put( GraphDatabaseSettings.auth_store.name(), new File( parentDir, \"auth\" ).getAbsolutePath() );\n\n        params.putAll( extraParams );\n\n        for ( Map.Entry<String, IntFunction<String>> entry : instanceExtraParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue().apply( serverId ) );\n        }\n\n        final File storeDir = coreServerStoreDirectory( parentDir, serverId );\n        params.put( GraphDatabaseSettings.logs_directory.name(), storeDir.getAbsolutePath() );\n        return new CoreGraphDatabase( storeDir, params, GraphDatabaseDependencies.newDependencies(),\n                discoveryServiceFactory );\n    }","id":88349,"modified_method":"private CoreGraphDatabase startCoreServer( int serverId, int clusterSize, List<AdvertisedSocketAddress> addresses,\n                                               Map<String, String> extraParams,\n                                               Map<String, IntFunction<String>> instanceExtraParams,\n                                               String recordFormat )\n    {\n        int clusterPort = 5000 + serverId;\n        int txPort = 6000 + serverId;\n        int raftPort = 7000 + serverId;\n        int boltPort = 8000 + serverId;\n\n        String initialHosts = addresses.stream().map( AdvertisedSocketAddress::toString ).collect( joining( \",\" ) );\n\n        final Map<String, String> params = serverParams( \"CORE\", serverId, initialHosts );\n\n        params.put( GraphDatabaseSettings.record_format.name(), recordFormat );\n\n        params.put( CoreEdgeClusterSettings.cluster_listen_address.name(), \"localhost:\" + clusterPort );\n\n        params.put( CoreEdgeClusterSettings.transaction_advertised_address.name(), \"localhost:\" + txPort );\n        params.put( CoreEdgeClusterSettings.transaction_listen_address.name(), \"127.0.0.1:\" + txPort );\n        params.put( CoreEdgeClusterSettings.raft_advertised_address.name(), \"localhost:\" + raftPort );\n        params.put( CoreEdgeClusterSettings.raft_listen_address.name(), \"127.0.0.1:\" + raftPort );\n\n        params.put( new GraphDatabaseSettings.BoltConnector( \"bolt\" ).type.name(), \"BOLT\" );\n        params.put( new GraphDatabaseSettings.BoltConnector( \"bolt\" ).enabled.name(), \"true\" );\n        params.put( new GraphDatabaseSettings.BoltConnector( \"bolt\" ).address.name(), \"0.0.0.0:\" + boltPort );\n\n        params.put( GraphDatabaseSettings.bolt_advertised_address.name(), \"127.0.0.1:\" + boltPort );\n\n        params.put( CoreEdgeClusterSettings.expected_core_cluster_size.name(), String.valueOf( clusterSize ) );\n        params.put( GraphDatabaseSettings.pagecache_memory.name(), \"8m\" );\n        params.put( GraphDatabaseSettings.auth_store.name(), new File( parentDir, \"auth\" ).getAbsolutePath() );\n\n        params.putAll( extraParams );\n\n        for ( Map.Entry<String, IntFunction<String>> entry : instanceExtraParams.entrySet() )\n        {\n            params.put( entry.getKey(), entry.getValue().apply( serverId ) );\n        }\n\n        File neo4jHome = new File( parentDir, \"server-core-\" + serverId );\n        final File storeDir = coreServerStoreDirectory( neo4jHome );\n        params.put( GraphDatabaseSettings.logs_directory.name(), new File(neo4jHome, \"logs\").getAbsolutePath() );\n        return new CoreGraphDatabase( storeDir, params, GraphDatabaseDependencies.newDependencies(),\n                discoveryServiceFactory );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] incomingArguments ) throws Throwable\n    {\n        Args args = Args.parse( incomingArguments );\n        if ( ArrayUtil.isEmpty( incomingArguments ) )\n        {\n            printUsage( System.out );\n            System.exit( 1 );\n        }\n\n        File homeDir = args.interpretOption( \"home-dir\", Converters.<File>mandatory(), File::new );\n        String databaseName = args.interpretOption( \"database\", Converters.<String>mandatory(), s -> s );\n        String configPath = args.interpretOption( \"config\", Converters.<String>mandatory(), s -> s );\n        String clusterSeed = args.interpretOption( \"cluster-seed\", Converters.<String>mandatory(), s -> s );\n\n        Config config = createConfig( homeDir, databaseName, configPath );\n\n        new ConvertClassicStoreCommand( new ConversionVerifier() ).convert(\n                config.get( DatabaseManagementSystemSettings.database_path ),\n                config.get( GraphDatabaseSettings.record_format ),\n                clusterSeed );\n    }","id":88350,"modified_method":"public static void main( String[] incomingArguments ) throws Throwable\n    {\n        Args args = Args.parse( incomingArguments );\n        if ( ArrayUtil.isEmpty( incomingArguments ) )\n        {\n            printUsage( System.out );\n            System.exit( 1 );\n        }\n\n        File homeDir = args.interpretOption( \"home-dir\", Converters.<File>mandatory(), File::new );\n        String databaseName = args.interpretOption( \"database\", Converters.<String>mandatory(), s -> s );\n        String configPath = args.interpretOption( \"config\", Converters.<String>mandatory(), s -> s );\n        String clusterSeed = args.interpretOption( \"cluster-seed\", Converters.<String>mandatory(), s -> s );\n\n        Config config = createConfig( homeDir, databaseName, configPath );\n\n        new ConvertClassicStoreToCoreCommand( new ConversionVerifier() ).convert(\n                config.get( DatabaseManagementSystemSettings.database_path ),\n                config.get( GraphDatabaseSettings.record_format ),\n                clusterSeed );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReplicateTransactionToCoreServers() throws Throwable\n    {\n        // given\n        File dbDir = clusterRule.testDirectory().cleanDirectory( \"classic-db\" );\n        File classicNeo4jStore = createClassicNeo4jStore( dbDir, 10, recordFormat );\n\n        File clusterDirectory = clusterRule.clusterDirectory();\n        String conversionMetadata = new GenerateClusterSeedCommand().generate( classicNeo4jStore ).getConversionId();\n\n        for ( int serverId = 0; serverId < CLUSTER_SIZE; serverId++ )\n        {\n            File destination = coreServerStoreDirectory( clusterDirectory, serverId );\n            restoreDatabase( classicNeo4jStore, destination );\n            new ConvertClassicStoreCommand( new ConversionVerifier() ).convert( destination, recordFormat, conversionMetadata );\n        }\n\n        Cluster cluster = clusterRule.withRecordFormat( recordFormat ).startCluster();\n\n        // when\n        GraphDatabaseService coreDB = cluster.awaitLeader( 5000 );\n\n        try ( Transaction tx = coreDB.beginTx() )\n        {\n            Node node = coreDB.createNode( label( \"boo\" ) );\n            node.setProperty( \"foobar\", \"baz_bat\" );\n            tx.success();\n        }\n\n        cluster.addEdgeServerWithFileLocation( 4, recordFormat );\n\n        // then\n        for ( final CoreGraphDatabase db : cluster.coreServers() )\n        {\n            try ( Transaction tx = db.beginTx() )\n            {\n                ThrowingSupplier<Long, Exception> nodeCount = () -> count( db.getAllNodes() );\n\n                Config config = db.getDependencyResolver().resolveDependency( Config.class );\n\n                assertEventually( \"node to appear on core server \" + config.get( raft_advertised_address ), nodeCount,\n                        greaterThan( 0L ), 15, SECONDS );\n\n                assertEquals( 11, count( db.getAllNodes() ) );\n\n                tx.success();\n            }\n        }\n    }","id":88351,"modified_method":"@Test\n    public void shouldReplicateTransactionToCoreServers() throws Throwable\n    {\n        // given\n        File dbDir = clusterRule.testDirectory().cleanDirectory( \"classic-db\" );\n        File classicNeo4jStore = createClassicNeo4jStore( dbDir, 10, recordFormat );\n\n        File clusterDirectory = clusterRule.clusterDirectory();\n\n        File homeDir = new File( clusterDirectory, \"server-core-\" + 0 ) ;\n        StringBuilder output = RestoreClusterUtils.execute( () -> RestoreNewClusterCli.main( toArray( args()\n                .homeDir( homeDir ).config( homeDir ).from( classicNeo4jStore )\n                .database( \"graph.db\" ).force().build() ) ) );\n\n        String seed = RestoreClusterCliTest.extractSeed( output );\n\n        for ( int serverId = 1; serverId < CLUSTER_SIZE; serverId++ )\n        {\n            File destination = new File( clusterDirectory, \"server-core-\" + serverId ) ;\n            RestoreClusterUtils.execute( () -> RestoreExistingClusterCli.main( toArray( args().homeDir( destination )\n                    .config( destination ).from( classicNeo4jStore ).database( \"graph.db\" ).seed( seed ).force().build() ) ) );\n        }\n\n        Cluster cluster = clusterRule.withRecordFormat( recordFormat ).startCluster();\n\n        // when\n        GraphDatabaseService coreDB = cluster.awaitLeader( 5000 );\n\n        try ( Transaction tx = coreDB.beginTx() )\n        {\n            Node node = coreDB.createNode( label( \"boo\" ) );\n            node.setProperty( \"foobar\", \"baz_bat\" );\n            tx.success();\n        }\n\n        cluster.addEdgeServerWithFileLocation( 4, recordFormat );\n\n        // then\n        for ( final CoreGraphDatabase db : cluster.coreServers() )\n        {\n            try ( Transaction tx = db.beginTx() )\n            {\n                ThrowingSupplier<Long, Exception> nodeCount = () -> count( db.getAllNodes() );\n\n                Config config = db.getDependencyResolver().resolveDependency( Config.class );\n\n                assertEventually( \"node to appear on core server \" + config.get( raft_advertised_address ), nodeCount,\n                        greaterThan( 0L ), 15, SECONDS );\n\n                assertEquals( 11, count( db.getAllNodes() ) );\n\n                tx.success();\n            }\n        }\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRestoreDatabase() throws Throwable\n    {\n        File classicDatabaseDir = testDirectory.cleanDirectory( \"classic-db\" );\n        File classicNeo4jStore = createClassicNeo4jStore( classicDatabaseDir, 10, StandardV3_0.NAME );\n        StoreMetadata storeMetadata = metadataFor( classicNeo4jStore );\n\n        // when\n        LinkedList<String> args = args( classicNeo4jStore, testDirectory.cleanDirectory( \"new-db-1\" ) );\n        StringBuilder out = execute( () -> RestoreNewClusterCli.main( args.toArray( new String[args.size()] ) ) );\n\n        // then\n        String seed = extractSeed( out );\n        ClusterSeed clusterSeed = ClusterSeed.create( seed );\n\n        assertTrue( storeMetadata.storeId().equals( clusterSeed.before() ) );\n        assertEquals( storeMetadata.lastTxId(), clusterSeed.lastTxId() );\n        assertFalse( storeMetadata.storeId().equals( clusterSeed.after() ) );\n\n        // when restore to another place\n        File rootNewDatabaseDir = testDirectory.cleanDirectory( \"new-db-2\" );\n        LinkedList<String> newArgs = args( classicNeo4jStore, rootNewDatabaseDir );\n        newArgs.add( \"--cluster-seed=\" + seed );\n        execute( () -> RestoreExistingClusterCli.main( newArgs.toArray( new String[newArgs.size()] ) ) );\n\n        // then\n        StoreMetadata newMetadata = metadataFor( extractDatabaseDir( rootNewDatabaseDir ) );\n        assertTrue( clusterSeed.after().equals( newMetadata.storeId() ) );\n    }","id":88352,"modified_method":"@Test\n    public void shouldRestoreDatabase() throws Throwable\n    {\n        File classicDatabaseDir = testDirectory.cleanDirectory( \"classic-db\" );\n        File classicNeo4jStore = createClassicNeo4jStore( classicDatabaseDir, 10, StandardV3_0.NAME );\n        StoreMetadata storeMetadata = metadataFor( classicNeo4jStore );\n\n        // when\n        File homeDir = testDirectory.cleanDirectory( \"new-db-1\" );\n        LinkedList<String> args = ArgsBuilder.args().homeDir( homeDir ).config( homeDir )\n                .from( classicNeo4jStore ).database( \"graph.db\" ).build() ;\n\n        StringBuilder out = RestoreClusterUtils.execute( () -> RestoreNewClusterCli.main( args.toArray( new String[args.size()] ) ) );\n\n        // then\n        String seed = extractSeed( out );\n        ClusterSeed clusterSeed = ClusterSeed.create( seed );\n\n        assertTrue( storeMetadata.storeId().equals( clusterSeed.before() ) );\n        assertEquals( storeMetadata.lastTxId(), clusterSeed.lastTxId() );\n        assertFalse( storeMetadata.storeId().equals( clusterSeed.after() ) );\n\n        // when restore to another place\n        File rootNewDatabaseDir = testDirectory.cleanDirectory( \"new-db-2\" );\n        LinkedList<String> newArgs = ArgsBuilder.args().homeDir( rootNewDatabaseDir ).config( rootNewDatabaseDir )\n                .from( classicNeo4jStore ).database( \"graph.db\" ).seed( seed ).build() ;\n\n        RestoreClusterUtils.execute( () -> RestoreExistingClusterCli.main( newArgs.toArray( new String[newArgs.size()] ) ) );\n\n        // then\n        StoreMetadata newMetadata = metadataFor( extractDatabaseDir( rootNewDatabaseDir ) );\n        assertTrue( clusterSeed.after().equals( newMetadata.storeId() ) );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String extractSeed( StringBuilder builder )\n    {\n        return builder.toString().replace( \"Cluster Seed: \", \"\" ).replace( \"\\n\", \"\" );\n    }","id":88353,"modified_method":"public static String extractSeed( StringBuilder builder )\n    {\n        return builder.toString().replace( \"Cluster Seed: \", \"\" ).replace( \"\\n\", \"\" );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public RestoreDatabaseCommand( FileSystemAbstraction fs, File fromPath, Config config,\n                                   String databaseName, boolean forceOverwrite )\n    {\n        this.fs = fs;\n        this.fromPath = fromPath;\n        this.databaseName = databaseName;\n        this.forceOverwrite = forceOverwrite;\n        this.databaseDir = configWith( config, databaseName ).get( database_path ).getAbsoluteFile();\n\n    }","id":88354,"modified_method":"public RestoreDatabaseCommand( FileSystemAbstraction fs, File fromPath, Config config,\n                                   String databaseName, boolean forceOverwrite )\n    {\n        this.fs = fs;\n        this.fromPath = fromPath;\n        this.databaseName = databaseName;\n        this.forceOverwrite = forceOverwrite;\n        this.databaseDir = config.get( database_path ).getAbsoluteFile();\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotCopyOverAndExistingDatabase() throws Exception\n    {\n        // given\n        FileSystemAbstraction fs = new DefaultFileSystemAbstraction();\n        String databaseName = \"to\";\n        Config config = RestoreDatabaseCommand.configWith(  Config.empty(), databaseName);\n\n        File fromPath = new File( directory.absolutePath(), \"from\" );\n        File toPath = config.get( DatabaseManagementSystemSettings.database_path );\n\n        createDbAt( fromPath, 0 );\n        createDbAt( toPath, 0 );\n\n        try\n        {\n            // when\n\n            new RestoreDatabaseCommand( fs, fromPath, config, databaseName, false ).execute();\n            fail( \"Should have thrown exception\" );\n        }\n        catch ( IllegalArgumentException exception )\n        {\n            // then\n            assertTrue( exception.getMessage(), exception.getMessage().contains(\n                    \"Database with name [to] already exists\" ) );\n        }\n    }","id":88355,"modified_method":"@Test\n    public void shouldNotCopyOverAndExistingDatabase() throws Exception\n    {\n        // given\n        FileSystemAbstraction fs = new DefaultFileSystemAbstraction();\n        String databaseName = \"to\";\n        Config config = configWith(  Config.empty(), databaseName);\n\n        File fromPath = new File( directory.absolutePath(), \"from\" );\n        File toPath = config.get( DatabaseManagementSystemSettings.database_path );\n\n        createDbAt( fromPath, 0 );\n        createDbAt( toPath, 0 );\n\n        try\n        {\n            // when\n\n            new RestoreDatabaseCommand( fs, fromPath, config, databaseName, false ).execute();\n            fail( \"Should have thrown exception\" );\n        }\n        catch ( IllegalArgumentException exception )\n        {\n            // then\n            assertTrue( exception.getMessage(), exception.getMessage().contains(\n                    \"Database with name [to] already exists\" ) );\n        }\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldThrowExceptionIfBackupDirectoryDoesNotExist() throws Exception\n    {\n        // given\n        FileSystemAbstraction fs = new DefaultFileSystemAbstraction();\n        String databaseName = \"to\";\n        Config config = RestoreDatabaseCommand.configWith(  Config.empty(), databaseName);\n\n        File fromPath = new File( directory.absolutePath(), \"from\" );\n        File toPath = config.get( DatabaseManagementSystemSettings.database_path );\n\n        createDbAt( toPath, 0 );\n\n        try\n        {\n            // when\n\n            new RestoreDatabaseCommand( fs, fromPath, config, databaseName, false ).execute();\n            fail( \"Should have thrown exception\" );\n        }\n        catch ( IllegalArgumentException exception )\n        {\n            // then\n            assertTrue( exception.getMessage(),\n                    exception.getMessage().contains( \"Source directory does not exist\" ) );\n        }\n    }","id":88356,"modified_method":"@Test\n    public void shouldThrowExceptionIfBackupDirectoryDoesNotExist() throws Exception\n    {\n        // given\n        FileSystemAbstraction fs = new DefaultFileSystemAbstraction();\n        String databaseName = \"to\";\n        Config config = configWith(  Config.empty(), databaseName);\n\n        File fromPath = new File( directory.absolutePath(), \"from\" );\n        File toPath = config.get( DatabaseManagementSystemSettings.database_path );\n\n        createDbAt( toPath, 0 );\n\n        try\n        {\n            // when\n\n            new RestoreDatabaseCommand( fs, fromPath, config, databaseName, false ).execute();\n            fail( \"Should have thrown exception\" );\n        }\n        catch ( IllegalArgumentException exception )\n        {\n            // then\n            assertTrue( exception.getMessage(),\n                    exception.getMessage().contains( \"Source directory does not exist\" ) );\n        }\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowForcedCopyOverAnExistingDatabase() throws Exception\n    {\n        // given\n        FileSystemAbstraction fs = new DefaultFileSystemAbstraction();\n        String databaseName = \"to\";\n        Config config = RestoreDatabaseCommand.configWith(  Config.empty(), databaseName);\n\n        File fromPath = new File( directory.absolutePath(), \"from\" );\n        File toPath = config.get( DatabaseManagementSystemSettings.database_path );\n        int fromNodeCount = 10;\n        int toNodeCount = 20;\n\n        createDbAt( fromPath, fromNodeCount );\n        createDbAt( toPath, toNodeCount );\n\n        // when\n        new RestoreDatabaseCommand( fs, fromPath, config, databaseName, true ).execute();\n\n        // then\n        GraphDatabaseService copiedDb = new GraphDatabaseFactory().newEmbeddedDatabase( toPath );\n\n        try(Transaction ignored = copiedDb.beginTx())\n        {\n            assertEquals(fromNodeCount, Iterables.count( copiedDb.getAllNodes() ) );\n        }\n\n        copiedDb.shutdown();\n    }","id":88357,"modified_method":"@Test\n    public void shouldAllowForcedCopyOverAnExistingDatabase() throws Exception\n    {\n        // given\n        FileSystemAbstraction fs = new DefaultFileSystemAbstraction();\n        String databaseName = \"to\";\n        Config config = configWith(  Config.empty(), databaseName);\n\n        File fromPath = new File( directory.absolutePath(), \"from\" );\n        File toPath = config.get( DatabaseManagementSystemSettings.database_path );\n        int fromNodeCount = 10;\n        int toNodeCount = 20;\n\n        createDbAt( fromPath, fromNodeCount );\n        createDbAt( toPath, toNodeCount );\n\n        // when\n        new RestoreDatabaseCommand( fs, fromPath, config, databaseName, true ).execute();\n\n        // then\n        GraphDatabaseService copiedDb = new GraphDatabaseFactory().newEmbeddedDatabase( toPath );\n\n        try(Transaction ignored = copiedDb.beginTx())\n        {\n            assertEquals(fromNodeCount, Iterables.count( copiedDb.getAllNodes() ) );\n        }\n\n        copiedDb.shutdown();\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void convertStore( Config config, String seed ) throws IOException, TransactionFailureException\n    {\n        ConvertClassicStoreCommand convert = new ConvertClassicStoreCommand( new ConversionVerifier() );\n        convert.convert( config.get( database_path ), config.get( record_format ), seed );\n    }","id":88358,"modified_method":"private static void convertStore( Config config, String seed ) throws IOException, TransactionFailureException\n    {\n        ConvertClassicStoreToCoreCommand convert = new ConvertClassicStoreToCoreCommand( new ConversionVerifier() );\n        convert.convert( config.get( database_path ), config.get( record_format ), seed );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Config loadNeo4jConfig( File homeDir, String configPath )\n    {\n        return new ConfigLoader( settings() ).loadConfig( Optional.of( homeDir ),\n                Optional.of( new File( configPath, \"neo4j.conf\" ) ), NullLog.getInstance() );\n    }","id":88359,"modified_method":"private static Config loadNeo4jConfig( File homeDir, String configPath, String databaseName )\n    {\n        ConfigLoader configLoader = new ConfigLoader( settings() );\n        Config config = configLoader.loadConfig(\n                Optional.of( homeDir ),\n                Optional.of( new File( configPath, \"neo4j.conf\" ) ),\n                NullLog.getInstance() );\n\n        return config.with( stringMap( DatabaseManagementSystemSettings.active_database.name(), databaseName ) );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] incomingArguments )\n    {\n        Args args = Args.parse( incomingArguments );\n        if ( ArrayUtil.isEmpty( incomingArguments ) )\n        {\n            printUsage( System.out );\n            System.exit( 1 );\n        }\n\n        File homeDir = args.interpretOption( \"home-dir\", Converters.<File>mandatory(), File::new );\n        String databaseName = args.interpretOption( \"database\", Converters.<String>mandatory(), s -> s );\n        String configPath = args.interpretOption( \"config\", Converters.<String>mandatory(), s -> s );\n        String fromPath = args.interpretOption( \"from\", Converters.<String>mandatory(), s -> s );\n        String clusterSeed = args.interpretOption( \"cluster-seed\", Converters.<String>mandatory(), s -> s );\n        boolean forceOverwrite = args.getBoolean( \"force\", Boolean.FALSE, true );\n\n        try\n        {\n            Config config = loadNeo4jConfig( homeDir, configPath );\n            restoreDatabase( databaseName, fromPath, forceOverwrite, config );\n            convertStore( config, clusterSeed );\n        }\n        catch ( IOException | TransactionFailureException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":88360,"modified_method":"public static void main( String[] incomingArguments )\n    {\n        Args args = Args.parse( incomingArguments );\n        if ( ArrayUtil.isEmpty( incomingArguments ) )\n        {\n            printUsage( System.out );\n            System.exit( 1 );\n        }\n\n        File homeDir = args.interpretOption( \"home-dir\", Converters.<File>mandatory(), File::new );\n        String databaseName = args.interpretOption( \"database\", Converters.<String>mandatory(), s -> s );\n        String configPath = args.interpretOption( \"config\", Converters.<String>mandatory(), s -> s );\n        String fromPath = args.interpretOption( \"from\", Converters.<String>mandatory(), s -> s );\n        String clusterSeed = args.interpretOption( \"cluster-seed\", Converters.<String>mandatory(), s -> s );\n        boolean forceOverwrite = args.getBoolean( \"force\", Boolean.FALSE, true );\n\n        try\n        {\n            Config config = loadNeo4jConfig( homeDir, configPath, databaseName );\n            restoreDatabase( databaseName, fromPath, forceOverwrite, config );\n            convertStore( config, clusterSeed );\n        }\n        catch ( IOException | TransactionFailureException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] incomingArguments )\n    {\n        Args args = Args.parse( incomingArguments );\n        if ( ArrayUtil.isEmpty( incomingArguments ) )\n        {\n            printUsage( System.out );\n            System.exit( 1 );\n        }\n\n        File homeDir = args.interpretOption( \"home-dir\", Converters.<File>mandatory(), File::new );\n        String databaseName = args.interpretOption( \"database\", Converters.<String>mandatory(), s -> s );\n        String configPath = args.interpretOption( \"config\", Converters.<String>mandatory(), s -> s );\n        String fromPath = args.interpretOption( \"from\", Converters.<String>mandatory(), s -> s );\n        boolean forceOverwrite = args.getBoolean( \"force\", Boolean.FALSE, true );\n\n        try\n        {\n            Config config = loadNeo4jConfig( homeDir, configPath );\n            restoreDatabase( databaseName, fromPath, forceOverwrite, config );\n            String seed = generateSeed( config );\n            convertStore( config, seed );\n            System.out.println( \"Cluster Seed: \" + seed );\n        }\n        catch ( IOException | TransactionFailureException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":88361,"modified_method":"public static void main( String[] incomingArguments )\n    {\n        Args args = Args.parse( incomingArguments );\n        if ( ArrayUtil.isEmpty( incomingArguments ) )\n        {\n            printUsage( System.out );\n            System.exit( 1 );\n        }\n\n        File homeDir = args.interpretOption( \"home-dir\", Converters.<File>mandatory(), File::new );\n        String databaseName = args.interpretOption( \"database\", Converters.<String>mandatory(), s -> s );\n        String configPath = args.interpretOption( \"config\", Converters.<String>mandatory(), s -> s );\n        String fromPath = args.interpretOption( \"from\", Converters.<String>mandatory(), s -> s );\n        boolean forceOverwrite = args.getBoolean( \"force\", Boolean.FALSE, true );\n\n        try\n        {\n            Config config = loadNeo4jConfig( homeDir, configPath, databaseName );\n            restoreDatabase( databaseName, fromPath, forceOverwrite, config );\n            String seed = generateSeed( config );\n            convertStore( config, seed );\n            System.out.println( \"Cluster Seed: \" + seed );\n        }\n        catch ( IOException | TransactionFailureException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Config loadNeo4jConfig( File homeDir, String configPath )\n    {\n        return new ConfigLoader( settings() ).loadConfig( Optional.of( homeDir ),\n                Optional.of( new File( configPath, \"neo4j.conf\" ) ), NullLog.getInstance() );\n    }","id":88362,"modified_method":"private static Config loadNeo4jConfig( File homeDir, String configPath, String databaseName )\n    {\n        ConfigLoader configLoader = new ConfigLoader( settings() );\n        Config config = configLoader.loadConfig(\n                Optional.of( homeDir ),\n                Optional.of( new File( configPath, \"neo4j.conf\" ) ),\n                NullLog.getInstance() );\n\n        return config.with( stringMap( DatabaseManagementSystemSettings.active_database.name(), databaseName ) );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void convertStore( Config config, String seed ) throws IOException, TransactionFailureException\n    {\n        ConvertClassicStoreCommand convert = new ConvertClassicStoreCommand( new ConversionVerifier() );\n        convert.convert( config.get( database_path ), config.get( record_format ), seed );\n    }","id":88363,"modified_method":"private static void convertStore( Config config, String seed ) throws IOException, TransactionFailureException\n    {\n        ConvertClassicStoreToCoreCommand convert = new ConvertClassicStoreToCoreCommand( new ConversionVerifier() );\n        convert.convert( config.get( database_path ), config.get( record_format ), seed );\n    }","commit_id":"8364d2f21a89b3adda06d952d36c7b975536de5b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public FieldHistogramResponse fieldHistogram(String field, String interval) throws IOException, APIException {\n        return api.get(FieldHistogramResponse.class)\n                .path(\"/search/universal/{0}/fieldhistogram\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"field\", field)\n                .queryParam(\"interval\", interval)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .execute();\n    }","id":88364,"modified_method":"public FieldHistogramResponse fieldHistogram(String field, String interval) throws IOException, APIException {\n        return api.get(FieldHistogramResponse.class)\n                .path(\"/search/universal/{0}/fieldhistogram\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"field\", field)\n                .queryParam(\"interval\", interval)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .timeout(KEITH, TimeUnit.SECONDS)\n                .execute();\n    }","commit_id":"4145ae05b49b377785374d2ab14b543b21d67dc6","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public FieldTermsResponse fieldTerms(String field) throws IOException, APIException {\n        return api.get(FieldTermsResponse.class)\n                .path(\"/search/universal/{0}/terms\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"field\", field)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .execute();\n    }","id":88365,"modified_method":"public FieldTermsResponse fieldTerms(String field) throws IOException, APIException {\n        return api.get(FieldTermsResponse.class)\n                .path(\"/search/universal/{0}/terms\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"field\", field)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .timeout(KEITH, TimeUnit.SECONDS)\n                .execute();\n    }","commit_id":"4145ae05b49b377785374d2ab14b543b21d67dc6","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public DateHistogramResult dateHistogram(String interval) throws IOException, APIException {\n        DateHistogramResponse response = api.get(DateHistogramResponse.class)\n                .path(\"/search/universal/{0}/histogram\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"interval\", interval)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .execute();\n        return new DateHistogramResult(response.query, response.time, response.interval, response.results);\n    }","id":88366,"modified_method":"public DateHistogramResult dateHistogram(String interval) throws IOException, APIException {\n        DateHistogramResponse response = api.get(DateHistogramResponse.class)\n                .path(\"/search/universal/{0}/histogram\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"interval\", interval)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .timeout(KEITH, TimeUnit.SECONDS)\n                .execute();\n        return new DateHistogramResult(response.query, response.time, response.interval, response.results);\n    }","commit_id":"4145ae05b49b377785374d2ab14b543b21d67dc6","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private <T> T doSearch(Class<T> clazz, MediaType mediaType, int pageSize) throws APIException, IOException {\n        return api.get(clazz)\n                .path(\"/search/universal/{0}\", timeRange.getType().toString().toLowerCase())\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"query\", query)\n                .queryParam(\"limit\", pageSize)\n                .queryParam(\"offset\", page * pageSize)\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .accept(mediaType)\n                .execute();\n    }","id":88367,"modified_method":"private <T> T doSearch(Class<T> clazz, MediaType mediaType, int pageSize) throws APIException, IOException {\n        return api.get(clazz)\n                .path(\"/search/universal/{0}\", timeRange.getType().toString().toLowerCase())\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"query\", query)\n                .queryParam(\"limit\", pageSize)\n                .queryParam(\"offset\", page * pageSize)\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .accept(mediaType)\n                .timeout(KEITH, TimeUnit.SECONDS)\n                .execute();\n    }","commit_id":"4145ae05b49b377785374d2ab14b543b21d67dc6","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public FieldStatsResponse fieldStats(String field) throws IOException, APIException {\n        return api.get(FieldStatsResponse.class)\n                .path(\"/search/universal/{0}/stats\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"field\", field)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .execute();\n    }","id":88368,"modified_method":"public FieldStatsResponse fieldStats(String field) throws IOException, APIException {\n        return api.get(FieldStatsResponse.class)\n                .path(\"/search/universal/{0}/stats\", timeRange.getType().toString().toLowerCase())\n                .queryParam(\"field\", field)\n                .queryParam(\"query\", query)\n                .queryParams(timeRange.getQueryParams())\n                .queryParam(\"filter\", (filter == null ? \"*\" : filter))\n                .timeout(KEITH, TimeUnit.SECONDS)\n                .execute();\n    }","commit_id":"4145ae05b49b377785374d2ab14b543b21d67dc6","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n\t * Generats and appends html for a single choice into the provided buffer\n\t * \n\t * @param buffer\n\t *            string buffer that will have the generated html appended\n\t * @param choice\n\t *            choice object\n\t * @param index\n\t * \n\t */\n\tprotected void appendOptionHtml(StringBuffer buffer, Object choice, int index)\n\t{\n\t\tfinal String displayValue = renderer.getDisplayValue(choice);\n\t\tbuffer.append(\"\\n<option \");\n\t\tif (isSelected(choice, index))\n\t\t{\n\t\t\tbuffer.append(\"selected=\\\"selected\\\"\");\n\t\t}\n\t\tbuffer.append(\"value=\\\"\");\n\t\tbuffer.append(renderer.getIdValue(choice, index));\n\t\tbuffer.append(\"\\\">\");\n\t\tString display = getLocalizer().getString(displayValue, this, displayValue);\n\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\tbuffer.append(escaped);\n\t\tbuffer.append(\"<\/option>\");\n\t}","id":88369,"modified_method":"/**\n\t * Generats and appends html for a single choice into the provided buffer\n\t * \n\t * @param buffer\n\t *            string buffer that will have the generated html appended\n\t * @param choice\n\t *            choice object\n\t * @param index\n\t * \n\t */\n\tprotected void appendOptionHtml(StringBuffer buffer, Object choice, int index)\n\t{\n\t\tfinal String displayValue = (String)getConverter().convert(renderer.getDisplayValue(choice), String.class);\n\t\tbuffer.append(\"\\n<option \");\n\t\tif (isSelected(choice, index))\n\t\t{\n\t\t\tbuffer.append(\"selected=\\\"selected\\\"\");\n\t\t}\n\t\tbuffer.append(\"value=\\\"\");\n\t\tbuffer.append(renderer.getIdValue(choice, index));\n\t\tbuffer.append(\"\\\">\");\n\t\tString display = getLocalizer().getString(displayValue, this, displayValue);\n\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\tbuffer.append(escaped);\n\t\tbuffer.append(\"<\/option>\");\n\t}","commit_id":"9d40c350b7d8de0e0d9321266c7c6455459ae76e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#onComponentTagBody(wicket.markup.MarkupStream,\n\t *      wicket.markup.ComponentTag)\n\t */\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Buffer to hold generated body\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\n\t\t// Iterate through choices\n\t\tfinal List choices = getChoices();\n\n\t\t// Loop through choices\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\n\t\t\t// Get label for choice\n\t\t\tfinal String label = getChoiceRenderer().getDisplayValue(choice);\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created checkbox tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add checkbox element\n\t\t\t\tbuffer.append(\"<input name=\\\"\" + getInputName() + \"\\\"\" + \" type=\\\"checkbox\\\"\"\n\t\t\t\t\t\t+ (isSelected(choice, index) ? \" checked=\\\"checked\\\"\" : \"\") + \" value=\\\"\"\n\t\t\t\t\t\t+ id + \"\\\" id=\\\"\" + idAttr + \"\\\"/>\");\n\n\t\t\t\t// Add label for checkbox\n\t\t\t\tString display = getLocalizer().getString(label, this, label);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\n\t\t\t\tbuffer.append(\"<label for=\\\"\" + idAttr + \"\\\">\").append(escaped).append(\"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","id":88370,"modified_method":"/**\n\t * @see wicket.Component#onComponentTagBody(wicket.markup.MarkupStream,\n\t *      wicket.markup.ComponentTag)\n\t */\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Buffer to hold generated body\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\n\t\t// Iterate through choices\n\t\tfinal List choices = getChoices();\n\n\t\t// Loop through choices\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\n\t\t\t// Get label for choice\n\t\t\tfinal String label = (String)getConverter().convert(getChoiceRenderer().getDisplayValue(choice), String.class);\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created checkbox tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add checkbox element\n\t\t\t\tbuffer.append(\"<input name=\\\"\" + getInputName() + \"\\\"\" + \" type=\\\"checkbox\\\"\"\n\t\t\t\t\t\t+ (isSelected(choice, index) ? \" checked=\\\"checked\\\"\" : \"\") + \" value=\\\"\"\n\t\t\t\t\t\t+ id + \"\\\" id=\\\"\" + idAttr + \"\\\"/>\");\n\n\t\t\t\t// Add label for checkbox\n\t\t\t\tString display = getLocalizer().getString(label, this, label);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\n\t\t\t\tbuffer.append(\"<label for=\\\"\" + idAttr + \"\\\">\").append(escaped).append(\"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","commit_id":"9d40c350b7d8de0e0d9321266c7c6455459ae76e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.IChoiceRenderer#getDisplayValue(java.lang.Object)\n\t */\n\tpublic String getDisplayValue(Object object)\n\t{\n\t\tObject returnValue = object;\n\t\tif ((displayExpression != null) && (object != null))\n\t\t{\n\t\t\treturnValue = PropertyResolver.getValue(displayExpression, object);\n\t\t}\n\n\t\tif (returnValue == null)\n\t\t{\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn returnValue.toString();\n\t}","id":88371,"modified_method":"/**\n\t * @see wicket.markup.html.form.IChoiceRenderer#getDisplayValue(java.lang.Object)\n\t */\n\tpublic Object getDisplayValue(Object object)\n\t{\n\t\tObject returnValue = object;\n\t\tif ((displayExpression != null) && (object != null))\n\t\t{\n\t\t\treturnValue = PropertyResolver.getValue(displayExpression, object);\n\t\t}\n\n\t\tif (returnValue == null)\n\t\t{\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn returnValue.toString();\n\t}","commit_id":"9d40c350b7d8de0e0d9321266c7c6455459ae76e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Buffer to hold generated body\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\n\t\t// Iterate through choices\n\t\tfinal List choices = getChoices();\n\n\t\t// Loop through choices\n\n\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\n\t\t\t// Get label for choice\n\t\t\tfinal String label = getChoiceRenderer().getDisplayValue(choice);\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created radio tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add radio tag\n\t\t\t\tbuffer.append(\"<input name=\\\"\" + getInputName() + \"\\\"\" + \" type=\\\"radio\\\"\"\n\t\t\t\t\t\t+ (isSelected(choice, index) ? \" checked=\\\"checked\\\"\" : \"\") + \" value=\\\"\"\n\t\t\t\t\t\t+ id + \"\\\" id=\\\"\" + idAttr + \"\\\"\");\n\n\t\t\t\t// Should a roundtrip be made (have onSelectionChanged called)\n\t\t\t\t// when the option is clicked?\n\t\t\t\tif (wantOnSelectionChangedNotifications())\n\t\t\t\t{\n\t\t\t\t\tfinal String url = urlFor(IOnChangeListener.class);\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tForm form = getForm();\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"\" +  form.getJsForInterfaceUrl(url)  + \";\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (WicketRuntimeException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t// NOTE: do not encode the url as that would give invalid\n\t\t\t\t\t\t// JavaScript\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"\" + url + \"&\" + getInputName() + \"=\"\n\t\t\t\t\t\t\t\t+ id + \"';\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbuffer.append(\"/>\");\n\n\t\t\t\t// Add label for radio button\n\t\t\t\tString display = getLocalizer().getString(label, this, label);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(\"<label for=\\\"\" + idAttr + \"\\\">\" + escaped + \"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","id":88372,"modified_method":"/**\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Buffer to hold generated body\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\n\t\t// Iterate through choices\n\t\tfinal List choices = getChoices();\n\n\t\t// Loop through choices\n\n\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\n\t\t\t// Get label for choice\n\t\t\tfinal String label = (String)getConverter().convert(getChoiceRenderer().getDisplayValue(choice), String.class);;\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created radio tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add radio tag\n\t\t\t\tbuffer.append(\"<input name=\\\"\" + getInputName() + \"\\\"\" + \" type=\\\"radio\\\"\"\n\t\t\t\t\t\t+ (isSelected(choice, index) ? \" checked=\\\"checked\\\"\" : \"\") + \" value=\\\"\"\n\t\t\t\t\t\t+ id + \"\\\" id=\\\"\" + idAttr + \"\\\"\");\n\n\t\t\t\t// Should a roundtrip be made (have onSelectionChanged called)\n\t\t\t\t// when the option is clicked?\n\t\t\t\tif (wantOnSelectionChangedNotifications())\n\t\t\t\t{\n\t\t\t\t\tfinal String url = urlFor(IOnChangeListener.class);\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tForm form = getForm();\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"\" +  form.getJsForInterfaceUrl(url)  + \";\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (WicketRuntimeException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t// NOTE: do not encode the url as that would give invalid\n\t\t\t\t\t\t// JavaScript\n\t\t\t\t\t\tbuffer.append(\" onclick=\\\"\" + url + \"&\" + getInputName() + \"=\"\n\t\t\t\t\t\t\t\t+ id + \"';\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbuffer.append(\"/>\");\n\n\t\t\t\t// Add label for radio button\n\t\t\t\tString display = getLocalizer().getString(label, this, label);\n\t\t\t\tString escaped = Strings.escapeMarkup(display, false, true);\n\t\t\t\tbuffer.append(\"<label for=\\\"\" + idAttr + \"\\\">\" + escaped + \"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer.toString());\n\t}","commit_id":"9d40c350b7d8de0e0d9321266c7c6455459ae76e","url":"https://github.com/apache/wicket"},{"original_method":"public void testAwaitTerminationDoesNotCompletePrematurely() throws InterruptedException {\n    ExecutorService executor2 = new BoundedScheduledExecutorService(PooledThreadExecutor.INSTANCE, 1);\n    Future<?> future = executor2.submit(() -> TimeoutUtil.sleep(10000));\n    executor2.shutdown();\n    assertFalse(executor2.awaitTermination(1, TimeUnit.SECONDS));\n    assertFalse(future.isDone());\n    assertFalse(future.isCancelled());\n    assertTrue(executor2.awaitTermination(1000, TimeUnit.SECONDS));\n    assertTrue(future.isDone());\n    assertFalse(future.isCancelled());\n  }","id":88373,"modified_method":"public void testAwaitTerminationDoesNotCompletePrematurely() throws InterruptedException {\n    ExecutorService executor2 = createBoundedScheduledExecutor(PooledThreadExecutor.INSTANCE, 1);\n    Future<?> future = executor2.submit(() -> TimeoutUtil.sleep(10000));\n    executor2.shutdown();\n    assertFalse(executor2.awaitTermination(1, TimeUnit.SECONDS));\n    assertFalse(future.isDone());\n    assertFalse(future.isCancelled());\n    assertTrue(executor2.awaitTermination(1000, TimeUnit.SECONDS));\n    assertTrue(future.isDone());\n    assertFalse(future.isCancelled());\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testStressWhenSomeTasksCallOtherTasksGet() throws ExecutionException, InterruptedException {\n    ExecutorService backendExecutor = AppExecutorUtil.getAppExecutorService();\n    for (int maxSimultaneousTasks = 1; maxSimultaneousTasks<20; maxSimultaneousTasks++) {\n      System.out.println(\"maxSimultaneousTasks = \" + maxSimultaneousTasks);\n      BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(backendExecutor, maxSimultaneousTasks);\n      AtomicInteger running = new AtomicInteger();\n      AtomicInteger maxThreads = new AtomicInteger();\n      AtomicInteger availableThreads = new AtomicInteger(maxSimultaneousTasks); // to avoid deadlocks when trying to wait inside the pool thread\n\n      try {\n        int N = 1000;\n        Future[] futures = new Future[N];\n        Random random = new Random();\n        for (int i = 0; i < N; i++) {\n          final int finalI = i;\n          final int finalMaxSimultaneousTasks = maxSimultaneousTasks;\n          futures[i] = executor.schedule(() -> {\n            maxThreads.accumulateAndGet(running.incrementAndGet(), Math::max);\n\n            try {\n              int r = random.nextInt(finalMaxSimultaneousTasks);\n              int prev = finalI - r;\n              if (prev < finalI && prev >= 0) {\n                if (availableThreads.decrementAndGet() > 0) {\n                  try {\n                    futures[prev].get();\n                  }\n                  catch (Exception e) {\n                    throw new RuntimeException(e);\n                  }\n                }\n                availableThreads.incrementAndGet();\n              }\n              TimeoutUtil.sleep(r);\n            }\n            finally {\n              running.decrementAndGet();\n            }\n          }, i % 10, TimeUnit.MILLISECONDS);\n        }\n        for (Future future : futures) {\n          future.get();\n        }\n      }\n      finally {\n        executor.shutdownNow();\n        assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n      }\n\n      assertTrue(\"Max threads was: \"+maxThreads+\" but bound was: \"+maxSimultaneousTasks, maxThreads.get() <= maxSimultaneousTasks);\n    }\n  }","id":88374,"modified_method":"public void testStressWhenSomeTasksCallOtherTasksGet() throws ExecutionException, InterruptedException {\n    ExecutorService backendExecutor = AppExecutorUtil.getAppExecutorService();\n    for (int maxSimultaneousTasks = 1; maxSimultaneousTasks<20; maxSimultaneousTasks++) {\n      System.out.println(\"maxSimultaneousTasks = \" + maxSimultaneousTasks);\n      BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(backendExecutor, maxSimultaneousTasks);\n      AtomicInteger running = new AtomicInteger();\n      AtomicInteger maxThreads = new AtomicInteger();\n      AtomicInteger availableThreads = new AtomicInteger(maxSimultaneousTasks); // to avoid deadlocks when trying to wait inside the pool thread\n\n      try {\n        int N = 1000;\n        Future[] futures = new Future[N];\n        Random random = new Random();\n        for (int i = 0; i < N; i++) {\n          final int finalI = i;\n          final int finalMaxSimultaneousTasks = maxSimultaneousTasks;\n          futures[i] = executor.schedule(() -> {\n            maxThreads.accumulateAndGet(running.incrementAndGet(), Math::max);\n\n            try {\n              int r = random.nextInt(finalMaxSimultaneousTasks);\n              int prev = finalI - r;\n              if (prev < finalI && prev >= 0) {\n                if (availableThreads.decrementAndGet() > 0) {\n                  try {\n                    futures[prev].get();\n                  }\n                  catch (Exception e) {\n                    throw new RuntimeException(e);\n                  }\n                }\n                availableThreads.incrementAndGet();\n              }\n              TimeoutUtil.sleep(r);\n            }\n            finally {\n              running.decrementAndGet();\n            }\n          }, i % 10, TimeUnit.MILLISECONDS);\n        }\n        for (Future future : futures) {\n          future.get();\n        }\n      }\n      finally {\n        executor.shutdownNow();\n        assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n      }\n\n      assertTrue(\"Max threads was: \"+maxThreads+\" but bound was: \"+maxSimultaneousTasks, maxThreads.get() <= maxSimultaneousTasks);\n    }\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testEarlyCancelPreventsRunning() throws ExecutionException, InterruptedException {\n    AtomicBoolean run = new AtomicBoolean();\n    BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(AppExecutorUtil.getAppExecutorService(), 1);\n\n    int delayMs = 10*1000;\n    Future<?> s1 = executor.schedule(EmptyRunnable.getInstance(), delayMs, TimeUnit.MILLISECONDS);\n    Future<Integer> f1 = executor.schedule(() -> {\n      run.set(true);\n      return 42;\n    }, delayMs, TimeUnit.MILLISECONDS);\n    f1.cancel(false);\n    TimeoutUtil.sleep(delayMs + 1000);\n    assertTrue(f1.isDone());\n    assertTrue(f1.isCancelled());\n    assertFalse(run.get());\n    assertTrue(s1.isDone());\n    executor.shutdownNow();\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","id":88375,"modified_method":"public void testEarlyCancelPreventsRunning() throws ExecutionException, InterruptedException {\n    AtomicBoolean run = new AtomicBoolean();\n    BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(AppExecutorUtil.getAppExecutorService(), 1);\n\n    int delayMs = 10*1000;\n    Future<?> s1 = executor.schedule(EmptyRunnable.getInstance(), delayMs, TimeUnit.MILLISECONDS);\n    Future<Integer> f1 = executor.schedule(() -> {\n      run.set(true);\n      return 42;\n    }, delayMs, TimeUnit.MILLISECONDS);\n    f1.cancel(false);\n    TimeoutUtil.sleep(delayMs + 1000);\n    assertTrue(f1.isDone());\n    assertTrue(f1.isCancelled());\n    assertFalse(run.get());\n    assertTrue(s1.isDone());\n    executor.shutdownNow();\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAwaitTerminationDoesWait() throws InterruptedException {\n    for (int maxTasks=1; maxTasks<10;maxTasks++) {\n      ExecutorService executor = new BoundedScheduledExecutorService(PooledThreadExecutor.INSTANCE, maxTasks);\n      int N = 100000;\n      StringBuffer log = new StringBuffer(N*4);\n\n      Future[] futures = new Future[N];\n      for (int i = 0; i < N; i++) {\n        futures[i] = executor.submit(() -> log.append(\" \"));\n      }\n      executor.shutdown();\n      assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n\n      String logs = log.toString();\n      assertEquals(N, logs.length());\n      for (Future future : futures) {\n        assertTrue(future.isDone());\n        assertTrue(!future.isCancelled());\n      }\n    }\n  }","id":88376,"modified_method":"public void testAwaitTerminationDoesWait() throws InterruptedException {\n    for (int maxTasks=1; maxTasks<10;maxTasks++) {\n      ExecutorService executor = createBoundedScheduledExecutor(PooledThreadExecutor.INSTANCE, maxTasks);\n      int N = 100000;\n      StringBuffer log = new StringBuffer(N*4);\n\n      Future[] futures = new Future[N];\n      for (int i = 0; i < N; i++) {\n        futures[i] = executor.submit(() -> log.append(\" \"));\n      }\n      executor.shutdown();\n      assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n\n      String logs = log.toString();\n      assertEquals(N, logs.length());\n      for (Future future : futures) {\n        assertTrue(future.isDone());\n        assertTrue(!future.isCancelled());\n      }\n    }\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSchedulesAreReallyBound() throws InterruptedException, ExecutionException {\n    ExecutorService backendExecutor = AppExecutorUtil.getAppExecutorService();\n    for (int maxTasks=1; maxTasks<5;maxTasks++) {\n      System.out.println(\"maxTasks = \" + maxTasks);\n      BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(backendExecutor, maxTasks);\n      AtomicInteger running = new AtomicInteger();\n      AtomicInteger max = new AtomicInteger();\n      AtomicInteger executed = new AtomicInteger();\n      int N = 10000;\n      ScheduledFuture[] futures = new ScheduledFuture[N];\n      for (int i = 0; i < N; i++) {\n        futures[i] = executor.schedule(() -> {\n          int r = running.incrementAndGet();\n          try {\n            TimeoutUtil.sleep(1);\n            max.accumulateAndGet(r, Math::max);\n            executed.incrementAndGet();\n          }\n          finally {\n            running.decrementAndGet();\n          }\n        }, i%10, TimeUnit.MILLISECONDS);\n      }\n      for (ScheduledFuture future : futures) {\n        future.get();\n      }\n      assertEquals(0, executor.shutdownNow().size());\n      assertTrue(executor.awaitTermination(N + N, TimeUnit.MILLISECONDS));\n      assertEquals(maxTasks, max.get());\n      assertEquals(N, executed.get());\n    }\n  }","id":88377,"modified_method":"public void testSchedulesAreReallyBound() throws InterruptedException, ExecutionException {\n    ExecutorService backendExecutor = AppExecutorUtil.getAppExecutorService();\n    for (int maxTasks=1; maxTasks<5;maxTasks++) {\n      System.out.println(\"maxTasks = \" + maxTasks);\n      BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(backendExecutor, maxTasks);\n      AtomicInteger running = new AtomicInteger();\n      AtomicInteger max = new AtomicInteger();\n      AtomicInteger executed = new AtomicInteger();\n      int N = 10000;\n      ScheduledFuture[] futures = new ScheduledFuture[N];\n      for (int i = 0; i < N; i++) {\n        futures[i] = executor.schedule(() -> {\n          int r = running.incrementAndGet();\n          try {\n            TimeoutUtil.sleep(1);\n            max.accumulateAndGet(r, Math::max);\n            executed.incrementAndGet();\n          }\n          finally {\n            running.decrementAndGet();\n          }\n        }, i%10, TimeUnit.MILLISECONDS);\n      }\n      for (ScheduledFuture future : futures) {\n        future.get();\n      }\n      assertEquals(0, executor.shutdownNow().size());\n      assertTrue(executor.awaitTermination(N + N, TimeUnit.MILLISECONDS));\n      assertEquals(maxTasks, max.get());\n      assertEquals(N, executed.get());\n    }\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCallableReallyReturnsValue() throws Exception{\n    BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(AppExecutorUtil.getAppExecutorService(), 1);\n\n    Future<Integer> f1 = executor.schedule(() -> 42, 1, TimeUnit.SECONDS);\n    Integer result = f1.get();\n    assertEquals(42, result.intValue());\n    executor.shutdownNow();\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","id":88378,"modified_method":"public void testCallableReallyReturnsValue() throws Exception{\n    BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(AppExecutorUtil.getAppExecutorService(), 1);\n\n    Future<Integer> f1 = executor.schedule(() -> 42, 1, TimeUnit.SECONDS);\n    Integer result = f1.get();\n    assertEquals(42, result.intValue());\n    executor.shutdownNow();\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testShutdownMustDisableSubmit() throws ExecutionException, InterruptedException {\n    BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(AppExecutorUtil.getAppExecutorService(), 1);\n    int N = 100000;\n    StringBuffer log = new StringBuffer(N*4);\n\n    Future[] futures = new Future[N];\n    for (int i = 0; i < N; i++) {\n      futures[i] = executor.schedule(() -> log.append(\" \"), 10, TimeUnit.SECONDS);\n    }\n    executor.shutdown();\n    assertTrue(executor.isShutdown());\n    try {\n      executor.schedule(EmptyRunnable.getInstance(), 10, TimeUnit.SECONDS);\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n    try {\n      executor.execute(EmptyRunnable.getInstance());\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n\n    for (int i = 0; i < N; i++) {\n      assertFalse(futures[i].isCancelled());\n      futures[i].cancel(false);\n    }\n\n    String logs = log.toString();\n    assertEquals(\"\", logs);\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","id":88379,"modified_method":"public void testShutdownMustDisableSubmit() throws ExecutionException, InterruptedException {\n    BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(AppExecutorUtil.getAppExecutorService(), 1);\n    int N = 100000;\n    StringBuffer log = new StringBuffer(N*4);\n\n    Future[] futures = new Future[N];\n    for (int i = 0; i < N; i++) {\n      futures[i] = executor.schedule(() -> log.append(\" \"), 10, TimeUnit.SECONDS);\n    }\n    executor.shutdown();\n    assertTrue(executor.isShutdown());\n    try {\n      executor.schedule(EmptyRunnable.getInstance(), 10, TimeUnit.SECONDS);\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n    try {\n      executor.execute(EmptyRunnable.getInstance());\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n\n    for (int i = 0; i < N; i++) {\n      assertFalse(futures[i].isCancelled());\n      futures[i].cancel(false);\n    }\n\n    String logs = log.toString();\n    assertEquals(\"\", logs);\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testShutdownNowMustCancel() throws ExecutionException, InterruptedException {\n    BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(AppExecutorUtil.getAppExecutorService(), 1);\n    int N = 100000;\n    StringBuffer log = new StringBuffer(N*4);\n\n    Future[] futures = new Future[N];\n    for (int i = 0; i < N; i++) {\n      futures[i] = executor.schedule(() -> log.append(\" \"), 10, TimeUnit.SECONDS);\n    }\n    List<Runnable> runnables = executor.shutdownNow();\n    assertTrue(executor.isShutdown());\n    assertEquals(N, runnables.size());\n\n    try {\n      executor.schedule(EmptyRunnable.getInstance(), 10, TimeUnit.SECONDS);\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n    try {\n      executor.execute(EmptyRunnable.getInstance());\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n\n    for (int i = 0; i < N; i++) {\n      assertTrue(futures[i].isCancelled());\n    }\n\n    String logs = log.toString();\n    assertEquals(\"\", logs);\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","id":88380,"modified_method":"public void testShutdownNowMustCancel() throws ExecutionException, InterruptedException {\n    BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(AppExecutorUtil.getAppExecutorService(), 1);\n    int N = 100000;\n    StringBuffer log = new StringBuffer(N*4);\n\n    Future[] futures = new Future[N];\n    for (int i = 0; i < N; i++) {\n      futures[i] = executor.schedule(() -> log.append(\" \"), 10, TimeUnit.SECONDS);\n    }\n    List<Runnable> runnables = executor.shutdownNow();\n    assertTrue(executor.isShutdown());\n    assertEquals(N, runnables.size());\n\n    try {\n      executor.schedule(EmptyRunnable.getInstance(), 10, TimeUnit.SECONDS);\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n    try {\n      executor.execute(EmptyRunnable.getInstance());\n      fail(\"Must reject\");\n    }\n    catch (RejectedExecutionException ignored) {\n    }\n\n    for (int i = 0; i < N; i++) {\n      assertTrue(futures[i].isCancelled());\n    }\n\n    String logs = log.toString();\n    assertEquals(\"\", logs);\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSubmitsAreReallyBound() throws InterruptedException, ExecutionException {\n    ExecutorService backendExecutor = AppExecutorUtil.getAppExecutorService();\n    for (int maxTasks=1; maxTasks<5;maxTasks++) {\n      System.out.println(\"maxTasks = \" + maxTasks);\n      BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(backendExecutor, maxTasks);\n      AtomicInteger running = new AtomicInteger();\n      AtomicInteger max = new AtomicInteger();\n      AtomicInteger executed = new AtomicInteger();\n      int N = 10000;\n      Future[] futures = new Future[N];\n      for (int i = 0; i < N; i++) {\n        futures[i] = executor.submit(() -> {\n          int r = running.incrementAndGet();\n          try {\n            TimeoutUtil.sleep(1);\n            max.accumulateAndGet(r, Math::max);\n            executed.incrementAndGet();\n          }\n          finally {\n            running.decrementAndGet();\n          }\n        });\n      }\n      for (Future future : futures) {\n        future.get();\n      }\n      assertEquals(0, executor.shutdownNow().size());\n      assertTrue(executor.awaitTermination(N + N, TimeUnit.MILLISECONDS));\n      assertEquals(maxTasks, max.get());\n      assertEquals(N, executed.get());\n    }\n  }","id":88381,"modified_method":"public void testSubmitsAreReallyBound() throws InterruptedException, ExecutionException {\n    ExecutorService backendExecutor = AppExecutorUtil.getAppExecutorService();\n    for (int maxTasks=1; maxTasks<5;maxTasks++) {\n      System.out.println(\"maxTasks = \" + maxTasks);\n      BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(backendExecutor, maxTasks);\n      AtomicInteger running = new AtomicInteger();\n      AtomicInteger max = new AtomicInteger();\n      AtomicInteger executed = new AtomicInteger();\n      int N = 10000;\n      Future[] futures = new Future[N];\n      for (int i = 0; i < N; i++) {\n        futures[i] = executor.submit(() -> {\n          int r = running.incrementAndGet();\n          try {\n            TimeoutUtil.sleep(1);\n            max.accumulateAndGet(r, Math::max);\n            executed.incrementAndGet();\n          }\n          finally {\n            running.decrementAndGet();\n          }\n        });\n      }\n      for (Future future : futures) {\n        future.get();\n      }\n      assertEquals(0, executor.shutdownNow().size());\n      assertTrue(executor.awaitTermination(N + N, TimeUnit.MILLISECONDS));\n      assertEquals(maxTasks, max.get());\n      assertEquals(N, executed.get());\n    }\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSequentialSchedulesMustExecuteSequentially() throws ExecutionException, InterruptedException {\n    BoundedScheduledExecutorService executor = new BoundedScheduledExecutorService(AppExecutorUtil.getAppExecutorService(), 1);\n    int N = 100000;\n    StringBuffer log = new StringBuffer(N*4);\n    StringBuilder expected = new StringBuilder(N * 4);\n\n    Future[] futures = new Future[N];\n    for (int i = 0; i < N; i++) {\n      final int finalI = i;\n      futures[i] = executor.schedule(() -> log.append(finalI+\" \"), 0, TimeUnit.MILLISECONDS);\n    }\n    for (int i = 0; i < N; i++) {\n      expected.append(i).append(\" \");\n      futures[i].get();\n    }\n\n    String logs = log.toString();\n    assertEquals(expected.toString(), logs);\n    executor.shutdownNow();\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","id":88382,"modified_method":"public void testSequentialSchedulesMustExecuteSequentially() throws ExecutionException, InterruptedException {\n    BoundedScheduledExecutorService executor = createBoundedScheduledExecutor(AppExecutorUtil.getAppExecutorService(), 1);\n    int N = 100000;\n    StringBuffer log = new StringBuffer(N*4);\n    StringBuilder expected = new StringBuilder(N * 4);\n\n    Future[] futures = new Future[N];\n    for (int i = 0; i < N; i++) {\n      final int finalI = i;\n      //noinspection StringConcatenationInsideStringBufferAppend\n      futures[i] = executor.schedule(() -> log.append(finalI+\" \"), 0, TimeUnit.MILLISECONDS);\n    }\n    for (int i = 0; i < N; i++) {\n      expected.append(i).append(\" \");\n      futures[i].get();\n    }\n\n    String logs = log.toString();\n    assertEquals(expected.toString(), logs);\n    executor.shutdownNow();\n    assertTrue(executor.awaitTermination(1, TimeUnit.SECONDS));\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private <T> MyScheduledFutureTask<T> delayedExecute(@NotNull MyScheduledFutureTask<T> t) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Submit at delay \" + t.getDelay(TimeUnit.MILLISECONDS) + \"ms \" + BoundedTaskExecutor.info(t));\n    }\n    if (isShutdown()) {\n      throw new RejectedExecutionException(\"Already shutdown\");\n    }\n    delayQueue.add(t);\n    return t;\n  }","id":88383,"modified_method":"@NotNull\n  private <T> MyScheduledFutureTask<T> delayedExecute(@NotNull MyScheduledFutureTask<T> t) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Submit at delay \" + t.getDelay(TimeUnit.MILLISECONDS) + \"ms \" + BoundedTaskExecutor.info(t));\n    }\n    if (isShutdown()) {\n      throw new RejectedExecutionException(\"Already shutdown\");\n    }\n    delayQueue.add(t);\n    if (t.getDelay(TimeUnit.HOURS) > 24 && !t.isPeriodic()) {\n      // guard against inadvertent queue overflow\n      throw new IllegalArgumentException(\"Unsupported crazy delay \" + t.getDelay(TimeUnit.MINUTES) + \" minutes: \" + BoundedTaskExecutor.info(t));\n    }\n    return t;\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean awaitTermination(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n    assert isShutdown() : \"must await termination after shutdown() or shutdownNow() only\";\n    List<MyScheduledFutureTask> tasks = new ArrayList<MyScheduledFutureTask>(delayQueue);\n    for (MyScheduledFutureTask task : tasks) {\n      if (task.getBackendExecutorService() != backendExecutorService) {\n        continue;\n      }\n      try {\n        task.get(timeout, unit);\n      }\n      catch (ExecutionException ignored) {\n\n      }\n      catch (TimeoutException e) {\n        return false;\n      }\n    }\n    return backendExecutorService.awaitTermination(timeout, unit);\n  }","id":88384,"modified_method":"@Override\n  public boolean awaitTermination(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n    if (!isShutdown()) throw new IllegalStateException(\"must await termination after shutdown() or shutdownNow() only\");\n    List<MyScheduledFutureTask> tasks = new ArrayList<MyScheduledFutureTask>(delayQueue);\n    for (MyScheduledFutureTask task : tasks) {\n      if (task.getBackendExecutorService() != backendExecutorService) {\n        continue;\n      }\n      try {\n        task.get(timeout, unit);\n      }\n      catch (ExecutionException ignored) {\n\n      }\n      catch (TimeoutException e) {\n        return false;\n      }\n    }\n    return backendExecutorService.awaitTermination(timeout, unit);\n  }","commit_id":"0dae08d1234b47dfa132fc35c80db02042e89a03","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public void handleMessage(ByteBuffer buf, Connection c) {\n            long nowNanos = System.nanoTime();\n            ClientResponseImpl response = new ClientResponseImpl();\n            try {\n                response.initFromBuffer(buf);\n            } catch (IOException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }\n\n            final long handle = response.getClientHandle();\n\n            // handle ping response and get out\n            if (handle == PING_HANDLE) {\n                m_outstandingPing = false;\n                return;\n            } else if (handle == ASYNC_TOPO_HANDLE) {\n                /*\n                 * Really didn't want to add this block because it is not DRY\n                 * for the exception handling, but trying to set + reset the async topo callback\n                 * turned out to be pretty challenging\n                 */\n                ProcedureCallback cb = new TopoUpdateCallback();\n                try {\n                    cb.clientCallback(response);\n                } catch (Exception e) {\n                    uncaughtException(cb, response, e);\n                }\n                return;\n            }\n\n            // track the timestamp of the most recent read on this connection\n            m_lastResponseTimeNanos = nowNanos;\n\n            final CallbackBookeeping stuff = m_callbacks.remove(response.getClientHandle());\n\n            // presumably (hopefully) this is a response for a timed-out message\n            if (stuff == null) {\n                // also ignore internal (topology and procedure) calls\n                if (handle >= 0) {\n                    // notify any listeners of the late response\n                    for (ClientStatusListenerExt listener : m_listeners) {\n                        listener.lateProcedureResponse(\n                                response,\n                                m_connection.getHostnameOrIP(),\n                                m_connection.getRemotePort());\n                    }\n                }\n            }\n            // handle a proper callback\n            else {\n                final long callTimeNanos = stuff.timestampNanos;\n                final long deltaNanos = Math.max(1, nowNanos - callTimeNanos);\n                final ProcedureCallback cb = stuff.callback;\n                assert(cb != null);\n                final byte status = response.getStatus();\n                boolean abort = false;\n                boolean error = false;\n                if (status == ClientResponse.USER_ABORT || status == ClientResponse.GRACEFUL_FAILURE) {\n                    abort = true;\n                } else if (status != ClientResponse.SUCCESS) {\n                    error = true;\n                }\n\n                int clusterRoundTrip = response.getClusterRoundtrip();\n                m_rateLimiter.transactionResponseReceived(nowNanos, clusterRoundTrip);\n                updateStats(stuff.name, deltaNanos, clusterRoundTrip, abort, error);\n                response.setClientRoundtrip(deltaNanos);\n                assert(response.getHash() == null); // make sure it didn't sneak into wire protocol\n                try {\n                    cb.clientCallback(response);\n                } catch (Exception e) {\n                    uncaughtException(cb, response, e);\n                }\n            }\n        }","id":88385,"modified_method":"@Override\n        public void handleMessage(ByteBuffer buf, Connection c) {\n            long nowNanos = System.nanoTime();\n            ClientResponseImpl response = new ClientResponseImpl();\n            try {\n                response.initFromBuffer(buf);\n            } catch (IOException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }\n\n            final long handle = response.getClientHandle();\n\n            // handle ping response and get out\n            if (handle == PING_HANDLE) {\n                m_outstandingPing = false;\n                return;\n            } else if (handle == ASYNC_TOPO_HANDLE) {\n                /*\n                 * Really didn't want to add this block because it is not DRY\n                 * for the exception handling, but trying to set + reset the async topo callback\n                 * turned out to be pretty challenging\n                 */\n                ProcedureCallback cb = new TopoUpdateCallback();\n                try {\n                    cb.clientCallback(response);\n                } catch (Exception e) {\n                    uncaughtException(cb, response, e);\n                }\n                return;\n            }\n\n            // track the timestamp of the most recent read on this connection\n            m_lastResponseTimeNanos = nowNanos;\n\n            final CallbackBookeeping stuff = m_callbacks.remove(response.getClientHandle());\n\n            // presumably (hopefully) this is a response for a timed-out message\n            if (stuff == null) {\n                // also ignore internal (topology and procedure) calls\n                if (handle >= 0) {\n                    // notify any listeners of the late response\n                    for (ClientStatusListenerExt listener : m_listeners) {\n                        listener.lateProcedureResponse(\n                                response,\n                                m_connection.getHostnameOrIP(),\n                                m_connection.getRemotePort());\n                    }\n                }\n            }\n            // handle a proper callback\n            else {\n                final long callTimeNanos = stuff.timestampNanos;\n                final long deltaNanos = Math.max(1, nowNanos - callTimeNanos);\n                final ProcedureCallback cb = stuff.callback;\n                assert(cb != null);\n                final byte status = response.getStatus();\n                boolean abort = false;\n                boolean error = false;\n                if (status == ClientResponse.USER_ABORT || status == ClientResponse.GRACEFUL_FAILURE) {\n                    abort = true;\n                } else if (status != ClientResponse.SUCCESS) {\n                    error = true;\n                }\n\n                int clusterRoundTrip = response.getClusterRoundtrip();\n                if (!stuff.ignoreBackpressure) {\n                    m_rateLimiter.transactionResponseReceived(nowNanos, clusterRoundTrip);\n                }\n                updateStats(stuff.name, deltaNanos, clusterRoundTrip, abort, error);\n                response.setClientRoundtrip(deltaNanos);\n                assert(response.getHash() == null); // make sure it didn't sneak into wire protocol\n                try {\n                    cb.clientCallback(response);\n                } catch (Exception e) {\n                    uncaughtException(cb, response, e);\n                }\n            }\n        }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void submitTimeoutTask(final long handle, long timeoutNanos) {\n            m_ex.schedule(new Runnable() {\n                @Override\n                public void run() {\n                    final CallbackBookeeping cb = m_callbacks.remove(handle);\n                    if (cb == null) return;\n                    final long nowNanos = System.nanoTime();\n                    final long deltaNanos = Math.max(1, nowNanos - cb.timestampNanos);\n\n                    ClientResponseImpl r = new ClientResponseImpl(\n                            ClientResponse.CONNECTION_TIMEOUT,\n                            ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                            \"\",\n                            new VoltTable[0],\n                            String.format(\"No response received in the allotted time (set to %d ms).\",\n                                    TimeUnit.NANOSECONDS.toMillis(cb.m_procedureTimeoutNanos)));\n                    r.setClientHandle(handle);\n                    r.setClientRoundtrip(deltaNanos);\n\n                    try {\n                        cb.callback.clientCallback(r);\n                    } catch (Throwable e1) {\n                        e1.printStackTrace();\n                    }\n                    m_rateLimiter.transactionResponseReceived(nowNanos, -1);\n                }\n            }, timeoutNanos, TimeUnit.NANOSECONDS);\n        }","id":88386,"modified_method":"void submitTimeoutTask(final long handle, long timeoutNanos) {\n            m_ex.schedule(new Runnable() {\n                @Override\n                public void run() {\n                    final CallbackBookeeping cb = m_callbacks.remove(handle);\n                    if (cb == null) return;\n                    final long nowNanos = System.nanoTime();\n                    final long deltaNanos = Math.max(1, nowNanos - cb.timestampNanos);\n\n                    ClientResponseImpl r = new ClientResponseImpl(\n                            ClientResponse.CONNECTION_TIMEOUT,\n                            ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                            \"\",\n                            new VoltTable[0],\n                            String.format(\"No response received in the allotted time (set to %d ms).\",\n                                    TimeUnit.NANOSECONDS.toMillis(cb.procedureTimeoutNanos)));\n                    r.setClientHandle(handle);\n                    r.setClientRoundtrip(deltaNanos);\n                    r.setClusterRoundtrip((int)TimeUnit.NANOSECONDS.toMillis(deltaNanos));\n                    try {\n                        cb.callback.clientCallback(r);\n                    } catch (Throwable e1) {\n                        e1.printStackTrace();\n                    }\n                    if (!cb.ignoreBackpressure) {\n                        m_rateLimiter.transactionResponseReceived(nowNanos, -1);\n                    }\n                }\n            }, timeoutNanos, TimeUnit.NANOSECONDS);\n        }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void createWork(long handle, String name, ByteBuffer c,\n                ProcedureCallback callback, boolean ignoreBackpressure, long timeoutNanos) {\n            assert(callback != null);\n            long nowNanos = System.nanoTime();\n            nowNanos = m_rateLimiter.sendTxnWithOptionalBlockAndReturnCurrentTime(\n                    nowNanos, ignoreBackpressure);\n            timeoutNanos = (timeoutNanos == Distributer.USE_DEFAULT_TIMEOUT) ? m_procedureCallTimeoutNanos : timeoutNanos;\n            assert(m_callbacks.containsKey(handle) == false);\n\n            //Optimistically submit the task\n            m_callbacks.put(handle, new CallbackBookeeping(nowNanos, callback, name, timeoutNanos));\n\n            //Schedule an individual timeout if necessary\n            if (timeoutNanos < TimeUnit.SECONDS.toNanos(1)) {\n                submitTimeoutTask(handle, timeoutNanos);\n            }\n\n            //Check for disconnect\n            if (!m_isConnected) {\n                //Check if the disconnect or expiration already handled the callback\n                if (m_callbacks.remove(handle) == null) return;\n                final ClientResponse r = new ClientResponseImpl(\n                        ClientResponse.CONNECTION_LOST, new VoltTable[0],\n                        \"Connection to database host (\" + m_connection.getHostnameAndIPAndPort() +\n                \") was lost before a response was received\");\n                try {\n                    callback.clientCallback(r);\n                } catch (Exception e) {\n                    uncaughtException(callback, r, e);\n                }\n                // for bookkeeping, but it feels dishonest to call this here\n                m_rateLimiter.transactionResponseReceived(nowNanos, -1);\n                return;\n            } else {\n                m_connection.writeStream().enqueue(c);\n            }\n        }","id":88387,"modified_method":"public void createWork(long handle, String name, ByteBuffer c,\n                ProcedureCallback callback, boolean ignoreBackpressure, long timeoutNanos) {\n            assert(callback != null);\n            timeoutNanos = (timeoutNanos == Distributer.USE_DEFAULT_TIMEOUT) ? m_procedureCallTimeoutNanos : timeoutNanos;\n            long nowNanos = System.nanoTime();\n\n            /*\n             * Do rate limiting or check for max outstanding related backpressure in\n             * the rate limiter which can block. If it blocks we can still get a timeout\n             * exception to give prompt timeouts\n             */\n            if (!ignoreBackpressure) {\n                try {\n                    nowNanos = m_rateLimiter.sendTxnWithOptionalBlockAndReturnCurrentTime(\n                            nowNanos, timeoutNanos, ignoreBackpressure);\n                } catch (TimeoutException e) {\n                    /*\n                     * It's possible we need to timeout because it took too long to get\n                     * the transaction out on the wire due to max outstanding\n                     */\n                    final long deltaNanos = Math.max(1, System.nanoTime() - nowNanos);\n                    ClientResponseImpl r = new ClientResponseImpl(\n                            ClientResponse.CONNECTION_TIMEOUT,\n                            ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                            \"\",\n                            new VoltTable[0],\n                            String.format(\"Timed out acquiring outstanding transaction permit (set to %d ms).\",\n                                    TimeUnit.NANOSECONDS.toMillis(timeoutNanos)));\n                    r.setClientHandle(handle);\n                    r.setClientRoundtrip(deltaNanos);\n                    r.setClusterRoundtrip((int)TimeUnit.NANOSECONDS.toMillis(deltaNanos));\n                    try {\n                        callback.clientCallback(r);\n                    } catch (Exception e3) {\n                        uncaughtException(callback, r, e);\n                    }\n                    return;\n                }\n            }\n\n            assert(m_callbacks.containsKey(handle) == false);\n\n            //Optimistically submit the task\n            m_callbacks.put(handle, new CallbackBookeeping(nowNanos, callback, name, timeoutNanos, ignoreBackpressure));\n\n            //Schedule an individual timeout if necessary\n            if (timeoutNanos < TimeUnit.SECONDS.toNanos(1)) {\n                submitTimeoutTask(handle, timeoutNanos);\n            }\n\n            //Check for disconnect\n            if (!m_isConnected) {\n                //Check if the disconnect or expiration already handled the callback\n                if (m_callbacks.remove(handle) == null) return;\n                final ClientResponse r = new ClientResponseImpl(\n                        ClientResponse.CONNECTION_LOST, new VoltTable[0],\n                        \"Connection to database host (\" + m_connection.getHostnameAndIPAndPort() +\n                \") was lost before a response was received\");\n                try {\n                    callback.clientCallback(r);\n                } catch (Exception e) {\n                    uncaughtException(callback, r, e);\n                }\n                if (!ignoreBackpressure) {\n                    //for bookkeeping, but it feels dishonest to call this here\n                    m_rateLimiter.transactionResponseReceived(nowNanos, -1);\n                }\n                return;\n            } else {\n                m_connection.writeStream().enqueue(c);\n            }\n        }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void run() {\n            try {\n                // make a threadsafe copy of all connections\n                ArrayList<NodeConnection> connections = new ArrayList<NodeConnection>();\n                synchronized (Distributer.this) {\n                    connections.addAll(m_connections);\n                }\n\n                final long nowNanos = System.nanoTime();\n\n                // for each connection\n                for (final NodeConnection c : connections) {\n                    // check for connection age\n                    final long sinceLastResponse = Math.max(1, nowNanos - c.m_lastResponseTimeNanos);\n\n                    // if outstanding ping and timeoutMS, close the connection\n                    if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutNanos)) {\n                        // memoize why it's closing\n                        c.m_closeCause = DisconnectCause.TIMEOUT;\n                        // this should trigger NodeConnection.stopping(..)\n                        c.m_connection.unregister();\n                    }\n\n                    // if 1/3 of the timeoutMS since last response, send a ping\n                    if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutNanos / 3))) {\n                        c.sendPing();\n                    }\n\n                    // for each outstanding procedure\n                    for (final Map.Entry<Long, CallbackBookeeping> e : c.m_callbacks.entrySet()) {\n                        final long handle = e.getKey();\n                        final CallbackBookeeping cb = e.getValue();\n\n                        // if the timeout is expired, call the callback and remove the\n                        // bookeeping data\n                        final long deltaNanos = Math.max(1, nowNanos - cb.timestampNanos);\n                        if (deltaNanos > cb.m_procedureTimeoutNanos) {\n\n                            // make the minimum timeoutMS for certain long running system procedures\n                            //  higher than the default 2m.\n                            // you can still set the default timeoutMS higher than even this value\n                            boolean isLongOp = false;\n                            // this form allows you to list ops to treat specially\n                            isLongOp |= cb.name.equals(\"@UpdateApplicationCatalog\");\n                            isLongOp |= cb.name.equals(\"@SnapshotSave\");\n                            if (isLongOp && (deltaNanos < TimeUnit.MILLISECONDS.toNanos(MINIMUM_LONG_RUNNING_SYSTEM_CALL_TIMEOUT_MS))) {\n                                continue;\n                            }\n\n                            //It was handled during the race\n                            if (c.m_callbacks.remove(handle) == null) continue;\n\n                            final ClientResponseImpl r = new ClientResponseImpl(\n                                    ClientResponse.CONNECTION_TIMEOUT,\n                                    ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                                    \"\",\n                                    new VoltTable[0],\n                                    String.format(\"No response received in the allotted time (set to %d ms).\",\n                                            TimeUnit.NANOSECONDS.toMillis(cb.m_procedureTimeoutNanos)));\n                            r.setClientHandle(handle);\n                            r.setClientRoundtrip(deltaNanos);\n                            try {\n                                cb.callback.clientCallback(r);\n                            } catch (Exception e1) {\n                                uncaughtException(cb.callback, r, e1);\n                            }\n                            m_rateLimiter.transactionResponseReceived(nowNanos, -1);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n        }","id":88388,"modified_method":"@Override\n        public void run() {\n            try {\n                // make a threadsafe copy of all connections\n                ArrayList<NodeConnection> connections = new ArrayList<NodeConnection>();\n                synchronized (Distributer.this) {\n                    connections.addAll(m_connections);\n                }\n\n                final long nowNanos = System.nanoTime();\n\n                // for each connection\n                for (final NodeConnection c : connections) {\n                    // check for connection age\n                    final long sinceLastResponse = Math.max(1, nowNanos - c.m_lastResponseTimeNanos);\n\n                    // if outstanding ping and timeoutMS, close the connection\n                    if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutNanos)) {\n                        // memoize why it's closing\n                        c.m_closeCause = DisconnectCause.TIMEOUT;\n                        // this should trigger NodeConnection.stopping(..)\n                        c.m_connection.unregister();\n                    }\n\n                    // if 1/3 of the timeoutMS since last response, send a ping\n                    if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutNanos / 3))) {\n                        c.sendPing();\n                    }\n\n                    // for each outstanding procedure\n                    for (final Map.Entry<Long, CallbackBookeeping> e : c.m_callbacks.entrySet()) {\n                        final long handle = e.getKey();\n                        final CallbackBookeeping cb = e.getValue();\n\n                        // if the timeout is expired, call the callback and remove the\n                        // bookeeping data\n                        final long deltaNanos = Math.max(1, nowNanos - cb.timestampNanos);\n                        if (deltaNanos > cb.procedureTimeoutNanos) {\n\n                            // make the minimum timeoutMS for certain long running system procedures\n                            //  higher than the default 2m.\n                            // you can still set the default timeoutMS higher than even this value\n                            boolean isLongOp = false;\n                            // this form allows you to list ops to treat specially\n                            isLongOp |= cb.name.equals(\"@UpdateApplicationCatalog\");\n                            isLongOp |= cb.name.equals(\"@SnapshotSave\");\n                            if (isLongOp && (deltaNanos < TimeUnit.MILLISECONDS.toNanos(MINIMUM_LONG_RUNNING_SYSTEM_CALL_TIMEOUT_MS))) {\n                                continue;\n                            }\n\n                            //It was handled during the race\n                            if (c.m_callbacks.remove(handle) == null) continue;\n\n                            final ClientResponseImpl r = new ClientResponseImpl(\n                                    ClientResponse.CONNECTION_TIMEOUT,\n                                    ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                                    \"\",\n                                    new VoltTable[0],\n                                    String.format(\"No response received in the allotted time (set to %d ms).\",\n                                            TimeUnit.NANOSECONDS.toMillis(cb.procedureTimeoutNanos)));\n                            r.setClientHandle(handle);\n                            r.setClientRoundtrip(deltaNanos);\n                            r.setClusterRoundtrip((int)TimeUnit.NANOSECONDS.toMillis(deltaNanos));\n                            try {\n                                cb.callback.clientCallback(r);\n                            } catch (Exception e1) {\n                                uncaughtException(cb.callback, r, e1);\n                            }\n                            if (!cb.ignoreBackpressure) {\n                                m_rateLimiter.transactionResponseReceived(nowNanos, -1);\n                            }\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n        }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public CallbackBookeeping(long timestampNanos, ProcedureCallback callback, String name, long timeoutNanos) {\n            assert(callback != null);\n            this.timestampNanos = timestampNanos;\n            this.callback = callback;\n            this.name = name;\n            this.m_procedureTimeoutNanos = timeoutNanos;\n        }","id":88389,"modified_method":"public CallbackBookeeping(long timestampNanos, ProcedureCallback callback, String name, long timeoutNanos, boolean ignoreBackpressure) {\n            assert(callback != null);\n            this.timestampNanos = timestampNanos;\n            this.callback = callback;\n            this.name = name;\n            this.procedureTimeoutNanos = timeoutNanos;\n            this.ignoreBackpressure = ignoreBackpressure;\n        }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void stopping(Connection c) {\n            super.stopping(c);\n            m_isConnected = false;\n            //Prevent queueing of new work to this connection\n            synchronized (Distributer.this) {\n                /*\n                 * Repair all cluster topology data with the node connection removed\n                 */\n                Iterator<Map.Entry<Integer, NodeConnection>> i = m_partitionMasters.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry<Integer, NodeConnection> entry = i.next();\n                    if (entry.getValue() == this) {\n                        i.remove();\n                    }\n                }\n\n                i = m_hostIdToConnection.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry<Integer, NodeConnection> entry = i.next();\n                    if (entry.getValue() == this) {\n                        i.remove();\n                    }\n                }\n\n                Iterator<Map.Entry<Integer, NodeConnection[]>> i2 = m_partitionReplicas.entrySet().iterator();\n                List<Pair<Integer, NodeConnection[]>> entriesToRewrite = new ArrayList<Pair<Integer, NodeConnection[]>>();\n                while (i2.hasNext()) {\n                    Map.Entry<Integer, NodeConnection[]> entry = i2.next();\n                    for (NodeConnection nc : entry.getValue()) {\n                        if (nc == this) {\n                            entriesToRewrite.add(Pair.of(entry.getKey(), entry.getValue()));\n                        }\n                    }\n                }\n\n                for (Pair<Integer, NodeConnection[]> entry : entriesToRewrite) {\n                    m_partitionReplicas.remove(entry.getFirst());\n                    NodeConnection survivors[] = new NodeConnection[entry.getSecond().length - 1];\n                    if (survivors.length == 0) break;\n                    int zz = 0;\n                    for (int ii = 0; ii < entry.getSecond().length; ii++) {\n                        if (entry.getSecond()[ii] != this) {\n                            survivors[zz++] = entry.getSecond()[ii];\n                        }\n                    }\n                    m_partitionReplicas.put(entry.getFirst(), survivors);\n                }\n\n                m_connections.remove(this);\n                //Notify listeners that a connection has been lost\n                for (ClientStatusListenerExt s : m_listeners) {\n                    s.connectionLost(\n                            m_connection.getHostnameOrIP(),\n                            m_connection.getRemotePort(),\n                            m_connections.size(),\n                            m_closeCause);\n                }\n\n                /*\n                 * Deal with the fact that this may have been the connection that subscriptions were issued\n                 * to. If a subscription request was pending, don't handle selecting a new node here\n                 * let the callback see the failure and retry\n                 */\n                if (m_useClientAffinity &&\n                    m_subscribedConnection == this &&\n                    m_subscriptionRequestPending == false &&\n                    !m_ex.isShutdown()) {\n                    //Don't subscribe to a new node immediately\n                    //to somewhat prevent a thundering herd\n                    m_ex.schedule(new Runnable() {\n                        @Override\n                        public void run() {\n                            subscribeToNewNode();\n                        }\n                    }, new Random().nextInt(RESUBSCRIPTION_DELAY_MS), TimeUnit.MILLISECONDS);\n                }\n            }\n\n            //Invoke callbacks for all queued invocations with a failure response\n            final ClientResponse r =\n                new ClientResponseImpl(\n                        ClientResponse.CONNECTION_LOST, new VoltTable[0],\n                        \"Connection to database host (\" + m_connection.getHostnameAndIPAndPort() +\n                \") was lost before a response was received\");\n            for (Map.Entry<Long, CallbackBookeeping> e : m_callbacks.entrySet()) {\n                //Check for race with other threads\n                if (m_callbacks.remove(e.getKey()) == null) continue;\n                final CallbackBookeeping callBk = e.getValue();\n                try {\n                    callBk.callback.clientCallback(r);\n                }\n                catch (Exception ex) {\n                    uncaughtException(callBk.callback, r, ex);\n                }\n                m_rateLimiter.transactionResponseReceived(System.currentTimeMillis(), -1);\n            }\n            m_callbacks.clear();\n        }","id":88390,"modified_method":"@Override\n        public void stopping(Connection c) {\n            super.stopping(c);\n            m_isConnected = false;\n            //Prevent queueing of new work to this connection\n            synchronized (Distributer.this) {\n                /*\n                 * Repair all cluster topology data with the node connection removed\n                 */\n                Iterator<Map.Entry<Integer, NodeConnection>> i = m_partitionMasters.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry<Integer, NodeConnection> entry = i.next();\n                    if (entry.getValue() == this) {\n                        i.remove();\n                    }\n                }\n\n                i = m_hostIdToConnection.entrySet().iterator();\n                while (i.hasNext()) {\n                    Map.Entry<Integer, NodeConnection> entry = i.next();\n                    if (entry.getValue() == this) {\n                        i.remove();\n                    }\n                }\n\n                Iterator<Map.Entry<Integer, NodeConnection[]>> i2 = m_partitionReplicas.entrySet().iterator();\n                List<Pair<Integer, NodeConnection[]>> entriesToRewrite = new ArrayList<Pair<Integer, NodeConnection[]>>();\n                while (i2.hasNext()) {\n                    Map.Entry<Integer, NodeConnection[]> entry = i2.next();\n                    for (NodeConnection nc : entry.getValue()) {\n                        if (nc == this) {\n                            entriesToRewrite.add(Pair.of(entry.getKey(), entry.getValue()));\n                        }\n                    }\n                }\n\n                for (Pair<Integer, NodeConnection[]> entry : entriesToRewrite) {\n                    m_partitionReplicas.remove(entry.getFirst());\n                    NodeConnection survivors[] = new NodeConnection[entry.getSecond().length - 1];\n                    if (survivors.length == 0) break;\n                    int zz = 0;\n                    for (int ii = 0; ii < entry.getSecond().length; ii++) {\n                        if (entry.getSecond()[ii] != this) {\n                            survivors[zz++] = entry.getSecond()[ii];\n                        }\n                    }\n                    m_partitionReplicas.put(entry.getFirst(), survivors);\n                }\n\n                m_connections.remove(this);\n                //Notify listeners that a connection has been lost\n                for (ClientStatusListenerExt s : m_listeners) {\n                    s.connectionLost(\n                            m_connection.getHostnameOrIP(),\n                            m_connection.getRemotePort(),\n                            m_connections.size(),\n                            m_closeCause);\n                }\n\n                /*\n                 * Deal with the fact that this may have been the connection that subscriptions were issued\n                 * to. If a subscription request was pending, don't handle selecting a new node here\n                 * let the callback see the failure and retry\n                 */\n                if (m_useClientAffinity &&\n                    m_subscribedConnection == this &&\n                    m_subscriptionRequestPending == false &&\n                    !m_ex.isShutdown()) {\n                    //Don't subscribe to a new node immediately\n                    //to somewhat prevent a thundering herd\n                    m_ex.schedule(new Runnable() {\n                        @Override\n                        public void run() {\n                            subscribeToNewNode();\n                        }\n                    }, new Random().nextInt(RESUBSCRIPTION_DELAY_MS), TimeUnit.MILLISECONDS);\n                }\n            }\n\n            //Invoke callbacks for all queued invocations with a failure response\n            final ClientResponse r =\n                new ClientResponseImpl(\n                        ClientResponse.CONNECTION_LOST, new VoltTable[0],\n                        \"Connection to database host (\" + m_connection.getHostnameAndIPAndPort() +\n                \") was lost before a response was received\");\n            for (Map.Entry<Long, CallbackBookeeping> e : m_callbacks.entrySet()) {\n                //Check for race with other threads\n                if (m_callbacks.remove(e.getKey()) == null) continue;\n                final CallbackBookeeping callBk = e.getValue();\n                try {\n                    callBk.callback.clientCallback(r);\n                }\n                catch (Exception ex) {\n                    uncaughtException(callBk.callback, r, ex);\n                }\n                if (!callBk.ignoreBackpressure) {\n                    m_rateLimiter.transactionResponseReceived(System.nanoTime(), -1);\n                }\n            }\n            m_callbacks.clear();\n        }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void transactionResponseReceived(long timestampNanos, int internalLatency) {\n        if (m_autoTune) {\n            synchronized (this) {\n                ensureCurrentBlockIsKosher(TimeUnit.NANOSECONDS.toMillis(timestampNanos));\n                //Wake someone up if they are blocked\n                if (m_outstandingTxns > m_maxOutstandingTxns && m_outstandingTxns - 1 == m_maxOutstandingTxns) {\n                    this.notify();\n                }\n                --m_outstandingTxns;\n                assert(m_outstandingTxns >= 0);\n                if (internalLatency != -1) {\n                    ++m_currentBlockRecvSuccessCount;\n                    m_currentBlockTotalInternalLatency += internalLatency;\n                }\n            }\n        } else {\n            m_outstandingTxnsSemaphore.release();\n        }\n    }","id":88391,"modified_method":"void transactionResponseReceived(long timestampNanos, int internalLatency) {\n        if (m_doesAnyTuning) {\n            synchronized (this) {\n                ensureCurrentBlockIsKosher(TimeUnit.NANOSECONDS.toMillis(timestampNanos));\n                //Wake someone up if they are blocked\n                if (m_outstandingTxns > m_maxOutstandingTxns && m_outstandingTxns - 1 == m_maxOutstandingTxns) {\n                    this.notify();\n                }\n                --m_outstandingTxns;\n                assert(m_outstandingTxns >= 0);\n                if (internalLatency != -1) {\n                    ++m_currentBlockRecvSuccessCount;\n                    m_currentBlockTotalInternalLatency += internalLatency;\n                }\n            }\n        } else {\n            m_outstandingTxnsSemaphore.release();\n        }\n    }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * May not be reflected until the next 100ms.\n     */\n    synchronized void enableAutoTuning(int latencyTarget) {\n        m_autoTune = true;\n        m_targetTxnsPerSecond = Integer.MAX_VALUE;\n        m_maxOutstandingTxns = 20;\n        m_latencyTarget = latencyTarget;\n    }","id":88392,"modified_method":"/**\n     * May not be reflected until the next 100ms.\n     */\n    synchronized void enableAutoTuning(int latencyTarget) {\n        m_autoTune = true;\n        m_doesAnyTuning = true;\n        m_targetTxnsPerSecond = Integer.MAX_VALUE;\n        m_maxOutstandingTxns = 20;\n        m_latencyTarget = latencyTarget;\n    }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     *\n     *\n     * @param timestamp The time as measured when the call is made.\n     * @param ignoreBackpressure If true, never block.\n     * @return The time as measured when the call returns.\n     */\n    long sendTxnWithOptionalBlockAndReturnCurrentTime(long timestampNanos, boolean ignoreBackpressure) {\n        if (m_autoTune) {\n            long timestamp = TimeUnit.NANOSECONDS.toMillis(timestampNanos);\n            while (true) {\n                synchronized(this) {\n                    // switch to a new block if 100ms has passed\n                    // possibly compute a new target rate\n                    ensureCurrentBlockIsKosher(timestamp);\n\n                    assert((timestamp - m_currentBlockTimestamp) <= BLOCK_SIZE);\n\n                    // don't let the time be before the start of the current block\n                    // also ensure faketime - m_currentBlockTimestamp is positive\n                    long faketime = timestamp < m_currentBlockTimestamp ? m_currentBlockTimestamp : timestamp;\n\n                    long targetTxnsPerBlock = m_targetTxnsPerSecond / (1000 / BLOCK_SIZE);\n\n                    // compute the percentage of the current 100ms block that has passed\n                    double expectedTxnsSent =\n                            targetTxnsPerBlock * (faketime - m_currentBlockTimestamp + 1.0) / BLOCK_SIZE;\n                    expectedTxnsSent = Math.ceil(expectedTxnsSent);\n\n                    assert(expectedTxnsSent <= targetTxnsPerBlock); // stupid fp math\n                    assert((expectedTxnsSent >= 1.0) || (targetTxnsPerBlock == 0));\n\n                    // if the rate is under target, no problems\n                    if (((m_currentBlockSendCount < expectedTxnsSent) &&\n                         (m_outstandingTxns < m_maxOutstandingTxns)) ||\n                        (ignoreBackpressure == true)) {\n\n                        // bookkeeping\n                        ++m_currentBlockSendCount;\n                        ++m_outstandingTxns;\n\n                        // exit the while loop\n                        break;\n                    }\n                }\n\n                // if the rate is above target, pause for the smallest time possible\n                try { Thread.sleep(1); } catch (InterruptedException e) {}\n                timestampNanos = System.nanoTime();\n                timestamp = TimeUnit.NANOSECONDS.toMillis(timestampNanos);\n            }\n        } else {\n            boolean acquired = m_outstandingTxnsSemaphore.tryAcquire();\n\n            if (!acquired) {\n                try {\n                    m_outstandingTxnsSemaphore.acquire();\n                } catch (InterruptedException e) {\n                    Throwables.propagate(e);\n                }\n                return System.nanoTime();\n            }\n        }\n\n        // this time may have changed if this call blocked during a sleep\n        return timestampNanos;\n    }","id":88393,"modified_method":"/**\n     *\n     *\n     * @param timestamp The time as measured when the call is made.\n     * @param ignoreBackpressure If true, never block.\n     * @return The time as measured when the call returns.\n     */\n    long sendTxnWithOptionalBlockAndReturnCurrentTime(long timestampNanos, long timeoutNanos, boolean ignoreBackpressure) throws TimeoutException {\n        if (m_doesAnyTuning) {\n            long timestamp = TimeUnit.NANOSECONDS.toMillis(timestampNanos);\n            while (true) {\n                synchronized(this) {\n                    // switch to a new block if 100ms has passed\n                    // possibly compute a new target rate\n                    ensureCurrentBlockIsKosher(timestamp);\n\n                    assert((timestamp - m_currentBlockTimestamp) <= BLOCK_SIZE);\n\n                    // don't let the time be before the start of the current block\n                    // also ensure faketime - m_currentBlockTimestamp is positive\n                    long faketime = timestamp < m_currentBlockTimestamp ? m_currentBlockTimestamp : timestamp;\n\n                    long targetTxnsPerBlock = m_targetTxnsPerSecond / (1000 / BLOCK_SIZE);\n\n                    // compute the percentage of the current 100ms block that has passed\n                    double expectedTxnsSent =\n                            targetTxnsPerBlock * (faketime - m_currentBlockTimestamp + 1.0) / BLOCK_SIZE;\n                    expectedTxnsSent = Math.ceil(expectedTxnsSent);\n\n                    assert(expectedTxnsSent <= targetTxnsPerBlock); // stupid fp math\n                    assert((expectedTxnsSent >= 1.0) || (targetTxnsPerBlock == 0));\n\n                    // if the rate is under target, no problems\n                    if (((m_currentBlockSendCount < expectedTxnsSent) &&\n                         (m_outstandingTxns < m_maxOutstandingTxns)) ||\n                        (ignoreBackpressure == true)) {\n\n                        // bookkeeping\n                        ++m_currentBlockSendCount;\n                        ++m_outstandingTxns;\n\n                        // exit the while loop\n                        break;\n                    }\n                }\n\n                // if the rate is above target, pause for the smallest time possible\n                try { Thread.sleep(1); } catch (InterruptedException e) {}\n                timestampNanos = System.nanoTime();\n                timestamp = TimeUnit.NANOSECONDS.toMillis(timestampNanos);\n            }\n        } else {\n            boolean acquired = m_outstandingTxnsSemaphore.tryAcquire();\n\n            if (!acquired) {\n                try {\n                    if (!m_outstandingTxnsSemaphore.tryAcquire(timeoutNanos, TimeUnit.NANOSECONDS)) {\n                        throw new TimeoutException();\n                    }\n                } catch (InterruptedException e) {\n                    Throwables.propagate(e);\n                }\n                return System.nanoTime();\n            }\n        }\n\n        // this time may have changed if this call blocked during a sleep\n        return timestampNanos;\n    }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * May not be reflected until the next 100ms.\n     */\n    synchronized void setLimits(int txnsPerSec, int maxOutstanding) {\n        m_autoTune = false;\n        m_targetTxnsPerSecond = txnsPerSec;\n        m_maxOutstandingTxns = maxOutstanding;\n        m_outstandingTxnsSemaphore.drainPermits();\n        m_outstandingTxnsSemaphore.release(maxOutstanding);\n    }","id":88394,"modified_method":"/**\n     * May not be reflected until the next 100ms.\n     */\n    synchronized void setLimits(int txnsPerSec, int maxOutstanding) {\n        m_autoTune = false;\n        /*\n         * If the rate limit is some reasonably low value then go through the effort\n         * of rate limiting\n         */\n        if (txnsPerSec < Integer.MAX_VALUE / 2) {\n            m_doesAnyTuning = true;\n        }\n        m_targetTxnsPerSecond = txnsPerSec;\n        m_maxOutstandingTxns = maxOutstanding;\n        m_outstandingTxnsSemaphore.drainPermits();\n        m_outstandingTxnsSemaphore.release(maxOutstanding);\n    }","commit_id":"8f62b2d41d37d29d2811f91c98fc46e9496c4328","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static Object generateId(Gradle gradle, String operationName) {\n        return String.format(\"%s:%s\", generateId(gradle), operationName);\n    }","id":88395,"modified_method":"public static Object generateId(Gradle gradle, String operationName) {\n        return generateId(gradle) + \":\" + operationName;\n    }","commit_id":"27646a870dd505fb93c184bc3d739945d0e9badb","url":"https://github.com/gradle/gradle"},{"original_method":"public static Object generateId(Settings settings) {\n        return String.format(\"%s:%s\", generateId(settings.getGradle()), System.identityHashCode(settings));\n    }","id":88396,"modified_method":"public static Object generateId(Settings settings) {\n        return generateId(settings.getGradle()) + \":\" + System.identityHashCode(settings);\n    }","commit_id":"27646a870dd505fb93c184bc3d739945d0e9badb","url":"https://github.com/gradle/gradle"},{"original_method":"public static Object generateId(Task task) {\n        return String.format(\"%s:%s\", generateId(task.getProject().getGradle()), task.getPath());\n    }","id":88397,"modified_method":"public static Object generateId(Task task) {\n        return generateId(task.getProject().getGradle()) + \":\" + task.getPath();\n    }","commit_id":"27646a870dd505fb93c184bc3d739945d0e9badb","url":"https://github.com/gradle/gradle"},{"original_method":"private void executeTask(TaskInfo taskInfo) {\n            TaskInternal task = taskInfo.getTask();\n            TaskStateInternal state = task.getState();\n            Project project = task.getProject();\n            String parentId = project!=null?OperationIdGenerator.generateId(project.getGradle()):null;\n            TaskOperationInternal taskOperation = new TaskOperationInternal(OperationIdGenerator.generateId(task), task, state, parentId);\n            synchronized (lock) {\n                taskListener.beforeExecute(taskOperation);\n            }\n            try {\n                task.executeWithoutThrowingTaskFailure();\n            } finally {\n                synchronized (lock) {\n                    taskListener.afterExecute(taskOperation);\n                }\n            }\n        }","id":88398,"modified_method":"private void executeTask(TaskInfo taskInfo) {\n            TaskInternal task = taskInfo.getTask();\n            Object id = OperationIdGenerator.generateId(task);\n            Object parentId = OperationIdGenerator.generateId(task.getProject().getGradle());\n            TaskOperationInternal taskOperation = new TaskOperationInternal(id, task, parentId);\n            synchronized (lock) {\n                taskListener.beforeExecute(taskOperation);\n            }\n            try {\n                task.executeWithoutThrowingTaskFailure();\n            } finally {\n                synchronized (lock) {\n                    taskListener.afterExecute(taskOperation);\n                }\n            }\n        }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void afterExecute(TaskOperationInternal taskOperation) {\n        eventConsumer.dispatch(new DefaultTaskFinishedProgressEvent(taskOperation.getState().getEndTime(), toTaskDescriptor(taskOperation), toTaskResult(taskOperation.getTask())));\n    }","id":88399,"modified_method":"@Override\n    public void afterExecute(TaskOperationInternal taskOperation) {\n        eventConsumer.dispatch(new DefaultTaskFinishedProgressEvent(taskOperation.getTask().getState().getEndTime(), toTaskDescriptor(taskOperation), toTaskResult(taskOperation.getTask())));\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void beforeExecute(TaskOperationInternal taskOperation) {\n        eventConsumer.dispatch(new DefaultTaskStartedProgressEvent(taskOperation.getState().getStartTime(), toTaskDescriptor(taskOperation)));\n    }","id":88400,"modified_method":"@Override\n    public void beforeExecute(TaskOperationInternal taskOperation) {\n        eventConsumer.dispatch(new DefaultTaskStartedProgressEvent(taskOperation.getTask().getState().getStartTime(), toTaskDescriptor(taskOperation)));\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> T internalBuildOperation(String id, String eventType, Factory<T> factory) {\n        String eventId = id != null ? id : eventType;\n        InternalBuildOperation startEvent = new InternalBuildOperation(eventId, gradle, parentEvent);\n        long sd = System.currentTimeMillis();\n        internalBuildListener.started(startEvent, sd, eventType);\n        parentEvent = startEvent;\n        T result = null;\n        Throwable error = null;\n        try {\n            result = factory.create();\n        } catch (Throwable e) {\n            error = e;\n        }\n        parentEvent = startEvent.getParent();\n        InternalBuildOperation endEvent = new InternalBuildOperation(eventId, error!=null?error:result, parentEvent);\n        internalBuildListener.finished(endEvent, sd, System.currentTimeMillis(), eventType);\n        if (error!=null) {\n            UncheckedException.throwAsUncheckedException(error);\n        }\n        return result;\n    }","id":88401,"modified_method":"private <T> T internalBuildOperation(Object id, String eventType, Factory<T> factory) {\n        Object eventId = id != null ? id : eventType;\n        InternalBuildOperation startEvent = new InternalBuildOperation(eventId, gradle, parentEvent);\n        long sd = System.currentTimeMillis();\n        internalBuildListener.started(startEvent, sd, eventType);\n        parentEvent = startEvent;\n        T result = null;\n        Throwable error = null;\n        try {\n            result = factory.create();\n        } catch (Throwable e) {\n            error = e;\n        }\n        parentEvent = startEvent.getParent();\n        InternalBuildOperation endEvent = new InternalBuildOperation(eventId, error!=null?error:result, parentEvent);\n        internalBuildListener.finished(endEvent, sd, System.currentTimeMillis(), eventType);\n        if (error!=null) {\n            UncheckedException.throwAsUncheckedException(error);\n        }\n        return result;\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void afterExecute(TaskOperationInternal taskOperation) {\n            TaskInternal task = taskOperation.getTask();\n            TaskStateInternal state = taskOperation.getState();\n            taskListeners.getSource().afterExecute(task, state);\n            state.setEndTime(System.currentTimeMillis());\n            internalTaskListeners.getSource().afterExecute(taskOperation);\n        }","id":88402,"modified_method":"@Override\n        public void afterExecute(TaskOperationInternal taskOperation) {\n            TaskInternal task = taskOperation.getTask();\n            TaskStateInternal state = task.getState();\n            taskListeners.getSource().afterExecute(task, state);\n            state.setEndTime(System.currentTimeMillis());\n            internalTaskListeners.getSource().afterExecute(taskOperation);\n        }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void beforeExecute(TaskOperationInternal taskOperation) {\n            taskOperation.getState().setStartTime(System.currentTimeMillis());\n            internalTaskListeners.getSource().beforeExecute(taskOperation);\n            taskListeners.getSource().beforeExecute(taskOperation.getTask());\n        }","id":88403,"modified_method":"@Override\n        public void beforeExecute(TaskOperationInternal taskOperation) {\n            TaskInternal task = taskOperation.getTask();\n            TaskStateInternal state = task.getState();\n            state.setStartTime(System.currentTimeMillis());\n            internalTaskListeners.getSource().beforeExecute(taskOperation);\n            taskListeners.getSource().beforeExecute(task);\n        }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(final Test testTask, TestResultProcessor testResultProcessor) {\n        final TestFramework testFramework = testTask.getTestFramework();\n        final WorkerTestClassProcessorFactory testInstanceFactory = testFramework.getProcessorFactory();\n        final Factory<TestClassProcessor> forkingProcessorFactory = new Factory<TestClassProcessor>() {\n            public TestClassProcessor create() {\n                return new ForkingTestClassProcessor(workerFactory, testInstanceFactory, testTask,\n                    testTask.getClasspath(), testFramework.getWorkerConfigurationAction());\n            }\n        };\n        Factory<TestClassProcessor> reforkingProcessorFactory = new Factory<TestClassProcessor>() {\n            public TestClassProcessor create() {\n                return new RestartEveryNTestClassProcessor(forkingProcessorFactory, testTask.getForkEvery());\n            }\n        };\n\n        TestClassProcessor processor = new MaxNParallelTestClassProcessor(testTask.getMaxParallelForks(),\n            reforkingProcessorFactory, actorFactor);\n\n        final FileTree testClassFiles = testTask.getCandidateClassFiles();\n\n        Runnable detector;\n        if (testTask.isScanForTestClasses()) {\n            TestFrameworkDetector testFrameworkDetector = testTask.getTestFramework().getDetector();\n            testFrameworkDetector.setTestClassesDirectory(testTask.getTestClassesDir());\n            testFrameworkDetector.setTestClasspath(testTask.getClasspath());\n            detector = new DefaultTestClassScanner(testClassFiles, testFrameworkDetector, processor);\n        } else {\n            detector = new DefaultTestClassScanner(testClassFiles, null, processor);\n        }\n\n        final String testTaskOperationId = OperationIdGenerator.generateId(testTask);\n\n        new TestMainAction(detector, processor, testResultProcessor, new TrueTimeProvider(), testTaskOperationId, testTask.getPath(), String.format(\"Gradle Test Run %s\", testTask.getPath())).run();\n    }","id":88404,"modified_method":"public void execute(final Test testTask, TestResultProcessor testResultProcessor) {\n        final TestFramework testFramework = testTask.getTestFramework();\n        final WorkerTestClassProcessorFactory testInstanceFactory = testFramework.getProcessorFactory();\n        final Factory<TestClassProcessor> forkingProcessorFactory = new Factory<TestClassProcessor>() {\n            public TestClassProcessor create() {\n                return new ForkingTestClassProcessor(workerFactory, testInstanceFactory, testTask,\n                    testTask.getClasspath(), testFramework.getWorkerConfigurationAction());\n            }\n        };\n        Factory<TestClassProcessor> reforkingProcessorFactory = new Factory<TestClassProcessor>() {\n            public TestClassProcessor create() {\n                return new RestartEveryNTestClassProcessor(forkingProcessorFactory, testTask.getForkEvery());\n            }\n        };\n\n        TestClassProcessor processor = new MaxNParallelTestClassProcessor(testTask.getMaxParallelForks(),\n            reforkingProcessorFactory, actorFactor);\n\n        final FileTree testClassFiles = testTask.getCandidateClassFiles();\n\n        Runnable detector;\n        if (testTask.isScanForTestClasses()) {\n            TestFrameworkDetector testFrameworkDetector = testTask.getTestFramework().getDetector();\n            testFrameworkDetector.setTestClassesDirectory(testTask.getTestClassesDir());\n            testFrameworkDetector.setTestClasspath(testTask.getClasspath());\n            detector = new DefaultTestClassScanner(testClassFiles, testFrameworkDetector, processor);\n        } else {\n            detector = new DefaultTestClassScanner(testClassFiles, null, processor);\n        }\n\n        final Object testTaskOperationId = OperationIdGenerator.generateId(testTask);\n\n        new TestMainAction(detector, processor, testResultProcessor, new TrueTimeProvider(), testTaskOperationId, testTask.getPath(), String.format(\"Gradle Test Run %s\", testTask.getPath())).run();\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public InternalBuildOperation(String id, Object payload, InternalBuildOperation parent) {\n        this.id = id;\n        this.payload = payload;\n        this.parent = parent;\n    }","id":88405,"modified_method":"public InternalBuildOperation(Object id, Object payload, InternalBuildOperation parent) {\n        this.id = id;\n        this.payload = payload;\n        this.parent = parent;\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public static String generateId(Task task) {\n        if (task==null) {\n            return null;\n        }\n        Project project = task.getProject();\n        Gradle gradle = project!=null?project.getGradle():null;\n        return generateId(gradle, task.getPath());\n    }","id":88406,"modified_method":"public static Object generateId(Task task) {\n        return generateId(task.getProject().getGradle(), task.getPath());\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public static String generateId(Gradle gradle) {\n        return gradle == null ? \"\" : String.valueOf(System.identityHashCode(gradle));\n    }","id":88407,"modified_method":"public static Object generateId(Gradle gradle) {\n        return gradle == null ? null : String.valueOf(System.identityHashCode(gradle));\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public static String generateId(Gradle gradle, String operationName) {\n        return String.format(\"%s : %s\", generateId(gradle), operationName);\n    }","id":88408,"modified_method":"public static Object generateId(Gradle gradle, String operationName) {\n        return generateId(gradle) + \"-\" + operationName;\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskOperationInternal(String id, TaskInternal task, TaskStateInternal state, String parentId) {\n        this.id = id;\n        this.task = task;\n        this.state = state;\n        this.parentId = parentId;\n    }","id":88409,"modified_method":"public TaskOperationInternal(Object id, TaskInternal task, Object parentId) {\n        this.id = id;\n        this.task = task;\n        this.parentId = parentId;\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public TestMainAction(Runnable detector, TestClassProcessor processor, TestResultProcessor resultProcessor, TimeProvider timeProvider, String testTaskOperationId, String rootTestSuiteId, String displayName) {\n        this.detector = detector;\n        this.processor = processor;\n        this.resultProcessor = new AttachParentTestResultProcessor(resultProcessor);\n        this.timeProvider = timeProvider;\n        this.testTaskOperationId = testTaskOperationId;\n        this.rootTestSuiteId = rootTestSuiteId;\n        this.displayName = displayName;\n    }","id":88410,"modified_method":"public TestMainAction(Runnable detector, TestClassProcessor processor, TestResultProcessor resultProcessor, TimeProvider timeProvider, Object testTaskOperationId, Object rootTestSuiteId, String displayName) {\n        this.detector = detector;\n        this.processor = processor;\n        this.resultProcessor = new AttachParentTestResultProcessor(resultProcessor);\n        this.timeProvider = timeProvider;\n        this.testTaskOperationId = testTaskOperationId;\n        this.rootTestSuiteId = rootTestSuiteId;\n        this.displayName = displayName;\n    }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"private RootTestSuiteDescriptor(Object id, String name, String testTaskOperationId) {\n            super(id, name);\n            this.testTaskOperationId = testTaskOperationId;\n        }","id":88411,"modified_method":"private RootTestSuiteDescriptor(Object id, String name, Object testTaskOperationId) {\n            super(id, name);\n            this.testTaskOperationId = testTaskOperationId;\n        }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"public String getTestTaskOperationId() {\n            return testTaskOperationId;\n        }","id":88412,"modified_method":"public Object getTestTaskOperationId() {\n            return testTaskOperationId;\n        }","commit_id":"cbc3f3e7c9ebd04251810473c8d044dfb9b9c7c9","url":"https://github.com/gradle/gradle"},{"original_method":"protected InboundEndpoint createTestInboundEndpoint(Filter filter,\n                                                        EndpointSecurityFilter securityFilter,\n                                                        Transformer transformer,\n                                                        Transformer responseTransformer,\n                                                        MessageExchangePattern exchangePattern,\n                                                        TransactionConfig txConfig)\n        throws EndpointException, InitialisationException\n    {\n        EndpointURIEndpointBuilder endpointBuilder = new EndpointURIEndpointBuilder(TEST_URI, muleContext);\n        endpointBuilder.addMessageProcessor(new MessageFilter(filter));\n        endpointBuilder.addMessageProcessor(new SecurityFilterMessageProcessorBuilder(securityFilter));\n        if (transformer != null)\n        {\n            endpointBuilder.setTransformers(Collections.singletonList(transformer));\n        }\n        if (responseTransformer != null)\n        {\n            endpointBuilder.setResponseTransformers(Collections.singletonList(responseTransformer));\n        }\n        endpointBuilder.setExchangePattern(exchangePattern);\n        endpointBuilder.setTransactionConfig(txConfig);\n        InboundEndpoint endpoint = endpointBuilder.buildInboundEndpoint();\n        return endpoint;\n    }","id":88413,"modified_method":"protected InboundEndpoint createTestInboundEndpoint(Filter filter,\n                                                        EndpointSecurityFilter securityFilter,\n                                                        Transformer transformer,\n                                                        Transformer responseTransformer,\n                                                        MessageExchangePattern exchangePattern,\n                                                        TransactionConfig txConfig)\n        throws EndpointException, InitialisationException\n    {\n        EndpointURIEndpointBuilder endpointBuilder = new EndpointURIEndpointBuilder(TEST_URI, muleContext);\n        if (filter != null)\n        {\n            endpointBuilder.addMessageProcessor(new MessageFilter(filter));\n        }\n        if (securityFilter != null)\n        {\n            endpointBuilder.addMessageProcessor(new SecurityFilterMessageProcessor(securityFilter));\n        }\n        if (transformer != null)\n        {\n            endpointBuilder.setTransformers(Collections.singletonList(transformer));\n        }\n        if (responseTransformer != null)\n        {\n            endpointBuilder.setResponseTransformers(Collections.singletonList(responseTransformer));\n        }\n        endpointBuilder.setExchangePattern(exchangePattern);\n        endpointBuilder.setTransactionConfig(txConfig);\n        InboundEndpoint endpoint = endpointBuilder.buildInboundEndpoint();\n        return endpoint;\n    }","commit_id":"c51c98fa898cb68ba80bb956c69194632d164d80","url":"https://github.com/mulesoft/mule"},{"original_method":"protected OutboundEndpoint createTestOutboundEndpoint(String uri, Filter filter,\n                                                          EndpointSecurityFilter securityFilter,\n                                                          Transformer transformer,\n                                                          Transformer responseTransformer,\n                                                          MessageExchangePattern exchangePattern,\n                                                          TransactionConfig txConfig)\n        throws EndpointException, InitialisationException\n    {\n        EndpointURIEndpointBuilder endpointBuilder = new EndpointURIEndpointBuilder(uri,\n            muleContext);\n        endpointBuilder.addMessageProcessor(new MessageFilter(filter));\n        endpointBuilder.addMessageProcessor(new SecurityFilterMessageProcessorBuilder(securityFilter));\n        if (transformer != null)\n        {\n            endpointBuilder.setMessageProcessors(Collections.singletonList(transformer));\n        }\n        if (responseTransformer != null)\n        {\n            endpointBuilder.setResponseMessageProcessors(Collections.singletonList(responseTransformer));\n        }\n        endpointBuilder.setExchangePattern(exchangePattern);\n        endpointBuilder.setTransactionConfig(txConfig);\n        customizeEndpointBuilder(endpointBuilder);\n        return endpointBuilder.buildOutboundEndpoint();\n    }","id":88414,"modified_method":"protected OutboundEndpoint createTestOutboundEndpoint(String uri, Filter filter,\n                                                          EndpointSecurityFilter securityFilter,\n                                                          Transformer transformer,\n                                                          Transformer responseTransformer,\n                                                          MessageExchangePattern exchangePattern,\n                                                          TransactionConfig txConfig)\n        throws EndpointException, InitialisationException\n    {\n        EndpointURIEndpointBuilder endpointBuilder = new EndpointURIEndpointBuilder(uri,\n            muleContext);\n        if (filter != null)\n        {\n            endpointBuilder.addMessageProcessor(new MessageFilter(filter));\n        }\n        if (securityFilter != null)\n        {\n            endpointBuilder.addMessageProcessor(new SecurityFilterMessageProcessor(securityFilter));\n        }\n        if (transformer != null)\n        {\n            endpointBuilder.setMessageProcessors(Collections.singletonList(transformer));\n        }\n        if (responseTransformer != null)\n        {\n            endpointBuilder.setResponseMessageProcessors(Collections.singletonList(responseTransformer));\n        }\n        endpointBuilder.setExchangePattern(exchangePattern);\n        endpointBuilder.setTransactionConfig(txConfig);\n        customizeEndpointBuilder(endpointBuilder);\n        return endpointBuilder.buildOutboundEndpoint();\n    }","commit_id":"c51c98fa898cb68ba80bb956c69194632d164d80","url":"https://github.com/mulesoft/mule"},{"original_method":"public void applyRule(final SNode parameter, final TypeCheckingContext typeCheckingContext) {\n    SNode chooser = SNodeOperations.getAncestor(parameter, \"jetbrains.mps.lang.refactoring.structure.MPSParameterChooser\", false, false);\n    if (SPropertyOperations.hasValue(chooser, \"type\", null, null)) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035588\", true), (SNode)new _Quotations.QuotationClass_28().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035585\", intentionProvider);\n      }\n    } else if (SPropertyOperations.hasValue(chooser, \"type\", null, null)) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035619\", true), (SNode)new _Quotations.QuotationClass_29().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035614\", intentionProvider);\n      }\n    } else if (SPropertyOperations.hasValue(chooser, \"type\", null, null)) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035628\", true), (SNode)new _Quotations.QuotationClass_30().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035623\", intentionProvider);\n      }\n    }\n  }","id":88415,"modified_method":"public void applyRule(final SNode parameter, final TypeCheckingContext typeCheckingContext) {\n    SNode chooser = SNodeOperations.getAncestor(parameter, \"jetbrains.mps.lang.refactoring.structure.MPSParameterChooser\", false, false);\n    if (SPropertyOperations.hasValue(chooser, \"type\", \"node\", \"node\")) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035588\", true), (SNode)new _Quotations.QuotationClass_28().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035585\", intentionProvider);\n      }\n    } else if (SPropertyOperations.hasValue(chooser, \"type\", \"model\", \"node\")) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035619\", true), (SNode)new _Quotations.QuotationClass_29().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035614\", intentionProvider);\n      }\n    } else if (SPropertyOperations.hasValue(chooser, \"type\", \"module\", \"node\")) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035628\", true), (SNode)new _Quotations.QuotationClass_30().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"5497648299879035623\", intentionProvider);\n      }\n    }\n  }","commit_id":"7a55eba0eec3e8002e4606a5adfefe60d834083c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode parameter, final TypeCheckingContext typeCheckingContext) {\n    SNode chooser = SLinkOperations.getTarget(parameter, \"chooser\", true);\n    if (SNodeOperations.isInstanceOf(chooser, \"jetbrains.mps.lang.refactoring.structure.CustomParameterChooser\")) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504961\", true), (SNode)SLinkOperations.getTarget(SNodeOperations.cast(chooser, \"jetbrains.mps.lang.refactoring.structure.CustomParameterChooser\"), \"entityType\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504956\", intentionProvider);\n      }\n    } else if (SNodeOperations.isInstanceOf(chooser, \"jetbrains.mps.lang.refactoring.structure.MPSParameterChooser\")) {\n      SNode mpsChooser = SNodeOperations.cast(chooser, \"jetbrains.mps.lang.refactoring.structure.MPSParameterChooser\");\n      if (SPropertyOperations.hasValue(mpsChooser, \"type\", null, null)) {\n        {\n          SNode _nodeToCheck_1029348928467 = parameter;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504991\", true), (SNode)new _Quotations.QuotationClass_25().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504986\", intentionProvider);\n        }\n      } else if (SPropertyOperations.hasValue(mpsChooser, \"type\", null, null)) {\n        {\n          SNode _nodeToCheck_1029348928467 = parameter;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505006\", true), (SNode)new _Quotations.QuotationClass_26().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505001\", intentionProvider);\n        }\n      } else if (SPropertyOperations.hasValue(mpsChooser, \"type\", null, null)) {\n        {\n          SNode _nodeToCheck_1029348928467 = parameter;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505021\", true), (SNode)new _Quotations.QuotationClass_27().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505016\", intentionProvider);\n        }\n      }\n    }\n  }","id":88416,"modified_method":"public void applyRule(final SNode parameter, final TypeCheckingContext typeCheckingContext) {\n    SNode chooser = SLinkOperations.getTarget(parameter, \"chooser\", true);\n    if (SNodeOperations.isInstanceOf(chooser, \"jetbrains.mps.lang.refactoring.structure.CustomParameterChooser\")) {\n      {\n        SNode _nodeToCheck_1029348928467 = parameter;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504961\", true), (SNode)SLinkOperations.getTarget(SNodeOperations.cast(chooser, \"jetbrains.mps.lang.refactoring.structure.CustomParameterChooser\"), \"entityType\", true), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504956\", intentionProvider);\n      }\n    } else if (SNodeOperations.isInstanceOf(chooser, \"jetbrains.mps.lang.refactoring.structure.MPSParameterChooser\")) {\n      SNode mpsChooser = SNodeOperations.cast(chooser, \"jetbrains.mps.lang.refactoring.structure.MPSParameterChooser\");\n      if (SPropertyOperations.hasValue(mpsChooser, \"type\", \"node\", \"node\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = parameter;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504991\", true), (SNode)new _Quotations.QuotationClass_25().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994504986\", intentionProvider);\n        }\n      } else if (SPropertyOperations.hasValue(mpsChooser, \"type\", \"model\", \"node\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = parameter;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505006\", true), (SNode)new _Quotations.QuotationClass_26().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505001\", intentionProvider);\n        }\n      } else if (SPropertyOperations.hasValue(mpsChooser, \"type\", \"module\", \"node\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = parameter;\n          BaseIntentionProvider intentionProvider = null;\n          typeCheckingContext.createEquation((SNode)typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505021\", true), (SNode)new _Quotations.QuotationClass_27().createNode(typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590316(jetbrains.mps.lang.refactoring.typesystem)\", \"478744034994505016\", intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"7a55eba0eec3e8002e4606a5adfefe60d834083c","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Overrides Object#hashCode() because Object#equals(Object) is overridden.\n     *\n     * @return a hash code value for this <tt>MediaFormat<\/tt>.\n     */\n    @Override\n    public int hashCode()\n    {\n        return (super.hashCode() | getFormatParameters().hashCode());\n    }","id":88417,"modified_method":"/**\n     * Overrides Object#hashCode() because Object#equals(Object) is overridden.\n     *\n     * @return a hash code value for this <tt>MediaFormat<\/tt>.\n     */\n    @Override\n    public int hashCode()\n    {\n        return (getFormat().hashCode() | getFormatParameters().hashCode());\n    }","commit_id":"ab464079f187a023fb3f4bed15b2f979dbdb3f58","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements MediaFormat#equals(Object) and actually compares the\n     * encapsulated JMF <tt>Format<\/tt> instances.\n     *\n     * @param mediaFormat the object that we'd like to compare <tt>this<\/tt> one\n     * to.\n     *\n     * @return <tt>true<\/tt> if the JMF <tt>Format<\/tt> instances encapsulated\n     * by this class are equal and <tt>false<\/tt> otherwise.\n     */\n    @Override\n    public boolean equals(Object mediaFormat)\n    {\n        if (this == mediaFormat)\n            return true;\n\n        if (!getClass().isInstance(mediaFormat))\n            return false;\n\n        @SuppressWarnings(\"unchecked\")\n        MediaFormatImpl<T> mediaFormatImpl = (MediaFormatImpl<T>) mediaFormat;\n\n        return format.equals(mediaFormatImpl.format)\n                && formatParametersAreEqual(\n                        getFormatParameters(),\n                        mediaFormatImpl.getFormatParameters());\n    }","id":88418,"modified_method":"/**\n     * Implements MediaFormat#equals(Object) and actually compares the\n     * encapsulated JMF <tt>Format<\/tt> instances.\n     *\n     * @param mediaFormat the object that we'd like to compare <tt>this<\/tt> one\n     * to.\n     *\n     * @return <tt>true<\/tt> if the JMF <tt>Format<\/tt> instances encapsulated\n     * by this class are equal and <tt>false<\/tt> otherwise.\n     */\n    @Override\n    public boolean equals(Object mediaFormat)\n    {\n        if (this == mediaFormat)\n            return true;\n\n        if (!getClass().isInstance(mediaFormat))\n            return false;\n\n        @SuppressWarnings(\"unchecked\")\n        MediaFormatImpl<T> mediaFormatImpl = (MediaFormatImpl<T>) mediaFormat;\n\n        return getFormat().equals(mediaFormatImpl.getFormat())\n                && formatParametersAreEqual(\n                        getFormatParameters(),\n                        mediaFormatImpl.getFormatParameters());\n    }","commit_id":"ab464079f187a023fb3f4bed15b2f979dbdb3f58","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Overrides <tt>MediaFormatImpl#hashCode()<\/tt> because\n     * <tt>Object#equals(Object)<\/tt> is overridden.\n     *\n     * @returns a hash code value for this <tt>VideoMediaFormatImpl<\/tt>\n     * @see MediaFormatImpl#hashCode()\n     */\n    @Override\n    public int hashCode()\n    {\n        return (super.hashCode() | (int) getClockRate()); \n    }","id":88419,"modified_method":"/**\n     * Overrides <tt>MediaFormatImpl#hashCode()<\/tt> because\n     * <tt>Object#equals(Object)<\/tt> is overridden.\n     *\n     * @returns a hash code value for this <tt>VideoMediaFormatImpl<\/tt>\n     * @see MediaFormatImpl#hashCode()\n     */\n    @Override\n    public int hashCode()\n    {\n        double clockRate = getClockRate();\n\n        /*\n         * The implementation of #equals(Object) of this instance assumes that\n         * MediaFormatFactory#CLOCK_RATE_NOT_SPECIFIED and #DEFAULT_CLOCK_RATE\n         * are equal.\n         */\n        if (MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED == clockRate)\n            clockRate = DEFAULT_CLOCK_RATE;\n        return (super.hashCode() | Double.valueOf(clockRate).hashCode());\n    }","commit_id":"ab464079f187a023fb3f4bed15b2f979dbdb3f58","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets <tt>pref<\/tt> as the preference associated with <tt>encoding<\/tt>.\n     * Use this method for both audio and video encodings and don't worry if\n     * preferences are equal since we rarely need to compare prefs of video\n     * encodings to those of audio encodings.\n     *\n     * @param encoding a string containing the SDP int of the encoding whose\n     *            pref we're setting.\n     * @param priority a positive int indicating the preference for that encoding.\n     */\n    public void setPriority(MediaFormat encoding, int priority)\n    {\n        encodingPreferences.put(encoding, priority);\n\n        // save the settings\n        NeomediaActivator\n            .getConfigurationService()\n                .setProperty(\n                    PROP_SDP_PREFERENCE\n                        + \".sdp\"\n                        + encoding.getEncoding()\n                        + \"/\"\n                        + ((long) encoding.getClockRate()),\n                    priority);\n\n        updateSupportedEncodings();\n    }","id":88420,"modified_method":"/**\n     * Sets <tt>pref<\/tt> as the preference associated with <tt>encoding<\/tt>.\n     * Use this method for both audio and video encodings and don't worry if\n     * preferences are equal since we rarely need to compare prefs of video\n     * encodings to those of audio encodings.\n     *\n     * @param encoding a string containing the SDP int of the encoding whose\n     * pref we're setting.\n     * @param priority a positive int indicating the preference for that encoding.\n     */\n    public void setPriority(MediaFormat encoding, int priority)\n    {\n        encodingPreferences.put(encoding, priority);\n\n        // save the settings\n        NeomediaActivator\n            .getConfigurationService()\n                .setProperty(\n                    PROP_SDP_PREFERENCE\n                        + \".\"\n                        + encoding.getEncoding()\n                        + \"/\"\n                        + encoding.getClockRateString(),\n                    priority);\n\n        updateSupportedEncodings();\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Register in JMF the custom codecs we provide\n     */\n    @SuppressWarnings(\"unchecked\") //legacy JMF code.\n    public void registerCustomCodecs()\n    {\n        // Register the custom codec which haven't already been registered.\n        Collection<String> registeredPlugins = new HashSet<String>(\n                PlugInManager.getPlugInList(null, null, PlugInManager.CODEC));\n        boolean commit = false;\n\n        for (String className : CUSTOM_CODECS)\n        {\n\n            /*\n             * A codec with a className of null is configured at compile time to\n             * not be registered.\n             */\n            if (className == null)\n                continue;\n\n            if (registeredPlugins.contains(className))\n            {\n                logger.debug(\"Codec : \" + className + \" is already registered\");\n            }\n            else\n            {\n                commit = true;\n\n                boolean registered;\n                Throwable exception = null;\n\n                try\n                {\n                    Codec codec = (Codec)\n                        Class.forName(className).newInstance();\n\n                    registered =\n                        PlugInManager.addPlugIn(\n                            className,\n                            codec.getSupportedInputFormats(),\n                            codec.getSupportedOutputFormats(null),\n                            PlugInManager.CODEC);\n                }\n                catch (Throwable ex)\n                {\n                    registered = false;\n                    exception = ex;\n                }\n                if (registered)\n                    logger.debug(\n                            \"Codec \"\n                            + className\n                            + \" is successfully registered\");\n                else\n                    logger.debug(\n                            \"Codec \"\n                            + className\n                            + \" is NOT succsefully registered\", exception);\n            }\n        }\n\n        if (commit)\n            try\n            {\n                PlugInManager.commit();\n            }\n            catch (IOException ex)\n            {\n                logger.error(\"Cannot commit to PlugInManager\", ex);\n            }\n\n        // Register the custom codec formats with the RTP manager once at\n        // initialization. This is needed for the Sun JMF implementation. It\n        // causes the registration of the formats with the static FormatInfo\n        // instance of com.sun.media.rtp.RTPSessionMgr, which in turn makes the\n        // formats available when the supported encodings arrays are generated\n        // in initProcessor(). In other JMF implementations this might not be\n        // needed, but should do no harm.\n\n        // Commented as it fails to load alaw codec\n        // RTPManager rtpManager = RTPManager.newInstance();\n        // CallSessionImpl.registerCustomCodecFormats(rtpManager);\n        // rtpManager.dispose();\n    }","id":88421,"modified_method":"/**\n     * Register in JMF the custom codecs we provide\n     */\n    public void registerCustomCodecs()\n    {\n        // Register the custom codec which haven't already been registered.\n        @SuppressWarnings(\"unchecked\")\n        Collection<String> registeredPlugins\n            = new HashSet<String>(\n                    PlugInManager\n                        .getPlugInList(null, null, PlugInManager.CODEC));\n        boolean commit = false;\n\n        for (String className : CUSTOM_CODECS)\n        {\n\n            /*\n             * A codec with a className of null is configured at compile time to\n             * not be registered.\n             */\n            if (className == null)\n                continue;\n\n            if (registeredPlugins.contains(className))\n            {\n                logger.debug(\"Codec : \" + className + \" is already registered\");\n            }\n            else\n            {\n                commit = true;\n\n                boolean registered;\n                Throwable exception = null;\n\n                try\n                {\n                    Codec codec = (Codec)\n                        Class.forName(className).newInstance();\n\n                    registered =\n                        PlugInManager.addPlugIn(\n                            className,\n                            codec.getSupportedInputFormats(),\n                            codec.getSupportedOutputFormats(null),\n                            PlugInManager.CODEC);\n                }\n                catch (Throwable ex)\n                {\n                    registered = false;\n                    exception = ex;\n                }\n                if (registered)\n                    logger.debug(\n                            \"Codec \"\n                            + className\n                            + \" is successfully registered\");\n                else\n                    logger.debug(\n                            \"Codec \"\n                            + className\n                            + \" is NOT succsefully registered\", exception);\n            }\n        }\n\n        if (commit)\n            try\n            {\n                PlugInManager.commit();\n            }\n            catch (IOException ex)\n            {\n                logger.error(\"Cannot commit to PlugInManager\", ex);\n            }\n\n        // Register the custom codec formats with the RTP manager once at\n        // initialization. This is needed for the Sun JMF implementation. It\n        // causes the registration of the formats with the static FormatInfo\n        // instance of com.sun.media.rtp.RTPSessionMgr, which in turn makes the\n        // formats available when the supported encodings arrays are generated\n        // in initProcessor(). In other JMF implementations this might not be\n        // needed, but should do no harm.\n\n        // Commented as it fails to load alaw codec\n        // RTPManager rtpManager = RTPManager.newInstance();\n        // CallSessionImpl.registerCustomCodecFormats(rtpManager);\n        // rtpManager.dispose();\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the codecs in the supported sets according preferences in\n     * encodingPreferences. If value is \"0\" the codec is disabled.\n     */\n    private void updateSupportedEncodings()\n    {\n        for (MediaFormat format : getAvailableEncodings(MediaType.AUDIO))\n        {\n            Integer pref1 = encodingPreferences.get(format);\n            int pref1IntValue = (pref1 == null) ? 0 : pref1;\n\n            if (pref1IntValue > 0)\n                supportedAudioEncodings.add(format);\n            else\n                supportedAudioEncodings.remove(format);\n        }\n\n        for (MediaFormat format : getAvailableEncodings(MediaType.VIDEO))\n        {\n            Integer pref1 = encodingPreferences.get(format);\n            int pref1IntValue = (pref1 == null) ? 0 : pref1;\n\n            if (pref1IntValue > 0)\n                supportedVideoEncodings.add(format);\n            else\n                supportedVideoEncodings.remove(format);\n        }\n    }","id":88422,"modified_method":"/**\n     * Updates the codecs in the supported sets according to the preferences in\n     * encodingPreferences. If the preference value is <tt>0<\/tt>, the codec is\n     * disabled.\n     */\n    private void updateSupportedEncodings()\n    {\n        /*\n         * If they need updating, their caches are invalid and need rebuilding\n         * next time they are requested.\n         */\n        supportedAudioEncodings = null;\n        supportedVideoEncodings = null;\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Retrieves (from the configuration service) preferences specified for\n     * various formats and assigns default ones to those that haven't been\n     * mentioned.\n     */\n    public void initializeFormatPreferences()\n    {\n        // first init default preferences\n        // video\n        setEncodingPreference(\"H264\", VideoMediaFormatImpl.DEFAULT_CLOCK_RATE, 1100);\n        setEncodingPreference(\"H263\", VideoMediaFormatImpl.DEFAULT_CLOCK_RATE, 1000);\n        setEncodingPreference(\"JPEG\", VideoMediaFormatImpl.DEFAULT_CLOCK_RATE, 950);\n        setEncodingPreference(\"H261\", VideoMediaFormatImpl.DEFAULT_CLOCK_RATE, 800);\n\n        // audio\n        setEncodingPreference(\"PCMU\", 8000, 650);\n        setEncodingPreference(\"PCMA\", 8000, 600);\n        setEncodingPreference(\"iLBC\", 8000, 500);\n        setEncodingPreference(\"GSM\", 8000, 450);\n        setEncodingPreference(\"speex\", 8000, 352);\n        setEncodingPreference(\"speex\", 16000, 351);\n        setEncodingPreference(\"speex\", 32000, 350);\n        setEncodingPreference(\"DVI4\", 8000, 300);\n        setEncodingPreference(\"DVI4\", 16000, 250);\n        setEncodingPreference(\"G723\", 8000, 150);\n        setEncodingPreference(\"G728\", 8000, 100);\n        setEncodingPreference(\"G729\", 8000, 50);\n\n        // now override with those that are specified by the user.\n        ConfigurationService confService\n            = NeomediaActivator.getConfigurationService();\n\n        List<String> sdpPreferences =\n            confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE, false);\n\n        for (String pName : sdpPreferences)\n        {\n            String prefStr = confService.getString(pName);\n            String fmtName\n                = pName\n                    .substring(pName.lastIndexOf('.') + 1)\n                        .replaceAll(\"sdp\", \"\");\n            int preference = -1;\n            String encoding;\n            double clockRate;\n            try\n            {\n                preference = Integer.parseInt(prefStr);\n\n                int encodingClockRateSeparator = fmtName.lastIndexOf('/');\n\n                if (encodingClockRateSeparator > -1)\n                {\n                    encoding = fmtName.substring(0, encodingClockRateSeparator);\n                    clockRate\n                        = Double\n                            .parseDouble(\n                                fmtName\n                                    .substring(encodingClockRateSeparator + 1));\n                }\n                else\n                {\n                    encoding = fmtName;\n                    clockRate = -1;\n                }\n            }\n            catch (NumberFormatException nfe)\n            {\n                logger\n                    .warn(\n                        \"Failed to parse format (\"\n                            + fmtName\n                            + \") or preference(\"\n                            + prefStr\n                            + \").\",\n                        nfe);\n                continue;\n            }\n\n            setEncodingPreference(encoding, clockRate, preference);\n        }\n\n        // now update the arrays so that they are returned by order of\n        // preference.\n        updateSupportedEncodings();\n    }","id":88423,"modified_method":"/**\n     * Retrieves (from the configuration service) preferences specified for\n     * various formats and assigns default ones to those that haven't been\n     * mentioned.\n     */\n    public void initializeFormatPreferences()\n    {\n        // first init default preferences\n        // video\n        setEncodingPreference(\n            \"H264\",\n            VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,\n            1100);\n        setEncodingPreference(\n            \"H263\",\n            VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,\n            1000);\n        setEncodingPreference(\n            \"JPEG\",\n            VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,\n            950);\n        setEncodingPreference(\n            \"H261\",\n            VideoMediaFormatImpl.DEFAULT_CLOCK_RATE,\n            800);\n\n        // audio\n        setEncodingPreference(\"PCMU\", 8000, 650);\n        setEncodingPreference(\"PCMA\", 8000, 600);\n        setEncodingPreference(\"iLBC\", 8000, 500);\n        setEncodingPreference(\"GSM\", 8000, 450);\n        setEncodingPreference(\"speex\", 8000, 352);\n        setEncodingPreference(\"speex\", 16000, 351);\n        setEncodingPreference(\"speex\", 32000, 350);\n        setEncodingPreference(\"DVI4\", 8000, 300);\n        setEncodingPreference(\"DVI4\", 16000, 250);\n        setEncodingPreference(\"G723\", 8000, 150);\n        setEncodingPreference(\"G728\", 8000, 100);\n        setEncodingPreference(\"G729\", 8000, 50);\n\n        // now override with those that are specified by the user.\n        ConfigurationService confService\n            = NeomediaActivator.getConfigurationService();\n\n        for (String pName\n                : confService\n                    .getPropertyNamesByPrefix(PROP_SDP_PREFERENCE, false))\n        {\n            String prefStr = confService.getString(pName);\n            String fmtName\n                = pName\n                    .substring(pName.lastIndexOf('.') + 1)\n                        .replaceAll(\"sdp\", \"\"); // legacy\n            int preference = -1;\n            String encoding;\n            double clockRate;\n            try\n            {\n                preference = Integer.parseInt(prefStr);\n\n                int encodingClockRateSeparator = fmtName.lastIndexOf('/');\n\n                if (encodingClockRateSeparator > -1)\n                {\n                    encoding = fmtName.substring(0, encodingClockRateSeparator);\n                    clockRate\n                        = Double\n                            .parseDouble(\n                                fmtName\n                                    .substring(encodingClockRateSeparator + 1));\n                }\n                else\n                {\n                    encoding = fmtName;\n                    clockRate = MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED;\n                }\n            }\n            catch (NumberFormatException nfe)\n            {\n                logger\n                    .warn(\n                        \"Failed to parse format (\"\n                            + fmtName\n                            + \") or preference (\"\n                            + prefStr\n                            + \").\",\n                        nfe);\n                continue;\n            }\n\n            setEncodingPreference(encoding, clockRate, preference);\n        }\n\n        // now update the arrays so that they are returned by order of\n        // preference.\n        updateSupportedEncodings();\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Register in JMF the custom packages we provide\n     */\n    @SuppressWarnings(\"unchecked\") //legacy JMF code.\n    public void registerCustomPackages()\n    {\n        Vector<String> currentPackagePrefix =\n            PackageManager.getProtocolPrefixList();\n\n        for (String className : CUSTOM_PACKAGES)\n        {\n            // linear search in a loop, but it doesn't have to scale since the\n            // list is always short\n            if (!currentPackagePrefix.contains(className))\n            {\n                currentPackagePrefix.add(className);\n                logger.debug(\"Adding package  : \" + className);\n            }\n        }\n\n        PackageManager.setProtocolPrefixList(currentPackagePrefix);\n        PackageManager.commitProtocolPrefixList();\n        logger.debug(\"Registering new protocol prefix list : \"\n            + currentPackagePrefix);\n    }","id":88424,"modified_method":"/**\n     * Register in JMF the custom packages we provide\n     */\n    public void registerCustomPackages()\n    {\n        @SuppressWarnings(\"unchecked\")\n        Vector<String> currentPackagePrefix\n            = PackageManager.getProtocolPrefixList();\n\n        for (String className : CUSTOM_PACKAGES)\n        {\n            // linear search in a loop, but it doesn't have to scale since the\n            // list is always short\n            if (!currentPackagePrefix.contains(className))\n            {\n                currentPackagePrefix.add(className);\n                logger.debug(\"Adding package  : \" + className);\n            }\n        }\n\n        PackageManager.setProtocolPrefixList(currentPackagePrefix);\n        PackageManager.commitProtocolPrefixList();\n        logger.debug(\"Registering new protocol prefix list : \"\n            + currentPackagePrefix);\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MediaFormat[] getSupportedEncodings(MediaType type)\n    {\n        Set<MediaFormat> supportedEncodings;\n\n        switch (type)\n        {\n        case AUDIO:\n            supportedEncodings = supportedAudioEncodings;\n            break;\n        case VIDEO:\n            supportedEncodings = supportedVideoEncodings;\n            break;\n        default:\n            return MediaUtils.EMPTY_MEDIA_FORMATS;\n        }\n        return\n            supportedEncodings\n                .toArray(new MediaFormat[supportedEncodings.size()]);\n    }","id":88425,"modified_method":"/**\n     * Gets the supported <tt>MediaFormat<\/tt>s i.e. the enabled available\n     * <tt>MediaFormat<\/tt>s sorted in decreasing priority.\n     *\n     * @param type the <tt>MediaType<\/tt> of the supported <tt>MediaFormat<\/tt>s\n     * to get\n     * @return an array of the supported <tt>MediaFormat<\/tt>s i.e. the enabled\n     * available <tt>MediaFormat<\/tt>s sorted in decreasing priority\n     */\n    public MediaFormat[] getSupportedEncodings(MediaType type)\n    {\n        Set<MediaFormat> supportedEncodings;\n\n        switch (type)\n        {\n        case AUDIO:\n            if (supportedAudioEncodings == null)\n                supportedAudioEncodings = updateSupportedEncodings(type);\n            supportedEncodings = supportedAudioEncodings;\n            break;\n        case VIDEO:\n            if (supportedVideoEncodings == null)\n                supportedVideoEncodings = updateSupportedEncodings(type);\n            supportedEncodings = supportedVideoEncodings;\n            break;\n        default:\n            return MediaUtils.EMPTY_MEDIA_FORMATS;\n        }\n        return\n            supportedEncodings\n                .toArray(new MediaFormat[supportedEncodings.size()]);\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a <tt>String<\/tt> representation of this <tt>MediaFormat<\/tt>\n     * containing, among other things, its encoding and clockrate values.\n     *\n     * @return a <tt>String<\/tt> representation of this <tt>MediaFormat<\/tt>.\n     */\n    @Override\n    public String toString()\n    {\n        return getEncoding() + \"/\" + (getClockRateString())\n            + \" PayloadType=\"+getRTPPayloadType();\n    }","id":88426,"modified_method":"/**\n     * Returns a <tt>String<\/tt> representation of this <tt>MediaFormat<\/tt>\n     * containing, among other things, its encoding and clockrate values.\n     *\n     * @return a <tt>String<\/tt> representation of this <tt>MediaFormat<\/tt>.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuffer str = new StringBuffer();\n\n        str.append(\"rtpmap:\");\n        str.append(getRTPPayloadType());\n        str.append(' ');\n        str.append(getEncoding());\n        str.append('/');\n        str.append(getClockRateString());\n\n        /*\n         * If the number of channels is 1, it does not have to be mentioned\n         * because it is the default.\n         */\n        if (MediaType.AUDIO.equals(getMediaType()))\n        {\n            int channels = ((AudioFormat) getFormat()).getChannels();\n\n            if (channels != 1)\n            {\n                str.append('/');\n                str.append(channels);\n            }\n        }\n\n        Map<String, String> formatParameters = getFormatParameters();\n\n        if (!formatParameters.isEmpty())\n        {\n            str.append(\" fmtp:\");\n\n            boolean prependSeparator = false;\n\n            for (Map.Entry<String, String> formatParameter\n                    : formatParameters.entrySet())\n            {\n                if (prependSeparator)\n                    str.append(';');\n                else\n                    prependSeparator = true;\n                str.append(formatParameter.getKey());\n                str.append('=');\n                str.append(formatParameter.getValue());\n            }\n        }\n\n        return str.toString();\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether a specific set of format parameters is equal to\n     * another set of format parameters in the sense that they define an equal\n     * number of parameters and assign them equal values. Since the values are\n     * <tt>String<\/tt>s, presumes that a value of <tt>null<\/tt> is equal to the\n     * empty <tt>String<\/tt>.\n     *\n     * @param formatParameters1 the first set of format parameters to be tested\n     * for equality\n     * @param formatParameters2 the second set of format parameters to be tested\n     * for equality\n     * @return <tt>true<\/tt> if the specified sets of format parameters are\n     * equal; <tt>false<\/tt>, otherwise\n     */\n    static boolean formatParametersAreEqual(\n            Map<String, String> formatParameters1,\n            Map<String, String> formatParameters2)\n    {\n        if (formatParameters1 == null)\n            return\n                (formatParameters2 == null)\n                    || (formatParameters2.size() == 0);\n        if (formatParameters2 == null)\n            return\n                (formatParameters1 == null)\n                    || (formatParameters1.size() == 0);\n        if (formatParameters1.size() == formatParameters2.size())\n        {\n            for (Map.Entry<String, String> formatParameter1\n                    : formatParameters1.entrySet())\n            {\n                String key1 = formatParameter1.getKey();\n\n                if (!formatParameters2.containsKey(key1))\n                    return false;\n\n                String value1 = formatParameter1.getValue();\n                String value2 = formatParameters2.get(key1);\n\n                /*\n                 * Since the values are strings, allow null to be equal to the\n                 * empty string.\n                 */\n                if ((value1 == null) || (value1.length() == 0))\n                {\n                    if ((value2 != null) && (value2.length() > 0))\n                        return false;\n                }\n                else if (!value1.equals(value2))\n                    return false;\n            }\n            return true;\n        }\n        else\n            return false;\n    }","id":88427,"modified_method":"/**\n     * Determines whether a specific set of format parameters is equal to\n     * another set of format parameters in the sense that they define an equal\n     * number of parameters and assign them equal values. Since the values are\n     * <tt>String<\/tt>s, presumes that a value of <tt>null<\/tt> is equal to the\n     * empty <tt>String<\/tt>.\n     *\n     * @param formatParameters1 the first set of format parameters to be tested\n     * for equality\n     * @param formatParameters2 the second set of format parameters to be tested\n     * for equality\n     * @return <tt>true<\/tt> if the specified sets of format parameters are\n     * equal; <tt>false<\/tt>, otherwise\n     */\n    static boolean formatParametersAreEqual(\n            Map<String, String> formatParameters1,\n            Map<String, String> formatParameters2)\n    {\n        if (formatParameters1 == null)\n            return\n                (formatParameters2 == null)\n                    || formatParameters2.isEmpty();\n        if (formatParameters2 == null)\n            return\n                (formatParameters1 == null)\n                    || formatParameters1.isEmpty();\n        if (formatParameters1.size() == formatParameters2.size())\n        {\n            for (Map.Entry<String, String> formatParameter1\n                    : formatParameters1.entrySet())\n            {\n                String key1 = formatParameter1.getKey();\n\n                if (!formatParameters2.containsKey(key1))\n                    return false;\n\n                String value1 = formatParameter1.getValue();\n                String value2 = formatParameters2.get(key1);\n\n                /*\n                 * Since the values are strings, allow null to be equal to the\n                 * empty string.\n                 */\n                if ((value1 == null) || value1.isEmpty())\n                {\n                    if ((value2 != null) && !value2.isEmpty())\n                        return false;\n                }\n                else if (!value1.equals(value2))\n                    return false;\n            }\n            return true;\n        }\n        else\n            return false;\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes a new <tt>VideoMediaFormatImpl<\/tt> instance which is to\n     * provide an implementation of <tt>VideoMediaFormat<\/tt> for a specific\n     * JMF <tt>VideoFormat<\/tt> and to have a specific clock rate.\n     *\n     * @param format the JMF <tt>VideoFormat<\/tt> the new instance is to wrap\n     * and provide an implementation of <tt>VideoMediaFormat<\/tt> for\n     * @param clockRate the clock rate of the new <tt>VideoMediaFormatImpl<\/tt>\n     * instance\n     */\n    VideoMediaFormatImpl(VideoFormat format, double clockRate)\n    {\n        super(format);\n\n        this.clockRate = clockRate;\n    }","id":88428,"modified_method":"/**\n     * Initializes a new <tt>VideoMediaFormatImpl<\/tt> instance which is to\n     * provide an implementation of <tt>VideoMediaFormat<\/tt> for a specific\n     * JMF <tt>VideoFormat<\/tt> and to have a specific clock rate.\n     *\n     * @param format the JMF <tt>VideoFormat<\/tt> the new instance is to wrap\n     * and provide an implementation of <tt>VideoMediaFormat<\/tt> for\n     * @param clockRate the clock rate of the new <tt>VideoMediaFormatImpl<\/tt>\n     * instance\n     */\n    VideoMediaFormatImpl(VideoFormat format, double clockRate)\n    {\n        this(format, clockRate, null);\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements <tt>MediaFormat#equals(Object)<\/tt> and actually compares the\n     * encapsulated JMF <tt>Format<\/tt> instances.\n     *\n     * @param mediaFormat the object that we'd like to compare <tt>this<\/tt> one\n     * to\n     * @return <tt>true<\/tt> if the JMF <tt>Format<\/tt> instances encapsulated\n     * by this instance and their other characteristics are equal;\n     * <tt>false<\/tt>, otherwise.\n     * @see MediaFormatImpl#equals(Object)\n     */\n    @Override\n    public boolean equals(Object mediaFormat)\n    {\n        if (this == mediaFormat)\n            return true;\n\n        if (!super.equals(mediaFormat))\n            return false;\n\n        VideoMediaFormatImpl videoMediaFormatImpl\n            = (VideoMediaFormatImpl) mediaFormat;\n\n        return (getClockRate() == videoMediaFormatImpl.getClockRate());\n    }","id":88429,"modified_method":"/**\n     * Implements <tt>MediaFormat#equals(Object)<\/tt> and actually compares the\n     * encapsulated JMF <tt>Format<\/tt> instances.\n     *\n     * @param mediaFormat the object that we'd like to compare <tt>this<\/tt> one\n     * to\n     * @return <tt>true<\/tt> if the JMF <tt>Format<\/tt> instances encapsulated\n     * by this instance and their other characteristics are equal;\n     * <tt>false<\/tt>, otherwise.\n     * @see MediaFormatImpl#equals(Object)\n     */\n    @Override\n    public boolean equals(Object mediaFormat)\n    {\n        if (this == mediaFormat)\n            return true;\n\n        if (!super.equals(mediaFormat))\n            return false;\n\n        VideoMediaFormatImpl videoMediaFormatImpl\n            = (VideoMediaFormatImpl) mediaFormat;\n\n        double clockRate = getClockRate();\n        double videoMediaFormatImplClockRate\n            = videoMediaFormatImpl.getClockRate();\n\n        if (MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED == clockRate)\n            clockRate = DEFAULT_CLOCK_RATE;\n        if (MediaFormatFactory.CLOCK_RATE_NOT_SPECIFIED\n                == videoMediaFormatImplClockRate)\n            videoMediaFormatImplClockRate = DEFAULT_CLOCK_RATE;\n\n        return (clockRate == videoMediaFormatImplClockRate);\n    }","commit_id":"b701cec66f50a7b98c5703af0fc7d95d4209166b","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static VmInstance lookup( final String name ) throws NoSuchElementException {\n    return VmInstance.Lookup.INSTANCE.apply( name );\n  }","id":88430,"modified_method":"public static VmInstance lookup( final String name ) throws NoSuchElementException {\n    if ( !terminateCache.containsKey( name ) ) {\n      return VmInstance.Lookup.INSTANCE.apply( name );\n    } else {\n      return terminateCache.get( name );\n    }\n  }","commit_id":"58271ddc185c8acbaafd95c2e0c15f2c8cecc364","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static VmInstance delete( final VmInstance vm ) throws TransactionException {\n    return VmInstance.Transitions.DELETE.apply( vm );\n  }","id":88431,"modified_method":"public static VmInstance delete( final VmInstance vm ) throws TransactionException {\n    VmInstance deadVm = VmInstance.Transitions.DELETE.apply( vm );\n    if ( VmStateSet.DONE.apply( deadVm ) ) {\n      terminateCache.put( deadVm.getInstanceId( ), deadVm );\n    }\n    return deadVm;\n  }","commit_id":"58271ddc185c8acbaafd95c2e0c15f2c8cecc364","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Predicate<VmInstance> vmWithPublicAddress( final String ip ) {\n    return new Predicate<VmInstance>( ) {\n      @Override\n      public boolean apply( VmInstance vm ) {\n        return ip.equals( vm.getPublicAddress( ) ) && VmIsOperational.INSTANCE.apply( vm );\n      }\n    };\n  }","id":88432,"modified_method":"public static Predicate<VmInstance> vmWithPublicAddress( final String ip ) {\n    return new Predicate<VmInstance>( ) {\n      @Override\n      public boolean apply( VmInstance vm ) {\n        return ip.equals( vm.getPublicAddress( ) ) && VmStateSet.RUN.apply( vm );\n      }\n    };\n  }","commit_id":"58271ddc185c8acbaafd95c2e0c15f2c8cecc364","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static Predicate<VmInstance> withPrivateAddress( final String ip ) {\n    return new Predicate<VmInstance>( ) {\n      @Override\n      public boolean apply( VmInstance vm ) {\n        return ip.equals( vm.getPrivateAddress( ) ) && VmIsOperational.INSTANCE.apply( vm );\n      }\n    };\n  }","id":88433,"modified_method":"public static Predicate<VmInstance> withPrivateAddress( final String ip ) {\n    return new Predicate<VmInstance>( ) {\n      @Override\n      public boolean apply( VmInstance vm ) {\n        return ip.equals( vm.getPrivateAddress( ) ) && VmStateSet.RUN.apply( vm );\n      }\n    };\n  }","commit_id":"58271ddc185c8acbaafd95c2e0c15f2c8cecc364","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Deprecated\n  public static List<VmInstance> listValues( ) {\n    final EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      final List<VmInstance> vms = Entities.query( VmInstance.named( null, null ) );\n      db.commit( );\n      return Lists.newArrayList( vms );\n    } catch ( final Exception ex ) {\n      Logs.extreme( ).error( ex, ex );\n      db.rollback( );\n      return Lists.newArrayList( );\n    }\n  }","id":88434,"modified_method":"@Deprecated\n  public static List<VmInstance> listValues( ) {\n    final EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      final List<VmInstance> vms = Entities.query( VmInstance.named( null, null ) );\n      db.commit( );\n      List<VmInstance> ret = Lists.newArrayList( vms );\n      ret.addAll( terminateCache.values( ) );\n      return ret;\n    } catch ( final Exception ex ) {\n      Logs.extreme( ).error( ex, ex );\n      db.rollback( );\n      return Lists.newArrayList( );\n    }\n  }","commit_id":"58271ddc185c8acbaafd95c2e0c15f2c8cecc364","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<AnAction> getActionsAsList() {\n      return Lists.newArrayList(myRunAction, myNextAction, myPrevAction);\n    }","id":88435,"modified_method":"public List<AnAction> getActionsAsList() {\n      ArrayList<AnAction> list = Lists.newArrayList(myRunAction, myNextAction, myPrevAction);\n      list.addAll(myAdditionalActions);\n      return list;\n    }","commit_id":"51430452f6393b954c72a0c914a956847021e0eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    protected List<String> additionalKotlinFiles() {\n        return Lists.newArrayList();\n    }","id":88436,"modified_method":"@NotNull\n    protected List<String> additionalKotlinFiles() {\n        List<String> additionalFiles = Lists.newArrayList();\n        additionalFiles.addAll(kotlinFilesInDirectory(pathToTestFilesRoot() + COMMON_FILES_DIR));\n        additionalFiles.addAll(kotlinFilesInDirectory(pathToTestFiles() + COMMON_FILES_DIR));\n        return additionalFiles;\n    }","commit_id":"dd3dbe5b10700c8c71dfbb0aa3a90740e60567a8","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    protected List<String> additionalJsFiles(@NotNull EcmaVersion ecmaVersion) {\n        return Lists.newArrayList();\n    }","id":88437,"modified_method":"@NotNull\n    protected List<String> additionalJsFiles(@NotNull EcmaVersion ecmaVersion) {\n        List<String> additionalFiles = Lists.newArrayList();\n\n        // add all js files from testData/_commonFiles\n        additionalFiles.addAll(JsTestUtils.getFilesInDirectoryByExtension(TEST_DATA_DIR_PATH + COMMON_FILES_DIR, JavaScript.EXTENSION));\n        // add all js files from <testDir>/_commonFiles\n        additionalFiles.addAll(JsTestUtils.getFilesInDirectoryByExtension(pathToTestDir() + COMMON_FILES_DIR, JavaScript.EXTENSION));\n\n        // add <testDir>/cases/<testName>.js if it exists\n        String jsFilePath = getInputFilePath(getTestName(true) + JavaScript.DOT_EXTENSION);\n        File jsFile = new File(jsFilePath);\n        if (jsFile.exists() && jsFile.isFile()) {\n            additionalFiles.add(jsFilePath);\n        }\n\n        return additionalFiles;\n    }","commit_id":"7d9b82441119f7eb3cb89e9149ead667d41d28be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    protected List<String> additionalKotlinFiles() {\n        List<String> additionalFiles = Lists.newArrayList();\n        additionalFiles.addAll(JsTestUtils.kotlinFilesInDirectory(TEST_DATA_DIR_PATH + COMMON_FILES_DIR));\n        additionalFiles.addAll(JsTestUtils.kotlinFilesInDirectory(pathToTestDir() + COMMON_FILES_DIR));\n        return additionalFiles;\n    }","id":88438,"modified_method":"@NotNull\n    protected List<String> additionalKotlinFiles() {\n        List<String> additionalFiles = Lists.newArrayList();\n\n        // add all kotlin files from testData/_commonFiles\n        additionalFiles.addAll(JsTestUtils.getFilesInDirectoryByExtension(TEST_DATA_DIR_PATH + COMMON_FILES_DIR, JetFileType.EXTENSION));\n        // add all kotlin files from <testDir>/_commonFiles\n        additionalFiles.addAll(JsTestUtils.getFilesInDirectoryByExtension(pathToTestDir() + COMMON_FILES_DIR, JetFileType.EXTENSION));\n\n        return additionalFiles;\n    }","commit_id":"7d9b82441119f7eb3cb89e9149ead667d41d28be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static List<String> kotlinFilesInDirectory(@NotNull String directory) {\n        File dir = new File(directory);\n\n        if (!dir.isDirectory()) {\n            return ContainerUtil.emptyList();\n        }\n\n        File[] kotlinFiles = dir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(@NotNull File dir, @NotNull String name) {\n                return name.endsWith(\".kt\");\n            }\n        });\n\n        if (kotlinFiles == null) {\n            return ContainerUtil.emptyList();\n        }\n\n        return ContainerUtil.map2List(kotlinFiles, new Function<File, String>() {\n            @Override\n            public String fun(File kotlinFile) {\n                return kotlinFile.getAbsolutePath();\n            }\n        });\n    }","id":88439,"modified_method":"@NotNull\n    public static List<String> getFilesInDirectoryByExtension(@NotNull String directory, String extension) {\n        File dir = new File(directory);\n\n        if (!dir.isDirectory()) return ContainerUtil.emptyList();\n\n        List<File> files = FileUtil.findFilesByMask(Pattern.compile(\".*\\\\.\" + extension + \"$\"), dir);\n\n        return ContainerUtil.map2List(files, new Function<File, String>() {\n            @Override\n            public String fun(File file) {\n                return file.getAbsolutePath();\n            }\n        });\n    }","commit_id":"7d9b82441119f7eb3cb89e9149ead667d41d28be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Test\n  public void test_status_error() {\n    QualityGate simple = qgClient().create(\"SimpleWithLowThreshold\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").errorThreshold(\"10\"));\n\n    try {\n      SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"));\n      orchestrator.executeBuild(build);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"ERROR\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n  }","id":88440,"modified_method":"@Test\n  public void test_status_error() {\n    QualityGate simple = qgClient().create(\"SimpleWithLowThreshold\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").errorThreshold(\"10\"));\n\n    try {\n      SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"));\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_ERROR);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"ERROR\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void conditions_on_multiple_metric_types() {\n    QualityGate allTypes = qgClient().create(\"AllMetricTypes\");\n    qgClient().createCondition(NewCondition.create(allTypes.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"10\"));\n    qgClient().createCondition(NewCondition.create(allTypes.id()).metricKey(\"duplicated_lines_density\").operator(\"GT\").warningThreshold(\"20\"));\n    qgClient().setDefault(allTypes.id());\n\n    try {\n      SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"))\n        .setProperty(\"sonar.cpd.xoo.minimumLines\", \"2\")\n        .setProperty(\"sonar.cpd.xoo.minimumTokens\", \"5\");\n      orchestrator.executeBuild(build);\n\n      Measure alertStatus = fetchGateStatus();\n      assertThat(alertStatus.getData()).isEqualTo(\"WARN\");\n      assertThat(alertStatus.getAlertText())\n        .contains(\"Lines of code > 10\")\n        .contains(\"Duplicated lines (%) > 20\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(allTypes.id());\n    }\n  }","id":88441,"modified_method":"@Test\n  public void conditions_on_multiple_metric_types() {\n    QualityGate allTypes = qgClient().create(\"AllMetricTypes\");\n    qgClient().createCondition(NewCondition.create(allTypes.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"10\"));\n    qgClient().createCondition(NewCondition.create(allTypes.id()).metricKey(\"duplicated_lines_density\").operator(\"GT\").warningThreshold(\"20\"));\n    qgClient().setDefault(allTypes.id());\n\n    try {\n      SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"))\n        .setProperty(\"sonar.cpd.xoo.minimumLines\", \"2\")\n        .setProperty(\"sonar.cpd.xoo.minimumTokens\", \"5\");\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_WARN);\n\n      Measure alertStatus = fetchGateStatus();\n      assertThat(alertStatus.getData()).isEqualTo(\"WARN\");\n      assertThat(alertStatus.getAlertText())\n        .contains(\"Lines of code > 10\")\n        .contains(\"Duplicated lines (%) > 20\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(allTypes.id());\n    }\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void ad_hoc_build_break_strategy() throws IOException {\n    QualityGate simple = qgClient().create(\"SimpleWithLowThresholdForBuildBreakStrategy\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").errorThreshold(\"7\"));\n\n    try {\n      File projectDir = projectDir(\"qualitygate/xoo-sample\");\n      SonarRunner build = SonarRunner.create(projectDir);\n      orchestrator.executeBuild(build);\n\n      String taskId = getTaskIdInLocalReport(projectDir);\n      String analysisId = getAnalysisId(taskId);\n\n      ProjectStatusWsResponse projectStatusWsResponse = wsClient.qualityGates().projectStatus(new ProjectStatusWsRequest().setAnalysisId(analysisId));\n      ProjectStatusWsResponse.ProjectStatus projectStatus = projectStatusWsResponse.getProjectStatus();\n      assertThat(projectStatus.getStatus()).isEqualTo(ProjectStatusWsResponse.Status.ERROR);\n      assertThat(projectStatus.getConditionsCount()).isEqualTo(1);\n      ProjectStatusWsResponse.Condition condition = projectStatus.getConditionsList().get(0);\n      assertThat(condition.getMetricKey()).isEqualTo(\"ncloc\");\n      assertThat(condition.getErrorThreshold()).isEqualTo(\"7\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n  }","id":88442,"modified_method":"@Test\n  public void ad_hoc_build_break_strategy() throws IOException {\n    QualityGate simple = qgClient().create(\"SimpleWithLowThresholdForBuildBreakStrategy\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").errorThreshold(\"7\"));\n\n    try {\n      File projectDir = projectDir(\"qualitygate/xoo-sample\");\n      SonarScanner build = SonarScanner.create(projectDir);\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_ERROR);\n\n      String taskId = getTaskIdInLocalReport(projectDir);\n      String analysisId = getAnalysisId(taskId);\n\n      ProjectStatusWsResponse projectStatusWsResponse = wsClient.qualityGates().projectStatus(new ProjectStatusWsRequest().setAnalysisId(analysisId));\n      ProjectStatusWsResponse.ProjectStatus projectStatus = projectStatusWsResponse.getProjectStatus();\n      assertThat(projectStatus.getStatus()).isEqualTo(ProjectStatusWsResponse.Status.ERROR);\n      assertThat(projectStatus.getConditionsCount()).isEqualTo(1);\n      ProjectStatusWsResponse.Condition condition = projectStatus.getConditionsList().get(0);\n      assertThat(condition.getMetricKey()).isEqualTo(\"ncloc\");\n      assertThat(condition.getErrorThreshold()).isEqualTo(\"7\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void use_server_settings_instead_of_default_gate() {\n    QualityGate alert = qgClient().create(\"AlertWithLowThreshold\");\n    qgClient().createCondition(NewCondition.create(alert.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"10\"));\n    QualityGate error = qgClient().create(\"ErrorWithLowThreshold\");\n    qgClient().createCondition(NewCondition.create(error.id()).metricKey(\"ncloc\").operator(\"GT\").errorThreshold(\"10\"));\n\n    qgClient().setDefault(alert.id());\n    qgClient().selectProject(error.id(), provisionedProjectId);\n\n    try {\n      SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"));\n      orchestrator.executeBuild(build);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"ERROR\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(alert.id());\n      qgClient().destroy(error.id());\n    }\n  }","id":88443,"modified_method":"@Test\n  public void use_server_settings_instead_of_default_gate() {\n    QualityGate alert = qgClient().create(\"AlertWithLowThreshold\");\n    qgClient().createCondition(NewCondition.create(alert.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"10\"));\n    QualityGate error = qgClient().create(\"ErrorWithLowThreshold\");\n    qgClient().createCondition(NewCondition.create(error.id()).metricKey(\"ncloc\").operator(\"GT\").errorThreshold(\"10\"));\n\n    qgClient().setDefault(alert.id());\n    qgClient().selectProject(error.id(), provisionedProjectId);\n\n    try {\n      SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"));\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_ERROR);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"ERROR\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(alert.id());\n      qgClient().destroy(error.id());\n    }\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_status_ok() {\n    QualityGate simple = qgClient().create(\"SimpleWithHighThreshold\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"40\"));\n\n    try {\n      SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"));\n      orchestrator.executeBuild(build);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"OK\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n  }","id":88444,"modified_method":"@Test\n  public void test_status_ok() {\n    QualityGate simple = qgClient().create(\"SimpleWithHighThreshold\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"40\"));\n\n    try {\n      SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"));\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_OK);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"OK\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void status_ok_if_empty_gate() {\n    QualityGate empty = qgClient().create(\"Empty\");\n    qgClient().setDefault(empty.id());\n\n    try {\n      SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"));\n      orchestrator.executeBuild(build);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"OK\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(empty.id());\n    }\n  }","id":88445,"modified_method":"@Test\n  public void status_ok_if_empty_gate() {\n    QualityGate empty = qgClient().create(\"Empty\");\n    qgClient().setDefault(empty.id());\n\n    try {\n      SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"));\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_OK);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"OK\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(empty.id());\n    }\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_status_warning() {\n    QualityGate simple = qgClient().create(\"SimpleWithLowThreshold\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"10\"));\n\n    try {\n      SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"));\n      orchestrator.executeBuild(build);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"WARN\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n\n  }","id":88446,"modified_method":"@Test\n  public void test_status_warning() {\n    QualityGate simple = qgClient().create(\"SimpleWithLowThreshold\");\n    qgClient().setDefault(simple.id());\n    qgClient().createCondition(NewCondition.create(simple.id()).metricKey(\"ncloc\").operator(\"GT\").warningThreshold(\"10\"));\n\n    try {\n      SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"));\n      BuildResult buildResult = orchestrator.executeBuild(build);\n\n      verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_WARN);\n\n      assertThat(fetchGateStatus().getData()).isEqualTo(\"WARN\");\n    } finally {\n      qgClient().unsetDefault();\n      qgClient().destroy(simple.id());\n    }\n\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_not_compute_status_if_no_gate() {\n    SonarRunner build = SonarRunner.create(projectDir(\"qualitygate/xoo-sample\"));\n    orchestrator.executeBuild(build);\n\n    assertThat(fetchResourceWithGateStatus()).isNull();\n  }","id":88447,"modified_method":"@Test\n  public void do_not_compute_status_if_no_gate() throws IOException {\n    SonarScanner build = SonarScanner.create(projectDir(\"qualitygate/xoo-sample\"));\n    BuildResult buildResult = orchestrator.executeBuild(build);\n\n    verifyQGStatusInPostTask(buildResult, TASK_STATUS_SUCCESS, QG_STATUS_NO_QG);\n\n    assertThat(fetchResourceWithGateStatus()).isNull();\n  }","commit_id":"1f69c8dd6cf99519d927cb8f7938d37dc3ac5b14","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic String merge(String siteId, Element root, String archivePath, String fromSiteId, Map attachmentNames, Map userIdTrans, Set userListAllowImport)\n\t{\n\t\tM_log.info(\"merge starts for News...\");\n\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tNodeList allChildrenNodes = root.getChildNodes();\n\t\t\t\tint length = allChildrenNodes.getLength();\n\t\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\t{\n\t\t\t\t\tNode siteNode = allChildrenNodes.item(i);\n\t\t\t\t\tif (siteNode.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t{\n\t\t\t\t\t\tElement siteElement = (Element) siteNode;\n\t\t\t\t\t\tif (siteElement.getTagName().equals(NEWS))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNodeList allContentNodes = siteElement.getChildNodes();\n\t\t\t\t\t\t\tint lengthContent = allContentNodes.getLength();\n\t\t\t\t\t\t\tfor (int j = 0; j < lengthContent; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tNode child1 = allContentNodes.item(j);\n\t\t\t\t\t\t\t\tif (child1.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tElement contentElement = (Element) child1;\n\t\t\t\t\t\t\t\t\tif (contentElement.getTagName().equals(NEWS_ITEM))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tString toolTitle = contentElement.getAttribute(TOOL_TITLE);\n\t\t\t\t\t\t\t\t\t\tString trimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && toolTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = Base64.decode(trimBody);\n\t\t\t\t\t\t\t\t\t\t\t\ttoolTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString pageTitle = contentElement.getAttribute(PAGE_TITLE);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(pageTitle != null && pageTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = Base64.decode(trimBody);\n\t\t\t\t\t\t\t\t\t\t\t\tpageTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString contentUrl = contentElement.getAttribute(NEWS_URL);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(contentUrl != null && contentUrl.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(contentUrl);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = Base64.decode(trimBody);\n\t\t\t\t\t\t\t\t\t\t\t\tcontentUrl = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && contentUrl != null && toolTitle.length() >0 && contentUrl.length() >0\n\t\t\t\t\t\t\t\t\t\t\t\t&& pageTitle !=null && pageTitle.length() > 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tTool tr = ToolManager.getTool(TOOL_ID);\n\t\t\t\t\t\t\t\t\t\t\tSitePage page = site.addPage(); \n\t\t\t\t\t\t\t\t\t\t\tpage.setTitle(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tToolConfiguration tool = page.addTool();\n\t\t\t\t\t\t\t\t\t\t\ttool.setTool(TOOL_ID, tr);\n\t\t\t\t\t\t\t\t\t\t\ttool.setTitle(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\ttool.getPlacementConfig().setProperty(NEWS_URL_PROP, contentUrl);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSiteService.save(site);\n\t\t\t\tToolSession session = SessionManager.getCurrentToolSession();\n\n\t\t\t\tif (session.getAttribute(ATTR_TOP_REFRESH) == null)\t\n\t\t\t\t{\n\t\t\t\t\tsession.setAttribute(ATTR_TOP_REFRESH, Boolean.TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tM_log.error(\"errors in merge for BasicNewsService\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":88448,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic String merge(String siteId, Element root, String archivePath, String fromSiteId, Map attachmentNames, Map userIdTrans, Set userListAllowImport)\n\t{\n\t\tBase64 codec = new Base64();\n\t\tM_log.info(\"merge starts for News...\");\n\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tNodeList allChildrenNodes = root.getChildNodes();\n\t\t\t\tint length = allChildrenNodes.getLength();\n\t\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\t{\n\t\t\t\t\tNode siteNode = allChildrenNodes.item(i);\n\t\t\t\t\tif (siteNode.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t{\n\t\t\t\t\t\tElement siteElement = (Element) siteNode;\n\t\t\t\t\t\tif (siteElement.getTagName().equals(NEWS))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNodeList allContentNodes = siteElement.getChildNodes();\n\t\t\t\t\t\t\tint lengthContent = allContentNodes.getLength();\n\t\t\t\t\t\t\tfor (int j = 0; j < lengthContent; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tNode child1 = allContentNodes.item(j);\n\t\t\t\t\t\t\t\tif (child1.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tElement contentElement = (Element) child1;\n\t\t\t\t\t\t\t\t\tif (contentElement.getTagName().equals(NEWS_ITEM))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tString toolTitle = contentElement.getAttribute(TOOL_TITLE);\n\t\t\t\t\t\t\t\t\t\tString trimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && toolTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = codec.decode(trimBody.getBytes(\"UTF-8\"));\n\t\t\t\t\t\t\t\t\t\t\t\ttoolTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString pageTitle = contentElement.getAttribute(PAGE_TITLE);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(pageTitle != null && pageTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = codec.decode(trimBody.getBytes(\"UTF-8\"));\n\t\t\t\t\t\t\t\t\t\t\t\tpageTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString contentUrl = contentElement.getAttribute(NEWS_URL);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(contentUrl != null && contentUrl.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(contentUrl);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = codec.decode(trimBody.getBytes(\"UTF-8\"));\n\t\t\t\t\t\t\t\t\t\t\t\tcontentUrl = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && contentUrl != null && toolTitle.length() >0 && contentUrl.length() >0\n\t\t\t\t\t\t\t\t\t\t\t\t&& pageTitle !=null && pageTitle.length() > 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tTool tr = ToolManager.getTool(TOOL_ID);\n\t\t\t\t\t\t\t\t\t\t\tSitePage page = site.addPage(); \n\t\t\t\t\t\t\t\t\t\t\tpage.setTitle(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tToolConfiguration tool = page.addTool();\n\t\t\t\t\t\t\t\t\t\t\ttool.setTool(TOOL_ID, tr);\n\t\t\t\t\t\t\t\t\t\t\ttool.setTitle(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\ttool.getPlacementConfig().setProperty(NEWS_URL_PROP, contentUrl);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSiteService.save(site);\n\t\t\t\tToolSession session = SessionManager.getCurrentToolSession();\n\n\t\t\t\tif (session.getAttribute(ATTR_TOP_REFRESH) == null)\t\n\t\t\t\t{\n\t\t\t\t\tsession.setAttribute(ATTR_TOP_REFRESH, Boolean.TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tM_log.error(\"errors in merge for BasicNewsService\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"6cff385b03e391ead6a7209068a95e63fffcfc1d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic String archive(String siteId, Document doc, Stack stack, String arg3,\n\t\t      List attachments)\n\t{\n\t\tStringBuffer results = new StringBuffer();\n\n\t\ttry\n\t\t{\n\t\t\tint count = 0;\n\t\t\tresults.append(\"archiving \" + getLabel() + \" context \"\n\t\t\t\t\t+ Entity.SEPARATOR + siteId + Entity.SEPARATOR\n\t\t\t\t\t+ SiteService.MAIN_CONTAINER + \".\\n\");\n\t\t\t\n\t\t\t// get the default news url\n\t\t\tString defaultUrl = ServerConfigurationService.getString(\"news.feedURL\");\n\t\t\t\n\t\t\t// start with an element with our very own (service) name\n\t\t\tElement element = doc.createElement(SERVICE_NAME);\n\t\t\telement.setAttribute(VERSION_ATTR, ARCHIVE_VERSION);\n\t\t\t((Element) stack.peek()).appendChild(element);\n\t\t\tstack.push(element);\n\t\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t\t{\n\t\t\t\tElement newsEl = doc.createElement(NEWS);\n\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tList sitePages = site.getPages();\n\n\t\t\t\tif (sitePages != null && !sitePages.isEmpty()) \n\t\t\t\t{\n\t\t\t\t\tIterator pageIter = sitePages.iterator();\n\t\t\t\t\twhile (pageIter.hasNext()) \n\t\t\t\t\t{\n\t\t\t\t\t\tSitePage currPage = (SitePage) pageIter.next();\n\n\t\t\t\t\t\tList toolList = currPage.getTools();\n\t\t\t\t\t\tIterator toolIter = toolList.iterator();\n\t\t\t\t\t\twhile (toolIter.hasNext()) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tToolConfiguration toolConfig = (ToolConfiguration)toolIter.next();\n\n\t\t\t\t\t\t\tif (toolConfig.getToolId().equals(TOOL_ID)) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tElement newsData = doc.createElement(NEWS_ITEM);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t//There will only be a url property if the user updated the default URL\n\t\t\t\t\t\t\t\tString newsUrl = toolConfig.getPlacementConfig().getProperty(NEWS_URL_PROP);\t\t\n\t\t\t\t\t\t\t\tif (newsUrl == null || newsUrl.length() <= 0) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// news item is using default url\n\t\t\t\t\t\t\t\t\tnewsUrl = defaultUrl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tString toolTitle = toolConfig.getTitle();\n\t\t\t\t\t\t\t\tString pageTitle = currPage.getTitle();\n\n\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString encoded = Base64.encode(newsUrl.getBytes());\n\t\t\t\t\t\t\t\t\tnewsData.setAttribute(NEWS_URL, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode News URL - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString encoded = Base64.encode(toolTitle.getBytes());\n\t\t\t\t\t\t\t\t\tnewsData.setAttribute(TOOL_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode News Tool Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString encoded = Base64.encode(pageTitle.getBytes());\n\t\t\t\t\t\t\t\t\tnewsData.setAttribute(PAGE_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode News Page Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewsEl.appendChild(newsData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t  \n\t\t\t\t\t}\n\t\t\t\t\tresults.append(\"archiving \" + getLabel() + \": (\" + count\n\t\t\t\t\t\t\t+ \") news items archived successfully.\\n\");\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tresults.append(\"archiving \" + getLabel()\n\t\t\t\t\t\t\t+ \": empty news archived.\\n\");\n\t\t\t\t}\n\n\t\t\t\t((Element) stack.peek()).appendChild(newsEl);\n\t\t\t\tstack.push(newsEl);\n\t\t\t}\n\t\t\tstack.pop();\n\n\t\t}\n\t\tcatch (DOMException e)\t\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (IdUnusedException e)\t\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (Exception e)\t\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\treturn results.toString();\n\t}","id":88449,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic String archive(String siteId, Document doc, Stack stack, String arg3,\n\t\t      List attachments)\n\t{\n\t\tStringBuffer results = new StringBuffer();\n        Base64 codec = new Base64();\n\t\ttry\n\t\t{\n\t\t\tint count = 0;\n\t\t\tresults.append(\"archiving \" + getLabel() + \" context \"\n\t\t\t\t\t+ Entity.SEPARATOR + siteId + Entity.SEPARATOR\n\t\t\t\t\t+ SiteService.MAIN_CONTAINER + \".\\n\");\n\t\t\t\n\t\t\t// get the default news url\n\t\t\tString defaultUrl = ServerConfigurationService.getString(\"news.feedURL\");\n\t\t\t\n\t\t\t// start with an element with our very own (service) name\n\t\t\tElement element = doc.createElement(SERVICE_NAME);\n\t\t\telement.setAttribute(VERSION_ATTR, ARCHIVE_VERSION);\n\t\t\t((Element) stack.peek()).appendChild(element);\n\t\t\tstack.push(element);\n\t\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t\t{\n\t\t\t\tElement newsEl = doc.createElement(NEWS);\n\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tList sitePages = site.getPages();\n\n\t\t\t\tif (sitePages != null && !sitePages.isEmpty()) \n\t\t\t\t{\n\t\t\t\t\tIterator pageIter = sitePages.iterator();\n\t\t\t\t\twhile (pageIter.hasNext()) \n\t\t\t\t\t{\n\t\t\t\t\t\tSitePage currPage = (SitePage) pageIter.next();\n\n\t\t\t\t\t\tList toolList = currPage.getTools();\n\t\t\t\t\t\tIterator toolIter = toolList.iterator();\n\t\t\t\t\t\twhile (toolIter.hasNext()) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tToolConfiguration toolConfig = (ToolConfiguration)toolIter.next();\n\n\t\t\t\t\t\t\tif (toolConfig.getToolId().equals(TOOL_ID)) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tElement newsData = doc.createElement(NEWS_ITEM);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t//There will only be a url property if the user updated the default URL\n\t\t\t\t\t\t\t\tString newsUrl = toolConfig.getPlacementConfig().getProperty(NEWS_URL_PROP);\t\t\n\t\t\t\t\t\t\t\tif (newsUrl == null || newsUrl.length() <= 0) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// news item is using default url\n\t\t\t\t\t\t\t\t\tnewsUrl = defaultUrl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tString toolTitle = toolConfig.getTitle();\n\t\t\t\t\t\t\t\tString pageTitle = currPage.getTitle();\n\n\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString encoded = new String(codec.encode(newsUrl.getBytes(\"UTF-8\")),\"UTF-8\");\n\t\t\t\t\t\t\t\t\tnewsData.setAttribute(NEWS_URL, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode News URL - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString encoded = new String(codec.encode(toolTitle.getBytes(\"UTF-8\")),\"UTF-8\");\n\t\t\t\t\t\t\t\t\tnewsData.setAttribute(TOOL_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode News Tool Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tString encoded = new String(codec.encode(pageTitle.getBytes(\"UTF-8\")),\"UTF-8\");\n\t\t\t\t\t\t\t\t\tnewsData.setAttribute(PAGE_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode News Page Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewsEl.appendChild(newsData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t  \n\t\t\t\t\t}\n\t\t\t\t\tresults.append(\"archiving \" + getLabel() + \": (\" + count\n\t\t\t\t\t\t\t+ \") news items archived successfully.\\n\");\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tresults.append(\"archiving \" + getLabel()\n\t\t\t\t\t\t\t+ \": empty news archived.\\n\");\n\t\t\t\t}\n\n\t\t\t\t((Element) stack.peek()).appendChild(newsEl);\n\t\t\t\tstack.push(newsEl);\n\t\t\t}\n\t\t\tstack.pop();\n\n\t\t}\n\t\tcatch (DOMException e)\t\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (IdUnusedException e)\t\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (Exception e)\t\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\treturn results.toString();\n\t}","commit_id":"6cff385b03e391ead6a7209068a95e63fffcfc1d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String archive(String siteId, Document doc, Stack stack, String archivePath, List attachments)\n\t{\n\t\tStringBuffer results = new StringBuffer();\n\n\t\ttry\n\t\t{\n\t\t\tint count = 0;\n\t\t\tresults.append(\"archiving \" + getLabel() + \" context \"\n\t\t\t\t\t+ Entity.SEPARATOR + siteId + Entity.SEPARATOR\n\t\t\t\t\t+ SiteService.MAIN_CONTAINER + \".\\n\");\n\t\t\t// start with an element with our very own (service) name\n\t\t\tElement element = doc.createElement(SERVICE_NAME);\n\t\t\telement.setAttribute(VERSION_ATTR, ARCHIVE_VERSION);\n\t\t\t((Element) stack.peek()).appendChild(element);\n\t\t\tstack.push(element);\n\t\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t\t{\n\t\t\t\tElement webContentEl = doc.createElement(WEB_CONTENT);\n\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tList sitePages = site.getPages();\n\n\t\t\t\tif (sitePages != null && !sitePages.isEmpty()) {\n\t\t\t\t\tIterator pageIter = sitePages.iterator();\n\t\t\t\t\twhile (pageIter.hasNext()) {\n\t\t\t\t\t\tSitePage currPage = (SitePage) pageIter.next();\n\n\t\t\t\t\t\tList toolList = currPage.getTools();\n\t\t\t\t\t\tIterator toolIter = toolList.iterator();\n\t\t\t\t\t\twhile (toolIter.hasNext()) {\n\t\t\t\t\t\t\tToolConfiguration toolConfig = (ToolConfiguration)toolIter.next();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// we do not want to archive \"special\" uses of sakai.iframe, such as worksite info\n\t\t\t\t\t\t\tString special = toolConfig.getPlacementConfig().getProperty(SPECIAL_PROP);\n\n\t\t\t\t\t\t\tif (toolConfig.getToolId().equals(TOOL_ID) && special == null) {\n\t\t\t\t\t\t\t\tElement webContentData = doc.createElement(REDIRECT_TAB);\n\t\t\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\t\t\tString contentUrl = toolConfig.getPlacementConfig().getProperty(WEB_CONTENT_URL_PROP);\n\t\t\t\t\t\t\t\tString toolTitle = toolConfig.getTitle();\n\t\t\t\t\t\t\t\tString pageTitle = currPage.getTitle();\n\t\t\t\t\t\t\t\tString height = toolConfig.getPlacementConfig().getProperty(HEIGHT_PROP);\n\n\t\t\t\t\t\t\t\twebContentData.setAttribute(NEW_WINDOW, new Boolean(currPage.isPopUp()).toString());\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tString encoded = Base64.encode(contentUrl.getBytes());\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(WEB_CONTENT_URL, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode Web Content URL - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tString encoded = Base64.encode(toolTitle.getBytes());\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(WEB_CONTENT_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode Web Content Tool Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (height != null) {\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(HEIGHT_PROP, height);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tString encoded = Base64.encode(pageTitle.getBytes());\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(PAGE_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode Web Content Page Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (height != null) {\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(HEIGHT_PROP, height);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twebContentEl.appendChild(webContentData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t  \n\t\t\t\t\t}\n\t\t\t\t\tresults.append(\"archiving \" + getLabel() + \": (\" + count\n\t\t\t\t\t\t\t+ \") web content items archived successfully.\\n\");\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresults.append(\"archiving \" + getLabel()\n\t\t\t\t\t\t\t+ \": empty web content archived.\\n\");\n\t\t\t\t}\n\n\t\t\t\t((Element) stack.peek()).appendChild(webContentEl);\n\t\t\t\tstack.push(webContentEl);\n\t\t\t}\n\t\t\tstack.pop();\n\n\t\t}\n\t\tcatch (DOMException e)\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (IdUnusedException e)\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\treturn results.toString();\n\t}","id":88450,"modified_method":"public String archive(String siteId, Document doc, Stack stack, String archivePath, List attachments)\n\t{\n\t\tStringBuffer results = new StringBuffer();\n\n\t\tBase64 codec = new Base64();\n\t\ttry\n\t\t{\n\t\t\tint count = 0;\n\t\t\tresults.append(\"archiving \" + getLabel() + \" context \"\n\t\t\t\t\t+ Entity.SEPARATOR + siteId + Entity.SEPARATOR\n\t\t\t\t\t+ SiteService.MAIN_CONTAINER + \".\\n\");\n\t\t\t// start with an element with our very own (service) name\n\t\t\tElement element = doc.createElement(SERVICE_NAME);\n\t\t\telement.setAttribute(VERSION_ATTR, ARCHIVE_VERSION);\n\t\t\t((Element) stack.peek()).appendChild(element);\n\t\t\tstack.push(element);\n\t\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t\t{\n\t\t\t\tElement webContentEl = doc.createElement(WEB_CONTENT);\n\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tList sitePages = site.getPages();\n\n\t\t\t\tif (sitePages != null && !sitePages.isEmpty()) {\n\t\t\t\t\tIterator pageIter = sitePages.iterator();\n\t\t\t\t\twhile (pageIter.hasNext()) {\n\t\t\t\t\t\tSitePage currPage = (SitePage) pageIter.next();\n\n\t\t\t\t\t\tList toolList = currPage.getTools();\n\t\t\t\t\t\tIterator toolIter = toolList.iterator();\n\t\t\t\t\t\twhile (toolIter.hasNext()) {\n\t\t\t\t\t\t\tToolConfiguration toolConfig = (ToolConfiguration)toolIter.next();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// we do not want to archive \"special\" uses of sakai.iframe, such as worksite info\n\t\t\t\t\t\t\tString special = toolConfig.getPlacementConfig().getProperty(SPECIAL_PROP);\n\n\t\t\t\t\t\t\tif (toolConfig.getToolId().equals(TOOL_ID) && special == null) {\n\t\t\t\t\t\t\t\tElement webContentData = doc.createElement(REDIRECT_TAB);\n\t\t\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\t\t\tString contentUrl = toolConfig.getPlacementConfig().getProperty(WEB_CONTENT_URL_PROP);\n\t\t\t\t\t\t\t\tString toolTitle = toolConfig.getTitle();\n\t\t\t\t\t\t\t\tString pageTitle = currPage.getTitle();\n\t\t\t\t\t\t\t\tString height = toolConfig.getPlacementConfig().getProperty(HEIGHT_PROP);\n\n\t\t\t\t\t\t\t\twebContentData.setAttribute(NEW_WINDOW, new Boolean(currPage.isPopUp()).toString());\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tString encoded = new String(codec.encode(contentUrl.getBytes(\"UTF-8\")),\"UTF-8\");\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(WEB_CONTENT_URL, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode Web Content URL - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tString encoded = new String(codec.encode(toolTitle.getBytes(\"UTF-8\")),\"UTF-8\");\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(WEB_CONTENT_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode Web Content Tool Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (height != null) {\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(HEIGHT_PROP, height);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tString encoded = new String(codec.encode(pageTitle.getBytes(\"UTF-8\")),\"UTF-8\");\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(PAGE_TITLE, encoded);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\t\tM_log.warn(\"Encode Web Content Page Title - \" + e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (height != null) {\n\t\t\t\t\t\t\t\t\twebContentData.setAttribute(HEIGHT_PROP, height);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twebContentEl.appendChild(webContentData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t  \n\t\t\t\t\t}\n\t\t\t\t\tresults.append(\"archiving \" + getLabel() + \": (\" + count\n\t\t\t\t\t\t\t+ \") web content items archived successfully.\\n\");\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresults.append(\"archiving \" + getLabel()\n\t\t\t\t\t\t\t+ \": empty web content archived.\\n\");\n\t\t\t\t}\n\n\t\t\t\t((Element) stack.peek()).appendChild(webContentEl);\n\t\t\t\tstack.push(webContentEl);\n\t\t\t}\n\t\t\tstack.pop();\n\n\t\t}\n\t\tcatch (DOMException e)\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (IdUnusedException e)\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tM_log.error(e.getMessage(), e);\n\t\t}\n\t\treturn results.toString();\n\t}","commit_id":"6cff385b03e391ead6a7209068a95e63fffcfc1d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String merge(String siteId, Element root, String archivePath, String fromSiteId, Map attachmentNames, Map userIdTrans, Set userListAllowImport)\n\t{\n\t\tM_log.info(\"merge starts for Web Content...\");\n\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tNodeList allChildrenNodes = root.getChildNodes();\n\t\t\t\tint length = allChildrenNodes.getLength();\n\t\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\t{\n\t\t\t\t\tNode siteNode = allChildrenNodes.item(i);\n\t\t\t\t\tif (siteNode.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t{\n\t\t\t\t\t\tElement siteElement = (Element) siteNode;\n\t\t\t\t\t\tif (siteElement.getTagName().equals(WEB_CONTENT))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNodeList allContentNodes = siteElement.getChildNodes();\n\t\t\t\t\t\t\tint lengthContent = allContentNodes.getLength();\n\t\t\t\t\t\t\tfor (int j = 0; j < lengthContent; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tNode child1 = allContentNodes.item(j);\n\t\t\t\t\t\t\t\tif (child1.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tElement contentElement = (Element) child1;\n\t\t\t\t\t\t\t\t\tif (contentElement.getTagName().equals(REDIRECT_TAB))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tString toolTitle = contentElement.getAttribute(WEB_CONTENT_TITLE);\n\t\t\t\t\t\t\t\t\t\tString trimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && toolTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = Base64.decode(trimBody);\n\t\t\t\t\t\t\t\t\t\t\t\ttoolTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString pageTitle = contentElement.getAttribute(PAGE_TITLE);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(pageTitle != null && pageTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = Base64.decode(trimBody);\n\t\t\t\t\t\t\t\t\t\t\t\tpageTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// if either tool or page title is missing, use the same for both\n\t\t\t\t\t\t\t\t\t\tif ((toolTitle != null && toolTitle.length() > 0) && (pageTitle == null || pageTitle.length() == 0))\n\t\t\t\t\t\t\t\t\t\t\tpageTitle = toolTitle;\n\t\t\t\t\t\t\t\t\t\tif ((pageTitle != null && pageTitle.length() > 0) && (toolTitle == null || toolTitle.length() == 0))\n\t\t\t\t\t\t\t\t\t\t\ttoolTitle = pageTitle;\n\n\t\t\t\t\t\t\t\t\t\tString contentUrl = contentElement.getAttribute(WEB_CONTENT_URL);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(contentUrl != null && contentUrl.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(contentUrl);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = Base64.decode(trimBody);\n\t\t\t\t\t\t\t\t\t\t\t\tcontentUrl = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString height = contentElement.getAttribute(HEIGHT_PROP);\n\t\t\t\t\t\t\t\t\t\tString openInNewWindow = contentElement.getAttribute(NEW_WINDOW);\n\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && contentUrl != null && toolTitle.length() >0 && contentUrl.length() >0\n\t\t\t\t\t\t\t\t\t\t\t\t&& pageTitle !=null && pageTitle.length() > 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tTool tr = ToolManager.getTool(TOOL_ID);\n\t\t\t\t\t\t\t\t\t\t\tSitePage page = site.addPage(); \n\t\t\t\t\t\t\t\t\t\t\tpage.setTitle(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tToolConfiguration tool = page.addTool();\n\t\t\t\t\t\t\t\t\t\t\ttool.setTool(TOOL_ID, tr);\n\t\t\t\t\t\t\t\t\t\t\ttool.setTitle(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\ttool.getPlacementConfig().setProperty(WEB_CONTENT_URL_PROP, contentUrl);\n\n\t\t\t\t\t\t\t\t\t\t\tif (height != null) {\n\t\t\t\t\t\t\t\t\t\t\t\ttool.getPlacementConfig().setProperty(HEIGHT_PROP, height);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (openInNewWindow.equalsIgnoreCase(\"true\")) \n\t\t\t\t\t\t\t\t\t\t\t\tpage.setPopup(true);\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tpage.setPopup(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tM_log.warn(\"Web content item not imported because page_title and title missing or url missing: \" + \"title: \" + toolTitle + \" page_title: \" + pageTitle + \" url: \" + contentUrl);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSiteService.save(site);\n\t\t\t\tToolSession session = SessionManager.getCurrentToolSession();\n\n\t\t\t\tif (session.getAttribute(ATTR_TOP_REFRESH) == null)\n\t\t\t\t{\n\t\t\t\t\tsession.setAttribute(ATTR_TOP_REFRESH, Boolean.TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tM_log.error(\"errors in merge for WebServiceImpl\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":88451,"modified_method":"public String merge(String siteId, Element root, String archivePath, String fromSiteId, Map attachmentNames, Map userIdTrans, Set userListAllowImport)\n\t{\n\t\tM_log.info(\"merge starts for Web Content...\");\n\t\tBase64 codec = new Base64();\n\t\tif (siteId != null && siteId.trim().length() > 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSite site = SiteService.getSite(siteId);\n\t\t\t\tNodeList allChildrenNodes = root.getChildNodes();\n\t\t\t\tint length = allChildrenNodes.getLength();\n\t\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\t{\n\t\t\t\t\tNode siteNode = allChildrenNodes.item(i);\n\t\t\t\t\tif (siteNode.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t{\n\t\t\t\t\t\tElement siteElement = (Element) siteNode;\n\t\t\t\t\t\tif (siteElement.getTagName().equals(WEB_CONTENT))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNodeList allContentNodes = siteElement.getChildNodes();\n\t\t\t\t\t\t\tint lengthContent = allContentNodes.getLength();\n\t\t\t\t\t\t\tfor (int j = 0; j < lengthContent; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tNode child1 = allContentNodes.item(j);\n\t\t\t\t\t\t\t\tif (child1.getNodeType() == Node.ELEMENT_NODE)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tElement contentElement = (Element) child1;\n\t\t\t\t\t\t\t\t\tif (contentElement.getTagName().equals(REDIRECT_TAB))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tString toolTitle = contentElement.getAttribute(WEB_CONTENT_TITLE);\n\t\t\t\t\t\t\t\t\t\tString trimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && toolTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = codec.decode(trimBody.getBytes(\"UTF-8\"));\n\t\t\t\t\t\t\t\t\t\t\t\ttoolTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString pageTitle = contentElement.getAttribute(PAGE_TITLE);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(pageTitle != null && pageTitle.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = codec.decode(trimBody.getBytes(\"UTF-8\"));\n\t\t\t\t\t\t\t\t\t\t\t\tpageTitle = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// if either tool or page title is missing, use the same for both\n\t\t\t\t\t\t\t\t\t\tif ((toolTitle != null && toolTitle.length() > 0) && (pageTitle == null || pageTitle.length() == 0))\n\t\t\t\t\t\t\t\t\t\t\tpageTitle = toolTitle;\n\t\t\t\t\t\t\t\t\t\tif ((pageTitle != null && pageTitle.length() > 0) && (toolTitle == null || toolTitle.length() == 0))\n\t\t\t\t\t\t\t\t\t\t\ttoolTitle = pageTitle;\n\n\t\t\t\t\t\t\t\t\t\tString contentUrl = contentElement.getAttribute(WEB_CONTENT_URL);\n\t\t\t\t\t\t\t\t\t\ttrimBody = null;\n\t\t\t\t\t\t\t\t\t\tif(contentUrl != null && contentUrl.length() >0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttrimBody = trimToNull(contentUrl);\n\t\t\t\t\t\t\t\t\t\t\tif (trimBody != null && trimBody.length() >0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbyte[] decoded = codec.decode(trimBody.getBytes(\"UTF-8\"));\n\t\t\t\t\t\t\t\t\t\t\t\tcontentUrl = new String(decoded, \"UTF-8\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tString height = contentElement.getAttribute(HEIGHT_PROP);\n\t\t\t\t\t\t\t\t\t\tString openInNewWindow = contentElement.getAttribute(NEW_WINDOW);\n\n\t\t\t\t\t\t\t\t\t\tif(toolTitle != null && contentUrl != null && toolTitle.length() >0 && contentUrl.length() >0\n\t\t\t\t\t\t\t\t\t\t\t\t&& pageTitle !=null && pageTitle.length() > 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tTool tr = ToolManager.getTool(TOOL_ID);\n\t\t\t\t\t\t\t\t\t\t\tSitePage page = site.addPage(); \n\t\t\t\t\t\t\t\t\t\t\tpage.setTitle(pageTitle);\n\t\t\t\t\t\t\t\t\t\t\tToolConfiguration tool = page.addTool();\n\t\t\t\t\t\t\t\t\t\t\ttool.setTool(TOOL_ID, tr);\n\t\t\t\t\t\t\t\t\t\t\ttool.setTitle(toolTitle);\n\t\t\t\t\t\t\t\t\t\t\ttool.getPlacementConfig().setProperty(WEB_CONTENT_URL_PROP, contentUrl);\n\n\t\t\t\t\t\t\t\t\t\t\tif (height != null) {\n\t\t\t\t\t\t\t\t\t\t\t\ttool.getPlacementConfig().setProperty(HEIGHT_PROP, height);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (openInNewWindow.equalsIgnoreCase(\"true\")) \n\t\t\t\t\t\t\t\t\t\t\t\tpage.setPopup(true);\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tpage.setPopup(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tM_log.warn(\"Web content item not imported because page_title and title missing or url missing: \" + \"title: \" + toolTitle + \" page_title: \" + pageTitle + \" url: \" + contentUrl);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSiteService.save(site);\n\t\t\t\tToolSession session = SessionManager.getCurrentToolSession();\n\n\t\t\t\tif (session.getAttribute(ATTR_TOP_REFRESH) == null)\n\t\t\t\t{\n\t\t\t\t\tsession.setAttribute(ATTR_TOP_REFRESH, Boolean.TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tM_log.error(\"errors in merge for WebServiceImpl\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"6cff385b03e391ead6a7209068a95e63fffcfc1d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public MappingConfig_ExternalRef getCopy() {\n    MappingConfig_ExternalRef result = new MappingConfig_ExternalRef();\n    result.myGenerator = myGenerator.getCopy();\n    result.myMappingConfig = myMappingConfig.getCopy();\n    return result;\n  }","id":88452,"modified_method":"public MappingConfig_ExternalRef getCopy() {\n    MappingConfig_ExternalRef result = new MappingConfig_ExternalRef();\n    result.myGenerator = myGenerator!=null?myGenerator.getCopy():null;\n    result.myMappingConfig = myMappingConfig!=null?myMappingConfig.getCopy():null;\n    return result;\n  }","commit_id":"ca486b0163d95cb8b80f702e295378e7bbb1c229","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MappingConfig_RefSet getCopy() {\n    MappingConfig_RefSet result = new MappingConfig_RefSet();\n    for (MappingConfig_AbstractRef ref:myRefs){\n      result.myRefs.add(ref.getCopy());\n    }\n    return result;\n  }","id":88453,"modified_method":"public MappingConfig_RefSet getCopy() {\n    MappingConfig_RefSet result = new MappingConfig_RefSet();\n    for (MappingConfig_AbstractRef ref:myRefs){\n      result.myRefs.add(ref!=null?ref.getCopy():null);\n    }\n    return result;\n  }","commit_id":"ca486b0163d95cb8b80f702e295378e7bbb1c229","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MappingPriorityRule getCopy() {\n    MappingPriorityRule result = new MappingPriorityRule();\n    result.myLeft = myLeft.getCopy();\n    result.myRight = myRight.getCopy();\n    result.myType = myType;\n\n    return result;\n  }","id":88454,"modified_method":"public MappingPriorityRule getCopy() {\n    MappingPriorityRule result = new MappingPriorityRule();\n\n    result.myLeft = myLeft!=null?myLeft.getCopy():null;\n    result.myRight = myRight!=null?myRight.getCopy():null;\n    result.myType = myType;\n\n    return result;\n  }","commit_id":"ca486b0163d95cb8b80f702e295378e7bbb1c229","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelRoot getCopy() {\n    ModelRoot result = new ModelRoot();\n    result.myPath = myPath;\n    result.myPrefix = myPrefix;\n    result.myHandlerClass = myHandlerClass;\n    result.myManager = myManager.getCopy();\n\n    return result;\n  }","id":88455,"modified_method":"public ModelRoot getCopy() {\n    ModelRoot result = new ModelRoot();\n    result.myPath = myPath;\n    result.myPrefix = myPrefix;\n    result.myHandlerClass = myHandlerClass;\n    result.myManager = myManager == null ? null : myManager.getCopy();\n\n    return result;\n  }","commit_id":"82e93b33773433e81a6cf3f0395d35852c306efe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void scrapeText(final char[] newtext, final String insideTag) {\r\n        // System.out.println(\"SCRAPE: \" + UTF8.String(newtext));\r\n        int p, pl, q, s = 0;\r\n\r\n        // match evaluation pattern\r\n        this.evaluationScores.match(Element.text, newtext);\r\n\r\n        // try to find location information in text\r\n        // Opencaching:\r\n        // <nobr>N 50o 05.453&#039;<\/nobr><nobr>E 008o 30.191&#039;<\/nobr>\r\n        // N 52o 28.025 E 013o 20.299\r\n        location: while (s < newtext.length) {\r\n            pl = 1;\r\n            p = CharBuffer.indexOf(newtext, s, this.degree);\r\n            if (p < 0) {p = CharBuffer.indexOf(newtext, s, \"&deg;\".toCharArray()); if (p >= 0) pl = 5;}\r\n            if (p < 0) break location;\r\n            q = CharBuffer.indexOf(newtext, p + pl, this.minuteCharsHTML);\r\n            if (q < 0) q = CharBuffer.indexOf(newtext, p + pl, \"'\".toCharArray());\r\n            if (q < 0) q = CharBuffer.indexOf(newtext, p + pl, \" E\".toCharArray());\r\n            if (q < 0) q = CharBuffer.indexOf(newtext, p + pl, \" W\".toCharArray());\r\n            if (q < 0 && newtext.length - p == 7 + pl) q = newtext.length;\r\n            if (q < 0) break location;\r\n            int r = p;\r\n            while (r-- > 1) {\r\n                if (newtext[r] == ' ') {\r\n                    r--;\r\n                    if (newtext[r] == 'N') {\r\n                        this.lat =  Float.parseFloat(new String(newtext, r + 2, p - r - 2)) +\r\n                                    Float.parseFloat(new String(newtext, p + pl + 1, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lon != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    if (newtext[r] == 'S') {\r\n                        this.lat = -Float.parseFloat(new String(newtext, r + 2, p - r - 2)) -\r\n                                    Float.parseFloat(new String(newtext, p + pl + 1, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lon != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    if (newtext[r] == 'E') {\r\n                        this.lon =  Float.parseFloat(new String(newtext, r + 2, p - r - 2)) +\r\n                                    Float.parseFloat(new String(newtext, p + pl + 1, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lat != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    if (newtext[r] == 'W') {\r\n                        this.lon = -Float.parseFloat(new String(newtext, r + 2, p - r - 2)) -\r\n                                    Float.parseFloat(new String(newtext, p + 2, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lat != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    break location;\r\n                }\r\n            }\r\n            break location;\r\n        }\r\n        // find tags inside text\r\n        String b = cleanLine(super.stripAllTags(newtext));\r\n        if ((insideTag != null) && (!(insideTag.equals(\"a\")))) {\r\n            // texts inside tags sometimes have no punctuation at the line end\r\n            // this is bad for the text semantics, because it is not possible for the\r\n            // condenser to distinguish headlines from text beginnings.\r\n            // to make it easier for the condenser, a dot ('.') is appended in case that\r\n            // no punctuation is part of the newtext line\r\n            if ((b.length() != 0) && (!(SentenceReader.punctuation(b.charAt(b.length() - 1))))) b = b + '.';\r\n            //System.out.println(\"*** Appended dot: \" + b.toString());\r\n        }\r\n        // find http links inside text\r\n        s = 0;\r\n        String u;\r\n        MultiProtocolURI url;\r\n        while (s < b.length()) {\r\n            p = find(b, dpssp, s);\r\n            if (p == Integer.MAX_VALUE) break;\r\n            s = Math.max(0, p - 5);\r\n            p = find(b, protp, s);\r\n            if (p == Integer.MAX_VALUE) break;\r\n            q = b.indexOf(\" \", p + 1);\r\n            u = b.substring(p, q < 0 ? b.length() : q);\r\n            if (u.endsWith(\".\")) u = u.substring(0, u.length() - 1); // remove the '.' that was appended above\r\n            s = p + 6;\r\n            try {\r\n                url = new MultiProtocolURI(u);\r\n                this.anchors.put(url, new Properties());\r\n                continue;\r\n            } catch (final MalformedURLException e) {}\r\n        }\r\n        // append string to content\r\n        if (b.length() != 0) this.content.append(b).append(32);\r\n    }","id":88456,"modified_method":"public void scrapeText(final char[] newtext, final String insideTag) {\r\n        // System.out.println(\"SCRAPE: \" + UTF8.String(newtext));\r\n        int p, pl, q, s = 0;\r\n\r\n        // match evaluation pattern\r\n        this.evaluationScores.match(Element.text, newtext);\r\n\r\n        // try to find location information in text\r\n        // Opencaching:\r\n        // <nobr>N 50o 05.453&#039;<\/nobr><nobr>E 008o 30.191&#039;<\/nobr>\r\n        // N 52o 28.025 E 013o 20.299\r\n        location: while (s < newtext.length) {\r\n            pl = 1;\r\n            p = CharBuffer.indexOf(newtext, s, this.degree);\r\n            if (p < 0) {p = CharBuffer.indexOf(newtext, s, \"&deg;\".toCharArray()); if (p >= 0) pl = 5;}\r\n            if (p < 0) break location;\r\n            q = CharBuffer.indexOf(newtext, p + pl, this.minuteCharsHTML);\r\n            if (q < 0) q = CharBuffer.indexOf(newtext, p + pl, \"'\".toCharArray());\r\n            if (q < 0) q = CharBuffer.indexOf(newtext, p + pl, \" E\".toCharArray());\r\n            if (q < 0) q = CharBuffer.indexOf(newtext, p + pl, \" W\".toCharArray());\r\n            if (q < 0 && newtext.length - p == 7 + pl) q = newtext.length;\r\n            if (q < 0) break location;\r\n            int r = p;\r\n            while (r-- > 1) {\r\n                if (newtext[r] == ' ') {\r\n                    r--;\r\n                    if (newtext[r] == 'N') {\r\n                        this.lat =  Float.parseFloat(new String(newtext, r + 2, p - r - 2)) +\r\n                                    Float.parseFloat(new String(newtext, p + pl + 1, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lon != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    if (newtext[r] == 'S') {\r\n                        this.lat = -Float.parseFloat(new String(newtext, r + 2, p - r - 2)) -\r\n                                    Float.parseFloat(new String(newtext, p + pl + 1, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lon != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    if (newtext[r] == 'E') {\r\n                        this.lon =  Float.parseFloat(new String(newtext, r + 2, p - r - 2)) +\r\n                                    Float.parseFloat(new String(newtext, p + pl + 1, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lat != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    if (newtext[r] == 'W') {\r\n                        this.lon = -Float.parseFloat(new String(newtext, r + 2, p - r - 2)) -\r\n                                    Float.parseFloat(new String(newtext, p + 2, q - p - pl - 1)) / 60.0f;\r\n                        if (this.lat != 0.0f) break location;\r\n                        s = q + 6;\r\n                        continue location;\r\n                    }\r\n                    break location;\r\n                }\r\n            }\r\n            break location;\r\n        }\r\n        // find tags inside text\r\n        String b = cleanLine(super.stripAllTags(newtext));\r\n        if ((insideTag != null) && (!(insideTag.equals(\"a\")))) {\r\n            // texts inside tags sometimes have no punctuation at the line end\r\n            // this is bad for the text semantics, because it is not possible for the\r\n            // condenser to distinguish headlines from text beginnings.\r\n            // to make it easier for the condenser, a dot ('.') is appended in case that\r\n            // no punctuation is part of the newtext line\r\n            if ((b.length() != 0) && (!(SentenceReader.punctuation(b.charAt(b.length() - 1))))) b = b + '.';\r\n            //System.out.println(\"*** Appended dot: \" + b.toString());\r\n        }\r\n        // find http links inside text\r\n        s = 0;\r\n        String u;\r\n        MultiProtocolURI url;\r\n        while (s < b.length()) {\r\n            p = find(b, dpssp, s);\r\n            if (p == Integer.MAX_VALUE) break;\r\n            s = Math.max(0, p - 5);\r\n            p = find(b, protp, s);\r\n            if (p == Integer.MAX_VALUE) break;\r\n            q = b.indexOf(\" \", p + 1);\r\n            u = b.substring(p, q < 0 ? b.length() : q);\r\n            if (u.endsWith(\".\")) u = u.substring(0, u.length() - 1); // remove the '.' that was appended above\r\n            s = p + 6;\r\n            try {\r\n                url = new MultiProtocolURI(u);\r\n                mergeAnchors(url, new Properties());\r\n                continue;\r\n            } catch (final MalformedURLException e) {}\r\n        }\r\n        // append string to content\r\n        if (b.length() != 0) this.content.append(b).append(32);\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void scrapeTag0(final String tagname, final Properties tagopts) {\r\n        if (tagname.equalsIgnoreCase(\"img\")) {\r\n            final String src = tagopts.getProperty(\"src\", \"\");\r\n            try {\r\n                final int width = Integer.parseInt(tagopts.getProperty(\"width\", \"-1\"));\r\n                final int height = Integer.parseInt(tagopts.getProperty(\"height\", \"-1\"));\r\n                if (src.length() > 0) {\r\n                    final MultiProtocolURI url = absolutePath(src);\r\n                    if (url != null) {\r\n                        final ImageEntry ie = new ImageEntry(url, tagopts.getProperty(\"alt\", \"\"), width, height, -1);\r\n                        addImage(this.images, ie);\r\n                    }\r\n                }\r\n            } catch (final NumberFormatException e) {}\r\n            this.evaluationScores.match(Element.imgpath, src);\r\n        } else if(tagname.equalsIgnoreCase(\"base\")) {\r\n            try {\r\n                this.root = new MultiProtocolURI(tagopts.getProperty(\"href\", \"\"));\r\n            } catch (final MalformedURLException e) {}\r\n        } else if (tagname.equalsIgnoreCase(\"frame\")) {\r\n            final MultiProtocolURI src = absolutePath(tagopts.getProperty(\"src\", \"\"));\r\n            this.anchors.put(src, tagopts /* with property \"name\" */);\r\n            this.frames.add(src);\r\n            this.evaluationScores.match(Element.framepath, src.toNormalform(true, false));\r\n        } else if (tagname.equalsIgnoreCase(\"body\")) {\r\n            final String c = tagopts.getProperty(\"class\", \"\");\r\n            this.evaluationScores.match(Element.bodyclass, c);\r\n        } else if (tagname.equalsIgnoreCase(\"div\")) {\r\n            final String id = tagopts.getProperty(\"id\", \"\");\r\n            this.evaluationScores.match(Element.divid, id);\r\n        } else if (tagname.equalsIgnoreCase(\"meta\")) {\r\n            String name = tagopts.getProperty(\"name\", \"\");\r\n            final String content = tagopts.getProperty(\"content\",\"\");\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n                if (name.equals(\"generator\")) {\r\n                    this.evaluationScores.match(Element.metagenerator, content);\r\n                }\r\n            } else {\r\n                name = tagopts.getProperty(\"http-equiv\", \"\");\r\n                if (name.length() > 0) {\r\n                    this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n                }\r\n            }\r\n        } else if (tagname.equalsIgnoreCase(\"area\")) {\r\n            final String areatitle = cleanLine(tagopts.getProperty(\"title\",\"\"));\r\n            //String alt   = tagopts.getProperty(\"alt\",\"\");\r\n            final String href  = tagopts.getProperty(\"href\", \"\");\r\n            final Properties p = new Properties(); p.put(\"name\", areatitle);\r\n            if (href.length() > 0) this.anchors.put(absolutePath(href), p);\r\n        } else if (tagname.equalsIgnoreCase(\"link\")) {\r\n            final String href = tagopts.getProperty(\"href\", \"\");\r\n            final MultiProtocolURI newLink = absolutePath(href);\r\n\r\n            if (newLink != null) {\r\n                final String rel = tagopts.getProperty(\"rel\", \"\");\r\n                final String linktitle = tagopts.getProperty(\"title\", \"\");\r\n                final String type = tagopts.getProperty(\"type\", \"\");\r\n\r\n                if (rel.equalsIgnoreCase(\"shortcut icon\")) {\r\n                    final ImageEntry ie = new ImageEntry(newLink, linktitle, -1, -1, -1);\r\n                    this.images.put(ie.url(), ie);\r\n                    this.favicon = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"canonical\")) {\r\n                    final Properties p = new Properties(); p.put(\"name\", this.title);\r\n                    this.anchors.put(newLink, p);\r\n                    this.canonical = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"alternate\") && type.equalsIgnoreCase(\"application/rss+xml\")) {\r\n                    this.rss.put(newLink, linktitle);\r\n                } else if (rel.equalsIgnoreCase(\"stylesheet\") && type.equalsIgnoreCase(\"text/css\")) {\r\n                    this.css.put(newLink, rel);\r\n                    this.evaluationScores.match(Element.csspath, href);\r\n                } else if (!rel.equalsIgnoreCase(\"stylesheet\") && !rel.equalsIgnoreCase(\"alternate stylesheet\")) {\r\n                    final Properties p = new Properties(); p.put(\"name\", linktitle);\r\n                    this.anchors.put(newLink, p);\r\n                }\r\n            }\r\n        } else if(tagname.equalsIgnoreCase(\"embed\")) {\r\n            this.anchors.put(absolutePath(tagopts.getProperty(\"src\", \"\")), tagopts /* with property \"name\" */);\r\n        } else if(tagname.equalsIgnoreCase(\"param\")) {\r\n            final String name = tagopts.getProperty(\"name\", \"\");\r\n            if (name.equalsIgnoreCase(\"movie\")) {\r\n                this.anchors.put(absolutePath(tagopts.getProperty(\"value\", \"\")), tagopts /* with property \"name\" */);\r\n            }\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag0(tagname, tagopts);\r\n    }","id":88457,"modified_method":"public void scrapeTag0(final String tagname, final Properties tagopts) {\r\n        if (tagname.equalsIgnoreCase(\"img\")) {\r\n            final String src = tagopts.getProperty(\"src\", \"\");\r\n            try {\r\n                final int width = Integer.parseInt(tagopts.getProperty(\"width\", \"-1\"));\r\n                final int height = Integer.parseInt(tagopts.getProperty(\"height\", \"-1\"));\r\n                if (src.length() > 0) {\r\n                    final MultiProtocolURI url = absolutePath(src);\r\n                    if (url != null) {\r\n                        final ImageEntry ie = new ImageEntry(url, tagopts.getProperty(\"alt\", \"\"), width, height, -1);\r\n                        addImage(this.images, ie);\r\n                    }\r\n                }\r\n            } catch (final NumberFormatException e) {}\r\n            this.evaluationScores.match(Element.imgpath, src);\r\n        } else if(tagname.equalsIgnoreCase(\"base\")) {\r\n            try {\r\n                this.root = new MultiProtocolURI(tagopts.getProperty(\"href\", \"\"));\r\n            } catch (final MalformedURLException e) {}\r\n        } else if (tagname.equalsIgnoreCase(\"frame\")) {\r\n            final MultiProtocolURI src = absolutePath(tagopts.getProperty(\"src\", \"\"));\r\n            mergeAnchors(src, tagopts /* with property \"name\" */);\r\n            this.frames.add(src);\r\n            this.evaluationScores.match(Element.framepath, src.toNormalform(true, false));\r\n        } else if (tagname.equalsIgnoreCase(\"body\")) {\r\n            final String c = tagopts.getProperty(\"class\", \"\");\r\n            this.evaluationScores.match(Element.bodyclass, c);\r\n        } else if (tagname.equalsIgnoreCase(\"div\")) {\r\n            final String id = tagopts.getProperty(\"id\", \"\");\r\n            this.evaluationScores.match(Element.divid, id);\r\n        } else if (tagname.equalsIgnoreCase(\"meta\")) {\r\n            String name = tagopts.getProperty(\"name\", \"\");\r\n            final String content = tagopts.getProperty(\"content\",\"\");\r\n            if (name.length() > 0) {\r\n                this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n                if (name.equals(\"generator\")) {\r\n                    this.evaluationScores.match(Element.metagenerator, content);\r\n                }\r\n            } else {\r\n                name = tagopts.getProperty(\"http-equiv\", \"\");\r\n                if (name.length() > 0) {\r\n                    this.metas.put(name.toLowerCase(), CharacterCoding.html2unicode(content));\r\n                }\r\n            }\r\n        } else if (tagname.equalsIgnoreCase(\"area\")) {\r\n            final String areatitle = cleanLine(tagopts.getProperty(\"title\",\"\"));\r\n            //String alt   = tagopts.getProperty(\"alt\",\"\");\r\n            final String href  = tagopts.getProperty(\"href\", \"\");\r\n            tagopts.put(\"nme\", areatitle);\r\n            if (href.length() > 0) mergeAnchors(absolutePath(href), tagopts);\r\n        } else if (tagname.equalsIgnoreCase(\"link\")) {\r\n            final String href = tagopts.getProperty(\"href\", \"\");\r\n            final MultiProtocolURI newLink = absolutePath(href);\r\n\r\n            if (newLink != null) {\r\n                final String rel = tagopts.getProperty(\"rel\", \"\");\r\n                final String linktitle = tagopts.getProperty(\"title\", \"\");\r\n                final String type = tagopts.getProperty(\"type\", \"\");\r\n\r\n                if (rel.equalsIgnoreCase(\"shortcut icon\")) {\r\n                    final ImageEntry ie = new ImageEntry(newLink, linktitle, -1, -1, -1);\r\n                    this.images.put(ie.url(), ie);\r\n                    this.favicon = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"canonical\")) {\r\n                    tagopts.put(\"name\", this.title);\r\n                    mergeAnchors(newLink, tagopts);\r\n                    this.canonical = newLink;\r\n                } else if (rel.equalsIgnoreCase(\"alternate\") && type.equalsIgnoreCase(\"application/rss+xml\")) {\r\n                    this.rss.put(newLink, linktitle);\r\n                } else if (rel.equalsIgnoreCase(\"stylesheet\") && type.equalsIgnoreCase(\"text/css\")) {\r\n                    this.css.put(newLink, rel);\r\n                    this.evaluationScores.match(Element.csspath, href);\r\n                } else if (!rel.equalsIgnoreCase(\"stylesheet\") && !rel.equalsIgnoreCase(\"alternate stylesheet\")) {\r\n                    tagopts.put(\"name\", linktitle);\r\n                    mergeAnchors(newLink, tagopts);\r\n                }\r\n            }\r\n        } else if(tagname.equalsIgnoreCase(\"embed\")) {\r\n            mergeAnchors(absolutePath(tagopts.getProperty(\"src\", \"\")), tagopts /* with property \"name\" */);\r\n        } else if(tagname.equalsIgnoreCase(\"param\")) {\r\n            final String name = tagopts.getProperty(\"name\", \"\");\r\n            if (name.equalsIgnoreCase(\"movie\")) {\r\n                mergeAnchors(absolutePath(tagopts.getProperty(\"value\", \"\")), tagopts /* with property \"name\" */);\r\n            }\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag0(tagname, tagopts);\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void scrapeTag1(final String tagname, final Properties tagopts, final char[] text) {\r\n        // System.out.println(\"ScrapeTag1: tagname=\" + tagname + \", opts=\" + tagopts.toString() + \", text=\" + UTF8.String(text));\r\n        if (tagname.equalsIgnoreCase(\"a\") && text.length < 2048) {\r\n            final String href = tagopts.getProperty(\"href\", \"\");\r\n            MultiProtocolURI url;\r\n            if ((href.length() > 0) && ((url = absolutePath(href)) != null)) {\r\n                final String f = url.getFile();\r\n                final int p = f.lastIndexOf('.');\r\n                final String type = (p < 0) ? \"\" : f.substring(p + 1);\r\n                if (type.equals(\"png\") || type.equals(\"gif\") || type.equals(\"jpg\") || type.equals(\"jpeg\") || type.equals(\"tiff\") || type.equals(\"tif\")) {\r\n                    // special handling of such urls: put them to the image urls\r\n                    final ImageEntry ie = new ImageEntry(url, recursiveParse(text), -1, -1, -1);\r\n                    addImage(this.images, ie);\r\n                } else {\r\n                    tagopts.put(\"name\", recursiveParse(text));\r\n                    this.anchors.put(url, tagopts);\r\n                }\r\n            }\r\n            this.evaluationScores.match(Element.apath, href);\r\n        }\r\n        final String h;\r\n        if ((tagname.equalsIgnoreCase(\"h1\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[0].add(h);\r\n        } else if((tagname.equalsIgnoreCase(\"h2\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[1].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h3\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[2].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h4\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[3].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h5\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[4].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h6\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[5].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"title\")) && (text.length < 1024)) {\r\n            this.title = recursiveParse(text);\r\n        } else if ((tagname.equalsIgnoreCase(\"b\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.bold.inc(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"strong\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.bold.inc(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"i\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.italic.inc(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"li\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.li.add(h);\r\n        } else if (tagname.equalsIgnoreCase(\"iframe\")) {\r\n            final MultiProtocolURI src = absolutePath(tagopts.getProperty(\"src\", \"\"));\r\n            this.anchors.put(src, tagopts /* with property \"name\" */);\r\n            this.iframes.add(src);\r\n            this.evaluationScores.match(Element.iframepath, src.toNormalform(true, false));\r\n        } else if (tagname.equalsIgnoreCase(\"script\")) {\r\n            final String src = tagopts.getProperty(\"src\", \"\");\r\n            if (src.length() > 0) {\r\n                this.script.add(absolutePath(src));\r\n                this.evaluationScores.match(Element.scriptpath, src);\r\n            } else {\r\n                this.evaluationScores.match(Element.scriptcode, text);\r\n            }\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag1(tagname, tagopts, text);\r\n    }","id":88458,"modified_method":"public void scrapeTag1(final String tagname, final Properties tagopts, final char[] text) {\r\n        // System.out.println(\"ScrapeTag1: tagname=\" + tagname + \", opts=\" + tagopts.toString() + \", text=\" + UTF8.String(text));\r\n        if (tagname.equalsIgnoreCase(\"a\") && text.length < 2048) {\r\n            final String href = tagopts.getProperty(\"href\", \"\");\r\n            MultiProtocolURI url;\r\n            if ((href.length() > 0) && ((url = absolutePath(href)) != null)) {\r\n                final String f = url.getFile();\r\n                final int p = f.lastIndexOf('.');\r\n                final String type = (p < 0) ? \"\" : f.substring(p + 1);\r\n                if (type.equals(\"png\") || type.equals(\"gif\") || type.equals(\"jpg\") || type.equals(\"jpeg\") || type.equals(\"tiff\") || type.equals(\"tif\")) {\r\n                    // special handling of such urls: put them to the image urls\r\n                    final ImageEntry ie = new ImageEntry(url, recursiveParse(text), -1, -1, -1);\r\n                    addImage(this.images, ie);\r\n                } else {\r\n                    tagopts.put(\"text\", recursiveParse(text));\r\n                    mergeAnchors(url, tagopts);\r\n                }\r\n            }\r\n            this.evaluationScores.match(Element.apath, href);\r\n        }\r\n        final String h;\r\n        if ((tagname.equalsIgnoreCase(\"h1\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[0].add(h);\r\n        } else if((tagname.equalsIgnoreCase(\"h2\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[1].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h3\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[2].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h4\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[3].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h5\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[4].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"h6\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.headlines[5].add(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"title\")) && (text.length < 1024)) {\r\n            this.title = recursiveParse(text);\r\n        } else if ((tagname.equalsIgnoreCase(\"b\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.bold.inc(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"strong\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.bold.inc(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"i\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.italic.inc(h);\r\n        } else if ((tagname.equalsIgnoreCase(\"li\")) && (text.length < 1024)) {\r\n            h = recursiveParse(text);\r\n            if (h.length() > 0) this.li.add(h);\r\n        } else if (tagname.equalsIgnoreCase(\"iframe\")) {\r\n            final MultiProtocolURI src = absolutePath(tagopts.getProperty(\"src\", \"\"));\r\n            mergeAnchors(src, tagopts /* with property \"name\" */);\r\n            this.iframes.add(src);\r\n            this.evaluationScores.match(Element.iframepath, src.toNormalform(true, false));\r\n        } else if (tagname.equalsIgnoreCase(\"script\")) {\r\n            final String src = tagopts.getProperty(\"src\", \"\");\r\n            if (src.length() > 0) {\r\n                this.script.add(absolutePath(src));\r\n                this.evaluationScores.match(Element.scriptpath, src);\r\n            } else {\r\n                this.evaluationScores.match(Element.scriptcode, text);\r\n            }\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag1(tagname, tagopts, text);\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private String recursiveParse(final char[] inlineHtml) {\r\n        if (inlineHtml.length < 14) return cleanLine(super.stripAll(inlineHtml));\r\n\r\n        // start a new scraper to parse links inside this text\r\n        // parsing the content\r\n        final ContentScraper scraper = new ContentScraper(this.root);\r\n        final TransformerWriter writer = new TransformerWriter(null, null, scraper, null, false);\r\n        try {\r\n            FileUtils.copy(new CharArrayReader(inlineHtml), writer);\r\n            writer.close();\r\n        } catch (final IOException e) {\r\n            Log.logException(e);\r\n            return cleanLine(super.stripAll(inlineHtml));\r\n        }\r\n        this.anchors.putAll(scraper.getAnchors());\r\n        this.images.putAll(scraper.images);\r\n\r\n        return cleanLine(super.stripAll(scraper.content.getChars()));\r\n    }","id":88459,"modified_method":"private String recursiveParse(final char[] inlineHtml) {\r\n        if (inlineHtml.length < 14) return cleanLine(super.stripAll(inlineHtml));\r\n\r\n        // start a new scraper to parse links inside this text\r\n        // parsing the content\r\n        final ContentScraper scraper = new ContentScraper(this.root);\r\n        final TransformerWriter writer = new TransformerWriter(null, null, scraper, null, false);\r\n        try {\r\n            FileUtils.copy(new CharArrayReader(inlineHtml), writer);\r\n            writer.close();\r\n        } catch (final IOException e) {\r\n            Log.logException(e);\r\n            return cleanLine(super.stripAll(inlineHtml));\r\n        }\r\n        for (final Map.Entry<MultiProtocolURI, Properties> entry: scraper.getAnchors().entrySet()) {\r\n            mergeAnchors(entry.getKey(), entry.getValue());\r\n        }\r\n        this.images.putAll(scraper.images);\r\n\r\n        return cleanLine(super.stripAll(scraper.content.getChars()));\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean containsFlash() {\r\n        this.anchors = new HashMap<MultiProtocolURI, Properties>();\r\n        String ext;\r\n        for (final MultiProtocolURI url: this.anchors.keySet()) {\r\n            ext = url.getFileExtension();\r\n            if (ext == null) continue;\r\n            if (ext.equals(\"swf\")) return true;\r\n        }\r\n        return false;\r\n    }","id":88460,"modified_method":"public boolean containsFlash() {\r\n        String ext;\r\n        for (final MultiProtocolURI url: this.anchors.keySet()) {\r\n            ext = url.getFileExtension();\r\n            if (ext == null) continue;\r\n            if (ext.equals(\"swf\")) return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public SolrInputDocument yacy2solr(final String id, final ResponseHeader header, final Document yacydoc) {\n        // we user the SolrCell design as index scheme\n        final SolrInputDocument solrdoc = new SolrInputDocument();\n        final DigestURI digestURI = new DigestURI(yacydoc.dc_source());\n        addSolr(solrdoc, \"failreason_t\", \"\"); // overwrite a possible fail reason (in case that there was a fail reason before)\n        addSolr(solrdoc, \"id\", id);\n        addSolr(solrdoc, \"sku\", digestURI.toNormalform(true, false), 3.0f);\n        final InetAddress address = Domains.dnsResolve(digestURI.getHost());\n        if (address != null) addSolr(solrdoc, \"ip_s\", address.getHostAddress());\n        if (digestURI.getHost() != null) addSolr(solrdoc, \"host_s\", digestURI.getHost());\n        addSolr(solrdoc, \"title\", yacydoc.dc_title());\n        addSolr(solrdoc, \"author\", yacydoc.dc_creator());\n        addSolr(solrdoc, \"description\", yacydoc.dc_description());\n        addSolr(solrdoc, \"content_type\", yacydoc.dc_format());\n        addSolr(solrdoc, \"last_modified\", header.lastModified());\n        addSolr(solrdoc, \"keywords\", yacydoc.dc_subject(' '));\n        final String content = UTF8.String(yacydoc.getTextBytes());\n        addSolr(solrdoc, \"text_t\", content);\n        if (isEmpty() || contains(\"wordcount_i\")) {\n            final int contentwc = content.split(\" \").length;\n            addSolr(solrdoc, \"wordcount_i\", contentwc);\n        }\n\n        // path elements of link\n        final String path = digestURI.getPath();\n        if (path != null && (isEmpty() || contains(\"attr_paths\"))) {\n            final String[] paths = path.split(\"/\");\n            if (paths.length > 0) addSolr(solrdoc, \"attr_paths\", paths);\n        }\n\n        // list all links\n        final Map<MultiProtocolURI, Properties> alllinks = yacydoc.getAnchors();\n        int c = 0;\n        if (isEmpty() || contains(\"inboundlinkscount_i\")) addSolr(solrdoc, \"inboundlinkscount_i\", yacydoc.inboundLinkCount());\n        if (isEmpty() || contains(\"inboundlinksnoindexcount_i\")) addSolr(solrdoc, \"inboundlinksnoindexcount_i\", yacydoc.inboundLinkNoindexCount());\n        if (isEmpty() || contains(\"attr_inboundlinks\")) {\n            final String[] inboundlinks = new String[yacydoc.inboundLinkCount()];\n            for (final MultiProtocolURI url: yacydoc.inboundLinks()) {\n                final Properties p = alllinks.get(url);\n                final String name = p.getProperty(\"name\", \"\");\n                final String rel = p.getProperty(\"rel\", \"\");\n                inboundlinks[c++] =\n                    \"<a href=\\\"\" + url.toNormalform(false, false) + \"\\\"\" +\n                    (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                    \">\" +\n                    ((name.length() > 0) ? name : \"\") + \"<\/a>\";\n            }\n            addSolr(solrdoc, \"attr_inboundlinks\", inboundlinks);\n        }\n        c = 0;\n        if (isEmpty() || contains(\"outboundlinkscount_i\")) addSolr(solrdoc, \"outboundlinkscount_i\", yacydoc.outboundLinkCount());\n        if (isEmpty() || contains(\"outboundlinksnoindexcount_i\")) addSolr(solrdoc, \"outboundlinksnoindexcount_i\", yacydoc.outboundLinkNoindexCount());\n        if (isEmpty() || contains(\"attr_outboundlinks\")) {\n            final String[] outboundlinks = new String[yacydoc.outboundLinkCount()];\n            for (final MultiProtocolURI url: yacydoc.outboundLinks()) {\n                final Properties p = alllinks.get(url);\n                final String name = p.getProperty(\"name\", \"\");\n                final String rel = p.getProperty(\"rel\", \"\");\n                outboundlinks[c++] =\n                    \"<a href=\\\"\" + url.toNormalform(false, false) + \"\\\"\" +\n                    (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                    \">\" +\n                    ((name.length() > 0) ? name : \"\") + \"<\/a>\";\n            }\n            addSolr(solrdoc, \"attr_outboundlinks\", outboundlinks);\n        }\n        // charset\n        addSolr(solrdoc, \"charset_s\", yacydoc.getCharset());\n\n        // coordinates\n        if (yacydoc.lat() != 0.0f && yacydoc.lon() != 0.0f) {\n            addSolr(solrdoc, \"lon_coordinate\", yacydoc.lon());\n            addSolr(solrdoc, \"lat_coordinate\", yacydoc.lat());\n        }\n        addSolr(solrdoc, \"httpstatus_i\", 200);\n        final Object parser = yacydoc.getParserObject();\n        if (parser instanceof ContentScraper) {\n            final ContentScraper html = (ContentScraper) parser;\n\n            // header tags\n            int h = 0;\n            int f = 1;\n            for (int i = 1; i <= 6; i++) {\n                final String[] hs = html.getHeadlines(i);\n                h = h | (hs.length > 0 ? f : 0);\n                f = f * 2;\n                addSolr(solrdoc, \"attr_h\" + i, hs);\n            }\n            addSolr(solrdoc, \"htags_i\", h);\n\n            // canonical tag\n            if (html.getCanonical() != null) addSolr(solrdoc, \"canonical_s\", html.getCanonical().toNormalform(false, false));\n\n            // meta tags\n            final Map<String, String> metas = html.getMetas();\n            final String robots = metas.get(\"robots\");\n            if (robots != null) addSolr(solrdoc, \"metarobots_t\", robots);\n            final String generator = metas.get(\"generator\");\n            if (generator != null) addSolr(solrdoc, \"metagenerator_t\", generator);\n\n            // bold, italic\n            final String[] bold = html.getBold();\n            addSolr(solrdoc, \"boldcount_i\", bold.length);\n            if (bold.length > 0) {\n                addSolr(solrdoc, \"attr_bold\", bold);\n                if (isEmpty() || contains(\"attr_boldcount\")) {\n                    addSolr(solrdoc, \"attr_boldcount\", html.getBoldCount(bold));\n                }\n            }\n            final String[] italic = html.getItalic();\n            addSolr(solrdoc, \"italiccount_i\", italic.length);\n            if (italic.length > 0) {\n                addSolr(solrdoc, \"attr_italic\", italic);\n                if (isEmpty() || contains(\"attr_italiccount\")) {\n                    addSolr(solrdoc, \"attr_italiccount\", html.getItalicCount(italic));\n                }\n            }\n            final String[] li = html.getLi();\n            addSolr(solrdoc, \"licount_i\", li.length);\n            if (li.length > 0) addSolr(solrdoc, \"attr_li\", li);\n\n            // images\n            if (isEmpty() || contains(\"attr_images\")) {\n                final Collection<ImageEntry> imagesc = html.getImages().values();\n                final String[] images = new String[imagesc.size()];\n                c = 0;\n                for (final ImageEntry ie: imagesc) images[c++] = ie.toString();\n                addSolr(solrdoc, \"imagescount_i\", images.length);\n                if (images.length > 0) addSolr(solrdoc, \"attr_images\", images);\n            }\n\n            // style sheets\n            if (isEmpty() || contains(\"attr_css\")) {\n                final Map<MultiProtocolURI, String> csss = html.getCSS();\n                final String[] css = new String[csss.size()];\n                c = 0;\n                for (final Map.Entry<MultiProtocolURI, String> entry: csss.entrySet()) {\n                    css[c++] =\n                        \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" media=\\\"\" + entry.getValue() + \"\\\"\" +\n                        \" href=\\\"\"+ entry.getKey().toNormalform(false, false, false, false) + \"\\\" />\";\n                }\n                addSolr(solrdoc, \"csscount_i\", css.length);\n                if (css.length > 0) addSolr(solrdoc, \"attr_css\", css);\n            }\n\n            // Scripts\n            if (isEmpty() || contains(\"attr_scripts\")) {\n                final Set<MultiProtocolURI> scriptss = html.getScript();\n                final String[] scripts = new String[scriptss.size()];\n                c = 0;\n                for (final MultiProtocolURI url: scriptss) {\n                    scripts[c++] = url.toNormalform(false, false, false, false);\n                }\n                addSolr(solrdoc, \"scriptscount_i\", scripts.length);\n                if (scripts.length > 0) addSolr(solrdoc, \"attr_scripts\", scripts);\n            }\n\n            // Frames\n            if (isEmpty() || contains(\"attr_frames\")) {\n                final Set<MultiProtocolURI> framess = html.getFrames();\n                final String[] frames = new String[framess.size()];\n                c = 0;\n                for (final MultiProtocolURI entry: framess) {\n                    frames[c++] = entry.toNormalform(false, false, false, false);\n                }\n                addSolr(solrdoc, \"framesscount_i\", frames.length);\n                if (frames.length > 0) addSolr(solrdoc, \"attr_frames\", frames);\n            }\n\n            // IFrames\n            if (isEmpty() || contains(\"attr_iframes\")) {\n                final Set<MultiProtocolURI> iframess = html.getIFrames();\n                final String[] iframes = new String[iframess.size()];\n                c = 0;\n                for (final MultiProtocolURI entry: iframess) {\n                    iframes[c++] = entry.toNormalform(false, false, false, false);\n                }\n                addSolr(solrdoc, \"iframesscount_i\", iframes.length);\n                if (iframes.length > 0) addSolr(solrdoc, \"attr_iframes\", iframes);\n            }\n\n            // flash embedded\n            addSolr(solrdoc, \"flash_b\", html.containsFlash());\n\n            // generic evaluation pattern\n            for (final String model: html.getEvaluationModelNames()) {\n                if (isEmpty() || contains(\"attr_\" + model)) {\n                    final String[] scorenames = html.getEvaluationModelScoreNames(model);\n                    if (scorenames.length > 0) {\n                        addSolr(solrdoc, \"attr_\" + model, scorenames);\n                        addSolr(solrdoc, \"attr_\" + model + \"count\", html.getEvaluationModelScoreCounts(model, scorenames));\n                    }\n                }\n            }\n\n            // response time\n            addSolr(solrdoc, \"responsetime_i\", header.get(HeaderFramework.RESPONSE_TIME_MILLIS, \"0\"));\n        }\n        return solrdoc;\n    }","id":88461,"modified_method":"public SolrInputDocument yacy2solr(final String id, final ResponseHeader header, final Document yacydoc) {\n        // we user the SolrCell design as index scheme\n        final SolrInputDocument solrdoc = new SolrInputDocument();\n        final DigestURI digestURI = new DigestURI(yacydoc.dc_source());\n        addSolr(solrdoc, \"failreason_t\", \"\"); // overwrite a possible fail reason (in case that there was a fail reason before)\n        addSolr(solrdoc, \"id\", id);\n        addSolr(solrdoc, \"sku\", digestURI.toNormalform(true, false), 3.0f);\n        final InetAddress address = Domains.dnsResolve(digestURI.getHost());\n        if (address != null) addSolr(solrdoc, \"ip_s\", address.getHostAddress());\n        if (digestURI.getHost() != null) addSolr(solrdoc, \"host_s\", digestURI.getHost());\n        addSolr(solrdoc, \"title\", yacydoc.dc_title());\n        addSolr(solrdoc, \"author\", yacydoc.dc_creator());\n        addSolr(solrdoc, \"description\", yacydoc.dc_description());\n        addSolr(solrdoc, \"content_type\", yacydoc.dc_format());\n        addSolr(solrdoc, \"last_modified\", header.lastModified());\n        addSolr(solrdoc, \"keywords\", yacydoc.dc_subject(' '));\n        final String content = UTF8.String(yacydoc.getTextBytes());\n        addSolr(solrdoc, \"text_t\", content);\n        if (isEmpty() || contains(\"wordcount_i\")) {\n            final int contentwc = content.split(\" \").length;\n            addSolr(solrdoc, \"wordcount_i\", contentwc);\n        }\n\n        // path elements of link\n        final String path = digestURI.getPath();\n        if (path != null && (isEmpty() || contains(\"attr_paths\"))) {\n            final String[] paths = path.split(\"/\");\n            if (paths.length > 0) addSolr(solrdoc, \"attr_paths\", paths);\n        }\n\n        // list all links\n        final Map<MultiProtocolURI, Properties> alllinks = yacydoc.getAnchors();\n        int c = 0;\n        if (isEmpty() || contains(\"inboundlinkscount_i\")) addSolr(solrdoc, \"inboundlinkscount_i\", yacydoc.inboundLinkCount());\n        if (isEmpty() || contains(\"inboundlinksnoindexcount_i\")) addSolr(solrdoc, \"inboundlinksnoindexcount_i\", yacydoc.inboundLinkNoindexCount());\n        if (isEmpty() || contains(\"attr_inboundlinks\")) {\n            final String[] inboundlinksTag = new String[yacydoc.inboundLinkCount()];\n            final String[] inboundlinksURLProtocol = new String[yacydoc.inboundLinkCount()];\n            final String[] inboundlinksURLStub = new String[yacydoc.inboundLinkCount()];\n            final String[] inboundlinksName = new String[yacydoc.inboundLinkCount()];\n            final String[] inboundlinksRel = new String[yacydoc.inboundLinkCount()];\n            final String[] inboundlinksText = new String[yacydoc.inboundLinkCount()];\n            for (final MultiProtocolURI url: yacydoc.inboundLinks()) {\n                final Properties p = alllinks.get(url);\n                final String name = p.getProperty(\"name\", \"\"); // the name attribute\n                final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\n                final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\n                final String urls = url.toNormalform(false, false);\n                final int pr = urls.indexOf(\"://\");\n                inboundlinksURLProtocol[c] = urls.substring(0, pr);\n                inboundlinksURLStub[c] = urls.substring(pr + 3);\n                inboundlinksName[c] = name.length() > 0 ? name : \"\";\n                inboundlinksRel[c] = rel.length() > 0 ? rel : \"\";\n                inboundlinksText[c] = text.length() > 0 ? rel : \"\";\n                inboundlinksTag[c] =\n                    \"<a href=\\\"\" + url.toNormalform(false, false) + \"\\\"\" +\n                    (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                    \">\" +\n                    ((name.length() > 0) ? name : \"\") + \"<\/a>\";\n                c++;\n            }\n            addSolr(solrdoc, \"attr_inboundlinks_tag\", inboundlinksTag);\n            addSolr(solrdoc, \"attr_inboundlinks_protocol\", inboundlinksURLProtocol);\n            addSolr(solrdoc, \"attr_inboundlinks_urlstub\", inboundlinksURLStub);\n            addSolr(solrdoc, \"attr_inboundlinks_name\", inboundlinksName);\n            addSolr(solrdoc, \"attr_inboundlinks_rel\", inboundlinksRel);\n            addSolr(solrdoc, \"attr_inboundlinks_text\", inboundlinksText);\n        }\n\n        c = 0;\n        if (isEmpty() || contains(\"outboundlinkscount_i\")) addSolr(solrdoc, \"outboundlinkscount_i\", yacydoc.outboundLinkCount());\n        if (isEmpty() || contains(\"outboundlinksnoindexcount_i\")) addSolr(solrdoc, \"outboundlinksnoindexcount_i\", yacydoc.outboundLinkNoindexCount());\n        if (isEmpty() || contains(\"attr_outboundlinks\")) {\n            final String[] outboundlinksTag = new String[yacydoc.outboundLinkCount()];\n            final String[] outboundlinksURLProtocol = new String[yacydoc.outboundLinkCount()];\n            final String[] outboundlinksURLStub = new String[yacydoc.outboundLinkCount()];\n            final String[] outboundlinksName = new String[yacydoc.outboundLinkCount()];\n            final String[] outboundlinksRel = new String[yacydoc.outboundLinkCount()];\n            final String[] outboundlinksText = new String[yacydoc.outboundLinkCount()];\n            for (final MultiProtocolURI url: yacydoc.outboundLinks()) {\n                final Properties p = alllinks.get(url);\n                final String name = p.getProperty(\"name\", \"\"); // the name attribute\n                final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\n                final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\n                final String urls = url.toNormalform(false, false);\n                final int pr = urls.indexOf(\"://\");\n                outboundlinksURLProtocol[c] = urls.substring(0, pr);\n                outboundlinksURLStub[c] = urls.substring(pr + 3);\n                outboundlinksName[c] = name.length() > 0 ? name : \"\";\n                outboundlinksRel[c] = rel.length() > 0 ? rel : \"\";\n                outboundlinksText[c] = text.length() > 0 ? rel : \"\";\n                outboundlinksTag[c] =\n                    \"<a href=\\\"\" + url.toNormalform(false, false) + \"\\\"\" +\n                    (rel.length() > 0 ? \" rel=\\\"\" + rel + \"\\\"\" : \"\") +\n                    \">\" +\n                    ((name.length() > 0) ? name : \"\") + \"<\/a>\";\n                c++;\n            }\n            addSolr(solrdoc, \"attr_outboundlinks_tag\", outboundlinksTag);\n            addSolr(solrdoc, \"attr_outboundlinks_protocol\", outboundlinksURLProtocol);\n            addSolr(solrdoc, \"attr_outboundlinks_urlstub\", outboundlinksURLStub);\n            addSolr(solrdoc, \"attr_outboundlinks_name\", outboundlinksName);\n            addSolr(solrdoc, \"attr_outboundlinks_rel\", outboundlinksRel);\n            addSolr(solrdoc, \"attr_outboundlinks_text\", outboundlinksText);\n        }\n\n        // charset\n        addSolr(solrdoc, \"charset_s\", yacydoc.getCharset());\n\n        // coordinates\n        if (yacydoc.lat() != 0.0f && yacydoc.lon() != 0.0f) {\n            addSolr(solrdoc, \"lon_coordinate\", yacydoc.lon());\n            addSolr(solrdoc, \"lat_coordinate\", yacydoc.lat());\n        }\n        addSolr(solrdoc, \"httpstatus_i\", 200);\n        final Object parser = yacydoc.getParserObject();\n        if (parser instanceof ContentScraper) {\n            final ContentScraper html = (ContentScraper) parser;\n\n            // header tags\n            int h = 0;\n            int f = 1;\n            for (int i = 1; i <= 6; i++) {\n                final String[] hs = html.getHeadlines(i);\n                h = h | (hs.length > 0 ? f : 0);\n                f = f * 2;\n                addSolr(solrdoc, \"attr_h\" + i, hs);\n            }\n            addSolr(solrdoc, \"htags_i\", h);\n\n            // canonical tag\n            if (html.getCanonical() != null) addSolr(solrdoc, \"canonical_s\", html.getCanonical().toNormalform(false, false));\n\n            // meta tags\n            final Map<String, String> metas = html.getMetas();\n            final String robots = metas.get(\"robots\");\n            if (robots != null) addSolr(solrdoc, \"metarobots_t\", robots);\n            final String generator = metas.get(\"generator\");\n            if (generator != null) addSolr(solrdoc, \"metagenerator_t\", generator);\n\n            // bold, italic\n            final String[] bold = html.getBold();\n            addSolr(solrdoc, \"boldcount_i\", bold.length);\n            if (bold.length > 0) {\n                addSolr(solrdoc, \"attr_bold\", bold);\n                if (isEmpty() || contains(\"attr_boldcount\")) {\n                    addSolr(solrdoc, \"attr_boldcount\", html.getBoldCount(bold));\n                }\n            }\n            final String[] italic = html.getItalic();\n            addSolr(solrdoc, \"italiccount_i\", italic.length);\n            if (italic.length > 0) {\n                addSolr(solrdoc, \"attr_italic\", italic);\n                if (isEmpty() || contains(\"attr_italiccount\")) {\n                    addSolr(solrdoc, \"attr_italiccount\", html.getItalicCount(italic));\n                }\n            }\n            final String[] li = html.getLi();\n            addSolr(solrdoc, \"licount_i\", li.length);\n            if (li.length > 0) addSolr(solrdoc, \"attr_li\", li);\n\n            // images\n            if (isEmpty() || contains(\"attr_images\")) {\n                final Collection<ImageEntry> imagesc = html.getImages().values();\n                final String[] images = new String[imagesc.size()];\n                c = 0;\n                for (final ImageEntry ie: imagesc) images[c++] = ie.toString();\n                addSolr(solrdoc, \"imagescount_i\", images.length);\n                if (images.length > 0) addSolr(solrdoc, \"attr_images\", images);\n            }\n\n            // style sheets\n            if (isEmpty() || contains(\"attr_css\")) {\n                final Map<MultiProtocolURI, String> csss = html.getCSS();\n                final String[] css = new String[csss.size()];\n                c = 0;\n                for (final Map.Entry<MultiProtocolURI, String> entry: csss.entrySet()) {\n                    css[c++] =\n                        \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" media=\\\"\" + entry.getValue() + \"\\\"\" +\n                        \" href=\\\"\"+ entry.getKey().toNormalform(false, false, false, false) + \"\\\" />\";\n                }\n                addSolr(solrdoc, \"csscount_i\", css.length);\n                if (css.length > 0) addSolr(solrdoc, \"attr_css\", css);\n            }\n\n            // Scripts\n            if (isEmpty() || contains(\"attr_scripts\")) {\n                final Set<MultiProtocolURI> scriptss = html.getScript();\n                final String[] scripts = new String[scriptss.size()];\n                c = 0;\n                for (final MultiProtocolURI url: scriptss) {\n                    scripts[c++] = url.toNormalform(false, false, false, false);\n                }\n                addSolr(solrdoc, \"scriptscount_i\", scripts.length);\n                if (scripts.length > 0) addSolr(solrdoc, \"attr_scripts\", scripts);\n            }\n\n            // Frames\n            if (isEmpty() || contains(\"attr_frames\")) {\n                final Set<MultiProtocolURI> framess = html.getFrames();\n                final String[] frames = new String[framess.size()];\n                c = 0;\n                for (final MultiProtocolURI entry: framess) {\n                    frames[c++] = entry.toNormalform(false, false, false, false);\n                }\n                addSolr(solrdoc, \"framesscount_i\", frames.length);\n                if (frames.length > 0) addSolr(solrdoc, \"attr_frames\", frames);\n            }\n\n            // IFrames\n            if (isEmpty() || contains(\"attr_iframes\")) {\n                final Set<MultiProtocolURI> iframess = html.getIFrames();\n                final String[] iframes = new String[iframess.size()];\n                c = 0;\n                for (final MultiProtocolURI entry: iframess) {\n                    iframes[c++] = entry.toNormalform(false, false, false, false);\n                }\n                addSolr(solrdoc, \"iframesscount_i\", iframes.length);\n                if (iframes.length > 0) addSolr(solrdoc, \"attr_iframes\", iframes);\n            }\n\n            // flash embedded\n            addSolr(solrdoc, \"flash_b\", html.containsFlash());\n\n            // generic evaluation pattern\n            for (final String model: html.getEvaluationModelNames()) {\n                if (isEmpty() || contains(\"attr_\" + model)) {\n                    final String[] scorenames = html.getEvaluationModelScoreNames(model);\n                    if (scorenames.length > 0) {\n                        addSolr(solrdoc, \"attr_\" + model, scorenames);\n                        addSolr(solrdoc, \"attr_\" + model + \"count\", html.getEvaluationModelScoreCounts(model, scorenames));\n                    }\n                }\n            }\n\n            // response time\n            addSolr(solrdoc, \"responsetime_i\", header.get(HeaderFramework.RESPONSE_TIME_MILLIS, \"0\"));\n        }\n        return solrdoc;\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void addSolr(final Collection<SolrInputDocument> docs) throws IOException, SolrException {\n        try {\n            this.server.add(docs);\n            this.server.commit();\n            /* To immediately commit after adding documents, you could use:\n                  UpdateRequest req = new UpdateRequest();\n                  req.setAction( UpdateRequest.ACTION.COMMIT, false, false );\n                  req.add( docs );\n                  UpdateResponse rsp = req.process( server );\n             */\n        } catch (final SolrServerException e) {\n            throw new IOException(e);\n        }\n    }","id":88462,"modified_method":"protected void addSolr(final Collection<SolrInputDocument> docs) throws IOException, SolrException {\n\n        try {\n            if (docs.size() != 0) this.server.add(docs);\n            this.server.commit();\n            /* To immediately commit after adding documents, you could use:\n                  UpdateRequest req = new UpdateRequest();\n                  req.setAction( UpdateRequest.ACTION.COMMIT, false, false );\n                  req.add( docs );\n                  UpdateResponse rsp = req.process( server );\n             */\n        } catch (final SolrServerException e) {\n            throw new IOException(e);\n        }\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private char[] filterTag(final String tag, final boolean opening, final char[] content, final char quotechar) {\r\n//      System.out.println(\"FILTER1: filterTag=\" + ((filterTag == null) ? \"null\" : filterTag) + \", tag=\" + tag + \", opening=\" + ((opening) ? \"true\" : \"false\") + \", content=\" + UTF8.String(content)); // debug\r\n        if (this.filterTag == null) {\r\n            // we are not collection tag text\r\n            if (tag == null) {\r\n                // and this is not a tag opener/closer\r\n                if (this.scraper != null) this.scraper.scrapeText(content, null);\r\n                if (this.transformer != null) return this.transformer.transformText(content);\r\n                return content;\r\n            }\r\n\r\n            // we have a new tag\r\n            if (opening) {\r\n                if ((this.scraper != null) && (this.scraper.isTag0(tag))) {\r\n                    // this single tag is collected at once here\r\n                \tfinal CharBuffer charBuffer = new CharBuffer(content);\r\n                    this.scraper.scrapeTag0(tag, charBuffer.propParser());\r\n                    try {\r\n\t\t\t\t\t\tcharBuffer.close();\r\n\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t}\r\n                }\r\n                if ((this.transformer != null) && (this.transformer.isTag0(tag))) {\r\n                    // this single tag is collected at once here\r\n                \tfinal CharBuffer scb = new CharBuffer(content);\r\n                \ttry {\r\n                \t\treturn this.transformer.transformTag0(tag, scb.propParser(), quotechar);\r\n                \t} finally {\r\n                \t\ttry {\r\n\t\t\t\t\t\t\tscb.close();\r\n\t\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t\t}\r\n                \t}\r\n                } else if (((this.scraper != null) && (this.scraper.isTag1(tag))) ||\r\n                           ((this.transformer != null) && (this.transformer.isTag1(tag)))) {\r\n                    // ok, start collecting\r\n                    this.filterTag = tag;\r\n                    final CharBuffer scb = new CharBuffer(content);\r\n                    this.filterOpts = scb.propParser();\r\n                    try {\r\n\t\t\t\t\t\tscb.close();\r\n\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t}\r\n                    if (this.filterCont == null) this.filterCont = new CharBuffer(Math.max(100, content.length)); else this.filterCont.reset();\r\n                    return new char[0];\r\n                } else {\r\n                     // we ignore that thing and return it again\r\n                     return genTag0raw(tag, true, content);\r\n                }\r\n            }\r\n\r\n            // we ignore that thing and return it again\r\n            return genTag0raw(tag, false, content);\r\n\r\n        }\r\n\r\n        // we are collection tag text for the tag 'filterTag'\r\n        if (tag == null) {\r\n            // go on collecting content\r\n            if (this.scraper != null) this.scraper.scrapeText(content, this.filterTag);\r\n            try {\r\n                if (this.transformer != null) {\r\n                    this.filterCont.append(this.transformer.transformText(content));\r\n                } else {\r\n                    this.filterCont.append(content);\r\n                }\r\n            } catch (final OutOfMemoryError e) {}\r\n            return new char[0];\r\n        }\r\n\r\n        // it's a tag! which one?\r\n        if ((opening) || (!(tag.equalsIgnoreCase(this.filterTag)))) {\r\n            // this tag is not our concern. just add it\r\n            this.filterCont.append(genTag0raw(tag, opening, content));\r\n            return new char[0];\r\n        }\r\n\r\n        // it's our closing tag! return complete result.\r\n        char[] ret;\r\n        if (this.scraper != null) this.scraper.scrapeTag1(this.filterTag, this.filterOpts, this.filterCont.getChars());\r\n        if (this.transformer != null) {\r\n            ret = this.transformer.transformTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n        } else {\r\n            ret = genTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n        }\r\n        this.filterTag = null;\r\n        this.filterOpts = null;\r\n        this.filterCont = null;\r\n        return ret;\r\n    }","id":88463,"modified_method":"/**\r\n     * every tag that appears is handed to the filterTag method. The method then returns text from the tag\r\n     * but also operates on the tag content to scrape information from it. In case that a tag is unclosed if\r\n     * another tag appears, both, the unclosed and the new one are merged into one new char[]\r\n     * @param tag\r\n     * @param opening\r\n     * @param content\r\n     * @param quotechar\r\n     * @return\r\n     */\r\n    private char[] filterTag(final String tag, final boolean opening, final char[] content, final char quotechar) {\r\n        //System.out.println(\"FILTER1: filterTag=\" + ((this.filterTag == null) ? \"null\" : this.filterTag) + \", tag=\" + tag + \", opening=\" + ((opening) ? \"true\" : \"false\") + \", content=\" + new String(content)); // debug\r\n        char[] unclosed = null;\r\n\r\n        if (this.filterTag != null && opening) {\r\n            // there is a missing close tag for the currently parsed tag filterTag\r\n            // close that tag here and go on with new tag\r\n            if (this.scraper != null) {\r\n                this.scraper.scrapeTag1(this.filterTag, this.filterOpts, this.filterCont.getChars());\r\n            }\r\n            if (this.transformer != null) {\r\n                unclosed = this.transformer.transformTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n            } else {\r\n                unclosed = genTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n            }\r\n            this.filterTag = null;\r\n            this.filterOpts = null;\r\n            this.filterCont = null;\r\n        }\r\n\r\n        if (this.filterTag == null) {\r\n            // we are not collection tag text\r\n            if (tag == null) {\r\n                // and this is not a tag opener/closer\r\n                if (this.scraper != null) this.scraper.scrapeText(content, null);\r\n                if (this.transformer != null) return mergedScrape(unclosed, this.transformer.transformText(content));\r\n                return mergedScrape(unclosed, content);\r\n            }\r\n\r\n            // we have a new tag\r\n            if (opening) {\r\n                if ((this.scraper != null) && (this.scraper.isTag0(tag))) {\r\n                    // this single tag is collected at once here\r\n                \tfinal CharBuffer charBuffer = new CharBuffer(content);\r\n                    this.scraper.scrapeTag0(tag, charBuffer.propParser());\r\n                    try {\r\n\t\t\t\t\t\tcharBuffer.close();\r\n\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t}\r\n                }\r\n                if ((this.transformer != null) && (this.transformer.isTag0(tag))) {\r\n                    // this single tag is collected at once here\r\n                \tfinal CharBuffer scb = new CharBuffer(content);\r\n                \ttry {\r\n                \t\treturn mergedScrape(unclosed, this.transformer.transformTag0(tag, scb.propParser(), quotechar));\r\n                \t} finally {\r\n                \t\ttry {\r\n\t\t\t\t\t\t\tscb.close();\r\n\t\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t\t}\r\n                \t}\r\n                } else if (((this.scraper != null) && (this.scraper.isTag1(tag))) ||\r\n                           ((this.transformer != null) && (this.transformer.isTag1(tag)))) {\r\n                    // ok, start collecting\r\n                    this.filterTag = tag;\r\n                    final CharBuffer scb = new CharBuffer(content);\r\n                    this.filterOpts = scb.propParser();\r\n                    try {\r\n\t\t\t\t\t\tscb.close();\r\n\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t}\r\n                    if (this.filterCont == null) this.filterCont = new CharBuffer(Math.max(100, content.length)); else this.filterCont.reset();\r\n                    return mergedScrape(unclosed, new char[0]);\r\n                } else {\r\n                     // we ignore that thing and return it again\r\n                     return mergedScrape(unclosed, genTag0raw(tag, true, content));\r\n                }\r\n            }\r\n\r\n            // we ignore that thing and return it again\r\n            return mergedScrape(unclosed, genTag0raw(tag, false, content));\r\n\r\n        }\r\n\r\n        // we are collection tag text for the tag 'filterTag'\r\n        if (tag == null) {\r\n            // go on collecting content\r\n            if (this.scraper != null) this.scraper.scrapeText(content, this.filterTag);\r\n            try {\r\n                if (this.transformer != null) {\r\n                    this.filterCont.append(this.transformer.transformText(content));\r\n                } else {\r\n                    this.filterCont.append(content);\r\n                }\r\n            } catch (final OutOfMemoryError e) {}\r\n            return mergedScrape(unclosed, new char[0]);\r\n        }\r\n\r\n        // it's a tag! which one?\r\n        if (opening || !(tag.equalsIgnoreCase(this.filterTag))) {\r\n            // this tag is not our concern. just add it\r\n            this.filterCont.append(genTag0raw(tag, opening, content));\r\n            return mergedScrape(unclosed, new char[0]);\r\n        }\r\n\r\n        // it's our closing tag! return complete result.\r\n        char[] ret;\r\n        if (this.scraper != null) this.scraper.scrapeTag1(this.filterTag, this.filterOpts, this.filterCont.getChars());\r\n        if (this.transformer != null) {\r\n            ret = this.transformer.transformTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n        } else {\r\n            ret = genTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n        }\r\n        this.filterTag = null;\r\n        this.filterOpts = null;\r\n        this.filterCont = null;\r\n        return mergedScrape(unclosed, ret);\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard)env;\r\n\r\n        if (post == null) {\r\n            prop.put(\"display\", 1);\r\n            prop.put(\"error_display\", 0);\r\n            prop.putHTML(\"error_words\", \"\");\r\n            prop.put(\"error_vMode-sentences\", \"1\");\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"url\", \"\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        final int display = post.getInt(\"display\", 1);\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        final boolean authorized = sb.verifyAuthentication(header, false);\r\n        if (post != null && post.containsKey(\"segment\") && authorized) {\r\n            indexSegment = sb.indexSegments.segment(post.get(\"segment\"));\r\n        } else {\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n\r\n        prop.put(\"display\", display);\r\n        prop.put(\"error_display\", display);\r\n\r\n        if (post.containsKey(\"words\"))\r\n            prop.putHTML(\"error_words\", post.get(\"words\"));\r\n        else {\r\n            prop.putHTML(\"error_words\", \"\");\r\n        }\r\n\r\n        final String viewMode = post.get(\"viewMode\",\"parsed\");\r\n        prop.put(\"error_vMode-\" + viewMode, \"1\");\r\n\r\n        DigestURI url = null;\r\n        String descr = \"\";\r\n        final int wordCount = 0;\r\n        int size = 0;\r\n        boolean pre = false;\r\n\r\n        // get the url hash from which the content should be loaded\r\n        String urlHash = post.get(\"urlHash\", \"\");\r\n        URIMetadataRow urlEntry = null;\r\n        // get the urlEntry that belongs to the url hash\r\n        if (urlHash.length() > 0 && (urlEntry = indexSegment.urlMetadata().load(ASCII.getBytes(urlHash))) != null) {\r\n            // get the url that belongs to the entry\r\n            final URIMetadataRow.Components metadata = urlEntry.metadata();\r\n            if ((metadata == null) || (metadata.url() == null)) {\r\n                prop.put(\"error\", \"3\");\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n            url = metadata.url();\r\n            descr = metadata.dc_title();\r\n            //urlEntry.wordCount();\r\n            size = urlEntry.size();\r\n            pre = urlEntry.flags().get(Condenser.flag_cat_indexof);\r\n        }\r\n\r\n        prop.put(\"error_inurldb\", urlEntry == null ? 0 : 1);\r\n\r\n        // alternatively, get the url simply from a url String\r\n        // this can be used as a simple tool to test the text parser\r\n        final String urlString = post.get(\"url\", \"\");\r\n        if (urlString.length() > 0) try {\r\n            // this call forces the peer to download  web pages\r\n            // it is therefore protected by the admin password\r\n\r\n            if (!sb.verifyAuthentication(header, false)) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n\r\n            // define an url by post parameter\r\n            url = new DigestURI(MultiProtocolURI.unescape(urlString));\r\n            urlHash = ASCII.String(url.hash());\r\n            pre = post.getBoolean(\"pre\", false);\r\n        } catch (final MalformedURLException e) {}\r\n\r\n\r\n        if (url == null) {\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            prop.put(\"url\", \"\");\r\n            return prop;\r\n        } else {\r\n            prop.put(\"url\", url.toNormalform(false, true));\r\n        }\r\n\r\n        // loading the resource content as byte array\r\n        prop.put(\"error_incache\", Cache.has(url) ? 1 : 0);\r\n\r\n        Response response = null;\r\n        try {\r\n            response = sb.loader.load(sb.loader.request(url, true, false), authorized ? CacheStrategy.IFEXIST : CacheStrategy.CACHEONLY, Integer.MAX_VALUE, true);\r\n        } catch (final IOException e) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"error loading resource: \" + e.getMessage());\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        if (response == null) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"No resource available\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        final String[] wordArray = wordArray(post.get(\"words\", null));\r\n\r\n        if (viewMode.equals(\"plain\")) {\r\n\r\n            // TODO: how to handle very large files here ?\r\n            String content;\r\n            try {\r\n                content = UTF8.String(response.getContent());\r\n            } catch (final Exception e) {\r\n                prop.put(\"error\", \"4\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            prop.put(\"error\", \"0\");\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_PLAIN_TEXT);\r\n            prop.put(\"viewMode_plainText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n        } else if (viewMode.equals(\"iframeWeb\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_WEB);\r\n            prop.put(\"viewMode_url\", url.toNormalform(false, true));\r\n\r\n        } else if (viewMode.equals(\"iframeCache\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_CACHE);\r\n            final String ext = url.getFileExtension();\r\n            if (\"jpg.jpeg.png.gif\".indexOf(ext) >= 0) {\r\n                prop.put(\"viewMode_png\", 1);\r\n                prop.put(\"viewMode_png_url\", url.toNormalform(false, true));\r\n            } else {\r\n                prop.put(\"viewMode_html\", 1);\r\n                prop.put(\"viewMode_html_url\", url.toNormalform(false, true));\r\n            }\r\n        } else if (viewMode.equals(\"parsed\") || viewMode.equals(\"sentences\")  || viewMode.equals(\"words\") || viewMode.equals(\"links\")) {\r\n            // parsing the resource content\r\n            Document document = null;\r\n            try {\r\n                document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n                if (document == null) {\r\n                    prop.put(\"error\", \"5\");\r\n                    prop.put(\"error_errorText\", \"Unknown error\");\r\n                    prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                    return prop;\r\n                }\r\n            } catch (final Parser.Failure e) {\r\n                prop.put(\"error\", \"5\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            if (viewMode.equals(\"parsed\")) {\r\n                final String content = UTF8.String(document.getTextBytes());\r\n                // content = wikiCode.replaceHTML(content); // added by Marc Nause\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_TEXT);\r\n                prop.put(\"viewMode_title\", document.dc_title());\r\n                prop.put(\"viewMode_creator\", document.dc_creator());\r\n                prop.put(\"viewMode_subject\", document.dc_subject(','));\r\n                prop.put(\"viewMode_description\", document.dc_description());\r\n                prop.put(\"viewMode_publisher\", document.dc_publisher());\r\n                prop.put(\"viewMode_format\", document.dc_format());\r\n                prop.put(\"viewMode_identifier\", document.dc_identifier());\r\n                prop.put(\"viewMode_source\", url.toString());\r\n                prop.put(\"viewMode_lat\", document.lat());\r\n                prop.put(\"viewMode_lon\", document.lon());\r\n                prop.put(\"viewMode_parsedText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n            } else if (viewMode.equals(\"sentences\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_SENTENCES);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        if (sentence.trim().length() > 0) {\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_nr\", i + 1);\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_text\", markup(wordArray, sentence));\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                            dark = !dark;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_sentences\", i);\r\n\r\n            } else if (viewMode.equals(\"words\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_WORDS);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence, token;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        Enumeration<String> tokens = null;\r\n                        tokens = new WordTokenizer(new ByteArrayInputStream(UTF8.getBytes(sentence)), LibraryProvider.dymLib);\r\n                        while (tokens.hasMoreElements()) {\r\n                            token = tokens.nextElement();\r\n                            if (token.length() > 0) {\r\n                                prop.put(\"viewMode_words_\" + i + \"_nr\", i + 1);\r\n                                prop.put(\"viewMode_words_\" + i + \"_word\", token);\r\n                                prop.put(\"viewMode_words_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                                dark = !dark;\r\n                                i++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_words\", i);\r\n\r\n            } else if (viewMode.equals(\"links\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_LINKLIST);\r\n                boolean dark = true;\r\n                int i = 0;\r\n                i += putMediaInfo(prop, wordArray, i, document.getVideolinks(), \"video\", (i % 2 == 0));\r\n                i += putMediaInfo(prop, wordArray, i, document.getAudiolinks(), \"audio\", (i % 2 == 0));\r\n                dark = (i % 2 == 0);\r\n\r\n                final Map<MultiProtocolURI, ImageEntry> ts = document.getImages();\r\n                final Iterator<ImageEntry> tsi = ts.values().iterator();\r\n                ImageEntry entry;\r\n                while (tsi.hasNext()) {\r\n                    entry = tsi.next();\r\n                    prop.put(\"viewMode_links_\" + i + \"_nr\", i);\r\n                    prop.put(\"viewMode_links_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_type\", \"image\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_text\", (entry.alt().isEmpty()) ? \"&nbsp;\" : markup(wordArray, entry.alt()));\r\n                    prop.put(\"viewMode_links_\" + i + \"_url\", entry.url().toNormalform(false, true));\r\n                    prop.put(\"viewMode_links_\" + i + \"_link\", markup(wordArray, entry.url().toNormalform(false, true)));\r\n                    if (entry.width() > 0 && entry.height() > 0)\r\n                        prop.put(\"viewMode_links_\" + i + \"_attr\", entry.width() + \"x\" + entry.height() + \" Pixel\");\r\n                    else\r\n                        prop.put(\"viewMode_links_\" + i + \"_attr\", \"unknown\");\r\n                    dark = !dark;\r\n                    i++;\r\n                }\r\n                i += putMediaInfo(prop, wordArray, i, document.getApplinks(), \"app\", (i % 2 == 0));\r\n                i += putMediaInfo(prop, wordArray, i, document.getHyperlinks(), \"link\", (i % 2 == 0));\r\n                prop.put(\"viewMode_links\", i);\r\n\r\n            }\r\n            if (document != null) document.close();\r\n        }\r\n        prop.put(\"error\", \"0\");\r\n        prop.put(\"error_url\", url.toNormalform(false, true));\r\n        prop.put(\"error_hash\", urlHash);\r\n        prop.put(\"error_wordCount\", wordCount);\r\n        prop.putHTML(\"error_desc\", (descr.isEmpty()) ? \"&nbsp;\" : descr);\r\n        prop.putNum(\"error_size\", size);\r\n        prop.put(\"error_mimeTypeAvailable\", (response.getMimeType() == null) ? \"0\" : \"1\");\r\n        prop.put(\"error_mimeTypeAvailable_mimeType\", response.getMimeType());\r\n        return prop;\r\n    }","id":88464,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard)env;\r\n\r\n        if (post == null) {\r\n            prop.put(\"display\", 1);\r\n            prop.put(\"error_display\", 0);\r\n            prop.putHTML(\"error_words\", \"\");\r\n            prop.put(\"error_vMode-sentences\", \"1\");\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"url\", \"\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        final int display = post.getInt(\"display\", 1);\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        final boolean authorized = sb.verifyAuthentication(header, false);\r\n        if (post != null && post.containsKey(\"segment\") && authorized) {\r\n            indexSegment = sb.indexSegments.segment(post.get(\"segment\"));\r\n        } else {\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n\r\n        prop.put(\"display\", display);\r\n        prop.put(\"error_display\", display);\r\n\r\n        if (post.containsKey(\"words\"))\r\n            prop.putHTML(\"error_words\", post.get(\"words\"));\r\n        else {\r\n            prop.putHTML(\"error_words\", \"\");\r\n        }\r\n\r\n        final String viewMode = post.get(\"viewMode\",\"parsed\");\r\n        prop.put(\"error_vMode-\" + viewMode, \"1\");\r\n\r\n        DigestURI url = null;\r\n        String descr = \"\";\r\n        final int wordCount = 0;\r\n        int size = 0;\r\n        boolean pre = false;\r\n\r\n        // get the url hash from which the content should be loaded\r\n        String urlHash = post.get(\"urlHash\", \"\");\r\n        URIMetadataRow urlEntry = null;\r\n        // get the urlEntry that belongs to the url hash\r\n        if (urlHash.length() > 0 && (urlEntry = indexSegment.urlMetadata().load(ASCII.getBytes(urlHash))) != null) {\r\n            // get the url that belongs to the entry\r\n            final URIMetadataRow.Components metadata = urlEntry.metadata();\r\n            if ((metadata == null) || (metadata.url() == null)) {\r\n                prop.put(\"error\", \"3\");\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n            url = metadata.url();\r\n            descr = metadata.dc_title();\r\n            //urlEntry.wordCount();\r\n            size = urlEntry.size();\r\n            pre = urlEntry.flags().get(Condenser.flag_cat_indexof);\r\n        }\r\n\r\n        prop.put(\"error_inurldb\", urlEntry == null ? 0 : 1);\r\n\r\n        // alternatively, get the url simply from a url String\r\n        // this can be used as a simple tool to test the text parser\r\n        final String urlString = post.get(\"url\", \"\");\r\n        if (urlString.length() > 0) try {\r\n            // this call forces the peer to download  web pages\r\n            // it is therefore protected by the admin password\r\n\r\n            if (!sb.verifyAuthentication(header, false)) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n\r\n            // define an url by post parameter\r\n            url = new DigestURI(MultiProtocolURI.unescape(urlString));\r\n            urlHash = ASCII.String(url.hash());\r\n            pre = post.getBoolean(\"pre\", false);\r\n        } catch (final MalformedURLException e) {}\r\n\r\n\r\n        if (url == null) {\r\n            prop.put(\"error\", \"1\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            prop.put(\"url\", \"\");\r\n            return prop;\r\n        } else {\r\n            prop.put(\"url\", url.toNormalform(false, true));\r\n        }\r\n\r\n        // loading the resource content as byte array\r\n        prop.put(\"error_incache\", Cache.has(url) ? 1 : 0);\r\n\r\n        Response response = null;\r\n        try {\r\n            response = sb.loader.load(sb.loader.request(url, true, false), authorized ? CacheStrategy.IFEXIST : CacheStrategy.CACHEONLY, Integer.MAX_VALUE, true);\r\n        } catch (final IOException e) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"error loading resource: \" + e.getMessage());\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        if (response == null) {\r\n            prop.put(\"error\", \"4\");\r\n            prop.put(\"error_errorText\", \"No resource available\");\r\n            prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n            return prop;\r\n        }\r\n\r\n        final String[] wordArray = wordArray(post.get(\"words\", null));\r\n\r\n        if (viewMode.equals(\"plain\")) {\r\n\r\n            // TODO: how to handle very large files here ?\r\n            String content;\r\n            try {\r\n                content = UTF8.String(response.getContent());\r\n            } catch (final Exception e) {\r\n                prop.put(\"error\", \"4\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            prop.put(\"error\", \"0\");\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_PLAIN_TEXT);\r\n            prop.put(\"viewMode_plainText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n        } else if (viewMode.equals(\"iframeWeb\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_WEB);\r\n            prop.put(\"viewMode_url\", url.toNormalform(false, true));\r\n\r\n        } else if (viewMode.equals(\"iframeCache\")) {\r\n            prop.put(\"viewMode\", VIEW_MODE_AS_IFRAME_FROM_CACHE);\r\n            final String ext = url.getFileExtension();\r\n            if (\"jpg.jpeg.png.gif\".indexOf(ext) >= 0) {\r\n                prop.put(\"viewMode_png\", 1);\r\n                prop.put(\"viewMode_png_url\", url.toNormalform(false, true));\r\n            } else {\r\n                prop.put(\"viewMode_html\", 1);\r\n                prop.put(\"viewMode_html_url\", url.toNormalform(false, true));\r\n            }\r\n        } else if (viewMode.equals(\"parsed\") || viewMode.equals(\"sentences\")  || viewMode.equals(\"words\") || viewMode.equals(\"links\")) {\r\n            // parsing the resource content\r\n            Document document = null;\r\n            try {\r\n                document = Document.mergeDocuments(response.url(), response.getMimeType(), response.parse());\r\n                if (document == null) {\r\n                    prop.put(\"error\", \"5\");\r\n                    prop.put(\"error_errorText\", \"Unknown error\");\r\n                    prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                    return prop;\r\n                }\r\n            } catch (final Parser.Failure e) {\r\n                prop.put(\"error\", \"5\");\r\n                prop.putHTML(\"error_errorText\", e.getMessage());\r\n                prop.put(\"viewMode\", VIEW_MODE_NO_TEXT);\r\n                return prop;\r\n            }\r\n\r\n            if (viewMode.equals(\"parsed\")) {\r\n                final String content = UTF8.String(document.getTextBytes());\r\n                // content = wikiCode.replaceHTML(content); // added by Marc Nause\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_TEXT);\r\n                prop.put(\"viewMode_title\", document.dc_title());\r\n                prop.put(\"viewMode_creator\", document.dc_creator());\r\n                prop.put(\"viewMode_subject\", document.dc_subject(','));\r\n                prop.put(\"viewMode_description\", document.dc_description());\r\n                prop.put(\"viewMode_publisher\", document.dc_publisher());\r\n                prop.put(\"viewMode_format\", document.dc_format());\r\n                prop.put(\"viewMode_identifier\", document.dc_identifier());\r\n                prop.put(\"viewMode_source\", url.toString());\r\n                prop.put(\"viewMode_lat\", document.lat());\r\n                prop.put(\"viewMode_lon\", document.lon());\r\n                prop.put(\"viewMode_parsedText\", markup(wordArray, content).replaceAll(\"\\n\", \"<br />\").replaceAll(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\"));\r\n\r\n            } else if (viewMode.equals(\"sentences\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_SENTENCES);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        if (sentence.trim().length() > 0) {\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_nr\", i + 1);\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_text\", markup(wordArray, sentence));\r\n                            prop.put(\"viewMode_sentences_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                            dark = !dark;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_sentences\", i);\r\n\r\n            } else if (viewMode.equals(\"words\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_PARSED_WORDS);\r\n                final Collection<StringBuilder> sentences = document.getSentences(pre);\r\n\r\n                boolean dark = true;\r\n                int i = 0;\r\n                String sentence, token;\r\n                if (sentences != null) {\r\n\r\n                    // Search word highlighting\r\n                    for (final StringBuilder s: sentences) {\r\n                        sentence = s.toString();\r\n                        Enumeration<String> tokens = null;\r\n                        tokens = new WordTokenizer(new ByteArrayInputStream(UTF8.getBytes(sentence)), LibraryProvider.dymLib);\r\n                        while (tokens.hasMoreElements()) {\r\n                            token = tokens.nextElement();\r\n                            if (token.length() > 0) {\r\n                                prop.put(\"viewMode_words_\" + i + \"_nr\", i + 1);\r\n                                prop.put(\"viewMode_words_\" + i + \"_word\", token);\r\n                                prop.put(\"viewMode_words_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                                dark = !dark;\r\n                                i++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                prop.put(\"viewMode_words\", i);\r\n\r\n            } else if (viewMode.equals(\"links\")) {\r\n                prop.put(\"viewMode\", VIEW_MODE_AS_LINKLIST);\r\n                boolean dark = true;\r\n                int i = 0;\r\n                i += putMediaInfo(prop, wordArray, i, document.getVideolinks(), \"video\", (i % 2 == 0), document.getAnchors());\r\n                i += putMediaInfo(prop, wordArray, i, document.getAudiolinks(), \"audio\", (i % 2 == 0), document.getAnchors());\r\n                dark = (i % 2 == 0);\r\n\r\n                final Map<MultiProtocolURI, ImageEntry> ts = document.getImages();\r\n                final Iterator<ImageEntry> tsi = ts.values().iterator();\r\n                ImageEntry entry;\r\n                while (tsi.hasNext()) {\r\n                    entry = tsi.next();\r\n                    prop.put(\"viewMode_links_\" + i + \"_nr\", i);\r\n                    prop.put(\"viewMode_links_\" + i + \"_dark\", dark ? \"1\" : \"0\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_type\", \"image\");\r\n                    prop.put(\"viewMode_links_\" + i + \"_text\", (entry.alt().isEmpty()) ? \"&nbsp;\" : markup(wordArray, entry.alt()));\r\n                    prop.put(\"viewMode_links_\" + i + \"_url\", entry.url().toNormalform(false, true));\r\n                    prop.put(\"viewMode_links_\" + i + \"_link\", markup(wordArray, entry.url().toNormalform(false, true)));\r\n                    if (entry.width() > 0 && entry.height() > 0) {\r\n                        prop.put(\"viewMode_links_\" + i + \"_rel\", entry.width() + \"x\" + entry.height() + \" Pixel\");\r\n                    } else {\r\n                        prop.put(\"viewMode_links_\" + i + \"_rel\", \"\");\r\n                    }\r\n                    prop.put(\"viewMode_links_\" + i + \"_name\", \"\");\r\n                    dark = !dark;\r\n                    i++;\r\n                }\r\n                i += putMediaInfo(prop, wordArray, i, document.getApplinks(), \"app\", (i % 2 == 0), document.getAnchors());\r\n                i += putMediaInfo(prop, wordArray, i, document.getHyperlinks(), \"link\", (i % 2 == 0), document.getAnchors());\r\n                prop.put(\"viewMode_links\", i);\r\n\r\n            }\r\n            if (document != null) document.close();\r\n        }\r\n        prop.put(\"error\", \"0\");\r\n        prop.put(\"error_url\", url.toNormalform(false, true));\r\n        prop.put(\"error_hash\", urlHash);\r\n        prop.put(\"error_wordCount\", wordCount);\r\n        prop.putHTML(\"error_desc\", (descr.isEmpty()) ? \"&nbsp;\" : descr);\r\n        prop.putNum(\"error_size\", size);\r\n        prop.put(\"error_mimeTypeAvailable\", (response.getMimeType() == null) ? \"0\" : \"1\");\r\n        prop.put(\"error_mimeTypeAvailable_mimeType\", response.getMimeType());\r\n        return prop;\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static int putMediaInfo(final serverObjects prop, final String[] wordArray, int c, final Map<MultiProtocolURI, String> media, final String name, boolean dark) {\r\n        int i = 0;\r\n        for (final Map.Entry<MultiProtocolURI, String> entry : media.entrySet()) {\r\n            prop.put(\"viewMode_links_\" + c + \"_nr\", c);\r\n            prop.put(\"viewMode_links_\" + c + \"_dark\", ((dark) ? 1 : 0));\r\n            prop.putHTML(\"viewMode_links_\" + c + \"_type\", name);\r\n            prop.put(\"viewMode_links_\" + c + \"_text\", ((entry.getValue().isEmpty()) ? \"&nbsp;\" : markup(wordArray, entry.getValue()) ));\r\n            prop.put(\"viewMode_links_\" + c + \"_link\", markup(wordArray, entry.getKey().toNormalform(true, false)));\r\n            prop.put(\"viewMode_links_\" + c + \"_url\", entry.getKey().toNormalform(true, false));\r\n            prop.put(\"viewMode_links_\" + c + \"_attr\", \"&nbsp;\");\r\n            dark = !dark;\r\n            c++;\r\n            i++;\r\n        }\r\n        return i;\r\n    }","id":88465,"modified_method":"private static int putMediaInfo(\r\n                    final serverObjects prop,\r\n                    final String[] wordArray,\r\n                    int c,\r\n                    final Map<MultiProtocolURI, String> media,\r\n                    final String type,\r\n                    boolean dark,\r\n                    final Map<MultiProtocolURI, Properties> alllinks) {\r\n        int i = 0;\r\n        for (final Map.Entry<MultiProtocolURI, String> entry : media.entrySet()) {\r\n            final Properties p = alllinks.get(entry.getKey());\r\n            final String name = p.getProperty(\"name\", \"\"); // the name attribute\r\n            final String rel = p.getProperty(\"rel\", \"\");   // the rel-attribute\r\n            final String text = p.getProperty(\"text\", \"\"); // the text between the <a><\/a> tag\r\n\r\n            prop.put(\"viewMode_links_\" + c + \"_nr\", c);\r\n            prop.put(\"viewMode_links_\" + c + \"_dark\", ((dark) ? 1 : 0));\r\n            prop.putHTML(\"viewMode_links_\" + c + \"_type\", type);\r\n            prop.put(\"viewMode_links_\" + c + \"_text\", text + \"/\" + ((entry.getValue().isEmpty()) ? \"&nbsp;\" : markup(wordArray, entry.getValue()) ));\r\n            prop.put(\"viewMode_links_\" + c + \"_link\", markup(wordArray, entry.getKey().toNormalform(true, false)));\r\n            prop.put(\"viewMode_links_\" + c + \"_url\", entry.getKey().toNormalform(true, false));\r\n            prop.put(\"viewMode_links_\" + c + \"_rel\", rel);\r\n            prop.put(\"viewMode_links_\" + c + \"_name\", name);\r\n            dark = !dark;\r\n            c++;\r\n            i++;\r\n        }\r\n        return i;\r\n    }","commit_id":"5dd2efc9a2cba063790008f32f13eb0b2182768a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * every tag that appears is handed to the filterTag method. The method then returns text from the tag\r\n     * but also operates on the tag content to scrape information from it. In case that a tag is unclosed if\r\n     * another tag appears, both, the unclosed and the new one are merged into one new char[]\r\n     * @param tag\r\n     * @param opening\r\n     * @param content\r\n     * @param quotechar\r\n     * @return\r\n     */\r\n    private char[] filterTag(final String tag, final boolean opening, final char[] content, final char quotechar) {\r\n        //System.out.println(\"FILTER1: filterTag=\" + ((this.filterTag == null) ? \"null\" : this.filterTag) + \", tag=\" + tag + \", opening=\" + ((opening) ? \"true\" : \"false\") + \", content=\" + new String(content)); // debug\r\n        char[] unclosed = null;\r\n\r\n        if (this.filterTag != null && opening) {\r\n            // there is a missing close tag for the currently parsed tag filterTag\r\n            // close that tag here and go on with new tag\r\n            if (this.scraper != null) {\r\n                this.scraper.scrapeTag1(this.filterTag, this.filterOpts, this.filterCont.getChars());\r\n            }\r\n            if (this.transformer != null) {\r\n                unclosed = this.transformer.transformTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n            } else {\r\n                unclosed = genTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n            }\r\n            this.filterTag = null;\r\n            this.filterOpts = null;\r\n            this.filterCont = null;\r\n        }\r\n\r\n        if (this.filterTag == null) {\r\n            // we are not collection tag text\r\n            if (tag == null) {\r\n                // and this is not a tag opener/closer\r\n                if (this.scraper != null) this.scraper.scrapeText(content, null);\r\n                if (this.transformer != null) return mergedScrape(unclosed, this.transformer.transformText(content));\r\n                return mergedScrape(unclosed, content);\r\n            }\r\n\r\n            // we have a new tag\r\n            if (opening) {\r\n                if ((this.scraper != null) && (this.scraper.isTag0(tag))) {\r\n                    // this single tag is collected at once here\r\n                \tfinal CharBuffer charBuffer = new CharBuffer(content);\r\n                    this.scraper.scrapeTag0(tag, charBuffer.propParser());\r\n                    try {\r\n\t\t\t\t\t\tcharBuffer.close();\r\n\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t}\r\n                }\r\n                if ((this.transformer != null) && (this.transformer.isTag0(tag))) {\r\n                    // this single tag is collected at once here\r\n                \tfinal CharBuffer scb = new CharBuffer(content);\r\n                \ttry {\r\n                \t\treturn mergedScrape(unclosed, this.transformer.transformTag0(tag, scb.propParser(), quotechar));\r\n                \t} finally {\r\n                \t\ttry {\r\n\t\t\t\t\t\t\tscb.close();\r\n\t\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t\t}\r\n                \t}\r\n                } else if (((this.scraper != null) && (this.scraper.isTag1(tag))) ||\r\n                           ((this.transformer != null) && (this.transformer.isTag1(tag)))) {\r\n                    // ok, start collecting\r\n                    this.filterTag = tag;\r\n                    final CharBuffer scb = new CharBuffer(content);\r\n                    this.filterOpts = scb.propParser();\r\n                    try {\r\n\t\t\t\t\t\tscb.close();\r\n\t\t\t\t\t} catch (final IOException e) {\r\n\t\t\t\t\t    Log.logException(e);\r\n\t\t\t\t\t}\r\n                    if (this.filterCont == null) this.filterCont = new CharBuffer(Math.max(100, content.length)); else this.filterCont.reset();\r\n                    return mergedScrape(unclosed, new char[0]);\r\n                } else {\r\n                     // we ignore that thing and return it again\r\n                     return mergedScrape(unclosed, genTag0raw(tag, true, content));\r\n                }\r\n            }\r\n\r\n            // we ignore that thing and return it again\r\n            return mergedScrape(unclosed, genTag0raw(tag, false, content));\r\n\r\n        }\r\n\r\n        // we are collection tag text for the tag 'filterTag'\r\n        if (tag == null) {\r\n            // go on collecting content\r\n            if (this.scraper != null) this.scraper.scrapeText(content, this.filterTag);\r\n            try {\r\n                if (this.transformer != null) {\r\n                    this.filterCont.append(this.transformer.transformText(content));\r\n                } else {\r\n                    this.filterCont.append(content);\r\n                }\r\n            } catch (final OutOfMemoryError e) {}\r\n            return mergedScrape(unclosed, new char[0]);\r\n        }\r\n\r\n        // it's a tag! which one?\r\n        if (opening || !(tag.equalsIgnoreCase(this.filterTag))) {\r\n            // this tag is not our concern. just add it\r\n            this.filterCont.append(genTag0raw(tag, opening, content));\r\n            return mergedScrape(unclosed, new char[0]);\r\n        }\r\n\r\n        // it's our closing tag! return complete result.\r\n        char[] ret;\r\n        if (this.scraper != null) this.scraper.scrapeTag1(this.filterTag, this.filterOpts, this.filterCont.getChars());\r\n        if (this.transformer != null) {\r\n            ret = this.transformer.transformTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n        } else {\r\n            ret = genTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\r\n        }\r\n        this.filterTag = null;\r\n        this.filterOpts = null;\r\n        this.filterCont = null;\r\n        return mergedScrape(unclosed, ret);\r\n    }","id":88466,"modified_method":"private char[] filterTag(final String tag, final boolean opening, final char[] content, final char quotechar) {\n//      System.out.println(\"FILTER1: filterTag=\" + ((filterTag == null) ? \"null\" : filterTag) + \", tag=\" + tag + \", opening=\" + ((opening) ? \"true\" : \"false\") + \", content=\" + UTF8.String(content)); // debug\n        if (this.filterTag == null) {\n            // we are not collection tag text\n            if (tag == null) {\n                // and this is not a tag opener/closer\n                if (this.scraper != null) this.scraper.scrapeText(content, null);\n                if (this.transformer != null) return this.transformer.transformText(content);\n                return content;\n            }\n\n            // we have a new tag\n            if (opening) {\n                if ((this.scraper != null) && (this.scraper.isTag0(tag))) {\n                    // this single tag is collected at once here\n                    final CharBuffer charBuffer = new CharBuffer(content);\n                    this.scraper.scrapeTag0(tag, charBuffer.propParser());\n                    try {\n                        charBuffer.close();\n                    } catch (final IOException e) {\n                        // TODO Auto-generated catch block\n                        Log.logException(e);\n                    }\n                }\n                if ((this.transformer != null) && (this.transformer.isTag0(tag))) {\n                    // this single tag is collected at once here\n                    final CharBuffer scb = new CharBuffer(content);\n                    try {\n                        return this.transformer.transformTag0(tag, scb.propParser(), quotechar);\n                    } finally {\n                        try {\n                            scb.close();\n                        } catch (final IOException e) {\n                            Log.logException(e);\n                        }\n                    }\n                } else if (((this.scraper != null) && (this.scraper.isTag1(tag))) ||\n                           ((this.transformer != null) && (this.transformer.isTag1(tag)))) {\n                    // ok, start collecting\n                    this.filterTag = tag;\n                    final CharBuffer scb = new CharBuffer(content);\n                    this.filterOpts = scb.propParser();\n                    try {\n                        scb.close();\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n                    if (this.filterCont == null) this.filterCont = new CharBuffer(Math.max(100, content.length)); else this.filterCont.reset();\n                    return new char[0];\n                } else {\n                     // we ignore that thing and return it again\n                     return genTag0raw(tag, true, content);\n                }\n            }\n\n            // we ignore that thing and return it again\n            return genTag0raw(tag, false, content);\n\n        }\n\n        // we are collection tag text for the tag 'filterTag'\n        if (tag == null) {\n            // go on collecting content\n            if (this.scraper != null) this.scraper.scrapeText(content, this.filterTag);\n            if (this.transformer != null) {\n                this.filterCont.append(this.transformer.transformText(content));\n            } else {\n                this.filterCont.append(content);\n            }\n            return new char[0];\n        }\n\n        // it's a tag! which one?\n        if ((opening) || (!(tag.equalsIgnoreCase(this.filterTag)))) {\n            // this tag is not our concern. just add it\n            this.filterCont.append(genTag0raw(tag, opening, content));\n            return new char[0];\n        }\n\n        // it's our closing tag! return complete result.\n        char[] ret;\n        if (this.scraper != null) this.scraper.scrapeTag1(this.filterTag, this.filterOpts, this.filterCont.getChars());\n        if (this.transformer != null) {\n            ret = this.transformer.transformTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\n        } else {\n            ret = genTag1(this.filterTag, this.filterOpts, this.filterCont.getChars(), quotechar);\n        }\n        this.filterTag = null;\n        this.filterOpts = null;\n        this.filterCont = null;\n        return ret;\n    }","commit_id":"231074bf0ab7149d304fd4c183268c620823b7d9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal WriterHelper wh = new WriterHelper(out);\r\n\t\tfinal Bandbox self = (Bandbox) comp;\r\n\t\tfinal String uuid = self.getUuid();\r\n\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\twh.write(\"<span id=\\\"\").write(uuid).write(\"\\\"\").write(\r\n\t\t\t\tself.getOuterAttrs());\r\n\t\twh.write(\" z.type=\\\"zul.cb.Bdbox\\\" z.combo=\\\"true\\\"><input id=\\\"\");\r\n\t\twh.write(uuid).write(\"!real\\\"\").write(self.getInnerAttrs());\r\n\t\twh.write(\" /><span id=\\\"\").write(uuid).write(\r\n\t\t\t\t\"!btn\\\" class=\\\"rbtnbk\\\"><img src=\\\"\");\r\n\t\twh.write(exec.encodeURL(self.getImage())).write(\"\\\"\");\r\n\t\tif (self.isButtonVisible())\r\n\t\t\twh.write(\"\");\r\n\t\telse wh.write(\" style=\\\"display:none\\\"\");\r\n\t\twh.write(\"/><\/span><div id=\\\"\").write(uuid);\r\n\t\twh.write(\"!pp\\\" class=\\\"bandboxpp\\\" style=\\\"display:none\\\" tabindex=\\\"-1\\\">\");\r\n\t\tif (self.getDropdown() != null) {\r\n\t\t\tself.getDropdown().redraw(out);\r\n\t\t}\r\n\t\twh.write(\"<\/div><\/span>\");\r\n\t\twh.writeln();\r\n\t}","id":88467,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal WriterHelper wh = new WriterHelper(out);\r\n\t\tfinal Bandbox self = (Bandbox) comp;\r\n\t\tfinal String uuid = self.getUuid();\r\n\t\tfinal Execution exec = Executions.getCurrent();\r\n\t\twh.write(\"<span id=\\\"\").write(uuid).write(\"\\\"\")\r\n\t\t\t.write(self.getOuterAttrs())\r\n\t\t\t.write(\" z.type=\\\"zul.cb.Bdbox\\\" z.combo=\\\"true\\\"><input id=\\\"\")\r\n\t\t\t.write(uuid).write(\"!real\\\"\").write(self.getInnerAttrs())\r\n\t\t\t.write(\" /><span id=\\\"\").write(uuid)\r\n\t\t\t.write(\"!btn\\\" class=\\\"rbtnbk\\\"><img src=\\\"\")\r\n\t\t\t.write(exec.encodeURL(self.getImage())).write(\"\\\"\");\r\n\r\n\t\tif (!self.isButtonVisible())\r\n\t\t\twh.write(\" style=\\\"display:none\\\"\");\r\n\r\n\t\twh.write(\"/><\/span><div id=\\\"\").write(uuid)\r\n\t\t\t.write(\"!pp\\\" class=\\\"bandboxpp\\\" style=\\\"display:none\\\" tabindex=\\\"-1\\\">\")\r\n\t\t\t.write(self.getDropdown())\r\n\t\t\t.writeln(\"<\/div><\/span>\");\r\n\t}","commit_id":"1a1ac1da9c00869cfba5a6412df4426e5f4c557a","url":"https://github.com/zkoss/zk"},{"original_method":"private void writeResourceAs(DocumentImpl resource, DBBroker broker,\n\t\t\tString stylesheet, String encoding, String asMimeType,\n\t\t\tProperties outputProperties, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows BadRequestException, PermissionDeniedException, IOException {\n\n\t\t// Do we have permission to read the resource\n\t\tif (!resource.getPermissions().validate(broker.getUser(),\n\t\t\t\tPermission.READ)) {\n\t\t\tthrow new PermissionDeniedException(\"Not allowed to read resource\");\n\t\t}\n\n\t\tif (resource.getResourceType() == DocumentImpl.BINARY_FILE) {\n\t\t\t// binary resource\n\n\t\t\tif (asMimeType != null) { // was a mime-type specified?\n\n\t\t\t\tresponse.setContentType(asMimeType);\n\t\t\t} else {\n\t\t\t\tresponse.setContentType(resource.getMetadata().getMimeType());\n\t\t\t}\n\t\t\tOutputStream os = response.getOutputStream();\n\t\t\tbroker.readBinaryResource((BinaryDocument) resource, os);\n\t\t\tos.flush();\n\t\t} else {\n\t\t\t// xml resource\n\n\t\t\tSAXSerializer sax = null;\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.reset();\n\n\t\t\t//setup the http context\n\t\t\tHttpContext httpContext = serializer.new HttpContext();\n\t\t\tHttpRequestWrapper reqw = new HttpRequestWrapper(request, formEncoding, containerEncoding);\n\t\t\thttpContext.setRequest(reqw);\n\t\t\thttpContext.setSession(reqw.getSession(false));\n\t\t\tserializer.setHttpContext(httpContext);\n\t\t\t\n\t\t\t\n\t\t\t// Serialize the document\n\t\t\ttry {\n\t\t\t\tsax = (SAXSerializer) SerializerPool.getInstance()\n\t\t\t\t\t\t.borrowObject(SAXSerializer.class);\n\n\t\t\t\t// use a stylesheet if specified in query parameters\n\t\t\t\tif (stylesheet != null) {\n\t\t\t\t\tserializer.setStylesheet(resource, stylesheet);\n\t\t\t\t}\n\t\t\t\tserializer.setProperties(outputProperties);\n                serializer.prepareStylesheets(resource);\n\n\t\t\t\tif (asMimeType != null) { // was a mime-type specified?\n\t\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t} else {\n\t\t\t\t\tif (serializer.isStylesheetApplied()\n\t\t\t\t\t\t\t|| serializer.hasXSLPi(resource) != null) {\n\t\t\t\t\t\tasMimeType = serializer.getStylesheetProperty(OutputKeys.MEDIA_TYPE);\n\t\t\t\t\t\tif (!useDynamicContentType || asMimeType == null)\n\t\t\t\t\t\t\tasMimeType = MimeType.HTML_TYPE.getName();\n\t\t\t\t\t\tLOG.debug(\"media-type: \" + asMimeType);\n\t\t\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasMimeType = resource.getMetadata().getMimeType();\n\t\t\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (asMimeType.equals(MimeType.HTML_TYPE.getName())) {\n\t\t\t\t\toutputProperties.setProperty(\"method\", \"xhtml\");\n\t\t\t\t\toutputProperties.setProperty(\"media-type\", \"text/html\");\n\t\t\t\t\toutputProperties.setProperty(\"ident\", \"yes\");\n\t\t\t\t\toutputProperties.setProperty(\"omit-xml-declaration\", \"no\");\n\t\t\t\t}\n\n\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(response\n\t\t\t\t\t\t.getOutputStream(), encoding);\n\t\t\t\tsax.setOutput(writer, outputProperties);\n\t\t\t\tserializer.setSAXHandlers(sax, sax);\n\t\t\t\t\n\t\t\t\tserializer.toSAX(resource);\n\n\t\t\t\twriter.flush();\n\t\t\t\twriter.close();\n\t\t\t} catch (SAXException saxe) {\n\t\t\t\tLOG.warn(saxe);\n\t\t\t\tthrow new BadRequestException(\"Error while serializing XML: \"\n\t\t\t\t\t\t+ saxe.getMessage());\n\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\tLOG.warn(e);\n\t\t\t\tthrow new BadRequestException(e.getMessageAndLocation());\n\t\t\t} finally {\n\t\t\t\tif (sax != null) {\n\t\t\t\t\tSerializerPool.getInstance().returnObject(sax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":88468,"modified_method":"private void writeResourceAs(DocumentImpl resource, DBBroker broker,\n\t\t\tString stylesheet, String encoding, String asMimeType,\n\t\t\tProperties outputProperties, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows BadRequestException, PermissionDeniedException, IOException {\n\n\t\t// Do we have permission to read the resource\n\t\tif (!resource.getPermissions().validate(broker.getUser(),\n\t\t\t\tPermission.READ)) {\n\t\t\tthrow new PermissionDeniedException(\"Not allowed to read resource\");\n\t\t}\n\n\t\tif (resource.getResourceType() == DocumentImpl.BINARY_FILE) {\n\t\t\t// binary resource\n\n\t\t\tif (asMimeType == null) { // wasn't a mime-type specified?\n\t\t\t\tasMimeType = resource.getMetadata().getMimeType();\n\t\t\t}\n\t\t\t\n\t\t\tif (asMimeType.startsWith(\"text/\")){\n\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t+ encoding);\n\t\t\t} else {\n\t\t\t\tresponse.setContentType(asMimeType);\n\t\t\t}\n\n\t\t\tOutputStream os = response.getOutputStream();\n\t\t\tbroker.readBinaryResource((BinaryDocument) resource, os);\n\t\t\tos.flush();\n\t\t} else {\n\t\t\t// xml resource\n\n\t\t\tSAXSerializer sax = null;\n\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\tserializer.reset();\n\n\t\t\t//setup the http context\n\t\t\tHttpContext httpContext = serializer.new HttpContext();\n\t\t\tHttpRequestWrapper reqw = new HttpRequestWrapper(request, formEncoding, containerEncoding);\n\t\t\thttpContext.setRequest(reqw);\n\t\t\thttpContext.setSession(reqw.getSession(false));\n\t\t\tserializer.setHttpContext(httpContext);\n\t\t\t\n\t\t\t\n\t\t\t// Serialize the document\n\t\t\ttry {\n\t\t\t\tsax = (SAXSerializer) SerializerPool.getInstance()\n\t\t\t\t\t\t.borrowObject(SAXSerializer.class);\n\n\t\t\t\t// use a stylesheet if specified in query parameters\n\t\t\t\tif (stylesheet != null) {\n\t\t\t\t\tserializer.setStylesheet(resource, stylesheet);\n\t\t\t\t}\n\t\t\t\tserializer.setProperties(outputProperties);\n                serializer.prepareStylesheets(resource);\n\n\t\t\t\tif (asMimeType != null) { // was a mime-type specified?\n\t\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t} else {\n\t\t\t\t\tif (serializer.isStylesheetApplied()\n\t\t\t\t\t\t\t|| serializer.hasXSLPi(resource) != null) {\n\t\t\t\t\t\tasMimeType = serializer.getStylesheetProperty(OutputKeys.MEDIA_TYPE);\n\t\t\t\t\t\tif (!useDynamicContentType || asMimeType == null)\n\t\t\t\t\t\t\tasMimeType = MimeType.HTML_TYPE.getName();\n\t\t\t\t\t\tLOG.debug(\"media-type: \" + asMimeType);\n\t\t\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasMimeType = resource.getMetadata().getMimeType();\n\t\t\t\t\t\tresponse.setContentType(asMimeType + \"; charset=\"\n\t\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (asMimeType.equals(MimeType.HTML_TYPE.getName())) {\n\t\t\t\t\toutputProperties.setProperty(\"method\", \"xhtml\");\n\t\t\t\t\toutputProperties.setProperty(\"media-type\", \"text/html; charset=\"\n\t\t\t\t\t\t\t\t\t+ encoding);\n\t\t\t\t\toutputProperties.setProperty(\"ident\", \"yes\");\n\t\t\t\t\toutputProperties.setProperty(\"omit-xml-declaration\", \"no\");\n\t\t\t\t}\n\n\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(response\n\t\t\t\t\t\t.getOutputStream(), encoding);\n\t\t\t\tsax.setOutput(writer, outputProperties);\n\t\t\t\tserializer.setSAXHandlers(sax, sax);\n\t\t\t\t\n\t\t\t\tserializer.toSAX(resource);\n\n\t\t\t\twriter.flush();\n\t\t\t\twriter.close();\n\t\t\t} catch (SAXException saxe) {\n\t\t\t\tLOG.warn(saxe);\n\t\t\t\tthrow new BadRequestException(\"Error while serializing XML: \"\n\t\t\t\t\t\t+ saxe.getMessage());\n\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\tLOG.warn(e);\n\t\t\t\tthrow new BadRequestException(e.getMessageAndLocation());\n\t\t\t} finally {\n\t\t\t\tif (sax != null) {\n\t\t\t\t\tSerializerPool.getInstance().returnObject(sax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"ee549b8865f216960942669d6c698ba378b3cd7e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Respond by trying to delegate getting the resource from the\n\t * {@link ServletContext} object and stream that to the client. If such a\n\t * resource is not found, a warning will be logged, and a 404 will be\n\t * issued.\n\t * \n\t * @see wicket.IRequestTarget#respond(wicket.RequestCycle)\n\t */\n\tpublic void respond(RequestCycle requestCycle)\n\t{\n\t\ttry\n\t\t{\n\t\t\tWebResponse webResponse = ((WebRequestCycle)requestCycle).getWebResponse();\n\t\t\tfinal ServletContext context = ((WebApplication)requestCycle.getApplication())\n\t\t\t\t\t.getWicketServlet().getServletContext();\n\n\t\t\t// Set content type\n\t\t\twebResponse.setContentType(context.getMimeType(url));\n\t\t\tfinal InputStream in = context.getResourceAsStream(url);\n\t\t\tif (in != null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Copy resource input stream to servlet output stream\n\t\t\t\t\tStreams.copy(in, webResponse.getHttpServletResponse().getOutputStream());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\t// NOTE: We only close the InputStream. The servlet\n\t\t\t\t\t// container should close the output stream.\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.warn(\"the resource requested by request \" + requestCycle.getRequest()\n\t\t\t\t\t\t+ \" was not found\");\n\t\t\t\tHttpServletResponse httpServletResponse = webResponse.getHttpServletResponse();\n\t\t\t\thttpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Cannot load static content for request \"\n\t\t\t\t\t+ requestCycle.getRequest(), e);\n\t\t}\n\t}","id":88469,"modified_method":"/**\n\t * Respond by trying to delegate getting the resource from the\n\t * {@link ServletContext} object and stream that to the client. If such a\n\t * resource is not found, a warning will be logged, and a 404 will be\n\t * issued.\n\t * \n\t * @see wicket.IRequestTarget#respond(wicket.RequestCycle)\n\t */\n\tpublic void respond(RequestCycle requestCycle)\n\t{\n\t\ttry\n\t\t{\n\t\t\tWebResponse webResponse = ((WebRequestCycle)requestCycle).getWebResponse();\n\t\t\tfinal ServletContext context = ((WebApplication)requestCycle.getApplication())\n\t\t\t\t\t.getWicketServlet().getServletContext();\n\n\t\t\tfinal InputStream in = context.getResourceAsStream(url);\n\t\t\tif (in != null)\n\t\t\t{\n\t\t\t\t// Set content type\n\t\t\t\tString contentType = context.getMimeType(url);\n\t\t\t\tif(contentType != null)\n\t\t\t\t{\n\t\t\t\t\twebResponse.setContentType(contentType);\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Copy resource input stream to servlet output stream\n\t\t\t\t\tStreams.copy(in, webResponse.getHttpServletResponse().getOutputStream());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\t// NOTE: We only close the InputStream. The servlet\n\t\t\t\t\t// container should close the output stream.\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.warn(\"the resource requested by request \" + requestCycle.getRequest()\n\t\t\t\t\t\t+ \" was not found\");\n\t\t\t\tHttpServletResponse httpServletResponse = webResponse.getHttpServletResponse();\n\t\t\t\thttpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Cannot load static content for request \"\n\t\t\t\t\t+ requestCycle.getRequest(), e);\n\t\t}\n\t}","commit_id":"df19e28f3b30a7f1528c6795021b75f7429ee6e4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Respond by trying to delegate getting the resource from the\n\t * {@link ServletContext} object and stream that to the client. If such a\n\t * resource is not found, a warning will be logged, and a 404 will be\n\t * issued.\n\t * \n\t * @see wicket.IRequestTarget#respond(wicket.RequestCycle)\n\t */\n\tpublic void respond(RequestCycle requestCycle)\n\t{\n\t\ttry\n\t\t{\n\t\t\tWebResponse webResponse = ((WebRequestCycle)requestCycle).getWebResponse();\n\t\t\tfinal ServletContext context = ((WebApplication)requestCycle.getApplication())\n\t\t\t\t\t.getServletContext();\n\n\t\t\t// Set content type\n\t\t\twebResponse.setContentType(context.getMimeType(url));\n\t\t\tfinal InputStream in = context.getResourceAsStream(url);\n\t\t\tif (in != null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Copy resource input stream to servlet output stream\n\t\t\t\t\tStreams.copy(in, webResponse.getHttpServletResponse().getOutputStream());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\t// NOTE: We only close the InputStream. The servlet\n\t\t\t\t\t// container should close the output stream.\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.warn(\"the resource requested by request \" + requestCycle.getRequest()\n\t\t\t\t\t\t+ \" was not found\");\n\t\t\t\tHttpServletResponse httpServletResponse = webResponse.getHttpServletResponse();\n\t\t\t\thttpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Cannot load static content for request \"\n\t\t\t\t\t+ requestCycle.getRequest(), e);\n\t\t}\n\t}","id":88470,"modified_method":"/**\n\t * Respond by trying to delegate getting the resource from the\n\t * {@link ServletContext} object and stream that to the client. If such a\n\t * resource is not found, a warning will be logged, and a 404 will be\n\t * issued.\n\t * \n\t * @see wicket.IRequestTarget#respond(wicket.RequestCycle)\n\t */\n\tpublic void respond(RequestCycle requestCycle)\n\t{\n\t\ttry\n\t\t{\n\t\t\tWebResponse webResponse = ((WebRequestCycle)requestCycle).getWebResponse();\n\t\t\tfinal ServletContext context = ((WebApplication)requestCycle.getApplication())\n\t\t\t\t\t.getServletContext();\n\n\t\t\tfinal InputStream in = context.getResourceAsStream(url);\n\t\t\tif (in != null)\n\t\t\t{\n\t\t\t\t// TODO check can this really by done by any kind of url??\n\t\t\t\t// Is this class really only used internally with a relative url to a resource in the servlet context.\n\t\t\t\t// Set content type. \n\t\t\t\tString contentType = context.getMimeType(url);\n\t\t\t\tif(contentType != null)\n\t\t\t\t{\n\t\t\t\t\twebResponse.setContentType(contentType);\n\t\t\t\t}\t\t\t\t\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Copy resource input stream to servlet output stream\n\t\t\t\t\tStreams.copy(in, webResponse.getHttpServletResponse().getOutputStream());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\t// NOTE: We only close the InputStream. The servlet\n\t\t\t\t\t// container should close the output stream.\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.warn(\"the resource requested by request \" + requestCycle.getRequest()\n\t\t\t\t\t\t+ \" was not found\");\n\t\t\t\tHttpServletResponse httpServletResponse = webResponse.getHttpServletResponse();\n\t\t\t\thttpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Cannot load static content for request \"\n\t\t\t\t\t+ requestCycle.getRequest(), e);\n\t\t}\n\t}","commit_id":"8a91bff591423be67eaa188c6a07c5c0bc42c0fe","url":"https://github.com/apache/wicket"},{"original_method":"protected View createDialogHeader(final FragmentActivity ctx, final boolean editF, final boolean flat, final AlertDialog dlg) {\n\t\t\tView v;\n\t\t\tv = ctx.getLayoutInflater().inflate(R.layout.waypoint_title, null);\n\t\t\tImageButton edit = (ImageButton) v.findViewById(R.id.edit);\n\t\t\tImageButton sort = (ImageButton) v.findViewById(R.id.sort);\n\t\t\tImageButton all = (ImageButton) v.findViewById(R.id.all);\n\t\t\tedit.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_action_edit_light\n\t\t\t\t\t: R.drawable.ic_action_edit_dark);\n\t\t\tedit.setVisibility(editF ? View.GONE : View.VISIBLE);\n\t\t\tedit.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tif(flat) {\n\t\t\t\t\t\tshowWaypointsDialogFlat(ctx, true);\n\t\t\t\t\t}  else {\n\t\t\t\t\t\tshowWaypointsDialog(ctx, true);\n\t\t\t\t\t}\n\t\t\t\t\tif(dlg != null) {\n\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(flat) {\n\t\t\t\tall.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_action_gdown_light\n\t\t\t\t\t\t: R.drawable.ic_action_gdown_dark);\n\t\t\t} else {\n\t\t\t\tall.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_action_gup_light\n\t\t\t\t\t\t: R.drawable.ic_action_gup_dark);\n\t\t\t}\n\t\t\tif(app.getTargetPointsHelper().getIntermediatePoints().size() > 0) {\n\t\t\t\tsort.setVisibility(View.VISIBLE);\n\t\t\t\tsort.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_sort_waypoint_white\n\t\t\t\t\t\t: R.drawable.ic_sort_waypoint_dark);\n\t\t\t\tsort.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tIntermediatePointsDialog.openIntermediatePointsDialog(getActivity(), app, true);\n\t\t\t\t\t\tif(dlg != null) {\n\t\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsort.setVisibility(View.GONE);\n\t\t\t}\n\t\t\t\n\t\t\tall.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tif(flat) {\n\t\t\t\t\t\tshowWaypointsDialog(ctx, editF);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshowWaypointsDialogFlat(ctx, editF);\n\t\t\t\t\t}\n\t\t\t\t\tif(dlg != null) {\n\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn v;\n\t\t}","id":88471,"modified_method":"protected View createDialogHeader(final FragmentActivity ctx, final boolean editF, final boolean flat, final AlertDialog dlg) {\n\t\t\tView v;\n\t\t\tv = ctx.getLayoutInflater().inflate(R.layout.waypoint_title, null);\n\t\t\tImageButton edit = (ImageButton) v.findViewById(R.id.edit);\n\t\t\tImageButton sort = (ImageButton) v.findViewById(R.id.sort);\n\t\t\tImageButton all = (ImageButton) v.findViewById(R.id.all);\n\t\t\tedit.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_action_edit_light\n\t\t\t\t\t: R.drawable.ic_action_edit_dark);\n\t\t\tedit.setVisibility(editF ? View.GONE : View.VISIBLE);\n\t\t\tedit.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tif(flat) {\n\t\t\t\t\t\tshowWaypointsDialogFlat(ctx, true);\n\t\t\t\t\t}  else {\n\t\t\t\t\t\tshowWaypointsDialog(ctx, true);\n\t\t\t\t\t}\n\t\t\t\t\tif(dlg != null) {\n\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif(app.getTargetPointsHelper().getIntermediatePoints().size() > 0) {\n\t\t\t\tsort.setVisibility(View.VISIBLE);\n\t\t\t\tsort.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_sort_waypoint_white\n\t\t\t\t\t\t: R.drawable.ic_sort_waypoint_dark);\n\t\t\t\tsort.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tIntermediatePointsDialog.openIntermediatePointsDialog(getActivity(), app, true);\n\t\t\t\t\t\tif(dlg != null) {\n\t\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsort.setVisibility(View.GONE);\n\t\t\t}\n\t\t\tif(waypointHelper.isRouteCalculated()) {\n\t\t\t\tall.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tall.setVisibility(View.VISIBLE);\n\t\t\t\tif(flat) {\n\t\t\t\t\tall.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_action_gdown_light\n\t\t\t\t\t\t\t: R.drawable.ic_action_gdown_dark);\n\t\t\t\t} else {\n\t\t\t\t\tall.setImageResource(app.getSettings().isLightContent() ? R.drawable.ic_action_gup_light\n\t\t\t\t\t\t\t: R.drawable.ic_action_gup_dark);\n\t\t\t\t}\n\t\t\t\tall.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tif(flat) {\n\t\t\t\t\t\t\tshowWaypointsDialog(ctx, editF);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowWaypointsDialogFlat(ctx, editF);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dlg != null) {\n\t\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn v;\n\t\t}","commit_id":"ec012994ddc6792979b5237ec2f7dde82566085f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void finishInsertMode(EditorContext editorContext) {\n    if (isInsertMode()) {\n      editorContext.getNodeEditorComponent().popKeyboardHandler(); // remove this handler from stack.\n\n      EditorCell prevCell = myListEditorCell_Collection.getPrevCell(myInsertCell);\n      myListEditorCell_Collection.removeCell(myInsertCell);\n      myListEditorCell_Collection.insertAfter(prevCell, myInsertedNodeCell);\n\n      myInsertCell = null;\n      myInsertedNode = null;\n      myInsertedNodeCell = null;\n      editorContext.getNodeEditorComponent().relayout();\n    }\n  }","id":88472,"modified_method":"private void finishInsertMode(EditorContext editorContext) {\n    if (isInsertMode()) {\n      editorContext.getNodeEditorComponent().popKeyboardHandler(); // remove this handler from stack.\n\n      EditorCell prevCell = myListEditorCell_Collection.getPrevCell(myInsertCell);\n      myListEditorCell_Collection.removeCell(myInsertCell);\n      if (myInsertedNodeCell != null) {\n        myListEditorCell_Collection.insertAfter(prevCell, myInsertedNodeCell);\n      }\n\n      myInsertCell = null;\n      myInsertedNode = null;\n      myInsertedNodeCell = null;\n      editorContext.getNodeEditorComponent().relayout();\n    }\n  }","commit_id":"29e9821f0abb01a3d20fc190b81caa9ef5fb45d2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void startInsertMode(EditorContext editorContext, EditorCell anchorCell, boolean insertBefore) {\n    SemanticNode anchorNode = (anchorCell != null ? anchorCell.getSemanticNode() : null);\n    if (anchorNode != null) {\n      Iterator<SemanticNode> listElementsIter = null;\n      if (myAggregation) {\n        listElementsIter = getOwner().children(myLinkRole);\n      } else {\n        listElementsIter = getOwner().referents(myLinkRole);\n      }\n      List<SemanticNode> listElements = new LinkedList<SemanticNode>();\n      while (listElementsIter.hasNext()) {\n        listElements.add(listElementsIter.next());\n      }\n      // anchor should be directly referenced from \"list owner\"\n      while (anchorNode != null && !listElements.contains(anchorNode)) {\n        anchorNode = anchorNode.getParent();\n      }\n    }\n    myInsertedNode = createNodeToInsert();\n    if (myAggregation) {\n      getOwner().insertChild(anchorNode, myLinkRole, myInsertedNode, insertBefore);\n    } else {\n      getOwner().insertReferent(anchorNode, myLinkRole, myInsertedNode, insertBefore);\n    }\n\n    AbstractEditorComponent editor = editorContext.getNodeEditorComponent();\n    editor.pushKeyboardHandler(this);\n    editor.rebuildEditorContent();\n    EditorCell selectableLeaf = myInsertCell.findFirstSelectableLeaf();\n    if (selectableLeaf != null) {\n      editor.changeSelection(selectableLeaf);\n    }\n  }","id":88473,"modified_method":"public void startInsertMode(EditorContext editorContext, EditorCell anchorCell, boolean insertBefore) {\n    SemanticNode anchorNode = (anchorCell != null ? anchorCell.getSemanticNode() : null);\n    if (anchorNode != null) {\n      Iterator<SemanticNode> listElementsIter = null;\n      if (myAggregation) {\n        listElementsIter = getOwner().children(myLinkRole);\n      } else {\n        listElementsIter = getOwner().referents(myLinkRole);\n      }\n      List<SemanticNode> listElements = new LinkedList<SemanticNode>();\n      while (listElementsIter.hasNext()) {\n        listElements.add(listElementsIter.next());\n      }\n      // anchor should be directly referenced from \"list owner\"\n      while (anchorNode != null && !listElements.contains(anchorNode)) {\n        anchorNode = anchorNode.getParent();\n      }\n    }\n    myInsertedNode = createNodeToInsert();\n    if (myAggregation) {\n      getOwner().insertChild(anchorNode, myLinkRole, myInsertedNode, insertBefore);\n    } else {\n      getOwner().insertReferent(anchorNode, myLinkRole, myInsertedNode, insertBefore);\n    }\n\n    AbstractEditorComponent editor = editorContext.getNodeEditorComponent();\n    editor.pushKeyboardHandler(this);\n    editor.rebuildEditorContent();\n    if (myInsertCell != null) {\n      EditorCell selectableLeaf = myInsertCell.findFirstSelectableLeaf();\n      if (selectableLeaf != null) {\n        editor.changeSelection(selectableLeaf);\n      }\n    }\n  }","commit_id":"29e9821f0abb01a3d20fc190b81caa9ef5fb45d2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public DocTabLayoutPanel(boolean closeableTabs,\n                            int padding,\n                            int rightMargin)\n   {\n      super(BAR_HEIGHT, Style.Unit.PX);\n      closeableTabs_ = closeableTabs;\n      padding_ = padding;\n      rightMargin_ = rightMargin;\n      styles_ = ThemeResources.INSTANCE.themeStyles();\n      addStyleName(styles_.docTabPanel());\n      addStyleName(styles_.moduleTabPanel());\n      dragManager_ = new DragManager();\n      \n      // sink drag-related events on the tab bar element; unfortunately\n      // GWT does not provide bits for the drag-related events, and \n      Scheduler.get().scheduleDeferred(new ScheduledCommand()\n      {\n         @Override\n         public void execute()\n         {\n            Element tabBar = getTabBarElement();\n            DOM.sinkBitlessEvent(tabBar, \"drag\");\n            DOM.sinkBitlessEvent(tabBar, \"dragstart\");\n            DOM.sinkBitlessEvent(tabBar, \"dragenter\");\n            DOM.sinkBitlessEvent(tabBar, \"dragover\");\n            DOM.sinkBitlessEvent(tabBar, \"drop\");\n            Event.setEventListener(tabBar, dragManager_);\n         }\n      });\n   }","id":88474,"modified_method":"public DocTabLayoutPanel(boolean closeableTabs,\n                            int padding,\n                            int rightMargin)\n   {\n      super(BAR_HEIGHT, Style.Unit.PX);\n      closeableTabs_ = closeableTabs;\n      padding_ = padding;\n      rightMargin_ = rightMargin;\n      styles_ = ThemeResources.INSTANCE.themeStyles();\n      addStyleName(styles_.docTabPanel());\n      addStyleName(styles_.moduleTabPanel());\n      dragManager_ = new DragManager();\n      \n      // listen for global drag events (these are broadcasted from other windows\n      // to notify us of incoming drags)\n      EventBus events = RStudioGinjector.INSTANCE.getEventBus();\n      events.addHandler(DocTabDragStartedEvent.TYPE, dragManager_);\n\n      // sink drag-related events on the tab bar element; unfortunately\n      // GWT does not provide bits for the drag-related events, and \n      Scheduler.get().scheduleDeferred(new ScheduledCommand()\n      {\n         @Override\n         public void execute()\n         {\n            Element tabBar = getTabBarElement();\n            DOM.sinkBitlessEvent(tabBar, \"drag\");\n            DOM.sinkBitlessEvent(tabBar, \"dragstart\");\n            DOM.sinkBitlessEvent(tabBar, \"dragenter\");\n            DOM.sinkBitlessEvent(tabBar, \"dragover\");\n            DOM.sinkBitlessEvent(tabBar, \"drop\");\n            Event.setEventListener(tabBar, dragManager_);\n         }\n      });\n   }","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private DocTab(ImageResource icon,\n                     String docId,\n                     String title,\n                     String tooltip,\n                     TabCloseObserver closeHandler)\n      {\n         docId_ = docId;\n         \n         final HorizontalPanel layoutPanel = new HorizontalPanel();\n         layoutPanel.setStylePrimaryName(styles_.tabLayout());\n         layoutPanel.setVerticalAlignment(HasVerticalAlignment.ALIGN_BOTTOM);\n         layoutPanel.getElement().setDraggable(\"true\");\n         layoutPanel.addDomHandler(new DragStartHandler()\n         {\n            @Override\n            public void onDragStart(DragStartEvent evt)\n            {\n               evt.getDataTransfer().setData(\"text\", docId_);\n            }\n         }, DragStartEvent.getType());\n\n         HTML left = new HTML();\n         left.setStylePrimaryName(styles_.tabLayoutLeft());\n         layoutPanel.add(left);\n\n         contentPanel_ = new HorizontalPanel();\n         contentPanel_.setTitle(tooltip);\n         contentPanel_.setStylePrimaryName(styles_.tabLayoutCenter());\n         contentPanel_.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n\n         if (icon != null)\n            contentPanel_.add(imageForIcon(icon));\n\n         label_ = new Label(title, false);\n         label_.addStyleName(styles_.docTabLabel());\n         contentPanel_.add(label_);\n\n         appendDirtyMarker();\n\n         Image img = new Image(ThemeResources.INSTANCE.closeTab());\n         img.setStylePrimaryName(styles_.closeTabButton());\n         img.addStyleName(ThemeStyles.INSTANCE.handCursor());\n         contentPanel_.add(img);\n\n         layoutPanel.add(contentPanel_);\n\n         HTML right = new HTML();\n         right.setStylePrimaryName(styles_.tabLayoutRight());\n         layoutPanel.add(right);\n\n         initWidget(layoutPanel);\n\n         this.sinkEvents(Event.ONMOUSEMOVE |\n               Event.ONMOUSEUP |\n               Event.ONLOSECAPTURE);\n         closeHandler_ = closeHandler;\n         closeElement_ = img.getElement();\n      }","id":88475,"modified_method":"private DocTab(ImageResource icon,\n                     String docId,\n                     String title,\n                     String tooltip,\n                     TabCloseObserver closeHandler)\n      {\n         docId_ = docId;\n         \n         final HorizontalPanel layoutPanel = new HorizontalPanel();\n         layoutPanel.setStylePrimaryName(styles_.tabLayout());\n         layoutPanel.setVerticalAlignment(HasVerticalAlignment.ALIGN_BOTTOM);\n         layoutPanel.getElement().setDraggable(\"true\");\n         layoutPanel.addDomHandler(new DragStartHandler()\n         {\n            @Override\n            public void onDragStart(DragStartEvent evt)\n            {\n               evt.getDataTransfer().setData(\"text\", docId_);\n               RStudioGinjector.INSTANCE.getEventBus().fireEvent(new\n                     DocTabDragStartedEvent(docId_, \n                           getElement().getClientWidth()));\n            }\n         }, DragStartEvent.getType());\n\n         HTML left = new HTML();\n         left.setStylePrimaryName(styles_.tabLayoutLeft());\n         layoutPanel.add(left);\n\n         contentPanel_ = new HorizontalPanel();\n         contentPanel_.setTitle(tooltip);\n         contentPanel_.setStylePrimaryName(styles_.tabLayoutCenter());\n         contentPanel_.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\n\n         if (icon != null)\n            contentPanel_.add(imageForIcon(icon));\n\n         label_ = new Label(title, false);\n         label_.addStyleName(styles_.docTabLabel());\n         contentPanel_.add(label_);\n\n         appendDirtyMarker();\n\n         Image img = new Image(ThemeResources.INSTANCE.closeTab());\n         img.setStylePrimaryName(styles_.closeTabButton());\n         img.addStyleName(ThemeStyles.INSTANCE.handCursor());\n         contentPanel_.add(img);\n\n         layoutPanel.add(contentPanel_);\n\n         HTML right = new HTML();\n         right.setStylePrimaryName(styles_.tabLayoutRight());\n         layoutPanel.add(right);\n\n         initWidget(layoutPanel);\n\n         this.sinkEvents(Event.ONMOUSEMOVE |\n               Event.ONMOUSEUP |\n               Event.ONLOSECAPTURE);\n         closeHandler_ = closeHandler;\n         closeElement_ = img.getElement();\n      }","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void beginDrag(Event evt)\n      {\n         DataTransfer dt = evt.getDataTransfer();\n         String[] pieces = dt.getData(\"text\").split(\"\\\\|\");\n         \n         // doesn't look like our data\n         if (pieces.length != 2)\n         {\n            return;\n         }\n\n         String docId = pieces[0];\n         int dragTabWidth = Integer.parseInt(pieces[1]);\n         \n         // attempt to ascertain whether the element being dragged is one of\n         // our own documents\n         for (DocTab tab: docTabs_)\n         {\n            if (tab.getDocId() == docId)\n            {\n               dragElement_ = tab.getElement();\n               break;\n            }\n         }\n         \n         // set drag element state\n         dragging_ = true;\n         dragTabsHost_ = getTabBarElement();\n         dragScrollHost_ = dragTabsHost_.getParentElement();\n         outOfBounds_ = 0;\n         candidatePos_ = 0;\n\n         // find the current position of this tab among its siblings--we'll use\n         // this later to determine whether to shift siblings left or right\n         for (int i = 0; i < dragTabsHost_.getChildCount(); i++)\n         {\n            Node node = dragTabsHost_.getChild(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE)\n            {\n               if (Element.as(node) == dragElement_)\n               {\n                  candidatePos_ = i;\n                  destPos_ = i;\n               }\n               // the relative position of the last node determines how far we\n               // can drag--add 10px so it stretches a little\n               dragMax_ = DomUtils.leftRelativeTo(dragTabsHost_, Element.as(node)) \n                     + (Element.as(node).getClientWidth() - dragElement_.getClientWidth())\n                     + 10;\n            }\n         }\n         startPos_ = candidatePos_;\n\n         // snap the element out of the tabset\n         lastElementX_ = DomUtils.leftRelativeTo(dragTabsHost_, dragElement_);\n         lastCursorX_= evt.getClientX();\n         dragElement_.getStyle().setPosition(Position.ABSOLUTE);\n         dragElement_.getStyle().setLeft(lastElementX_, Unit.PX);\n         dragElement_.getStyle().setZIndex(100);\n         Scheduler.get().scheduleDeferred(new ScheduledCommand()\n         {\n            @Override\n            public void execute()\n            {\n              dragElement_.getStyle().setDisplay(Display.NONE);\n            }\n         });\n\n         // create the placeholder that shows where this tab will go when the\n         // mouse is released\n         dragPlaceholder_ = Document.get().createDivElement();\n         dragPlaceholder_.getStyle().setWidth(dragTabWidth, Unit.PX);\n         dragPlaceholder_.getStyle().setHeight(100, Unit.PCT);\n         dragPlaceholder_.getStyle().setDisplay(Display.INLINE_BLOCK);\n         dragPlaceholder_.getStyle().setPosition(Position.RELATIVE);\n         dragPlaceholder_.getStyle().setFloat(Float.LEFT);\n         dragPlaceholder_.getStyle().setBorderStyle(BorderStyle.DOTTED);\n         dragPlaceholder_.getStyle().setBorderColor(\"#414243\");\n         dragPlaceholder_.getStyle().setBorderWidth(2, Unit.PX);\n         dragPlaceholder_.getStyle().setProperty(\"boxSizing\", \"border-box\");\n         dragPlaceholder_.getStyle().setProperty(\"borderRadius\", \"3px\");\n         dragPlaceholder_.getStyle().setProperty(\"borderBottom\", \"0px\");\n         dragTabsHost_.insertAfter(dragPlaceholder_, dragElement_);\n      }","id":88476,"modified_method":"public void beginDrag(Event evt)\n      {\n         String docId = initDragDocId_;\n         int dragTabWidth = initDragWidth_;\n         \n         // attempt to ascertain whether the element being dragged is one of\n         // our own documents\n         for (DocTab tab: docTabs_)\n         {\n            if (tab.getDocId() == docId)\n            {\n               dragElement_ = tab.getElement();\n               break;\n            }\n         }\n         \n         // set drag element state\n         dragging_ = true;\n         dragTabsHost_ = getTabBarElement();\n         dragScrollHost_ = dragTabsHost_.getParentElement();\n         outOfBounds_ = 0;\n         candidatePos_ = 0;\n\n         // find the current position of this tab among its siblings--we'll use\n         // this later to determine whether to shift siblings left or right\n         if (dragElement_ != null)\n         {\n            for (int i = 0; i < dragTabsHost_.getChildCount(); i++)\n            {\n               Node node = dragTabsHost_.getChild(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE)\n               {\n                  if (Element.as(node) == dragElement_)\n                  {\n                     candidatePos_ = i;\n                     destPos_ = i;\n                  }\n                  // the relative position of the last node determines how far we\n                  // can drag--add 10px so it stretches a little\n                  dragMax_ = DomUtils.leftRelativeTo(dragTabsHost_, Element.as(node)) \n                        + (Element.as(node).getClientWidth() - dragElement_.getClientWidth())\n                        + 10;\n               }\n            }\n         }\n         startPos_ = candidatePos_;\n\n         // snap the element out of the tabset\n         lastCursorX_= evt.getClientX();\n         \n         // if we're dragging one of our own tabs, snap it out of the \n         // tabset\n         if (dragElement_ != null)\n         {\n            lastElementX_ = DomUtils.leftRelativeTo(dragTabsHost_, dragElement_);\n\n            dragElement_.getStyle().setPosition(Position.ABSOLUTE);\n            dragElement_.getStyle().setLeft(lastElementX_, Unit.PX);\n            dragElement_.getStyle().setZIndex(100);\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                 dragElement_.getStyle().setDisplay(Display.NONE);\n               }\n            });\n         }\n\n         // create the placeholder that shows where this tab will go when the\n         // mouse is released\n         dragPlaceholder_ = Document.get().createDivElement();\n         dragPlaceholder_.getStyle().setWidth(dragTabWidth, Unit.PX);\n         dragPlaceholder_.getStyle().setHeight(100, Unit.PCT);\n         dragPlaceholder_.getStyle().setDisplay(Display.INLINE_BLOCK);\n         dragPlaceholder_.getStyle().setPosition(Position.RELATIVE);\n         dragPlaceholder_.getStyle().setFloat(Float.LEFT);\n         dragPlaceholder_.getStyle().setBorderStyle(BorderStyle.DOTTED);\n         dragPlaceholder_.getStyle().setBorderColor(\"#414243\");\n         dragPlaceholder_.getStyle().setBorderWidth(2, Unit.PX);\n         dragPlaceholder_.getStyle().setProperty(\"boxSizing\", \"border-box\");\n         dragPlaceholder_.getStyle().setProperty(\"borderRadius\", \"3px\");\n         dragPlaceholder_.getStyle().setProperty(\"borderBottom\", \"0px\");\n         \n         if (dragElement_ != null)\n            dragTabsHost_.insertAfter(dragPlaceholder_, dragElement_);\n      }","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private final native void fireEventToMainWindow(JavaScriptObject data) /*-{\n      $wnd.opener.fireRStudioEventExternal(data);\n   }-*/;","id":88477,"modified_method":"private final native void fireEventToMainWindow(JavaScriptObject data,\n         String windowName) /*-{\n      $wnd.opener.fireRStudioEventExternal(data, windowName);\n   }-*/;","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void fireEventFromOtherWindow(JavaScriptObject data)\n   {\n      fireEvent((GwtEvent<?>)serializer_.deserialize(data), true);\n   }","id":88478,"modified_method":"private void fireEventFromOtherWindow(JavaScriptObject data, \n         String windowName)\n   {\n      CrossWindowEvent<?> evt = \n            (CrossWindowEvent<?>)serializer_.deserialize(data);\n      evt.setOriginWindowName(windowName);\n      fireEvent(evt, true);\n   }","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void fireEvent(GwtEvent<?> event, boolean fromOtherWindow)\n   {\n      // if this is a cross-window event that originated in this satellite \n      // window (and wasn't itself forwarded from somewhere else), pass it to\n      // the main window\n      if (event instanceof CrossWindowEvent &&\n          pSatellite_.get().isCurrentWindowSatellite() &&\n          !fromOtherWindow)\n      {\n         CrossWindowEvent<?> crossWindow = (CrossWindowEvent<?>)(event);\n         if (crossWindow.forward())\n         {\n            JavaScriptObject jso = serializer_.serialize(event);\n            fireEventToMainWindow(jso);\n         }\n         else\n         {\n            super.fireEvent(event);\n         }\n      }\n      else\n      {\n         super.fireEvent(event);\n      }\n      \n   }","id":88479,"modified_method":"private void fireEvent(GwtEvent<?> event, boolean fromOtherWindow)\n   {\n      // if this is a cross-window event that originated in this satellite \n      // window (and wasn't itself forwarded from somewhere else), pass it to\n      // the main window\n      if (event instanceof CrossWindowEvent &&\n          pSatellite_.get().isCurrentWindowSatellite() &&\n          !fromOtherWindow)\n      {\n         CrossWindowEvent<?> crossWindow = (CrossWindowEvent<?>)(event);\n         if (crossWindow.forward())\n         {\n            JavaScriptObject jso = serializer_.serialize(event);\n            fireEventToMainWindow(jso, pSatellite_.get().getSatelliteName());\n         }\n         else\n         {\n            super.fireEvent(event);\n         }\n      }\n      else\n      {\n         super.fireEvent(event);\n      }\n      \n   }","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public SourceWindowManager(\n         Provider<SatelliteManager> pSatelliteManager, \n         Provider<Satellite> pSatellite,\n         SourceServerOperations server,\n         EventBus events,\n         FileTypeRegistry registry)\n   {\n      events_ = events;\n      server_ = server;\n      pSatelliteManager_ = pSatelliteManager;\n      pSatellite_ = pSatellite;\n      events_.addHandler(PopoutDocEvent.TYPE, this);\n      events_.addHandler(SourceDocAddedEvent.TYPE, this);\n      events_.addHandler(LastSourceDocClosedEvent.TYPE, this);\n      events_.addHandler(SatelliteClosedEvent.TYPE, this);\n      \n      // the main window maintains an array of all open source documents \n      // across all satellites; rather than attempt to synchronize this list \n      // among satellites, the main window exposes it on its window object for\n      // the satellites to read \n      if (isMainSourceWindow())\n      {\n         exportSourceDocs();\n      }\n   }","id":88480,"modified_method":"@Inject\n   public SourceWindowManager(\n         Provider<SatelliteManager> pSatelliteManager, \n         Provider<Satellite> pSatellite,\n         SourceServerOperations server,\n         EventBus events,\n         FileTypeRegistry registry)\n   {\n      events_ = events;\n      server_ = server;\n      pSatelliteManager_ = pSatelliteManager;\n      pSatellite_ = pSatellite;\n      events_.addHandler(PopoutDocEvent.TYPE, this);\n      events_.addHandler(SourceDocAddedEvent.TYPE, this);\n      events_.addHandler(LastSourceDocClosedEvent.TYPE, this);\n      events_.addHandler(SatelliteClosedEvent.TYPE, this);\n      events_.addHandler(DocTabDragStartedEvent.TYPE, this);\n      \n      // the main window maintains an array of all open source documents \n      // across all satellites; rather than attempt to synchronize this list \n      // among satellites, the main window exposes it on its window object for\n      // the satellites to read \n      if (isMainSourceWindow())\n      {\n         exportSourceDocs();\n      }\n   }","commit_id":"854d8920aae896d88a24e04f503630e4dce4a42f","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void endDrag(final Event evt)\n      {\n         // remove the properties used to position for dragging\n         dragElement_.getStyle().clearLeft();\n         dragElement_.getStyle().clearPosition();\n         dragElement_.getStyle().clearZIndex();\n         dragElement_.getStyle().clearDisplay();\n         \n         // insert this tab where the placeholder landed\n         dragTabsHost_.removeChild(dragElement_);\n         dragTabsHost_.insertAfter(dragElement_, dragPlaceholder_);\n         dragTabsHost_.removeChild(dragPlaceholder_);\n\n         // finish dragging\n         DOM.releaseCapture(getElement());\n         dragging_ = false;\n         \n         // unsink mousedown/mouseup and simulate a click to activate the tab\n         simulateClick(evt);\n         \n         // let observer know we moved; adjust the destination position one to\n         // the left if we're right of the start position to account for the\n         // position of the tab prior to movement\n         if (startPos_ != destPos_)\n         {\n            TabReorderEvent event = new TabReorderEvent(startPos_, destPos_);\n            fireEvent(event);\n         }\n      }","id":88481,"modified_method":"private void endDrag(final Event evt)\n      {\n         // remove the properties used to position for dragging\n         if (dragElement_ != null)\n         {\n            dragElement_.getStyle().clearLeft();\n            dragElement_.getStyle().clearPosition();\n            dragElement_.getStyle().clearZIndex();\n            dragElement_.getStyle().clearDisplay();\n            \n            // insert this tab where the placeholder landed\n            dragTabsHost_.removeChild(dragElement_);\n            dragTabsHost_.insertAfter(dragElement_, dragPlaceholder_);\n         }\n         \n         dragTabsHost_.removeChild(dragPlaceholder_);\n\n         // finish dragging\n         DOM.releaseCapture(getElement());\n         dragging_ = false;\n         \n         // unsink mousedown/mouseup and simulate a click to activate the tab\n         simulateClick(evt);\n         \n         // let observer know we moved; adjust the destination position one to\n         // the left if we're right of the start position to account for the\n         // position of the tab prior to movement\n         if (startPos_ != destPos_)\n         {\n            TabReorderEvent event = new TabReorderEvent(startPos_, destPos_);\n            fireEvent(event);\n         }\n      }","commit_id":"f1cbc86ae0e99d272f1e2ca51a2b097fe38cbb6e","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n      public void onBrowserEvent(Event event)\n      {\n         if (event.getType() == \"drag\")\n         {\n            drag(event);\n         }\n         else if (event.getType() == \"dragstart\")\n         {\n         }\n         else if (event.getType() == \"dragenter\")\n         {\n            beginDrag(event);\n            event.preventDefault();\n         }\n         else if (event.getType() == \"dragover\")\n         {\n            event.preventDefault();\n         }\n         else if (event.getType() == \"drop\")\n         {\n            endDrag(event);\n         }\n      }","id":88482,"modified_method":"@Override\n      public void onBrowserEvent(Event event)\n      {\n         if (event.getType() == \"drag\")\n         {\n            drag(event);\n         }\n         else if (event.getType() == \"dragstart\")\n         {\n         }\n         else if (event.getType() == \"dragenter\")\n         {\n            if (!dragging_)\n               beginDrag(event);\n            event.preventDefault();\n         }\n         else if (event.getType() == \"dragover\")\n         {\n            event.preventDefault();\n         }\n         else if (event.getType() == \"drop\")\n         {\n            endDrag(event);\n         }\n      }","commit_id":"f1cbc86ae0e99d272f1e2ca51a2b097fe38cbb6e","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void commitPosition(int pos)\n      {\n         lastElementX_ = pos;\n\n         // move element to its new position\n         dragElement_.getStyle().setLeft(lastElementX_, Unit.PX);\n\n         // check to see if we're overlapping with another tab \n         for (int i = 0; i < dragTabsHost_.getChildCount(); i++)\n         {\n            // skip non-element DOM nodes\n            Node node = dragTabsHost_.getChild(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE)\n            {\n               continue;\n            }\n            // skip the element we're dragging and elements that are not tabs\n            Element ele = (Element)node;\n            if (ele == dragElement_ || \n                ele.getClassName().indexOf(\"gwt-TabLayoutPanelTab\") < 0)\n            {\n               continue;\n            }\n\n            int left = DomUtils.leftRelativeTo(dragTabsHost_, ele);\n            int right = left + ele.getClientWidth();\n            int minOverlap = Math.min(dragElement_.getClientWidth() / 2, \n                  ele.getClientWidth() / 2);\n\n            // a little complicated: compute the number of overlapping pixels\n            // with this element; if the overlap is more than half of our width\n            // (or the width of the candidate), it's swapping time\n            if (Math.min(lastElementX_ + dragElement_.getClientWidth(), right) - \n                Math.max(lastElementX_, left) >= minOverlap)\n            {\n               dragTabsHost_.removeChild(dragPlaceholder_);\n               if (candidatePos_ > i)\n               {\n                  dragTabsHost_.insertBefore(dragPlaceholder_, ele);\n               }\n               else\n               {\n                  dragTabsHost_.insertAfter(dragPlaceholder_, ele);\n               }\n               candidatePos_ = i;\n\n               // account for the extra element when moving to the right of the\n               // original location\n               destPos_ = startPos_ <= candidatePos_ ? \n                     candidatePos_ - 1 : candidatePos_;\n            }\n         }\n      }","id":88483,"modified_method":"private void commitPosition(int pos)\n      {\n         lastElementX_ = pos;\n\n         // check to see if we're overlapping with another tab \n         for (int i = 0; i < dragTabsHost_.getChildCount(); i++)\n         {\n            // skip non-element DOM nodes\n            Node node = dragTabsHost_.getChild(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE)\n            {\n               continue;\n            }\n            // skip the element we're dragging and elements that are not tabs\n            Element ele = (Element)node;\n            if (ele == dragElement_ || \n                ele.getClassName().indexOf(\"gwt-TabLayoutPanelTab\") < 0)\n            {\n               continue;\n            }\n\n            int left = DomUtils.leftRelativeTo(dragTabsHost_, ele);\n            int right = left + ele.getClientWidth();\n            int minOverlap = Math.min(initDragWidth_ / 2, \n                  ele.getClientWidth() / 2);\n\n            // a little complicated: compute the number of overlapping pixels\n            // with this element; if the overlap is more than half of our width\n            // (or the width of the candidate), it's swapping time\n            if (Math.min(lastElementX_ + initDragWidth_, right) - \n                Math.max(lastElementX_, left) >= minOverlap)\n            {\n               dragTabsHost_.removeChild(dragPlaceholder_);\n               if (candidatePos_ > i)\n               {\n                  dragTabsHost_.insertBefore(dragPlaceholder_, ele);\n               }\n               else\n               {\n                  dragTabsHost_.insertAfter(dragPlaceholder_, ele);\n               }\n               candidatePos_ = i;\n               Debug.devlog(lastElementX_ + \" - \" + candidatePos_);\n\n               // account for the extra element when moving to the right of the\n               // original location\n               destPos_ = startPos_ <= candidatePos_ ? \n                     candidatePos_ - 1 : candidatePos_;\n            }\n         }\n      }","commit_id":"f1cbc86ae0e99d272f1e2ca51a2b097fe38cbb6e","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void beginDrag(Event evt)\n      {\n         String docId = initDragDocId_;\n         int dragTabWidth = initDragWidth_;\n         \n         // attempt to ascertain whether the element being dragged is one of\n         // our own documents\n         for (DocTab tab: docTabs_)\n         {\n            if (tab.getDocId() == docId)\n            {\n               dragElement_ = tab.getElement();\n               break;\n            }\n         }\n         \n         // set drag element state\n         dragging_ = true;\n         dragTabsHost_ = getTabBarElement();\n         dragScrollHost_ = dragTabsHost_.getParentElement();\n         outOfBounds_ = 0;\n         candidatePos_ = 0;\n\n         // find the current position of this tab among its siblings--we'll use\n         // this later to determine whether to shift siblings left or right\n         if (dragElement_ != null)\n         {\n            for (int i = 0; i < dragTabsHost_.getChildCount(); i++)\n            {\n               Node node = dragTabsHost_.getChild(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE)\n               {\n                  if (Element.as(node) == dragElement_)\n                  {\n                     candidatePos_ = i;\n                     destPos_ = i;\n                  }\n                  // the relative position of the last node determines how far we\n                  // can drag--add 10px so it stretches a little\n                  dragMax_ = DomUtils.leftRelativeTo(dragTabsHost_, Element.as(node)) \n                        + (Element.as(node).getClientWidth() - dragElement_.getClientWidth())\n                        + 10;\n               }\n            }\n         }\n         startPos_ = candidatePos_;\n\n         // snap the element out of the tabset\n         lastCursorX_= evt.getClientX();\n         \n         // if we're dragging one of our own tabs, snap it out of the \n         // tabset\n         if (dragElement_ != null)\n         {\n            lastElementX_ = DomUtils.leftRelativeTo(dragTabsHost_, dragElement_);\n\n            dragElement_.getStyle().setPosition(Position.ABSOLUTE);\n            dragElement_.getStyle().setLeft(lastElementX_, Unit.PX);\n            dragElement_.getStyle().setZIndex(100);\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                 dragElement_.getStyle().setDisplay(Display.NONE);\n               }\n            });\n         }\n\n         // create the placeholder that shows where this tab will go when the\n         // mouse is released\n         dragPlaceholder_ = Document.get().createDivElement();\n         dragPlaceholder_.getStyle().setWidth(dragTabWidth, Unit.PX);\n         dragPlaceholder_.getStyle().setHeight(100, Unit.PCT);\n         dragPlaceholder_.getStyle().setDisplay(Display.INLINE_BLOCK);\n         dragPlaceholder_.getStyle().setPosition(Position.RELATIVE);\n         dragPlaceholder_.getStyle().setFloat(Float.LEFT);\n         dragPlaceholder_.getStyle().setBorderStyle(BorderStyle.DOTTED);\n         dragPlaceholder_.getStyle().setBorderColor(\"#414243\");\n         dragPlaceholder_.getStyle().setBorderWidth(2, Unit.PX);\n         dragPlaceholder_.getStyle().setProperty(\"boxSizing\", \"border-box\");\n         dragPlaceholder_.getStyle().setProperty(\"borderRadius\", \"3px\");\n         dragPlaceholder_.getStyle().setProperty(\"borderBottom\", \"0px\");\n         \n         if (dragElement_ != null)\n            dragTabsHost_.insertAfter(dragPlaceholder_, dragElement_);\n      }","id":88484,"modified_method":"public void beginDrag(Event evt)\n      {\n         String docId = initDragDocId_;\n         int dragTabWidth = initDragWidth_;\n         \n         // set drag element state\n         dragging_ = true;\n         dragTabsHost_ = getTabBarElement();\n         dragScrollHost_ = dragTabsHost_.getParentElement();\n         outOfBounds_ = 0;\n         candidatePos_ = null;\n\n         // figure out which tab the cursor is over so we can use this as the\n         // start position in the drag\n         Element ele = DomUtils.elementFromPoint(evt.getClientX(), \n               evt.getClientY());\n         Debug.logObject(ele);\n         do\n         {\n            if (ele.getClassName().contains(\"gwt-TabLayoutPanelTabs\"))\n            {\n               // the cursor is over the tab panel itself--append to end\n               candidatePos_ = docTabs_.size() - 1;\n               Debug.devlog(\"panel drag: \" + candidatePos_);\n               break;\n            }\n            else if (ele.getClassName().contains(\"gwt-TabLayoutPanelTab \"))\n            {\n               // the cursor is inside a tab--figure out which one\n               for (int i = 0; i < dragTabsHost_.getChildCount(); i++)\n               {\n                  Node node = dragTabsHost_.getChild(i);\n                  if (node.getNodeType() == Node.ELEMENT_NODE &&\n                      Element.as(node) == ele)\n                  {\n                     candidatePos_ = i;\n                     Debug.devlog(\"tab drag: \" + candidatePos_);\n                     break;\n                  }\n               }\n               break;\n            }\n            ele = ele.getParentElement();\n         } while (ele != null && ele != Document.get().getBody());\n         \n         // couldn't figure out where to drop tab\n         if (candidatePos_ == null)\n            return;\n\n         // the relative position of the last node determines how far we\n         // can drag--add 10px so it stretches a little\n         dragMax_ = DomUtils.leftRelativeTo(dragTabsHost_, \n               getLastChildElement(dragTabsHost_)) + \n               getLastChildElement(dragTabsHost_).getClientWidth() + \n               10;\n         lastCursorX_= evt.getClientX();\n         lastElementX_ = DomUtils.leftRelativeTo(\n               dragTabsHost_, Element.as(dragTabsHost_.getChild(candidatePos_)));\n         \n         // attempt to ascertain whether the element being dragged is one of\n         // our own documents\n         for (DocTab tab: docTabs_)\n         {\n            if (tab.getDocId() == docId)\n            {\n               dragElement_ = tab.getElement();\n               break;\n            }\n         }\n         \n         // if we're dragging one of our own tabs, snap it out of the \n         // tabset\n         if (dragElement_ != null)\n         {\n            dragElement_.getStyle().setPosition(Position.ABSOLUTE);\n            dragElement_.getStyle().setLeft(lastElementX_, Unit.PX);\n            dragElement_.getStyle().setZIndex(100);\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                 dragElement_.getStyle().setDisplay(Display.NONE);\n               }\n            });\n         }\n\n         // create the placeholder that shows where this tab will go when the\n         // mouse is released\n         dragPlaceholder_ = Document.get().createDivElement();\n         dragPlaceholder_.getStyle().setWidth(dragTabWidth, Unit.PX);\n         dragPlaceholder_.getStyle().setHeight(100, Unit.PCT);\n         dragPlaceholder_.getStyle().setDisplay(Display.INLINE_BLOCK);\n         dragPlaceholder_.getStyle().setPosition(Position.RELATIVE);\n         dragPlaceholder_.getStyle().setFloat(Float.LEFT);\n         dragPlaceholder_.getStyle().setBorderStyle(BorderStyle.DOTTED);\n         dragPlaceholder_.getStyle().setBorderColor(\"#414243\");\n         dragPlaceholder_.getStyle().setBorderWidth(2, Unit.PX);\n         dragPlaceholder_.getStyle().setProperty(\"boxSizing\", \"border-box\");\n         dragPlaceholder_.getStyle().setProperty(\"borderRadius\", \"3px\");\n         dragPlaceholder_.getStyle().setProperty(\"borderBottom\", \"0px\");\n         Debug.devlog(\"inserting placeholder\");\n         Debug.logObject(dragTabsHost_.getChild(candidatePos_));\n         dragTabsHost_.insertAfter(dragPlaceholder_, \n               dragTabsHost_.getChild(candidatePos_));\n      }","commit_id":"f1cbc86ae0e99d272f1e2ca51a2b097fe38cbb6e","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void drag(Event evt) \n      {\n         int offset = evt.getClientX() - lastCursorX_;\n         lastCursorX_ = evt.getClientX();\n         // cursor is outside the tab area\n         if (outOfBounds_ != 0)\n         {\n            // did the cursor move back in bounds? \n            if (outOfBounds_ + offset > 0 != outOfBounds_ > 0)\n            {\n               outOfBounds_ = 0;\n               offset = outOfBounds_ + offset;\n            }\n            else \n            {\n               // cursor is still out of bounds\n               outOfBounds_ += offset;\n               return;\n            }\n         }\n         int targetLeft = lastElementX_ + offset;\n         int targetRight = targetLeft + dragElement_.getClientWidth();\n         int scrollLeft = dragScrollHost_.getScrollLeft();\n         if (targetLeft < 0)\n         {\n            // dragged past the beginning - lock to beginning\n            targetLeft = 0;\n            outOfBounds_ += offset;\n         }\n         else if (targetLeft > dragMax_)\n         {\n            // dragged past the end - lock to the end\n            targetLeft = dragMax_;\n            outOfBounds_ += offset;\n         }\n\n         if (targetLeft - scrollLeft < SCROLL_THRESHOLD &&\n               scrollLeft > 0)\n         {\n            // dragged past scroll threshold, to the left--autoscroll \n            outOfBounds_ = (targetLeft - scrollLeft) - SCROLL_THRESHOLD;\n            targetLeft = scrollLeft + SCROLL_THRESHOLD;\n            Scheduler.get().scheduleFixedPeriod(new RepeatingCommand()\n            {\n               @Override\n               public boolean execute()\n               {\n                  return autoScroll(-1);\n               }\n            }, 5);\n         } \n         else if (targetRight + SCROLL_THRESHOLD > scrollLeft + \n                     dragScrollHost_.getClientWidth() &&\n                  scrollLeft < dragScrollHost_.getScrollWidth() - \n                     dragScrollHost_.getClientWidth())\n         {\n            // dragged past scroll threshold, to the right--autoscroll \n            outOfBounds_ = (targetRight + SCROLL_THRESHOLD) - \n                  (scrollLeft + dragScrollHost_.getClientWidth());\n            targetLeft = scrollLeft + dragScrollHost_.getClientWidth() - \n                  (dragElement_.getClientWidth() + SCROLL_THRESHOLD);\n            Scheduler.get().scheduleFixedPeriod(new RepeatingCommand()\n            {\n               @Override\n               public boolean execute()\n               {\n                  return autoScroll(1);\n               }\n            }, 5);\n         } \n         commitPosition(targetLeft);\n      }","id":88485,"modified_method":"private void drag(Event evt) \n      {\n         int offset = evt.getClientX() - lastCursorX_;\n         lastCursorX_ = evt.getClientX();\n         // cursor is outside the tab area\n         if (outOfBounds_ != 0)\n         {\n            // did the cursor move back in bounds? \n            if (outOfBounds_ + offset > 0 != outOfBounds_ > 0)\n            {\n               outOfBounds_ = 0;\n               offset = outOfBounds_ + offset;\n            }\n            else \n            {\n               // cursor is still out of bounds\n               outOfBounds_ += offset;\n               return;\n            }\n         }\n\n         int targetLeft = lastElementX_ + offset;\n         int targetRight = targetLeft + initDragWidth_;\n         int scrollLeft = dragScrollHost_.getScrollLeft();\n         if (targetLeft < 0)\n         {\n            // dragged past the beginning - lock to beginning\n            targetLeft = 0;\n            outOfBounds_ += offset;\n         }\n         else if (targetLeft > dragMax_)\n         {\n            // dragged past the end - lock to the end\n            targetLeft = dragMax_;\n            outOfBounds_ += offset;\n         }\n\n         if (targetLeft - scrollLeft < SCROLL_THRESHOLD &&\n               scrollLeft > 0)\n         {\n            // dragged past scroll threshold, to the left--autoscroll \n            outOfBounds_ = (targetLeft - scrollLeft) - SCROLL_THRESHOLD;\n            targetLeft = scrollLeft + SCROLL_THRESHOLD;\n            Scheduler.get().scheduleFixedPeriod(new RepeatingCommand()\n            {\n               @Override\n               public boolean execute()\n               {\n                  return autoScroll(-1);\n               }\n            }, 5);\n         } \n         else if (targetRight + SCROLL_THRESHOLD > scrollLeft + \n                     dragScrollHost_.getClientWidth() &&\n                  scrollLeft < dragScrollHost_.getScrollWidth() - \n                     dragScrollHost_.getClientWidth())\n         {\n            // dragged past scroll threshold, to the right--autoscroll \n            outOfBounds_ = (targetRight + SCROLL_THRESHOLD) - \n                  (scrollLeft + dragScrollHost_.getClientWidth());\n            targetLeft = scrollLeft + dragScrollHost_.getClientWidth() - \n                  (initDragWidth_ + SCROLL_THRESHOLD);\n            Scheduler.get().scheduleFixedPeriod(new RepeatingCommand()\n            {\n               @Override\n               public boolean execute()\n               {\n                  return autoScroll(1);\n               }\n            }, 5);\n         } \n         commitPosition(targetLeft);\n      }","commit_id":"f1cbc86ae0e99d272f1e2ca51a2b097fe38cbb6e","url":"https://github.com/rstudio/rstudio"},{"original_method":"private boolean addParameterToConstructor(final Project project, final PsiFile file, final Editor editor, PsiMethod constructor) throws IncorrectOperationException {\n    final PsiParameter[] parameters = constructor.getParameterList().getParameters();\n    PsiExpression[] expressions = new PsiExpression[parameters.length+1];\n    PsiElementFactory factory = JavaPsiFacade.getInstance(file.getProject()).getElementFactory();\n    for (int i = 0; i < parameters.length; i++) {\n      PsiParameter parameter = parameters[i];\n      String value = PsiTypesUtil.getDefaultValueOfType(parameter.getType());\n      expressions[i] = factory.createExpressionFromText(value, parameter);\n    }\n    expressions[parameters.length] = factory.createExpressionFromText(getField().getName(), constructor);\n    final SmartPointerManager manager = SmartPointerManager.getInstance(getField().getProject());\n    final SmartPsiElementPointer constructorPointer = manager.createSmartPsiElementPointer(constructor);\n\n    final ChangeMethodSignatureFromUsageFix addParamFix = new ChangeMethodSignatureFromUsageFix(constructor, expressions, PsiSubstitutor.EMPTY, constructor, true, 1);\n    addParamFix.invoke(project, editor, file);\n    return ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>() {\n      public Boolean compute() {\n        return doCreate(project, editor, parameters, constructorPointer, addParamFix);\n      }\n    });\n  }","id":88486,"modified_method":"private boolean addParameterToConstructor(final Project project, final PsiFile file, final Editor editor, PsiMethod constructor) throws IncorrectOperationException {\n    final PsiParameter[] parameters = constructor.getParameterList().getParameters();\n    PsiExpression[] expressions = new PsiExpression[parameters.length+1];\n    PsiElementFactory factory = JavaPsiFacade.getInstance(file.getProject()).getElementFactory();\n    for (int i = 0; i < parameters.length; i++) {\n      PsiParameter parameter = parameters[i];\n      String value = PsiTypesUtil.getDefaultValueOfType(parameter.getType());\n      expressions[i] = factory.createExpressionFromText(value, parameter);\n    }\n    expressions[parameters.length] = factory.createExpressionFromText(getField().getName(), constructor);\n    if (constructor.isVarArgs()) {\n      ArrayUtil.swap(expressions, expressions.length - 1, expressions.length - 2);\n    }\n    final SmartPointerManager manager = SmartPointerManager.getInstance(getField().getProject());\n    final SmartPsiElementPointer constructorPointer = manager.createSmartPsiElementPointer(constructor);\n\n    final ChangeMethodSignatureFromUsageFix addParamFix = new ChangeMethodSignatureFromUsageFix(constructor, expressions, PsiSubstitutor.EMPTY, constructor, true, 1);\n    if (addParamFix.isAvailable(project, editor, file)) {\n      addParamFix.invoke(project, editor, file);\n    }\n    return ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>() {\n      public Boolean compute() {\n        return doCreate(project, editor, parameters, constructorPointer, addParamFix);\n      }\n    });\n  }","commit_id":"865c7b0bcc85e402a99b159f6ce8e242e89acb11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void characters (char ch[], int start, int length) {\n      if (elementName == null)\n        return;\n\n      String chValue = new String(ch, start, length);\n\n      if (elementName.equals(\"name\")) {\n        svcItem.setName(chValue);\n      } else if (elementName.equals(\"class\")) {\n        svcItem.setJavaClass(chValue);\n      } else if (elementName.equals(\"method\")) {\n        svcItem.setStartMethod(chValue);\n      } else if (elementName.equals(\"datatype\") && argProcessing) {\n          argItem.setDataType(chValue);\n      } else if (elementName.equals(\"value\")) {\n        if (argProcessing) {\n          argItem.addValue(chValue);\n        }\n      }\n    }","id":88487,"modified_method":"public void characters (char ch[], int start, int length) {\n      if (elementName == null)\n        return;\n\n      String chValue = new String(ch, start, length);\n\n      if (elementName.equals(\"name\")) {\n        svcItem.setName(chValue);\n      } else if (elementName.equals(\"class\")) {\n        svcItem.setJavaClass(chValue);\n      } else if (elementName.equals(\"jndi_name\")) {\n        svcItem.setJndiName(chValue);\n      } else if (elementName.equals(\"method\")) {\n        svcItem.setStartMethod(chValue);\n      } else if (elementName.equals(\"datatype\") && argProcessing) {\n          argItem.setDataType(chValue);\n      } else if (elementName.equals(\"value\")) {\n        if (argProcessing) {\n          argItem.addValue(chValue);\n        }\n      }\n    }","commit_id":"5d8d4543535d19cca01ab7f2e3b75476b8fb78c7","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void endElement (String namespaceURI, String localName, String qName) {\n      elementName = null;  // The element has ended.  Null it.\n\n      if (qName.equals(\"service\")) {\n        String name = svcItem.getName();\n        String javaClass = svcItem.getJavaClass();\n        Class[] classNames = null;\n        Object[] args = null;\n        Class svcClass = null;\n\n        try {\n          svcClass   = Class.forName(javaClass);\n          args       = svcItem.getArguments();\n          classNames = svcItem.getArgumentClasses();\n        } catch (java.lang.ClassNotFoundException cnfe) {\n          outputMessage(\"Class not found - \" + cnfe.getMessage());\n          return;\n        } catch (Exception e) {\n          outputMessage(\"The service \\\"\" + svcItem.getName() + \"\\\" FAILED TO START.\");\n          return;\n        }\n\n        try {\n          Method startMethod = svcClass.getMethod(svcItem.getStartMethod(), classNames);\n          Object obj = svcClass.newInstance();\n          startMethod.invoke(obj, args);\n          outputMessage(\"The service \\\"\" + svcItem.getName() + \"\\\" service started.\");\n          return;\n        } catch (java.lang.NoSuchMethodException nsme) {\n          outputMessage(\"Method not found - \" + nsme.getMessage());\n        } catch (java.lang.Exception ex) {\n          outputMessage(\"General Exception - \" + ex.getMessage());\n          ex.printStackTrace();\n        }\n        outputMessage(\"The service \\\"\" + svcItem.getName() + \"\\\" FAILED TO START.\");\n\n      } else if (qName.equals(\"arguments\")) {\n        argProcessing = false;\n      } else if (qName.equals(\"argitem\")) {\n        svcItem.addArgument(argItem);\n        argItem = null;\n      }\n    }","id":88488,"modified_method":"public void endElement (String namespaceURI, String localName, String qName) {\n      elementName = null;  // The element has ended.  Null it.\n\n      if (qName.equals(\"service\")) {\n        String name = svcItem.getName();\n        String javaClass = svcItem.getJavaClass();\n        Class[] classNames = null;\n        Object[] args = null;\n        Class svcClass = null;\n\n        try {\n          svcClass   = Class.forName(javaClass);\n          args       = svcItem.getArguments();\n          classNames = svcItem.getArgumentClasses();\n        } catch (java.lang.ClassNotFoundException cnfe) {\n          outputMessage(\"Class not found - \" + cnfe.getMessage());\n          return;\n        } catch (Exception e) {\n          outputMessage(\"The service \\\"\" + svcItem.getName() + \"\\\" FAILED TO START.\");\n          return;\n        }\n\n        try {\n            Object obj=null;\n            Object returnObject=null;\n            \n          // check if any method is specified\n          if(svcItem.getStartMethod()!=null) {\n              Method startMethod = svcClass.getMethod(svcItem.getStartMethod(), classNames);\n              if(Modifier.isStatic(startMethod.getModifiers())) {\n                  // no need to instantiate an object\n                  returnObject=startMethod.invoke(null,args);\n              } else {\n                  // instantiate \n                  obj = svcClass.newInstance();\n                  returnObject=startMethod.invoke(obj,args);\n              }\n              outputMessage(\"initialized \\\"\" + svcItem.getName() + \"\\\"\");\n          }\n \n          // check if jndi binding needed\n          if(svcItem.getJndiName()!=null) {\n              if(returnObject!=null) {\n                  // a non-void method was specified\n                  // in the service description, bind \n                  // returned object\n                  servicesContext.bind(svcItem.getJndiName(), returnObject);\n                  outputMessage(\"bound intialization result for service \\\"\" + svcItem.getName() + \"\\\"\");\n              } else {\n                  if(obj==null) {\n                      // instantiate\n                      obj = svcClass.newInstance();\n                  }\n                  servicesContext.bind(svcItem.getJndiName(), obj);\n                  outputMessage(\"bound class instance for service \\\"\" + svcItem.getName() + \"\\\"\");\n              }\n          }\n          return;\n        } catch (java.lang.NoSuchMethodException nsme) {\n          outputMessage(\"Method not found - \" + nsme.getMessage());\n        } catch (java.lang.Exception ex) {\n          outputMessage(\"General Exception - \" + ex.getMessage());\n          ex.printStackTrace();\n        }\n        outputMessage(\"The service \\\"\" + svcItem.getName() + \"\\\" FAILED TO START.\");\n\n      } else if (qName.equals(\"arguments\")) {\n        argProcessing = false;\n      } else if (qName.equals(\"argitem\")) {\n        svcItem.addArgument(argItem);\n        argItem = null;\n      }\n    }","commit_id":"5d8d4543535d19cca01ab7f2e3b75476b8fb78c7","url":"https://github.com/Jasig/uPortal"},{"original_method":"public static void startServices() throws Exception {\n\n    InputStream svcDesciptor = ResourceLoader.getResourceAsStream(ExternalServices.class, \"/properties/services.xml\");\n\n    if (svcDesciptor != null) {\n      ExternalServices svcMgr = new ExternalServices();\n      SAXParser parser = svcMgr.createParser();\n      parser.parse(svcDesciptor, svcMgr.svcHandler);\n    }\n  }","id":88489,"modified_method":"public ExternalServices(Context servicesContext) {\n    this.servicesContext=servicesContext;\n    svcHandler = new ServiceHandler();\n  }","commit_id":"5d8d4543535d19cca01ab7f2e3b75476b8fb78c7","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Checks if the method is accepted as a JAXB property getter.\n     */\n    static boolean isMethodAccepted(Method method, XmlAccessType accessType) {\n        // We only accept non static property getters which are not marked @XmlTransient\n        if (Modifier.isStatic(method.getModifiers()) \n            || method.isAnnotationPresent(XmlTransient.class)\n            || !Modifier.isPublic(method.getModifiers())) {\n            return false;\n        }\n\n        // must not have parameters and return type must not be void\n        if (method.getReturnType() == Void.class \n            || method.getParameterTypes().length != 0\n            || method.getDeclaringClass().equals(Throwable.class)) {\n            return false;\n        }\n\n        int beginIndex = 3;\n        if (method.getName().startsWith(\"is\")) {\n            beginIndex = 2;\n        }\n        Method setter = null;\n        try {\n            setter = method.getDeclaringClass()\n                .getMethod(\"set\" + method.getName().substring(beginIndex),\n                           new Class[] {method.getReturnType()});\n        } catch (Exception e) {\n            //getter, but no setter\n        }\n        if (setter == null \n            || setter.isAnnotationPresent(XmlTransient.class)\n            || !Modifier.isPublic(setter.getModifiers())) {\n            return false;\n        }\n\n        if (accessType == XmlAccessType.NONE\n            || accessType == XmlAccessType.FIELD) {\n            return checkJaxbAnnotation(method.getAnnotations());\n        } else {\n            return true;\n        }\n    }","id":88490,"modified_method":"/**\n     * Checks if the method is accepted as a JAXB property getter.\n     */\n    static boolean isMethodAccepted(Method method, XmlAccessType accessType) {\n        // We only accept non static property getters which are not marked @XmlTransient\n        if (Modifier.isStatic(method.getModifiers()) \n                || method.isAnnotationPresent(XmlTransient.class)\n                || !Modifier.isPublic(method.getModifiers())\n                || \"getClass\".equals(method.getName())) {\n            return false;\n        }\n\n        // must not have parameters and return type must not be void\n        if (method.getReturnType() == Void.class \n            || method.getParameterTypes().length != 0\n            || method.getDeclaringClass().equals(Throwable.class)) {\n            return false;\n        }\n        if (method.getName().startsWith(\"get\")\n                || method.getName().startsWith(\"is\")) { \n                //continue with below check.\n        } else {\n            return false;\n        }\n        int beginIndex = 3;\n        if (method.getName().startsWith(\"is\")) {\n            beginIndex = 2;\n        }\n        \n        Method setter = null;\n        try {\n            setter = method.getDeclaringClass()\n                .getMethod(\"set\" + method.getName().substring(beginIndex),\n                           new Class[] {method.getReturnType()});\n        } catch (Exception e) {\n            //getter, but no setter\n        }\n        if ((setter != null) \n                && ((setter.isAnnotationPresent(XmlTransient.class)\n                 || !Modifier.isPublic(setter.getModifiers())))) {\n            return false;\n             \n        }\n\n        if (accessType == XmlAccessType.NONE\n            || accessType == XmlAccessType.FIELD) {\n            return checkJaxbAnnotation(method.getAnnotations());\n        } else {\n            return true;\n        }\n    }","commit_id":"74b4ee8bce0652c21a486a1539dcb9851d2c483b","url":"https://github.com/apache/cxf"},{"original_method":"public static Exception unmarshallException(Unmarshaller u, \n                                                Object source,\n                                                MessagePartInfo part) {\n        XMLStreamReader reader;\n        if (source instanceof XMLStreamReader) {\n            reader = (XMLStreamReader)source;\n        } else if (source instanceof Element) {\n            reader = StaxUtils.createXMLStreamReader((Element)source);\n            try {\n                // advance into the node\n                reader.nextTag();\n            } catch (XMLStreamException e) {\n                // ignore\n            }\n        } else {\n            throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n        }\n        try {\n            QName qn = part.getElementQName();\n            if (!qn.equals(reader.getName())) {\n                throw new Fault(new Message(\"ELEMENT_NAME_MISMATCH\", LOG, qn, reader.getName()));\n            }\n\n            Class<?> cls = part.getTypeClass();\n            Object obj = null;\n            try {\n                Constructor<?> cons = cls.getConstructor();\n                obj = cons.newInstance();\n            } catch (NoSuchMethodException nse) {\n                Constructor<?> cons = cls.getConstructor(new Class[] {String.class});\n                obj = cons.newInstance(new Object[1]);\n            }\n\n            XmlAccessType accessType = Utils.getXmlAccessType(cls);\n            reader.nextTag();\n            while (reader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                QName q = reader.getName();\n                String fieldName = q.getLocalPart();\n                Field f = Utils.getField(cls, accessType, fieldName);\n                if (f != null) {\n                    Type type = f.getGenericType();\n                    ReflectionUtil.setAccessible(f);\n                    if (JAXBSchemaInitializer.isArray(type)) {\n                        Class<?> compType = JAXBSchemaInitializer.getArrayComponentType(type);\n                        List<Object> ret = unmarshallArray(u, reader, q, compType, createList(type));\n                        Object o = ret;\n                        if (!isList(type)) {\n                            if (compType.isPrimitive()) {\n                                o = java.lang.reflect.Array.newInstance(compType, ret.size());\n                                for (int x = 0; x < ret.size(); x++) {\n                                    Array.set(o, x, ret.get(x));\n                                }\n                            } else {\n                                o = ret.toArray((Object[]) Array.newInstance(compType, ret.size()));\n                            }\n                        }\n\n                        f.set(obj, o);\n                    } else {\n                        Object o = getElementValue(u.unmarshal(reader, Utils.getFieldType(f)));\n                        Utils.setFieldValue(f, obj, o);\n                    }\n                } else {\n                    String s = Character.toUpperCase(q.getLocalPart().charAt(0))\n                               + q.getLocalPart().substring(1);\n                    Method m = Utils.getMethod(cls, accessType, \"get\" + s);\n                    if (m == null) {\n                        m = Utils.getMethod(cls, accessType, \"is\" + s);\n                    }\n                    Type type = m.getGenericReturnType();\n                    Method m2 = Utils.getMethod(cls, accessType, \"set\" + s, m.getReturnType());\n                    if (JAXBSchemaInitializer.isArray(type)) {\n                        Class<?> compType = JAXBSchemaInitializer\n                            .getArrayComponentType(type);\n                        List<Object> ret = unmarshallArray(u, reader,\n                                                           q,\n                                                           compType,\n                                                           createList(type));\n                        Object o = ret;\n                        if (!isList(type)) {\n                            if (compType.isPrimitive()) {\n                                o = java.lang.reflect.Array.newInstance(compType, ret.size());\n                                for (int x = 0; x < ret.size(); x++) {\n                                    Array.set(o, x, ret.get(x));\n                                }\n                            } else {\n                                o = ret.toArray((Object[])Array.newInstance(compType, ret.size()));\n                            }\n                        }\n\n                        m2.invoke(obj, o);\n                    } else {\n                        Object o = getElementValue(u.unmarshal(reader, Utils.getMethodReturnType(m)));\n                        Utils.setMethodValue(m, m2, obj, o);\n                    }\n                }\n            }\n            return (Exception)obj;\n        } catch (Exception e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, e.getMessage()), e);\n        }\n    }","id":88491,"modified_method":"public static Exception unmarshallException(Unmarshaller u, \n                                                Object source,\n                                                MessagePartInfo part) {\n        XMLStreamReader reader;\n        if (source instanceof XMLStreamReader) {\n            reader = (XMLStreamReader)source;\n        } else if (source instanceof Element) {\n            reader = StaxUtils.createXMLStreamReader((Element)source);\n            try {\n                // advance into the node\n                reader.nextTag();\n            } catch (XMLStreamException e) {\n                // ignore\n            }\n        } else {\n            throw new Fault(new Message(\"UNKNOWN_SOURCE\", LOG, source.getClass().getName()));\n        }\n        try {\n            QName qn = part.getElementQName();\n            if (!qn.equals(reader.getName())) {\n                throw new Fault(new Message(\"ELEMENT_NAME_MISMATCH\", LOG, qn, reader.getName()));\n            }\n\n            Class<?> cls = part.getTypeClass();\n            Object obj = null;\n            try {\n                Constructor<?> cons = cls.getConstructor();\n                obj = cons.newInstance();\n            } catch (NoSuchMethodException nse) {\n                Constructor<?> cons = cls.getConstructor(new Class[] {String.class});\n                obj = cons.newInstance(new Object[1]);\n            }\n\n            XmlAccessType accessType = Utils.getXmlAccessType(cls);\n            reader.nextTag();\n            while (reader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                QName q = reader.getName();\n                String fieldName = q.getLocalPart();\n                Field f = Utils.getField(cls, accessType, fieldName);\n                if (f != null) {\n                    Type type = f.getGenericType();\n                    ReflectionUtil.setAccessible(f);\n                    if (JAXBSchemaInitializer.isArray(type)) {\n                        Class<?> compType = JAXBSchemaInitializer.getArrayComponentType(type);\n                        List<Object> ret = unmarshallArray(u, reader, q, compType, createList(type));\n                        Object o = ret;\n                        if (!isList(type)) {\n                            if (compType.isPrimitive()) {\n                                o = java.lang.reflect.Array.newInstance(compType, ret.size());\n                                for (int x = 0; x < ret.size(); x++) {\n                                    Array.set(o, x, ret.get(x));\n                                }\n                            } else {\n                                o = ret.toArray((Object[]) Array.newInstance(compType, ret.size()));\n                            }\n                        }\n\n                        f.set(obj, o);\n                    } else {\n                        Object o = getElementValue(u.unmarshal(reader, Utils.getFieldType(f)));\n                        Utils.setFieldValue(f, obj, o);\n                    }\n                } else {\n                    String s = Character.toUpperCase(q.getLocalPart().charAt(0))\n                               + q.getLocalPart().substring(1);\n                    Method m = Utils.getMethod(cls, accessType, \"get\" + s);\n                    if (m == null) {\n                        m = Utils.getMethod(cls, accessType, \"is\" + s);\n                    }\n                    Type type = m.getGenericReturnType();\n                    Object o = null;\n                    if (JAXBSchemaInitializer.isArray(type)) {\n                        Class<?> compType = JAXBSchemaInitializer\n                            .getArrayComponentType(type);\n                        List<Object> ret = unmarshallArray(u, reader,\n                                                           q,\n                                                           compType,\n                                                           createList(type));\n                        o = ret;\n                        if (!isList(type)) {\n                            if (compType.isPrimitive()) {\n                                o = java.lang.reflect.Array.newInstance(compType, ret.size());\n                                for (int x = 0; x < ret.size(); x++) {\n                                    Array.set(o, x, ret.get(x));\n                                }\n                            } else {\n                                o = ret.toArray((Object[])Array.newInstance(compType, ret.size()));\n                            }\n                        }\n                    } else {\n                        o = getElementValue(u.unmarshal(reader, Utils.getMethodReturnType(m)));\n                    }\n                    Method m2 = Utils.getMethod(cls, accessType, \"set\" + s, m.getReturnType());\n                    if (m2 != null) {\n                        if (JAXBSchemaInitializer.isArray(type)) {\n                            m2.invoke(obj, o);\n                        } else {\n                            Utils.setMethodValue(m, m2, obj, o);\n                        }\n                    } else {\n                        Field fn = ReflectionUtil.getDeclaredField(cls, q.getLocalPart());\n                        if (fn != null) {\n                            ReflectionUtil.setAccessible(fn);\n                            fn.set(obj, o);\n                        }\n                    }                \n                }\n            }\n            return (Exception)obj;\n        } catch (Exception e) {\n            throw new Fault(new Message(\"MARSHAL_ERROR\", LOG, e.getMessage()), e);\n        }\n    }","commit_id":"74b4ee8bce0652c21a486a1539dcb9851d2c483b","url":"https://github.com/apache/cxf"},{"original_method":"static boolean isMethodAccepted(Method method, XmlAccessType accessType, boolean acceptSetters) {\n        // ignore bridge, static, @XmlTransient methods plus methods declared in Throwable\n        if (method.isBridge()\n                || Modifier.isStatic(method.getModifiers())\n                || method.isAnnotationPresent(XmlTransient.class)\n                || method.getDeclaringClass().equals(Throwable.class)) {\n            return false;\n        }\n        // Allow only public methods if PUBLIC_MEMBER access is requested\n        if (accessType == XmlAccessType.PUBLIC_MEMBER && !Modifier.isPublic(method.getModifiers())) { \n            return false;\n        }\n        if (isGetter(method)) {\n            // does nothing\n        } else if (isSetter(method)) {\n            if (!acceptSetters) {\n                return false;\n            }\n        } else {\n            // we accept only getters and setters\n            return false;\n        }\n        // let JAXB annotations decide if NONE or FIELD access is requested\n        if (accessType == XmlAccessType.NONE || accessType == XmlAccessType.FIELD) {\n            return JAXBContextInitializer.checkJaxbAnnotation(method.getAnnotations());\n        }\n        // method accepted\n        return true;\n    }","id":88492,"modified_method":"static boolean isMethodAccepted(Method method, XmlAccessType accessType, boolean acceptSetters) {\n        // ignore bridge, static, @XmlTransient methods plus methods declared in Throwable\n        if (method.isBridge()\n                || Modifier.isStatic(method.getModifiers())\n                || method.isAnnotationPresent(XmlTransient.class)\n                || method.getDeclaringClass().equals(Throwable.class)\n                || \"getClass\".equals(method.getName())) {\n            return false;\n        }\n        // Allow only public methods if PUBLIC_MEMBER access is requested\n        if (accessType == XmlAccessType.PUBLIC_MEMBER && !Modifier.isPublic(method.getModifiers())) { \n            return false;\n        }\n        if (isGetter(method)) {\n            // does nothing\n        } else if (isSetter(method)) {\n            if (!acceptSetters) {\n                return false;\n            }\n        } else {\n            // we accept only getters and setters\n            return false;\n        }\n        // let JAXB annotations decide if NONE or FIELD access is requested\n        if (accessType == XmlAccessType.NONE || accessType == XmlAccessType.FIELD) {\n            return JAXBContextInitializer.checkJaxbAnnotation(method.getAnnotations());\n        }\n        // method accepted\n        return true;\n    }","commit_id":"74b4ee8bce0652c21a486a1539dcb9851d2c483b","url":"https://github.com/apache/cxf"},{"original_method":"private static boolean isGetter(Method m) {\n        Class<?> declaringClass = m.getDeclaringClass();\n        if (m.getReturnType() != Void.class && m.getParameterTypes().length == 0) {\n            final int index = getterIndex(m.getName());\n            if (index != -1) {\n                String setterName = \"set\" + m.getName().substring(index);\n                Class<?> paramTypes = m.getReturnType();\n                Method setter = getDeclaredMethod(declaringClass, setterName, paramTypes);\n                if (setter != null && !setter.isAnnotationPresent(XmlTransient.class)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":88493,"modified_method":"private static boolean isGetter(Method m) {\n        Class<?> declaringClass = m.getDeclaringClass();\n        if (m.getReturnType() != Void.class && m.getParameterTypes().length == 0) {\n            final int index = getterIndex(m.getName());\n            if (index != -1) {\n                String setterName = \"set\" + m.getName().substring(index);\n                Class<?> paramTypes = m.getReturnType();\n                Method setter = getDeclaredMethod(declaringClass, setterName, paramTypes);\n                if (setter == null) {\n                    return true;\n                }\n                if (setter != null && !setter.isAnnotationPresent(XmlTransient.class)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"74b4ee8bce0652c21a486a1539dcb9851d2c483b","url":"https://github.com/apache/cxf"},{"original_method":"public static PsiElement[] getRefs(PsiCodeBlock body, final PsiVariable def, PsiElement ref) {\n    try {\n      return new RefsDefs(body) {\n\n        protected int nNext(int index) {\n          return instructions.get(index).nNext();\n        }\n\n        protected int getNext(int index, int no) {\n          return instructions.get(index).getNext(index, no);\n        }\n\n        protected boolean defs() { return false; }\n\n        protected void processInstruction(final Set<PsiElement> res, final Instruction instruction, int index) {\n          if (instruction instanceof ReadVariableInstruction) {\n            ReadVariableInstruction instructionR = (ReadVariableInstruction)instruction;\n            if (instructionR.variable == def) {\n\n              final PsiElement element = flow.getElement(index);\n              element.accept(new PsiRecursiveElementVisitor() {\n                public void visitReferenceExpression(PsiReferenceExpression ref) {\n                  if (ref.resolve() == def) {\n                    res.add(ref);\n                  }\n                }\n              });\n            }\n          }\n        }\n      }.get(def, ref);\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n  }","id":88494,"modified_method":"public static PsiElement[] getRefs(PsiCodeBlock body, final PsiVariable variable, PsiElement def) {\n    try {\n      return new RefsDefs(body) {\n\n        protected int nNext(int index) {\n          return instructions.get(index).nNext();\n        }\n\n        protected int getNext(int index, int no) {\n          return instructions.get(index).getNext(index, no);\n        }\n\n        protected boolean defs() { return false; }\n\n        protected void processInstruction(final Set<PsiElement> res, final Instruction instruction, int index) {\n          if (instruction instanceof ReadVariableInstruction) {\n            ReadVariableInstruction instructionR = (ReadVariableInstruction)instruction;\n            if (instructionR.variable == variable) {\n\n              final PsiElement element = flow.getElement(index);\n              element.accept(new PsiRecursiveElementVisitor() {\n                public void visitReferenceExpression(PsiReferenceExpression ref) {\n                  if (ref.resolve() == variable) {\n                    res.add(ref);\n                  }\n                }\n              });\n            }\n          }\n        }\n      }.get(variable, def);\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement [] get (final PsiVariable def, PsiElement ref) {\n      if (body == null) {\n        return null;\n      }\n\n      final boolean [] visited = new boolean[instructions.size() + 1];\n      visited [visited.length-1] = true; // stop on the code end\n      int elem = flow.getStartOffset(ref);\n\n      // hack: ControlFlow doesn't contains parameters initialization\n      if (elem == -1 && def instanceof PsiParameter) {\n        elem = 0;\n      }\n\n      if (elem != -1) {\n        if (!defs () && instructions.get(elem) instanceof ReadVariableInstruction) {\n          LOG.assertTrue(nNext(elem) == 1);\n          LOG.assertTrue(getNext(elem,0) == elem+1);\n          elem += 1;\n        }\n\n        final Set<PsiElement> res = new THashSet<PsiElement>();\n        class Inner {\n\n          void traverse (int index) {\n            visited [index] = true;\n\n            if (defs ()) {\n              final Instruction instruction = instructions.get(index);\n              processInstruction(res, instruction, index);\n              if (instruction instanceof WriteVariableInstruction) {\n                WriteVariableInstruction instructionW = (WriteVariableInstruction)instruction;\n                if (instructionW.variable == def) {\n                  return;\n                }\n              }\n\n              // hack: ControlFlow doesnn't contains parameters initialization\n              final boolean[] parmsVisited = new boolean [1];\n              if (index == 0 && !parmsVisited [0]) {\n                parmsVisited [0] = true;\n                if (def instanceof PsiParameter) {\n                  res.add(def.getNameIdentifier());\n                }\n              }\n            }\n\n            final int nNext = nNext (index);\n            for (int i = 0; i < nNext; i++) {\n              final int prev = getNext(index, i);\n              if (!visited [prev]) {\n                if (!defs ()) {\n                  final Instruction instruction = instructions.get(prev);\n                  if (instruction instanceof WriteVariableInstruction) {\n                    WriteVariableInstruction instructionW = (WriteVariableInstruction)instruction;\n                    if (instructionW.variable == def) {\n                      continue;\n                    }\n                  } else {\n                    processInstruction(res, instruction, prev);\n                  }\n                }\n                traverse (prev);\n\n              }\n            }\n          }\n        }\n        new Inner ().traverse (elem);\n        return res.toArray(new PsiElement[res.size ()]);\n      }\n      return null;\n    }","id":88495,"modified_method":"public PsiElement [] get (final PsiVariable def, PsiElement ref) {\n      if (body == null) {\n        return null;\n      }\n\n      final boolean [] visited = new boolean[instructions.size() + 1];\n      visited [visited.length-1] = true; // stop on the code end\n      int elem = flow.getStartOffset(ref);\n\n      // hack: ControlFlow doesn't contains parameters initialization\n      if (elem == -1 && def instanceof PsiParameter) {\n        elem = 0;\n      }\n\n      if (elem != -1) {\n        if (!defs () && instructions.get(elem) instanceof ReadVariableInstruction) {\n          LOG.assertTrue(nNext(elem) == 1);\n          LOG.assertTrue(getNext(elem,0) == elem+1);\n          elem += 1;\n        }\n\n        final Set<PsiElement> res = new THashSet<PsiElement>();\n        class Inner {\n\n          void traverse (int index) {\n            visited [index] = true;\n\n            if (defs ()) {\n              final Instruction instruction = instructions.get(index);\n              processInstruction(res, instruction, index);\n              if (instruction instanceof WriteVariableInstruction) {\n                WriteVariableInstruction instructionW = (WriteVariableInstruction)instruction;\n                if (instructionW.variable == def) {\n                  return;\n                }\n              }\n\n              // hack: ControlFlow doesnn't contains parameters initialization\n              final boolean[] parmsVisited = new boolean [1];\n              if (index == 0 && !parmsVisited [0]) {\n                parmsVisited [0] = true;\n                if (def instanceof PsiParameter) {\n                  res.add(def.getNameIdentifier());\n                }\n              }\n            }\n\n            final int nNext = nNext (index);\n            for (int i = 0; i < nNext; i++) {\n              final int next = getNext(index, i);\n              if (!visited [next]) {\n                if (!defs ()) {\n                  final Instruction instruction = instructions.get(next);\n                  processInstruction(res, instruction, next);\n                }\n                traverse (next);\n\n              }\n            }\n          }\n        }\n        new Inner ().traverse (elem);\n        return res.toArray(new PsiElement[res.size ()]);\n      }\n      return null;\n    }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement[] getDefs(PsiCodeBlock body, final PsiVariable def, PsiElement ref) {\n    try {\n      return new RefsDefs(body) {\n\n        final InstructionState[] states = getStates(instructions);\n\n        protected int nNext(int index) {\n          return states[index].getBackwardTraces().size();\n        }\n\n        protected int getNext(int index, int no) {\n          return states[index].getBackwardTraces().get(no);\n        }\n\n        protected boolean defs() { return true; }\n\n        protected void processInstruction(final Set<PsiElement> res, final Instruction instruction, int index) {\n          if (instruction instanceof WriteVariableInstruction) {\n            WriteVariableInstruction instructionW = (WriteVariableInstruction)instruction;\n            if (instructionW.variable == def) {\n\n              final PsiElement element = flow.getElement(index);\n              element.accept(new PsiRecursiveElementVisitor() {\n                public void visitReferenceExpression(PsiReferenceExpression ref) {\n                  if (PsiUtil.isAccessedForWriting(ref)) {\n                    if (ref.resolve() == def) {\n                      res.add(ref);\n                    }\n                  }\n                }\n                public void visitVariable(PsiVariable var) {\n                  if (var == def && (var instanceof PsiParameter || var.hasInitializer())) {\n                    res.add(var);\n                  }\n                }\n              });\n            }\n          }\n        }\n      }.get(def, ref);\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n  }","id":88496,"modified_method":"public static PsiElement[] getDefs(PsiCodeBlock body, final PsiVariable variable, PsiElement ref) {\n    try {\n      return new RefsDefs(body) {\n\n        final InstructionState[] states = getStates(instructions);\n\n        protected int nNext(int index) {\n          return states[index].getBackwardTraces().size();\n        }\n\n        protected int getNext(int index, int no) {\n          return states[index].getBackwardTraces().get(no);\n        }\n\n        protected boolean defs() { return true; }\n\n        protected void processInstruction(final Set<PsiElement> res, final Instruction instruction, int index) {\n          if (instruction instanceof WriteVariableInstruction) {\n            WriteVariableInstruction instructionW = (WriteVariableInstruction)instruction;\n            if (instructionW.variable == variable) {\n\n              final PsiElement element = flow.getElement(index);\n              element.accept(new PsiRecursiveElementVisitor() {\n                public void visitReferenceExpression(PsiReferenceExpression ref) {\n                  if (PsiUtil.isAccessedForWriting(ref)) {\n                    if (ref.resolve() == variable) {\n                      res.add(ref);\n                    }\n                  }\n                }\n                public void visitVariable(PsiVariable var) {\n                  if (var == variable && (var instanceof PsiParameter || var.hasInitializer())) {\n                    res.add(var);\n                  }\n                }\n              });\n            }\n          }\n        }\n      }.get(variable, ref);\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, PsiElement[] elements, DataContext dataContext) {\n    LOG.assertTrue(elements.length == 1);\n    if (dataContext == null) {\n      dataContext = DataManager.getInstance().getDataContext();\n    }\n    final Editor editor = (Editor)dataContext.getData(DataConstants.EDITOR);\n    if (elements[0] instanceof PsiMethod) {\n      new InlineMethodHandler().invoke(project, editor, (PsiMethod) elements[0]);\n    } else if (elements[0] instanceof  PsiField) {\n      new InlineConstantFieldHandler().invoke(project, editor, (PsiField) elements[0]);\n    } else if (elements[0] instanceof PsiLocalVariable) {\n      new InlineLocalHandler().invoke(project, editor, (PsiLocalVariable)elements[0]);\n    } else {\n      LOG.error(\"Unknown element type to inline:\" + elements[0]);\n    }\n  }","id":88497,"modified_method":"public void invoke(Project project, PsiElement[] elements, DataContext dataContext) {\n    LOG.assertTrue(elements.length == 1);\n    if (dataContext == null) {\n      dataContext = DataManager.getInstance().getDataContext();\n    }\n    final Editor editor = (Editor)dataContext.getData(DataConstants.EDITOR);\n    if (elements[0] instanceof PsiMethod) {\n      InlineMethodHandler.invoke(project, editor, (PsiMethod) elements[0]);\n    } else if (elements[0] instanceof  PsiField) {\n      InlineConstantFieldHandler.invoke(project, editor, (PsiField) elements[0]);\n    } else if (elements[0] instanceof PsiLocalVariable) {\n      InlineLocalHandler.invoke(project, editor, (PsiLocalVariable)elements[0], null);\n    } else {\n      LOG.error(\"Unknown element type to inline:\" + elements[0]);\n    }\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(final Project project, Editor editor, PsiFile file, DataContext dataContext) {\n    editor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    PsiElement element = (PsiElement) dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (element instanceof PsiLocalVariable) {\n      new InlineLocalHandler().invoke(project, editor, (PsiLocalVariable) element);\n    } else if (element instanceof PsiMethod) {\n      new InlineMethodHandler().invoke(project, editor, (PsiMethod) element);\n    } else if (element instanceof PsiField) {\n      new InlineConstantFieldHandler().invoke(project, editor, (PsiField) element);\n    } else if (PsiUtil.isInJspFile(file)) {\n      new InlineIncludeFileHandler().invoke(project, editor, PsiUtil.getJspFile(file));\n    }\n    else {\n      String message =\n        RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"error.wrong.caret.position.method.or.local.name\"));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, null, project);\n    }\n  }","id":88498,"modified_method":"public void invoke(final Project project, Editor editor, PsiFile file, DataContext dataContext) {\n    editor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    PsiElement element = (PsiElement) dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (element instanceof PsiLocalVariable) {\n      final PsiReference psiReference = TargetElementUtil.findReference(editor);\n      final PsiReferenceExpression refExpr = psiReference instanceof PsiReferenceExpression ? ((PsiReferenceExpression)psiReference) : null;\n      InlineLocalHandler.invoke(project, editor, (PsiLocalVariable) element, refExpr);\n    } else if (element instanceof PsiMethod) {\n      InlineMethodHandler.invoke(project, editor, (PsiMethod) element);\n    } else if (element instanceof PsiField) {\n      InlineConstantFieldHandler.invoke(project, editor, (PsiField) element);\n    } else if (PsiUtil.isInJspFile(file)) {\n      InlineIncludeFileHandler.invoke(project, editor, PsiUtil.getJspFile(file));\n    }\n    else {\n      String message =\n        RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"error.wrong.caret.position.method.or.local.name\"));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, null, project);\n    }\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * should be called in AtomicAction\n   */\n  public void invoke(final Project project, final Editor editor, final PsiLocalVariable local) {\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, local)) return;\n\n    final HighlightManager highlightManager = HighlightManager.getInstance(project);\n\n    final String localName = local.getName();\n    final PsiExpression initializer = local.getInitializer();\n    if (initializer == null){\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"variable.has.no.initializer\", localName));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      return;\n    }\n\n    PsiSearchHelper searchHelper = PsiManager.getInstance(project).getSearchHelper();\n    final PsiReference[] refs = searchHelper.findReferences(local, GlobalSearchScope.projectScope(project), false);\n\n    if (refs.length == 0){\n      String message = RefactoringBundle.message(\"variable.is.never.used\", localName);\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      return;\n    }\n\n    PsiFile workingFile = local.getContainingFile();\n    for (PsiReference ref : refs) {\n      final PsiFile otherFile = ref.getElement().getContainingFile();\n      if (!otherFile.equals(workingFile)) {\n        String message = RefactoringBundle.message(\"variable.is.referenced.in.multiple.files\", localName);\n        CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n        return;\n      }\n    }\n\n    final ArrayList<PsiReference> toInlines = new ArrayList<PsiReference>(refs.length);\n    final PsiJavaCodeReferenceElement firstWriteUsage = (PsiJavaCodeReferenceElement)filterUsagesToInline(refs, toInlines);\n    if (toInlines.size() == 0) {\n      String message = RefactoringBundle.message(\"variable.is.never.used.before.modification\", localName);\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      return;\n    }\n    final PsiElement lastUsage = toInlines.get(toInlines.size() - 1).getElement();\n    final PsiElement codeFragment = ControlFlowUtil.findCodeFragment(local);\n    EditorColorsManager manager = EditorColorsManager.getInstance();\n    final TextAttributes attributes = manager.getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n    try {\n      ControlFlow controlFlow = ControlFlowFactory.getInstance(project).getControlFlow(codeFragment, new LocalsControlFlowPolicy(codeFragment), false);\n      PsiElement commonParent = PsiTreeUtil.findCommonParent(local, lastUsage);\n      PsiElement anchor = lastUsage;\n      while (!commonParent.equals(anchor.getParent())) {\n        anchor = anchor.getParent();\n      }\n      while (controlFlow.getEndOffset(anchor) < 0) {\n        anchor = anchor.getParent();\n      }\n      int offset = controlFlow.getEndOffset(anchor);\n      if (ControlFlowUtil.needVariableValueAt(local, controlFlow, offset)){\n        ArrayList<PsiReference> refsForWriting = new ArrayList<PsiReference>(refs.length);\n        for (PsiReference ref : refs) {\n          if (PsiUtil.isAccessedForWriting((PsiExpression)ref.getElement())) {\n            refsForWriting.add(ref);\n          }\n        }\n        if (refsForWriting.size() > 0) {\n          highlightManager.addOccurrenceHighlights(\n            editor,\n            refsForWriting.toArray(new PsiReference[refsForWriting.size()]),\n            attributes, true, null\n          );\n          String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"variable.is.accessed.for.writing\", localName));\n          CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n          WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n          return;\n        }\n      }\n\n      if (firstWriteUsage != null) {\n        PsiElement tmp = firstWriteUsage;\n        int writeInstructionOffset;\n        do {\n          writeInstructionOffset = controlFlow.getEndOffset(tmp);\n          tmp = tmp.getParent();\n        } while(writeInstructionOffset < 0);\n\n        for (final PsiReference toInline : toInlines) {\n          PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)toInline;\n          if (ControlFlowUtil.isInstructionReachable(controlFlow, controlFlow.getStartOffset(ref), writeInstructionOffset)) {\n            String message = RefactoringBundle.getCannotRefactorMessage(\n              RefactoringBundle.message(\"variable.initializer.does.not.dominate.its.usages\"));\n            CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n            return;\n          }\n        }\n      }\n    }\n    catch (AnalysisCanceledException e) {\n    }\n\n    if (editor != null && !ApplicationManager.getApplication().isUnitTestMode()) {\n      // TODO : check if initializer uses fieldNames that possibly will be hidden by other\n      // locals with the same names after inlining\n      highlightManager.addOccurrenceHighlights(\n        editor,\n        toInlines.toArray(new PsiReference[toInlines.size()]),\n        attributes, true, null\n      );\n      int occurrencesCount = toInlines.size();\n      String occurencesString = RefactoringBundle.message(\"occurences.string\", occurrencesCount);\n      final String question = RefactoringBundle.message(\"inline.local.variable.prompt\", localName) + \" \" + occurencesString;\n      RefactoringMessageDialog dialog = new RefactoringMessageDialog(\n        REFACTORING_NAME,\n        question,\n        HelpID.INLINE_VARIABLE,\n        \"OptionPane.questionIcon\",\n        true,\n        project);\n      dialog.show();\n      if (!dialog.isOK()){\n        WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n        return;\n      }\n    }\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        try{\n          final PsiExpression initializer = local.getInitializer();\n          PsiExpression[] exprs = new PsiExpression[toInlines.size()];\n          for(int idx = 0; idx < toInlines.size(); idx++){\n            PsiReference ref = toInlines.get(idx);\n            PsiJavaCodeReferenceElement refElement = (PsiJavaCodeReferenceElement)ref.getElement();\n            exprs[idx] = InlineUtil.inlineVariable(local, initializer, refElement);\n          }\n          if (firstWriteUsage != null) {\n//            PsiReference firstWriteUsage = refs[toInlines.size()];\n            ControlFlow controlFlow;\n            try {\n              controlFlow = ControlFlowFactory.getInstance(project).getControlFlow(codeFragment, new LocalsControlFlowPolicy(codeFragment), false);\n            }\n            catch (AnalysisCanceledException e) {\n              controlFlow = ControlFlow.EMPTY;\n            }\n            PsiElement insertAnchor = firstWriteUsage.getElement();\n            PsiElement parent = PsiTreeUtil.findCommonParent(local, insertAnchor);\n            while (!parent.equals(insertAnchor.getParent())) {\n              insertAnchor = insertAnchor.getParent();\n            }\n            int startOffset = controlFlow.getStartOffset(insertAnchor);\n            if (startOffset != -1) {\n              insertAnchor = controlFlow.getElement(startOffset);\n            }\n            parent = PsiTreeUtil.findCommonParent(local, insertAnchor);\n            while (!parent.equals(insertAnchor.getParent())) {\n              insertAnchor = insertAnchor.getParent();\n            }\n            if (initializer != null) {\n              initializer.delete();\n            }\n            PsiAssignmentExpression assignment = getAssignmentExpression(firstWriteUsage);\n            PsiDeclarationStatement newDeclaration = createDeclarationStatement(local, assignment);\n            parent.addBefore(newDeclaration, insertAnchor);\n            if (assignment != null && local.getParent().getParent().equals(assignment.getParent().getParent())) {\n              // there is a first assignment and it is on the _same_ level with the local variable declaration\n              assignment.getParent().delete();\n            }\n          }\n          local.delete();\n\n          if (editor != null && !ApplicationManager.getApplication().isUnitTestMode()) {\n            highlightManager.addOccurrenceHighlights(editor, exprs, attributes, true, null);\n            WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n          }\n        }\n        catch(IncorrectOperationException e){\n          LOG.error(e);\n        }\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(runnable);\n      }\n    }, RefactoringBundle.message(\"inline.local.command\", localName), null);\n  }","id":88499,"modified_method":"/**\n   * should be called in AtomicAction\n   */\n  public static void invoke(final Project project, final Editor editor, final PsiLocalVariable local, PsiReferenceExpression refExpr) {\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, local)) return;\n\n    final HighlightManager highlightManager = HighlightManager.getInstance(project);\n\n    final String localName = local.getName();\n    final PsiCodeBlock containerBlock = PsiTreeUtil.getParentOfType(local, PsiCodeBlock.class);\n    LOG.assertTrue(containerBlock != null);\n    final PsiExpression defToInline = getDefToInline(local, refExpr, containerBlock);\n    if (defToInline == null){\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"variable.has.no.initializer\", localName));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      return;\n    }\n\n    final Collection<PsiReference> refs = ReferencesSearch.search(local, GlobalSearchScope.projectScope(project), false).findAll();\n\n    if (refs.isEmpty()){\n      LOG.assertTrue(refExpr == null);\n      String message = RefactoringBundle.message(\"variable.is.never.used\", localName);\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      return;\n    }\n\n    final PsiElement[] refsToInline = DefUseUtil.getRefs(containerBlock, local, defToInline);\n    if (refsToInline.length == 0) {\n      LOG.assertTrue(refExpr == null || PsiUtil.isAccessedForWriting(refExpr));\n      String message = RefactoringBundle.message(\"variable.is.never.used.before.modification\", localName);\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      return;\n    }\n\n    EditorColorsManager manager = EditorColorsManager.getInstance();\n    final TextAttributes attributes = manager.getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n    if (refExpr != null && PsiUtil.isAccessedForReading(refExpr) && !Arrays.asList(refsToInline).contains(refExpr)) {\n      final PsiElement[] defs = DefUseUtil.getDefs(containerBlock, local, refExpr);\n      LOG.assertTrue(defs.length > 0);\n      highlightManager.addOccurrenceHighlights(editor, defs, attributes, true, null);\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"variable.is.accessed.for.writing\", localName));\n      CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n      WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n      return;\n    }\n\n    PsiFile workingFile = local.getContainingFile();\n    for (PsiElement ref : refsToInline) {\n      final PsiFile otherFile = ref.getContainingFile();\n      if (!otherFile.equals(workingFile)) {\n        String message = RefactoringBundle.message(\"variable.is.referenced.in.multiple.files\", localName);\n        CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n        return;\n      }\n    }\n\n    for (final PsiElement ref : refsToInline) {\n      final PsiElement[] defs = DefUseUtil.getDefs(containerBlock, local, ref);\n      if (defs.length != 1 || !isSameDefinition(defs[0], defToInline)) {\n        highlightManager.addOccurrenceHighlights(editor, defs, attributes, true, null);\n        String message =\n          RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"variable.is.accessed.for.writing.and.used.with.inlined\", localName));\n        CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME, message, HelpID.INLINE_VARIABLE, project);\n        WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n        return;\n      }\n    }\n\n    if (editor != null && !ApplicationManager.getApplication().isUnitTestMode()) {\n      // TODO : check if initializer uses fieldNames that possibly will be hidden by other\n      // locals with the same names after inlining\n      highlightManager.addOccurrenceHighlights(\n        editor,\n        refsToInline,\n        attributes, true, null\n      );\n      int occurrencesCount = refsToInline.length;\n      String occurencesString = RefactoringBundle.message(\"occurences.string\", occurrencesCount);\n      final String promptKey = isInliningVariableInitializer(defToInline)\n                               ? \"inline.local.variable.prompt\" : \"inline.local.variable.definition.prompt\";\n      final String question = RefactoringBundle.message(promptKey, localName) + \" \" + occurencesString;\n      RefactoringMessageDialog dialog = new RefactoringMessageDialog(\n        REFACTORING_NAME,\n        question,\n        HelpID.INLINE_VARIABLE,\n        \"OptionPane.questionIcon\",\n        true,\n        project);\n      dialog.show();\n      if (!dialog.isOK()){\n        WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n        return;\n      }\n    }\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        try{\n          PsiExpression[] exprs = new PsiExpression[refsToInline.length];\n          for(int idx = 0; idx < refsToInline.length; idx++){\n            PsiJavaCodeReferenceElement refElement = (PsiJavaCodeReferenceElement)refsToInline[idx];\n            exprs[idx] = InlineUtil.inlineVariable(local, defToInline, refElement);\n          }\n\n          if (!isInliningVariableInitializer(defToInline)) {\n            defToInline.getParent().delete();\n          } else {\n            defToInline.delete();\n          }\n\n          if (ReferencesSearch.search(local).findFirst() == null) {\n            new RemoveUnusedVariableFix(local).invoke(project, editor, local.getContainingFile());\n          }\n\n          if (editor != null && !ApplicationManager.getApplication().isUnitTestMode()) {\n            highlightManager.addOccurrenceHighlights(editor, exprs, attributes, true, null);\n            WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n          }\n        }\n        catch (IncorrectOperationException e){\n          LOG.error(e);\n        }\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(runnable);\n      }\n    }, RefactoringBundle.message(\"inline.local.command\", localName), null);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testIDEADEV950 () throws Exception {\n    doTest();\n  }","id":88500,"modified_method":"public void testIDEADEV950 () throws Exception {\n    doTest(false);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testIDEADEV12244 () throws Exception {\n    doTest();\n  }","id":88501,"modified_method":"public void testIDEADEV12244 () throws Exception {\n    doTest(false);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNoRedundantCasts () throws Exception {\n    doTest();\n  }","id":88502,"modified_method":"public void testNoRedundantCasts () throws Exception {\n    doTest(false);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testInference () throws Exception {\n    doTest();\n  }","id":88503,"modified_method":"public void testInference () throws Exception {\n    doTest(false);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void performInline(Project project, Editor editor) {\n    PsiElement element = TargetElementUtil.findTargetElement(editor,\n            TargetElementUtil.ELEMENT_NAME_ACCEPTED | TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED);\n    assertTrue(element instanceof PsiLocalVariable);\n\n    new InlineLocalHandler().invoke(project, editor, (PsiLocalVariable)element);\n  }","id":88504,"modified_method":"public static void performInline(Project project, Editor editor) {\n    PsiElement element = TargetElementUtil.findTargetElement(editor,\n            TargetElementUtil.ELEMENT_NAME_ACCEPTED | TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED);\n    assertTrue(element instanceof PsiLocalVariable);\n\n    InlineLocalHandler.invoke(project, editor, (PsiLocalVariable)element, null);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testQualifier () throws Exception {\n    doTest();\n  }","id":88505,"modified_method":"public void testQualifier () throws Exception {\n    doTest(false);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testIDEADEV9404 () throws Exception {\n    doTest();\n  }","id":88506,"modified_method":"public void testIDEADEV9404 () throws Exception {\n    doTest(false);\n  }","commit_id":"d411b7782b245d549bc3d14e5e0bd63c401ad2b5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testIssue615KeysetPredicates() throws TransactionException {\n        final String MAP_NAME = \"defaultMap\";\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(MAP_NAME);\n        final SampleObjects.Employee employee1 = new SampleObjects.Employee(\"abc-123-xvz\", 34, true, 10D);\n        final SampleObjects.Employee employee2 = new SampleObjects.Employee(\"abc-1xvz\", 4, true, 7D);\n        final SampleObjects.Employee employee3 = new SampleObjects.Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final SampleObjects.Employee employee4 = new SampleObjects.Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(employee1, employee1);\n\n        final TransactionContext context = h1.newTransactionContext();\n        context.beginTransaction();\n\n        final TransactionalMap<Object, Object> txMap = context.getMap(MAP_NAME);\n\n        assertNull(txMap.put(employee2, employee2));\n\n        assertEquals(2, txMap.size());\n        assertEquals(2, txMap.keySet().size());\n        assertEquals(1, txMap.keySet(new SqlPredicate(\"age = 34\")).size());\n\n        context.commitTransaction();\n\n\n        assertEquals(2, map.size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","id":88507,"modified_method":"@Test\n    public void testIssue615KeysetPredicates() throws TransactionException {\n        final String MAP_NAME = \"defaultMap\";\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(MAP_NAME);\n        final Employee employee1 = new Employee(\"abc-123-xvz\", 34, true, 10D);\n        final Employee employee2 = new Employee(\"abc-1xvz\", 4, true, 7D);\n        final Employee employee3 = new Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final Employee employee4 = new Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(employee1, employee1);\n\n        final TransactionContext context = h1.newTransactionContext();\n        context.beginTransaction();\n\n        final TransactionalMap<Object, Object> txMap = context.getMap(MAP_NAME);\n\n        assertNull(txMap.put(employee2, employee2));\n\n        assertEquals(2, txMap.size());\n        assertEquals(2, txMap.keySet().size());\n        assertEquals(1, txMap.keySet(new SqlPredicate(\"age = 34\")).size());\n\n        context.commitTransaction();\n\n\n        assertEquals(2, map.size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testValuesWithPredicates_notContains_oldValues() throws TransactionException {\n        Config config = new Config();\n        final String mapName = \"testValuesWithPredicate_notContains_oldValues\";\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h1.getMap(mapName);\n        final SampleObjects.Employee employeeAtAge22 = new SampleObjects.Employee(\"emin\", 22, true, 10D);\n        final SampleObjects.Employee employeeAtAge23 = new SampleObjects.Employee(\"emin\", 23, true, 10D);\n        map.put(1, employeeAtAge22);\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                assertEquals(1, txMap.values(new SqlPredicate(\"age > 21\")).size());\n                txMap.put(1, employeeAtAge23);\n                Collection coll = txMap.values(new SqlPredicate(\"age > 21\"));\n                assertEquals(1, coll.size());\n                return true;\n            }\n        });\n        h1.shutdown();\n        h2.shutdown();\n\n    }","id":88508,"modified_method":"@Test\n    public void testValuesWithPredicates_notContains_oldValues() throws TransactionException {\n        final String mapName = \"testValuesWithPredicate_notContains_oldValues\";\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance();\n        final HazelcastInstance h2 = factory.newHazelcastInstance();\n        final IMap<Integer, Employee> map = h1.getMap(mapName);\n        final Employee employeeAtAge22 = new Employee(\"emin\", 22, true, 10D);\n        final Employee employeeAtAge23 = new Employee(\"emin\", 23, true, 10D);\n        map.put(1, employeeAtAge22);\n\n        h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                assertEquals(1, txMap.values(new SqlPredicate(\"age > 21\")).size());\n                txMap.put(1, employeeAtAge23);\n                Collection coll = txMap.values(new SqlPredicate(\"age > 21\"));\n                assertEquals(1, coll.size());\n                return true;\n            }\n        });\n        h1.shutdown();\n        h2.shutdown();\n\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testTxnOwnerDies() throws TransactionException, InterruptedException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h3 = factory.newHazelcastInstance(config);\n        final IMap map1 = h1.getMap(\"default\");\n        final int size = 50;\n        final AtomicBoolean result = new AtomicBoolean(false);\n\n        Runnable runnable = new Runnable() {\n            public void run() {\n                try {\n                    boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                        public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                            final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                            for (int i = 0; i < size; i++) {\n                                txMap.put(i, i);\n                                sleepSeconds(1);\n                            }\n                            return true;\n                        }\n                    });\n                    result.set(b);\n                } catch (HazelcastInstanceNotActiveException ignored) {\n                } catch (TransactionException ignored) {\n                }\n            }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        sleepSeconds(1);\n\n        h1.shutdown();\n        // wait till thread finishes.\n        thread.join(30 * 1000);\n\n        assertFalse(result.get());\n        final IMap map2 = h2.getMap(\"default\");\n        for (int i = 0; i < size; i++) {\n            assertNull(map2.get(i));\n        }\n    }","id":88509,"modified_method":"@Test\n    public void testTxnOwnerDies() throws TransactionException, InterruptedException {\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n        final HazelcastInstance h1 = factory.newHazelcastInstance();\n        final HazelcastInstance h2 = factory.newHazelcastInstance();\n        final HazelcastInstance h3 = factory.newHazelcastInstance();\n        final int size = 50;\n        final AtomicBoolean result = new AtomicBoolean(false);\n\n        Runnable runnable = new Runnable() {\n            public void run() {\n                try {\n                    boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                        public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                            final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                            for (int i = 0; i < size; i++) {\n                                txMap.put(i, i);\n                                sleepSeconds(1);\n                            }\n                            return true;\n                        }\n                    });\n                    result.set(b);\n                } catch (HazelcastInstanceNotActiveException ignored) {\n                } catch (TransactionException ignored) {\n                }\n            }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        sleepSeconds(1);\n\n        h1.shutdown();\n        // wait till thread finishes.\n        thread.join(30 * 1000);\n\n        assertFalse(result.get());\n        final IMap map2 = h2.getMap(\"default\");\n        for (int i = 0; i < size; i++) {\n            assertNull(map2.get(i));\n        }\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testTxnContainsKey() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final IMap map = h1.getMap(\"default\");\n        map.put(\"1\", \"1\");\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                txMap.delete(\"1\");\n                assertEquals(false, txMap.containsKey(\"1\"));\n                assertEquals(true, map.containsKey(\"1\"));\n                return true;\n            }\n        });\n        assertTrue(b);\n    }","id":88510,"modified_method":"@Test\n    public void testTxnContainsKey() throws TransactionException {\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance();\n        final IMap<String, String> map = h1.getMap(\"default\");\n        map.put(\"1\", \"1\");\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                txMap.delete(\"1\");\n                assertEquals(false, txMap.containsKey(\"1\"));\n                assertEquals(true, map.containsKey(\"1\"));\n                return true;\n            }\n        });\n        assertTrue(b);\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testValuesWithPredicate_removingExistentEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"_testValuesWithPredicate_removingExistentEntry_\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final SampleObjects.Employee emp = new SampleObjects.Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                txMap.remove(1);\n                Collection<Object> coll = txMap.values(new SqlPredicate(\"age > 70 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","id":88511,"modified_method":"@Test\n    public void testValuesWithPredicate_removingExistentEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"_testValuesWithPredicate_removingExistentEntry_\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final Employee emp = new Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                txMap.remove(1);\n                Collection<Object> coll = txMap.values(new SqlPredicate(\"age > 70 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue615KeysetWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(\"default\");\n        final SampleObjects.Employee employee1 = new SampleObjects.Employee(\"abc-123-xvz\", 34, true, 10D);\n        final SampleObjects.Employee employee2 = new SampleObjects.Employee(\"abc-1xvz\", 4, true, 7D);\n        final SampleObjects.Employee employee3 = new SampleObjects.Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final SampleObjects.Employee employee4 = new SampleObjects.Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(1, employee1);\n\n\n        try {\n            boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                    final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n\n                    assertEquals(0, txMap.keySet(new SqlPredicate(\"age <= 10\")).size());\n                    //put\n                    txMap.put(2, employee2);\n                    Set keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    Iterator iterator = keys.iterator();\n\n                    assertEquals(1, keys.size());\n\n                    while (iterator.hasNext()) {\n                        assertEquals(2, ((Integer) iterator.next()).intValue());\n                    }\n\n                    txMap.put(3, employee3);\n                    txMap.put(4, employee4);\n\n                    keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    assertEquals(3, keys.size());\n\n                    // force rollback.\n                    throw new DummyUncheckedHazelcastTestException();\n                }\n            });\n        } catch (Exception e) {\n            if (!(e instanceof DummyUncheckedHazelcastTestException)) {\n                throw new RuntimeException(e);\n            }\n        }\n        assertEquals(1, map.size());\n        assertEquals(1, map.keySet().size());\n        assertEquals(0, map.keySet(new SqlPredicate(\"age <= 10\")).size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","id":88512,"modified_method":"@Test\n    public void testIssue615KeysetWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(\"default\");\n        final Employee employee1 = new Employee(\"abc-123-xvz\", 34, true, 10D);\n        final Employee employee2 = new Employee(\"abc-1xvz\", 4, true, 7D);\n        final Employee employee3 = new Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final Employee employee4 = new Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(1, employee1);\n\n\n        try {\n            h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                    final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n\n                    assertEquals(0, txMap.keySet(new SqlPredicate(\"age <= 10\")).size());\n                    //put\n                    txMap.put(2, employee2);\n                    Set keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    Iterator iterator = keys.iterator();\n\n                    assertEquals(1, keys.size());\n\n                    while (iterator.hasNext()) {\n                        assertEquals(2, ((Integer) iterator.next()).intValue());\n                    }\n\n                    txMap.put(3, employee3);\n                    txMap.put(4, employee4);\n\n                    keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    assertEquals(3, keys.size());\n\n                    // force rollback.\n                    throw new DummyUncheckedHazelcastTestException();\n                }\n            });\n        } catch (Exception e) {\n            if (!(e instanceof DummyUncheckedHazelcastTestException)) {\n                throw new RuntimeException(e);\n            }\n        }\n        assertEquals(1, map.size());\n        assertEquals(1, map.keySet().size());\n        assertEquals(0, map.keySet(new SqlPredicate(\"age <= 10\")).size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue615ValuesWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map2 = h2.getMap(\"default\");\n        final SampleObjects.Employee emp1 = new SampleObjects.Employee(\"abc-123-xvz\", 34, true, 10D);\n        map2.put(1, emp1);\n        final SampleObjects.Employee emp2 = new SampleObjects.Employee(\"xvz\", 4, true, 10D);\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                assertEquals(0, txMap.values(new SqlPredicate(\"age <= 10\")).size());\n                txMap.put(2, emp2);\n                Collection coll = txMap.values(new SqlPredicate(\"age <= 10\"));\n                Iterator<Object> iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final SampleObjects.Employee e = (SampleObjects.Employee) iterator.next();\n                    assertEquals(emp2, e);\n                }\n                coll = txMap.values(new SqlPredicate(\"age > 30 \"));\n                iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final SampleObjects.Employee e = (SampleObjects.Employee) iterator.next();\n                    assertEquals(emp1, e);\n                }\n                txMap.remove(2);\n                coll = txMap.values(new SqlPredicate(\"age <= 10 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        assertEquals(0, map2.values(new SqlPredicate(\"age <= 10\")).size());\n        assertEquals(1, map2.values(new SqlPredicate(\"age = 34\")).size());\n        h1.shutdown();\n        h2.shutdown();\n    }","id":88513,"modified_method":"@Test\n    public void testIssue615ValuesWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map2 = h2.getMap(\"default\");\n        final Employee emp1 = new Employee(\"abc-123-xvz\", 34, true, 10D);\n        map2.put(1, emp1);\n        final Employee emp2 = new Employee(\"xvz\", 4, true, 10D);\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                assertEquals(0, txMap.values(new SqlPredicate(\"age <= 10\")).size());\n                txMap.put(2, emp2);\n                Collection coll = txMap.values(new SqlPredicate(\"age <= 10\"));\n                Iterator<Object> iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final Employee e = (Employee) iterator.next();\n                    assertEquals(emp2, e);\n                }\n                coll = txMap.values(new SqlPredicate(\"age > 30 \"));\n                iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final Employee e = (Employee) iterator.next();\n                    assertEquals(emp1, e);\n                }\n                txMap.remove(2);\n                coll = txMap.values(new SqlPredicate(\"age <= 10 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        assertEquals(0, map2.values(new SqlPredicate(\"age <= 10\")).size());\n        assertEquals(1, map2.values(new SqlPredicate(\"age = 34\")).size());\n        h1.shutdown();\n        h2.shutdown();\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testValues_resultSetContainsUpdatedEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName();\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final SampleObjects.Employee emp = new SampleObjects.Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Integer, SampleObjects.Employee> txMap = context.getMap(mapName);\n                emp.setAge(30);\n                txMap.put(1, emp);\n                Collection<SampleObjects.Employee> coll = txMap.values();\n                assertEquals(1, coll.size());\n                SampleObjects.Employee employee = coll.iterator().next();\n                assertEquals(30, employee.getAge());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","id":88514,"modified_method":"@Test\n    public void testValues_resultSetContainsUpdatedEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName();\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final Employee emp = new Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Integer, Employee> txMap = context.getMap(mapName);\n                emp.setAge(30);\n                txMap.put(1, emp);\n                Collection<Employee> coll = txMap.values();\n                assertEquals(1, coll.size());\n                Employee employee = coll.iterator().next();\n                assertEquals(30, employee.getAge());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = IllegalArgumentException.class)\n    public void testValuesWithPagingPredicate() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"testValuesWithPagingPredicate\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final SampleObjects.Employee emp = new SampleObjects.Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                PagingPredicate predicate = new PagingPredicate(5);\n                txMap.values(predicate);\n                return true;\n            }\n        });\n    }","id":88515,"modified_method":"@Test(expected = IllegalArgumentException.class)\n    public void testValuesWithPagingPredicate() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"testValuesWithPagingPredicate\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final Employee emp = new Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                PagingPredicate predicate = new PagingPredicate(5);\n                txMap.values(predicate);\n                return true;\n            }\n        });\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean containsKey(Object key) {\n        checkTransactionState();\n        final TxnValueWrapper valueWrapper = txMap.get(key);\n        if (valueWrapper != null) {\n            return valueWrapper.type == TxnValueWrapper.Type.REMOVED ? false : true;\n        }\n        return containsKeyInternal(getService().getMapServiceContext().toData(key, partitionStrategy));\n    }","id":88516,"modified_method":"public boolean containsKey(Object key) {\n        checkTransactionState();\n        Data keyData = getService().getMapServiceContext().toData(key, partitionStrategy);\n        final TxnValueWrapper valueWrapper = txMap.get(keyData);\n        if (valueWrapper != null) {\n            return valueWrapper.type == TxnValueWrapper.Type.REMOVED ? false : true;\n        }\n        return containsKeyInternal(keyData);\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean replace(Object key, Object oldValue, Object newValue) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n        boolean haveTxnPast = wrapper != null;\n\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (haveTxnPast) {\n            if (!wrapper.value.equals(oldValue)) {\n                return false;\n            }\n            putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(newValue));\n            txMap.put(key, new TxnValueWrapper(wrapper.value, TxnValueWrapper.Type.UPDATED));\n            return true;\n        } else {\n            boolean success = replaceIfSameInternal(mapServiceContext.toData(key),\n                    mapServiceContext.toData(oldValue), mapServiceContext.toData(newValue));\n            if (success) {\n                txMap.put(key, new TxnValueWrapper(newValue, TxnValueWrapper.Type.UPDATED));\n            }\n            return success;\n        }\n    }","id":88517,"modified_method":"public boolean replace(Object key, Object oldValue, Object newValue) {\n        checkTransactionState();\n        MapService service = getService();\n        MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper wrapper = txMap.get(keyData);\n        boolean haveTxnPast = wrapper != null;\n\n        if (haveTxnPast) {\n            if (!wrapper.value.equals(oldValue)) {\n                return false;\n            }\n            putInternal(keyData, mapServiceContext.toData(newValue));\n            txMap.put(keyData, new TxnValueWrapper(wrapper.value, TxnValueWrapper.Type.UPDATED));\n            return true;\n        } else {\n            boolean success = replaceIfSameInternal(keyData,\n                    mapServiceContext.toData(oldValue), mapServiceContext.toData(newValue));\n            if (success) {\n                txMap.put(keyData, new TxnValueWrapper(newValue, TxnValueWrapper.Type.UPDATED));\n            }\n            return success;\n        }\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Set<Object> keySet() {\n        checkTransactionState();\n        final Set<Data> keySet = keySetInternal();\n        final Set<Object> keys = new HashSet<Object>(keySet.size());\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        // convert Data to Object\n        for (final Data data : keySet) {\n            keys.add(mapServiceContext.toObject(data));\n        }\n\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            if (TxnValueWrapper.Type.NEW.equals(entry.getValue().type)) {\n                keys.add(entry.getKey());\n            } else if (TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                keys.remove(entry.getKey());\n            }\n        }\n        return keys;\n    }","id":88518,"modified_method":"public Set<Object> keySet() {\n        checkTransactionState();\n        final Set<Data> keySet = keySetInternal();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n\n        for (final Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            if (TxnValueWrapper.Type.NEW.equals(entry.getValue().type)) {\n                keySet.add(entry.getKey());\n            } else if (TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                keySet.remove(entry.getKey());\n            }\n        }\n        HashSet<Object> keys = new HashSet<Object>();\n        for (Data keyData : keySet) {\n            keys.add(mapServiceContext.toObject(keyData));\n        }\n        return keys;\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object get(Object key) {\n        checkTransactionState();\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        return mapServiceContext.toObject(getInternal(mapServiceContext.toData(key, partitionStrategy)));\n    }","id":88519,"modified_method":"public Object get(Object key) {\n        checkTransactionState();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n        return mapServiceContext.toObject(getInternal(keyData));\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object put(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(mapServiceContext.toData(key, partitionStrategy),\n                mapServiceContext.toData(value)));\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n\n            txMap.put(key, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","id":88520,"modified_method":"public Object put(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(keyData, mapServiceContext.toData(value)));\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n\n            txMap.put(keyData, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Collection values(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate can not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new IllegalArgumentException(\"Paging is not supported for Transactional queries\");\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.ENTRY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> valueSet = new HashSet<Object>();\n        final Set<Object> keyWontBeIncluded = new HashSet<Object>();\n\n        // iterate over the txMap and see if the values are updated or removed.\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            Object objectKey = entry.getKey();\n            if (isRemoved) {\n                keyWontBeIncluded.add(objectKey);\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(objectKey);\n                }\n                Object entryValue = entry.getValue().value;\n                final Object objectValue = entryValue instanceof Data\n                        ? mapServiceContext.toObject(entryValue) : entryValue;\n                Data dataKey = mapServiceContext.toData(objectKey);\n                final SerializationService serializationService = getNodeEngine().getSerializationService();\n                final QueryEntry queryEntry = new QueryEntry(serializationService, dataKey, objectKey, objectValue);\n                if (predicate.apply(queryEntry)) {\n                    valueSet.add(entryValue);\n                }\n            }\n        }\n        removeFromResultSet(queryResultSet, valueSet, keyWontBeIncluded);\n        return valueSet;\n    }","id":88521,"modified_method":"public Collection values(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate can not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new IllegalArgumentException(\"Paging is not supported for Transactional queries\");\n        }\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.ENTRY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> valueSet = new HashSet<Object>();\n        final Set<Object> keyWontBeIncluded = new HashSet<Object>();\n\n        SerializationService serializationService = getNodeEngine().getSerializationService();\n        // iterate over the txMap and see if the values are updated or removed.\n        for (Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            Object keyObject = serializationService.toObject(entry.getKey());\n            if (isRemoved) {\n                keyWontBeIncluded.add(keyObject);\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(keyObject);\n                }\n                Object entryValue = entry.getValue().value;\n\n                QueryEntry queryEntry = new QueryEntry(serializationService, entry.getKey(), keyObject, entryValue);\n                if (predicate.apply(queryEntry)) {\n                    valueSet.add(queryEntry.getValue());\n                }\n            }\n        }\n        removeFromResultSet(queryResultSet, valueSet, keyWontBeIncluded);\n        return valueSet;\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object put(Object key, Object value, long ttl, TimeUnit timeUnit) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(mapServiceContext.toData(key, partitionStrategy),\n                mapServiceContext.toData(value), ttl, timeUnit));\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(key, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","id":88522,"modified_method":"public Object put(Object key, Object value, long ttl, TimeUnit timeUnit) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(keyData,\n                mapServiceContext.toData(value), ttl, timeUnit));\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(keyData, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object replace(Object key, Object value) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n        boolean haveTxnPast = wrapper != null;\n\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (haveTxnPast) {\n            if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                return null;\n            }\n            putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n            txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            return wrapper.value;\n        } else {\n            Data oldValue = replaceInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n            if (oldValue != null) {\n                txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","id":88523,"modified_method":"public Object replace(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n\n        TxnValueWrapper wrapper = txMap.get(keyData);\n        boolean haveTxnPast = wrapper != null;\n        if (haveTxnPast) {\n            if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                return null;\n            }\n            putInternal(keyData, mapServiceContext.toData(value));\n            txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            return wrapper.value;\n        } else {\n            Data oldValue = replaceInternal(keyData, mapServiceContext.toData(value));\n            if (oldValue != null) {\n                txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object getForUpdate(Object key) {\n        checkTransactionState();\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data dataKey = mapServiceContext.toData(key, partitionStrategy);\n        return mapServiceContext.toObject(getForUpdateInternal(dataKey));\n    }","id":88524,"modified_method":"public Object getForUpdate(Object key) {\n        checkTransactionState();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n\n        return mapServiceContext.toObject(getForUpdateInternal(keyData));\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean remove(Object key, Object value) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (wrapper != null && !mapServiceContext.compare(name, wrapper.value, value)) {\n            return false;\n        }\n        boolean removed = removeIfSameInternal(mapServiceContext.toData(key, partitionStrategy), value);\n        if (removed) {\n            txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.REMOVED));\n        }\n        return removed;\n    }","id":88525,"modified_method":"public boolean remove(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper wrapper = txMap.get(keyData);\n\n        if (wrapper != null && !mapServiceContext.compare(name, wrapper.value, value)) {\n            return false;\n        }\n\n        boolean removed = removeIfSameInternal(keyData, value);\n        if (removed) {\n            txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.REMOVED));\n        }\n        return removed;\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public int size() {\n        checkTransactionState();\n        int currentSize = sizeInternal();\n        for (TxnValueWrapper wrapper : txMap.values()) {\n            if (wrapper.type == TxnValueWrapper.Type.NEW) {\n                currentSize++;\n            } else if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                currentSize--;\n            }\n        }\n        return currentSize;\n    }","id":88526,"modified_method":"public int size() {\n        checkTransactionState();\n        int currentSize = sizeInternal();\n        for (Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            TxnValueWrapper wrapper = entry.getValue();\n            if (wrapper.type == TxnValueWrapper.Type.NEW) {\n                currentSize++;\n            } else if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                VersionedValue versionedValue = valueMap.get(entry.getKey());\n                if (versionedValue != null && versionedValue.value != null) {\n                    currentSize--;\n                }\n            }\n        }\n        return currentSize;\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void delete(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data data = removeInternal(mapServiceContext.toData(key, partitionStrategy));\n        if (data != null || txMap.containsKey(key)) {\n            txMap.put(key, new TxnValueWrapper(mapServiceContext.toObject(data), TxnValueWrapper.Type.REMOVED));\n        }\n    }","id":88527,"modified_method":"public void delete(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        Data data = removeInternal(keyData);\n        if (data != null || txMap.containsKey(keyData)) {\n            txMap.put(keyData, new TxnValueWrapper(mapServiceContext.toObject(data), TxnValueWrapper.Type.REMOVED));\n        }\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object remove(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Object valueBeforeTxn\n                = mapServiceContext.toObject(removeInternal(mapServiceContext.toData(key, partitionStrategy)));\n        TxnValueWrapper wrapper = null;\n        if (valueBeforeTxn != null || txMap.containsKey(key)) {\n            wrapper = txMap.put(key, new TxnValueWrapper(valueBeforeTxn, TxnValueWrapper.Type.REMOVED));\n        }\n        return wrapper == null ? valueBeforeTxn : checkIfRemoved(wrapper);\n    }","id":88528,"modified_method":"public Object remove(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Object valueBeforeTxn = mapServiceContext.toObject(removeInternal(keyData));\n        TxnValueWrapper wrapper = null;\n        if (valueBeforeTxn != null || txMap.containsKey(keyData)) {\n            wrapper = txMap.put(keyData, new TxnValueWrapper(valueBeforeTxn, TxnValueWrapper.Type.REMOVED));\n        }\n        return wrapper == null ? valueBeforeTxn : checkIfRemoved(wrapper);\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object putIfAbsent(Object key, Object value) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n        boolean haveTxnPast = wrapper != null;\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (haveTxnPast) {\n            if (wrapper.type != TxnValueWrapper.Type.REMOVED) {\n                return wrapper.value;\n            }\n            putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n            txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            return null;\n        } else {\n            Data oldValue\n                    = putIfAbsentInternal(mapServiceContext.toData(key, partitionStrategy),\n                    mapServiceContext.toData(value));\n            if (oldValue == null) {\n                txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","id":88529,"modified_method":"public Object putIfAbsent(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper wrapper = txMap.get(keyData);\n        boolean haveTxnPast = wrapper != null;\n        if (haveTxnPast) {\n            if (wrapper.type != TxnValueWrapper.Type.REMOVED) {\n                return wrapper.value;\n            }\n            putInternal(keyData, mapServiceContext.toData(value));\n            txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            return null;\n        } else {\n            Data oldValue\n                    = putIfAbsentInternal(keyData,\n                    mapServiceContext.toData(value));\n            if (oldValue == null) {\n                txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Set keySet(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate should not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new NullPointerException(\"Paging is not supported for Transactional queries!\");\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.KEY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> keySet = new HashSet<Object>(queryResultSet);\n\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                final Object value = entry.getValue().value instanceof Data\n                        ? mapServiceContext.toObject(entry.getValue().value) : entry.getValue().value;\n\n                final SerializationService ss = getNodeEngine().getSerializationService();\n                final QueryEntry queryEntry =\n                        new QueryEntry(ss, mapServiceContext.toData(entry.getKey()), entry.getKey(), value);\n                // apply predicate on txMap.\n                if (predicate.apply(queryEntry)) {\n                    keySet.add(entry.getKey());\n                }\n            } else {\n                // meanwhile remove keys which are not in txMap.\n                keySet.remove(entry.getKey());\n            }\n        }\n        return keySet;\n    }","id":88530,"modified_method":"public Set keySet(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate should not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new NullPointerException(\"Paging is not supported for Transactional queries!\");\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.KEY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> keySet = new HashSet<Object>(queryResultSet);\n        final SerializationService ss = getNodeEngine().getSerializationService();\n        for (final Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            Object key = ss.toObject(entry.getKey());\n            if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                Object value = entry.getValue().value instanceof Data\n                        ? mapServiceContext.toObject(entry.getValue().value) : entry.getValue().value;\n\n                QueryEntry queryEntry = new QueryEntry(ss, entry.getKey(), key, value);\n                // apply predicate on txMap.\n                if (predicate.apply(queryEntry)) {\n                    keySet.add(key);\n                }\n            } else {\n                // meanwhile remove keys which are not in txMap.\n                keySet.remove(key);\n            }\n        }\n        return keySet;\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void set(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Data dataBeforeTxn = putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n        if (value != null) {\n            TxnValueWrapper wrapper = dataBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(key, wrapper);\n        }\n    }","id":88531,"modified_method":"public void set(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Data dataBeforeTxn = putInternal(keyData, mapServiceContext.toData(value));\n        if (value != null) {\n            TxnValueWrapper wrapper = dataBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(keyData, wrapper);\n        }\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Collection<Object> values() {\n        checkTransactionState();\n        final List<Map.Entry<Data, Data>> entries = getEntries();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Collection<Object> values = new ArrayList<Object>(entries.size());\n        final Set<Object> keyWontBeIncluded = new HashSet<Object>();\n\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            Object objectKey = entry.getKey();\n            if (isRemoved) {\n                keyWontBeIncluded.add(objectKey);\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(objectKey);\n                }\n                Object entryValue = entry.getValue().value;\n                values.add(entryValue);\n            }\n        }\n        Iterator<Map.Entry<Data, Data>> iterator = entries.iterator();\n        while (iterator.hasNext()) {\n            final Map.Entry entry = iterator.next();\n            Object key = mapServiceContext.toObject(entry.getKey());\n            if (keyWontBeIncluded.contains(key)) {\n                continue;\n            }\n            Object value = mapServiceContext.toObject(entry.getValue());\n            values.add(value);\n        }\n        return values;\n    }","id":88532,"modified_method":"public Collection<Object> values() {\n        checkTransactionState();\n        final List<Map.Entry<Data, Data>> entries = getEntries();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Collection<Object> values = new ArrayList<Object>(entries.size());\n        final Set<Data> keyWontBeIncluded = new HashSet<Data>();\n\n        for (Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            if (isRemoved) {\n                keyWontBeIncluded.add(entry.getKey());\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(entry.getKey());\n                }\n                Object entryValue = entry.getValue().value;\n                values.add(entryValue);\n            }\n        }\n        Iterator<Map.Entry<Data, Data>> iterator = entries.iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = iterator.next();\n            if (keyWontBeIncluded.contains(entry.getKey())) {\n                continue;\n            }\n            Object value = mapServiceContext.toObject(entry.getValue());\n            values.add(value);\n        }\n        return values;\n    }","commit_id":"55c1b2819acd5487af5082a6340d5b8594724227","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testValuesWithPredicate_removingExistentEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"_testValuesWithPredicate_removingExistentEntry_\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final SampleObjects.Employee emp = new SampleObjects.Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                txMap.remove(1);\n                Collection<Object> coll = txMap.values(new SqlPredicate(\"age > 70 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","id":88533,"modified_method":"@Test\n    public void testValuesWithPredicate_removingExistentEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"_testValuesWithPredicate_removingExistentEntry_\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final Employee emp = new Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                txMap.remove(1);\n                Collection<Object> coll = txMap.values(new SqlPredicate(\"age > 70 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue615KeysetWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(\"default\");\n        final SampleObjects.Employee employee1 = new SampleObjects.Employee(\"abc-123-xvz\", 34, true, 10D);\n        final SampleObjects.Employee employee2 = new SampleObjects.Employee(\"abc-1xvz\", 4, true, 7D);\n        final SampleObjects.Employee employee3 = new SampleObjects.Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final SampleObjects.Employee employee4 = new SampleObjects.Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(1, employee1);\n\n\n        try {\n            boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                    final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n\n                    assertEquals(0, txMap.keySet(new SqlPredicate(\"age <= 10\")).size());\n                    //put\n                    txMap.put(2, employee2);\n                    Set keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    Iterator iterator = keys.iterator();\n\n                    assertEquals(1, keys.size());\n\n                    while (iterator.hasNext()) {\n                        assertEquals(2, ((Integer) iterator.next()).intValue());\n                    }\n\n                    txMap.put(3, employee3);\n                    txMap.put(4, employee4);\n\n                    keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    assertEquals(3, keys.size());\n\n                    // force rollback.\n                    throw new DummyUncheckedHazelcastTestException();\n                }\n            });\n        } catch (Exception e) {\n            if (!(e instanceof DummyUncheckedHazelcastTestException)) {\n                throw new RuntimeException(e);\n            }\n        }\n        assertEquals(1, map.size());\n        assertEquals(1, map.keySet().size());\n        assertEquals(0, map.keySet(new SqlPredicate(\"age <= 10\")).size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","id":88534,"modified_method":"@Test\n    public void testIssue615KeysetWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(\"default\");\n        final Employee employee1 = new Employee(\"abc-123-xvz\", 34, true, 10D);\n        final Employee employee2 = new Employee(\"abc-1xvz\", 4, true, 7D);\n        final Employee employee3 = new Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final Employee employee4 = new Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(1, employee1);\n\n\n        try {\n            h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                    final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n\n                    assertEquals(0, txMap.keySet(new SqlPredicate(\"age <= 10\")).size());\n                    //put\n                    txMap.put(2, employee2);\n                    Set keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    Iterator iterator = keys.iterator();\n\n                    assertEquals(1, keys.size());\n\n                    while (iterator.hasNext()) {\n                        assertEquals(2, ((Integer) iterator.next()).intValue());\n                    }\n\n                    txMap.put(3, employee3);\n                    txMap.put(4, employee4);\n\n                    keys = txMap.keySet(new SqlPredicate(\"age <= 10\"));\n                    assertEquals(3, keys.size());\n\n                    // force rollback.\n                    throw new DummyUncheckedHazelcastTestException();\n                }\n            });\n        } catch (Exception e) {\n            if (!(e instanceof DummyUncheckedHazelcastTestException)) {\n                throw new RuntimeException(e);\n            }\n        }\n        assertEquals(1, map.size());\n        assertEquals(1, map.keySet().size());\n        assertEquals(0, map.keySet(new SqlPredicate(\"age <= 10\")).size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testValues_resultSetContainsUpdatedEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName();\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final SampleObjects.Employee emp = new SampleObjects.Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Integer, SampleObjects.Employee> txMap = context.getMap(mapName);\n                emp.setAge(30);\n                txMap.put(1, emp);\n                Collection<SampleObjects.Employee> coll = txMap.values();\n                assertEquals(1, coll.size());\n                SampleObjects.Employee employee = coll.iterator().next();\n                assertEquals(30, employee.getAge());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","id":88535,"modified_method":"@Test\n    public void testValues_resultSetContainsUpdatedEntry() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName();\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final Employee emp = new Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Integer, Employee> txMap = context.getMap(mapName);\n                emp.setAge(30);\n                txMap.put(1, emp);\n                Collection<Employee> coll = txMap.values();\n                assertEquals(1, coll.size());\n                Employee employee = coll.iterator().next();\n                assertEquals(30, employee.getAge());\n                return true;\n            }\n        });\n        node.shutdown();\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue615ValuesWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map2 = h2.getMap(\"default\");\n        final SampleObjects.Employee emp1 = new SampleObjects.Employee(\"abc-123-xvz\", 34, true, 10D);\n        map2.put(1, emp1);\n        final SampleObjects.Employee emp2 = new SampleObjects.Employee(\"xvz\", 4, true, 10D);\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                assertEquals(0, txMap.values(new SqlPredicate(\"age <= 10\")).size());\n                txMap.put(2, emp2);\n                Collection coll = txMap.values(new SqlPredicate(\"age <= 10\"));\n                Iterator<Object> iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final SampleObjects.Employee e = (SampleObjects.Employee) iterator.next();\n                    assertEquals(emp2, e);\n                }\n                coll = txMap.values(new SqlPredicate(\"age > 30 \"));\n                iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final SampleObjects.Employee e = (SampleObjects.Employee) iterator.next();\n                    assertEquals(emp1, e);\n                }\n                txMap.remove(2);\n                coll = txMap.values(new SqlPredicate(\"age <= 10 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        assertEquals(0, map2.values(new SqlPredicate(\"age <= 10\")).size());\n        assertEquals(1, map2.values(new SqlPredicate(\"age = 34\")).size());\n        h1.shutdown();\n        h2.shutdown();\n    }","id":88536,"modified_method":"@Test\n    public void testIssue615ValuesWithPredicate() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map2 = h2.getMap(\"default\");\n        final Employee emp1 = new Employee(\"abc-123-xvz\", 34, true, 10D);\n        map2.put(1, emp1);\n        final Employee emp2 = new Employee(\"xvz\", 4, true, 10D);\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                assertEquals(0, txMap.values(new SqlPredicate(\"age <= 10\")).size());\n                txMap.put(2, emp2);\n                Collection coll = txMap.values(new SqlPredicate(\"age <= 10\"));\n                Iterator<Object> iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final Employee e = (Employee) iterator.next();\n                    assertEquals(emp2, e);\n                }\n                coll = txMap.values(new SqlPredicate(\"age > 30 \"));\n                iterator = coll.iterator();\n                while (iterator.hasNext()) {\n                    final Employee e = (Employee) iterator.next();\n                    assertEquals(emp1, e);\n                }\n                txMap.remove(2);\n                coll = txMap.values(new SqlPredicate(\"age <= 10 \"));\n                assertEquals(0, coll.size());\n                return true;\n            }\n        });\n        assertEquals(0, map2.values(new SqlPredicate(\"age <= 10\")).size());\n        assertEquals(1, map2.values(new SqlPredicate(\"age = 34\")).size());\n        h1.shutdown();\n        h2.shutdown();\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testTxnOwnerDies() throws TransactionException, InterruptedException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h3 = factory.newHazelcastInstance(config);\n        final IMap map1 = h1.getMap(\"default\");\n        final int size = 50;\n        final AtomicBoolean result = new AtomicBoolean(false);\n\n        Runnable runnable = new Runnable() {\n            public void run() {\n                try {\n                    boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                        public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                            final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                            for (int i = 0; i < size; i++) {\n                                txMap.put(i, i);\n                                sleepSeconds(1);\n                            }\n                            return true;\n                        }\n                    });\n                    result.set(b);\n                } catch (HazelcastInstanceNotActiveException ignored) {\n                } catch (TransactionException ignored) {\n                }\n            }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        sleepSeconds(1);\n\n        h1.shutdown();\n        // wait till thread finishes.\n        thread.join(30 * 1000);\n\n        assertFalse(result.get());\n        final IMap map2 = h2.getMap(\"default\");\n        for (int i = 0; i < size; i++) {\n            assertNull(map2.get(i));\n        }\n    }","id":88537,"modified_method":"@Test\n    public void testTxnOwnerDies() throws TransactionException, InterruptedException {\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n        final HazelcastInstance h1 = factory.newHazelcastInstance();\n        final HazelcastInstance h2 = factory.newHazelcastInstance();\n        final HazelcastInstance h3 = factory.newHazelcastInstance();\n        final int size = 50;\n        final AtomicBoolean result = new AtomicBoolean(false);\n\n        Runnable runnable = new Runnable() {\n            public void run() {\n                try {\n                    boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n                        public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                            final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                            for (int i = 0; i < size; i++) {\n                                txMap.put(i, i);\n                                sleepSeconds(1);\n                            }\n                            return true;\n                        }\n                    });\n                    result.set(b);\n                } catch (HazelcastInstanceNotActiveException ignored) {\n                } catch (TransactionException ignored) {\n                }\n            }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        sleepSeconds(1);\n\n        h1.shutdown();\n        // wait till thread finishes.\n        thread.join(30 * 1000);\n\n        assertFalse(result.get());\n        final IMap map2 = h2.getMap(\"default\");\n        for (int i = 0; i < size; i++) {\n            assertNull(map2.get(i));\n        }\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(expected = IllegalArgumentException.class)\n    public void testValuesWithPagingPredicate() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"testValuesWithPagingPredicate\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final SampleObjects.Employee emp = new SampleObjects.Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                PagingPredicate predicate = new PagingPredicate(5);\n                txMap.values(predicate);\n                return true;\n            }\n        });\n    }","id":88538,"modified_method":"@Test(expected = IllegalArgumentException.class)\n    public void testValuesWithPagingPredicate() throws TransactionException {\n        final int nodeCount = 1;\n        final String mapName = randomMapName(\"testValuesWithPagingPredicate\");\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(nodeCount);\n        final HazelcastInstance node = factory.newHazelcastInstance(config);\n        final IMap map = node.getMap(mapName);\n\n        final Employee emp = new Employee(\"name\", 77, true, 10D);\n        map.put(1, emp);\n\n        node.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                PagingPredicate predicate = new PagingPredicate(5);\n                txMap.values(predicate);\n                return true;\n            }\n        });\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testIssue615KeysetPredicates() throws TransactionException {\n        final String MAP_NAME = \"defaultMap\";\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(MAP_NAME);\n        final SampleObjects.Employee employee1 = new SampleObjects.Employee(\"abc-123-xvz\", 34, true, 10D);\n        final SampleObjects.Employee employee2 = new SampleObjects.Employee(\"abc-1xvz\", 4, true, 7D);\n        final SampleObjects.Employee employee3 = new SampleObjects.Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final SampleObjects.Employee employee4 = new SampleObjects.Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(employee1, employee1);\n\n        final TransactionContext context = h1.newTransactionContext();\n        context.beginTransaction();\n\n        final TransactionalMap<Object, Object> txMap = context.getMap(MAP_NAME);\n\n        assertNull(txMap.put(employee2, employee2));\n\n        assertEquals(2, txMap.size());\n        assertEquals(2, txMap.keySet().size());\n        assertEquals(1, txMap.keySet(new SqlPredicate(\"age = 34\")).size());\n\n        context.commitTransaction();\n\n\n        assertEquals(2, map.size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","id":88539,"modified_method":"@Test\n    public void testIssue615KeysetPredicates() throws TransactionException {\n        final String MAP_NAME = \"defaultMap\";\n        final Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h2.getMap(MAP_NAME);\n        final Employee employee1 = new Employee(\"abc-123-xvz\", 34, true, 10D);\n        final Employee employee2 = new Employee(\"abc-1xvz\", 4, true, 7D);\n        final Employee employee3 = new Employee(\"abc-1xasda...vz\", 7, true, 1D);\n        final Employee employee4 = new Employee(\"abc-1asdsaxvz\", 2, true, 2D);\n\n        map.put(employee1, employee1);\n\n        final TransactionContext context = h1.newTransactionContext();\n        context.beginTransaction();\n\n        final TransactionalMap<Object, Object> txMap = context.getMap(MAP_NAME);\n\n        assertNull(txMap.put(employee2, employee2));\n\n        assertEquals(2, txMap.size());\n        assertEquals(2, txMap.keySet().size());\n        assertEquals(1, txMap.keySet(new SqlPredicate(\"age = 34\")).size());\n\n        context.commitTransaction();\n\n\n        assertEquals(2, map.size());\n\n        h1.shutdown();\n        h2.shutdown();\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testValuesWithPredicates_notContains_oldValues() throws TransactionException {\n        Config config = new Config();\n        final String mapName = \"testValuesWithPredicate_notContains_oldValues\";\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final HazelcastInstance h2 = factory.newHazelcastInstance(config);\n        final IMap map = h1.getMap(mapName);\n        final SampleObjects.Employee employeeAtAge22 = new SampleObjects.Employee(\"emin\", 22, true, 10D);\n        final SampleObjects.Employee employeeAtAge23 = new SampleObjects.Employee(\"emin\", 23, true, 10D);\n        map.put(1, employeeAtAge22);\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                assertEquals(1, txMap.values(new SqlPredicate(\"age > 21\")).size());\n                txMap.put(1, employeeAtAge23);\n                Collection coll = txMap.values(new SqlPredicate(\"age > 21\"));\n                assertEquals(1, coll.size());\n                return true;\n            }\n        });\n        h1.shutdown();\n        h2.shutdown();\n\n    }","id":88540,"modified_method":"@Test\n    public void testValuesWithPredicates_notContains_oldValues() throws TransactionException {\n        final String mapName = \"testValuesWithPredicate_notContains_oldValues\";\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance();\n        final HazelcastInstance h2 = factory.newHazelcastInstance();\n        final IMap<Integer, Employee> map = h1.getMap(mapName);\n        final Employee employeeAtAge22 = new Employee(\"emin\", 22, true, 10D);\n        final Employee employeeAtAge23 = new Employee(\"emin\", 23, true, 10D);\n        map.put(1, employeeAtAge22);\n\n        h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                TransactionalMap<Object, Object> txMap = context.getMap(mapName);\n                assertEquals(1, txMap.values(new SqlPredicate(\"age > 21\")).size());\n                txMap.put(1, employeeAtAge23);\n                Collection coll = txMap.values(new SqlPredicate(\"age > 21\"));\n                assertEquals(1, coll.size());\n                return true;\n            }\n        });\n        h1.shutdown();\n        h2.shutdown();\n\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testTxnContainsKey() throws TransactionException {\n        Config config = new Config();\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance(config);\n        final IMap map = h1.getMap(\"default\");\n        map.put(\"1\", \"1\");\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                txMap.delete(\"1\");\n                assertEquals(false, txMap.containsKey(\"1\"));\n                assertEquals(true, map.containsKey(\"1\"));\n                return true;\n            }\n        });\n        assertTrue(b);\n    }","id":88541,"modified_method":"@Test\n    public void testTxnContainsKey() throws TransactionException {\n        final TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance h1 = factory.newHazelcastInstance();\n        final IMap<String, String> map = h1.getMap(\"default\");\n        map.put(\"1\", \"1\");\n\n        boolean b = h1.executeTransaction(options, new TransactionalTask<Boolean>() {\n            public Boolean execute(TransactionalTaskContext context) throws TransactionException {\n                final TransactionalMap<Object, Object> txMap = context.getMap(\"default\");\n                txMap.delete(\"1\");\n                assertEquals(false, txMap.containsKey(\"1\"));\n                assertEquals(true, map.containsKey(\"1\"));\n                return true;\n            }\n        });\n        assertTrue(b);\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object replace(Object key, Object value) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n        boolean haveTxnPast = wrapper != null;\n\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (haveTxnPast) {\n            if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                return null;\n            }\n            putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n            txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            return wrapper.value;\n        } else {\n            Data oldValue = replaceInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n            if (oldValue != null) {\n                txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","id":88542,"modified_method":"public Object replace(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n\n        TxnValueWrapper wrapper = txMap.get(keyData);\n        boolean haveTxnPast = wrapper != null;\n        if (haveTxnPast) {\n            if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                return null;\n            }\n            putInternal(keyData, mapServiceContext.toData(value));\n            txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            return wrapper.value;\n        } else {\n            Data oldValue = replaceInternal(keyData, mapServiceContext.toData(value));\n            if (oldValue != null) {\n                txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Collection<Object> values() {\n        checkTransactionState();\n        final List<Map.Entry<Data, Data>> entries = getEntries();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Collection<Object> values = new ArrayList<Object>(entries.size());\n        final Set<Object> keyWontBeIncluded = new HashSet<Object>();\n\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            Object objectKey = entry.getKey();\n            if (isRemoved) {\n                keyWontBeIncluded.add(objectKey);\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(objectKey);\n                }\n                Object entryValue = entry.getValue().value;\n                values.add(entryValue);\n            }\n        }\n        Iterator<Map.Entry<Data, Data>> iterator = entries.iterator();\n        while (iterator.hasNext()) {\n            final Map.Entry entry = iterator.next();\n            Object key = mapServiceContext.toObject(entry.getKey());\n            if (keyWontBeIncluded.contains(key)) {\n                continue;\n            }\n            Object value = mapServiceContext.toObject(entry.getValue());\n            values.add(value);\n        }\n        return values;\n    }","id":88543,"modified_method":"public Collection<Object> values() {\n        checkTransactionState();\n        final List<Map.Entry<Data, Data>> entries = getEntries();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Collection<Object> values = new ArrayList<Object>(entries.size());\n        final Set<Data> keyWontBeIncluded = new HashSet<Data>();\n\n        for (Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            if (isRemoved) {\n                keyWontBeIncluded.add(entry.getKey());\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(entry.getKey());\n                }\n                Object entryValue = entry.getValue().value;\n                values.add(entryValue);\n            }\n        }\n        Iterator<Map.Entry<Data, Data>> iterator = entries.iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = iterator.next();\n            if (keyWontBeIncluded.contains(entry.getKey())) {\n                continue;\n            }\n            Object value = mapServiceContext.toObject(entry.getValue());\n            values.add(value);\n        }\n        return values;\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object remove(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Object valueBeforeTxn\n                = mapServiceContext.toObject(removeInternal(mapServiceContext.toData(key, partitionStrategy)));\n        TxnValueWrapper wrapper = null;\n        if (valueBeforeTxn != null || txMap.containsKey(key)) {\n            wrapper = txMap.put(key, new TxnValueWrapper(valueBeforeTxn, TxnValueWrapper.Type.REMOVED));\n        }\n        return wrapper == null ? valueBeforeTxn : checkIfRemoved(wrapper);\n    }","id":88544,"modified_method":"public Object remove(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Object valueBeforeTxn = mapServiceContext.toObject(removeInternal(keyData));\n        TxnValueWrapper wrapper = null;\n        if (valueBeforeTxn != null || txMap.containsKey(keyData)) {\n            wrapper = txMap.put(keyData, new TxnValueWrapper(valueBeforeTxn, TxnValueWrapper.Type.REMOVED));\n        }\n        return wrapper == null ? valueBeforeTxn : checkIfRemoved(wrapper);\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object get(Object key) {\n        checkTransactionState();\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        return mapServiceContext.toObject(getInternal(mapServiceContext.toData(key, partitionStrategy)));\n    }","id":88545,"modified_method":"public Object get(Object key) {\n        checkTransactionState();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n        return mapServiceContext.toObject(getInternal(keyData));\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object getForUpdate(Object key) {\n        checkTransactionState();\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data dataKey = mapServiceContext.toData(key, partitionStrategy);\n        return mapServiceContext.toObject(getForUpdateInternal(dataKey));\n    }","id":88546,"modified_method":"public Object getForUpdate(Object key) {\n        checkTransactionState();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (currentValue != null) {\n            return checkIfRemoved(currentValue);\n        }\n\n        return mapServiceContext.toObject(getForUpdateInternal(keyData));\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object put(Object key, Object value, long ttl, TimeUnit timeUnit) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(mapServiceContext.toData(key, partitionStrategy),\n                mapServiceContext.toData(value), ttl, timeUnit));\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(key, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","id":88547,"modified_method":"public Object put(Object key, Object value, long ttl, TimeUnit timeUnit) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(keyData,\n                mapServiceContext.toData(value), ttl, timeUnit));\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(keyData, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean remove(Object key, Object value) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (wrapper != null && !mapServiceContext.compare(name, wrapper.value, value)) {\n            return false;\n        }\n        boolean removed = removeIfSameInternal(mapServiceContext.toData(key, partitionStrategy), value);\n        if (removed) {\n            txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.REMOVED));\n        }\n        return removed;\n    }","id":88548,"modified_method":"public boolean remove(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper wrapper = txMap.get(keyData);\n\n        if (wrapper != null && !mapServiceContext.compare(name, wrapper.value, value)) {\n            return false;\n        }\n\n        boolean removed = removeIfSameInternal(keyData, value);\n        if (removed) {\n            txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.REMOVED));\n        }\n        return removed;\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Set<Object> keySet() {\n        checkTransactionState();\n        final Set<Data> keySet = keySetInternal();\n        final Set<Object> keys = new HashSet<Object>(keySet.size());\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        // convert Data to Object\n        for (final Data data : keySet) {\n            keys.add(mapServiceContext.toObject(data));\n        }\n\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            if (TxnValueWrapper.Type.NEW.equals(entry.getValue().type)) {\n                keys.add(entry.getKey());\n            } else if (TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                keys.remove(entry.getKey());\n            }\n        }\n        return keys;\n    }","id":88549,"modified_method":"public Set<Object> keySet() {\n        checkTransactionState();\n        final Set<Data> keySet = keySetInternal();\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n\n        for (final Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            if (TxnValueWrapper.Type.NEW.equals(entry.getValue().type)) {\n                keySet.add(entry.getKey());\n            } else if (TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                keySet.remove(entry.getKey());\n            }\n        }\n        HashSet<Object> keys = new HashSet<Object>();\n        for (Data keyData : keySet) {\n            keys.add(mapServiceContext.toObject(keyData));\n        }\n        return keys;\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object putIfAbsent(Object key, Object value) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n        boolean haveTxnPast = wrapper != null;\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (haveTxnPast) {\n            if (wrapper.type != TxnValueWrapper.Type.REMOVED) {\n                return wrapper.value;\n            }\n            putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n            txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            return null;\n        } else {\n            Data oldValue\n                    = putIfAbsentInternal(mapServiceContext.toData(key, partitionStrategy),\n                    mapServiceContext.toData(value));\n            if (oldValue == null) {\n                txMap.put(key, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","id":88550,"modified_method":"public Object putIfAbsent(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper wrapper = txMap.get(keyData);\n        boolean haveTxnPast = wrapper != null;\n        if (haveTxnPast) {\n            if (wrapper.type != TxnValueWrapper.Type.REMOVED) {\n                return wrapper.value;\n            }\n            putInternal(keyData, mapServiceContext.toData(value));\n            txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            return null;\n        } else {\n            Data oldValue\n                    = putIfAbsentInternal(keyData,\n                    mapServiceContext.toData(value));\n            if (oldValue == null) {\n                txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));\n            }\n            return mapServiceContext.toObject(oldValue);\n        }\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Set keySet(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate should not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new NullPointerException(\"Paging is not supported for Transactional queries!\");\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.KEY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> keySet = new HashSet<Object>(queryResultSet);\n\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                final Object value = entry.getValue().value instanceof Data\n                        ? mapServiceContext.toObject(entry.getValue().value) : entry.getValue().value;\n\n                final SerializationService ss = getNodeEngine().getSerializationService();\n                final QueryEntry queryEntry =\n                        new QueryEntry(ss, mapServiceContext.toData(entry.getKey()), entry.getKey(), value);\n                // apply predicate on txMap.\n                if (predicate.apply(queryEntry)) {\n                    keySet.add(entry.getKey());\n                }\n            } else {\n                // meanwhile remove keys which are not in txMap.\n                keySet.remove(entry.getKey());\n            }\n        }\n        return keySet;\n    }","id":88551,"modified_method":"public Set keySet(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate should not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new NullPointerException(\"Paging is not supported for Transactional queries!\");\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.KEY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> keySet = new HashSet<Object>(queryResultSet);\n        final SerializationService ss = getNodeEngine().getSerializationService();\n        for (final Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            Object key = ss.toObject(entry.getKey());\n            if (!TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type)) {\n                Object value = entry.getValue().value instanceof Data\n                        ? mapServiceContext.toObject(entry.getValue().value) : entry.getValue().value;\n\n                QueryEntry queryEntry = new QueryEntry(ss, entry.getKey(), key, value);\n                // apply predicate on txMap.\n                if (predicate.apply(queryEntry)) {\n                    keySet.add(key);\n                }\n            } else {\n                // meanwhile remove keys which are not in txMap.\n                keySet.remove(key);\n            }\n        }\n        return keySet;\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object put(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(mapServiceContext.toData(key, partitionStrategy),\n                mapServiceContext.toData(value)));\n        TxnValueWrapper currentValue = txMap.get(key);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n\n            txMap.put(key, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","id":88552,"modified_method":"public Object put(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Object valueBeforeTxn = mapServiceContext.toObject(putInternal(keyData, mapServiceContext.toData(value)));\n        TxnValueWrapper currentValue = txMap.get(keyData);\n        if (value != null) {\n            TxnValueWrapper wrapper = valueBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n\n            txMap.put(keyData, wrapper);\n        }\n        return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Collection values(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate can not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new IllegalArgumentException(\"Paging is not supported for Transactional queries\");\n        }\n        final MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.ENTRY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> valueSet = new HashSet<Object>();\n        final Set<Object> keyWontBeIncluded = new HashSet<Object>();\n\n        // iterate over the txMap and see if the values are updated or removed.\n        for (final Map.Entry<Object, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            Object objectKey = entry.getKey();\n            if (isRemoved) {\n                keyWontBeIncluded.add(objectKey);\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(objectKey);\n                }\n                Object entryValue = entry.getValue().value;\n                final Object objectValue = entryValue instanceof Data\n                        ? mapServiceContext.toObject(entryValue) : entryValue;\n                Data dataKey = mapServiceContext.toData(objectKey);\n                final SerializationService serializationService = getNodeEngine().getSerializationService();\n                final QueryEntry queryEntry = new QueryEntry(serializationService, dataKey, objectKey, objectValue);\n                if (predicate.apply(queryEntry)) {\n                    valueSet.add(entryValue);\n                }\n            }\n        }\n        removeFromResultSet(queryResultSet, valueSet, keyWontBeIncluded);\n        return valueSet;\n    }","id":88553,"modified_method":"public Collection values(Predicate predicate) {\n        checkTransactionState();\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate can not be null!\");\n        }\n        if (predicate instanceof PagingPredicate) {\n            throw new IllegalArgumentException(\"Paging is not supported for Transactional queries\");\n        }\n        final QueryResultSet queryResultSet = (QueryResultSet) queryInternal(predicate, IterationType.ENTRY, false);\n        //todo: Can't we just use the original set?\n        final Set<Object> valueSet = new HashSet<Object>();\n        final Set<Object> keyWontBeIncluded = new HashSet<Object>();\n\n        SerializationService serializationService = getNodeEngine().getSerializationService();\n        // iterate over the txMap and see if the values are updated or removed.\n        for (Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            final boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(entry.getValue().type);\n            final boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(entry.getValue().type);\n\n            Object keyObject = serializationService.toObject(entry.getKey());\n            if (isRemoved) {\n                keyWontBeIncluded.add(keyObject);\n            } else {\n                if (isUpdated) {\n                    keyWontBeIncluded.add(keyObject);\n                }\n                Object entryValue = entry.getValue().value;\n\n                QueryEntry queryEntry = new QueryEntry(serializationService, entry.getKey(), keyObject, entryValue);\n                if (predicate.apply(queryEntry)) {\n                    valueSet.add(queryEntry.getValue());\n                }\n            }\n        }\n        removeFromResultSet(queryResultSet, valueSet, keyWontBeIncluded);\n        return valueSet;\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean containsKey(Object key) {\n        checkTransactionState();\n        final TxnValueWrapper valueWrapper = txMap.get(key);\n        if (valueWrapper != null) {\n            return valueWrapper.type == TxnValueWrapper.Type.REMOVED ? false : true;\n        }\n        return containsKeyInternal(getService().getMapServiceContext().toData(key, partitionStrategy));\n    }","id":88554,"modified_method":"public boolean containsKey(Object key) {\n        checkTransactionState();\n        Data keyData = getService().getMapServiceContext().toData(key, partitionStrategy);\n        final TxnValueWrapper valueWrapper = txMap.get(keyData);\n        if (valueWrapper != null) {\n            return valueWrapper.type == TxnValueWrapper.Type.REMOVED ? false : true;\n        }\n        return containsKeyInternal(keyData);\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public int size() {\n        checkTransactionState();\n        int currentSize = sizeInternal();\n        for (TxnValueWrapper wrapper : txMap.values()) {\n            if (wrapper.type == TxnValueWrapper.Type.NEW) {\n                currentSize++;\n            } else if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                currentSize--;\n            }\n        }\n        return currentSize;\n    }","id":88555,"modified_method":"public int size() {\n        checkTransactionState();\n        int currentSize = sizeInternal();\n        for (Map.Entry<Data, TxnValueWrapper> entry : txMap.entrySet()) {\n            TxnValueWrapper wrapper = entry.getValue();\n            if (wrapper.type == TxnValueWrapper.Type.NEW) {\n                currentSize++;\n            } else if (wrapper.type == TxnValueWrapper.Type.REMOVED) {\n                VersionedValue versionedValue = valueMap.get(entry.getKey());\n                if (versionedValue != null && versionedValue.value != null) {\n                    currentSize--;\n                }\n            }\n        }\n        return currentSize;\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void delete(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data data = removeInternal(mapServiceContext.toData(key, partitionStrategy));\n        if (data != null || txMap.containsKey(key)) {\n            txMap.put(key, new TxnValueWrapper(mapServiceContext.toObject(data), TxnValueWrapper.Type.REMOVED));\n        }\n    }","id":88556,"modified_method":"public void delete(Object key) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        Data data = removeInternal(keyData);\n        if (data != null || txMap.containsKey(keyData)) {\n            txMap.put(keyData, new TxnValueWrapper(mapServiceContext.toObject(data), TxnValueWrapper.Type.REMOVED));\n        }\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean replace(Object key, Object oldValue, Object newValue) {\n        checkTransactionState();\n        TxnValueWrapper wrapper = txMap.get(key);\n        boolean haveTxnPast = wrapper != null;\n\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        if (haveTxnPast) {\n            if (!wrapper.value.equals(oldValue)) {\n                return false;\n            }\n            putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(newValue));\n            txMap.put(key, new TxnValueWrapper(wrapper.value, TxnValueWrapper.Type.UPDATED));\n            return true;\n        } else {\n            boolean success = replaceIfSameInternal(mapServiceContext.toData(key),\n                    mapServiceContext.toData(oldValue), mapServiceContext.toData(newValue));\n            if (success) {\n                txMap.put(key, new TxnValueWrapper(newValue, TxnValueWrapper.Type.UPDATED));\n            }\n            return success;\n        }\n    }","id":88557,"modified_method":"public boolean replace(Object key, Object oldValue, Object newValue) {\n        checkTransactionState();\n        MapService service = getService();\n        MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        TxnValueWrapper wrapper = txMap.get(keyData);\n        boolean haveTxnPast = wrapper != null;\n\n        if (haveTxnPast) {\n            if (!wrapper.value.equals(oldValue)) {\n                return false;\n            }\n            putInternal(keyData, mapServiceContext.toData(newValue));\n            txMap.put(keyData, new TxnValueWrapper(wrapper.value, TxnValueWrapper.Type.UPDATED));\n            return true;\n        } else {\n            boolean success = replaceIfSameInternal(keyData,\n                    mapServiceContext.toData(oldValue), mapServiceContext.toData(newValue));\n            if (success) {\n                txMap.put(keyData, new TxnValueWrapper(newValue, TxnValueWrapper.Type.UPDATED));\n            }\n            return success;\n        }\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void set(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        final Data dataBeforeTxn = putInternal(mapServiceContext.toData(key, partitionStrategy), mapServiceContext.toData(value));\n        if (value != null) {\n            TxnValueWrapper wrapper = dataBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(key, wrapper);\n        }\n    }","id":88558,"modified_method":"public void set(Object key, Object value) {\n        checkTransactionState();\n        MapService service = getService();\n        final MapServiceContext mapServiceContext = service.getMapServiceContext();\n        Data keyData = mapServiceContext.toData(key, partitionStrategy);\n        final Data dataBeforeTxn = putInternal(keyData, mapServiceContext.toData(value));\n        if (value != null) {\n            TxnValueWrapper wrapper = dataBeforeTxn == null\n                    ? new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)\n                    : new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED);\n            txMap.put(keyData, wrapper);\n        }\n    }","commit_id":"7794501797eed5250325767450165bd64fa45cd6","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Long> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        long socketRef = socket.getSocket().longValue();\n        Socket.setrbb(socketRef, inputBuffer);\n        Socket.setsbb(socketRef, outputBuffer);\n\n        // Error flag\n        error = false;\n\n        boolean keptAlive = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage, true, keptAlive)) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    if (Socket.sendb(socketRef, pongMessageBuffer, 0,\n                            pongMessageBuffer.position()) < 0) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    continue;\n                }\n\n                keptAlive = true;\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Setting up filters, and parse some request headers\n            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n            try {\n                prepareRequest();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                // 400 - Internal Server Error\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n        }\n\n        // Add the socket to the poller\n        if (!error && !endpoint.isPaused()) {\n            if (!isAsync()) {\n                ((AprEndpoint)endpoint).getPoller().add(socketRef);\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        \n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (isAsync()) {\n            return SocketState.LONG;\n        } else {\n            return SocketState.OPEN;\n        }\n    }","id":88559,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Long> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        long socketRef = socket.getSocket().longValue();\n        Socket.setrbb(socketRef, inputBuffer);\n        Socket.setsbb(socketRef, outputBuffer);\n\n        // Error flag\n        error = false;\n\n        boolean keptAlive = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage, true, keptAlive)) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    if (Socket.sendb(socketRef, pongMessageBuffer, 0,\n                            pongMessageBuffer.position()) < 0) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    continue;\n                }\n\n                keptAlive = true;\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n        }\n\n        // Add the socket to the poller\n        if (!error && !endpoint.isPaused()) {\n            if (!isAsync()) {\n                ((AprEndpoint)endpoint).getPoller().add(socketRef);\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        \n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (isAsync()) {\n            return SocketState.LONG;\n        } else {\n            return SocketState.OPEN;\n        }\n    }","commit_id":"fb3409f72403c65149bfa8cd1ca84293223494e0","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Read an AJP message.\n     *\n     * @param first is true if the message is the first in the request, which\n     *        will cause a short duration blocking read\n     * @return true if the message has been read, false if the short read\n     *         didn't return anything\n     * @throws IOException any other failure, including incomplete reads\n     */\n    protected boolean readMessage(AjpMessage message, boolean first,\n            boolean useAvailableData)\n        throws IOException {\n\n        int headerLength = message.getHeaderLength();\n\n        if (first) {\n            if (!readt(headerLength, useAvailableData)) {\n                return false;\n            }\n        } else {\n            read(headerLength);\n        }\n        inputBuffer.get(message.getBuffer(), 0, headerLength);\n        int messageLength = message.processHeader();\n        if (messageLength < 0) {\n            // Invalid AJP header signature\n            // TODO: Throw some exception and close the connection to frontend.\n            return false;\n        }\n        else if (messageLength == 0) {\n            // Zero length message.\n            return true;\n        }\n        else {\n            read(messageLength);\n            inputBuffer.get(message.getBuffer(), headerLength, messageLength);\n            return true;\n        }\n\n    }","id":88560,"modified_method":"/**\n     * Read an AJP message.\n     *\n     * @param first is true if the message is the first in the request, which\n     *        will cause a short duration blocking read\n     * @return true if the message has been read, false if the short read\n     *         didn't return anything\n     * @throws IOException any other failure, including incomplete reads\n     */\n    protected boolean readMessage(AjpMessage message, boolean first,\n            boolean useAvailableData)\n        throws IOException {\n\n        int headerLength = message.getHeaderLength();\n\n        if (first) {\n            if (!readt(headerLength, useAvailableData)) {\n                return false;\n            }\n        } else {\n            read(headerLength);\n        }\n        inputBuffer.get(message.getBuffer(), 0, headerLength);\n        int messageLength = message.processHeader();\n        if (messageLength < 0) {\n            // Invalid AJP header signature\n            // TODO: Throw some exception and close the connection to frontend.\n            return false;\n        }\n        else if (messageLength == 0) {\n            // Zero length message.\n            return true;\n        }\n        else {\n            if (messageLength > message.getBuffer().length) {\n                // Message too long for the buffer\n                // Need to trigger a 400 response\n                throw new IllegalArgumentException(sm.getString(\n                        \"ajpprocessor.header.tooLong\",\n                        Integer.valueOf(messageLength),\n                        Integer.valueOf(message.getBuffer().length)));\n            }\n            read(messageLength);\n            inputBuffer.get(message.getBuffer(), headerLength, messageLength);\n            return true;\n        }\n\n    }","commit_id":"fb3409f72403c65149bfa8cd1ca84293223494e0","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Read an AJP message.\n     *\n     * @return true if the message has been read, false if the short read\n     *         didn't return anything\n     * @throws IOException any other failure, including incomplete reads\n     */\n    protected boolean readMessage(AjpMessage message)\n        throws IOException {\n\n        byte[] buf = message.getBuffer();\n        int headerLength = message.getHeaderLength();\n\n        read(buf, 0, headerLength);\n\n        int messageLength = message.processHeader();\n        if (messageLength < 0) {\n            // Invalid AJP header signature\n            // TODO: Throw some exception and close the connection to frontend.\n            return false;\n        }\n        else if (messageLength == 0) {\n            // Zero length message.\n            return true;\n        }\n        else {\n            read(buf, headerLength, messageLength);\n            return true;\n        }\n    }","id":88561,"modified_method":"/**\n     * Read an AJP message.\n     *\n     * @return true if the message has been read, false if the short read\n     *         didn't return anything\n     * @throws IOException any other failure, including incomplete reads\n     */\n    protected boolean readMessage(AjpMessage message)\n        throws IOException {\n\n        byte[] buf = message.getBuffer();\n        int headerLength = message.getHeaderLength();\n\n        read(buf, 0, headerLength);\n\n        int messageLength = message.processHeader();\n        if (messageLength < 0) {\n            // Invalid AJP header signature\n            // TODO: Throw some exception and close the connection to frontend.\n            return false;\n        }\n        else if (messageLength == 0) {\n            // Zero length message.\n            return true;\n        }\n        else {\n            if (messageLength > buf.length) {\n                // Message too long for the buffer\n                // Need to trigger a 400 response\n                throw new IllegalArgumentException(sm.getString(\n                        \"ajpprocessor.header.tooLong\",\n                        Integer.valueOf(messageLength),\n                        Integer.valueOf(buf.length)));\n            }\n            read(buf, headerLength, messageLength);\n            return true;\n        }\n    }","commit_id":"fb3409f72403c65149bfa8cd1ca84293223494e0","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Socket> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        input = socket.getSocket().getInputStream();\n        output = socket.getSocket().getOutputStream();\n        int soTimeout = -1;\n        if (keepAliveTimeout > 0) {\n            soTimeout = socket.getSocket().getSoTimeout();\n        }\n\n        // Error flag\n        error = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Set keep alive timeout if enabled\n                if (keepAliveTimeout > 0) {\n                    socket.getSocket().setSoTimeout(keepAliveTimeout);\n                }\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage)) {\n                    // This means a connection timeout\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Set back timeout if keep alive timeout is enabled\n                if (keepAliveTimeout > 0) {\n                    socket.getSocket().setSoTimeout(soTimeout);\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    try {\n                        output.write(pongMessageArray);\n                    } catch (IOException e) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    continue;\n                }\n\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Setting up filters, and parse some request headers\n            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n            try {\n                prepareRequest();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                // 400 - Internal Server Error\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (endpoint.isPaused()) {\n                // 503 - Service unavailable\n                response.setStatus(503);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n        }\n        \n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (isAsync() && !error && !endpoint.isPaused()) {\n            return SocketState.LONG;\n        } else {\n            input = null;\n            output = null;\n            return SocketState.CLOSED;\n        }\n        \n    }","id":88562,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Socket> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        input = socket.getSocket().getInputStream();\n        output = socket.getSocket().getOutputStream();\n        int soTimeout = -1;\n        if (keepAliveTimeout > 0) {\n            soTimeout = socket.getSocket().getSoTimeout();\n        }\n\n        // Error flag\n        error = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Set keep alive timeout if enabled\n                if (keepAliveTimeout > 0) {\n                    socket.getSocket().setSoTimeout(keepAliveTimeout);\n                }\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage)) {\n                    // This means a connection timeout\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Set back timeout if keep alive timeout is enabled\n                if (keepAliveTimeout > 0) {\n                    socket.getSocket().setSoTimeout(soTimeout);\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    try {\n                        output.write(pongMessageArray);\n                    } catch (IOException e) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    continue;\n                }\n\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (endpoint.isPaused()) {\n                // 503 - Service unavailable\n                response.setStatus(503);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n        }\n        \n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (isAsync() && !error && !endpoint.isPaused()) {\n            return SocketState.LONG;\n        } else {\n            input = null;\n            output = null;\n            return SocketState.CLOSED;\n        }\n        \n    }","commit_id":"fb3409f72403c65149bfa8cd1ca84293223494e0","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Send an action to the connector.\n     *\n     * @param actionCode Type of the action\n     * @param param Action parameter\n     */\n    public void action(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.ACTION_COMMIT) {\n\n            if (response.isCommitted())\n                return;\n\n            // Validate and write response headers\n            try {\n                prepareResponse();\n            } catch (IOException e) {\n                // Set error flag\n                error = true;\n            }\n\n        } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) {\n\n            if (!response.isCommitted()) {\n                // Validate and write response headers\n                try {\n                    prepareResponse();\n                } catch (IOException e) {\n                    // Set error flag\n                    error = true;\n                    return;\n                }\n            }\n\n            try {\n                flush();\n            } catch (IOException e) {\n                // Set error flag\n                error = true;\n            }\n\n        } else if (actionCode == ActionCode.ACTION_CLOSE) {\n            // Close\n\n            // End the processing of the current request, and stop any further\n            // transactions with the client\n\n            try {\n                finish();\n            } catch (IOException e) {\n                // Set error flag\n                error = true;\n            }\n\n        } else if (actionCode == ActionCode.ACTION_START) {\n\n            started = true;\n\n        } else if (actionCode == ActionCode.ACTION_STOP) {\n\n            started = false;\n\n        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {\n\n            if (!certificates.isNull()) {\n                ByteChunk certData = certificates.getByteChunk();\n                X509Certificate jsseCerts[] = null;\n                ByteArrayInputStream bais =\n                    new ByteArrayInputStream(certData.getBytes(),\n                            certData.getStart(),\n                            certData.getLength());\n                // Fill the  elements.\n                try {\n                    CertificateFactory cf =\n                        CertificateFactory.getInstance(\"X.509\");\n                    while(bais.available() > 0) {\n                        X509Certificate cert = (X509Certificate)\n                            cf.generateCertificate(bais);\n                        if(jsseCerts == null) {\n                            jsseCerts = new X509Certificate[1];\n                            jsseCerts[0] = cert;\n                        } else {\n                            X509Certificate [] temp = new X509Certificate[jsseCerts.length+1];\n                            System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);\n                            temp[jsseCerts.length] = cert;\n                            jsseCerts = temp;\n                        }\n                    }\n                } catch (java.security.cert.CertificateException e) {\n                    log.error(sm.getString(\"ajpprocessor.certs.fail\"), e);\n                    return;\n                }\n                request.setAttribute(AbstractEndpoint.CERTIFICATE_KEY, jsseCerts);\n            }\n\n        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {\n\n            // Get remote host name using a DNS resolution\n            if (request.remoteHost().isNull()) {\n                try {\n                    request.remoteHost().setString(InetAddress.getByName\n                            (request.remoteAddr().toString()).getHostName());\n                } catch (IOException iex) {\n                    // Ignore\n                }\n            }\n\n        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {\n\n            // Copy from local name for now, which should simply be an address\n            request.localAddr().setString(request.localName().toString());\n\n        } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) {\n\n            // Set the given bytes as the content\n            ByteChunk bc = (ByteChunk) param;\n            int length = bc.getLength();\n            bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length);\n            request.setContentLength(length);\n            first = false;\n            empty = false;\n            replay = true;\n\n        }\n\n\n    }","id":88563,"modified_method":"/**\n     * Send an action to the connector.\n     *\n     * @param actionCode Type of the action\n     * @param param Action parameter\n     */\n    public void action(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.ACTION_COMMIT) {\n\n            if (response.isCommitted())\n                return;\n\n            // Validate and write response headers\n            try {\n                prepareResponse();\n            } catch (IOException e) {\n                // Set error flag\n                error = true;\n            }\n\n        } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) {\n\n            if (!response.isCommitted()) {\n                // Validate and write response headers\n                try {\n                    prepareResponse();\n                } catch (IOException e) {\n                    // Set error flag\n                    error = true;\n                    return;\n                }\n            }\n\n            try {\n                flush();\n            } catch (IOException e) {\n                // Set error flag\n                error = true;\n            }\n\n        } else if (actionCode == ActionCode.ACTION_CLOSE) {\n            // Close\n            async = false;\n            // End the processing of the current request, and stop any further\n            // transactions with the client\n\n            try {\n                finish();\n            } catch (IOException e) {\n                // Set error flag\n                error = true;\n            }\n\n        } else if (actionCode == ActionCode.ACTION_START) {\n\n            started = true;\n\n        } else if (actionCode == ActionCode.ACTION_STOP) {\n\n            started = false;\n\n        } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {\n\n            if (!certificates.isNull()) {\n                ByteChunk certData = certificates.getByteChunk();\n                X509Certificate jsseCerts[] = null;\n                ByteArrayInputStream bais =\n                    new ByteArrayInputStream(certData.getBytes(),\n                            certData.getStart(),\n                            certData.getLength());\n                // Fill the  elements.\n                try {\n                    CertificateFactory cf =\n                        CertificateFactory.getInstance(\"X.509\");\n                    while(bais.available() > 0) {\n                        X509Certificate cert = (X509Certificate)\n                            cf.generateCertificate(bais);\n                        if(jsseCerts == null) {\n                            jsseCerts = new X509Certificate[1];\n                            jsseCerts[0] = cert;\n                        } else {\n                            X509Certificate [] temp = new X509Certificate[jsseCerts.length+1];\n                            System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);\n                            temp[jsseCerts.length] = cert;\n                            jsseCerts = temp;\n                        }\n                    }\n                } catch (java.security.cert.CertificateException e) {\n                    log.error(sm.getString(\"ajpprocessor.certs.fail\"), e);\n                    return;\n                }\n                request.setAttribute(AbstractEndpoint.CERTIFICATE_KEY, jsseCerts);\n            }\n\n        } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {\n\n            // Get remote host name using a DNS resolution\n            if (request.remoteHost().isNull()) {\n                try {\n                    request.remoteHost().setString(InetAddress.getByName\n                            (request.remoteAddr().toString()).getHostName());\n                } catch (IOException iex) {\n                    // Ignore\n                }\n            }\n\n        } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {\n\n            // Copy from local name for now, which should simply be an address\n            request.localAddr().setString(request.localName().toString());\n\n        } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) {\n\n            // Set the given bytes as the content\n            ByteChunk bc = (ByteChunk) param;\n            int length = bc.getLength();\n            bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length);\n            request.setContentLength(length);\n            first = false;\n            empty = false;\n            replay = true;\n\n        }  else if (actionCode == ActionCode.ACTION_ASYNC_START) {\n            //TODO SERVLET3 - async\n            async = true;\n        } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {\n          //TODO SERVLET3 - async\n            AtomicBoolean dispatch = (AtomicBoolean)param;\n            RequestInfo rp = request.getRequestProcessor();\n            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) { //async handling\n                dispatch.set(true);\n                endpoint.processSocket(this.socket, SocketStatus.STOP);\n            } else {\n                dispatch.set(true);\n            }\n        } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {\n          //TODO SERVLET3 - async\n            if (param==null) return;\n            long timeout = ((Long)param).longValue();\n            //if we are not piggy backing on a worker thread, set the timeout\n            socket.setTimeout(timeout);\n        } else if (actionCode == ActionCode.ACTION_ASYNC_DISPATCH) {\n            RequestInfo rp = request.getRequestProcessor();\n            AtomicBoolean dispatch = (AtomicBoolean)param;\n            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling\n                endpoint.processSocket(this.socket, SocketStatus.OPEN);\n                dispatch.set(true);\n            } else { \n                dispatch.set(true);\n            }\n        }\n\n\n    }","commit_id":"8a5843ccb3924bf376559702520aedc25e11f906","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public void process(Socket socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        input = socket.getInputStream();\n        output = socket.getOutputStream();\n        int soTimeout = -1;\n        if (keepAliveTimeout > 0) {\n            soTimeout = socket.getSoTimeout();\n        }\n\n        // Error flag\n        error = false;\n\n        while (started && !error) {\n\n            // Parsing the request header\n            try {\n                // Set keep alive timeout if enabled\n                if (keepAliveTimeout > 0) {\n                    socket.setSoTimeout(keepAliveTimeout);\n                }\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage)) {\n                    // This means a connection timeout\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Set back timeout if keep alive timeout is enabled\n                if (keepAliveTimeout > 0) {\n                    socket.setSoTimeout(soTimeout);\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    try {\n                        output.write(pongMessageArray);\n                    } catch (IOException e) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    continue;\n                }\n\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                error = true;\n            }\n\n            // Setting up filters, and parse some request headers\n            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n            try {\n                prepareRequest();\n            } catch (Throwable t) {\n                log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                // 400 - Internal Server Error\n                response.setStatus(400);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    error = true;\n                }\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        recycle();\n        input = null;\n        output = null;\n        \n    }","id":88564,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    public SocketState process(SocketWrapper<Socket> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        input = socket.getSocket().getInputStream();\n        output = socket.getSocket().getOutputStream();\n        int soTimeout = -1;\n        if (keepAliveTimeout > 0) {\n            soTimeout = socket.getSocket().getSoTimeout();\n        }\n\n        // Error flag\n        error = false;\n\n        while (started && !error) {\n\n            // Parsing the request header\n            try {\n                // Set keep alive timeout if enabled\n                if (keepAliveTimeout > 0) {\n                    socket.getSocket().setSoTimeout(keepAliveTimeout);\n                }\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage)) {\n                    // This means a connection timeout\n                    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n                    break;\n                }\n                // Set back timeout if keep alive timeout is enabled\n                if (keepAliveTimeout > 0) {\n                    socket.getSocket().setSoTimeout(soTimeout);\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    try {\n                        output.write(pongMessageArray);\n                    } catch (IOException e) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Usually the servlet didn't read the previous request body\n                    if(log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \"+type);\n                    }\n                    continue;\n                }\n\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                error = true;\n            }\n\n            // Setting up filters, and parse some request headers\n            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n            try {\n                prepareRequest();\n            } catch (Throwable t) {\n                log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                // 400 - Internal Server Error\n                response.setStatus(400);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    error = true;\n                }\n            }\n            \n            if (async && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle();\n\n        }\n        if (async && !error) {\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n            socket.setAsync(true);\n            return SocketState.LONG;\n        } else {\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n            recycle();\n            input = null;\n            output = null;\n            return SocketState.CLOSED;\n        }\n        \n    }","commit_id":"8a5843ccb3924bf376559702520aedc25e11f906","url":"https://github.com/apache/tomcat"},{"original_method":"public SocketState process(SocketWrapper<Socket> socket) {\n            AjpProcessor processor = recycledProcessors.poll();\n            try {\n\n                if (processor == null) {\n                    processor = createProcessor();\n                }\n\n                processor.action(ActionCode.ACTION_START, null);\n\n                processor.process(socket.getSocket());\n                return SocketState.CLOSED;\n\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                AjpProtocol.log.debug\n                    (sm.getString\n                     (\"ajpprotocol.proto.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                AjpProtocol.log.debug\n                    (sm.getString\n                     (\"ajpprotocol.proto.ioexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (Throwable e) {\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                AjpProtocol.log.error\n                    (sm.getString(\"ajpprotocol.proto.error\"), e);\n            } finally {\n                processor.action(ActionCode.ACTION_STOP, null);\n                recycledProcessors.offer(processor);\n            }\n            return SocketState.CLOSED;\n        }","id":88565,"modified_method":"public SocketState process(SocketWrapper<Socket> socket) {\n            return process(socket,SocketStatus.OPEN);\n        }","commit_id":"8a5843ccb3924bf376559702520aedc25e11f906","url":"https://github.com/apache/tomcat"},{"original_method":"public SocketState process(SocketWrapper<Socket> socket, SocketStatus status) {\n            throw new UnsupportedOperationException();\n        }","id":88566,"modified_method":"public SocketState process(SocketWrapper<Socket> socket, SocketStatus status) {\n            AjpProcessor processor = connections.remove(socket);\n            try {\n                if (processor == null) {\n                    processor = recycledProcessors.poll();\n                }\n                if (processor == null) {\n                    processor = createProcessor();\n                }\n                processor.action(ActionCode.ACTION_START, null);\n\n                SocketState state = socket.isAsync()?processor.asyncDispatch(status):processor.process(socket);\n                if (state == SocketState.LONG) {\n                    connections.put(socket, processor);\n                } else {\n                    connections.remove(socket);\n                }\n                return state;\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                AjpProtocol.log.debug\n                    (sm.getString\n                     (\"ajpprotocol.proto.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                AjpProtocol.log.debug\n                    (sm.getString\n                     (\"ajpprotocol.proto.ioexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (Throwable e) {\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                AjpProtocol.log.error\n                    (sm.getString(\"ajpprotocol.proto.error\"), e);\n            } finally {\n                processor.action(ActionCode.ACTION_STOP, null);\n                recycledProcessors.offer(processor);\n            }\n            return SocketState.CLOSED;\n        }","commit_id":"8a5843ccb3924bf376559702520aedc25e11f906","url":"https://github.com/apache/tomcat"},{"original_method":"@After\n    public void tearDown() throws Exception\n    {\n        cleanUpTestFolder();\n\n        sftpClient.disconnect();\n\n        if (sftpServer != null)\n        {\n            sftpServer.stop();\n        }\n    }","id":88567,"modified_method":"@After\n    public void tearDown() throws Exception\n    {\n        // In case there was a failure in @Before and the client is not set, avoid throwing an NPE that would hide the\n        // first exception.\n        if (sftpClient != null)\n        {\n            cleanUpTestFolder();\n\n            sftpClient.disconnect();\n        }\n\n        if (sftpServer != null)\n        {\n            sftpServer.stop();\n        }\n    }","commit_id":"f0d86fdc325cfdc02f9d3888cdefe667a629eabb","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void stopSftpServerAndClient() throws Exception\n    {\n        sftpServer.stop();\n        sftpClient.disconnect();\n    }","id":88568,"modified_method":"protected void stopSftpServerAndClient() throws Exception\n    {\n        sftpClient.disconnect();\n        sftpServer.stop();\n    }","commit_id":"f0d86fdc325cfdc02f9d3888cdefe667a629eabb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\r\n\tpublic void destroy() {\r\n\t\tSystem.out.println(\"Desktop Sharing Applet Destroy\");\r\n\t\tclient.stop();\r\n\t\tsuper.destroy();\r\n\t}","id":88569,"modified_method":"@Override\r\n\tpublic void destroy() {\r\n\t\t/* We make this a privileged job.\r\n\t\t* The privileges of the javascript code  are 'anded' with the \r\n                * java privs. Sometimes (depending on jre version, browser, etc.)\r\n                * javascript will not have the privs to do some of the operations \r\n                * required for destroy, particularly network related activities,\r\n\t\t* but java does. So we make sure here that we run only considering\r\n                * java privs, not javascript's. This should be 'security safe', since\r\n                * we are only shutting things down.\r\n\t\t*/ \r\n                try {\r\n \t\t\tAccessController.doPrivileged( this.new DestroyJob() );\r\n                } catch ( PrivilegedActionException e) {\r\n\t\t\tSystem.out.println(\"Exception during Desktop Sharing Applet Stopping\"+e.toString());\r\n\t\t\tUncheckedExceptions.spit((Exception) e.getException());\r\n\t\t}\r\n\t\tsuper.destroy();\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void handleCaptureUpdateRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\r\n\t\t// MultipartFile is a copy of file in memory, not in file system\r\n\t\tMultipartFile multipartFile = multipartRequest.getFile(\"blockdata\");\r\n\t\r\n\t\tlong startRx = System.currentTimeMillis();\r\n\t\t\r\n\t\tbyte[] blockData = multipartFile.getBytes();\r\n\t\tString room = request.getParameterValues(\"room\")[0];\r\n\t\tString seqNum = request.getParameterValues(\"sequenceNumber\")[0];\r\n\t\tString keyframe = request.getParameterValues(\"keyframe\")[0];\r\n\t\tString position = request.getParameterValues(\"position\")[0];\r\n\t\t\t\t\r\n\t\tif (! hasSessionManager) {\r\n\t\t\tsessionManager = getSessionManager();\r\n\t\t\thasSessionManager = true;\r\n\t\t}\r\n\t\t\t\r\n\t\tsessionManager.updateBlock(room, Integer.valueOf(position), blockData, Boolean.parseBoolean(keyframe), Integer.parseInt(seqNum));\r\n\t}","id":88570,"modified_method":"private void handleCaptureUpdateRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n\r\n\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\r\n\r\n\r\n      String room = request.getParameterValues(\"room\")[0];\r\n      String keyframe = \"false\";  // This data is never a keyframe\r\n\r\n      //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n      // Get the list of multipart files that are in this POST request.\r\n      // Get the block info from each embedded file and send it to the\r\n      // session manager to update the viewers.\r\n      //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n      Iterator uploadedFilenames = multipartRequest.getFileNames();\r\n      while(uploadedFilenames.hasNext())\r\n      { // process each embedded upload-file (block)\r\n\r\n         String uploadedFilename = (String)uploadedFilenames.next();\r\n         MultipartFile multipartFile = multipartRequest.getFile(uploadedFilename);\r\n\r\n         // Parse the block info out of the upload file name\r\n         // The file name is of format \"blockgroup_<seqnum>_<position>\".\r\n         String[] uploadedFileInfo = uploadedFilename.split(\"[_]\");\r\n         \r\n         String seqNum = uploadedFileInfo[1];\r\n         String position = uploadedFileInfo[2];\r\n\r\n         // Update the viewers with the uploaded block data.\r\n         sessionManager.updateBlock(room,\r\n                                    Integer.valueOf(position),\r\n                                    multipartFile.getBytes(),\r\n                                    false, // This data is never a keyframe\r\n                                    Integer.parseInt(seqNum));\r\n\r\n      } // process each embedded upload-file (block)\r\n\r\n /*\r\n\t\t// MultipartFile is a copy of file in memory, not in file system\r\n\t\tMultipartFile multipartFile = multipartRequest.getFile(\"blockdata\");\r\n\t\r\n\t\tlong startRx = System.currentTimeMillis();\r\n\t\t\r\n\t\tbyte[] blockData = multipartFile.getBytes();\r\n\t\tString room = request.getParameterValues(\"room\")[0];\r\n\t\tString seqNum = request.getParameterValues(\"sequenceNumber\")[0];\r\n\t\tString keyframe = request.getParameterValues(\"keyframe\")[0];\r\n\t\tString position = request.getParameterValues(\"position\")[0];\r\n\t\t\t\t\r\n\t\tif (! hasSessionManager) {\r\n\t\t\tsessionManager = getSessionManager();\r\n\t\t\thasSessionManager = true;\r\n\t\t}\r\n\t\t\t\r\n\t\tsessionManager.updateBlock(room, Integer.valueOf(position), blockData, Boolean.parseBoolean(keyframe), Integer.parseInt(seqNum));\r\n*/\r\n\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void processNextMessageToSend(Message message) {\r\n\t\tif (message.getMessageType() == Message.MessageType.BLOCK) {\t\r\n\t\t\tlong start = System.currentTimeMillis();\r\n\t\t\tInteger[] changedBlocks = ((BlockMessage)message).getBlocks();\r\n\t\t\tString blockSize = \"Http[\" + id + \"] Block length [\";\r\n\t\t\tString encodeTime = \"Http[\" + id + \"]Encode times [\";\r\n\t\t\tlong encStart = 0;\r\n\t\t\tlong encEnd = 0;\r\n\t\t\tint totalBytes = 0;\r\n\t\t\tlong totalMillis = 0;\r\n\t\t\tfor (int i = 0; i < changedBlocks.length; i++) {\r\n\t\t\t\tencStart = System.currentTimeMillis();\r\n\t\t\t\tEncodedBlockData block = retriever.getBlockToSend((Integer)changedBlocks[i]);\r\n\t\t\t\ttotalBytes += block.getVideoData().length;\r\n\t\t\t\tblockSize += block.getVideoData().length + \",\";\r\n\t\t\t\tencEnd = System.currentTimeMillis();\r\n\t\t\t\ttotalMillis += (encEnd - encStart);\r\n\t\t\t\tencodeTime += (encEnd - encStart) + \",\";\r\n\t\t\t\tBlockVideoData\tbv = new BlockVideoData(room, block.getPosition(), block.getVideoData(), false /* should remove later */);\t\r\n\t\t\t\tsendBlockData(bv);\r\n\t\t\t}\r\n\t\t\tSystem.out.println(blockSize + \"] total=\" + totalBytes + \" bytes\");\r\n\t\t\tSystem.out.println(encodeTime + \"] total=\" + totalMillis + \" ms\");\r\n\t\t\tfor (int i = 0; i< changedBlocks.length; i++) {\r\n\t\t\t\tretriever.blockSent((Integer)changedBlocks[i]);\r\n\t\t\t}\r\n\t\t\tlong end = System.currentTimeMillis();\r\n\t\t\tSystem.out.println(\"[HTTP \" + id + \"] Sending \" + changedBlocks.length + \" blocks took \" + (end - start) + \" millis\");\r\n\t\t} else if (message.getMessageType() == Message.MessageType.CURSOR) {\r\n\t\t\tCursorMessage msg = (CursorMessage)message;\r\n\t\t\tsendCursor(msg.getMouseLocation(), msg.getRoom());\r\n\t\t}\r\n\t}","id":88571,"modified_method":"private void processNextMessageToSend(Message message) {\r\n\r\n    if (message.getMessageType() == Message.MessageType.BLOCK) {\r\n\r\n      long start = System.currentTimeMillis();\r\n      Integer[] changedBlocks = ((BlockMessage) message).getBlocks();\r\n      String blockSize = \"Http[\" + id + \"] Block length [\";\r\n      String encodeTime = \"Http[\" + id + \"]Encode times [\";\r\n      long encStart = 0;\r\n      long encEnd = 0;\r\n      int totalBytes = 0;\r\n      long totalMillis = 0;\r\n\r\n      ClientHttpRequest chr;\r\n\r\n      try {\r\n\r\n        // Open a connection to the web server and create a request that has\r\n        // the room and event type.\r\n        System.out.println(getTimeStamp() + \" Http[\" + id + \"] Open connection. In sendBlockData\");\r\n        openConnection();\r\n        chr = new ClientHttpRequest(conn);\r\n        chr.setParameter(ROOM, room);\r\n        chr.setParameter(EVENT, CaptureEvents.CAPTURE_UPDATE.getEvent());\r\n\r\n        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // For each changed block, append an uploaded-file entry to the form data.\r\n        // The file name contains the block info.  The file name has this format:\r\n        // \"blockgroup_<seqnum>_<position>\".  The original filename is just set to\r\n        // \"block<i>\".\r\n        //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        for (int i = 0; i < changedBlocks.length; i++) \r\n        { // append each changed-block to the form\r\n\r\n          EncodedBlockData block = retriever.getBlockToSend((Integer) changedBlocks[i]);\r\n          String changed_blocks_upload_filename = \r\n                  BLOCKGROUP + \"_\" + seqNumGenerator.getNext() + \"_\" + block.getPosition();\r\n          \r\n          chr.setParameter(changed_blocks_upload_filename, \"block\"+i, new ByteArrayInputStream(block.getVideoData()));\r\n\r\n        } // append each changed-block to the form\r\n\r\n        // Post the multi-part form to the server\r\n        chr.post();\r\n\r\n        System.out.println(blockSize + \"] total=\" + totalBytes + \" bytes\");\r\n        System.out.println(encodeTime + \"] total=\" + totalMillis + \" ms\");\r\n        for (int i = 0; i < changedBlocks.length; i++) {\r\n          retriever.blockSent((Integer) changedBlocks[i]);\r\n        }\r\n        long end = System.currentTimeMillis();\r\n        System.out.println(\"[HTTP \" + id + \"] Sending \" + changedBlocks.length + \" blocks took \" + (end - start) + \" millis\");\r\n\r\n      } catch (IOException e) {\r\n        e.printStackTrace();\r\n      } catch (ConnectionException e) {\r\n        System.out.println(\"ERROR: Failed to send block data.\");\r\n      }\r\n\r\n      }\r\n      else if (message.getMessageType() == Message.MessageType.CURSOR)\r\n      {\r\n\r\n        CursorMessage msg = (CursorMessage) message;\r\n\r\n        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // If the mouse has changed location from the previous time sent,\r\n        // then send its new location.\r\n        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        if (!msg.getMouseLocation().equals(previousMouseLocation))\r\n        {\r\n           System.out.println(\"SEND MOUSE: old=\" + previousMouseLocation + \" new=\" + msg.getMouseLocation());\r\n           previousMouseLocation = msg.getMouseLocation();\r\n           sendCursor(previousMouseLocation, msg.getRoom());\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendBlockData(BlockVideoData blockData) {\r\n\t\tlong start = System.currentTimeMillis();\r\n\t    ClientHttpRequest chr;\r\n\t\ttry {\r\n\t\t\tSystem.out.println(\"Http[\" + id + \"] Open connection. In sendBlockData\");\r\n\t\t\topenConnection();\r\n\t\t\tchr = new ClientHttpRequest(conn);\r\n\t\t    chr.setParameter(ROOM, blockData.getRoom());\r\n\t\t    chr.setParameter(SEQ_NUM, seqNumGenerator.getNext());\r\n\t\t    chr.setParameter(POSITION, blockData.getPosition());\r\n\t\t    chr.setParameter(KEYFRAME, blockData.isKeyFrame());\r\n\t\t    chr.setParameter(EVENT, CaptureEvents.CAPTURE_UPDATE.getEvent());\r\n\t\t\tByteArrayInputStream block = new ByteArrayInputStream(blockData.getVideoData());\t\t\t\t\r\n\t\t\tchr.setParameter(BLOCKDATA, \"block\", block);\r\n\t\t\tchr.post();\t\t\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (ConnectionException e) {\r\n\t\t\tSystem.out.println(\"ERROR: Failed to send block data.\");\r\n\t\t}\r\n\t\tlong end = System.currentTimeMillis();\r\n\t\tSystem.out.println(\"[HTTP \" + id + \"] Sending \" + blockData.getVideoData().length + \" bytes took \" + (end - start) + \" ms\");\r\n\t}","id":88572,"modified_method":"private void sendBlockData(BlockVideoData blockData) {\r\n\t\tlong start = System.currentTimeMillis();\r\n\t    ClientHttpRequest chr;\r\n\t\ttry {\r\n\t\t\tSystem.out.println(getTimeStamp()+ \" Http[\" + id + \"] Open connection. In sendBlockData\");\r\n\t\t\topenConnection();\r\n\t\t\tchr = new ClientHttpRequest(conn);\r\n\t\t    chr.setParameter(ROOM, blockData.getRoom());\r\n\t\t    chr.setParameter(SEQ_NUM, seqNumGenerator.getNext());\r\n\t\t    chr.setParameter(POSITION, blockData.getPosition());\r\n\t\t    chr.setParameter(KEYFRAME, blockData.isKeyFrame());\r\n\t\t    chr.setParameter(EVENT, CaptureEvents.CAPTURE_UPDATE.getEvent());\r\n\t\t\tByteArrayInputStream block = new ByteArrayInputStream(blockData.getVideoData());\t\t\t\t\r\n\t\t\tchr.setParameter(BLOCKDATA, \"block\", block);\r\n\t\t\tchr.post();\r\n               //         try {\r\n               //         Thread.sleep(1000);\r\n               //         }\r\n               //         catch (InterruptedException e)\r\n               //         { }\r\n\t\t\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (ConnectionException e) {\r\n\t\t\tSystem.out.println(\"ERROR: Failed to send block data.\");\r\n\t\t}\r\n\t\tlong end = System.currentTimeMillis();\r\n\t\tSystem.out.println(getTimeStamp() + \" [HTTP \" + id + \"] Sending \" + blockData.getVideoData().length + \" bytes took \" + (end - start) + \" ms\");\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void stop() throws ConnectionException {\r\n\t\tstopped = true;\r\n\t\tSystem.out.println(NAME + \"Stopping network sender\");\r\n\t\tfor (int i = 0; i < numRunningThreads; i++) {\r\n\t\t\tif (tunneling) {\r\n\t\t\t\thttpSenders[i].disconnect();\r\n\t\t\t} else {\r\n\t\t\t//\tsocketSenders[i].disconnect();\r\n\t\t\t\tif (clearQ) {\r\n\t\t\t\t\tclearQ = false;\r\n\t\t\t\t\tblockDataQ.clear();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tsend(new PoisonMessage());\r\n\t\t\t}\t\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(\"Shutting down executor\");\r\n\t\texecutor.shutdownNow();\r\n\t\tSystem.out.println(\"Shutting down executor [DONE]\");\r\n\t\thttpSenders = null;\r\n\t\tsocketSenders = null;\r\n\t\t\r\n\t}","id":88573,"modified_method":"public void stop() throws ConnectionException {\r\n\t\tstopped = true;\r\n\t\tSystem.out.println(NAME + \"Stopping network sender\");\r\n\r\n      // NEW\r\n      \t\tif (tunneling) {\r\n               \t\tif (httpSenders == null) \r\n                   \t\treturn;\r\n                \tif (httpSenders[0] != null)\r\n\t\t\t\thttpSenders[0].disconnect();\r\n\t\t}\r\n\r\n\t\tif (socketSenders == null)\r\n\t\t\treturn;\r\n\r\n\t\tfor (int i = 0; i < numRunningThreads; i++) {\r\n\t\t   try {\r\n\t\t\tif (tunneling) {\r\n                                if (httpSenders[i] != null)\r\n\t\t\t\t\thttpSenders[i].stopProcessingBlocks();\r\n\t\t\t} else {\r\n\t\t\t\t//socketSenders[i].disconnect();\r\n\t\t\t\tif (clearQ) {\r\n\t\t\t\t\tclearQ = false;\r\n\t\t\t\t\tblockDataQ.clear();\r\n\t\t\t\t}\r\n\t\t\t\tsend(new PoisonMessage());\r\n                                // LRP changed 06-06-2012\r\n\t\t\t\tThread.yield();\r\n                                //Thread.sleep(1000);\r\n\t\t\t\tsocketSenders[i].disconnect();\r\n\t\t\t}\r\n                   } catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t   }\t\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(\"Shutting down executor\");\r\n\t\texecutor.shutdownNow();\r\n\t\tSystem.out.println(\"Shutting down executor [DONE]\");\r\n\t\thttpSenders = null;\r\n\t\tsocketSenders = null;\r\n\t\t\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public boolean connect() {\t\r\n\t\tif (trySocketConnection(host, port)) {\r\n\t\t\tsocketSenders = new NetworkSocketStreamSender[numThreads];\r\n\t\t\tfor (int i = 0; i < numThreads; i++) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcreateSender(i);\r\n\t\t\t\t\tnumRunningThreads++;\r\n\t\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\t\tSystem.out.println(\"Failed to connect using socket.\");\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t} else {\r\n\t\t\tif (httpTunnel) {\r\n\t\t\t\tSystem.out.println(NAME + \"Trying http tunneling\");\r\n\t\t\t\tnumRunningThreads = 0;\r\n\t\t\t\tif (tryHttpTunneling()) {\r\n\t\t\t\t\ttunneling = true;\r\n\t\t\t\t\tSystem.out.println(NAME + \"Will use http tunneling\");\r\n\t\t\t\t\thttpSenders = new NetworkHttpStreamSender[numThreads];\r\n\t\t\t\t\tfor (int i = 0; i < numThreads; i++) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tcreateHttpSender(i);\r\n\t\t\t\t\t\t\tnumRunningThreads++;\r\n\t\t\t\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\t\t\t\tSystem.out.println(\"Failed to connect using http.\");\r\n\t\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\r\n\t\tif (numRunningThreads != numThreads) {\r\n\t\t\ttry {\r\n\t\t\t\tstop();\r\n\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\tSystem.out.println(\"Failed to stop deskshare applet.\");\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t} \r\n\t\t\r\n\t\treturn true;\r\n\t}","id":88574,"modified_method":"public boolean connect() {\r\n\r\n      //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n      // If the requested server port is nonzero, then try to connect to the\r\n      // requested port.  Otherwise, tunnel the connection to the web server.\r\n      //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\t\tif ((port != 0) && trySocketConnection(host, port)) {\r\n\t\t\tsocketSenders = new NetworkSocketStreamSender[numThreads];\r\n\t\t\tfor (int i = 0; i < numThreads; i++) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcreateSender(i);\r\n\t\t\t\t\tnumRunningThreads++;\r\n\t\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\t\tSystem.out.println(\"Failed to connect using socket.\");\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t} else {\r\n\t\t\tif (httpTunnel) {\r\n\t\t\t\tSystem.out.println(NAME + \"Trying http tunneling\");\r\n\t\t\t\tnumRunningThreads = 0;\r\n\t\t\t\tif (tryHttpTunneling()) {\r\n\t\t\t\t\ttunneling = true;\r\n\t\t\t\t\tSystem.out.println(NAME + \"Will use http tunneling\");\r\n\t\t\t\t\thttpSenders = new NetworkHttpStreamSender[numThreads];\r\n\t\t\t\t\tfor (int i = 0; i < numThreads; i++) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tcreateHttpSender(i);\r\n\t\t\t\t\t\t\tnumRunningThreads++;\r\n\t\t\t\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\t\t\t\tSystem.out.println(\"Failed to connect using http.\");\r\n\t\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\r\n\t\tif (numRunningThreads != numThreads) {\r\n\t\t\ttry {\r\n\t\t\t\tstop();\r\n\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\tSystem.out.println(\"Failed to stop deskshare applet.\");\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t} \r\n\t\t\r\n\t\treturn true;\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void start() {\r\n\t\tSystem.out.println(NAME + \"Starting network sender.\");\t\t\r\n\t\tif (tunneling) {\r\n\t\t\tfor (int i = 0; i < numRunningThreads; i++) {\r\n\t\t\t\thttpSenders[i].sendStartStreamMessage();\r\n\t\t\t\texecutor.execute(httpSenders[i]);\r\n\t\t\t}\r\n\t\t} else {\t\t\t\r\n\t\t\tfor (int i = 0; i < numRunningThreads; i++) {\t\t\t\t\t\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsocketSenders[i].sendStartStreamMessage();\r\n\t\t\t\t\texecutor.execute(socketSenders[i]);\r\n\t\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstopped = false;\r\n\t}","id":88575,"modified_method":"public void start() {\r\n\t\tSystem.out.println(NAME + \"Starting network sender.\");\t\t\r\n\t\tif (tunneling) {\r\n\r\n         // NEW\r\n         httpSenders[0].sendStartStreamMessage();\r\n\r\n\t\t\tfor (int i = 0; i < numRunningThreads; i++) {\r\n\t\t\t\texecutor.execute(httpSenders[i]);\r\n\t\t\t}\r\n\t\t} else {\t\t\t\r\n\t\t\tfor (int i = 0; i < numRunningThreads; i++) {\t\t\t\t\t\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsocketSenders[i].sendStartStreamMessage();\r\n\t\t\t\t\texecutor.execute(socketSenders[i]);\r\n\t\t\t\t} catch (ConnectionException e) {\r\n\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstopped = false;\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void send(Message message) {\r\n\t\tblockDataQ.offer(message);\r\n\t}","id":88576,"modified_method":"public void send(Message message) {\r\n             boolean added = blockDataQ.offer(message);\r\n             System.out.println(\"Offered to queue: res=\"+added+\" size=\"+blockDataQ.size()+\" remaining_capacity=\"+blockDataQ.remainingCapacity());\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public NetworkStreamSender(BlockManager blockManager, String host, int port,\r\n\t\t\tString room, Dimension screenDim, Dimension blockDim, boolean httpTunnel) {\r\n\t\tthis.blockManager = blockManager;\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\r\n\t\tthis.room = room;\r\n\t\tthis.screenDim = screenDim;\r\n\t\tthis.blockDim = blockDim;\r\n\t\tthis.httpTunnel = httpTunnel;\r\n\t\t\r\n\t\tnumThreads = Runtime.getRuntime().availableProcessors() * 3;\r\n\t\tSystem.out.println(NAME + \"Starting up \" + numThreads + \" sender threads.\");\r\n\t\texecutor = Executors.newFixedThreadPool(numThreads);\r\n\t}","id":88577,"modified_method":"public NetworkStreamSender(BlockManager blockManager, String host, int port,\r\n\t\t\tString room, Dimension screenDim, Dimension blockDim, boolean httpTunnel) {\r\n\t\tthis.blockManager = blockManager;\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\r\n\t\tthis.room = room;\r\n\t\tthis.screenDim = screenDim;\r\n\t\tthis.blockDim = blockDim;\r\n\t\tthis.httpTunnel = httpTunnel;\r\n\t\t\r\n\t\t//numThreads = Runtime.getRuntime().availableProcessors() * 3;\r\n\r\n      //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n      // Use one thread per row of tiles\r\n      //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n      numThreads = screenDim.getHeight() / blockDim.getHeight();\r\n      \r\n\t\tSystem.out.println(NAME + \"Starting up \" + numThreads + \" sender threads.\");\r\n\t\texecutor = Executors.newFixedThreadPool(numThreads);\r\n\t}","commit_id":"2f13cbb86b7d9ec8f4807bad7c44222134288ac4","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n  public void disconnect() {\n    myMainDebugger.disconnect();\n    for (ProcessDebugger d : myOtherDebuggers) {\n      d.disconnect();\n    }\n    myDebugProcessAcceptor.disconnect();\n  }","id":88578,"modified_method":"@Override\n  public void disconnect() {\n    myMainDebugger.disconnect();\n    for (ProcessDebugger d : myOtherDebuggers) {\n      d.disconnect();\n    }\n    if (myDebugProcessAcceptor != null) {\n      myDebugProcessAcceptor.disconnect();\n    }\n  }","commit_id":"315b9ca7697d881fe80cf10edfe38a2ec4bd8843","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"GitRepositoryUpdater(GitRepository repository) {\n    VirtualFile gitDir = repository.getGitDir();\n    myWatchRequest = LocalFileSystem.getInstance().addRootToWatch(gitDir.getPath(), true);\n\n    myRepositoryFiles = GitRepositoryFiles.getInstance(gitDir);\n    visitGitDirVfs(gitDir);\n    myHeadsDir = VcsUtil.getVirtualFile(myRepositoryFiles.getRefsHeadsPath());\n    myRemotesDir = VcsUtil.getVirtualFile(myRepositoryFiles.getRefsRemotesPath());\n\n    myUpdateQueue = new QueueProcessor<GitRepository.TrackedTopic>(new Updater(repository), repository.getProject().getDisposed());\n    myMessageBusConnection = repository.getProject().getMessageBus().connect();\n    myMessageBusConnection.subscribe(VirtualFileManager.VFS_CHANGES, this);\n  }","id":88579,"modified_method":"GitRepositoryUpdater(GitRepository repository) {\n    VirtualFile gitDir = repository.getGitDir();\n    myWatchRequest = LocalFileSystem.getInstance().addRootToWatch(gitDir.getPath(), true);\n\n    myRepositoryFiles = GitRepositoryFiles.getInstance(gitDir);\n    visitGitDirVfs(gitDir);\n    myHeadsDir = VcsUtil.getVirtualFile(myRepositoryFiles.getRefsHeadsPath());\n    myRemotesDir = VcsUtil.getVirtualFile(myRepositoryFiles.getRefsRemotesPath());\n\n    Project project = repository.getProject();\n    myUpdateQueue = new QueueProcessor<GitRepository.TrackedTopic>(new Updater(repository), project.getDisposed());\n    if (!project.isDisposed()) {\n      myMessageBusConnection = project.getMessageBus().connect();\n      myMessageBusConnection.subscribe(VirtualFileManager.VFS_CHANGES, this);\n    }\n    else {\n      myMessageBusConnection = null;\n    }\n  }","commit_id":"734007eccfba2fa56d9421a41807f7d2b41350e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void dispose() {\n    if (myWatchRequest != null) {\n      LocalFileSystem.getInstance().removeWatchedRoot(myWatchRequest);\n    }\n    myMessageBusConnection.disconnect();\n  }","id":88580,"modified_method":"@Override\n  public void dispose() {\n    if (myWatchRequest != null) {\n      LocalFileSystem.getInstance().removeWatchedRoot(myWatchRequest);\n    }\n    if (myMessageBusConnection != null) {\n      myMessageBusConnection.disconnect();\n    }\n  }","commit_id":"734007eccfba2fa56d9421a41807f7d2b41350e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Ends the registration of this protocol provider with the service.\n     */\n    public void unregister()\n    {\n        aimConnection.disconnect(true);\n    }","id":88581,"modified_method":"/**\n     * Ends the registration of this protocol provider with the service.\n     */\n    public void unregister()\n    {\n        if(aimConnection != null)\n            aimConnection.disconnect(true);\n    }","commit_id":"a27fa2069ca903b1a75199fd8d4631e10e270fc4","url":"https://github.com/jitsi/jitsi"},{"original_method":"public InvalidManagedModelElementTypeException(ModelType<?> type, String propertyName, InvalidManagedModelElementTypeException cause) {\n        super(String.format(\"Invalid managed model type %s: managed type of property '%s' is invalid\", type, propertyName), cause);\n    }","id":88582,"modified_method":"public InvalidManagedModelElementTypeException(ModelType<?> type, String message, InvalidManagedModelElementTypeException cause) {\n        super(getMessage(type, message), cause);\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public InvalidManagedModelElementTypeException(ModelType<?> type, String message) {\n        super(\"Invalid managed model type \" + type + \": \" + message);\n    }","id":88583,"modified_method":"public InvalidManagedModelElementTypeException(ModelType<?> type, String message) {\n        super(getMessage(type, message));\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public T createInstance() {\n        Class<T> concreteType = type.getConcreteClass();\n        Object instance = Proxy.newProxyInstance(concreteType.getClassLoader(), new Class<?>[]{concreteType, ManagedInstance.class}, new ManagedModelElementInvocationHandler());\n        @SuppressWarnings(\"unchecked\") T typedInstance = (T) instance;\n        return typedInstance;\n    }","id":88584,"modified_method":"public T createInstance() {\n        Class<T> concreteType = schema.getType().getConcreteClass();\n        if (concreteType.equals(ManagedSet.class)) {\n            return Cast.uncheckedCast(createManagedSetInstance(schema.getTypeParameterSchemas().get(0)));\n        } else {\n            return Cast.uncheckedCast(Proxy.newProxyInstance(concreteType.getClassLoader(), new Class<?>[]{concreteType, ManagedInstance.class}, new ManagedModelElementInvocationHandler()));\n        }\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"private <U> void setInstanceProperty(ModelType<U> propertyType, String propertyName, Object value) {\n            ModelPropertyInstance<U> modelPropertyInstance = get(propertyType, propertyName);\n            if (modelPropertyInstance.getMeta().isManaged() && !ManagedInstance.class.isInstance(value)) {\n                throw new IllegalArgumentException(String.format(\"Only managed model instances can be set as property '%s' of class '%s'\", propertyName, type));\n            }\n            modelPropertyInstance.set(Cast.cast(propertyType.getConcreteClass(), value));\n        }","id":88585,"modified_method":"private <U> void setInstanceProperty(ModelType<U> propertyType, String propertyName, Object value) {\n            ModelPropertyInstance<U> modelPropertyInstance = get(propertyType, propertyName);\n            if (modelPropertyInstance.getMeta().isManaged() && !ManagedInstance.class.isInstance(value)) {\n                throw new IllegalArgumentException(String.format(\"Only managed model instances can be set as property '%s' of class '%s'\", propertyName, schema.getType()));\n            }\n            modelPropertyInstance.set(Cast.cast(propertyType.getConcreteClass(), value));\n        }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelType<T> getType() {\n        return type;\n    }","id":88586,"modified_method":"public ModelType<T> getType() {\n        return schema.getType();\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public ManagedModelElement(ModelSchema<T> schema) {\n        this.type = schema.getType();\n        ImmutableSortedMap.Builder<String, ModelPropertyInstance<?>> builder = ImmutableSortedMap.naturalOrder();\n        for (ModelProperty<?> property : schema.getProperties().values()) {\n            builder.put(property.getName(), ModelPropertyInstance.of(property));\n        }\n        this.properties = builder.build();\n    }","id":88587,"modified_method":"public ManagedModelElement(ModelSchema<T> schema) {\n        this.schema = schema;\n        ImmutableSortedMap.Builder<String, ModelPropertyInstance<?>> builder = ImmutableSortedMap.naturalOrder();\n        for (ModelProperty<?> property : schema.getProperties().values()) {\n            builder.put(property.getName(), ModelPropertyInstance.of(property));\n        }\n        this.properties = builder.build();\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public <U> ModelPropertyInstance<U> get(ModelType<U> propertyType, String propertyName) {\n        ModelPropertyInstance<?> modelPropertyInstance = properties.get(propertyName);\n        ModelType<?> modelPropertyType = modelPropertyInstance.getMeta().getType();\n        if (!modelPropertyType.equals(propertyType)) {\n            throw new UnexpectedModelPropertyTypeException(propertyName, type, propertyType, modelPropertyType);\n        }\n        @SuppressWarnings(\"unchecked\") ModelPropertyInstance<U> cast = (ModelPropertyInstance<U>) modelPropertyInstance;\n        return cast;\n    }","id":88588,"modified_method":"public <U> ModelPropertyInstance<U> get(ModelType<U> propertyType, String propertyName) {\n        ModelPropertyInstance<?> modelPropertyInstance = properties.get(propertyName);\n        ModelType<?> modelPropertyType = modelPropertyInstance.getMeta().getType();\n        if (!modelPropertyType.equals(propertyType)) {\n            throw new UnexpectedModelPropertyTypeException(propertyName, schema.getType(), propertyType, modelPropertyType);\n        }\n        return Cast.uncheckedCast(modelPropertyInstance);\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelSchema(ModelType<T> type, Iterable<ModelProperty<?>> properties) {\n        this.type = type;\n\n        ImmutableSortedMap.Builder<String, ModelProperty<?>> builder = ImmutableSortedMap.naturalOrder();\n        for (ModelProperty<?> property : properties) {\n            builder.put(property.getName(), property);\n        }\n        this.properties = builder.build();\n    }","id":88589,"modified_method":"public ModelSchema(ModelType<T> type, Iterable<ModelProperty<?>> properties) {\n        this(type, properties, Collections.<ModelSchema<?>>emptyList());\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> ModelSchema<T> extractSchema(ModelType<T> type, ModelSchemaCache cache) {\n        ModelSchema<T> cached = cache.get(type);\n        if (cached != null) {\n            return cached;\n        }\n\n        validateType(type);\n\n        List<Method> methodList = Arrays.asList(type.getRawClass().getDeclaredMethods());\n        if (methodList.isEmpty()) {\n            return new ModelSchema<T>(type, Collections.<ModelProperty<?>>emptyList());\n        }\n\n        List<ModelProperty<?>> properties = Lists.newLinkedList();\n\n        Map<String, Method> methods = Maps.newHashMap();\n        for (Method method : methodList) {\n            String name = method.getName();\n            if (methods.containsKey(name)) {\n                throw invalidMethod(type, name, \"overloaded methods are not supported\");\n            }\n            methods.put(name, method);\n        }\n\n        List<String> methodNames = Lists.newLinkedList(methods.keySet());\n        List<String> handled = Lists.newArrayList();\n\n        for (String methodName : methodNames) {\n            Method method = methods.get(methodName);\n            if (methodName.startsWith(\"get\") && !methodName.equals(\"get\")) {\n                if (method.getParameterTypes().length != 0) {\n                    throw invalidMethod(type, methodName, \"getter methods cannot take parameters\");\n                }\n\n                Character getterPropertyNameFirstChar = methodName.charAt(3);\n                if (!Character.isUpperCase(getterPropertyNameFirstChar)) {\n                    throw invalidMethod(type, methodName, \"the 4th character of the getter method name must be an uppercase character\");\n                }\n\n                ModelType<?> returnType = ModelType.of(method.getGenericReturnType());\n                if (isManaged(returnType.getRawClass())) {\n                    properties.add(extractPropertyOfManagedType(cache, type, methods, methodName, returnType, handled));\n                } else {\n                    properties.add(extractPropertyOfUnmanagedType(type, methods, methodName, returnType, handled));\n                }\n                handled.add(methodName);\n            }\n        }\n\n        methodNames.removeAll(handled);\n\n        // TODO - should call out valid getters without setters\n        if (!methodNames.isEmpty()) {\n            throw invalid(type, \"only paired getter/setter methods are supported (invalid methods: [\" + Joiner.on(\", \").join(methodNames) + \"])\");\n        }\n\n        ModelSchema<T> schema = new ModelSchema<T>(type, properties);\n        cache.set(type, schema);\n        return schema;\n    }","id":88590,"modified_method":"private <T> ModelSchema<T> extractSchema(ModelType<T> type, ModelSchemaCache cache) {\n        ModelSchema<T> cached = cache.get(type);\n        if (cached != null) {\n            return cached;\n        }\n\n        if (type.getRawClass().equals(ManagedSet.class)) {\n            return extractManagedSetSchema(type, cache);\n        }\n\n        validateType(type);\n\n        List<Method> methodList = Arrays.asList(type.getRawClass().getDeclaredMethods());\n        if (methodList.isEmpty()) {\n            return new ModelSchema<T>(type, Collections.<ModelProperty<?>>emptyList());\n        }\n\n        List<ModelProperty<?>> properties = Lists.newLinkedList();\n\n        Map<String, Method> methods = Maps.newHashMap();\n        for (Method method : methodList) {\n            String name = method.getName();\n            if (methods.containsKey(name)) {\n                throw invalidMethod(type, name, \"overloaded methods are not supported\");\n            }\n            methods.put(name, method);\n        }\n\n        List<String> methodNames = Lists.newLinkedList(methods.keySet());\n        List<String> handled = Lists.newArrayList();\n\n        for (String methodName : methodNames) {\n            Method method = methods.get(methodName);\n            if (methodName.startsWith(\"get\") && !methodName.equals(\"get\")) {\n                if (method.getParameterTypes().length != 0) {\n                    throw invalidMethod(type, methodName, \"getter methods cannot take parameters\");\n                }\n\n                Character getterPropertyNameFirstChar = methodName.charAt(3);\n                if (!Character.isUpperCase(getterPropertyNameFirstChar)) {\n                    throw invalidMethod(type, methodName, \"the 4th character of the getter method name must be an uppercase character\");\n                }\n\n                ModelType<?> returnType = ModelType.of(method.getGenericReturnType());\n                if (isManaged(returnType.getRawClass())) {\n                    properties.add(extractPropertyOfManagedType(cache, type, methods, methodName, returnType, handled));\n                } else {\n                    properties.add(extractPropertyOfUnmanagedType(type, methods, methodName, returnType, handled));\n                }\n                handled.add(methodName);\n            }\n        }\n\n        methodNames.removeAll(handled);\n\n        // TODO - should call out valid getters without setters\n        if (!methodNames.isEmpty()) {\n            throw invalid(type, \"only paired getter/setter methods are supported (invalid methods: [\" + Joiner.on(\", \").join(methodNames) + \"])\");\n        }\n\n        ModelSchema<T> schema = new ModelSchema<T>(type, properties);\n        cache.set(type, schema);\n        return schema;\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchema<T> extract(ModelType<T> type, ModelSchemaCache cache) {\n        ModelSchema<T> schema = extractSchema(type, cache);\n\n        Extraction extraction = new Extraction(type);\n        pushDependencies(schema, extraction, cache);\n        ModelProperty<?> next = extraction.next();\n\n        while (next != null) {\n            ModelSchema<?> nextSchema;\n            try {\n                nextSchema = extractSchema(next.getType(), cache);\n            } catch (InvalidManagedModelElementTypeException e) {\n                InvalidManagedModelElementTypeException cause = e;\n                List<ModelProperty<?>> currentStack = extraction.getCurrentStack();\n                while (!currentStack.isEmpty()) {\n                    ModelProperty<?> previous = currentStack.remove(0);\n                    ModelType<?> owner = currentStack.isEmpty() ? type : currentStack.get(0).getType();\n                    cause = new InvalidManagedModelElementTypeException(owner, previous.getName(), cause);\n                }\n\n                throw cause;\n            }\n\n            pushDependencies(nextSchema, extraction, cache);\n            next = extraction.next();\n        }\n\n        return schema;\n    }","id":88591,"modified_method":"public <T> ModelSchema<T> extract(ModelType<T> type, ModelSchemaCache cache) {\n        ModelSchema<T> schema = extractSchema(type, cache);\n\n        Extraction extraction = new Extraction(type);\n        pushDependencies(schema, extraction, cache);\n        ModelProperty<?> next = extraction.next();\n\n        while (next != null) {\n            ModelSchema<?> nextSchema;\n            try {\n                nextSchema = extractSchema(next.getType(), cache);\n            } catch (InvalidManagedModelElementTypeException e) {\n                InvalidManagedModelElementTypeException cause = e;\n                List<ModelProperty<?>> currentStack = extraction.getCurrentStack();\n                while (!currentStack.isEmpty()) {\n                    ModelProperty<?> previous = currentStack.remove(0);\n                    ModelType<?> owner = currentStack.isEmpty() ? type : currentStack.get(0).getType();\n                    cause = invalid(owner, String.format(\"managed type of property '%s' is invalid\", previous.getName()), cause);\n                }\n\n                throw cause;\n            }\n\n            pushDependencies(nextSchema, extraction, cache);\n            next = extraction.next();\n        }\n\n        return schema;\n    }","commit_id":"6fe643f4c66b370dd4571eecef8038957ec00347","url":"https://github.com/gradle/gradle"},{"original_method":"public static <T> T castToLocal(final Object remote, final Class<T> clazz) {\n    final ClassLoader loader = clazz.getClassLoader();\n    Object proxy = Proxy.newProxyInstance(loader, new Class[]{clazz}, new InvocationHandler() {\n      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getDeclaringClass() == Object.class) {\n          return method.invoke(remote, args);\n        }\n        else {\n          Method m = ourRemoteToLocalMap.get(Pair.<Class<?>, Class<?>>create(remote.getClass(), clazz)).get(method);\n          if (m == null) throw new NoSuchMethodError(method.getName() + \" in \" + remote.getClass());\n          try {\n            Object result = m.invoke(remote, args);\n            if (result instanceof Remote) {\n              return castToLocal(result, tryFixReturnType(result, method.getReturnType(), loader));\n            }\n            return result;\n          }\n          catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException) throw cause;\n            if (cause instanceof Error) throw cause;\n            if (canThrow(cause, method)) throw cause;\n            throw new RuntimeException(cause);\n          }\n        }\n      }\n    });\n    return (T)proxy;\n  }","id":88592,"modified_method":"public static <T> T castToLocal(final Object remote, final Class<T> clazz) {\n    final ClassLoader loader = clazz.getClassLoader();\n    //noinspection unchecked\n    return (T)Proxy.newProxyInstance(loader, new Class[]{clazz}, new RemoteInvocationHandler(remote, clazz, loader));\n  }","commit_id":"499c1542835401f1631219a80d6b0387872ad59a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T extends XmlAnnotatedElement> T getXmlAnnotatedElement(final Class<T> aClass, final XmlFile file) {\n    return getXmlAnnotatedElement(aClass, file.getDocument().getRootTag());\n  }","id":88593,"modified_method":"public static <T extends XmlAnnotatedElement> XmlFileAnnotatedElement<T> getFileElement(final XmlFile file, final Class<T> aClass) {\n    return new XmlFileAnnotatedElement<T>(file, aClass);\n  }","commit_id":"a2499a1421f77dfa4e4ffc26b56b3f69b84a9420","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T extends XmlAnnotatedElement> T getXmlAnnotatedElement(final Class<T> aClass, final XmlTag tag) {\n    final Object o = Proxy.newProxyInstance(null, new Class[]{aClass}, new InvocationHandler() {\n      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        final AttributeValue attributeValue = method.getAnnotation(AttributeValue.class);\n        if (attributeValue != null) {\n          return tag.getAttributeValue(attributeValue.value());\n        }\n        final TagValue tagValue = method.getAnnotation(TagValue.class);\n        if (tagValue != null) {\n          return tag.getValue().getText();\n        }\n        final SubTagValue subTagValue = method.getAnnotation(SubTagValue.class);\n        if (subTagValue != null) {\n          final XmlTag subTag = tag.findFirstSubTag(subTagValue.value());\n          return subTag == null ? null : subTag.getValue().getText();\n        }\n\n        final Class<?> returnType = method.getReturnType();\n        final SubTag subTagAnnotation = method.getAnnotation(SubTag.class);\n        if (subTagAnnotation != null && XmlAnnotatedElement.class.isAssignableFrom(returnType)) {\n          final XmlTag subTag = tag.findFirstSubTag(subTagAnnotation.value());\n          return subTag == null ? null : getXmlAnnotatedElement((Class<XmlAnnotatedElement>)returnType, subTag);\n        }\n\n        final SubTagList subTagList = method.getAnnotation(SubTagList.class);\n        if (subTagList != null) {\n          final Class<? extends XmlAnnotatedElement> aClass = extractElementType(method.getGenericReturnType());\n          if (aClass != null) {\n            final XmlTag[] subTags = tag.findSubTags(subTagList.value());\n            final ArrayList<XmlAnnotatedElement> list = new ArrayList<XmlAnnotatedElement>(subTags.length);\n            for (XmlTag xmlTag : subTags) {\n              list.add(getXmlAnnotatedElement(aClass, xmlTag));\n            }\n            return Collections.unmodifiableList(list);\n          }\n        }\n\n\n\n        throw new UnsupportedOperationException();\n      }\n\n      @Nullable\n      private Class<? extends XmlAnnotatedElement> extractElementType(Type returnType) {\n        if (returnType instanceof ParameterizedType) {\n          ParameterizedType parameterizedType = (ParameterizedType)returnType;\n          if (List.class.equals(parameterizedType.getRawType())) {\n            final Type[] arguments = parameterizedType.getActualTypeArguments();\n            if (arguments.length == 1) {\n              final Type argument = arguments[0];\n              if (argument instanceof WildcardType) {\n                WildcardType wildcardType = (WildcardType)argument;\n                final Type[] upperBounds = wildcardType.getUpperBounds();\n                if (upperBounds.length == 1) {\n                  final Type upperBound = upperBounds[0];\n                  if (upperBound instanceof Class) {\n                    Class aClass1 = (Class)upperBound;\n                    if (XmlAnnotatedElement.class.isAssignableFrom(aClass1)) {\n                      return (Class<? extends XmlAnnotatedElement>)aClass1;\n                    }\n                  }\n                }\n              } else if (argument instanceof Class) {\n                Class aClass1 = (Class)argument;\n                if (XmlAnnotatedElement.class.isAssignableFrom(aClass1)) {\n                  return (Class<? extends XmlAnnotatedElement>)aClass1;\n                }\n              }\n            }\n          }\n        }\n        return null;\n      }\n    });\n    return (T)o;\n  }","id":88594,"modified_method":"public static <T extends XmlAnnotatedElement> T getXmlAnnotatedElement(final Class<T> aClass, final XmlTag tag) {\n    return (T)Proxy.newProxyInstance(null, new Class[]{aClass}, new MyInvocationHandler(tag));\n  }","commit_id":"a2499a1421f77dfa4e4ffc26b56b3f69b84a9420","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String _parseSassFile(\n\t\t\tString docrootDirName, String portalCommonDirName, String fileName)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(fileName);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"commonSassPath\", portalCommonDirName);\n\t\tinputObjects.put(\"content\", getContent(docrootDirName, fileName));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\t_rubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\treturn unsyncByteArrayOutputStream.toString();\n\t}","id":88595,"modified_method":"private String _parseSassFile(\n\t\t\tRubyExecutor rubyExecutor, String docrootDirName,\n\t\t\tString portalCommonDirName, String fileName)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(fileName);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"commonSassPath\", portalCommonDirName);\n\t\tinputObjects.put(\"content\", getContent(docrootDirName, fileName));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\trubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\treturn unsyncByteArrayOutputStream.toString();\n\t}","commit_id":"92c6603c82a71ba9693db6be0e008b5777452a88","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SassToCssBuilder(\n\t\t\tList<String> dirNames, String docrootDirName,\n\t\t\tString portalCommonDirName)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss\" +\n\t\t\t\t\"/dependencies/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tfor (String dirName : dirNames) {\n\n\t\t\t// Create a new Ruby executor as a workaround for a bug with Ruby\n\t\t\t// that breaks \"ant build-css\" when it parses too many CSS files\n\n\t\t\t_rubyExecutor = new RubyExecutor();\n\n\t\t\t_rubyExecutor.setExecuteInSeparateThread(false);\n\n\t\t\t_parseSassDirectory(dirName, docrootDirName, portalCommonDirName);\n\t\t}\n\t}","id":88596,"modified_method":"public SassToCssBuilder(\n\t\t\tList<String> dirNames, String docrootDirName,\n\t\t\tString portalCommonDirName)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss\" +\n\t\t\t\t\"/dependencies/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tRubyExecutor rubyExecutor = new RubyExecutor();\n\n\t\trubyExecutor.setExecuteInSeparateThread(false);\n\n\t\tList<String> fileNameList = new ArrayList<String>();\n\n\t\tfor (String dirName : dirNames) {\n\t\t\t_collectSassFiles(fileNameList, dirName, docrootDirName);\n\t\t}\n\n\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\tExecutorService executorService = Executors.newFixedThreadPool(\n\t\t\truntime.availableProcessors());\n\n\t\tList<Future<String>> futureList = new ArrayList<Future<String>>(\n\t\t\tfileNameList.size());\n\n\t\tfor (String fileName : fileNameList) {\n\t\t\tCallable<String> callable = new CacheSassCallable(\n\t\t\t\trubyExecutor, docrootDirName, portalCommonDirName, fileName);\n\n\t\t\tfutureList.add(executorService.submit(callable));\n\t\t}\n\n\t\tfor (Future<String> future : futureList) {\n\t\t\tSystem.out.println(future.get());\n\t\t}\n\n\t\texecutorService.shutdownNow();\n\t}","commit_id":"92c6603c82a71ba9693db6be0e008b5777452a88","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SassToCssBuilder(\n\t\t\tList<String> dirNames, String docrootDirName,\n\t\t\tString portalCommonDirName)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss\" +\n\t\t\t\t\"/dependencies/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tfor (String dirName : dirNames) {\n\n\t\t\t// Create a new Ruby executor as a workaround for a bug with Ruby\n\t\t\t// that breaks \"ant build-css\" when it parses too many CSS files\n\n\t\t\t_rubyExecutor = new RubyExecutor();\n\n\t\t\t_rubyExecutor.setExecuteInSeparateThread(false);\n\n\t\t\t_parseSassDirectory(dirName, docrootDirName, portalCommonDirName);\n\t\t}\n\t}","id":88597,"modified_method":"public SassToCssBuilder(\n\t\t\tList<String> dirNames, String docrootDirName,\n\t\t\tString portalCommonDirName)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss\" +\n\t\t\t\t\"/dependencies/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tRubyExecutor rubyExecutor = new RubyExecutor();\n\n\t\trubyExecutor.setExecuteInSeparateThread(false);\n\n\t\tList<String> fileNameList = new ArrayList<String>();\n\n\t\tfor (String dirName : dirNames) {\n\t\t\t_collectSassFiles(fileNameList, dirName, docrootDirName);\n\t\t}\n\n\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\tExecutorService executorService = Executors.newFixedThreadPool(\n\t\t\truntime.availableProcessors());\n\n\t\tList<Future<String>> futureList = new ArrayList<Future<String>>(\n\t\t\tfileNameList.size());\n\n\t\tfor (String fileName : fileNameList) {\n\t\t\tCallable<String> callable = new CacheSassCallable(\n\t\t\t\trubyExecutor, docrootDirName, portalCommonDirName, fileName);\n\n\t\t\tfutureList.add(executorService.submit(callable));\n\t\t}\n\n\t\tfor (Future<String> future : futureList) {\n\t\t\tSystem.out.println(future.get());\n\t\t}\n\n\t\texecutorService.shutdownNow();\n\t}","commit_id":"b0d87682d39d6f2465163bcad380cfa8d2b19cb0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _parseSassFile(\n\t\t\tString docrootDirName, String portalCommonDirName, String fileName)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(fileName);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"commonSassPath\", portalCommonDirName);\n\t\tinputObjects.put(\"content\", getContent(docrootDirName, fileName));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\t_rubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\treturn unsyncByteArrayOutputStream.toString();\n\t}","id":88598,"modified_method":"private String _parseSassFile(\n\t\t\tRubyExecutor rubyExecutor, String docrootDirName,\n\t\t\tString portalCommonDirName, String fileName)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(fileName);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"commonSassPath\", portalCommonDirName);\n\t\tinputObjects.put(\"content\", getContent(docrootDirName, fileName));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\trubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\treturn unsyncByteArrayOutputStream.toString();\n\t}","commit_id":"b0d87682d39d6f2465163bcad380cfa8d2b19cb0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SassToCssBuilder(\n\t\t\tList<String> dirNames, String docrootDirName,\n\t\t\tString portalCommonDirName)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss\" +\n\t\t\t\t\"/dependencies/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tRubyExecutor rubyExecutor = new RubyExecutor();\n\n\t\trubyExecutor.setExecuteInSeparateThread(false);\n\n\t\tList<String> fileNameList = new ArrayList<String>();\n\n\t\tfor (String dirName : dirNames) {\n\t\t\t_collectSassFiles(fileNameList, dirName, docrootDirName);\n\t\t}\n\n\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\tExecutorService executorService = Executors.newFixedThreadPool(\n\t\t\truntime.availableProcessors());\n\n\t\tList<Future<String>> futureList = new ArrayList<Future<String>>(\n\t\t\tfileNameList.size());\n\n\t\tfor (String fileName : fileNameList) {\n\t\t\tCallable<String> callable = new CacheSassCallable(\n\t\t\t\trubyExecutor, docrootDirName, portalCommonDirName, fileName);\n\n\t\t\tfutureList.add(executorService.submit(callable));\n\t\t}\n\n\t\tfor (Future<String> future : futureList) {\n\t\t\tSystem.out.println(future.get());\n\t\t}\n\n\t\texecutorService.shutdownNow();\n\t}","id":88599,"modified_method":"public SassToCssBuilder(\n\t\t\tList<String> dirNames, String docrootDirName,\n\t\t\tString portalCommonDirName)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\t_initUtil(classLoader);\n\n\t\t_rubyScript = StringUtil.read(\n\t\t\tclassLoader,\n\t\t\t\"com/liferay/portal/servlet/filters/dynamiccss\" +\n\t\t\t\t\"/dependencies/main.rb\");\n\n\t\t_tempDir = SystemProperties.get(SystemProperties.TMP_DIR);\n\n\t\tfor (String dirName : dirNames) {\n\n\t\t\t// Create a new Ruby executor as a workaround for a bug with Ruby\n\t\t\t// that breaks \"ant build-css\" when it parses too many CSS files\n\n\t\t\t_rubyExecutor = new RubyExecutor();\n\n\t\t\t_rubyExecutor.setExecuteInSeparateThread(false);\n\n\t\t\t_parseSassDirectory(dirName, docrootDirName, portalCommonDirName);\n\t\t}\n\t}","commit_id":"493ec808fb46ca4decb9bdc3592f1b01e4f3170e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _parseSassFile(\n\t\t\tRubyExecutor rubyExecutor, String docrootDirName,\n\t\t\tString portalCommonDirName, String fileName)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(fileName);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"commonSassPath\", portalCommonDirName);\n\t\tinputObjects.put(\"content\", getContent(docrootDirName, fileName));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\trubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\treturn unsyncByteArrayOutputStream.toString();\n\t}","id":88600,"modified_method":"private String _parseSassFile(\n\t\t\tString docrootDirName, String portalCommonDirName, String fileName)\n\t\tthrows Exception {\n\n\t\tString filePath = docrootDirName.concat(fileName);\n\n\t\tMap<String, Object> inputObjects = new HashMap<String, Object>();\n\n\t\tinputObjects.put(\"commonSassPath\", portalCommonDirName);\n\t\tinputObjects.put(\"content\", getContent(docrootDirName, fileName));\n\t\tinputObjects.put(\"cssRealPath\", filePath);\n\t\tinputObjects.put(\"cssThemePath\", _getCssThemePath(filePath));\n\t\tinputObjects.put(\"sassCachePath\", _tempDir);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tUnsyncPrintWriter unsyncPrintWriter = UnsyncPrintWriterPool.borrow(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tinputObjects.put(\"out\", unsyncPrintWriter);\n\n\t\t_rubyExecutor.eval(null, inputObjects, null, _rubyScript);\n\n\t\tunsyncPrintWriter.flush();\n\n\t\treturn unsyncByteArrayOutputStream.toString();\n\t}","commit_id":"493ec808fb46ca4decb9bdc3592f1b01e4f3170e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void initGraph() {\n      Graph graph = new Graph();\n\n      MultiMap<VirtualFile, Node> roots = MultiMap.createSmart();\n\n      for (final Module module : ModuleManager.getInstance(myProject).getModules()) {\n        final ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n        List<OrderEnumerationHandler> handlers = OrderEnumeratorBase.getCustomHandlers(module);\n        for (OrderEntry orderEntry : moduleRootManager.getOrderEntries()) {\n          if (orderEntry instanceof ModuleOrderEntry) {\n            ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n            final Module depModule = moduleOrderEntry.getModule();\n            if (depModule != null) {\n              Node node = graph.myNodes.get(depModule);\n              OrderEnumerator en = OrderEnumerator.orderEntries(depModule).exportedOnly().recursively();\n              if (node == null) {\n                node = new Node();\n                node.myKey = depModule;\n                graph.myNodes.put(depModule, node);\n\n                VirtualFile[] importedClassRoots = en.classes().usingCache().getRoots();\n                for (VirtualFile importedClassRoot : importedClassRoots) {\n                  roots.putValue(importedClassRoot, node);\n                }\n\n                VirtualFile[] importedSourceRoots = en.sources().usingCache().getRoots();\n                for (VirtualFile sourceRoot : importedSourceRoots) {\n                  roots.putValue(sourceRoot, node);\n                }\n              }\n              boolean shouldRecurse = en.shouldRecurse(moduleOrderEntry, handlers);\n              node.myEdges.add(new Edge(module, moduleOrderEntry, shouldRecurse));\n            }\n          }\n        }\n      }\n\n      myGraph = graph;\n      myRoots = roots;\n    }","id":88601,"modified_method":"private void initGraph() {\n      Graph graph = new Graph();\n\n      MultiMap<VirtualFile, Node> roots = MultiMap.createSmart();\n\n      for (final Module module : ModuleManager.getInstance(myProject).getModules()) {\n        final ModuleRootManager moduleRootManager = ModuleRootManager.getInstance(module);\n        List<OrderEnumerationHandler> handlers = OrderEnumeratorBase.getCustomHandlers(module);\n        for (OrderEntry orderEntry : moduleRootManager.getOrderEntries()) {\n          if (orderEntry instanceof ModuleOrderEntry) {\n            ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;\n            final Module depModule = moduleOrderEntry.getModule();\n            if (depModule != null) {\n              Node node = graph.myNodes.get(depModule);\n              OrderEnumerator en = OrderEnumerator.orderEntries(depModule).exportedOnly();\n              if (node == null) {\n                node = new Node();\n                node.myKey = depModule;\n                graph.myNodes.put(depModule, node);\n\n                VirtualFile[] importedClassRoots = en.classes().usingCache().getRoots();\n                for (VirtualFile importedClassRoot : importedClassRoots) {\n                  roots.putValue(importedClassRoot, node);\n                }\n\n                VirtualFile[] importedSourceRoots = en.sources().usingCache().getRoots();\n                for (VirtualFile sourceRoot : importedSourceRoots) {\n                  roots.putValue(sourceRoot, node);\n                }\n              }\n              boolean shouldRecurse = en.recursively().shouldRecurse(moduleOrderEntry, handlers);\n              node.myEdges.add(new Edge(module, moduleOrderEntry, shouldRecurse));\n            }\n          }\n        }\n      }\n\n      myGraph = graph;\n      myRoots = roots;\n    }","commit_id":"540392faad0aa4658956147f0621be9cd1260b49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Generate fake metadata for an archive which doesn't have any.\n\t * @param ctx The context object.\n\t * @param key The key from which the archive we are unpacking was fetched.\n\t * @param names Set of names in the archive.\n\t * @param element2\n\t * @param gotElement\n\t * @param callbackName If we generate a\n\t * @throws ArchiveFailureException\n\t */\n\tprivate ArchiveStoreItem generateMetadata(ArchiveStoreContext ctx, FreenetURI key, Set<String> names, MutableBoolean gotElement, String element2, ArchiveExtractCallback callback, ObjectContainer container, ClientContext context) throws ArchiveFailureException {\n\t\t/* What we have to do is to:\n\t\t * - Construct a filesystem tree of the names.\n\t\t * - Turn each level of the tree into a Metadata object, including those below it, with\n\t\t * simple manifests and archive internal redirects.\n\t\t * - Turn the master Metadata object into binary metadata, with all its subsidiaries.\n\t\t * - Create a .metadata entry containing this data.\n\t\t */\n\t\t// Root directory.\n\t\t// String -> either itself, or another HashMap\n\t\tHashMap<String, Object> dir = new HashMap<String, Object>();\n\t\tfor (String name : names) {\n\t\t\taddToDirectory(dir, name, \"\");\n\t\t}\n\t\tMetadata metadata = new Metadata(dir, \"\");\n\t\tint x = 0;\n\t\tBucket bucket = null;\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tbucket = tempBucketFactory.makeBucket(-1);\n\t\t\t\tbyte[] buf = metadata.writeToByteArray();\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\tos.write(buf);\n\t\t\t\tos.close();\n\t\t\t\treturn addStoreElement(ctx, key, \".metadata\", bucket, gotElement, element2, callback, container, context);\n\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\ttry {\n\t\t\t\t\tx = resolve(e, x, bucket, ctx, key, gotElement, element2, callback, container, context);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t\t}\n\t\t\t} catch (IOException e1) {\n\t\t\t\tLogger.error(this, \"Failed to create metadata: \"+e1, e1);\n\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t}\n\t\t}\n\t}","id":88602,"modified_method":"/**\n\t * Generate fake metadata for an archive which doesn't have any.\n\t * @param ctx The context object.\n\t * @param key The key from which the archive we are unpacking was fetched.\n\t * @param names Set of names in the archive.\n\t * @param element2\n\t * @param gotElement\n\t * @param callbackName If we generate a\n\t * @throws ArchiveFailureException\n\t */\n\tprivate ArchiveStoreItem generateMetadata(ArchiveStoreContext ctx, FreenetURI key, Set<String> names, MutableBoolean gotElement, String element2, ArchiveExtractCallback callback, ObjectContainer container, ClientContext context) throws ArchiveFailureException {\n\t\t/* What we have to do is to:\n\t\t * - Construct a filesystem tree of the names.\n\t\t * - Turn each level of the tree into a Metadata object, including those below it, with\n\t\t * simple manifests and archive internal redirects.\n\t\t * - Turn the master Metadata object into binary metadata, with all its subsidiaries.\n\t\t * - Create a .metadata entry containing this data.\n\t\t */\n\t\t// Root directory.\n\t\t// String -> either itself, or another HashMap\n\t\tHashMap<String, Object> dir = new HashMap<String, Object>();\n\t\tfor (String name : names) {\n\t\t\taddToDirectory(dir, name, \"\");\n\t\t}\n\t\tMetadata metadata = new Metadata(dir, \"\");\n\t\tint x = 0;\n\t\tBucket bucket = null;\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tbucket = BucketTools.makeImmutableBucket(tempBucketFactory, metadata.writeToByteArray());\n\t\t\t\treturn addStoreElement(ctx, key, \".metadata\", bucket, gotElement, element2, callback, container, context);\n\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\ttry {\n\t\t\t\t\tx = resolve(e, x, bucket, ctx, key, gotElement, element2, callback, container, context);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t\t}\n\t\t\t} catch (IOException e1) {\n\t\t\t\tLogger.error(this, \"Failed to create metadata: \"+e1, e1);\n\t\t\t\tthrow new ArchiveFailureException(\"Failed to create metadata: \"+e1, e1);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b0985810c3e07be21def7e6612162229844b02b3","url":"https://github.com/freenet/fred"},{"original_method":"private int resolve(MetadataUnresolvedException e, int x, FreenetURI key, String element2, ObjectContainer container, ClientContext context) throws IOException {\n\t\tMetadata[] m = e.mustResolve;\n\t\tfor(int i=0;i<m.length;i++) {\n\t\t\ttry {\n\t\t\t\tbyte[] buf = m[i].writeToByteArray();\n\t\t\t\tBucket bucket = context.tempBucketFactory.makeBucket(buf.length);\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\tos.write(buf);\n\t\t\t\tos.close();\n\t\t\t\tString nameInArchive = \".metadata-\"+(x++);\n\t\t\t\tcontainerItems.add(new ContainerElement(bucket, nameInArchive));\n\t\t\t\tm[i].resolve(nameInArchive);\n\t\t\t} catch (MetadataUnresolvedException e1) {\n\t\t\t\tx = resolve(e, x, key, element2, container, context);\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}","id":88603,"modified_method":"private int resolve(MetadataUnresolvedException e, int x, FreenetURI key, String element2, ObjectContainer container, ClientContext context) throws IOException {\n\t\tMetadata[] m = e.mustResolve;\n\t\tfor(int i=0;i<m.length;i++) {\n\t\t\ttry {\n\t\t\t\tBucket bucket = BucketTools.makeImmutableBucket(context.tempBucketFactory, m[i].writeToByteArray());\n\t\t\t\tString nameInArchive = \".metadata-\"+(x++);\n\t\t\t\tcontainerItems.add(new ContainerElement(bucket, nameInArchive));\n\t\t\t\tm[i].resolve(nameInArchive);\n\t\t\t} catch (MetadataUnresolvedException e1) {\n\t\t\t\tx = resolve(e, x, key, element2, container, context);\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}","commit_id":"fd7aa35e09e474e0e9dca89f11f5974c8e7c2c25","url":"https://github.com/freenet/fred"},{"original_method":"private void makeMetadata(ClientContext context, ObjectContainer container) {\n\n\t\tBucket bucket = null;\n\t\tint x = 0;\n\n\t\tMetadata md = makeManifest(origMetadata, \"/\");\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tbyte[] buf;\n\t\t\t\ttry {\n\t\t\t\t\tbuf = md.writeToByteArray();\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tx = resolve(e, x, bucket, null, null, container, context);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\tfail(new InsertException(InsertException.INTERNAL_ERROR, e, null), container, context);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tbucket = context.tempBucketFactory.makeBucket(-1);\n\t\t\t\tOutputStream os = bucket.getOutputStream();\n\t\t\t\tos.write(buf);\n\t\t\t\tos.close();\n\t\t\t\tcontainerItems.add(new ContainerElement(bucket, \".metadata\"));\n\t\t\t\treturn;\n\t\t\t} catch (IOException e) {\n\t\t\t\tfail(new InsertException(InsertException.INTERNAL_ERROR, e, null), container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t}","id":88604,"modified_method":"private void makeMetadata(ClientContext context, ObjectContainer container) {\n\n\t\tBucket bucket = null;\n\t\tint x = 0;\n\n\t\tMetadata md = makeManifest(origMetadata, \"/\");\n\n\t\twhile(true) {\n\t\t\ttry {\n\t\t\t\tbucket = BucketTools.makeImmutableBucket(context.tempBucketFactory, md.writeToByteArray());\n\t\t\t\tcontainerItems.add(new ContainerElement(bucket, \".metadata\"));\n\t\t\t\treturn;\n\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\ttry {\n\t\t\t\t\tx = resolve(e, x, bucket, null, null, container, context);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tfail(new InsertException(InsertException.INTERNAL_ERROR, e, null), container, context);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tfail(new InsertException(InsertException.INTERNAL_ERROR, e, null), container, context);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"b31d9f13c0f9c5d4dedab8d8a1bdb2bc073bccc5","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n        public void run() {\n            while (true) {\n                try {\n                    long totalQueryTime = 0;\n                    for (int j = 0; j < QUERY_COUNT; j++) {\n                        SearchResponse searchResponse = client.prepareSearch(indexName)\n                                .setQuery(\n                                        filteredQuery(\n                                                matchAllQuery(),\n                                                hasChildFilter(\"child\", termQuery(\"tag\", \"tag\" + random.nextInt(CHILD_COUNT)))\n                                        )\n                                )\n                                .execute().actionGet();\n                        if (searchResponse.getFailedShards() > 0) {\n                            System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n                        }\n                        if (searchResponse.getHits().totalHits() != COUNT) {\n                            System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + COUNT + \"]\");\n                        }\n                        totalQueryTime += searchResponse.getTookInMillis();\n                    }\n                    System.out.println(\"--> has_child filter with term filter Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n                    totalQueryTime = 0;\n                    for (int j = 1; j <= QUERY_COUNT; j++) {\n                        SearchResponse searchResponse = client.prepareSearch(indexName)\n                                .setQuery(\n                                        filteredQuery(\n                                                matchAllQuery(),\n                                                hasChildFilter(\"child\", matchAllQuery())\n                                        )\n                                )\n                                .execute().actionGet();\n                        if (searchResponse.getFailedShards() > 0) {\n                            System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n                        }\n                        long expected = (COUNT / BATCH) * BATCH;\n                        if (searchResponse.getHits().totalHits() != expected) {\n                            System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + expected + \"]\");\n                        }\n                        totalQueryTime += searchResponse.getTookInMillis();\n                    }\n                    System.out.println(\"--> has_child filter with match_all child query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n                    NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                            .setJvm(true).execute().actionGet();\n                    System.out.println(\"--> Committed heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());\n                    System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n                    Thread.sleep(1000);\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n        }","id":88605,"modified_method":"@Override\n        public void run() {\n            while (run) {\n                try {\n                    long totalQueryTime = 0;\n                    for (int j = 0; j < QUERY_COUNT; j++) {\n                        SearchResponse searchResponse = client.prepareSearch(indexName)\n                                .setQuery(\n                                        filteredQuery(\n                                                matchAllQuery(),\n                                                hasChildFilter(\"child\", termQuery(\"tag\", \"tag\" + random.nextInt(CHILD_COUNT)))\n                                        )\n                                )\n                                .execute().actionGet();\n                        if (searchResponse.getFailedShards() > 0) {\n                            System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n                        }\n                        if (searchResponse.getHits().totalHits() != COUNT) {\n//                            System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + COUNT + \"]\");\n                        }\n                        totalQueryTime += searchResponse.getTookInMillis();\n                    }\n                    System.out.println(\"--> has_child filter with term filter Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n                    totalQueryTime = 0;\n                    for (int j = 1; j <= QUERY_COUNT; j++) {\n                        SearchResponse searchResponse = client.prepareSearch(indexName)\n                                .setQuery(\n                                        filteredQuery(\n                                                matchAllQuery(),\n                                                hasChildFilter(\"child\", matchAllQuery())\n                                        )\n                                )\n                                .execute().actionGet();\n                        if (searchResponse.getFailedShards() > 0) {\n                            System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n                        }\n                        long expected = (COUNT / BATCH) * BATCH;\n                        if (searchResponse.getHits().totalHits() != expected) {\n//                            System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + expected + \"]\");\n                        }\n                        totalQueryTime += searchResponse.getTookInMillis();\n                    }\n                    System.out.println(\"--> has_child filter with match_all child query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n                    NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                            .setJvm(true).execute().actionGet();\n                    System.out.println(\"--> Committed heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());\n                    System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n                    Thread.sleep(1000);\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n        }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void run() {\n            while (true) {\n                for (int i = 1; i < COUNT; i++) {\n                    try {\n                        client.prepareIndex(indexName, \"parent\", Integer.toString(i))\n                                .setSource(parentSource(Integer.toString(i), \"test\" + i)).execute().actionGet();\n                        for (int j = 0; j < CHILD_COUNT; j++) {\n                            client.prepareIndex(indexName, \"child\", Integer.toString(i) + \"_\" + j)\n                                    .setParent(Integer.toString(i))\n                                    .setSource(childSource(Integer.toString(j), \"tag\" + j)).execute().actionGet();\n                        }\n                        client.admin().indices().prepareRefresh(indexName).execute().actionGet();\n                        Thread.sleep(100);\n                        if (i % 500 == 0) {\n                            NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                                    .clear().setIndices(true).execute().actionGet();\n                            System.out.println(\"Deleted docs: \" + statsResponse.getAt(0).getIndices().getDocs().getDeleted());\n                        }\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }","id":88606,"modified_method":"@Override\n        public void run() {\n            while (run) {\n                for (int i = 1; run && i < COUNT; i++) {\n                    try {\n                        client.prepareIndex(indexName, \"parent\", Integer.toString(i))\n                                .setSource(parentSource(Integer.toString(i), \"test\" + i)).execute().actionGet();\n                        for (int j = 0; j < CHILD_COUNT; j++) {\n                            client.prepareIndex(indexName, \"child\", Integer.toString(i) + \"_\" + j)\n                                    .setParent(Integer.toString(i))\n                                    .setSource(childSource(Integer.toString(j), \"tag\" + j)).execute().actionGet();\n                        }\n                        client.admin().indices().prepareRefresh(indexName).execute().actionGet();\n                        Thread.sleep(100);\n                        if (i % 500 == 0) {\n                            NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                                    .clear().setIndices(true).execute().actionGet();\n                            System.out.println(\"Deleted docs: \" + statsResponse.getAt(0).getIndices().getDocs().getDeleted());\n                        }\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node node1 = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        Client client = node1.client();\n\n        client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10s\").execute().actionGet();\n        try {\n            client.admin().indices().create(createIndexRequest(indexName)).actionGet();\n            client.admin().indices().preparePutMapping(indexName).setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] parent document and [\" + (COUNT * CHILD_COUNT) + \" child documents\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(indexName).type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(Integer.toString(counter), \"test\" + counter)));\n                    for (int k = 0; k < CHILD_COUNT; k++) {\n                        request.add(Requests.indexRequest(indexName).type(\"child\").id(Integer.toString(counter) + \"_\" + k)\n                                .parent(Integer.toString(counter))\n                                .source(childSource(Integer.toString(counter), \"tag\" + k)));\n                    }\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) * (1 + CHILD_COUNT) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount());\n        new Thread(new SearchThread(client)).start();\n        new Thread(new IndexThread(client)).start();\n        Thread.sleep(Long.MAX_VALUE);\n        client.close();\n        node1.close();\n    }","id":88607,"modified_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        String clusterName = ChildSearchAndIndexingBenchmark.class.getSimpleName();\n        Node node1 = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node1\"))\n                .clusterName(clusterName)\n                .node();\n        Client client = node1.client();\n\n        client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10s\").execute().actionGet();\n        try {\n            client.admin().indices().create(createIndexRequest(indexName)).actionGet();\n            client.admin().indices().preparePutMapping(indexName).setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] parent document and [\" + (COUNT * CHILD_COUNT) + \" child documents\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(indexName).type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(Integer.toString(counter), \"test\" + counter)));\n                    for (int k = 0; k < CHILD_COUNT; k++) {\n                        request.add(Requests.indexRequest(indexName).type(\"child\").id(Integer.toString(counter) + \"_\" + k)\n                                .parent(Integer.toString(counter))\n                                .source(childSource(Integer.toString(counter), \"tag\" + k)));\n                    }\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) * (1 + CHILD_COUNT) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount());\n\n        SearchThread searchThread = new SearchThread(client);\n        new Thread(searchThread).start();\n        IndexThread indexThread = new IndexThread(client);\n        new Thread(indexThread).start();\n\n        System.in.read();\n\n        indexThread.stop();\n        searchThread.stop();\n        client.close();\n        node1.close();\n    }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node node1 = nodeBuilder().clusterName(\"classic\").settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        Client client = node1.client();\n\n        long COUNT = SizeValue.parseSizeValue(\"10m\").singles();\n        int CHILD_COUNT = 5;\n        int BATCH = 100;\n        int QUERY_WARMUP = 20;\n        int QUERY_COUNT = 50;\n        String indexName = \"test\";\n\n        client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10s\").execute().actionGet();\n        try {\n            client.admin().indices().create(createIndexRequest(indexName)).actionGet();\n            client.admin().indices().preparePutMapping(indexName).setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] parent document and [\" + (COUNT * CHILD_COUNT) + \" child documents\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(indexName).type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(counter, \"test\" + counter)));\n                    for (int k = 0; k < CHILD_COUNT; k++) {\n                        request.add(Requests.indexRequest(indexName).type(\"child\").id(Integer.toString(counter) + \"_\" + k)\n                                .parent(Integer.toString(counter))\n                                .source(childSource(counter, \"tag\" + k)));\n                    }\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) * (1 + CHILD_COUNT) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount(indexName).setQuery(matchAllQuery()).execute().actionGet().getCount());\n\n        System.out.println(\"--> Running just child query\");\n        // run just the child query, warm up first\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (j == 0) {\n                System.out.println(\"--> Warmup took: \" + searchResponse.getTook());\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n\n        long totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Just Child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).execute().actionGet();\n        System.out.println(\"--> Committed heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n        \n        // run parent child constant query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasChildFilter(\"child\", termQuery(\"tag\", \"tag1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + COUNT + \"]\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasChildFilter(\"child\", termQuery(\"tag\", \"tag1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + COUNT + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running has_child filter with match_all child query\");\n        totalQueryTime = 0;\n        for (int j = 1; j <= QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasChildFilter(\"child\", matchAllQuery())\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            long expected = (COUNT / BATCH) * BATCH;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + expected + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter with match_all child query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(\n                    filteredQuery(matchAllQuery(), hasChildFilter(\"child\", termQuery(\"id\", Integer.toString(j + 1))))\n            ).execute().actionGet();\n            long expected = 1;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter with single parent match Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", constantScoreQuery(rangeFilter(\"num\").lte(expected)))))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits: \" + searchResponse.getHits().totalHits() + \" != \" + expected);\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter with exponential parent results Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        /*// run parent child constant query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasParentFilter(\"parent\", termQuery(\"name\", \"test1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 1; j <= QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasParentFilter(\"parent\", termQuery(\"name\", \"test1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent filter Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running has_parent filter with match_all parent query \");\n        totalQueryTime = 0;\n        for (int j = 1; j <= QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(filteredQuery(\n                            matchAllQuery(),\n                            hasParentFilter(\"parent\", matchAllQuery())\n                    ))\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != 5000000) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + 5000000 + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent filter with match_all parent query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        System.out.println(\"--> Running top_children query\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> top_children Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running top_children query, with match_all as child query\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", matchAllQuery())).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", matchAllQuery())).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> top_children, with match_all Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");*/\n\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        System.out.println(\"--> Running has_child query with score type\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\")).scoreType(\"max\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\")).scoreType(\"max\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", matchAllQuery()).scoreType(\"max\")).execute().actionGet();\n            long expected = (COUNT / BATCH) * BATCH;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child query with match_all Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", termQuery(\"id\", Integer.toString(j + 1))).scoreType(\"max\")).execute().actionGet();\n            long expected = 1;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child query with single parent match Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", constantScoreQuery(rangeFilter(\"num\").lte(expected))).scoreType(\"max\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits: \" + searchResponse.getHits().totalHits() + \" != \" + expected);\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child query with exponential parent results Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        /*System.out.println(\"--> Running has_parent query with score type\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasParentQuery(\"parent\", termQuery(\"name\", \"test1\")).scoreType(\"score\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasParentQuery(\"parent\", termQuery(\"name\", \"test1\")).scoreType(\"score\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasParentQuery(\"parent\", matchAllQuery()).scoreType(\"score\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != 5000000) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent query with match_all Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");*/\n\n        System.gc();\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        client.close();\n        node1.close();\n    }","id":88608,"modified_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        String clusterName = ChildSearchBenchmark.class.getSimpleName();\n        Node node1 = nodeBuilder().clusterName(clusterName)\n                .settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        Client client = node1.client();\n\n        long COUNT = SizeValue.parseSizeValue(\"10m\").singles();\n        int CHILD_COUNT = 5;\n        int BATCH = 100;\n        int QUERY_WARMUP = 20;\n        int QUERY_COUNT = 50;\n        String indexName = \"test\";\n\n        client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10s\").execute().actionGet();\n        try {\n            client.admin().indices().create(createIndexRequest(indexName)).actionGet();\n            client.admin().indices().preparePutMapping(indexName).setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] parent document and [\" + (COUNT * CHILD_COUNT) + \" child documents\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(indexName).type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(counter, \"test\" + counter)));\n                    for (int k = 0; k < CHILD_COUNT; k++) {\n                        request.add(Requests.indexRequest(indexName).type(\"child\").id(Integer.toString(counter) + \"_\" + k)\n                                .parent(Integer.toString(counter))\n                                .source(childSource(counter, \"tag\" + k)));\n                    }\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) * (1 + CHILD_COUNT) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount(indexName).setQuery(matchAllQuery()).execute().actionGet().getCount());\n\n        System.out.println(\"--> Running just child query\");\n        // run just the child query, warm up first\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (j == 0) {\n                System.out.println(\"--> Warmup took: \" + searchResponse.getTook());\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n\n        long totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(termQuery(\"child.tag\", \"tag1\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Just Child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).execute().actionGet();\n        System.out.println(\"--> Committed heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n        \n        // run parent child constant query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasChildFilter(\"child\", termQuery(\"tag\", \"tag1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + COUNT + \"]\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasChildFilter(\"child\", termQuery(\"tag\", \"tag1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + COUNT + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running has_child filter with match_all child query\");\n        totalQueryTime = 0;\n        for (int j = 1; j <= QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasChildFilter(\"child\", matchAllQuery())\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            long expected = (COUNT / BATCH) * BATCH;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + expected + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter with match_all child query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(\n                    filteredQuery(matchAllQuery(), hasChildFilter(\"child\", termQuery(\"id\", Integer.toString(j + 1))))\n            ).execute().actionGet();\n            long expected = 1;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter with single parent match Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", constantScoreQuery(rangeFilter(\"num\").lte(expected)))))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits: \" + searchResponse.getHits().totalHits() + \" != \" + expected);\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child filter with exponential parent results Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        /*// run parent child constant query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasParentFilter(\"parent\", termQuery(\"name\", \"test1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 1; j <= QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            filteredQuery(\n                                    matchAllQuery(),\n                                    hasParentFilter(\"parent\", termQuery(\"name\", \"test1\"))\n                            )\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + CHILD_COUNT + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent filter Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running has_parent filter with match_all parent query \");\n        totalQueryTime = 0;\n        for (int j = 1; j <= QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(filteredQuery(\n                            matchAllQuery(),\n                            hasParentFilter(\"parent\", matchAllQuery())\n                    ))\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != 5000000) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + 5000000 + \"]\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent filter with match_all parent query, Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        System.out.println(\"--> Running top_children query\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", termQuery(\"tag\", \"tag1\"))).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> top_children Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        System.out.println(\"--> Running top_children query, with match_all as child query\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", matchAllQuery())).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(topChildrenQuery(\"child\", matchAllQuery())).execute().actionGet();\n            // we expect to have mismatch on hits here\n//            if (searchResponse.hits().totalHits() != COUNT) {\n//                System.err.println(\"mismatch on hits\");\n//            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> top_children, with match_all Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");*/\n\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        System.out.println(\"--> Running has_child query with score type\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\")).scoreType(\"max\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", termQuery(\"tag\", \"tag1\")).scoreType(\"max\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", matchAllQuery()).scoreType(\"max\")).execute().actionGet();\n            long expected = (COUNT / BATCH) * BATCH;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child query with match_all Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", termQuery(\"id\", Integer.toString(j + 1))).scoreType(\"max\")).execute().actionGet();\n            long expected = 1;\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child query with single parent match Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery(\"child\", constantScoreQuery(rangeFilter(\"num\").lte(expected))).scoreType(\"max\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != expected) {\n                System.err.println(\"mismatch on hits: \" + searchResponse.getHits().totalHits() + \" != \" + expected);\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_child query with exponential parent results Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        \n        /*System.out.println(\"--> Running has_parent query with score type\");\n        // run parent child score query\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasParentQuery(\"parent\", termQuery(\"name\", \"test1\")).scoreType(\"score\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasParentQuery(\"parent\", termQuery(\"name\", \"test1\")).scoreType(\"score\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasParentQuery(\"parent\", matchAllQuery()).scoreType(\"score\")).execute().actionGet();\n            if (searchResponse.getHits().totalHits() != 5000000) {\n                System.err.println(\"mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> has_parent query with match_all Query Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");*/\n\n        System.gc();\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        client.close();\n        node1.close();\n    }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node node1 = nodeBuilder().clusterName(\"bench1\").settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        Client client = node1.client();\n\n        long PARENT_COUNT = SizeValue.parseSizeValue(\"10M\").singles();\n        int BATCH = 100;\n        int QUERY_WARMUP = 5;\n        int QUERY_COUNT = 25;\n        String indexName = \"test\";\n\n        client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10s\").execute().actionGet();\n        try {\n            client.admin().indices().create(createIndexRequest(indexName)).actionGet();\n            client.admin().indices().preparePutMapping(indexName).setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + PARENT_COUNT + \"] parent document and some child documents\");\n            long ITERS = PARENT_COUNT / BATCH;\n            int i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(indexName).type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(counter)));\n\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \"parent docs; took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n\n            int id = 0;\n            for (i = 1; i <= PARENT_COUNT; i *= 2) {\n                int parentId = 1;\n                for (int j = 0; j < i; j++) {\n                    client.prepareIndex(indexName, \"child\", Integer.toString(id++))\n                            .setParent(Integer.toString(parentId++))\n                            .setSource(childSource(i))\n                            .execute().actionGet();\n                }\n            }\n\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime());\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount(indexName).setQuery(matchAllQuery()).execute().actionGet().getCount());\n\n        System.out.println(\"--> Running just child query\");\n        // run just the child query, warm up first\n        for (int i = 1; i <= 10000; i *= 2) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(matchQuery(\"child.field2\", i)).execute().actionGet();\n            System.out.println(\"--> Warmup took[\"+ i +\"]: \" + searchResponse.getTook());\n            if (searchResponse.getHits().totalHits() != i) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n\n        NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).execute().actionGet();\n        System.out.println(\"--> Committed heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        // run parent child constant query\n        for (int j = 1; j < QUERY_WARMUP; j *= 2) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            hasChildQuery(\"child\", matchQuery(\"field2\", j))\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != j) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + PARENT_COUNT + \"]\");\n            }\n        }\n\n        long totalQueryTime = 0;\n        for (int i = 1; i < PARENT_COUNT; i *= 2) {\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch(indexName)\n                        .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", matchQuery(\"field2\", i))))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != i) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> has_child filter \" + i +\" Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        totalQueryTime = 0;\n        for (int i = 1; i < PARENT_COUNT; i *= 2) {\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch(indexName)\n                        .setQuery(hasChildQuery(\"child\", matchQuery(\"field2\", i)).scoreType(\"max\"))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != i) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> has_child query \" + i +\" Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        System.gc();\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        client.close();\n        node1.close();\n    }","id":88609,"modified_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        String clusterName = ChildSearchShortCircuitBenchmark.class.getSimpleName();\n        Node node1 = nodeBuilder().clusterName(clusterName)\n                .settings(settingsBuilder().put(settings).put(\"name\", \"node1\"))\n                .node();\n        Client client = node1.client();\n\n        long PARENT_COUNT = SizeValue.parseSizeValue(\"10M\").singles();\n        int BATCH = 100;\n        int QUERY_WARMUP = 5;\n        int QUERY_COUNT = 25;\n        String indexName = \"test\";\n\n        client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10s\").execute().actionGet();\n        try {\n            client.admin().indices().create(createIndexRequest(indexName)).actionGet();\n            client.admin().indices().preparePutMapping(indexName).setType(\"child\").setSource(XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                    .startObject(\"_parent\").field(\"type\", \"parent\").endObject()\n                    .endObject().endObject()).execute().actionGet();\n            Thread.sleep(5000);\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + PARENT_COUNT + \"] parent document and some child documents\");\n            long ITERS = PARENT_COUNT / BATCH;\n            int i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    request.add(Requests.indexRequest(indexName).type(\"parent\").id(Integer.toString(counter))\n                            .source(parentSource(counter)));\n\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \"parent docs; took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n\n            int id = 0;\n            for (i = 1; i <= PARENT_COUNT; i *= 2) {\n                int parentId = 1;\n                for (int j = 0; j < i; j++) {\n                    client.prepareIndex(indexName, \"child\", Integer.toString(id++))\n                            .setParent(Integer.toString(parentId++))\n                            .setSource(childSource(i))\n                            .execute().actionGet();\n                }\n            }\n\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime());\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        System.out.println(\"--> Number of docs in index: \" + client.prepareCount(indexName).setQuery(matchAllQuery()).execute().actionGet().getCount());\n\n        System.out.println(\"--> Running just child query\");\n        // run just the child query, warm up first\n        for (int i = 1; i <= 10000; i *= 2) {\n            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(matchQuery(\"child.field2\", i)).execute().actionGet();\n            System.out.println(\"--> Warmup took[\"+ i +\"]: \" + searchResponse.getTook());\n            if (searchResponse.getHits().totalHits() != i) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n\n        NodesStatsResponse statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).execute().actionGet();\n        System.out.println(\"--> Committed heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        // run parent child constant query\n        for (int j = 1; j < QUERY_WARMUP; j *= 2) {\n            SearchResponse searchResponse = client.prepareSearch(indexName)\n                    .setQuery(\n                            hasChildQuery(\"child\", matchQuery(\"field2\", j))\n                    )\n                    .execute().actionGet();\n            if (searchResponse.getFailedShards() > 0) {\n                System.err.println(\"Search Failures \" + Arrays.toString(searchResponse.getShardFailures()));\n            }\n            if (searchResponse.getHits().totalHits() != j) {\n                System.err.println(\"--> mismatch on hits [\" + j + \"], got [\" + searchResponse.getHits().totalHits() + \"], expected [\" + PARENT_COUNT + \"]\");\n            }\n        }\n\n        long totalQueryTime = 0;\n        for (int i = 1; i < PARENT_COUNT; i *= 2) {\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch(indexName)\n                        .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", matchQuery(\"field2\", i))))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != i) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> has_child filter \" + i +\" Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        totalQueryTime = 0;\n        for (int i = 1; i < PARENT_COUNT; i *= 2) {\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch(indexName)\n                        .setQuery(hasChildQuery(\"child\", matchQuery(\"field2\", i)).scoreType(\"max\"))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != i) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> has_child query \" + i +\" Avg: \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        System.gc();\n        statsResponse = client.admin().cluster().prepareNodesStats()\n                .setJvm(true).setIndices(true).execute().actionGet();\n\n        System.out.println(\"--> Id cache size: \" + statsResponse.getNodes()[0].getIndices().getIdCache().getMemorySize());\n        System.out.println(\"--> Used heap size: \" + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());\n\n        client.close();\n        node1.close();\n    }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 2)\n                .put(SETTING_NUMBER_OF_REPLICAS, 1)\n                .build();\n\n        Node node1 = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n\n        //Node clientNode = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"client\")).client(true).node();\n\n        Client client = node1.client();\n\n        long COUNT = SizeValue.parseSizeValue(\"20m\").singles();\n        int BATCH = 500;\n        int QUERY_WARMUP = 20;\n        int QUERY_COUNT = 200;\n        int NUMBER_OF_TERMS = 1000;\n\n        long[] lValues = new long[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            lValues[i] = i;\n        }\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().prepareCreate(\"test\")\n                    .setSettings(settingsBuilder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0))\n                    .addMapping(\"test\", jsonBuilder()\n                        .startObject()\n                            .startObject(\"test\")\n                                .startObject(\"properties\")\n                                    .startObject(\"name\")\n                                        .startObject(\"fields\")\n                                            .startObject(\"l_value\")\n                                                .field(\"type\", \"long\")\n                                            .endObject()\n                                            .startObject(\"i_value\")\n                                                .field(\"type\", \"integer\")\n                                            .endObject()\n                                            .startObject(\"s_value\")\n                                                .field(\"type\", \"short\")\n                                            .endObject()\n                                            .startObject(\"b_value\")\n                                                .field(\"type\", \"byte\")\n                                            .endObject()\n                                        .endObject()\n                                    .endObject()\n                                .endObject()\n                            .endObject()\n                        .endObject())\n                    .execute().actionGet();\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    final long value = lValues[counter % lValues.length];\n                    XContentBuilder source = jsonBuilder().startObject()\n                            .field(\"id\", Integer.valueOf(counter))\n                            .field(\"l_value\", value)\n                            .field(\"i_value\", (int) value)\n                            .field(\"s_value\", (short) value)\n                            .field(\"b_value\", (byte) value)\n                            .field(\"date\", new Date())\n                            .endObject();\n                    request.add(Requests.indexRequest(\"test\").type(\"type1\").id(Integer.toString(counter))\n                            .source(source));\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT)) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        COUNT = client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();\n        System.out.println(\"--> Number of docs in index: \" + COUNT);\n\n        System.out.println(\"--> Warmup...\");\n        // run just the child query, warm up first\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(histogramFacet(\"l_value\").field(\"l_value\").interval(4))\n                    .addFacet(histogramFacet(\"i_value\").field(\"i_value\").interval(4))\n                    .addFacet(histogramFacet(\"s_value\").field(\"s_value\").interval(4))\n                    .addFacet(histogramFacet(\"b_value\").field(\"b_value\").interval(4))\n                    .addFacet(histogramFacet(\"date\").field(\"date\").interval(1000))\n                    .execute().actionGet();\n            if (j == 0) {\n                System.out.println(\"--> Warmup took: \" + searchResponse.getTook());\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n        System.out.println(\"--> Warmup DONE\");\n\n        long totalQueryTime = 0;\n        for (String field : new String[] {\"b_value\", \"s_value\", \"i_value\", \"l_value\"}) {\n            totalQueryTime = 0;\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(matchAllQuery())\n                        .addFacet(histogramFacet(field).field(field).interval(4))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != COUNT) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> Histogram Facet (\" + field + \") \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n            totalQueryTime = 0;\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(matchAllQuery())\n                        .addFacet(histogramFacet(\"l_value\").field(\"l_value\").valueField(\"l_value\").interval(4))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != COUNT) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> Histogram Facet (\" + field + \"/\" + field + \") \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(histogramFacet(\"date\").field(\"date\").interval(1000))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Histogram Facet (date) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(histogramFacet(\"date\").field(\"date\").valueField(\"l_value\").interval(1000))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Histogram Facet (date/l_value) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(dateHistogramFacet(\"date\").field(\"date\").interval(\"day\").mode(FacetBuilder.Mode.COLLECTOR))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Date Histogram Facet (mode/collector) (date) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(dateHistogramFacet(\"date\").field(\"date\").interval(\"day\").mode(FacetBuilder.Mode.POST))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Date Histogram Facet (mode/post) (date) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        node1.close();\n    }","id":88610,"modified_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.engine.robin.refreshInterval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 2)\n                .put(SETTING_NUMBER_OF_REPLICAS, 1)\n                .build();\n\n        String clusterName = HistogramFacetSearchBenchmark.class.getSimpleName();\n        Node node1 = nodeBuilder()\n                .clusterName(clusterName)\n                .settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n\n        //Node clientNode = nodeBuilder().clusterName(clusterName).settings(settingsBuilder().put(settings).put(\"name\", \"client\")).client(true).node();\n\n        Client client = node1.client();\n\n        long COUNT = SizeValue.parseSizeValue(\"20m\").singles();\n        int BATCH = 500;\n        int QUERY_WARMUP = 20;\n        int QUERY_COUNT = 200;\n        int NUMBER_OF_TERMS = 1000;\n\n        long[] lValues = new long[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            lValues[i] = i;\n        }\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().prepareCreate(\"test\")\n                    .setSettings(settingsBuilder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0))\n                    .addMapping(\"test\", jsonBuilder()\n                        .startObject()\n                            .startObject(\"test\")\n                                .startObject(\"properties\")\n                                    .startObject(\"name\")\n                                        .startObject(\"fields\")\n                                            .startObject(\"l_value\")\n                                                .field(\"type\", \"long\")\n                                            .endObject()\n                                            .startObject(\"i_value\")\n                                                .field(\"type\", \"integer\")\n                                            .endObject()\n                                            .startObject(\"s_value\")\n                                                .field(\"type\", \"short\")\n                                            .endObject()\n                                            .startObject(\"b_value\")\n                                                .field(\"type\", \"byte\")\n                                            .endObject()\n                                        .endObject()\n                                    .endObject()\n                                .endObject()\n                            .endObject()\n                        .endObject())\n                    .execute().actionGet();\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n                    final long value = lValues[counter % lValues.length];\n                    XContentBuilder source = jsonBuilder().startObject()\n                            .field(\"id\", Integer.valueOf(counter))\n                            .field(\"l_value\", value)\n                            .field(\"i_value\", (int) value)\n                            .field(\"s_value\", (short) value)\n                            .field(\"b_value\", (byte) value)\n                            .field(\"date\", new Date())\n                            .endObject();\n                    request.add(Requests.indexRequest(\"test\").type(\"type1\").id(Integer.toString(counter))\n                            .source(source));\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT)) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        COUNT = client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();\n        System.out.println(\"--> Number of docs in index: \" + COUNT);\n\n        System.out.println(\"--> Warmup...\");\n        // run just the child query, warm up first\n        for (int j = 0; j < QUERY_WARMUP; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(histogramFacet(\"l_value\").field(\"l_value\").interval(4))\n                    .addFacet(histogramFacet(\"i_value\").field(\"i_value\").interval(4))\n                    .addFacet(histogramFacet(\"s_value\").field(\"s_value\").interval(4))\n                    .addFacet(histogramFacet(\"b_value\").field(\"b_value\").interval(4))\n                    .addFacet(histogramFacet(\"date\").field(\"date\").interval(1000))\n                    .execute().actionGet();\n            if (j == 0) {\n                System.out.println(\"--> Warmup took: \" + searchResponse.getTook());\n            }\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n        }\n        System.out.println(\"--> Warmup DONE\");\n\n        long totalQueryTime = 0;\n        for (String field : new String[] {\"b_value\", \"s_value\", \"i_value\", \"l_value\"}) {\n            totalQueryTime = 0;\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(matchAllQuery())\n                        .addFacet(histogramFacet(field).field(field).interval(4))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != COUNT) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> Histogram Facet (\" + field + \") \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n            totalQueryTime = 0;\n            for (int j = 0; j < QUERY_COUNT; j++) {\n                SearchResponse searchResponse = client.prepareSearch()\n                        .setQuery(matchAllQuery())\n                        .addFacet(histogramFacet(\"l_value\").field(\"l_value\").valueField(\"l_value\").interval(4))\n                        .execute().actionGet();\n                if (searchResponse.getHits().totalHits() != COUNT) {\n                    System.err.println(\"--> mismatch on hits\");\n                }\n                totalQueryTime += searchResponse.getTookInMillis();\n            }\n            System.out.println(\"--> Histogram Facet (\" + field + \"/\" + field + \") \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n        }\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(histogramFacet(\"date\").field(\"date\").interval(1000))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Histogram Facet (date) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(histogramFacet(\"date\").field(\"date\").valueField(\"l_value\").interval(1000))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Histogram Facet (date/l_value) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(dateHistogramFacet(\"date\").field(\"date\").interval(\"day\").mode(FacetBuilder.Mode.COLLECTOR))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Date Histogram Facet (mode/collector) (date) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setQuery(matchAllQuery())\n                    .addFacet(dateHistogramFacet(\"date\").field(\"date\").interval(\"day\").mode(FacetBuilder.Mode.POST))\n                    .execute().actionGet();\n            if (searchResponse.getHits().totalHits() != COUNT) {\n                System.err.println(\"--> mismatch on hits\");\n            }\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"--> Date Histogram Facet (mode/post) (date) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        node1.close();\n    }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.refresh_interval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 2)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node node1 = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        client = node1.client();\n\n        long[] lValues = new long[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            lValues[i] = ThreadLocalRandom.current().nextLong();\n        }\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n\n                    XContentBuilder builder = jsonBuilder().startObject();\n                    builder.field(\"id\", Integer.toString(counter));\n                    builder.field(\"l_value\", lValues[counter % lValues.length]);\n\n                    builder.endObject();\n\n                    request.add(Requests.indexRequest(\"test\").type(\"type1\").id(Integer.toString(counter))\n                            .source(builder));\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT)) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        COUNT = client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();\n        System.out.println(\"--> Number of docs in index: \" + COUNT);\n\n\n        long totalQueryTime = 0;\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Simple Query on first l_value \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .addFacet(FacetBuilders.queryFacet(\"query\").query(termQuery(\"l_value\", lValues[0])))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Query facet first l_value \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .addFacet(FacetBuilders.queryFacet(\"query\").query(termQuery(\"l_value\", lValues[0])).global(true).mode(FacetBuilder.Mode.COLLECTOR))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Query facet first l_value (global) (mode/collector) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .addFacet(FacetBuilders.queryFacet(\"query\").query(termQuery(\"l_value\", lValues[0])).global(true).mode(FacetBuilder.Mode.POST))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Query facet first l_value (global) (mode/post) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n    }","id":88611,"modified_method":"public static void main(String[] args) throws Exception {\n        Settings settings = settingsBuilder()\n                .put(\"index.refresh_interval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 2)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        String clusterName = QueryFilterFacetSearchBenchmark.class.getSimpleName();\n        Node node1 = nodeBuilder()\n                .clusterName(clusterName)\n                .settings(settingsBuilder().put(settings).put(\"name\", \"node1\")).node();\n        client = node1.client();\n\n        long[] lValues = new long[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            lValues[i] = ThreadLocalRandom.current().nextLong();\n        }\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n\n                    XContentBuilder builder = jsonBuilder().startObject();\n                    builder.field(\"id\", Integer.toString(counter));\n                    builder.field(\"l_value\", lValues[counter % lValues.length]);\n\n                    builder.endObject();\n\n                    request.add(Requests.indexRequest(\"test\").type(\"type1\").id(Integer.toString(counter))\n                            .source(builder));\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT)) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        COUNT = client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();\n        System.out.println(\"--> Number of docs in index: \" + COUNT);\n\n\n        long totalQueryTime = 0;\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Simple Query on first l_value \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .addFacet(FacetBuilders.queryFacet(\"query\").query(termQuery(\"l_value\", lValues[0])))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Query facet first l_value \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .addFacet(FacetBuilders.queryFacet(\"query\").query(termQuery(\"l_value\", lValues[0])).global(true).mode(FacetBuilder.Mode.COLLECTOR))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Query facet first l_value (global) (mode/collector) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n\n        totalQueryTime = 0;\n        for (int j = 0; j < QUERY_COUNT; j++) {\n            SearchResponse searchResponse = client.prepareSearch()\n                    .setSearchType(SearchType.COUNT)\n                    .setQuery(termQuery(\"l_value\", lValues[0]))\n                    .addFacet(FacetBuilders.queryFacet(\"query\").query(termQuery(\"l_value\", lValues[0])).global(true).mode(FacetBuilder.Mode.POST))\n                    .execute().actionGet();\n            totalQueryTime += searchResponse.getTookInMillis();\n        }\n        System.out.println(\"-->  Query facet first l_value (global) (mode/post) \" + (totalQueryTime / QUERY_COUNT) + \"ms\");\n    }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws Exception {\n        Random random = new Random();\n\n        Settings settings = settingsBuilder()\n                .put(\"index.refresh_interval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        Node[] nodes = new Node[1];\n        for (int i = 0; i < nodes.length; i++) {\n            nodes[i] = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"node\" + i)).node();\n        }\n\n        Node clientNode = nodeBuilder().settings(settingsBuilder().put(settings).put(\"name\", \"client\")).client(true).node();\n\n        client = clientNode.client();\n\n        long[] lValues = new long[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            lValues[i] = ThreadLocalRandom.current().nextLong();\n        }\n        String[] sValues = new String[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            sValues[i] = RandomStrings.randomAsciiOfLength(random, STRING_TERM_SIZE);\n        }\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n\n                    XContentBuilder builder = jsonBuilder().startObject();\n                    builder.field(\"id\", Integer.toString(counter));\n                    builder.field(\"s_value\", sValues[counter % sValues.length]);\n                    builder.field(\"l_value\", lValues[counter % lValues.length]);\n\n                    builder.startArray(\"sm_value\");\n                    for (int k = 0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {\n                        builder.value(sValues[ThreadLocalRandom.current().nextInt(sValues.length)]);\n                    }\n                    builder.endArray();\n\n                    builder.startArray(\"lm_value\");\n                    for (int k = 0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {\n                        builder.value(lValues[ThreadLocalRandom.current().nextInt(sValues.length)]);\n                    }\n                    builder.endArray();\n\n                    builder.endObject();\n\n                    request.add(Requests.indexRequest(\"test\").type(\"type1\").id(Integer.toString(counter))\n                            .source(builder));\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT)) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        COUNT = client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();\n        System.out.println(\"--> Number of docs in index: \" + COUNT);\n\n\n        List<StatsResult> stats = Lists.newArrayList();\n        stats.add(terms(\"terms_s\", \"s_value\", null));\n        stats.add(terms(\"terms_map_s\", \"s_value\", \"map\"));\n        stats.add(terms(\"terms_l\", \"l_value\", null));\n        stats.add(terms(\"terms_map_l\", \"l_value\", \"map\"));\n        stats.add(terms(\"terms_sm\", \"sm_value\", null));\n        stats.add(terms(\"terms_map_sm\", \"sm_value\", \"map\"));\n        stats.add(terms(\"terms_lm\", \"lm_value\", null));\n        stats.add(terms(\"terms_map_lm\", \"lm_value\", \"map\"));\n\n        stats.add(termsStats(\"terms_stats_s_l\", \"s_value\", \"l_value\", null));\n        stats.add(termsStats(\"terms_stats_s_lm\", \"s_value\", \"lm_value\", null));\n        stats.add(termsStats(\"terms_stats_sm_l\", \"sm_value\", \"l_value\", null));\n\n        System.out.println(\"------------------ SUMMARY -------------------------------\");\n        System.out.format(\"%25s%10s%10s\\n\", \"name\", \"took\", \"millis\");\n        for (StatsResult stat : stats) {\n            System.out.format(\"%25s%10s%10d\\n\", stat.name, TimeValue.timeValueMillis(stat.took), (stat.took / QUERY_COUNT));\n        }\n        System.out.println(\"------------------ SUMMARY -------------------------------\");\n\n        clientNode.close();\n\n        for (Node node : nodes) {\n            node.close();\n        }\n    }","id":88612,"modified_method":"public static void main(String[] args) throws Exception {\n        Random random = new Random();\n\n        Settings settings = settingsBuilder()\n                .put(\"index.refresh_interval\", \"-1\")\n                .put(\"gateway.type\", \"local\")\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .build();\n\n        String clusterName = TermsFacetSearchBenchmark.class.getSimpleName();\n        Node[] nodes = new Node[1];\n        for (int i = 0; i < nodes.length; i++) {\n            nodes[i] = nodeBuilder().clusterName(clusterName)\n                    .settings(settingsBuilder().put(settings).put(\"name\", \"node\" + i))\n                    .node();\n        }\n\n        Node clientNode = nodeBuilder()\n                .clusterName(clusterName)\n                .settings(settingsBuilder().put(settings).put(\"name\", \"client\")).client(true).node();\n\n        client = clientNode.client();\n\n        long[] lValues = new long[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            lValues[i] = ThreadLocalRandom.current().nextLong();\n        }\n        String[] sValues = new String[NUMBER_OF_TERMS];\n        for (int i = 0; i < NUMBER_OF_TERMS; i++) {\n            sValues[i] = RandomStrings.randomAsciiOfLength(random, STRING_TERM_SIZE);\n        }\n\n        Thread.sleep(10000);\n        try {\n            client.admin().indices().create(createIndexRequest(\"test\")).actionGet();\n\n            StopWatch stopWatch = new StopWatch().start();\n\n            System.out.println(\"--> Indexing [\" + COUNT + \"] ...\");\n            long ITERS = COUNT / BATCH;\n            long i = 1;\n            int counter = 0;\n            for (; i <= ITERS; i++) {\n                BulkRequestBuilder request = client.prepareBulk();\n                for (int j = 0; j < BATCH; j++) {\n                    counter++;\n\n                    XContentBuilder builder = jsonBuilder().startObject();\n                    builder.field(\"id\", Integer.toString(counter));\n                    builder.field(\"s_value\", sValues[counter % sValues.length]);\n                    builder.field(\"l_value\", lValues[counter % lValues.length]);\n\n                    builder.startArray(\"sm_value\");\n                    for (int k = 0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {\n                        builder.value(sValues[ThreadLocalRandom.current().nextInt(sValues.length)]);\n                    }\n                    builder.endArray();\n\n                    builder.startArray(\"lm_value\");\n                    for (int k = 0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {\n                        builder.value(lValues[ThreadLocalRandom.current().nextInt(sValues.length)]);\n                    }\n                    builder.endArray();\n\n                    builder.endObject();\n\n                    request.add(Requests.indexRequest(\"test\").type(\"type1\").id(Integer.toString(counter))\n                            .source(builder));\n                }\n                BulkResponse response = request.execute().actionGet();\n                if (response.hasFailures()) {\n                    System.err.println(\"--> failures...\");\n                }\n                if (((i * BATCH) % 10000) == 0) {\n                    System.out.println(\"--> Indexed \" + (i * BATCH) + \" took \" + stopWatch.stop().lastTaskTime());\n                    stopWatch.start();\n                }\n            }\n            System.out.println(\"--> Indexing took \" + stopWatch.totalTime() + \", TPS \" + (((double) (COUNT)) / stopWatch.totalTime().secondsFrac()));\n        } catch (Exception e) {\n            System.out.println(\"--> Index already exists, ignoring indexing phase, waiting for green\");\n            ClusterHealthResponse clusterHealthResponse = client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout(\"10m\").execute().actionGet();\n            if (clusterHealthResponse.isTimedOut()) {\n                System.err.println(\"--> Timed out waiting for cluster health\");\n            }\n        }\n        client.admin().indices().prepareRefresh().execute().actionGet();\n        COUNT = client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();\n        System.out.println(\"--> Number of docs in index: \" + COUNT);\n\n\n        List<StatsResult> stats = Lists.newArrayList();\n        stats.add(terms(\"terms_s\", \"s_value\", null));\n        stats.add(terms(\"terms_map_s\", \"s_value\", \"map\"));\n        stats.add(terms(\"terms_l\", \"l_value\", null));\n        stats.add(terms(\"terms_map_l\", \"l_value\", \"map\"));\n        stats.add(terms(\"terms_sm\", \"sm_value\", null));\n        stats.add(terms(\"terms_map_sm\", \"sm_value\", \"map\"));\n        stats.add(terms(\"terms_lm\", \"lm_value\", null));\n        stats.add(terms(\"terms_map_lm\", \"lm_value\", \"map\"));\n\n        stats.add(termsStats(\"terms_stats_s_l\", \"s_value\", \"l_value\", null));\n        stats.add(termsStats(\"terms_stats_s_lm\", \"s_value\", \"lm_value\", null));\n        stats.add(termsStats(\"terms_stats_sm_l\", \"sm_value\", \"l_value\", null));\n\n        System.out.println(\"------------------ SUMMARY -------------------------------\");\n        System.out.format(\"%25s%10s%10s\\n\", \"name\", \"took\", \"millis\");\n        for (StatsResult stat : stats) {\n            System.out.format(\"%25s%10s%10d\\n\", stat.name, TimeValue.timeValueMillis(stat.took), (stat.took / QUERY_COUNT));\n        }\n        System.out.println(\"------------------ SUMMARY -------------------------------\");\n\n        clientNode.close();\n\n        for (Node node : nodes) {\n            node.close();\n        }\n    }","commit_id":"23c035da35bffbfd99091f1c349c10cf49906bfc","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    myIsTemplate = Boolean.valueOf(element.getAttributeValue(TEMPLATE_FLAG_ATTRIBUTE)).booleanValue();\n    myTemporary = Boolean.valueOf(element.getAttributeValue(TEMPORARY_ATTRIBUTE)).booleanValue() || TEMP_CONFIGURATION.equals(element.getName());\n    myEditBeforeRun = Boolean.valueOf(element.getAttributeValue(EDIT_BEFORE_RUN)).booleanValue();\n    myFolderName = element.getAttributeValue(FOLDER_NAME);\n    // singleton is not configurable by user for template\n    if (!myIsTemplate) {\n      mySingleton = Boolean.valueOf(element.getAttributeValue(SINGLETON)).booleanValue();\n    }\n\n    final ConfigurationFactory factory = getFactory(element);\n    if (factory == null) return;\n\n    if (myIsTemplate) {\n      mySingleton = factory.isConfigurationSingletonByDefault();\n      myConfiguration = myManager.getConfigurationTemplate(factory).getConfiguration();\n    } else {\n      final String name = element.getAttributeValue(NAME_ATTR);\n      // shouldn't call createConfiguration since it calls StepBeforeRunProviders that\n      // may not be loaded yet. This creates initialization order issue.\n      myConfiguration = myManager.doCreateConfiguration(name, factory, false);\n    }\n\n    myConfiguration.readExternal(element);\n    List<Element> runners = element.getChildren(RUNNER_ELEMENT);\n    myUnloadedRunnerSettings = null;\n    for (final Element runnerElement : runners) {\n      String id = runnerElement.getAttributeValue(RUNNER_ID);\n      ProgramRunner runner = RunnerRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        RunnerSettings settings = createRunnerSettings(runner);\n        settings.readExternal(runnerElement);\n        myRunnerSettings.put(runner, settings);\n      }\n      else {\n        if (myUnloadedRunnerSettings == null) myUnloadedRunnerSettings = new ArrayList<Element>(1);\n        IdeaPluginDescriptorImpl.internJDOMElement(runnerElement);\n        myUnloadedRunnerSettings.add(runnerElement);\n      }\n    }\n\n    List configurations = element.getChildren(CONFIGURATION_ELEMENT);\n    myUnloadedConfigurationPerRunnerSettings = null;\n    for (final Object configuration : configurations) {\n      Element configurationElement = (Element) configuration;\n      String id = configurationElement.getAttributeValue(RUNNER_ID);\n      ProgramRunner runner = RunnerRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        ConfigurationPerRunnerSettings settings = myConfiguration.createRunnerSettings(new InfoProvider(runner));\n        settings.readExternal(configurationElement);\n        myConfigurationPerRunnerSettings.put(runner, settings);\n      } else {\n        if (myUnloadedConfigurationPerRunnerSettings == null)\n          myUnloadedConfigurationPerRunnerSettings = new ArrayList<Element>(1);\n        myUnloadedConfigurationPerRunnerSettings.add(configurationElement);\n      }\n    }\n  }","id":88613,"modified_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    myIsTemplate = Boolean.valueOf(element.getAttributeValue(TEMPLATE_FLAG_ATTRIBUTE)).booleanValue();\n    myTemporary = Boolean.valueOf(element.getAttributeValue(TEMPORARY_ATTRIBUTE)).booleanValue() || TEMP_CONFIGURATION.equals(element.getName());\n    myEditBeforeRun = Boolean.valueOf(element.getAttributeValue(EDIT_BEFORE_RUN)).booleanValue();\n    myFolderName = element.getAttributeValue(FOLDER_NAME);\n    // singleton is not configurable by user for template\n    if (!myIsTemplate) {\n      mySingleton = Boolean.valueOf(element.getAttributeValue(SINGLETON)).booleanValue();\n    }\n\n    final ConfigurationFactory factory = getFactory(element);\n    if (factory == null) return;\n\n    if (myIsTemplate) {\n      mySingleton = factory.isConfigurationSingletonByDefault();\n      myConfiguration = myManager.getConfigurationTemplate(factory).getConfiguration();\n    } else {\n      final String name = element.getAttributeValue(NAME_ATTR);\n      // shouldn't call createConfiguration since it calls StepBeforeRunProviders that\n      // may not be loaded yet. This creates initialization order issue.\n      myConfiguration = myManager.doCreateConfiguration(name, factory, false);\n    }\n\n    myConfiguration.readExternal(element);\n    List<Element> runners = element.getChildren(RUNNER_ELEMENT);\n    myUnloadedRunnerSettings = null;\n    for (final Element runnerElement : runners) {\n      String id = runnerElement.getAttributeValue(RUNNER_ID);\n      ProgramRunner runner = RunnerRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        RunnerSettings settings = createRunnerSettings(runner);\n        settings.readExternal(runnerElement);\n        myRunnerSettings.put(runner, settings);\n      }\n      else {\n        if (myUnloadedRunnerSettings == null) myUnloadedRunnerSettings = new ArrayList<Element>(1);\n        IdeaPluginDescriptorImpl.internJDOMElement(runnerElement);\n        myUnloadedRunnerSettings.add(runnerElement);\n      }\n    }\n\n    List configurations = element.getChildren(CONFIGURATION_ELEMENT);\n    myUnloadedConfigurationPerRunnerSettings = null;\n    for (final Object configuration : configurations) {\n      Element configurationElement = (Element) configuration;\n      String id = configurationElement.getAttributeValue(RUNNER_ID);\n      ProgramRunner runner = RunnerRegistry.getInstance().findRunnerById(id);\n      if (runner != null) {\n        ConfigurationPerRunnerSettings settings = myConfiguration.createRunnerSettings(new InfoProvider(runner));\n        if (settings != null) {\n          settings.readExternal(configurationElement);\n        }\n        myConfigurationPerRunnerSettings.put(runner, settings);\n      } else {\n        if (myUnloadedConfigurationPerRunnerSettings == null)\n          myUnloadedConfigurationPerRunnerSettings = new ArrayList<Element>(1);\n        myUnloadedConfigurationPerRunnerSettings.add(configurationElement);\n      }\n    }\n  }","commit_id":"a96c9a19149e3194a04276296258888b31220c38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void writeConfigurationPerRunnerSettings(final Comparator<Element> runnerComparator, final Element element)\n      throws WriteExternalException {\n    final ArrayList<Element> configurationPerRunnerSettings = new ArrayList<Element>();\n    for (ProgramRunner runner : myConfigurationPerRunnerSettings.keySet()) {\n      ConfigurationPerRunnerSettings settings = myConfigurationPerRunnerSettings.get(runner);\n      Element runnerElement = new Element(CONFIGURATION_ELEMENT);\n      settings.writeExternal(runnerElement);\n      runnerElement.setAttribute(RUNNER_ID, runner.getRunnerId());\n      configurationPerRunnerSettings.add(runnerElement);\n    }\n    if (myUnloadedConfigurationPerRunnerSettings != null) {\n      for (Element unloadedCRunnerSetting : myUnloadedConfigurationPerRunnerSettings) {\n        configurationPerRunnerSettings.add((Element) unloadedCRunnerSetting.clone());\n      }\n    }\n    Collections.sort(configurationPerRunnerSettings, runnerComparator);\n    for (Element runnerConfigurationSetting : configurationPerRunnerSettings) {\n      element.addContent(runnerConfigurationSetting);\n    }\n  }","id":88614,"modified_method":"private void writeConfigurationPerRunnerSettings(final Comparator<Element> runnerComparator, final Element element)\n      throws WriteExternalException {\n    final ArrayList<Element> configurationPerRunnerSettings = new ArrayList<Element>();\n    for (ProgramRunner runner : myConfigurationPerRunnerSettings.keySet()) {\n      ConfigurationPerRunnerSettings settings = myConfigurationPerRunnerSettings.get(runner);\n      Element runnerElement = new Element(CONFIGURATION_ELEMENT);\n      runnerElement.setAttribute(RUNNER_ID, runner.getRunnerId());\n      if (settings != null) {\n        settings.writeExternal(runnerElement);\n      }\n      configurationPerRunnerSettings.add(runnerElement);\n    }\n    if (myUnloadedConfigurationPerRunnerSettings != null) {\n      for (Element unloadedCRunnerSetting : myUnloadedConfigurationPerRunnerSettings) {\n        configurationPerRunnerSettings.add(unloadedCRunnerSetting.clone());\n      }\n    }\n    Collections.sort(configurationPerRunnerSettings, runnerComparator);\n    for (Element runnerConfigurationSetting : configurationPerRunnerSettings) {\n      element.addContent(runnerConfigurationSetting);\n    }\n  }","commit_id":"a96c9a19149e3194a04276296258888b31220c38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void importRunnerAndConfigurationSettings(RunnerAndConfigurationSettingsImpl template) {\n    try {\n      for (ProgramRunner runner : template.myRunnerSettings.keySet()) {\n        RunnerSettings data = createRunnerSettings(runner);\n        myRunnerSettings.put(runner, data);\n        Element temp = new Element(DUMMY_ELEMENT_NANE);\n        template.myRunnerSettings.get(runner).writeExternal(temp);\n        data.readExternal(temp);\n      }\n\n      for (ProgramRunner runner : template.myConfigurationPerRunnerSettings.keySet()) {\n        ConfigurationPerRunnerSettings data = myConfiguration.createRunnerSettings(new InfoProvider(runner));\n        myConfigurationPerRunnerSettings.put(runner, data);\n        Element temp = new Element(DUMMY_ELEMENT_NANE);\n        template.myConfigurationPerRunnerSettings.get(runner).writeExternal(temp);\n        data.readExternal(temp);\n      }\n      setSingleton(template.isSingleton());\n      setEditBeforeRun(template.isEditBeforeRun());\n    }\n    catch (WriteExternalException e) {\n      LOG.error(e);\n    }\n    catch (InvalidDataException e) {\n      LOG.error(e);\n    }\n  }","id":88615,"modified_method":"public void importRunnerAndConfigurationSettings(RunnerAndConfigurationSettingsImpl template) {\n    try {\n      for (ProgramRunner runner : template.myRunnerSettings.keySet()) {\n        RunnerSettings data = createRunnerSettings(runner);\n        myRunnerSettings.put(runner, data);\n        Element temp = new Element(DUMMY_ELEMENT_NANE);\n        template.myRunnerSettings.get(runner).writeExternal(temp);\n        data.readExternal(temp);\n      }\n\n      for (ProgramRunner runner : template.myConfigurationPerRunnerSettings.keySet()) {\n        ConfigurationPerRunnerSettings data = myConfiguration.createRunnerSettings(new InfoProvider(runner));\n        myConfigurationPerRunnerSettings.put(runner, data);\n        if (data != null) {\n          Element temp = new Element(DUMMY_ELEMENT_NANE);\n          ConfigurationPerRunnerSettings templateSettings = template.myConfigurationPerRunnerSettings.get(runner);\n          if (templateSettings != null) {\n            templateSettings.writeExternal(temp);\n            data.readExternal(temp);\n          }\n        }\n      }\n      setSingleton(template.isSingleton());\n      setEditBeforeRun(template.isEditBeforeRun());\n    }\n    catch (WriteExternalException e) {\n      LOG.error(e);\n    }\n    catch (InvalidDataException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"a96c9a19149e3194a04276296258888b31220c38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public ConfigurationPerRunnerSettings getConfigurationSettings(@NotNull ProgramRunner runner) {\n    ConfigurationPerRunnerSettings settings = myConfigurationPerRunnerSettings.get(runner);\n    if (settings == null) {\n      settings = myConfiguration.createRunnerSettings(new InfoProvider(runner));\n      myConfigurationPerRunnerSettings.put(runner, settings);\n    }\n    return settings;\n  }","id":88616,"modified_method":"@Override\n  @Nullable\n  public ConfigurationPerRunnerSettings getConfigurationSettings(@NotNull ProgramRunner runner) {\n    if (!myConfigurationPerRunnerSettings.containsKey(runner)) {\n      ConfigurationPerRunnerSettings settings = myConfiguration.createRunnerSettings(new InfoProvider(runner));\n      myConfigurationPerRunnerSettings.put(runner, settings);\n      return settings;\n    }\n    return myConfigurationPerRunnerSettings.get(runner);\n  }","commit_id":"a96c9a19149e3194a04276296258888b31220c38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    initCommonSettingsMap();\n    final List list = element.getChildren(COMMON_SETTINGS_TAG);\n    if (list != null) {\n      for(Object o:list) {\n        if (o instanceof Element) {\n          final Element commonSettingsElement = (Element)o;\n          final String languageId = commonSettingsElement.getAttributeValue(LANGUAGE_ATTR);\n          if (languageId != null && languageId.length() > 0) {\n            Language target = Language.findLanguageByID(languageId);\n            if (target != null) {\n              final CommonCodeStyleSettings defaultSettings = LanguageCodeStyleSettingsProvider.getDefaultCommonSettings(target);\n              final CommonCodeStyleSettings settings = defaultSettings != null ? defaultSettings : new CommonCodeStyleSettings(target);\n              settings.readExternal(commonSettingsElement);\n              registerCommonSettings(target, settings);\n            } else {\n              myUnknownSettingsMap.put(languageId, (Content)commonSettingsElement.clone());\n            }\n          }\n        }\n      }\n    }\n    initNonReadSettings();\n  }","id":88617,"modified_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    initCommonSettingsMap();\n    final List list = element.getChildren(COMMON_SETTINGS_TAG);\n    if (list != null) {\n      for(Object o:list) {\n        if (o instanceof Element) {\n          final Element commonSettingsElement = (Element)o;\n          final String languageId = commonSettingsElement.getAttributeValue(LANGUAGE_ATTR);\n          if (languageId != null && languageId.length() > 0) {\n            Language target = Language.findLanguageByID(languageId);\n            boolean isKnownLanguage = target != null;\n            if (isKnownLanguage) {\n              final CommonCodeStyleSettings settings = LanguageCodeStyleSettingsProvider.getDefaultCommonSettings(target);\n              if (settings != null) {\n                settings.readExternal(commonSettingsElement);\n                registerCommonSettings(target, settings);\n              }\n              else {\n                isKnownLanguage = false;\n              }\n            }\n            if (!isKnownLanguage) {\n              myUnknownSettingsMap.put(languageId, (Content)commonSettingsElement.clone());\n            }\n          }\n        }\n      }\n    }\n    initNonReadSettings();\n  }","commit_id":"d154c712b876ce981e0eb68747c80b2471e24672","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Configuration readConfiguration(final Element childElement) {\n    final Configuration config =\n      childElement.getName().equals(SEARCH_TAG_NAME) ? new SearchConfiguration() : new ReplaceConfiguration();\n\n    config.readExternal(childElement);\n    return config;\n  }","id":88618,"modified_method":"public static Configuration readConfiguration(final Element childElement) {\n    String s = childElement.getName();\n    final Configuration config =\n      s.equals(SEARCH_TAG_NAME) ? new SearchConfiguration() : s.equals(REPLACE_TAG_NAME) ? new ReplaceConfiguration():null;\n    if (config != null) config.readExternal(childElement);\n    return config;\n  }","commit_id":"1628fe56694766c39103a0a4c5efc5855b4fcb27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void readConfigurations(final Element element, @NotNull Collection<Configuration> configurations, @NotNull Collection<Configuration> historyConfigurations) {\n    List patterns = element.getChildren();\n\n    if (patterns != null && patterns.size() > 0) {\n      for (final Object pattern : patterns) {\n        final Element childElement = (Element)pattern;\n        final Configuration config = readConfiguration(childElement);\n\n        if (childElement.getAttribute(SAVE_HISTORY_ATTR_NAME) != null) {\n          historyConfigurations.add(config);\n        }\n        else {\n          configurations.add(config);\n        }\n      }\n    }\n  }","id":88619,"modified_method":"public static void readConfigurations(final Element element, @NotNull Collection<Configuration> configurations, @NotNull Collection<Configuration> historyConfigurations) {\n    List patterns = element.getChildren();\n\n    if (patterns != null && patterns.size() > 0) {\n      for (final Object pattern : patterns) {\n        final Element childElement = (Element)pattern;\n        final Configuration config = readConfiguration(childElement);\n        if (config == null) continue;\n\n        if (childElement.getAttribute(SAVE_HISTORY_ATTR_NAME) != null) {\n          historyConfigurations.add(config);\n        }\n        else {\n          configurations.add(config);\n        }\n      }\n    }\n  }","commit_id":"1628fe56694766c39103a0a4c5efc5855b4fcb27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BsmAdminPageEdgeEditWindow weight(int weight) {\n            enterText(By.id(\"weightField\"), String.valueOf(weight));\n            findElementById(\"weightField\").sendKeys(Keys.ENTER);\n            return this;\n        }","id":88620,"modified_method":"public BsmAdminPageEdgeEditWindow weight(int weight) {\n            enterText(By.id(\"weightField\"), String.valueOf(weight)).sendKeys(Keys.ENTER);\n            return this;\n        }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageEdgeEditWindow friendlyName(String friendlyName) throws InterruptedException {\n            enterText(By.id(\"friendlyNameField\"), friendlyName != null ? friendlyName : \"\");\n            findElementById(\"friendlyNameField\").sendKeys(Keys.ENTER);\n            return this;\n        }","id":88621,"modified_method":"public BsmAdminPageEdgeEditWindow friendlyName(String friendlyName) throws InterruptedException {\n            enterText(By.id(\"friendlyNameField\"), friendlyName != null ? friendlyName : \"\").sendKeys(Keys.ENTER);\n            return this;\n        }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * In some cases, Vaadin doesn't register our clicks,\n     * so this method keeps click until the given element\n     * is no longer found.\n     *\n     * @param by selector\n     */\n    private void clickElementUntilItDisappears(By by) {\n        try {\n            setImplicitWait(100, TimeUnit.MILLISECONDS);\n            wait.until(new ExpectedCondition<Boolean>() {\n                @Override\n                public Boolean apply(WebDriver driver) {\n                    try {\n                        driver.findElement(by).click();\n                        return false;\n                    } catch (NoSuchElementException e) {\n                        return true;\n                    }\n                }\n            });\n        } finally {\n            setImplicitWait();\n        }\n    }","id":88622,"modified_method":"/**\n     * In some cases, Vaadin doesn't register our clicks,\n     * so this method keeps click until the given element\n     * is no longer found.\n     *\n     * @param by selector\n     */\n    private void clickElementUntilItDisappears(By by) {\n        try {\n            setImplicitWait(100, TimeUnit.MILLISECONDS);\n            wait.until(new ExpectedCondition<Boolean>() {\n                @Override\n                public Boolean apply(WebDriver driver) {\n                    try {\n                        driver.findElement(by).click();\n                        return false;\n                    } catch (NoSuchElementException|StaleElementReferenceException e) {\n                        return true;\n                    }\n                }\n            });\n        } finally {\n            setImplicitWait();\n        }\n    }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageEditWindow name(String newName) {\n            WebElement nameField = findElementById(\"nameField\");\n            nameField.clear();\n            nameField.sendKeys(newName);\n            nameField.sendKeys(Keys.ENTER);\n            return new BsmAdminPageEditWindow(newName);\n        }","id":88623,"modified_method":"public BsmAdminPageEditWindow name(String newName) {\n            enterText(By.id(\"nameField\"), newName).sendKeys(Keys.ENTER);\n            return new BsmAdminPageEditWindow(newName);\n        }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageEditWindow openEditDialog(String businessServiceName) {\n            findElementById(\"editButton-\" + businessServiceName).click();\n            wait.until(pageContainsText(\"Business Service Edit\"));\n            return new BsmAdminPageEditWindow(businessServiceName);\n        }","id":88624,"modified_method":"public BsmAdminPageEditWindow openEditDialog(String businessServiceName) {\n            waitForElement(By.id(\"editButton-\" + businessServiceName)).click();\n            wait.until(pageContainsText(\"Business Service Edit\"));\n            return new BsmAdminPageEditWindow(businessServiceName);\n        }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Verifies that the provided element is not present.\n     * @param by\n     */\n    private void verifyElementNotPresent(final By by) {\n        new WebDriverWait(m_driver, 5 /* seconds */).until(\n                ExpectedConditions.not(new ExpectedCondition<Boolean>() {\n                    @Nullable\n                    @Override\n                    public Boolean apply(@Nullable WebDriver input) {\n                        try {\n                            // the default implicit wait timeout is too long, make it shorter\n                            input.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);\n                            WebElement elementFound = input.findElement(by);\n                            return elementFound != null;\n                        } catch (NoSuchElementException ex) {\n                            return false;\n                        } finally {\n                            // set the implicit wait timeout back to the value it has been before\n                            input.manage().timeouts().implicitlyWait(LOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n                        }\n                    }\n                })\n        );\n    }","id":88625,"modified_method":"/**\n     * Verifies that the provided element is not present.\n     * @param by\n     */\n    private void verifyElementNotPresent(final By by) {\n        new WebDriverWait(m_driver, 5 /* seconds */).until(\n                ExpectedConditions.not(new ExpectedCondition<Boolean>() {\n                    @Nullable\n                    @Override\n                    public Boolean apply(@Nullable WebDriver input) {\n                        try {\n                            // the default implicit wait timeout is too long, make it shorter\n                            input.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);\n                            WebElement elementFound = input.findElement(by);\n                            return elementFound != null;\n                        } catch (NoSuchElementException|StaleElementReferenceException ex) {\n                            return false;\n                        } finally {\n                            // set the implicit wait timeout back to the value it has been before\n                            input.manage().timeouts().implicitlyWait(LOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n                        }\n                    }\n                })\n        );\n    }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPage open() {\n            m_driver.get(getBsmBaseUrl());\n            switchToVaadinFrame();\n            return this;\n        }","id":88626,"modified_method":"public BsmAdminPage open() {\n            m_driver.get(getBsmBaseUrl());\n            try {\n\t\t\t\tThread.sleep(2000);\n            } catch (final InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n            switchToVaadinFrame();\n            return this;\n        }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public BsmAdminPageEdgeEditWindow reductionKey(String reductionKey) throws InterruptedException {\n            selectEdgeType(\"Reduction Key\");\n            enterText(By.id(\"reductionKeyField\"), reductionKey);\n            findElementById(\"reductionKeyField\").sendKeys(Keys.ENTER);\n            return this;\n        }","id":88627,"modified_method":"public BsmAdminPageEdgeEditWindow reductionKey(String reductionKey) throws InterruptedException {\n            selectEdgeType(\"Reduction Key\");\n            enterText(By.id(\"reductionKeyField\"), reductionKey).sendKeys(Keys.ENTER);\n            return this;\n        }","commit_id":"bafd4e6f250a7d91347b7f55ce8c0808da8fea59","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public JComponent createComponent() {\n    myMainPanel = new JPanel(new GridBagLayout());\n    myTemplateEditor = createEditor();\n    myNameField = new JTextField();\n    myExtensionField = new JTextField();\n    final Splitter splitter = new Splitter(true, 0.66f);\n\n    myDescriptionComponent = new JEditorPane(CONTENT_TYPE_HTML, EMPTY_HTML);\n    myDescriptionComponent.setEditable(false);\n//    myDescriptionComponent.setMargin(new Insets(2, 2, 2, 2));\n\n//    myDescriptionComponent = new JLabel();\n//    myDescriptionComponent.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n//    myDescriptionComponent.setVerticalAlignment(SwingConstants.TOP);\n\n    myAdjustBox = new JCheckBox(IdeBundle.message(\"checkbox.reformat.according.to.style\"));\n    myTopPanel = new JPanel(new GridBagLayout());\n\n    JPanel secondPanel = new JPanel(new GridBagLayout());\n    secondPanel.add(new JLabel(IdeBundle.message(\"label.description\")),\n                    new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                           new Insets(0, 0, 2, 0), 0, 0));\n    secondPanel.add(new JScrollPane(myDescriptionComponent),\n                    new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n\n    myMainPanel.add(myTopPanel,\n                    new GridBagConstraints(0, 0, 4, 1, 1.0, 0.0, GridBagConstraints.CENTER,\n                                           GridBagConstraints.HORIZONTAL, new Insets(0, 0, 2, 0), 0, 0));\n    myMainPanel.add(myAdjustBox,\n                    new GridBagConstraints(0, 1, 4, 1, 0.0, 0.0, GridBagConstraints.WEST,\n                                           GridBagConstraints.HORIZONTAL, new Insets(2, 0, 2, 0), 0, 0));\n    myMainPanel.add(splitter,\n                    new GridBagConstraints(0, 2, 4, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n    splitter.setFirstComponent(myTemplateEditor.getComponent());\n    splitter.setSecondComponent(secondPanel);\n    setShowInternalMessage(null);\n    myTemplateEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      public void documentChanged(DocumentEvent e) {\n        onTextChanged();\n      }\n    });\n    myNameField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    myExtensionField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    myMainPanel.setPreferredSize(new Dimension(400, 300));\n    return myMainPanel;\n  }","id":88628,"modified_method":"public JComponent createComponent() {\n    myMainPanel = new JPanel(new GridBagLayout());\n    myNameField = new JTextField();\n    myExtensionField = new JTextField();\n    mySplitter = new Splitter(true, 0.66f);\n\n    myTemplateEditor = createEditor();\n\n    myDescriptionComponent = new JEditorPane(CONTENT_TYPE_HTML, EMPTY_HTML);\n    myDescriptionComponent.setEditable(false);\n//    myDescriptionComponent.setMargin(new Insets(2, 2, 2, 2));\n\n//    myDescriptionComponent = new JLabel();\n//    myDescriptionComponent.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n//    myDescriptionComponent.setVerticalAlignment(SwingConstants.TOP);\n\n    myAdjustBox = new JCheckBox(IdeBundle.message(\"checkbox.reformat.according.to.style\"));\n    myTopPanel = new JPanel(new GridBagLayout());\n\n    JPanel secondPanel = new JPanel(new GridBagLayout());\n    secondPanel.add(new JLabel(IdeBundle.message(\"label.description\")),\n                    new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,\n                                           new Insets(0, 0, 2, 0), 0, 0));\n    secondPanel.add(new JScrollPane(myDescriptionComponent),\n                    new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n\n    myMainPanel.add(myTopPanel,\n                    new GridBagConstraints(0, 0, 4, 1, 1.0, 0.0, GridBagConstraints.CENTER,\n                                           GridBagConstraints.HORIZONTAL, new Insets(0, 0, 2, 0), 0, 0));\n    myMainPanel.add(myAdjustBox,\n                    new GridBagConstraints(0, 1, 4, 1, 0.0, 0.0, GridBagConstraints.WEST,\n                                           GridBagConstraints.HORIZONTAL, new Insets(2, 0, 2, 0), 0, 0));\n    myMainPanel.add(mySplitter,\n                    new GridBagConstraints(0, 2, 4, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,\n                                           new Insets(2, 0, 0, 0), 0, 0));\n\n    mySplitter.setSecondComponent(secondPanel);\n    setShowInternalMessage(null);\n\n    myNameField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    myExtensionField.addFocusListener(new FocusAdapter() {\n      public void focusLost(FocusEvent e) {\n        onNameChanged();\n      }\n    });\n    myMainPanel.setPreferredSize(new Dimension(400, 300));\n    return myMainPanel;\n  }","commit_id":"45730204129a88a91f2c9ce88ae5ee0c2c9a50fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disposeUIResources() {\n    myMainPanel = null;\n    if (myTemplateEditor != null) {\n      EditorFactory.getInstance().releaseEditor(myTemplateEditor);\n      myTemplateEditor = null;\n    }\n  }","id":88629,"modified_method":"public void disposeUIResources() {\n    myMainPanel = null;\n    if (myTemplateEditor != null) {\n      EditorFactory.getInstance().releaseEditor(myTemplateEditor);\n      myTemplateEditor = null;\n    }\n    myFile = null;\n  }","commit_id":"45730204129a88a91f2c9ce88ae5ee0c2c9a50fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    final String text = (myTemplate == null) ? \"\" : myTemplate.getText();\n    String name = (myTemplate == null) ? \"\" : myTemplate.getName();\n    String extension = (myTemplate == null) ? \"\" : myTemplate.getExtension();\n    String description = (myTemplate == null) ? \"\" : myTemplate.getDescription();\n\n    if ((description.length() == 0) && (myDefaultDescriptionUrl != null)) {\n      try {\n        VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(myDefaultDescriptionUrl);\n        if (file != null) {\n          description = VfsUtil.loadText(file);\n        }\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n    }\n    boolean adjust = (myTemplate != null) && myTemplate.isAdjust();\n    setHighlighter();\n    myNameField.setText(name);\n    myExtensionField.setText(extension);\n    myAdjustBox.setSelected(adjust);\n    String desc = description.length() > 0 ? description : EMPTY_HTML;\n\n    // [myakovlev] do not delete these stupid lines! Or you get Exception!\n    myDescriptionComponent.setContentType(CONTENT_TYPE_PLAIN);\n    myDescriptionComponent.setEditable(true);\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setContentType(CONTENT_TYPE_HTML);\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setCaretPosition(0);\n    myDescriptionComponent.setEditable(false);\n\n    CommandProcessor.getInstance().executeCommand(null, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            final Document document = myTemplateEditor.getDocument();\n            document.replaceString(0, document.getTextLength(), text);\n            UndoManager.getGlobalInstance().undoableActionPerformed(new NonUndoableAction() {\n              public DocumentReference[] getAffectedDocuments() {\n                return new DocumentReference[] {DocumentReferenceByDocument.createDocumentReference(document)};\n              }\n\n              public boolean isComplex() {\n                return false;\n              }\n            });\n          }\n        });\n      }\n    }, \"\", null);\n\n    myNameField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myExtensionField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myModified = false;\n  }","id":88630,"modified_method":"public void reset() {\n    final String text = (myTemplate == null) ? \"\" : myTemplate.getText();\n    String name = (myTemplate == null) ? \"\" : myTemplate.getName();\n    String extension = (myTemplate == null) ? \"\" : myTemplate.getExtension();\n    String description = (myTemplate == null) ? \"\" : myTemplate.getDescription();\n\n    if ((description.length() == 0) && (myDefaultDescriptionUrl != null)) {\n      try {\n        VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(myDefaultDescriptionUrl);\n        if (file != null) {\n          description = VfsUtil.loadText(file);\n        }\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n    }\n\n    EditorFactory.getInstance().releaseEditor(myTemplateEditor);\n    myFile = createFile(text, name);\n    myTemplateEditor = createEditor();\n\n    boolean adjust = (myTemplate != null) && myTemplate.isAdjust();\n    myNameField.setText(name);\n    myExtensionField.setText(extension);\n    myAdjustBox.setSelected(adjust);\n    String desc = description.length() > 0 ? description : EMPTY_HTML;\n\n    // [myakovlev] do not delete these stupid lines! Or you get Exception!\n    myDescriptionComponent.setContentType(CONTENT_TYPE_PLAIN);\n    myDescriptionComponent.setEditable(true);\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setContentType(CONTENT_TYPE_HTML);\n    myDescriptionComponent.setText(desc);\n    myDescriptionComponent.setCaretPosition(0);\n    myDescriptionComponent.setEditable(false);\n\n    myNameField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myExtensionField.setEditable((myTemplate != null) && (!myTemplate.isDefault()));\n    myModified = false;\n  }","commit_id":"45730204129a88a91f2c9ce88ae5ee0c2c9a50fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Editor createEditor() {\n    EditorFactory editorFactory = EditorFactory.getInstance();\n    Document doc = editorFactory.createDocument(\"\");\n    Editor editor = editorFactory.createEditor(doc);\n\n    EditorSettings editorSettings = editor.getSettings();\n    editorSettings.setVirtualSpace(false);\n    editorSettings.setLineMarkerAreaShown(false);\n    editorSettings.setLineNumbersShown(false);\n    editorSettings.setFoldingOutlineShown(false);\n    editorSettings.setAdditionalColumnsCount(3);\n    editorSettings.setAdditionalLinesCount(3);\n\n    EditorColorsScheme scheme = editor.getColorsScheme();\n    scheme.setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    return editor;\n  }","id":88631,"modified_method":"private Editor createEditor() {\n    EditorFactory editorFactory = EditorFactory.getInstance();\n    Document doc = myFile == null ? editorFactory.createDocument(myTemplate == null ? \"\" : myTemplate.getText()) : PsiDocumentManager.getInstance(myFile.getProject()).getDocument(myFile);\n    Editor editor = myProject == null ? editorFactory.createEditor(doc) : editorFactory.createEditor(doc, myProject);\n\n    EditorSettings editorSettings = editor.getSettings();\n    editorSettings.setVirtualSpace(false);\n    editorSettings.setLineMarkerAreaShown(false);\n    editorSettings.setLineNumbersShown(false);\n    editorSettings.setFoldingOutlineShown(false);\n    editorSettings.setAdditionalColumnsCount(3);\n    editorSettings.setAdditionalLinesCount(3);\n\n    EditorColorsScheme scheme = editor.getColorsScheme();\n    scheme.setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.getDocument().addDocumentListener(new DocumentAdapter() {\n      public void documentChanged(DocumentEvent e) {\n        onTextChanged();\n      }\n    });\n\n    ((EditorEx)editor).setHighlighter(createHighlighter());\n    mySplitter.setFirstComponent(editor.getComponent());\n    return editor;\n  }","commit_id":"45730204129a88a91f2c9ce88ae5ee0c2c9a50fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setHighlighter() {\n    FileType fileType;\n    if (myTemplate != null) {\n      String extension = myTemplate.getExtension();\n      fileType = FileTypeManager.getInstance().getFileTypeByExtension(extension);\n    }\n    else {\n      fileType = FileTypes.PLAIN_TEXT;\n    }\n\n    SyntaxHighlighter originalHighlighter = SyntaxHighlighter.PROVIDER.create(fileType, null, null);\n    if (originalHighlighter == null) originalHighlighter = new PlainSyntaxHighlighter();\n    EditorHighlighter highlighter = new LexerEditorHighlighter(new TemplateHighlighter(originalHighlighter), EditorColorsManager.getInstance().getGlobalScheme());\n    ((EditorEx)myTemplateEditor).setHighlighter(highlighter);\n    ((EditorEx)myTemplateEditor).repaint(0, myTemplateEditor.getDocument().getTextLength());\n  }","id":88632,"modified_method":"private EditorHighlighter createHighlighter() {\n    if (myTemplate != null && myProject != null) {\n      return EditorHighlighterFactory.getInstance().createEditorHighlighter(myProject, new LightVirtualFile(\"aaa.\" + myTemplate.getExtension() + \".ft\"));\n    }\n    else {\n      FileType fileType = null;\n      if (myTemplate != null) {\n        fileType = FileTypeManager.getInstance().getFileTypeByExtension(myTemplate.getExtension());\n      }\n      if (fileType == null) {\n        fileType = FileTypes.PLAIN_TEXT;\n      }\n      SyntaxHighlighter originalHighlighter = SyntaxHighlighter.PROVIDER.create(fileType, null, null);\n      if (originalHighlighter == null) originalHighlighter = new PlainSyntaxHighlighter();\n      return new LexerEditorHighlighter(new TemplateHighlighter(originalHighlighter), EditorColorsManager.getInstance().getGlobalScheme());\n    }\n  }","commit_id":"45730204129a88a91f2c9ce88ae5ee0c2c9a50fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doShow(boolean navigate) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n\n    removeHighlighter();\n\n\n    OpenFileDescriptor fileDescriptor = myOpenFileDescriptor;\n    if (!navigate && myOpenFileDescriptor != null) {\n      fileDescriptor = new OpenFileDescriptor(myProject, myOpenFileDescriptor.getFile());\n    }\n    myEditor = fileDescriptor == null ? null : XDebuggerUtilImpl.createEditor(fileDescriptor);\n    if (myEditor != null) {\n      addHighlighter();\n    }\n  }","id":88633,"modified_method":"private void doShow(boolean navigate) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n\n    removeHighlighter();\n\n\n    OpenFileDescriptor fileDescriptor = myOpenFileDescriptor;\n    if (!navigate && myOpenFileDescriptor != null) {\n      fileDescriptor = new OpenFileDescriptor(myProject, myOpenFileDescriptor.getFile());\n    }\n    myEditor = null;\n    if (fileDescriptor != null) {\n      if (!navigate) {\n        FileEditor editor = FileEditorManager.getInstance(fileDescriptor.getProject()).getSelectedEditor(fileDescriptor.getFile());\n        if (editor instanceof TextEditor) {\n          myEditor = ((TextEditor)editor).getEditor();\n        }\n      }\n      if (myEditor == null) {\n        myEditor = XDebuggerUtilImpl.createEditor(fileDescriptor);\n      }\n    }\n    if (myEditor != null) {\n      addHighlighter();\n    }\n  }","commit_id":"8657475ff0de4dc5ec672c424af1a56c817c27f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doShow() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    removeHighlighter();\n\n    myEditor = XDebuggerUtilImpl.createEditor(myOpenFileDescriptor);\n    if (myEditor != null) {\n      addHighlighter();\n    }\n  }","id":88634,"modified_method":"private void doShow() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    removeHighlighter();\n\n    myEditor = myOpenFileDescriptor == null ? null : XDebuggerUtilImpl.createEditor(myOpenFileDescriptor);\n    if (myEditor != null) {\n      addHighlighter();\n    }\n  }","commit_id":"7c0dece7a7e24f72149143b43ee3d98378cd0ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void hide() {\n    AppUIUtil.invokeOnEdt(new Runnable() {\n      @Override\n      public void run() {\n        doHide();\n      }\n    });\n  }","id":88635,"modified_method":"public void hide() {\n    AppUIUtil.invokeOnEdt(new Runnable() {\n      @Override\n      public void run() {\n        updateRequested.set(false);\n\n        removeHighlighter();\n        myOpenFileDescriptor = null;\n        myEditor = null;\n        myGutterIconRenderer = null;\n      }\n    });\n  }","commit_id":"7c0dece7a7e24f72149143b43ee3d98378cd0ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void show(final @NotNull XSourcePosition position, final boolean useSelection,\n                   @Nullable final GutterIconRenderer gutterIconRenderer) {\n    updateRequested.set(false);\n    AppUIUtil.invokeLaterIfProjectAlive(myProject, new Runnable() {\n      @Override\n      public void run() {\n        mySourcePosition = position;\n\n        myOpenFileDescriptor = XSourcePositionImpl.createOpenFileDescriptor(myProject, position);\n        myOpenFileDescriptor.setUseCurrentWindow(true);\n\n        myGutterIconRenderer = gutterIconRenderer;\n        myUseSelection = useSelection;\n\n        doShow();\n      }\n    });\n  }","id":88636,"modified_method":"public void show(final @NotNull XSourcePosition position, final boolean useSelection,\n                   @Nullable final GutterIconRenderer gutterIconRenderer) {\n    updateRequested.set(false);\n    AppUIUtil.invokeLaterIfProjectAlive(myProject, new Runnable() {\n      @Override\n      public void run() {\n        updateRequested.set(false);\n\n        mySourcePosition = position;\n\n        myOpenFileDescriptor = XSourcePositionImpl.createOpenFileDescriptor(myProject, position);\n        myOpenFileDescriptor.setUseCurrentWindow(true);\n\n        myGutterIconRenderer = gutterIconRenderer;\n        myUseSelection = useSelection;\n\n        doShow();\n      }\n    });\n  }","commit_id":"7c0dece7a7e24f72149143b43ee3d98378cd0ec8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected long create(\n\t\t\tStorageAdapter storageAdapter, long ddmStructureId, Fields fields)\n\t\tthrows Exception {\n\n\t\treturn storageAdapter.create(\n\t\t\tTestPropsValues.getCompanyId(), ddmStructureId, fields,\n\t\t\tServiceContextTestUtil.getServiceContext(group.getGroupId()));\n\t}","id":88637,"modified_method":"protected long create(\n\t\t\tStorageAdapter storageAdapter, long ddmStructureId, Fields fields)\n\t\tthrows Exception {\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tddmStructureId);\n\n\t\tDDMFormValues ddmFormValues =\n\t\t\tFieldsToDDMFormValuesConverterUtil.convert(ddmStructure, fields);\n\n\t\treturn storageAdapter.create(\n\t\t\tTestPropsValues.getCompanyId(), ddmStructureId, ddmFormValues,\n\t\t\tServiceContextTestUtil.getServiceContext(group.getGroupId()));\n\t}","commit_id":"4f6a673ea3abc90f596a65c5188738b7e2db61ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validate(long ddmStructureId, Fields fields)\n\t\tthrows Exception {\n\n\t\tJSONSerializer jsonSerializer = JSONFactoryUtil.createJSONSerializer();\n\n\t\tString expectedFieldsString = jsonSerializer.serializeDeep(fields);\n\n\t\tlong classPK = create(_jsonStorageAdapater, ddmStructureId, fields);\n\n\t\tFields actualFields = _jsonStorageAdapater.getFields(classPK);\n\n\t\tAssert.assertEquals(\n\t\t\texpectedFieldsString, jsonSerializer.serializeDeep(actualFields));\n\t}","id":88638,"modified_method":"protected void validate(long ddmStructureId, Fields fields)\n\t\tthrows Exception {\n\n\t\tJSONSerializer jsonSerializer = JSONFactoryUtil.createJSONSerializer();\n\n\t\tString expectedFieldsString = jsonSerializer.serializeDeep(fields);\n\n\t\tlong classPK = create(_jsonStorageAdapater, ddmStructureId, fields);\n\n\t\tDDMStructure ddmStructure = DDMStructureLocalServiceUtil.getStructure(\n\t\t\tddmStructureId);\n\n\t\tDDMFormValues actualDDMFormValues =\n\t\t\t_jsonStorageAdapater.getDDMFormValues(classPK);\n\n\t\tFields actualFields = DDMFormValuesToFieldsConverterUtil.convert(\n\t\t\tddmStructure, actualDDMFormValues);\n\n\t\tAssert.assertEquals(\n\t\t\texpectedFieldsString, jsonSerializer.serializeDeep(actualFields));\n\t}","commit_id":"4f6a673ea3abc90f596a65c5188738b7e2db61ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void update() {\n\t\ttry {\n\t\t\t_storageEngine.update(\n\t\t\t\t_dlFileEntryMetadata.getDDMStorageId(), _fields,\n\t\t\t\tnew ServiceContext());\n\t\t}\n\t\tcatch (StorageException se) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to update DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tse);\n\t\t}\n\t}","id":88639,"modified_method":"public void update() {\n\t\ttry {\n\t\t\tDDMFormValues ddmFormValues = toDDMFormValues(_fields);\n\n\t\t\t_storageEngine.update(\n\t\t\t\t_dlFileEntryMetadata.getDDMStorageId(), ddmFormValues,\n\t\t\t\tnew ServiceContext());\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to update DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","commit_id":"5b8445eef7ecf283b87f3f5d631843dec8f43cd8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initDLFileEntryMetadataAndFields() {\n\t\tif (_fieldsMap != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_dlFileVersion == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t_fieldsMap = new HashMap<>();\n\n\t\ttry {\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\t_dlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\t_ddmStructure.getStructureId(),\n\t\t\t\t\t_dlFileVersion.getFileVersionId());\n\t\t}\n\t\tcatch (NoSuchFileEntryMetadataException nsfeme) {\n\t\t\taddGoogleDocsDLFileEntryMetadata();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to load file entry metadata for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\n\t\ttry {\n\t\t\t_fields = _storageEngine.getFields(\n\t\t\t\t_dlFileEntryMetadata.getDDMStorageId());\n\n\t\t\tfor (Field field : _fields) {\n\t\t\t\t_fieldsMap.put(field.getName(), field);\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to load DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","id":88640,"modified_method":"protected void initDLFileEntryMetadataAndFields() {\n\t\tif (_fieldsMap != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_dlFileVersion == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t_fieldsMap = new HashMap<>();\n\n\t\ttry {\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\t_dlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\t_ddmStructure.getStructureId(),\n\t\t\t\t\t_dlFileVersion.getFileVersionId());\n\t\t}\n\t\tcatch (NoSuchFileEntryMetadataException nsfeme) {\n\t\t\taddGoogleDocsDLFileEntryMetadata();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to load file entry metadata for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\n\t\ttry {\n\t\t\tDDMFormValues ddmFormValues = _storageEngine.getDDMFormValues(\n\t\t\t\t_dlFileEntryMetadata.getDDMStorageId());\n\n\t\t\t_fields = DDMFormValuesToFieldsConverterUtil.convert(\n\t\t\t\t_ddmStructure, ddmFormValues);\n\n\t\t\tfor (Field field : _fields) {\n\t\t\t\t_fieldsMap.put(field.getName(), field);\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to load DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","commit_id":"5b8445eef7ecf283b87f3f5d631843dec8f43cd8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addGoogleDocsDLFileEntryMetadata() {\n\t\ttry {\n\t\t\tDLFileEntry dlFileEntry = _dlFileVersion.getFileEntry();\n\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\t_dlFileEntryMetadataLocalService.createDLFileEntryMetadata(\n\t\t\t\t\tCounterLocalServiceUtil.increment());\n\n\t\t\tlong ddmStructureId = _ddmStructure.getStructureId();\n\n\t\t\tFields fields = new Fields();\n\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId,\n\t\t\t\t\tGoogleDocsConstants.DDM_FIELD_NAME_DESCRIPTION, \"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId,\n\t\t\t\t\tGoogleDocsConstants.DDM_FIELD_NAME_EMBEDDABLE_URL, \"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_ICON_URL,\n\t\t\t\t\t\"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_ID, \"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_NAME,\n\t\t\t\t\t\"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_URL,\n\t\t\t\t\t\"\"));\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setScopeGroupId(_dlFileVersion.getGroupId());\n\t\t\tserviceContext.setUserId(_dlFileVersion.getUserId());\n\n\t\t\tlong ddmStorageId = _storageEngine.create(\n\t\t\t\t_dlFileVersion.getCompanyId(), ddmStructureId, fields,\n\t\t\t\tserviceContext);\n\n\t\t\t_dlFileEntryMetadata.setDDMStorageId(ddmStorageId);\n\t\t\t_dlFileEntryMetadata.setDDMStructureId(ddmStructureId);\n\t\t\t_dlFileEntryMetadata.setFileEntryTypeId(\n\t\t\t\tdlFileEntry.getFileEntryTypeId());\n\t\t\t_dlFileEntryMetadata.setFileEntryId(dlFileEntry.getFileEntryId());\n\t\t\t_dlFileEntryMetadata.setFileVersionId(\n\t\t\t\t_dlFileVersion.getFileVersionId());\n\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\t_dlFileEntryMetadataLocalService.addDLFileEntryMetadata(\n\t\t\t\t\t_dlFileEntryMetadata);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to add DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","id":88641,"modified_method":"protected void addGoogleDocsDLFileEntryMetadata() {\n\t\ttry {\n\t\t\tDLFileEntry dlFileEntry = _dlFileVersion.getFileEntry();\n\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\t_dlFileEntryMetadataLocalService.createDLFileEntryMetadata(\n\t\t\t\t\tCounterLocalServiceUtil.increment());\n\n\t\t\tlong ddmStructureId = _ddmStructure.getStructureId();\n\n\t\t\tFields fields = new Fields();\n\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId,\n\t\t\t\t\tGoogleDocsConstants.DDM_FIELD_NAME_DESCRIPTION, \"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId,\n\t\t\t\t\tGoogleDocsConstants.DDM_FIELD_NAME_EMBEDDABLE_URL, \"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_ICON_URL,\n\t\t\t\t\t\"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_ID, \"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_NAME,\n\t\t\t\t\t\"\"));\n\t\t\tfields.put(\n\t\t\t\tnew Field(\n\t\t\t\t\tddmStructureId, GoogleDocsConstants.DDM_FIELD_NAME_URL,\n\t\t\t\t\t\"\"));\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setScopeGroupId(_dlFileVersion.getGroupId());\n\t\t\tserviceContext.setUserId(_dlFileVersion.getUserId());\n\n\t\t\tDDMFormValues ddmFormValues = toDDMFormValues(fields);\n\n\t\t\tlong ddmStorageId = _storageEngine.create(\n\t\t\t\t_dlFileVersion.getCompanyId(), ddmStructureId, ddmFormValues,\n\t\t\t\tserviceContext);\n\n\t\t\t_dlFileEntryMetadata.setDDMStorageId(ddmStorageId);\n\t\t\t_dlFileEntryMetadata.setDDMStructureId(ddmStructureId);\n\t\t\t_dlFileEntryMetadata.setFileEntryTypeId(\n\t\t\t\tdlFileEntry.getFileEntryTypeId());\n\t\t\t_dlFileEntryMetadata.setFileEntryId(dlFileEntry.getFileEntryId());\n\t\t\t_dlFileEntryMetadata.setFileVersionId(\n\t\t\t\t_dlFileVersion.getFileVersionId());\n\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\t_dlFileEntryMetadataLocalService.addDLFileEntryMetadata(\n\t\t\t\t\t_dlFileEntryMetadata);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to add DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","commit_id":"5b8445eef7ecf283b87f3f5d631843dec8f43cd8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initDLFileEntryMetadataAndFields() {\n\t\tif (_fields != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_dlFileVersion == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t_fields = new HashMap<>();\n\n\t\ttry {\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\tDLFileEntryMetadataLocalServiceUtil.getFileEntryMetadata(\n\t\t\t\t\t_ddmStructure.getStructureId(),\n\t\t\t\t\t_dlFileVersion.getFileVersionId());\n\n\t\t\tFields fields = _storageEngine.getFields(\n\t\t\t\t_dlFileEntryMetadata.getDDMStorageId());\n\n\t\t\tfor (Field field : fields) {\n\t\t\t\t_fields.put(field.getName(), field);\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to load DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","id":88642,"modified_method":"protected void initDLFileEntryMetadataAndFields() {\n\t\tif (_fields != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_dlFileVersion == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t_fields = new HashMap<>();\n\n\t\ttry {\n\t\t\t_dlFileEntryMetadata =\n\t\t\t\tDLFileEntryMetadataLocalServiceUtil.getFileEntryMetadata(\n\t\t\t\t\t_ddmStructure.getStructureId(),\n\t\t\t\t\t_dlFileVersion.getFileVersionId());\n\n\t\t\tDDMFormValues ddmFormValues = _storageEngine.getDDMFormValues(\n\t\t\t\t_dlFileEntryMetadata.getDDMStorageId());\n\n\t\t\tFields fields = DDMFormValuesToFieldsConverterUtil.convert(\n\t\t\t\t_ddmStructure, ddmFormValues);\n\n\t\t\tfor (Field field : fields) {\n\t\t\t\t_fields.put(field.getName(), field);\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"Unable to load DDM fields for file version \" +\n\t\t\t\t\t_dlFileVersion.getFileVersionId(),\n\t\t\t\tpe);\n\t\t}\n\t}","commit_id":"5b8445eef7ecf283b87f3f5d631843dec8f43cd8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void run() {\n\n        if (theType == NBINVENTORY){\n            log().debug(\"InventoryService runNodeBaseInventoryReport Date [\"+ theDate +\"] key [\" + theField + \"]\"); \n            boolean withKey = false;\n            if (theField.compareTo(\"\")!=0){\n                withKey = true;\n            }\n            try {            \n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = format.parse(theDate);\n                log().debug(\"InventoryService runNodeBaseInventoryReport date[\" + tmp_date.toString() + \"]\"); \n\n                RwsNbinventoryreport rnbi = new RwsNbinventoryreport();\n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    GroupSet groupSet = new GroupSet(); \n                    boolean groupIsEmpty = true;\n                    boolean groupIsIncremented = false;\n                    log().debug(\"InventoryService runNodeBaseInventoryReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n                    while (iterDevice.hasNext()){\n                        groupIsEmpty = false;\n                        if (!groupIsIncremented){\n                            totalGroups++;\n                            groupIsIncremented = true;\n                        }\n                        String deviceName = iterDevice.next();\n                        totalNodes++;\n                        log().debug(\"InventoryService runNodeBaseInventoryReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                InventoryNode invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runNodeBaseInventoryReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runNodeBaseInventoryReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            if (!withKey){\n                            //                                Nbisinglenode nbisn = new Nbisinglenode();\n                            //                                nbisn.setDevicename(deviceName);\n                            //                                nbisn.setGroupname(groupName);\n                            //                                nbisn.setComment(\"No inventory associated\");\n                            //                                groupSet.addNbisinglenode(nbisn);\n                            //                            }\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n\n                        //we have groupname devicename and version\n\n                        try {\n                            NodeBaseInventory nodeBaseInv = getNodeBaseInventory(cProperties, deviceName, groupName, versionMatch);\n\n                            //marshall xml and save to disk\n                            log().debug(\"InventoryService runNodeBaseInventoryReport MARSHALL [\" + deviceName + \"] group [\"+groupName+\"] Version [\"+ versionMatch +\"]\"); \n                            log().debug(\"InventoryService runNodeBaseInventoryReport data [\" + nodeBaseInv.expand()); \n\n\n\n                            Nbisinglenode nbisn = new Nbisinglenode();\n                            boolean includeNbisn = false;\n\n\n                            nbisn.setConfigurationurl(nodeBaseInv.getConfigurationurl());\n                            nbisn.setCreationdate(nodeBaseInv.getCreationdate());\n                            nbisn.setDevicename(nodeBaseInv.getDevicename());\n                            nbisn.setGroupname(nodeBaseInv.getGroupname());\n                            nbisn.setStatus(nodeBaseInv.getStatus());\n                            nbisn.setSwconfigurationurl(nodeBaseInv.getSwconfigurationurl());\n                            nbisn.setVersion(nodeBaseInv.getVersion());\n\n                            List<InventoryElement2RP> ie2rpList = new ArrayList<InventoryElement2RP>();\n                            Iterator<InventoryElement2> ie2rpIter = nodeBaseInv.getIe().iterator();\n\n                            while (ie2rpIter.hasNext()){\n\n                                InventoryElement2RP ie2rp = new InventoryElement2RP();\n\n                                InventoryElement2 ie2 = ie2rpIter.next();\n                                Iterator<Tuple> iterTuple = ie2.getTupleList().iterator();\n                                Iterator<InventoryMemory> iterMemory = ie2.getMemoryList().iterator();\n                                Iterator<InventorySoftware> iterSoftware = ie2.getSoftwareList().iterator();\n\n                                while (iterTuple.hasNext()){\n                                    TupleRP tmp2 = new TupleRP();\n                                    Tuple tmp1 = iterTuple.next();\n                                    tmp2.setName(tmp1.getName());\n                                    //filter here\n                                    if (withKey && tmp1.getDescription().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp2.setDescription(tmp1.getDescription());\n                                    ie2rp.addTupleRP(tmp2);\n                                }\n\n                                while (iterMemory.hasNext()){\n                                    InventoryMemoryRP tmp3 = new InventoryMemoryRP();\n                                    InventoryMemory tmp1 = iterMemory.next();\n                                    //filter here\n                                    if (withKey && tmp1.getSize().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setSize(tmp1.getSize());\n                                    if (withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setType(tmp1.getType());\n                                    ie2rp.addInventoryMemoryRP(tmp3);\n                                }\n                                while (iterSoftware.hasNext()){\n                                    InventorySoftwareRP tmp4 = new InventorySoftwareRP();\n                                    InventorySoftware tmp1 = iterSoftware.next();\n                                    //filter here\n                                    if(withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setType(tmp1.getType());\n                                    if(withKey && tmp1.getVersion().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setVersion(tmp1.getVersion());\n\n                                    ie2rp.addInventorySoftwareRP(tmp4);\n                                }\n\n                                ie2rpList.add(ie2rp);\n\n                            }\n                            nbisn.setInventoryElement2RP(ie2rpList);\n                            // if withKey is false then include it in any case\n                            // includeNbsin is true the fiels has been found\n                            // data must be included\n                            if(!withKey || includeNbisn){\n                                groupSet.addNbisinglenode(nbisn);\n                            }\n                            //else skip \n                        }catch (Exception e){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has inventory errors [\"+deviceName+ \"]\"); \n                            continue;\n\n                        }\n                        groupSet.setTotalNodes(totalNodes);\n                    }\n                    rnbi.addGroupSet(groupSet);\n                    rnbi.setTotalGroups(totalGroups);\n                    rnbi.setDateInventory(theDate);\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport object filled\");\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".xml\";\n\n                // Generate source XML\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rnbi);\n                writer.close();\n                log().debug(\"runNodeBaseInventoryReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runNodeBaseInventoryReport generating pdf is still not supported :( \");\n\n                } else {\n\n                    log().debug(\"runNodeBaseInventoryReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-nbinventoryreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runNodeBaseInventoryReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n            }\n            catch (Exception e){\n                log().debug(\"InventoryService runNodeBaseInventoryReport exception \"+ e.getMessage() );\n            }\n\n        }\n        else if (theType == RANCIDLIST){\n            RwsRancidlistreport rlist = new RwsRancidlistreport();\n\n            try {\n\n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = format.parse(theDate);\n                log().debug(\"InventoryService runRacidListReport date[\" + tmp_date.toString() + \"]\"); \n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    log().debug(\"InventoryService runRacidListReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n\n                    GroupXSet gs = new GroupXSet();\n                    boolean groupHasDevices = false;\n                    boolean groupTotalIncremented = false;\n\n                    while (iterDevice.hasNext()){\n                        String deviceName = iterDevice.next();\n                        //totalNodes++;\n                        log().debug(\"InventoryService runRacidListReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            InventoryNode invNode = new InventoryNode(rancidNode);\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runRacidListReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runRacidListReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runRacidListReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            } else{\n                                NodeSet ns = new NodeSet();\n                                ns.setDevicename(deviceName);\n                                ns.setGroupname(groupName);\n                                ns.setVersion(versionMatch);\n                                ns.setConfigurationurl(invNode.getConfigurationUrl());\n                                ns.setSwconfigurationurl(invNode.getSoftwareImageUrl());\n                                ns.setStatus(rancidNode.getState());\n\n                                gs.addNodeSet(ns);\n\n                                groupHasDevices = true;\n                                if (!groupTotalIncremented){\n                                    totalGroups++;\n                                    groupTotalIncremented = true;\n                                }\n                                totalNodes ++;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runRacidListReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            Nbisinglenode nbisn = new Nbisinglenode();\n                            //                            nbisn.setDevicename(deviceName);\n                            //                            nbisn.setGroupname(groupName);\n                            //                            nbisn.setComment(\"No inventory associated\");\n                            //                            groupSet.addNbisinglenode(nbisn);\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n                    }\n                    if (groupHasDevices){\n                        gs.setTotalNodes(totalNodes);\n                        rlist.addGroupXSet(gs);\n                    }\n                }\n                rlist.setTotalGroups(totalGroups);\n                // Generate source XML\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".xml\";\n\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rlist);\n                writer.close();\n                log().debug(\"runRancidListReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runRancidListReport generating pdf is still not supported :( \");\n\n                    //                        String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n                    //                        \n                    //                        File file = new File(htmlFileName);\n                    //                        FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    //                        PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    //                        File fileR = new File(xmlFileName);\n                    //                        FileReader fileReader = new FileReader(fileR);\n                    //                        //htmlWriter.generatePDF(fileReader, hmtlFileWriter, ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".fot\");\n                    //                        htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    //\n                    //                        org.apache.fop.apps.Driver m_driver;\n                    //                        \n                    //                        Reader reader = new FileReader(fileR);\n                    //                        InputSource dataSource = new InputSource(reader);\n                    //                        \n                    //                        String pdfFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".pdf\";\n                    //\n                    //                        File fileP = new File(pdfFileName);\n                    //                        FileOutputStream pdfFileWriter = new FileOutputStream(fileP);\n                    //\n                    //                        m_driver = new org.apache.fop.apps.Driver(dataSource, pdfFileWriter);\n                    //                        m_driver.setRenderer(org.apache.fop.apps.Driver.RENDER_PDF);\n                    //                        m_driver.run();\n                    //\n                    //                        log().debug(\"runRancidListReport html done\");\n\n                } else {\n\n                    log().debug(\"runRancidListReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runRancidListReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n\n\n            }\n            catch (Exception e) {\n                log().debug(\"InventoryService runRancidListReport has given exception \"+ e.getMessage() );\n                //\n            }\n        }\n    }","id":88643,"modified_method":"public void run() {\n\n        if (theType == NBINVENTORY){\n            log().debug(\"InventoryService runNodeBaseInventoryReport Date [\"+ theDate +\"] key [\" + theField + \"]\"); \n            boolean withKey = false;\n            if (theField.compareTo(\"\")!=0){\n                withKey = true;\n            }\n            try {            \n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = new Date();\n                try {\n                    tmp_date = format.parse(theDate);\n                }\n                catch (ParseException pe){\n                    tmp_date = Calendar.getInstance().getTime();\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport date[\" + tmp_date.toString() + \"]\"); \n\n                RwsNbinventoryreport rnbi = new RwsNbinventoryreport();\n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    GroupSet groupSet = new GroupSet(); \n                    boolean groupIsEmpty = true;\n                    boolean groupIsIncremented = false;\n                    log().debug(\"InventoryService runNodeBaseInventoryReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n                    while (iterDevice.hasNext()){\n                        //groupIsEmpty = false;\n                        if (!groupIsIncremented){\n                            totalGroups++;\n                            groupIsIncremented = true;\n                        }\n                        String deviceName = iterDevice.next();\n                        log().debug(\"InventoryService runNodeBaseInventoryReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                InventoryNode invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runNodeBaseInventoryReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runNodeBaseInventoryReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            if (!withKey){\n                            //                                Nbisinglenode nbisn = new Nbisinglenode();\n                            //                                nbisn.setDevicename(deviceName);\n                            //                                nbisn.setGroupname(groupName);\n                            //                                nbisn.setComment(\"No inventory associated\");\n                            //                                groupSet.addNbisinglenode(nbisn);\n                            //                            }\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n\n                        //we have groupname devicename and version\n\n                        try {\n                            NodeBaseInventory nodeBaseInv = getNodeBaseInventory(cProperties, deviceName, groupName, versionMatch);\n\n                            //marshall xml and save to disk\n                            log().debug(\"InventoryService runNodeBaseInventoryReport MARSHALL [\" + deviceName + \"] group [\"+groupName+\"] Version [\"+ versionMatch +\"]\"); \n                            log().debug(\"InventoryService runNodeBaseInventoryReport data [\" + nodeBaseInv.expand()); \n\n\n\n                            Nbisinglenode nbisn = new Nbisinglenode();\n                            boolean includeNbisn = false;\n\n\n                            nbisn.setConfigurationurl(nodeBaseInv.getConfigurationurl());\n                            nbisn.setCreationdate(nodeBaseInv.getCreationdate());\n                            nbisn.setDevicename(nodeBaseInv.getDevicename());\n                            nbisn.setGroupname(nodeBaseInv.getGroupname());\n                            nbisn.setStatus(nodeBaseInv.getStatus());\n                            nbisn.setSwconfigurationurl(nodeBaseInv.getSwconfigurationurl());\n                            nbisn.setVersion(nodeBaseInv.getVersion());\n\n                            List<InventoryElement2RP> ie2rpList = new ArrayList<InventoryElement2RP>();\n                            Iterator<InventoryElement2> ie2rpIter = nodeBaseInv.getIe().iterator();\n\n                            while (ie2rpIter.hasNext()){\n\n                                InventoryElement2RP ie2rp = new InventoryElement2RP();\n\n                                InventoryElement2 ie2 = ie2rpIter.next();\n                                Iterator<Tuple> iterTuple = ie2.getTupleList().iterator();\n                                Iterator<InventoryMemory> iterMemory = ie2.getMemoryList().iterator();\n                                Iterator<InventorySoftware> iterSoftware = ie2.getSoftwareList().iterator();\n\n                                while (iterTuple.hasNext()){\n                                    TupleRP tmp2 = new TupleRP();\n                                    Tuple tmp1 = iterTuple.next();\n                                    tmp2.setName(tmp1.getName());\n                                    //filter here\n                                    if (withKey && tmp1.getDescription().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp2.setDescription(tmp1.getDescription());\n                                    ie2rp.addTupleRP(tmp2);\n                                }\n\n                                while (iterMemory.hasNext()){\n                                    InventoryMemoryRP tmp3 = new InventoryMemoryRP();\n                                    InventoryMemory tmp1 = iterMemory.next();\n                                    //filter here\n                                    if (withKey && tmp1.getSize().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setSize(tmp1.getSize());\n                                    if (withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setType(tmp1.getType());\n                                    ie2rp.addInventoryMemoryRP(tmp3);\n                                }\n                                while (iterSoftware.hasNext()){\n                                    InventorySoftwareRP tmp4 = new InventorySoftwareRP();\n                                    InventorySoftware tmp1 = iterSoftware.next();\n                                    //filter here\n                                    if(withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setType(tmp1.getType());\n                                    if(withKey && tmp1.getVersion().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setVersion(tmp1.getVersion());\n\n                                    ie2rp.addInventorySoftwareRP(tmp4);\n                                }\n\n                                ie2rpList.add(ie2rp);\n\n                            }\n                            nbisn.setInventoryElement2RP(ie2rpList);\n                            // if withKey is false then include it in any case\n                            // includeNbsin is true the fiels has been found\n                            // data must be included\n                            if(!withKey || includeNbisn){\n                                groupIsEmpty = false;\n                                totalNodes++;\n                                groupSet.addNbisinglenode(nbisn);\n                            }\n                            //else skip \n                        }catch (Exception e){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has inventory errors [\"+deviceName+ \"]\"); \n                            continue;\n\n                        }\n                        if (!groupIsEmpty){\n                            groupSet.setTotalNodes(totalNodes);\n                        }\n                    }\n                    rnbi.addGroupSet(groupSet);\n                    rnbi.setTotalGroups(totalGroups);\n                    rnbi.setDateInventory(format.format(tmp_date));\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport object filled\");\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".xml\";\n\n                // Generate source XML\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rnbi);\n                writer.close();\n                log().debug(\"runNodeBaseInventoryReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runNodeBaseInventoryReport generating pdf is still not supported :( sending xml\");\n                    log().debug(\"runNodeBaseInventoryReport xml sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,xmlFileName);\n                    mailer.send();\n\n\n                } else {\n\n                    log().debug(\"runNodeBaseInventoryReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-nbinventoryreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runNodeBaseInventoryReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n            }\n            catch (Exception e){\n                log().debug(\"InventoryService runNodeBaseInventoryReport exception \"+ e.getMessage() );\n            }\n\n        }\n        else if (theType == RANCIDLIST){\n            RwsRancidlistreport rlist = new RwsRancidlistreport();\n\n            try {\n\n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = new Date();\n                try {\n                    tmp_date = format.parse(theDate);\n                }\n                catch (ParseException pe){\n                    tmp_date = Calendar.getInstance().getTime();\n                }\n                log().debug(\"InventoryService runRacidListReport date[\" + tmp_date.toString() + \"]\"); \n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    log().debug(\"InventoryService runRacidListReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n\n                    GroupXSet gs = new GroupXSet();\n                    boolean groupHasDevices = false;\n                    boolean groupTotalIncremented = false;\n\n                    while (iterDevice.hasNext()){\n                        String deviceName = iterDevice.next();\n                        //totalNodes++;\n                        log().debug(\"InventoryService runRacidListReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            InventoryNode invNode = new InventoryNode(rancidNode);\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runRacidListReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runRacidListReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runRacidListReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            } else{\n                                NodeSet ns = new NodeSet();\n                                ns.setDevicename(deviceName);\n                                ns.setGroupname(groupName);\n                                ns.setVersion(versionMatch);\n                                ns.setConfigurationurl(invNode.getConfigurationUrl());\n                                ns.setSwconfigurationurl(invNode.getSoftwareImageUrl());\n                                ns.setStatus(rancidNode.getState());\n\n                                gs.addNodeSet(ns);\n\n                                groupHasDevices = true;\n                                if (!groupTotalIncremented){\n                                    totalGroups++;\n                                    groupTotalIncremented = true;\n                                }\n                                totalNodes ++;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runRacidListReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            Nbisinglenode nbisn = new Nbisinglenode();\n                            //                            nbisn.setDevicename(deviceName);\n                            //                            nbisn.setGroupname(groupName);\n                            //                            nbisn.setComment(\"No inventory associated\");\n                            //                            groupSet.addNbisinglenode(nbisn);\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n                    }\n                    if (groupHasDevices){\n                        gs.setTotalNodes(totalNodes);\n                        rlist.addGroupXSet(gs);\n                    }\n                }\n                rlist.setTotalGroups(totalGroups);\n                // Generate source XML\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".xml\";\n\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rlist);\n                writer.close();\n                log().debug(\"runRancidListReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runRancidListReport generating pdf is still not supported :( sending xml\");\n                    \n                    log().debug(\"runRancidListReport xml sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,xmlFileName);\n                    mailer.send();\n                    \n\n\n                } else {\n\n                    log().debug(\"runRancidListReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runRancidListReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n\n\n            }\n            catch (Exception e) {\n                log().debug(\"InventoryService runRancidListReport has given exception \"+ e.getMessage() );\n                //\n            }\n        }\n    }","commit_id":"ca1de8324582fc2dfe568691427a9efd478fe945","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"RancidReportExecController ModelAndView onSubmit\");\n        \n        RancidReportExecCommClass bean = (RancidReportExecCommClass) command;\n        \n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getReporttype());\n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getFieldhas());\n\n        ModelAndView mav = new ModelAndView(getSuccessView());\n\n        if (bean.getReporttype().compareTo(\"rancidlist\") == 0){\n            log().debug(\"RancidReportExecController rancidlist report \");\n            boolean done = m_inventoryService.runRancidListReport(bean.getDate(), bean.getReportfiletype(), bean.getReportemail());\n            mav.addObject(\"type\", \"Rancid List\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        } else if (bean.getReporttype().compareTo(\"inventory\") == 0){\n            log().debug(\"RancidReportExecController inventory report \");\n            boolean done = m_inventoryService.runNodeBaseInventoryReport(bean.getDate(), bean.getFieldhas(), bean.getReportfiletype(),bean.getReportemail());\n            mav.addObject(\"type\", \"Inventory Report\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        }\n        mav.addObject(\"date\", bean.getDate());\n        mav.addObject(\"searchfield\", bean.getFieldhas());\n        if( bean.getReportfiletype().compareTo(\"pdftype\") == 0){\n            mav.addObject(\"reportformat\", \"PDF\");\n        } else {\n            mav.addObject(\"reportformat\", \"HTML\");\n        }\n        \n        return mav;\n\n        \n//        String redirectURL = request.getHeader(\"Referer\");\n//        response.sendRedirect(redirectURL);\n//        return super.onSubmit(request, response, command, errors);\n    }","id":88644,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"RancidReportExecController ModelAndView onSubmit\");\n        \n        RancidReportExecCommClass bean = (RancidReportExecCommClass) command;\n        \n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getReporttype());\n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getFieldhas());\n\n        ModelAndView mav = new ModelAndView(getSuccessView());\n\n        if (bean.getReporttype().compareTo(\"rancidlist\") == 0){\n            log().debug(\"RancidReportExecController rancidlist report \");\n            boolean done = m_inventoryService.runRancidListReport(bean.getDate(), bean.getReportfiletype(), bean.getReportemail());\n            mav.addObject(\"type\", \"Rancid List\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        } else if (bean.getReporttype().compareTo(\"inventory\") == 0){\n            log().debug(\"RancidReportExecController inventory report \");\n            boolean done = m_inventoryService.runNodeBaseInventoryReport(bean.getDate(), bean.getFieldhas(), bean.getReportfiletype(),bean.getReportemail());\n            mav.addObject(\"type\", \"Inventory Report\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        }\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n        try {\n            mav.addObject(\"date\", format.parse(bean.getDate()));\n        }\n        catch (ParseException pe){\n            mav.addObject(\"date\", format.format(Calendar.getInstance().getTime()));\n        }\n        mav.addObject(\"searchfield\", bean.getFieldhas());\n        if( bean.getReportfiletype().compareTo(\"pdftype\") == 0){\n            mav.addObject(\"reportformat\", \"PDF\");\n        } else {\n            mav.addObject(\"reportformat\", \"HTML\");\n        }\n        \n        return mav;\n\n        \n//        String redirectURL = request.getHeader(\"Referer\");\n//        response.sendRedirect(redirectURL);\n//        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"ca1de8324582fc2dfe568691427a9efd478fe945","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n\n        if (theType == NBINVENTORY){\n            log().debug(\"InventoryService runNodeBaseInventoryReport Date [\"+ theDate +\"] key [\" + theField + \"]\"); \n            boolean withKey = false;\n            if (theField.compareTo(\"\")!=0){\n                withKey = true;\n            }\n            try {            \n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = format.parse(theDate);\n                log().debug(\"InventoryService runNodeBaseInventoryReport date[\" + tmp_date.toString() + \"]\"); \n\n                RwsNbinventoryreport rnbi = new RwsNbinventoryreport();\n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    GroupSet groupSet = new GroupSet(); \n                    boolean groupIsEmpty = true;\n                    boolean groupIsIncremented = false;\n                    log().debug(\"InventoryService runNodeBaseInventoryReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n                    while (iterDevice.hasNext()){\n                        groupIsEmpty = false;\n                        if (!groupIsIncremented){\n                            totalGroups++;\n                            groupIsIncremented = true;\n                        }\n                        String deviceName = iterDevice.next();\n                        totalNodes++;\n                        log().debug(\"InventoryService runNodeBaseInventoryReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                InventoryNode invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runNodeBaseInventoryReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runNodeBaseInventoryReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            if (!withKey){\n                            //                                Nbisinglenode nbisn = new Nbisinglenode();\n                            //                                nbisn.setDevicename(deviceName);\n                            //                                nbisn.setGroupname(groupName);\n                            //                                nbisn.setComment(\"No inventory associated\");\n                            //                                groupSet.addNbisinglenode(nbisn);\n                            //                            }\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n\n                        //we have groupname devicename and version\n\n                        try {\n                            NodeBaseInventory nodeBaseInv = getNodeBaseInventory(cProperties, deviceName, groupName, versionMatch);\n\n                            //marshall xml and save to disk\n                            log().debug(\"InventoryService runNodeBaseInventoryReport MARSHALL [\" + deviceName + \"] group [\"+groupName+\"] Version [\"+ versionMatch +\"]\"); \n                            log().debug(\"InventoryService runNodeBaseInventoryReport data [\" + nodeBaseInv.expand()); \n\n\n\n                            Nbisinglenode nbisn = new Nbisinglenode();\n                            boolean includeNbisn = false;\n\n\n                            nbisn.setConfigurationurl(nodeBaseInv.getConfigurationurl());\n                            nbisn.setCreationdate(nodeBaseInv.getCreationdate());\n                            nbisn.setDevicename(nodeBaseInv.getDevicename());\n                            nbisn.setGroupname(nodeBaseInv.getGroupname());\n                            nbisn.setStatus(nodeBaseInv.getStatus());\n                            nbisn.setSwconfigurationurl(nodeBaseInv.getSwconfigurationurl());\n                            nbisn.setVersion(nodeBaseInv.getVersion());\n\n                            List<InventoryElement2RP> ie2rpList = new ArrayList<InventoryElement2RP>();\n                            Iterator<InventoryElement2> ie2rpIter = nodeBaseInv.getIe().iterator();\n\n                            while (ie2rpIter.hasNext()){\n\n                                InventoryElement2RP ie2rp = new InventoryElement2RP();\n\n                                InventoryElement2 ie2 = ie2rpIter.next();\n                                Iterator<Tuple> iterTuple = ie2.getTupleList().iterator();\n                                Iterator<InventoryMemory> iterMemory = ie2.getMemoryList().iterator();\n                                Iterator<InventorySoftware> iterSoftware = ie2.getSoftwareList().iterator();\n\n                                while (iterTuple.hasNext()){\n                                    TupleRP tmp2 = new TupleRP();\n                                    Tuple tmp1 = iterTuple.next();\n                                    tmp2.setName(tmp1.getName());\n                                    //filter here\n                                    if (withKey && tmp1.getDescription().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp2.setDescription(tmp1.getDescription());\n                                    ie2rp.addTupleRP(tmp2);\n                                }\n\n                                while (iterMemory.hasNext()){\n                                    InventoryMemoryRP tmp3 = new InventoryMemoryRP();\n                                    InventoryMemory tmp1 = iterMemory.next();\n                                    //filter here\n                                    if (withKey && tmp1.getSize().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setSize(tmp1.getSize());\n                                    if (withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setType(tmp1.getType());\n                                    ie2rp.addInventoryMemoryRP(tmp3);\n                                }\n                                while (iterSoftware.hasNext()){\n                                    InventorySoftwareRP tmp4 = new InventorySoftwareRP();\n                                    InventorySoftware tmp1 = iterSoftware.next();\n                                    //filter here\n                                    if(withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setType(tmp1.getType());\n                                    if(withKey && tmp1.getVersion().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setVersion(tmp1.getVersion());\n\n                                    ie2rp.addInventorySoftwareRP(tmp4);\n                                }\n\n                                ie2rpList.add(ie2rp);\n\n                            }\n                            nbisn.setInventoryElement2RP(ie2rpList);\n                            // if withKey is false then include it in any case\n                            // includeNbsin is true the fiels has been found\n                            // data must be included\n                            if(!withKey || includeNbisn){\n                                groupSet.addNbisinglenode(nbisn);\n                            }\n                            //else skip \n                        }catch (Exception e){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has inventory errors [\"+deviceName+ \"]\"); \n                            continue;\n\n                        }\n                        groupSet.setTotalNodes(totalNodes);\n                    }\n                    rnbi.addGroupSet(groupSet);\n                    rnbi.setTotalGroups(totalGroups);\n                    rnbi.setDateInventory(theDate);\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport object filled\");\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".xml\";\n\n                // Generate source XML\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rnbi);\n                writer.close();\n                log().debug(\"runNodeBaseInventoryReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runNodeBaseInventoryReport generating pdf is still not supported :( \");\n\n                } else {\n\n                    log().debug(\"runNodeBaseInventoryReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-nbinventoryreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runNodeBaseInventoryReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n            }\n            catch (Exception e){\n                log().debug(\"InventoryService runNodeBaseInventoryReport exception \"+ e.getMessage() );\n            }\n\n        }\n        else if (theType == RANCIDLIST){\n            RwsRancidlistreport rlist = new RwsRancidlistreport();\n\n            try {\n\n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = format.parse(theDate);\n                log().debug(\"InventoryService runRacidListReport date[\" + tmp_date.toString() + \"]\"); \n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    log().debug(\"InventoryService runRacidListReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n\n                    GroupXSet gs = new GroupXSet();\n                    boolean groupHasDevices = false;\n                    boolean groupTotalIncremented = false;\n\n                    while (iterDevice.hasNext()){\n                        String deviceName = iterDevice.next();\n                        //totalNodes++;\n                        log().debug(\"InventoryService runRacidListReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            InventoryNode invNode = new InventoryNode(rancidNode);\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runRacidListReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runRacidListReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runRacidListReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            } else{\n                                NodeSet ns = new NodeSet();\n                                ns.setDevicename(deviceName);\n                                ns.setGroupname(groupName);\n                                ns.setVersion(versionMatch);\n                                ns.setConfigurationurl(invNode.getConfigurationUrl());\n                                ns.setSwconfigurationurl(invNode.getSoftwareImageUrl());\n                                ns.setStatus(rancidNode.getState());\n\n                                gs.addNodeSet(ns);\n\n                                groupHasDevices = true;\n                                if (!groupTotalIncremented){\n                                    totalGroups++;\n                                    groupTotalIncremented = true;\n                                }\n                                totalNodes ++;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runRacidListReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            Nbisinglenode nbisn = new Nbisinglenode();\n                            //                            nbisn.setDevicename(deviceName);\n                            //                            nbisn.setGroupname(groupName);\n                            //                            nbisn.setComment(\"No inventory associated\");\n                            //                            groupSet.addNbisinglenode(nbisn);\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n                    }\n                    if (groupHasDevices){\n                        gs.setTotalNodes(totalNodes);\n                        rlist.addGroupXSet(gs);\n                    }\n                }\n                rlist.setTotalGroups(totalGroups);\n                // Generate source XML\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".xml\";\n\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rlist);\n                writer.close();\n                log().debug(\"runRancidListReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runRancidListReport generating pdf is still not supported :( \");\n\n                    //                        String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n                    //                        \n                    //                        File file = new File(htmlFileName);\n                    //                        FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    //                        PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    //                        File fileR = new File(xmlFileName);\n                    //                        FileReader fileReader = new FileReader(fileR);\n                    //                        //htmlWriter.generatePDF(fileReader, hmtlFileWriter, ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".fot\");\n                    //                        htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    //\n                    //                        org.apache.fop.apps.Driver m_driver;\n                    //                        \n                    //                        Reader reader = new FileReader(fileR);\n                    //                        InputSource dataSource = new InputSource(reader);\n                    //                        \n                    //                        String pdfFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".pdf\";\n                    //\n                    //                        File fileP = new File(pdfFileName);\n                    //                        FileOutputStream pdfFileWriter = new FileOutputStream(fileP);\n                    //\n                    //                        m_driver = new org.apache.fop.apps.Driver(dataSource, pdfFileWriter);\n                    //                        m_driver.setRenderer(org.apache.fop.apps.Driver.RENDER_PDF);\n                    //                        m_driver.run();\n                    //\n                    //                        log().debug(\"runRancidListReport html done\");\n\n                } else {\n\n                    log().debug(\"runRancidListReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runRancidListReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n\n\n            }\n            catch (Exception e) {\n                log().debug(\"InventoryService runRancidListReport has given exception \"+ e.getMessage() );\n                //\n            }\n        }\n    }","id":88645,"modified_method":"public void run() {\n\n        if (theType == NBINVENTORY){\n            log().debug(\"InventoryService runNodeBaseInventoryReport Date [\"+ theDate +\"] key [\" + theField + \"]\"); \n            boolean withKey = false;\n            if (theField.compareTo(\"\")!=0){\n                withKey = true;\n            }\n            try {            \n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = new Date();\n                try {\n                    tmp_date = format.parse(theDate);\n                }\n                catch (ParseException pe){\n                    tmp_date = Calendar.getInstance().getTime();\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport date[\" + tmp_date.toString() + \"]\"); \n\n                RwsNbinventoryreport rnbi = new RwsNbinventoryreport();\n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    GroupSet groupSet = new GroupSet(); \n                    boolean groupIsEmpty = true;\n                    boolean groupIsIncremented = false;\n                    log().debug(\"InventoryService runNodeBaseInventoryReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n                    while (iterDevice.hasNext()){\n                        //groupIsEmpty = false;\n                        if (!groupIsIncremented){\n                            totalGroups++;\n                            groupIsIncremented = true;\n                        }\n                        String deviceName = iterDevice.next();\n                        log().debug(\"InventoryService runNodeBaseInventoryReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                InventoryNode invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runNodeBaseInventoryReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runNodeBaseInventoryReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            if (!withKey){\n                            //                                Nbisinglenode nbisn = new Nbisinglenode();\n                            //                                nbisn.setDevicename(deviceName);\n                            //                                nbisn.setGroupname(groupName);\n                            //                                nbisn.setComment(\"No inventory associated\");\n                            //                                groupSet.addNbisinglenode(nbisn);\n                            //                            }\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n\n                        //we have groupname devicename and version\n\n                        try {\n                            NodeBaseInventory nodeBaseInv = getNodeBaseInventory(cProperties, deviceName, groupName, versionMatch);\n\n                            //marshall xml and save to disk\n                            log().debug(\"InventoryService runNodeBaseInventoryReport MARSHALL [\" + deviceName + \"] group [\"+groupName+\"] Version [\"+ versionMatch +\"]\"); \n                            log().debug(\"InventoryService runNodeBaseInventoryReport data [\" + nodeBaseInv.expand()); \n\n\n\n                            Nbisinglenode nbisn = new Nbisinglenode();\n                            boolean includeNbisn = false;\n\n\n                            nbisn.setConfigurationurl(nodeBaseInv.getConfigurationurl());\n                            nbisn.setCreationdate(nodeBaseInv.getCreationdate());\n                            nbisn.setDevicename(nodeBaseInv.getDevicename());\n                            nbisn.setGroupname(nodeBaseInv.getGroupname());\n                            nbisn.setStatus(nodeBaseInv.getStatus());\n                            nbisn.setSwconfigurationurl(nodeBaseInv.getSwconfigurationurl());\n                            nbisn.setVersion(nodeBaseInv.getVersion());\n\n                            List<InventoryElement2RP> ie2rpList = new ArrayList<InventoryElement2RP>();\n                            Iterator<InventoryElement2> ie2rpIter = nodeBaseInv.getIe().iterator();\n\n                            while (ie2rpIter.hasNext()){\n\n                                InventoryElement2RP ie2rp = new InventoryElement2RP();\n\n                                InventoryElement2 ie2 = ie2rpIter.next();\n                                Iterator<Tuple> iterTuple = ie2.getTupleList().iterator();\n                                Iterator<InventoryMemory> iterMemory = ie2.getMemoryList().iterator();\n                                Iterator<InventorySoftware> iterSoftware = ie2.getSoftwareList().iterator();\n\n                                while (iterTuple.hasNext()){\n                                    TupleRP tmp2 = new TupleRP();\n                                    Tuple tmp1 = iterTuple.next();\n                                    tmp2.setName(tmp1.getName());\n                                    //filter here\n                                    if (withKey && tmp1.getDescription().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp2.setDescription(tmp1.getDescription());\n                                    ie2rp.addTupleRP(tmp2);\n                                }\n\n                                while (iterMemory.hasNext()){\n                                    InventoryMemoryRP tmp3 = new InventoryMemoryRP();\n                                    InventoryMemory tmp1 = iterMemory.next();\n                                    //filter here\n                                    if (withKey && tmp1.getSize().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setSize(tmp1.getSize());\n                                    if (withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setType(tmp1.getType());\n                                    ie2rp.addInventoryMemoryRP(tmp3);\n                                }\n                                while (iterSoftware.hasNext()){\n                                    InventorySoftwareRP tmp4 = new InventorySoftwareRP();\n                                    InventorySoftware tmp1 = iterSoftware.next();\n                                    //filter here\n                                    if(withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setType(tmp1.getType());\n                                    if(withKey && tmp1.getVersion().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setVersion(tmp1.getVersion());\n\n                                    ie2rp.addInventorySoftwareRP(tmp4);\n                                }\n\n                                ie2rpList.add(ie2rp);\n\n                            }\n                            nbisn.setInventoryElement2RP(ie2rpList);\n                            // if withKey is false then include it in any case\n                            // includeNbsin is true the fiels has been found\n                            // data must be included\n                            if(!withKey || includeNbisn){\n                                groupIsEmpty = false;\n                                totalNodes++;\n                                groupSet.addNbisinglenode(nbisn);\n                            }\n                            //else skip \n                        }catch (Exception e){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has inventory errors [\"+deviceName+ \"]\"); \n                            continue;\n\n                        }\n                        if (!groupIsEmpty){\n                            groupSet.setTotalNodes(totalNodes);\n                        }\n                    }\n                    rnbi.addGroupSet(groupSet);\n                    rnbi.setTotalGroups(totalGroups);\n                    rnbi.setDateInventory(format.format(tmp_date));\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport object filled\");\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".xml\";\n\n                // Generate source XML\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rnbi);\n                writer.close();\n                log().debug(\"runNodeBaseInventoryReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runNodeBaseInventoryReport generating pdf is still not supported :( sending xml\");\n                    log().debug(\"runNodeBaseInventoryReport xml sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,xmlFileName);\n                    mailer.send();\n\n\n                } else {\n\n                    log().debug(\"runNodeBaseInventoryReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-nbinventoryreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runNodeBaseInventoryReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n            }\n            catch (Exception e){\n                log().debug(\"InventoryService runNodeBaseInventoryReport exception \"+ e.getMessage() );\n            }\n\n        }\n        else if (theType == RANCIDLIST){\n            RwsRancidlistreport rlist = new RwsRancidlistreport();\n\n            try {\n\n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = new Date();\n                try {\n                    tmp_date = format.parse(theDate);\n                }\n                catch (ParseException pe){\n                    tmp_date = Calendar.getInstance().getTime();\n                }\n                log().debug(\"InventoryService runRacidListReport date[\" + tmp_date.toString() + \"]\"); \n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    log().debug(\"InventoryService runRacidListReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n\n                    GroupXSet gs = new GroupXSet();\n                    boolean groupHasDevices = false;\n                    boolean groupTotalIncremented = false;\n\n                    while (iterDevice.hasNext()){\n                        String deviceName = iterDevice.next();\n                        //totalNodes++;\n                        log().debug(\"InventoryService runRacidListReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            InventoryNode invNode = new InventoryNode(rancidNode);\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runRacidListReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runRacidListReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runRacidListReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            } else{\n                                NodeSet ns = new NodeSet();\n                                ns.setDevicename(deviceName);\n                                ns.setGroupname(groupName);\n                                ns.setVersion(versionMatch);\n                                ns.setConfigurationurl(invNode.getConfigurationUrl());\n                                ns.setSwconfigurationurl(invNode.getSoftwareImageUrl());\n                                ns.setStatus(rancidNode.getState());\n\n                                gs.addNodeSet(ns);\n\n                                groupHasDevices = true;\n                                if (!groupTotalIncremented){\n                                    totalGroups++;\n                                    groupTotalIncremented = true;\n                                }\n                                totalNodes ++;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runRacidListReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            Nbisinglenode nbisn = new Nbisinglenode();\n                            //                            nbisn.setDevicename(deviceName);\n                            //                            nbisn.setGroupname(groupName);\n                            //                            nbisn.setComment(\"No inventory associated\");\n                            //                            groupSet.addNbisinglenode(nbisn);\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n                    }\n                    if (groupHasDevices){\n                        gs.setTotalNodes(totalNodes);\n                        rlist.addGroupXSet(gs);\n                    }\n                }\n                rlist.setTotalGroups(totalGroups);\n                // Generate source XML\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".xml\";\n\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rlist);\n                writer.close();\n                log().debug(\"runRancidListReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runRancidListReport generating pdf is still not supported :( sending xml\");\n                    \n                    log().debug(\"runRancidListReport xml sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,xmlFileName);\n                    mailer.send();\n                    \n\n\n                } else {\n\n                    log().debug(\"runRancidListReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runRancidListReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n\n\n            }\n            catch (Exception e) {\n                log().debug(\"InventoryService runRancidListReport has given exception \"+ e.getMessage() );\n                //\n            }\n        }\n    }","commit_id":"ad2296708861de4e8a46bd9ff11a02c007258662","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"RancidReportExecController ModelAndView onSubmit\");\n        \n        RancidReportExecCommClass bean = (RancidReportExecCommClass) command;\n        \n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getReporttype());\n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getFieldhas());\n\n        ModelAndView mav = new ModelAndView(getSuccessView());\n\n        if (bean.getReporttype().compareTo(\"rancidlist\") == 0){\n            log().debug(\"RancidReportExecController rancidlist report \");\n            boolean done = m_inventoryService.runRancidListReport(bean.getDate(), bean.getReportfiletype(), bean.getReportemail());\n            mav.addObject(\"type\", \"Rancid List\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        } else if (bean.getReporttype().compareTo(\"inventory\") == 0){\n            log().debug(\"RancidReportExecController inventory report \");\n            boolean done = m_inventoryService.runNodeBaseInventoryReport(bean.getDate(), bean.getFieldhas(), bean.getReportfiletype(),bean.getReportemail());\n            mav.addObject(\"type\", \"Inventory Report\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        }\n        mav.addObject(\"date\", bean.getDate());\n        mav.addObject(\"searchfield\", bean.getFieldhas());\n        if( bean.getReportfiletype().compareTo(\"pdftype\") == 0){\n            mav.addObject(\"reportformat\", \"PDF\");\n        } else {\n            mav.addObject(\"reportformat\", \"HTML\");\n        }\n        \n        return mav;\n\n        \n//        String redirectURL = request.getHeader(\"Referer\");\n//        response.sendRedirect(redirectURL);\n//        return super.onSubmit(request, response, command, errors);\n    }","id":88646,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"RancidReportExecController ModelAndView onSubmit\");\n        \n        RancidReportExecCommClass bean = (RancidReportExecCommClass) command;\n        \n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getReporttype());\n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getFieldhas());\n\n        ModelAndView mav = new ModelAndView(getSuccessView());\n\n        if (bean.getReporttype().compareTo(\"rancidlist\") == 0){\n            log().debug(\"RancidReportExecController rancidlist report \");\n            boolean done = m_inventoryService.runRancidListReport(bean.getDate(), bean.getReportfiletype(), bean.getReportemail());\n            mav.addObject(\"type\", \"Rancid List\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        } else if (bean.getReporttype().compareTo(\"inventory\") == 0){\n            log().debug(\"RancidReportExecController inventory report \");\n            boolean done = m_inventoryService.runNodeBaseInventoryReport(bean.getDate(), bean.getFieldhas(), bean.getReportfiletype(),bean.getReportemail());\n            mav.addObject(\"type\", \"Inventory Report\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        }\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n        try {\n            mav.addObject(\"date\", format.parse(bean.getDate()));\n        }\n        catch (ParseException pe){\n            mav.addObject(\"date\", format.format(Calendar.getInstance().getTime()));\n        }\n        mav.addObject(\"searchfield\", bean.getFieldhas());\n        if( bean.getReportfiletype().compareTo(\"pdftype\") == 0){\n            mav.addObject(\"reportformat\", \"PDF\");\n        } else {\n            mav.addObject(\"reportformat\", \"HTML\");\n        }\n        \n        return mav;\n\n        \n//        String redirectURL = request.getHeader(\"Referer\");\n//        response.sendRedirect(redirectURL);\n//        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"ad2296708861de4e8a46bd9ff11a02c007258662","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n\n        if (theType == NBINVENTORY){\n            log().debug(\"InventoryService runNodeBaseInventoryReport Date [\"+ theDate +\"] key [\" + theField + \"]\"); \n            boolean withKey = false;\n            if (theField.compareTo(\"\")!=0){\n                withKey = true;\n            }\n            try {            \n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = format.parse(theDate);\n                log().debug(\"InventoryService runNodeBaseInventoryReport date[\" + tmp_date.toString() + \"]\"); \n\n                RwsNbinventoryreport rnbi = new RwsNbinventoryreport();\n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    GroupSet groupSet = new GroupSet(); \n                    boolean groupIsEmpty = true;\n                    boolean groupIsIncremented = false;\n                    log().debug(\"InventoryService runNodeBaseInventoryReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n                    while (iterDevice.hasNext()){\n                        groupIsEmpty = false;\n                        if (!groupIsIncremented){\n                            totalGroups++;\n                            groupIsIncremented = true;\n                        }\n                        String deviceName = iterDevice.next();\n                        totalNodes++;\n                        log().debug(\"InventoryService runNodeBaseInventoryReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                InventoryNode invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runNodeBaseInventoryReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runNodeBaseInventoryReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            if (!withKey){\n                            //                                Nbisinglenode nbisn = new Nbisinglenode();\n                            //                                nbisn.setDevicename(deviceName);\n                            //                                nbisn.setGroupname(groupName);\n                            //                                nbisn.setComment(\"No inventory associated\");\n                            //                                groupSet.addNbisinglenode(nbisn);\n                            //                            }\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n\n                        //we have groupname devicename and version\n\n                        try {\n                            NodeBaseInventory nodeBaseInv = getNodeBaseInventory(cProperties, deviceName, groupName, versionMatch);\n\n                            //marshall xml and save to disk\n                            log().debug(\"InventoryService runNodeBaseInventoryReport MARSHALL [\" + deviceName + \"] group [\"+groupName+\"] Version [\"+ versionMatch +\"]\"); \n                            log().debug(\"InventoryService runNodeBaseInventoryReport data [\" + nodeBaseInv.expand()); \n\n\n\n                            Nbisinglenode nbisn = new Nbisinglenode();\n                            boolean includeNbisn = false;\n\n\n                            nbisn.setConfigurationurl(nodeBaseInv.getConfigurationurl());\n                            nbisn.setCreationdate(nodeBaseInv.getCreationdate());\n                            nbisn.setDevicename(nodeBaseInv.getDevicename());\n                            nbisn.setGroupname(nodeBaseInv.getGroupname());\n                            nbisn.setStatus(nodeBaseInv.getStatus());\n                            nbisn.setSwconfigurationurl(nodeBaseInv.getSwconfigurationurl());\n                            nbisn.setVersion(nodeBaseInv.getVersion());\n\n                            List<InventoryElement2RP> ie2rpList = new ArrayList<InventoryElement2RP>();\n                            Iterator<InventoryElement2> ie2rpIter = nodeBaseInv.getIe().iterator();\n\n                            while (ie2rpIter.hasNext()){\n\n                                InventoryElement2RP ie2rp = new InventoryElement2RP();\n\n                                InventoryElement2 ie2 = ie2rpIter.next();\n                                Iterator<Tuple> iterTuple = ie2.getTupleList().iterator();\n                                Iterator<InventoryMemory> iterMemory = ie2.getMemoryList().iterator();\n                                Iterator<InventorySoftware> iterSoftware = ie2.getSoftwareList().iterator();\n\n                                while (iterTuple.hasNext()){\n                                    TupleRP tmp2 = new TupleRP();\n                                    Tuple tmp1 = iterTuple.next();\n                                    tmp2.setName(tmp1.getName());\n                                    //filter here\n                                    if (withKey && tmp1.getDescription().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp2.setDescription(tmp1.getDescription());\n                                    ie2rp.addTupleRP(tmp2);\n                                }\n\n                                while (iterMemory.hasNext()){\n                                    InventoryMemoryRP tmp3 = new InventoryMemoryRP();\n                                    InventoryMemory tmp1 = iterMemory.next();\n                                    //filter here\n                                    if (withKey && tmp1.getSize().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setSize(tmp1.getSize());\n                                    if (withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setType(tmp1.getType());\n                                    ie2rp.addInventoryMemoryRP(tmp3);\n                                }\n                                while (iterSoftware.hasNext()){\n                                    InventorySoftwareRP tmp4 = new InventorySoftwareRP();\n                                    InventorySoftware tmp1 = iterSoftware.next();\n                                    //filter here\n                                    if(withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setType(tmp1.getType());\n                                    if(withKey && tmp1.getVersion().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setVersion(tmp1.getVersion());\n\n                                    ie2rp.addInventorySoftwareRP(tmp4);\n                                }\n\n                                ie2rpList.add(ie2rp);\n\n                            }\n                            nbisn.setInventoryElement2RP(ie2rpList);\n                            // if withKey is false then include it in any case\n                            // includeNbsin is true the fiels has been found\n                            // data must be included\n                            if(!withKey || includeNbisn){\n                                groupSet.addNbisinglenode(nbisn);\n                            }\n                            //else skip \n                        }catch (Exception e){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has inventory errors [\"+deviceName+ \"]\"); \n                            continue;\n\n                        }\n                        groupSet.setTotalNodes(totalNodes);\n                    }\n                    rnbi.addGroupSet(groupSet);\n                    rnbi.setTotalGroups(totalGroups);\n                    rnbi.setDateInventory(theDate);\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport object filled\");\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".xml\";\n\n                // Generate source XML\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rnbi);\n                writer.close();\n                log().debug(\"runNodeBaseInventoryReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runNodeBaseInventoryReport generating pdf is still not supported :( \");\n\n                } else {\n\n                    log().debug(\"runNodeBaseInventoryReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-nbinventoryreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runNodeBaseInventoryReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n            }\n            catch (Exception e){\n                log().debug(\"InventoryService runNodeBaseInventoryReport exception \"+ e.getMessage() );\n            }\n\n        }\n        else if (theType == RANCIDLIST){\n            RwsRancidlistreport rlist = new RwsRancidlistreport();\n\n            try {\n\n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = format.parse(theDate);\n                log().debug(\"InventoryService runRacidListReport date[\" + tmp_date.toString() + \"]\"); \n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    log().debug(\"InventoryService runRacidListReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n\n                    GroupXSet gs = new GroupXSet();\n                    boolean groupHasDevices = false;\n                    boolean groupTotalIncremented = false;\n\n                    while (iterDevice.hasNext()){\n                        String deviceName = iterDevice.next();\n                        //totalNodes++;\n                        log().debug(\"InventoryService runRacidListReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            InventoryNode invNode = new InventoryNode(rancidNode);\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runRacidListReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runRacidListReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runRacidListReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            } else{\n                                NodeSet ns = new NodeSet();\n                                ns.setDevicename(deviceName);\n                                ns.setGroupname(groupName);\n                                ns.setVersion(versionMatch);\n                                ns.setConfigurationurl(invNode.getConfigurationUrl());\n                                ns.setSwconfigurationurl(invNode.getSoftwareImageUrl());\n                                ns.setStatus(rancidNode.getState());\n\n                                gs.addNodeSet(ns);\n\n                                groupHasDevices = true;\n                                if (!groupTotalIncremented){\n                                    totalGroups++;\n                                    groupTotalIncremented = true;\n                                }\n                                totalNodes ++;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runRacidListReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            Nbisinglenode nbisn = new Nbisinglenode();\n                            //                            nbisn.setDevicename(deviceName);\n                            //                            nbisn.setGroupname(groupName);\n                            //                            nbisn.setComment(\"No inventory associated\");\n                            //                            groupSet.addNbisinglenode(nbisn);\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n                    }\n                    if (groupHasDevices){\n                        gs.setTotalNodes(totalNodes);\n                        rlist.addGroupXSet(gs);\n                    }\n                }\n                rlist.setTotalGroups(totalGroups);\n                // Generate source XML\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".xml\";\n\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rlist);\n                writer.close();\n                log().debug(\"runRancidListReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runRancidListReport generating pdf is still not supported :( \");\n\n                    //                        String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n                    //                        \n                    //                        File file = new File(htmlFileName);\n                    //                        FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    //                        PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    //                        File fileR = new File(xmlFileName);\n                    //                        FileReader fileReader = new FileReader(fileR);\n                    //                        //htmlWriter.generatePDF(fileReader, hmtlFileWriter, ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".fot\");\n                    //                        htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    //\n                    //                        org.apache.fop.apps.Driver m_driver;\n                    //                        \n                    //                        Reader reader = new FileReader(fileR);\n                    //                        InputSource dataSource = new InputSource(reader);\n                    //                        \n                    //                        String pdfFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".pdf\";\n                    //\n                    //                        File fileP = new File(pdfFileName);\n                    //                        FileOutputStream pdfFileWriter = new FileOutputStream(fileP);\n                    //\n                    //                        m_driver = new org.apache.fop.apps.Driver(dataSource, pdfFileWriter);\n                    //                        m_driver.setRenderer(org.apache.fop.apps.Driver.RENDER_PDF);\n                    //                        m_driver.run();\n                    //\n                    //                        log().debug(\"runRancidListReport html done\");\n\n                } else {\n\n                    log().debug(\"runRancidListReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runRancidListReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n\n\n            }\n            catch (Exception e) {\n                log().debug(\"InventoryService runRancidListReport has given exception \"+ e.getMessage() );\n                //\n            }\n        }\n    }","id":88647,"modified_method":"public void run() {\n\n        if (theType == NBINVENTORY){\n            log().debug(\"InventoryService runNodeBaseInventoryReport Date [\"+ theDate +\"] key [\" + theField + \"]\"); \n            boolean withKey = false;\n            if (theField.compareTo(\"\")!=0){\n                withKey = true;\n            }\n            try {            \n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = new Date();\n                try {\n                    tmp_date = format.parse(theDate);\n                }\n                catch (ParseException pe){\n                    tmp_date = Calendar.getInstance().getTime();\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport date[\" + tmp_date.toString() + \"]\"); \n\n                RwsNbinventoryreport rnbi = new RwsNbinventoryreport();\n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    GroupSet groupSet = new GroupSet(); \n                    boolean groupIsEmpty = true;\n                    boolean groupIsIncremented = false;\n                    log().debug(\"InventoryService runNodeBaseInventoryReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n                    while (iterDevice.hasNext()){\n                        //groupIsEmpty = false;\n                        if (!groupIsIncremented){\n                            totalGroups++;\n                            groupIsIncremented = true;\n                        }\n                        String deviceName = iterDevice.next();\n                        log().debug(\"InventoryService runNodeBaseInventoryReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                InventoryNode invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runNodeBaseInventoryReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runNodeBaseInventoryReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            if (!withKey){\n                            //                                Nbisinglenode nbisn = new Nbisinglenode();\n                            //                                nbisn.setDevicename(deviceName);\n                            //                                nbisn.setGroupname(groupName);\n                            //                                nbisn.setComment(\"No inventory associated\");\n                            //                                groupSet.addNbisinglenode(nbisn);\n                            //                            }\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n\n                        //we have groupname devicename and version\n\n                        try {\n                            NodeBaseInventory nodeBaseInv = getNodeBaseInventory(cProperties, deviceName, groupName, versionMatch);\n\n                            //marshall xml and save to disk\n                            log().debug(\"InventoryService runNodeBaseInventoryReport MARSHALL [\" + deviceName + \"] group [\"+groupName+\"] Version [\"+ versionMatch +\"]\"); \n                            log().debug(\"InventoryService runNodeBaseInventoryReport data [\" + nodeBaseInv.expand()); \n\n\n\n                            Nbisinglenode nbisn = new Nbisinglenode();\n                            boolean includeNbisn = false;\n\n\n                            nbisn.setConfigurationurl(nodeBaseInv.getConfigurationurl());\n                            nbisn.setCreationdate(nodeBaseInv.getCreationdate());\n                            nbisn.setDevicename(nodeBaseInv.getDevicename());\n                            nbisn.setGroupname(nodeBaseInv.getGroupname());\n                            nbisn.setStatus(nodeBaseInv.getStatus());\n                            nbisn.setSwconfigurationurl(nodeBaseInv.getSwconfigurationurl());\n                            nbisn.setVersion(nodeBaseInv.getVersion());\n\n                            List<InventoryElement2RP> ie2rpList = new ArrayList<InventoryElement2RP>();\n                            Iterator<InventoryElement2> ie2rpIter = nodeBaseInv.getIe().iterator();\n\n                            while (ie2rpIter.hasNext()){\n\n                                InventoryElement2RP ie2rp = new InventoryElement2RP();\n\n                                InventoryElement2 ie2 = ie2rpIter.next();\n                                Iterator<Tuple> iterTuple = ie2.getTupleList().iterator();\n                                Iterator<InventoryMemory> iterMemory = ie2.getMemoryList().iterator();\n                                Iterator<InventorySoftware> iterSoftware = ie2.getSoftwareList().iterator();\n\n                                while (iterTuple.hasNext()){\n                                    TupleRP tmp2 = new TupleRP();\n                                    Tuple tmp1 = iterTuple.next();\n                                    tmp2.setName(tmp1.getName());\n                                    //filter here\n                                    if (withKey && tmp1.getDescription().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp2.setDescription(tmp1.getDescription());\n                                    ie2rp.addTupleRP(tmp2);\n                                }\n\n                                while (iterMemory.hasNext()){\n                                    InventoryMemoryRP tmp3 = new InventoryMemoryRP();\n                                    InventoryMemory tmp1 = iterMemory.next();\n                                    //filter here\n                                    if (withKey && tmp1.getSize().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setSize(tmp1.getSize());\n                                    if (withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp3.setType(tmp1.getType());\n                                    ie2rp.addInventoryMemoryRP(tmp3);\n                                }\n                                while (iterSoftware.hasNext()){\n                                    InventorySoftwareRP tmp4 = new InventorySoftwareRP();\n                                    InventorySoftware tmp1 = iterSoftware.next();\n                                    //filter here\n                                    if(withKey && tmp1.getType().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setType(tmp1.getType());\n                                    if(withKey && tmp1.getVersion().contains(theField)){\n                                        includeNbisn = true;\n                                    }\n                                    tmp4.setVersion(tmp1.getVersion());\n\n                                    ie2rp.addInventorySoftwareRP(tmp4);\n                                }\n\n                                ie2rpList.add(ie2rp);\n\n                            }\n                            nbisn.setInventoryElement2RP(ie2rpList);\n                            // if withKey is false then include it in any case\n                            // includeNbsin is true the fiels has been found\n                            // data must be included\n                            if(!withKey || includeNbisn){\n                                groupIsEmpty = false;\n                                totalNodes++;\n                                groupSet.addNbisinglenode(nbisn);\n                            }\n                            //else skip \n                        }catch (Exception e){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device has inventory errors [\"+deviceName+ \"]\"); \n                            continue;\n\n                        }\n                        if (!groupIsEmpty){\n                            groupSet.setTotalNodes(totalNodes);\n                        }\n                    }\n                    rnbi.addGroupSet(groupSet);\n                    rnbi.setTotalGroups(totalGroups);\n                    rnbi.setDateInventory(format.format(tmp_date));\n                }\n                log().debug(\"InventoryService runNodeBaseInventoryReport object filled\");\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".xml\";\n\n                // Generate source XML\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rnbi);\n                writer.close();\n                log().debug(\"runNodeBaseInventoryReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runNodeBaseInventoryReport generating pdf is still not supported :( sending xml\");\n                    log().debug(\"runNodeBaseInventoryReport xml sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,xmlFileName);\n                    mailer.send();\n\n\n                } else {\n\n                    log().debug(\"runNodeBaseInventoryReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/NODEINVENTORY\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-nbinventoryreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runNodeBaseInventoryReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n            }\n            catch (Exception e){\n                log().debug(\"InventoryService runNodeBaseInventoryReport exception \"+ e.getMessage() );\n            }\n\n        }\n        else if (theType == RANCIDLIST){\n            RwsRancidlistreport rlist = new RwsRancidlistreport();\n\n            try {\n\n                //parse date\n                SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n                Date tmp_date = new Date();\n                try {\n                    tmp_date = format.parse(theDate);\n                }\n                catch (ParseException pe){\n                    tmp_date = Calendar.getInstance().getTime();\n                }\n                log().debug(\"InventoryService runRacidListReport date[\" + tmp_date.toString() + \"]\"); \n\n                //get the list of groups\n                RWSResourceList groupList = RWSClientApi.getRWSResourceGroupsList(cProperties);\n                List<String> groupListStr= groupList.getResource();\n                Iterator<String> iterGroup = groupListStr.iterator();\n                int totalGroups = 0;\n\n                while (iterGroup.hasNext()){\n                    String groupName = iterGroup.next();\n                    log().debug(\"InventoryService runRacidListReport group [\" + groupName + \"]\"); \n                    RWSResourceList deviceList = RWSClientApi.getRWSResourceDeviceList(cProperties, groupName);\n                    List<String> deviceListStr= deviceList.getResource();\n                    Iterator<String> iterDevice = deviceListStr.iterator();\n                    int totalNodes = 0;\n\n                    GroupXSet gs = new GroupXSet();\n                    boolean groupHasDevices = false;\n                    boolean groupTotalIncremented = false;\n\n                    while (iterDevice.hasNext()){\n                        String deviceName = iterDevice.next();\n                        //totalNodes++;\n                        log().debug(\"InventoryService runRacidListReport device [\" + deviceName + \"]\");\n                        String versionMatch=\"\";\n                        try {\n                            RWSResourceList versionList = RWSClientApi.getRWSResourceConfigList(cProperties, groupName, deviceName);\n                            List<String> versionListStr= versionList.getResource();\n                            Iterator<String> iterVersion = versionListStr.iterator();\n\n                            RancidNode rancidNode;\n                            rancidNode = RWSClientApi.getRWSRancidNodeInventory(cProperties ,groupName, deviceName);\n\n                            boolean found = false;\n\n                            InventoryNode invNode = new InventoryNode(rancidNode);\n                            while (iterVersion.hasNext() && !found)  {\n                                versionMatch = iterVersion.next();\n                                invNode = (InventoryNode)rancidNode.getNodeVersions().get(versionMatch);\n                                log().debug(\"InventoryService runRacidListReport InventoryNode version[\" + invNode.getVersionId() + \"] date [\"+invNode.getCreationDate()+\"] config [\"+ invNode.getConfigurationUrl() +\"]\"); \n                                if (tmp_date.compareTo(invNode.getCreationDate()) >  0 ) {\n                                    found = true;\n                                    log().debug(\"InventoryService runRacidListReport Date found is [\"+invNode.getCreationDate()+\"] version is [\" + versionMatch + \"]\"); \n                                }\n                            }\n                            if (found == false) {\n                                // skip device\n                                log().debug(\"InventoryService runRacidListReport device has no inventory at this date[\"+deviceName+ \"]\"); \n                                continue;\n                            } else{\n                                NodeSet ns = new NodeSet();\n                                ns.setDevicename(deviceName);\n                                ns.setGroupname(groupName);\n                                ns.setVersion(versionMatch);\n                                ns.setConfigurationurl(invNode.getConfigurationUrl());\n                                ns.setSwconfigurationurl(invNode.getSoftwareImageUrl());\n                                ns.setStatus(rancidNode.getState());\n\n                                gs.addNodeSet(ns);\n\n                                groupHasDevices = true;\n                                if (!groupTotalIncremented){\n                                    totalGroups++;\n                                    groupTotalIncremented = true;\n                                }\n                                totalNodes ++;\n                            }\n                        } catch (Exception e){\n                            //no inventory, skip node....\n                            log().debug(\"InventoryService runRacidListReport device has no inventory [\"+deviceName+ \"]\"); \n                            //                            Nbisinglenode nbisn = new Nbisinglenode();\n                            //                            nbisn.setDevicename(deviceName);\n                            //                            nbisn.setGroupname(groupName);\n                            //                            nbisn.setComment(\"No inventory associated\");\n                            //                            groupSet.addNbisinglenode(nbisn);\n                            continue;\n                        }\n                        if (versionMatch.compareTo(\"\") == 0){\n                            log().debug(\"InventoryService runNodeBaseInventoryReport device skipped [\"+deviceName+ \"]\"); \n                            continue;\n                        }\n                    }\n                    if (groupHasDevices){\n                        gs.setTotalNodes(totalNodes);\n                        rlist.addGroupXSet(gs);\n                    }\n                }\n                rlist.setTotalGroups(totalGroups);\n                // Generate source XML\n                SimpleDateFormat fmt = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n                String datestamp = fmt.format(new java.util.Date()) ;\n                String xmlFileName = ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".xml\";\n\n                FileWriter writer = new FileWriter(xmlFileName);\n                Marshaller marshaller = new Marshaller(writer);\n                marshaller.setSuppressNamespaces(true);\n                marshaller.marshal(rlist);\n                writer.close();\n                log().debug(\"runRancidListReport marshal done\");\n\n                if (reportFormat.compareTo(\"pdftype\") == 0){\n\n                    log().debug(\"runRancidListReport generating pdf is still not supported :( sending xml\");\n                    \n                    log().debug(\"runRancidListReport xml sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,xmlFileName);\n                    mailer.send();\n                    \n\n\n                } else {\n\n                    log().debug(\"runRancidListReport generating html\");\n\n                    String htmlFileName=ConfigFileConstants.getHome() + \"/share/reports/RANCIDLISTREPORT\" + datestamp + \".html\";\n\n                    File file = new File(htmlFileName);\n                    FileOutputStream hmtlFileWriter = new FileOutputStream(file);\n                    PDFWriter htmlWriter = new PDFWriter(ConfigFileConstants.getFilePathString() + \"/rws-rancidlistreport.xsl\");\n                    File fileR = new File(xmlFileName);\n                    FileReader fileReader = new FileReader(fileR);\n                    htmlWriter.generateHTML(fileReader, hmtlFileWriter);\n                    log().debug(\"runRancidListReport html sending email\");\n                    ReportMailer mailer = new ReportMailer(reportEmail,htmlFileName);\n                    mailer.send();\n\n                }\n\n\n            }\n            catch (Exception e) {\n                log().debug(\"InventoryService runRancidListReport has given exception \"+ e.getMessage() );\n                //\n            }\n        }\n    }","commit_id":"398fafc0a229d4f4ed6df81f01be55754d95a712","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"RancidReportExecController ModelAndView onSubmit\");\n        \n        RancidReportExecCommClass bean = (RancidReportExecCommClass) command;\n        \n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getReporttype());\n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getFieldhas());\n\n        ModelAndView mav = new ModelAndView(getSuccessView());\n\n        if (bean.getReporttype().compareTo(\"rancidlist\") == 0){\n            log().debug(\"RancidReportExecController rancidlist report \");\n            boolean done = m_inventoryService.runRancidListReport(bean.getDate(), bean.getReportfiletype(), bean.getReportemail());\n            mav.addObject(\"type\", \"Rancid List\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        } else if (bean.getReporttype().compareTo(\"inventory\") == 0){\n            log().debug(\"RancidReportExecController inventory report \");\n            boolean done = m_inventoryService.runNodeBaseInventoryReport(bean.getDate(), bean.getFieldhas(), bean.getReportfiletype(),bean.getReportemail());\n            mav.addObject(\"type\", \"Inventory Report\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        }\n        mav.addObject(\"date\", bean.getDate());\n        mav.addObject(\"searchfield\", bean.getFieldhas());\n        if( bean.getReportfiletype().compareTo(\"pdftype\") == 0){\n            mav.addObject(\"reportformat\", \"PDF\");\n        } else {\n            mav.addObject(\"reportformat\", \"HTML\");\n        }\n        \n        return mav;\n\n        \n//        String redirectURL = request.getHeader(\"Referer\");\n//        response.sendRedirect(redirectURL);\n//        return super.onSubmit(request, response, command, errors);\n    }","id":88648,"modified_method":"protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,\n            Object command, BindException errors) throws ServletException, IOException, Exception {\n\n        log().debug(\"RancidReportExecController ModelAndView onSubmit\");\n        \n        RancidReportExecCommClass bean = (RancidReportExecCommClass) command;\n        \n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getReporttype());\n        log().debug(\"RancidReportExecController ModelAndView type\" + bean.getFieldhas());\n\n        ModelAndView mav = new ModelAndView(getSuccessView());\n\n        if (bean.getReporttype().compareTo(\"rancidlist\") == 0){\n            log().debug(\"RancidReportExecController rancidlist report \");\n            boolean done = m_inventoryService.runRancidListReport(bean.getDate(), bean.getReportfiletype(), bean.getReportemail());\n            mav.addObject(\"type\", \"Rancid List\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        } else if (bean.getReporttype().compareTo(\"inventory\") == 0){\n            log().debug(\"RancidReportExecController inventory report \");\n            boolean done = m_inventoryService.runNodeBaseInventoryReport(bean.getDate(), bean.getFieldhas(), bean.getReportfiletype(),bean.getReportemail());\n            mav.addObject(\"type\", \"Inventory Report\");\n            if (!done){\n                log().debug(\"RancidReportExecController error \");\n            }\n        }\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy/M/d\");\n        try {\n            mav.addObject(\"date\", format.parse(bean.getDate()));\n        }\n        catch (ParseException pe){\n            mav.addObject(\"date\", format.format(Calendar.getInstance().getTime()));\n        }\n        mav.addObject(\"searchfield\", bean.getFieldhas());\n        if( bean.getReportfiletype().compareTo(\"pdftype\") == 0){\n            mav.addObject(\"reportformat\", \"PDF\");\n        } else {\n            mav.addObject(\"reportformat\", \"HTML\");\n        }\n        \n        return mav;\n\n        \n//        String redirectURL = request.getHeader(\"Referer\");\n//        response.sendRedirect(redirectURL);\n//        return super.onSubmit(request, response, command, errors);\n    }","commit_id":"398fafc0a229d4f4ed6df81f01be55754d95a712","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public String getApplicableConcept() {\n    return NameUtil.nodeFQName(this.applicableConcept);\n  }","id":88649,"modified_method":"@Override\n  public String getApplicableConcept() {\n    return this.applicableConcept;\n  }","commit_id":"b307985f98cac4c28865088cdf50ec5a53f6c66b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void weaveTemplateDeclaration_intern(SNode template, SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (template == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n\n    List<SNode> templateFragments = GeneratorUtilEx.getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      environment.getGenerator().showErrorMessage(context.getInput(), template, ruleNode, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    checkTemplateFragmentsForWeaving(template, templateFragments, environment.getGenerator());\n\n    String ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n\n    // for each template fragment create output nodes\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (SNode templateFragment : templateFragments) {\n      SNode templateFragmentNode = templateFragment.getParent();\n      SNode contextParentNode = null;\n      try {\n        contextParentNode = environment.getReductionContext().getQueryExecutor().getContextNodeForTemplateFragment(templateFragmentNode, outputContextNode, context);\n      } catch (Exception e) {\n        environment.getGenerator().getLogger().handleException(e);\n      }\n      if (contextParentNode != null) {\n        try {\n          List<SNode> outputNodesToWeave = templateProcessor.apply(\n            GeneratorUtilEx.getMappingName(templateFragment, ruleMappingName),\n            templateFragmentNode, context);\n          String childRole = templateFragmentNode.getRole_();\n          for (SNode outputNodeToWeave : outputNodesToWeave) {\n            environment.weaveNode(contextParentNode, childRole, outputNodeToWeave, new SNodePointer(templateFragment), context.getInput());\n          }\n        } catch (DismissTopMappingRuleException e) {\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"wrong template: dismission of weaving rule is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          // FIXME\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"error processing template fragment\");\n          environment.getGenerator().getLogger().info(contextParentNode, \" -- was output context node:\");\n        }\n      } else {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"couldn't define 'context' for template fragment\");\n      }\n    }\n  }","id":88650,"modified_method":"private void weaveTemplateDeclaration_intern(SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (templateFragments == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n    if (templateFragments.isEmpty()) {\n      environment.getGenerator().showErrorMessage(context.getInput(), template, ruleNode, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    checkTemplateFragmentsForWeaving(template, templateFragments, environment.getGenerator());\n\n    // for each template fragment create output nodes\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (SNode templateFragment : templateFragments) {\n      SNode templateFragmentNode = templateFragment.getParent();\n      SNode contextParentNode = null;\n      try {\n        contextParentNode = environment.getReductionContext().getQueryExecutor().getContextNodeForTemplateFragment(templateFragmentNode, outputContextNode, context);\n      } catch (Exception e) {\n        environment.getGenerator().getLogger().handleException(e);\n      }\n      if (contextParentNode != null) {\n        try {\n          List<SNode> outputNodesToWeave = templateProcessor.apply(\n            GeneratorUtilEx.getMappingName(templateFragment, ruleMappingName),\n            templateFragmentNode, context);\n          String childRole = templateFragmentNode.getRole_();\n          for (SNode outputNodeToWeave : outputNodesToWeave) {\n            environment.weaveNode(contextParentNode, childRole, outputNodeToWeave, new SNodePointer(templateFragment), context.getInput());\n          }\n        } catch (DismissTopMappingRuleException e) {\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"wrong template: dismission of weaving rule is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          // FIXME\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"error processing template fragment\");\n          environment.getGenerator().getLogger().info(contextParentNode, \" -- was output context node:\");\n        }\n      } else {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"couldn't define 'context' for template fragment\");\n      }\n    }\n  }","commit_id":"b307985f98cac4c28865088cdf50ec5a53f6c66b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateWeavingRuleInterpreted(SNode rule) {\n    ruleNode = rule;\n    applicableConcept = RuleUtil.getBaseRuleApplicableConcept(ruleNode);\n  }","id":88651,"modified_method":"public TemplateWeavingRuleInterpreted(SNode rule) {\n    ruleNode = rule;\n    applicableConcept = NameUtil.nodeFQName(RuleUtil.getBaseRuleApplicableConcept(ruleNode));\n\n    SNode condition = RuleUtil.getBaseRuleCondition(ruleNode);\n    conditionMethod = condition == null ? null : TemplateFunctionMethodName.baseMappingRule_Condition(condition);\n\n    consequenceNode = RuleUtil.getWeaving_Consequence(ruleNode);\n    if (consequenceNode == null) {\n      consequence = null;\n      template = null;\n    } else {\n      String consequenceConceptFQName = consequenceNode.getConcept().getId();\n      if (consequenceConceptFQName.equals(RuleUtil.concept_TemplateDeclarationReference)) {\n        consequence = new TemplateDeclarationConsequence();\n        template = RuleUtil.getTemplateDeclarationReference_Template(consequenceNode);\n      } else if (consequenceConceptFQName.equals(RuleUtil.concept_WeaveEach_RuleConsequence)) {\n        consequence = new ForeachConsequence(consequenceNode);\n        template = RuleUtil.getWeaveEach_Template(consequenceNode);\n      } else {\n        consequence = new InvalidConsequence();\n        template = null;\n      }\n    }\n\n    templateFragments = template != null ? GeneratorUtilEx.getTemplateFragments(template) : null;\n    ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n  }","commit_id":"b307985f98cac4c28865088cdf50ec5a53f6c66b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isApplicable(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    SNode condition = RuleUtil.getBaseRuleCondition(ruleNode);\n    if (condition == null) {\n      return true;\n    }\n\n    String methodName = TemplateFunctionMethodName.baseMappingRule_Condition(condition);\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(\n        methodName,\n        environment.getGenerator().getGeneratorSessionContext(),\n        new BaseMappingRuleContext(context.getInput(), ruleNode, environment.getGenerator()),\n        ruleNode.getModel(),\n        true);\n    } catch (ClassNotFoundException e) {\n      environment.getGenerator().getLogger().warning(condition, \"cannot find condition method '\" + methodName + \"' : evaluate to FALSE\");\n    } catch (NoSuchMethodException e) {\n      environment.getGenerator().getLogger().warning(condition, \"cannot find condition method '\" + methodName + \"' : evaluate to FALSE\");\n    } catch (Throwable t) {\n      environment.getGenerator().getLogger().handleException(t);\n      environment.getGenerator().getLogger().error(condition, \"error executing condition \" + methodName + \" (see exception)\");\n      throw new GenerationFailureException(t);\n    }\n    return false;\n  }","id":88652,"modified_method":"@Override\n  public boolean isApplicable(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    if (conditionMethod == null) {\n      return true;\n    }\n\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(\n        conditionMethod,\n        environment.getGenerator().getGeneratorSessionContext(),\n        new BaseMappingRuleContext(context.getInput(), ruleNode, environment.getGenerator()),\n        ruleNode.getModel(),\n        true);\n    } catch (ClassNotFoundException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + conditionMethod + \"' : evaluate to FALSE\");\n    } catch (NoSuchMethodException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + conditionMethod + \"' : evaluate to FALSE\");\n    } catch (Throwable t) {\n      environment.getGenerator().getLogger().handleException(t);\n      environment.getGenerator().getLogger().error(ruleNode, \"error executing condition \" + conditionMethod + \" (see exception)\");\n      throw new GenerationFailureException(t);\n    }\n    return false;\n  }","commit_id":"b307985f98cac4c28865088cdf50ec5a53f6c66b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean apply(TemplateExecutionEnvironment environment, TemplateContext context, SNode outputContextNode) throws GenerationException {\n    SNode consequence = RuleUtil.getWeaving_Consequence(ruleNode);\n    if (consequence == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"weaving rule: no rule consequence\");\n      return false;\n    }\n\n    environment.getTracer().pushRuleConsequence(new SNodePointer(consequence));\n    String consequenceConceptFQName = consequence.getConcept().getId();\n    if (consequenceConceptFQName.equals(RuleUtil.concept_TemplateDeclarationReference)) {\n      SNode template = RuleUtil.getTemplateDeclarationReference_Template(consequence);\n      weaveTemplateDeclaration(template, outputContextNode,\n        GeneratorUtil.createConsequenceContext(context.getInput(), null, environment.getReductionContext(), consequence, context.getInput(), environment.getGenerator()), environment);\n      return true;\n\n    } else if (consequenceConceptFQName.equals(RuleUtil.concept_WeaveEach_RuleConsequence)) {\n      SNode query = RuleUtil.getWeaveEach_SourceNodesQuery(consequence);\n      if (query == null) {\n        environment.getGenerator().showErrorMessage(context.getInput(), ruleNode, \"weaving rule: cannot create list of source nodes\");\n        return false;\n      }\n      SNode template = RuleUtil.getWeaveEach_Template(consequence);\n      Collection<SNode> queryNodes = environment.getReductionContext().getQueryExecutor().evaluateSourceNodesQuery(context.getInput(), ruleNode, null, query, context);\n      if (queryNodes.isEmpty()) {\n        return false;\n      }\n      for (SNode queryNode : queryNodes) {\n        weaveTemplateDeclaration(template, outputContextNode,\n          GeneratorUtil.createConsequenceContext(queryNode, null, environment.getReductionContext(), consequence, queryNode, environment.getGenerator()), environment);\n      }\n\n      return true;\n    } else {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, consequence, \"weaving rule: unsupported rule consequence\");\n      return false;\n    }\n  }","id":88653,"modified_method":"@Override\n  public boolean apply(TemplateExecutionEnvironment environment, TemplateContext context, SNode outputContextNode) throws GenerationException {\n    if (consequence == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"weaving rule: no rule consequence\");\n      return false;\n    }\n\n    environment.getTracer().pushRuleConsequence(new SNodePointer(consequenceNode));\n    return consequence.apply(environment, context, outputContextNode);\n  }","commit_id":"b307985f98cac4c28865088cdf50ec5a53f6c66b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void weaveTemplateDeclaration(SNode template,\n                      SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    try {\n      weaveTemplateDeclaration_intern(template, outputContextNode, context, environment);\n    } finally {\n      environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    }\n  }","id":88654,"modified_method":"private void weaveTemplateDeclaration(SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    try {\n      weaveTemplateDeclaration_intern(outputContextNode, context, environment);\n    } finally {\n      environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(context.getInput()));\n    }\n  }","commit_id":"b307985f98cac4c28865088cdf50ec5a53f6c66b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateCreateRootRuleInterpreted(SNode ruleNode) {\n    this.ruleNode = ruleNode;\n  }","id":88655,"modified_method":"public TemplateCreateRootRuleInterpreted(SNode ruleNode) {\n    this.ruleNode = ruleNode;\n    SNode conditionFunction = RuleUtil.getCreateRootRuleCondition(ruleNode);\n    this.conditionMethod = conditionFunction == null ? null : TemplateFunctionMethodName.createRootRule_Condition(conditionFunction);\n    this.ruleMappingName = RuleUtil.getCreateRootRuleLabel(ruleNode);\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationFailureException {\n    SNode conditionFunction = RuleUtil.getCreateRootRuleCondition(ruleNode);\n    if (conditionFunction == null) {\n      return true;\n    }\n    String methodName = TemplateFunctionMethodName.createRootRule_Condition(conditionFunction);\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(\n        methodName,\n        environment.getGenerator().getGeneratorSessionContext(),\n        new CreateRootRuleContext(ruleNode, environment.getGenerator()),\n        ruleNode.getModel(),\n        true);\n    } catch (ClassNotFoundException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + methodName + \"' : evaluate to FALSE\");\n    } catch (NoSuchMethodException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + methodName + \"' : evaluate to FALSE\");\n    } catch (Throwable t) {\n      environment.getGenerator().getLogger().handleException(t);\n      environment.getGenerator().getLogger().error(ruleNode, \"error executing condition \" + methodName + \" (see exception)\");\n      throw new GenerationFailureException(t);\n    }\n    return false;\n  }","id":88656,"modified_method":"@Override\n  public boolean isApplicable(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationFailureException {\n    if (conditionMethod == null) {\n      return true;\n    }\n\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(\n        conditionMethod,\n        environment.getGenerator().getGeneratorSessionContext(),\n        new CreateRootRuleContext(ruleNode, environment.getGenerator()),\n        ruleNode.getModel(),\n        true);\n    } catch (ClassNotFoundException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + conditionMethod + \"' : evaluate to FALSE\");\n    } catch (NoSuchMethodException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + conditionMethod + \"' : evaluate to FALSE\");\n    } catch (Throwable t) {\n      environment.getGenerator().getLogger().handleException(t);\n      environment.getGenerator().getLogger().error(ruleNode, \"error executing condition \" + conditionMethod + \" (see exception)\");\n      throw new GenerationFailureException(t);\n    }\n    return false;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Collection<SNode> apply(TemplateExecutionEnvironment environment) throws GenerationCanceledException, TemplateProcessingFailureException, GenerationFailureException, DismissTopMappingRuleException {\n    SNode templateNode = RuleUtil.getCreateRootRuleTemplateNode(ruleNode);\n    if (templateNode != null) {\n      String ruleMappingName = RuleUtil.getCreateRootRuleLabel(ruleNode);\n\n      return new TemplateProcessor(environment.getGenerator(), environment.getReductionContext())\n        .processTemplateNode(ruleMappingName, templateNode, new DefaultTemplateContext(null));\n    } else {\n      environment.getGenerator().showErrorMessage(null, null, ruleNode, \"'create root' rule has no template\");\n      return null;\n    }\n  }","id":88657,"modified_method":"@Override\n  public Collection<SNode> apply(TemplateExecutionEnvironment environment) throws GenerationCanceledException, TemplateProcessingFailureException, GenerationFailureException, DismissTopMappingRuleException {\n    SNode templateNode = RuleUtil.getCreateRootRuleTemplateNode(ruleNode);\n    if (templateNode != null) {\n      return new TemplateProcessor(environment.getGenerator(), environment.getReductionContext())\n        .apply(ruleMappingName, templateNode, new DefaultTemplateContext(null));\n    } else {\n      environment.getGenerator().showErrorMessage(null, null, ruleNode, \"'create root' rule has no template\");\n      return null;\n    }\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> apply(@NotNull TemplateExecutionEnvironment environment, @NotNull TemplateContext context) throws GenerationException {\n    TemplateContext applyContext = myArguments.length == 0 ? context : context.subContext(getArgumentsAsMap());\n\n    if (myTemplateNode.getConcept().isSubConceptOf(SConceptRepository.getInstance().getConcept(RuleUtil.concept_TemplateDeclaration))) {\n      List<SNode> fragments = GeneratorUtilEx.getTemplateFragments(myTemplateNode);\n      if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments, myTemplateNode, context.getInput(), null, environment.getGenerator())) {\n        environment.getGenerator().showErrorMessage(context.getInput(), myTemplateNode, \"error processing template declaration\");\n        return null;\n      }\n\n      environment.getTracer().pushTemplateNode(new SNodePointer(myTemplateNode));\n\n      Collection<SNode> outputNodes = new ArrayList<SNode>();\n      for (SNode fragment : fragments) {\n        SNode templateForInclude = fragment.getParent();\n        String mappingName = GeneratorUtilEx.getMappingName(fragment, null);\n        TemplateProcessor p = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n        try {\n          outputNodes.addAll(p.processTemplateNode(mappingName, templateForInclude, context.subContext(mappingName)));\n        } catch (TemplateProcessingFailureException ex) {\n          /* ignore */\n        }\n      }\n      return outputNodes;\n    } else {\n      return new TemplateProcessor(environment.getGenerator(), environment.getReductionContext())\n        .processTemplateNode(null, myTemplateNode, applyContext);\n    }\n  }","id":88658,"modified_method":"@Override\n  public Collection<SNode> apply(@NotNull TemplateExecutionEnvironment environment, @NotNull TemplateContext context) throws GenerationException {\n    TemplateContext applyContext = myArguments.length == 0 ? context : context.subContext(getArgumentsAsMap());\n\n    if (myTemplateNode.getConcept().isSubConceptOf(SConceptRepository.getInstance().getConcept(RuleUtil.concept_TemplateDeclaration))) {\n      List<SNode> fragments = GeneratorUtilEx.getTemplateFragments(myTemplateNode);\n      if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments, myTemplateNode, context.getInput(), null, environment.getGenerator())) {\n        environment.getGenerator().showErrorMessage(context.getInput(), myTemplateNode, \"error processing template declaration\");\n        return null;\n      }\n\n      environment.getTracer().pushTemplateNode(new SNodePointer(myTemplateNode));\n\n      Collection<SNode> outputNodes = new ArrayList<SNode>();\n      for (SNode fragment : fragments) {\n        SNode templateForInclude = fragment.getParent();\n        String mappingName = GeneratorUtilEx.getMappingName(fragment, null);\n        TemplateProcessor p = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n        try {\n          outputNodes.addAll(p.apply(mappingName, templateForInclude, context.subContext(mappingName)));\n        } catch (TemplateProcessingFailureException ex) {\n          /* ignore */\n        }\n      }\n      return outputNodes;\n    } else {\n      return new TemplateProcessor(environment.getGenerator(), environment.getReductionContext())\n        .apply(null, myTemplateNode, applyContext);\n    }\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private List<SNode> createOutputNodesForTemplateNode(String mappingName,\n                                                       SNode templateNode,\n                                                       @NotNull TemplateContext context,\n                                                       int nodeMacrosToSkip)\n    throws DismissTopMappingRuleException, GenerationFailureException, GenerationCanceledException {\n\n    IGenerationTracer generationTracer = myGenerator.getGenerationTracer();\n    assert mappingName == null || mappingName.equals(context.getInputName());\n\n    int macroCount = 0;\n    // templateNode has unprocessed node-macros?\n    for (SNode templateChildNode : templateNode.getChildren()) {\n      if (!(templateChildNode.getConcept().isSubConceptOf(SConceptRepository.getInstance().getConcept(RuleUtil.concept_NodeMacro))))\n        continue;\n      macroCount++;\n      if (macroCount <= nodeMacrosToSkip) continue;\n      generationTracer.pushMacro(new SNodePointer(templateChildNode));\n      try {\n        return createOutputNodesForTemplateNodeWithMacro(templateChildNode, templateNode, context, nodeMacrosToSkip, mappingName);\n      } finally {\n        generationTracer.closeMacro(new SNodePointer(templateChildNode));\n      }\n    }\n\n    // templateNode has no unprocessed node-macros - create output instance for the tempate node\n    generationTracer.pushTemplateNode(new SNodePointer(templateNode));\n    SNode outputNode = new SNode(templateNode.getConcept().getId());\n    GeneratorMappings mappings = myGenerator.getMappings();\n    mappings.addOutputNodeByInputAndTemplateNode(context.getInput(), templateNode, outputNode);\n    for (SNode historyInputNode : context.getInputHistory()) {\n      mappings.addOutputNodeByIndirectInputAndTemplateNode(historyInputNode, templateNode, outputNode);\n    }\n    mappings.addOutputNodeByInputNodeAndMappingName(context.getInput(), mappingName, outputNode);\n    mappings.addOutputNodeByTemplateNode(templateNode, outputNode);\n    jetbrains.mps.util.SNodeOperations.copyProperties(templateNode, outputNode);\n\n    SModel templateModel = templateNode.getModel();\n    for (SReference reference : templateNode.getReferences()) {\n      if (AttributeOperations.getLinkAttribute(templateNode, \"referenceMacro\", reference.getRole()) != null) {\n        continue;\n      }\n      SNode templateReferentNode = reference.getTargetNode();\n      if (templateReferentNode == null) {\n        myGenerator.getLogger().error(templateNode, \"cannot resolve reference in template model; role: \" + reference.getRole() + \" in \" + org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(templateNode));\n        continue;\n      }\n      if (templateReferentNode.getModel() == templateModel) { // internal reference\n        ReferenceInfo_TemplateNode refInfo = new ReferenceInfo_TemplateNode(\n          outputNode,\n          reference,\n          context);\n        PostponedReference postponedReference = new PostponedReference(\n          refInfo,\n          myGenerator\n        );\n        outputNode.setReference(postponedReference.getRole(), postponedReference);\n      } else {\n        outputNode.setReferenceTarget(reference.getRole(), templateReferentNode);\n      }\n    }\n\n    // process property and reference macros\n    List<SNode> templateChildNodes = new ArrayList<SNode>();\n    for (SNode templateChildNode : templateNode.getChildren()) {\n      String templateChildNodeConcept = templateChildNode.getConcept().getId();\n\n      if (templateChildNodeConcept.equals(RuleUtil.concept_PropertyMacro)) {\n        myReductionContext.getQueryExecutor().expandPropertyMacro(templateChildNode, context.getInput(), templateNode, outputNode, context);\n      } else if (templateChildNodeConcept.equals(RuleUtil.concept_ReferenceMacro)) {\n        ReferenceInfo_Macro refInfo = new ReferenceInfo_MacroNode(\n          outputNode, templateChildNode,\n          templateNode,\n          context, myReductionContext\n        );\n        PostponedReference postponedReference = new PostponedReference(\n          refInfo,\n          myGenerator\n        );\n        outputNode.setReference(postponedReference.getRole(), postponedReference);\n      } else if (!GeneratorUtilEx.isTemplateLanguageElement(templateChildNode)) {\n        templateChildNodes.add(templateChildNode);\n      }\n    }\n\n    // process children\n    try {\n      for (SNode templateChildNode : templateChildNodes) {\n        List<SNode> outputChildNodes = createOutputNodesForTemplateNode(null, templateChildNode, context, 0);\n        if (outputChildNodes != null) {\n          String role = templateChildNode.getRole_();\n          for (SNode outputChildNode : outputChildNodes) {\n            // check child\n            RoleValidationStatus status = myGenerator.validateChild(outputNode, role, outputChildNode);\n            if (status != null) {\n              status.reportProblem(false, \"\",\n                GeneratorUtil.describe(context.getInput(), \"input\"),\n                GeneratorUtil.describe(templateNode, \"parent in template\"),\n                GeneratorUtil.describe(templateChildNode, \"child in template\"));\n            }\n            outputNode.addChild(role, outputChildNode);\n          }\n        }\n      }\n    } finally {\n      generationTracer.pushOutputNode(GenerationTracerUtil.getSNodePointer(myOutputModel, outputNode));\n      generationTracer.closeTemplateNode(new SNodePointer(templateNode));\n    }\n    return Collections.singletonList(outputNode);\n  }","id":88659,"modified_method":"@Nullable\n  private List<SNode> applyTemplate(String mappingName,\n                    SNode templateNode,\n                    @NotNull TemplateContext context,\n                    int nodeMacrosToSkip)\n    throws DismissTopMappingRuleException, GenerationFailureException, GenerationCanceledException {\n\n    assert mappingName == null || mappingName.equals(context.getInputName());\n\n    int macroCount = 0;\n    // templateNode has unprocessed node-macros?\n    for (SNode templateChildNode : templateNode.getChildren()) {\n      if (!(templateChildNode.getConcept().isSubConceptOf(SConceptRepository.getInstance().getConcept(RuleUtil.concept_NodeMacro))))\n        continue;\n      macroCount++;\n      if (macroCount <= nodeMacrosToSkip) continue;\n      myTracer.pushMacro(new SNodePointer(templateChildNode));\n      try {\n        return applyMacro(templateChildNode, templateNode, context, nodeMacrosToSkip, mappingName);\n      } finally {\n        myTracer.closeMacro(new SNodePointer(templateChildNode));\n      }\n    }\n\n    // templateNode has no unprocessed node-macros - create output instance for the tempate node\n    myTracer.pushTemplateNode(new SNodePointer(templateNode));\n    SNode outputNode = new SNode(templateNode.getConcept().getId());\n    GeneratorMappings mappings = myGenerator.getMappings();\n    mappings.addOutputNodeByInputAndTemplateNode(context.getInput(), templateNode, outputNode);\n    for (SNode historyInputNode : context.getInputHistory()) {\n      mappings.addOutputNodeByIndirectInputAndTemplateNode(historyInputNode, templateNode, outputNode);\n    }\n    mappings.addOutputNodeByInputNodeAndMappingName(context.getInput(), mappingName, outputNode);\n    mappings.addOutputNodeByTemplateNode(templateNode, outputNode);\n    jetbrains.mps.util.SNodeOperations.copyProperties(templateNode, outputNode);\n\n    SModel templateModel = templateNode.getModel();\n    for (SReference reference : templateNode.getReferences()) {\n      if (AttributeOperations.getLinkAttribute(templateNode, \"referenceMacro\", reference.getRole()) != null) {\n        continue;\n      }\n      SNode templateReferentNode = reference.getTargetNode();\n      if (templateReferentNode == null) {\n        myGenerator.getLogger().error(templateNode, \"cannot resolve reference in template model; role: \" + reference.getRole() + \" in \" + org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(templateNode));\n        continue;\n      }\n      if (templateReferentNode.getModel() == templateModel) { // internal reference\n        ReferenceInfo_TemplateNode refInfo = new ReferenceInfo_TemplateNode(\n          outputNode,\n          reference,\n          context);\n        PostponedReference postponedReference = new PostponedReference(\n          refInfo,\n          myGenerator\n        );\n        outputNode.setReference(postponedReference.getRole(), postponedReference);\n      } else {\n        outputNode.setReferenceTarget(reference.getRole(), templateReferentNode);\n      }\n    }\n\n    // process property and reference macros\n    List<SNode> templateChildNodes = new ArrayList<SNode>();\n    for (SNode templateChildNode : templateNode.getChildren()) {\n      String templateChildNodeConcept = templateChildNode.getConcept().getId();\n\n      if (templateChildNodeConcept.equals(RuleUtil.concept_PropertyMacro)) {\n        myReductionContext.getQueryExecutor().expandPropertyMacro(templateChildNode, context.getInput(), templateNode, outputNode, context);\n      } else if (templateChildNodeConcept.equals(RuleUtil.concept_ReferenceMacro)) {\n        ReferenceInfo_Macro refInfo = new ReferenceInfo_MacroNode(\n          outputNode, templateChildNode,\n          templateNode,\n          context, myReductionContext\n        );\n        PostponedReference postponedReference = new PostponedReference(\n          refInfo,\n          myGenerator\n        );\n        outputNode.setReference(postponedReference.getRole(), postponedReference);\n      } else if (!GeneratorUtilEx.isTemplateLanguageElement(templateChildNode)) {\n        templateChildNodes.add(templateChildNode);\n      }\n    }\n\n    // process children\n    try {\n      for (SNode templateChildNode : templateChildNodes) {\n        List<SNode> outputChildNodes = applyTemplate(null, templateChildNode, context, 0);\n        if (outputChildNodes != null) {\n          String role = templateChildNode.getRoleInParent();\n          for (SNode outputChildNode : outputChildNodes) {\n            // check child\n            RoleValidationStatus status = myGenerator.validateChild(outputNode, role, outputChildNode);\n            if (status != null) {\n              status.reportProblem(false, \"\",\n                GeneratorUtil.describe(context.getInput(), \"input\"),\n                GeneratorUtil.describe(templateNode, \"parent in template\"),\n                GeneratorUtil.describe(templateChildNode, \"child in template\"));\n            }\n            outputNode.addChild(role, outputChildNode);\n          }\n        }\n      }\n    } finally {\n      myTracer.pushOutputNode(GenerationTracerUtil.getSNodePointer(myOutputModel, outputNode));\n      myTracer.closeTemplateNode(new SNodePointer(templateNode));\n    }\n    return Collections.singletonList(outputNode);\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private List<SNode> createOutputNodesForExternalTemplateNode(String mappingName,\n                                                               SNode templateNode,\n                                                               TemplateContext context)\n    throws\n    DismissTopMappingRuleException,\n    GenerationFailureException, GenerationCanceledException {\n    TemplateProcessor templateProcessor = new TemplateProcessor(myGenerator, myReductionContext);\n    return templateProcessor.createOutputNodesForTemplateNode(mappingName, templateNode, context, 0);\n  }","id":88660,"modified_method":"@Nullable\n  private List<SNode> applyExternalTemplate(String mappingName,\n                        SNode templateNode,\n                        TemplateContext context)\n    throws\n    DismissTopMappingRuleException,\n    GenerationFailureException, GenerationCanceledException {\n    TemplateProcessor templateProcessor = new TemplateProcessor(myGenerator, myReductionContext);\n    return templateProcessor.applyTemplate(mappingName, templateNode, context, 0);\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateProcessor(@NotNull TemplateGenerator generator, @NotNull ReductionContext reductionContext) {\n    myGenerator = generator;\n    myReductionContext = reductionContext;\n    myOutputModel = myGenerator.getOutputModel();\n  }","id":88661,"modified_method":"public TemplateProcessor(@NotNull TemplateGenerator generator, @NotNull ReductionContext reductionContext) {\n    myGenerator = generator;\n    myReductionContext = reductionContext;\n    myOutputModel = myGenerator.getOutputModel();\n    myTracer = myGenerator.getGenerationTracer();\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public List<SNode> processTemplateNode(String mappingName, SNode templateNode, @NotNull TemplateContext context)\n    throws DismissTopMappingRuleException, TemplateProcessingFailureException, GenerationFailureException, GenerationCanceledException {\n    IGeneratorLogger logger = myGenerator.getLogger();\n    if (myGenerator.isIncremental()) {\n      // turn off tracing\n      NodeReadEventsCaster.setNodesReadListener(null);\n    }\n    try {\n      if (myGenerator.getProgressMonitor().isCanceled()) {\n        if (myGenerator.getGenerationTracer().isTracing() && logger.needsInfo()) {\n          logger.info(\"generation canceled when processing branch:\");\n          GeneratorUtil.logCurrentGenerationBranch(logger, myGenerator.getGenerationTracer(), false);\n        }\n        throw new GenerationCanceledException();\n      }\n\n      try {\n        List<SNode> outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, context.subContext(mappingName), 0);\n        if (outputNodes == null) {\n          throw new TemplateProcessingFailureException();\n        }\n        return outputNodes;\n      } catch (StackOverflowError e) {\n        // this is critical\n        logger.error(\"generation thread run out of stack space :(\");\n        if (myGenerator.getGenerationTracer().isTracing()) {\n          logger.error(\"failed branch was:\");\n          GeneratorUtil.logCurrentGenerationBranch(logger, myGenerator.getGenerationTracer(), true);\n        } else {\n          logger.error(\"try to increase JVM stack size (-Xss option)\");\n          logger.error(\"to get more diagnostic generate model with the 'save transient models' option\");\n        }\n        myGenerator.showErrorMessage(context.getInput(), templateNode, \"couldn't process template\");\n        throw new GenerationFailureException(e);\n      }\n    } finally {\n      if (myGenerator.isIncremental()) {\n        // restore tracing\n        NodeReadEventsCaster.removeNodesReadListener();\n      }\n    }\n  }","id":88662,"modified_method":"@NotNull\n  public List<SNode> apply(String mappingName, SNode templateNode, @NotNull TemplateContext context)\n    throws DismissTopMappingRuleException, TemplateProcessingFailureException, GenerationFailureException, GenerationCanceledException {\n    IGeneratorLogger logger = myGenerator.getLogger();\n    if (myGenerator.isIncremental()) {\n      // turn off tracing\n      NodeReadEventsCaster.setNodesReadListener(null);\n    }\n    try {\n      if (myGenerator.getProgressMonitor().isCanceled()) {\n        if (myTracer.isTracing() && logger.needsInfo()) {\n          logger.info(\"generation canceled when processing branch:\");\n          GeneratorUtil.logCurrentGenerationBranch(logger, myTracer, false);\n        }\n        throw new GenerationCanceledException();\n      }\n\n      try {\n        List<SNode> outputNodes = applyTemplate(mappingName, templateNode, context.subContext(mappingName), 0);\n        if (outputNodes == null) {\n          throw new TemplateProcessingFailureException();\n        }\n        return outputNodes;\n      } catch (StackOverflowError e) {\n        // this is critical\n        logger.error(\"generation thread run out of stack space :(\");\n        if (myTracer.isTracing()) {\n          logger.error(\"failed branch was:\");\n          GeneratorUtil.logCurrentGenerationBranch(logger, myTracer, true);\n        } else {\n          logger.error(\"try to increase JVM stack size (-Xss option)\");\n          logger.error(\"to get more diagnostic generate model with the 'save transient models' option\");\n        }\n        myGenerator.showErrorMessage(context.getInput(), templateNode, \"couldn't process template\");\n        throw new GenerationFailureException(e);\n      }\n    } finally {\n      if (myGenerator.isIncremental()) {\n        // restore tracing\n        NodeReadEventsCaster.removeNodesReadListener();\n      }\n    }\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private List<SNode> createOutputNodesForTemplateNodeWithMacro(SNode macro, SNode templateNode, @NotNull TemplateContext templateContext, int nodeMacrosToSkip, String outerMappingName) throws DismissTopMappingRuleException, GenerationFailureException, GenerationCanceledException {\n    String macroConceptFQName = macro.getConcept().getId();\n    IGenerationTracer generationTracer = myGenerator.getGenerationTracer();\n    List<SNode> outputNodes = new ArrayList<SNode>();\n    String mappingName = GeneratorUtilEx.getMappingName(macro, outerMappingName);\n\n    if (macroConceptFQName.equals(RuleUtil.concept_LoopMacro)) {\n      // $LOOP$\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != templateContext.getInput());\n        if (inputChanged) {\n          generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n        try {\n          List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName, newInputNode), nodeMacrosToSkip + 1);\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        } finally {\n          if (inputChanged) {\n            generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n          }\n        }\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_CopySrcNodeMacro) || macroConceptFQName.equals(RuleUtil.concept_CopySrcListMacro)) {\n      // $COPY-SRC$ / $COPY-SRCL$\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      SNodePointer templateNodeRef = templateNode == null ? null : new SNodePointer(templateNode);\n      for (SNode newInputNode : newInputNodes) {\n        Collection<SNode> _outputNodes =\n          newInputNode.getModel() == myGenerator.getInputModel() && newInputNode.getModel() != null\n            ? myGenerator.copyNodeFromInputNode(mappingName, templateNodeRef, null, newInputNode, myReductionContext, new boolean[]{false})\n            : myGenerator.copyNodeFromExternalNode(mappingName, templateNodeRef, null, newInputNode, myReductionContext);\n        if (_outputNodes != null) {\n          // check node languages : prevent 'input node' query from returning node, which language was not counted when\n          // planning the generation steps.\n          for (SNode outputNode : _outputNodes) {\n            Language outputNodeLang = jetbrains.mps.util.SNodeOperations.getLanguage(outputNode);\n            if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(outputNodeLang)) {\n              if (!outputNodeLang.getGenerators().isEmpty()) {\n                myGenerator.getLogger().error(outputNode, \"language of output node is '\" + outputNodeLang.getModuleFqName() + \"' - this language did not show up when computing generation steps!\",\n                  GeneratorUtil.describe(macro, \"template\"),\n                  GeneratorUtil.describe(templateContext.getInput(), \"input\"),\n                  new ProblemDescription(null, \"workaround: add the language '\" + outputNodeLang.getModuleFqName() + \"' to list of 'Languages Engaged On Generation' in model '\" + myGenerator.getGeneratorSessionContext().getOriginalInputModel().getSModelFqName() + \"'\"));\n              }\n            }\n          }\n          outputNodes.addAll(_outputNodes);\n        }\n      }\n      return outputNodes;\n    } else if (macroConceptFQName.equals(RuleUtil.concept_InsertMacro)) {\n      // $INSERT$\n      SNode child = InputQueryUtil.getNodeToInsert(macro, templateContext.subContext(mappingName), myReductionContext, myGenerator);\n      if (child != null) {\n        // check node languages : prevent 'insert' query from returnning node, which language was not counted when\n        // planning the generation steps.\n        Language childLang = jetbrains.mps.util.SNodeOperations.getLanguage(child);\n        if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(childLang)) {\n          if (!childLang.getGenerators().isEmpty()) {\n            myGenerator.getLogger().error(child, \"language of output node is '\" + childLang.getModuleFqName() + \"' - this language did not show up when computing generation steps!\",\n              GeneratorUtil.describe(macro, \"template\"),\n              GeneratorUtil.describe(templateContext.getInput(), \"input\"),\n              new ProblemDescription(null, \"workaround: add the language '\" + childLang.getModuleFqName() + \"' to list of 'Languages Engaged On Generation' in model '\" + myGenerator.getGeneratorSessionContext().getOriginalInputModel().getSModelFqName() + \"'\"));\n          }\n        }\n\n        if (child.getModel() != null) {\n          // must be \"in air\"\n          child = CopyUtil.copy(child);\n        }\n        // replace references back to input model\n        validateReferences(child, templateContext.getInput());\n\n        // label\n        myGenerator.getMappings().addOutputNodeByInputNodeAndMappingName(templateContext.getInput(), mappingName, child);\n        outputNodes.add(child);\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_WeaveMacro)) {\n      // $WEAVE$\n      List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null && _outputNodes.size() > 0) {\n\n        if (_outputNodes.size() == 1) {\n          SNode contextNode = _outputNodes.get(0);\n\n          List<SNode> nodesToWeave = getNewInputNodes(macro, templateContext);\n          for (SNode node : nodesToWeave) {\n            try {\n              generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(node));\n              generationTracer.pushRuleConsequence(new SNodePointer(macro));\n              SNode consequence = RuleUtil.getWeaveMacro_Consequence(macro);\n              if (consequence == null) {\n                myGenerator.showErrorMessage(templateContext.getInput(), macro, \"couldn't evaluate weave macro: no consequence\");\n                break;\n              }\n\n              SNode template = RuleUtil.getTemplateDeclarationReference_Template(consequence);\n              weaveMacro(template, contextNode, templateContext.subContext(null, node), macro);\n            } finally {\n              generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(node));\n            }\n          }\n        } else {\n          myGenerator.getLogger().error(templateContext.getInput(), \"cannot apply $WEAVE$ to a list of nodes\",\n            GeneratorUtil.describe(macro, \"template\"),\n            GeneratorUtil.describe(templateContext.getInput(), \"input\"));\n        }\n\n\n        outputNodes.addAll(_outputNodes);\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_LabelMacro)) {\n      // $LABEL$\n      List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_VarMacro)) {\n      // $VAR$\n      String varName = RuleUtil.getVarMacro_Name(macro);\n      Object varValue = myReductionContext.getQueryExecutor().evaluateVariableQuery(templateContext.getInput(), RuleUtil.getVarMacro_Query(macro), templateContext);\n      TemplateContext newContext = templateContext.subContext(Collections.singletonMap(varName, varValue));\n\n      List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_IfMacro)) {\n      // $IF$\n      List<SNode> _outputNodes = null;\n      if (myReductionContext.getQueryExecutor().checkConditionForIfMacro(templateContext.getInput(), macro, templateContext)) {\n        _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      } else {\n        // alternative consequence\n        SNode altConsequence = RuleUtil.getIfMacro_AlternativeConsequence(macro);\n        if (altConsequence != null) {\n          try {\n            List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(altConsequence, templateContext.getInput(), macro, myReductionContext, myGenerator);\n            if (nodeAndMappingNamePairs == null) {\n              myGenerator.showErrorMessage(templateContext.getInput(), null, macro, \"error processing $IF$/alternative\");\n              return null;\n            }\n\n            for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n              SNode altTemplateNode = nodeAndMappingNamePair.o1;\n              String innerMappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;\n              List<SNode> __outputNodes = createOutputNodesForExternalTemplateNode(innerMappingName, altTemplateNode, templateContext.subContext(innerMappingName));\n              if (__outputNodes != null) {\n                if (_outputNodes == null) _outputNodes = new ArrayList<SNode>();\n                _outputNodes.addAll(__outputNodes);\n              }\n            }\n          } catch (AbandonRuleInputException e) {\n            // it's ok. just ignore\n          }\n        }\n      }\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_MapSrcNodeMacro) || macroConceptFQName.equals(RuleUtil.concept_MapSrcListMacro)) {\n      // $MAP-SRC$ or $MAP-SRCL$\n      SNode macro_mapperFunction = RuleUtil.getMapSrc_MapperFunction(macro);\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != templateContext.getInput());\n        if (inputChanged) {\n          generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n        try {\n          TemplateContext newcontext = templateContext.subContext(mappingName, newInputNode);\n          if (macro_mapperFunction != null) {\n            SNode childToReplaceLater = SModelUtil_new.instantiateConceptDeclaration(templateNode.getConcept().getId(), myOutputModel, myGenerator.getScope(), false);\n            generationTracer.pushOutputNodeToReplaceLater(childToReplaceLater);\n            outputNodes.add(childToReplaceLater);\n            // execute the 'mapper' function later\n            myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(\n              macro, childToReplaceLater, newcontext, myReductionContext);\n          } else {\n            List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newcontext, nodeMacrosToSkip + 1);\n            if (_outputNodes != null) {\n              outputNodes.addAll(_outputNodes);\n              // do post-processing here (it's not really a post-processing because model is not completed yet - output nodes are not added to parent node).\n              for (SNode outputNode : _outputNodes) {\n                myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroPostProcChange(\n                  macro, outputNode, newcontext, myReductionContext);\n              }\n            }\n          }\n        } finally {\n          if (inputChanged) {\n            generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n          }\n        }\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_SwitchMacro)) {\n      // $SWITCH$\n      SNode templateSwitch = RuleUtil.getSwitchMacro_TemplateSwitch(macro);\n      if (templateSwitch == null) {\n        myGenerator.showErrorMessage(templateContext.getInput(), macro, \"error processing $SWITCH$ - bad TemplateSwitch reference\");\n        return null;\n      }\n\n      final SNodePointer switchPtr = new SNodePointer(templateSwitch);\n      SNode newInputNode = getNewInputNode(macro, templateContext);\n      if (newInputNode == null) {\n        TemplateSwitchMapping tswitch = myGenerator.getSwitch(switchPtr);\n        if (tswitch != null) {\n          tswitch.processNull(new TemplateExecutionEnvironmentImpl(myGenerator, myReductionContext, myGenerator.getOperationContext(), myGenerator.getGenerationTracer()), switchPtr, templateContext);\n        }\n        return Collections.emptyList(); // skip template\n      }\n\n      boolean inputChanged = (newInputNode != templateContext.getInput());\n      if (inputChanged) {\n        generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n      }\n      generationTracer.pushSwitch(new SNodePointer(templateSwitch));\n      try {\n        final TemplateContext switchContext = templateContext.subContext(mappingName, newInputNode);\n\n        Collection<SNode> collection = myGenerator.tryToReduce(switchContext, switchPtr, mappingName, myReductionContext);\n        if (collection == null) {\n          // try the default case\n          TemplateSwitchMapping tswitch = myGenerator.getSwitch(switchPtr);\n          if (tswitch != null) {\n            TemplateExecutionEnvironment environment = new TemplateExecutionEnvironmentImpl(myGenerator, myReductionContext, myGenerator.getOperationContext(), myGenerator.getGenerationTracer());\n            try {\n              collection = tswitch.applyDefault(environment, switchPtr, mappingName, switchContext);\n            } catch (GenerationException e) {\n              if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n              if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n              if (e instanceof DismissTopMappingRuleException) throw (DismissTopMappingRuleException) e;\n              myGenerator.showErrorMessage(null, tswitch.getSwitchNode().getNode(), \"internal error in switch.applyDefault: \" + e.toString());\n            }\n          }\n\n          // no switch-case found for the inputNode - continue with templateNode under the $switch$\n          if (collection == null) {\n            collection = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName, newInputNode), nodeMacrosToSkip + 1);\n          }\n        }\n\n        if (collection != null) {\n          outputNodes.addAll(collection);\n        }\n\n      } finally {\n        if (inputChanged) {\n          generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_IncludeMacro)) {\n      // $INCLUDE$\n      SNode newInputNode = getNewInputNode(macro, templateContext);\n      if (newInputNode == null) {\n        return outputNodes; // skip template\n      }\n\n      SNode includeTemplate = RuleUtil.getIncludeMacro_Template(macro);\n      if (includeTemplate == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$ : no 'include template'\");\n        return null;\n      }\n\n      final String[] parameterNames = RuleUtil.getTemplateDeclarationParameterNames(includeTemplate);\n      if (parameterNames == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$: target template is broken\");\n        return null;\n      }\n\n      for (String name : parameterNames) {\n        if (!templateContext.hasVariable(name)) {\n          myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$: parameter `\" + name + \"' is missing\");\n        }\n      }\n/*\n      TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(includeTemplate, newInputNode, macro, myGenerator);\n      if (fragment == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$\");\n        return null;\n      }\n*/\n      List<SNode> fragments = GeneratorUtilEx.getTemplateFragments(includeTemplate);\n      if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments, includeTemplate, newInputNode, macro, myGenerator)) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$\");\n        return null;\n      }\n\n      boolean inputChanged = (newInputNode != templateContext.getInput());\n      if (inputChanged) {\n        generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n      }\n      generationTracer.pushTemplateNode(new SNodePointer(includeTemplate));\n\n      try {\n        for (SNode fragment : fragments) {\n          SNode templateForInclude = fragment.getParent();\n          mappingName = GeneratorUtilEx.getMappingName(fragment, mappingName);\n          List<SNode> _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, templateForInclude, templateContext.subContext(mappingName, newInputNode));\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n      }\n\n      return outputNodes;\n    } else if (macroConceptFQName.equals(RuleUtil.concept_TemplateCallMacro)) {\n      // $CALL$\n      SNode newInputNode = getNewInputNode(macro, templateContext);\n      if (newInputNode == null) {\n        return outputNodes; // skip template\n      }\n\n      SNode template = RuleUtil.getCallMacro_Template(macro);\n      if (template == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $CALL$ : no 'include template'\");\n        return null;\n      }\n\n      TemplateContext newcontext = GeneratorUtil.createTemplateCallContext(templateContext.getInput(), templateContext, myReductionContext, macro, newInputNode, myGenerator);\n\n/*\n      TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(template, newInputNode, macro, myGenerator);\n      if (fragment == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $CALL$\");\n        return null;\n      }\n*/\n      List<SNode> fragments = GeneratorUtilEx.getTemplateFragments(template);\n      if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments, template, newInputNode, macro, myGenerator)) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $CALL$\");\n        return null;\n      }\n\n      boolean inputChanged = (newInputNode != templateContext.getInput());\n      if (inputChanged) {\n        generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n      }\n      generationTracer.pushTemplateNode(new SNodePointer(template));\n\n      try {\n        for (SNode fragment : fragments) {\n          SNode templateForInclude = fragment.getParent();\n          mappingName = GeneratorUtilEx.getMappingName(fragment, mappingName);\n          List<SNode> _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, templateForInclude, newcontext.subContext(mappingName));\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n      }\n\n      return outputNodes;\n    } else if (macroConceptFQName.equals(RuleUtil.concept_TraceMacro)) {\n      // $TRACE$\n      SNode inputNode = getNewInputNode(macro, templateContext);\n\n      List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null) {\n        outputNodes.addAll(_outputNodes);\n        for (SNode outputNode : _outputNodes) {\n          TracingUtil.fillOriginalNode(inputNode, outputNode, myGenerator.getGeneratorSessionContext().getOriginalInputModel() == inputNode.getModel());\n        }\n      }\n      return outputNodes;\n    } else {\n\n      // $$\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != templateContext.getInput());\n        if (inputChanged) {\n          generationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n        try {\n          List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, templateContext.subContext(mappingName, newInputNode), nodeMacrosToSkip + 1);\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        } finally {\n          if (inputChanged) {\n            generationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n          }\n        }\n      }\n      return outputNodes;\n    }\n  }","id":88663,"modified_method":"@Nullable\n  private List<SNode> applyMacro(SNode macro, SNode templateNode, @NotNull TemplateContext templateContext, int nodeMacrosToSkip, String outerMappingName) throws DismissTopMappingRuleException, GenerationFailureException, GenerationCanceledException {\n    String macroConceptFQName = macro.getConcept().getId();\n    List<SNode> outputNodes = new ArrayList<SNode>();\n    String mappingName = GeneratorUtilEx.getMappingName(macro, outerMappingName);\n\n    if (macroConceptFQName.equals(RuleUtil.concept_LoopMacro)) {\n      // $LOOP$\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != templateContext.getInput());\n        if (inputChanged) {\n          myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n        try {\n          List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName, newInputNode), nodeMacrosToSkip + 1);\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        } finally {\n          if (inputChanged) {\n            myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n          }\n        }\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_CopySrcNodeMacro) || macroConceptFQName.equals(RuleUtil.concept_CopySrcListMacro)) {\n      // $COPY-SRC$ / $COPY-SRCL$\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      SNodePointer templateNodeRef = templateNode == null ? null : new SNodePointer(templateNode);\n      for (SNode newInputNode : newInputNodes) {\n        Collection<SNode> _outputNodes =\n          newInputNode.getModel() == myGenerator.getInputModel() && newInputNode.getModel() != null\n            ? myGenerator.copyNodeFromInputNode(mappingName, templateNodeRef, null, newInputNode, myReductionContext, new boolean[]{false})\n            : myGenerator.copyNodeFromExternalNode(mappingName, templateNodeRef, null, newInputNode, myReductionContext);\n        if (_outputNodes != null) {\n          // check node languages : prevent 'input node' query from returning node, which language was not counted when\n          // planning the generation steps.\n          for (SNode outputNode : _outputNodes) {\n            Language outputNodeLang = jetbrains.mps.util.SNodeOperations.getLanguage(outputNode);\n            if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(outputNodeLang)) {\n              if (!outputNodeLang.getGenerators().isEmpty()) {\n                myGenerator.getLogger().error(outputNode, \"language of output node is '\" + outputNodeLang.getModuleFqName() + \"' - this language did not show up when computing generation steps!\",\n                  GeneratorUtil.describe(macro, \"template\"),\n                  GeneratorUtil.describe(templateContext.getInput(), \"input\"),\n                  new ProblemDescription(null, \"workaround: add the language '\" + outputNodeLang.getModuleFqName() + \"' to list of 'Languages Engaged On Generation' in model '\" + myGenerator.getGeneratorSessionContext().getOriginalInputModel().getSModelFqName() + \"'\"));\n              }\n            }\n          }\n          outputNodes.addAll(_outputNodes);\n        }\n      }\n      return outputNodes;\n    } else if (macroConceptFQName.equals(RuleUtil.concept_InsertMacro)) {\n      // $INSERT$\n      SNode child = InputQueryUtil.getNodeToInsert(macro, templateContext.subContext(mappingName), myReductionContext, myGenerator);\n      if (child != null) {\n        // check node languages : prevent 'insert' query from returnning node, which language was not counted when\n        // planning the generation steps.\n        Language childLang = jetbrains.mps.util.SNodeOperations.getLanguage(child);\n        if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(childLang)) {\n          if (!childLang.getGenerators().isEmpty()) {\n            myGenerator.getLogger().error(child, \"language of output node is '\" + childLang.getModuleFqName() + \"' - this language did not show up when computing generation steps!\",\n              GeneratorUtil.describe(macro, \"template\"),\n              GeneratorUtil.describe(templateContext.getInput(), \"input\"),\n              new ProblemDescription(null, \"workaround: add the language '\" + childLang.getModuleFqName() + \"' to list of 'Languages Engaged On Generation' in model '\" + myGenerator.getGeneratorSessionContext().getOriginalInputModel().getSModelFqName() + \"'\"));\n          }\n        }\n\n        if (child.getModel() != null) {\n          // must be \"in air\"\n          child = CopyUtil.copy(child);\n        }\n        // replace references back to input model\n        validateReferences(child, templateContext.getInput());\n\n        // label\n        myGenerator.getMappings().addOutputNodeByInputNodeAndMappingName(templateContext.getInput(), mappingName, child);\n        outputNodes.add(child);\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_WeaveMacro)) {\n      // $WEAVE$\n      List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null && _outputNodes.size() > 0) {\n\n        if (_outputNodes.size() == 1) {\n          SNode contextNode = _outputNodes.get(0);\n\n          List<SNode> nodesToWeave = getNewInputNodes(macro, templateContext);\n          for (SNode node : nodesToWeave) {\n            try {\n              myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(node));\n              myTracer.pushRuleConsequence(new SNodePointer(macro));\n              SNode consequence = RuleUtil.getWeaveMacro_Consequence(macro);\n              if (consequence == null) {\n                myGenerator.showErrorMessage(templateContext.getInput(), macro, \"couldn't evaluate weave macro: no consequence\");\n                break;\n              }\n\n              SNode template = RuleUtil.getTemplateDeclarationReference_Template(consequence);\n              weaveMacro(template, contextNode, templateContext.subContext(null, node), macro);\n            } finally {\n              myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(node));\n            }\n          }\n        } else {\n          myGenerator.getLogger().error(templateContext.getInput(), \"cannot apply $WEAVE$ to a list of nodes\",\n            GeneratorUtil.describe(macro, \"template\"),\n            GeneratorUtil.describe(templateContext.getInput(), \"input\"));\n        }\n\n\n        outputNodes.addAll(_outputNodes);\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_LabelMacro)) {\n      // $LABEL$\n      List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_VarMacro)) {\n      // $VAR$\n      String varName = RuleUtil.getVarMacro_Name(macro);\n      Object varValue = myReductionContext.getQueryExecutor().evaluateVariableQuery(templateContext.getInput(), RuleUtil.getVarMacro_Query(macro), templateContext);\n      TemplateContext newContext = templateContext.subContext(Collections.singletonMap(varName, varValue));\n\n      List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, newContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_IfMacro)) {\n      // $IF$\n      List<SNode> _outputNodes = null;\n      if (myReductionContext.getQueryExecutor().checkConditionForIfMacro(templateContext.getInput(), macro, templateContext)) {\n        _outputNodes = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      } else {\n        // alternative consequence\n        SNode altConsequence = RuleUtil.getIfMacro_AlternativeConsequence(macro);\n        if (altConsequence != null) {\n          try {\n            List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(altConsequence, templateContext.getInput(), macro, myReductionContext, myGenerator);\n            if (nodeAndMappingNamePairs == null) {\n              myGenerator.showErrorMessage(templateContext.getInput(), null, macro, \"error processing $IF$/alternative\");\n              return null;\n            }\n\n            for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n              SNode altTemplateNode = nodeAndMappingNamePair.o1;\n              String innerMappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;\n              List<SNode> __outputNodes = applyExternalTemplate(innerMappingName, altTemplateNode, templateContext.subContext(innerMappingName));\n              if (__outputNodes != null) {\n                if (_outputNodes == null) _outputNodes = new ArrayList<SNode>();\n                _outputNodes.addAll(__outputNodes);\n              }\n            }\n          } catch (AbandonRuleInputException e) {\n            // it's ok. just ignore\n          }\n        }\n      }\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_MapSrcNodeMacro) || macroConceptFQName.equals(RuleUtil.concept_MapSrcListMacro)) {\n      // $MAP-SRC$ or $MAP-SRCL$\n      SNode macro_mapperFunction = RuleUtil.getMapSrc_MapperFunction(macro);\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != templateContext.getInput());\n        if (inputChanged) {\n          myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n        try {\n          TemplateContext newcontext = templateContext.subContext(mappingName, newInputNode);\n          if (macro_mapperFunction != null) {\n            SNode childToReplaceLater = SModelUtil_new.instantiateConceptDeclaration(templateNode.getConcept().getId(), myOutputModel, myGenerator.getScope(), false);\n            myTracer.pushOutputNodeToReplaceLater(childToReplaceLater);\n            outputNodes.add(childToReplaceLater);\n            // execute the 'mapper' function later\n            myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(\n              macro, childToReplaceLater, newcontext, myReductionContext);\n          } else {\n            List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, newcontext, nodeMacrosToSkip + 1);\n            if (_outputNodes != null) {\n              outputNodes.addAll(_outputNodes);\n              // do post-processing here (it's not really a post-processing because model is not completed yet - output nodes are not added to parent node).\n              for (SNode outputNode : _outputNodes) {\n                myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroPostProcChange(\n                  macro, outputNode, newcontext, myReductionContext);\n              }\n            }\n          }\n        } finally {\n          if (inputChanged) {\n            myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n          }\n        }\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_SwitchMacro)) {\n      // $SWITCH$\n      SNode templateSwitch = RuleUtil.getSwitchMacro_TemplateSwitch(macro);\n      if (templateSwitch == null) {\n        myGenerator.showErrorMessage(templateContext.getInput(), macro, \"error processing $SWITCH$ - bad TemplateSwitch reference\");\n        return null;\n      }\n\n      final SNodePointer switchPtr = new SNodePointer(templateSwitch);\n      SNode newInputNode = getNewInputNode(macro, templateContext);\n      if (newInputNode == null) {\n        TemplateSwitchMapping tswitch = myGenerator.getSwitch(switchPtr);\n        if (tswitch != null) {\n          tswitch.processNull(new TemplateExecutionEnvironmentImpl(myGenerator, myReductionContext, myGenerator.getOperationContext(), myTracer), switchPtr, templateContext);\n        }\n        return Collections.emptyList(); // skip template\n      }\n\n      boolean inputChanged = (newInputNode != templateContext.getInput());\n      if (inputChanged) {\n        myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n      }\n      myTracer.pushSwitch(new SNodePointer(templateSwitch));\n      try {\n        final TemplateContext switchContext = templateContext.subContext(mappingName, newInputNode);\n\n        Collection<SNode> collection = myGenerator.tryToReduce(switchContext, switchPtr, mappingName, myReductionContext);\n        if (collection == null) {\n          // try the default case\n          TemplateSwitchMapping tswitch = myGenerator.getSwitch(switchPtr);\n          if (tswitch != null) {\n            TemplateExecutionEnvironment environment = new TemplateExecutionEnvironmentImpl(myGenerator, myReductionContext, myGenerator.getOperationContext(), myTracer);\n            try {\n              collection = tswitch.applyDefault(environment, switchPtr, mappingName, switchContext);\n            } catch (GenerationException e) {\n              if (e instanceof GenerationCanceledException) throw (GenerationCanceledException) e;\n              if (e instanceof GenerationFailureException) throw (GenerationFailureException) e;\n              if (e instanceof DismissTopMappingRuleException) throw (DismissTopMappingRuleException) e;\n              myGenerator.showErrorMessage(null, tswitch.getSwitchNode().getNode(), \"internal error in switch.applyDefault: \" + e.toString());\n            }\n          }\n\n          // no switch-case found for the inputNode - continue with templateNode under the $switch$\n          if (collection == null) {\n            collection = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName, newInputNode), nodeMacrosToSkip + 1);\n          }\n        }\n\n        if (collection != null) {\n          outputNodes.addAll(collection);\n        }\n\n      } finally {\n        if (inputChanged) {\n          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n      }\n      return outputNodes;\n\n    } else if (macroConceptFQName.equals(RuleUtil.concept_IncludeMacro)) {\n      // $INCLUDE$\n      SNode newInputNode = getNewInputNode(macro, templateContext);\n      if (newInputNode == null) {\n        return outputNodes; // skip template\n      }\n\n      SNode includeTemplate = RuleUtil.getIncludeMacro_Template(macro);\n      if (includeTemplate == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$ : no 'include template'\");\n        return null;\n      }\n\n      final String[] parameterNames = RuleUtil.getTemplateDeclarationParameterNames(includeTemplate);\n      if (parameterNames == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$: target template is broken\");\n        return null;\n      }\n\n      for (String name : parameterNames) {\n        if (!templateContext.hasVariable(name)) {\n          myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$: parameter `\" + name + \"' is missing\");\n        }\n      }\n/*\n      TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(includeTemplate, newInputNode, macro, myGenerator);\n      if (fragment == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$\");\n        return null;\n      }\n*/\n      List<SNode> fragments = GeneratorUtilEx.getTemplateFragments(includeTemplate);\n      if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments, includeTemplate, newInputNode, macro, myGenerator)) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $INCLUDE$\");\n        return null;\n      }\n\n      boolean inputChanged = (newInputNode != templateContext.getInput());\n      if (inputChanged) {\n        myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n      }\n      myTracer.pushTemplateNode(new SNodePointer(includeTemplate));\n\n      try {\n        for (SNode fragment : fragments) {\n          SNode templateForInclude = fragment.getParent();\n          mappingName = GeneratorUtilEx.getMappingName(fragment, mappingName);\n          List<SNode> _outputNodes = applyExternalTemplate(mappingName, templateForInclude, templateContext.subContext(mappingName, newInputNode));\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n      }\n\n      return outputNodes;\n    } else if (macroConceptFQName.equals(RuleUtil.concept_TemplateCallMacro)) {\n      // $CALL$\n      SNode newInputNode = getNewInputNode(macro, templateContext);\n      if (newInputNode == null) {\n        return outputNodes; // skip template\n      }\n\n      SNode template = RuleUtil.getCallMacro_Template(macro);\n      if (template == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $CALL$ : no 'include template'\");\n        return null;\n      }\n\n      TemplateContext newcontext = GeneratorUtil.createTemplateCallContext(templateContext.getInput(), templateContext, myReductionContext, macro, newInputNode, myGenerator);\n\n/*\n      TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(template, newInputNode, macro, myGenerator);\n      if (fragment == null) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $CALL$\");\n        return null;\n      }\n*/\n      List<SNode> fragments = GeneratorUtilEx.getTemplateFragments(template);\n      if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments, template, newInputNode, macro, myGenerator)) {\n        myGenerator.showErrorMessage(newInputNode, null, macro, \"error processing $CALL$\");\n        return null;\n      }\n\n      boolean inputChanged = (newInputNode != templateContext.getInput());\n      if (inputChanged) {\n        myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n      }\n      myTracer.pushTemplateNode(new SNodePointer(template));\n\n      try {\n        for (SNode fragment : fragments) {\n          SNode templateForInclude = fragment.getParent();\n          mappingName = GeneratorUtilEx.getMappingName(fragment, mappingName);\n          List<SNode> _outputNodes = applyExternalTemplate(mappingName, templateForInclude, newcontext.subContext(mappingName));\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n      }\n\n      return outputNodes;\n    } else if (macroConceptFQName.equals(RuleUtil.concept_TraceMacro)) {\n      // $TRACE$\n      SNode inputNode = getNewInputNode(macro, templateContext);\n\n      List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName), nodeMacrosToSkip + 1);\n      if (_outputNodes != null) {\n        outputNodes.addAll(_outputNodes);\n        for (SNode outputNode : _outputNodes) {\n          TracingUtil.fillOriginalNode(inputNode, outputNode, myGenerator.getGeneratorSessionContext().getOriginalInputModel() == inputNode.getModel());\n        }\n      }\n      return outputNodes;\n    } else {\n\n      // $$\n      List<SNode> newInputNodes = getNewInputNodes(macro, templateContext);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != templateContext.getInput());\n        if (inputChanged) {\n          myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n        }\n        try {\n          List<SNode> _outputNodes = applyTemplate(mappingName, templateNode, templateContext.subContext(mappingName, newInputNode), nodeMacrosToSkip + 1);\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        } finally {\n          if (inputChanged) {\n            myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));\n          }\n        }\n      }\n      return outputNodes;\n    }\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void weaveMacro(SNode template, SNode outputContextNode, @NotNull TemplateContext context, SNode macro)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (template == null) {\n      myGenerator.showErrorMessage(context.getInput(), macro, \"couldn't evaluate weave macro: no template\");\n      return;\n    }\n\n    List<SNode> templateFragments = GeneratorUtilEx.getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      myGenerator.showErrorMessage(context.getInput(), template, macro, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    TemplateWeavingRuleInterpreted.checkTemplateFragmentsForWeaving(template, templateFragments, myGenerator);\n\n    // for each template fragment create output nodes\n    TemplateProcessor templateProcessor = new TemplateProcessor(myGenerator, myReductionContext);\n    for (SNode templateFragment : templateFragments) {\n      SNode templateFragmentNode = templateFragment.getParent();\n      SNode contextParentNode = null;\n      try {\n        contextParentNode = myReductionContext.getQueryExecutor().getContextNodeForTemplateFragment(templateFragmentNode, outputContextNode, context);\n      } catch (Exception e) {\n        myGenerator.getLogger().handleException(e);\n      }\n      if (contextParentNode != null) {\n        try {\n          List<SNode> outputNodesToWeave = templateProcessor.processTemplateNode(\n            GeneratorUtilEx.getMappingName(templateFragment, null),\n            templateFragmentNode, context);\n          String childRole = templateFragmentNode.getRole_();\n\n          TemplateExecutionEnvironment env = new TemplateExecutionEnvironmentImpl(myGenerator, myReductionContext, null, myGenerator.getGenerationTracer());\n          for (SNode outputNodeToWeave : outputNodesToWeave) {\n            env.weaveNode(contextParentNode, childRole, outputNodeToWeave, new SNodePointer(templateFragment), context.getInput());\n          }\n        } catch (DismissTopMappingRuleException e) {\n          myGenerator.showErrorMessage(context.getInput(), templateFragment, macro, \"wrong template: dismission in weave macro is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          // FIXME\n          myGenerator.showErrorMessage(context.getInput(), templateFragment, macro, \"error processing template fragment\");\n          myGenerator.getLogger().info(contextParentNode, \" -- was output context node:\");\n        }\n      } else {\n        myGenerator.showErrorMessage(context.getInput(), templateFragment, macro, \"couldn't define 'context' for template fragment\");\n      }\n    }\n  }","id":88664,"modified_method":"private void weaveMacro(SNode template, SNode outputContextNode, @NotNull TemplateContext context, SNode macro)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (template == null) {\n      myGenerator.showErrorMessage(context.getInput(), macro, \"couldn't evaluate weave macro: no template\");\n      return;\n    }\n\n    List<SNode> templateFragments = GeneratorUtilEx.getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      myGenerator.showErrorMessage(context.getInput(), template, macro, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    TemplateWeavingRuleInterpreted.checkTemplateFragmentsForWeaving(template, templateFragments, myGenerator);\n\n    // for each template fragment create output nodes\n    TemplateProcessor templateProcessor = new TemplateProcessor(myGenerator, myReductionContext);\n    for (SNode templateFragment : templateFragments) {\n      SNode templateFragmentNode = templateFragment.getParent();\n      SNode contextParentNode = null;\n      try {\n        contextParentNode = myReductionContext.getQueryExecutor().getContextNodeForTemplateFragment(templateFragmentNode, outputContextNode, context);\n      } catch (Exception e) {\n        myGenerator.getLogger().handleException(e);\n      }\n      if (contextParentNode != null) {\n        try {\n          List<SNode> outputNodesToWeave = templateProcessor.apply(\n            GeneratorUtilEx.getMappingName(templateFragment, null),\n            templateFragmentNode, context);\n          String childRole = templateFragmentNode.getRole_();\n\n          TemplateExecutionEnvironment env = new TemplateExecutionEnvironmentImpl(myGenerator, myReductionContext, null, myTracer);\n          for (SNode outputNodeToWeave : outputNodesToWeave) {\n            env.weaveNode(contextParentNode, childRole, outputNodeToWeave, new SNodePointer(templateFragment), context.getInput());\n          }\n        } catch (DismissTopMappingRuleException e) {\n          myGenerator.showErrorMessage(context.getInput(), templateFragment, macro, \"wrong template: dismission in weave macro is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          // FIXME\n          myGenerator.showErrorMessage(context.getInput(), templateFragment, macro, \"error processing template fragment\");\n          myGenerator.getLogger().info(contextParentNode, \" -- was output context node:\");\n        }\n      } else {\n        myGenerator.showErrorMessage(context.getInput(), templateFragment, macro, \"couldn't define 'context' for template fragment\");\n      }\n    }\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private Collection<SNode> apply(SNode inputNode, @NotNull GeneratedMatchingPattern pattern, @NotNull TemplateExecutionEnvironment environment)\n    throws DismissTopMappingRuleException, AbandonRuleInputException, GenerationFailureException, GenerationCanceledException {\n\n    String ruleMappingName = RuleUtil.getPatternReductionRuleLabel(ruleNode);\n    SNode ruleConsequence = RuleUtil.getPatternReductionRuleConsequence(ruleNode);\n    if (ruleConsequence == null) {\n      environment.getGenerator().showErrorMessage(inputNode, null, ruleNode, \"error processing reduction rule: no rule consequence\");\n      return null;\n    }\n    TemplateContext conseqContext = GeneratorUtil.createConsequenceContext(inputNode, new DefaultTemplateContext(pattern, null, inputNode), environment.getReductionContext(), ruleConsequence, inputNode, environment.getGenerator());\n\n    List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(ruleConsequence, inputNode, ruleNode, environment.getReductionContext(), environment.getGenerator());\n    if (nodeAndMappingNamePairs == null) {\n      environment.getGenerator().showErrorMessage(inputNode, null, ruleConsequence, \"error processing reduction rule consequence\");\n      return null;\n    }\n\n    List<SNode> result = new ArrayList<SNode>(nodeAndMappingNamePairs.size());\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n      SNode templateNode = nodeAndMappingNamePair.o1;\n      String mappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : ruleMappingName;\n      try {\n        result.addAll(templateProcessor.processTemplateNode(mappingName, templateNode, conseqContext));\n      } catch (DismissTopMappingRuleException e) {\n        throw e;\n      } catch (TemplateProcessingFailureException e) {\n        environment.getGenerator().showErrorMessage(inputNode, templateNode, ruleNode, \"error processing reduction rule\");\n      } catch (GenerationFailureException e) {\n        throw e;\n      } catch (GenerationCanceledException e) {\n        throw e;\n      } catch (Throwable t) {\n        environment.getGenerator().getLogger().handleException(t);\n        environment.getGenerator().showErrorMessage(inputNode, templateNode, ruleNode, \"error processing reduction rule\");\n      }\n    }\n    return result;\n  }","id":88665,"modified_method":"@Nullable\n  private Collection<SNode> apply(SNode inputNode, @NotNull GeneratedMatchingPattern pattern, @NotNull TemplateExecutionEnvironment environment)\n    throws DismissTopMappingRuleException, AbandonRuleInputException, GenerationFailureException, GenerationCanceledException {\n\n    String ruleMappingName = RuleUtil.getPatternReductionRuleLabel(ruleNode);\n    SNode ruleConsequence = RuleUtil.getPatternReductionRuleConsequence(ruleNode);\n    if (ruleConsequence == null) {\n      environment.getGenerator().showErrorMessage(inputNode, null, ruleNode, \"error processing reduction rule: no rule consequence\");\n      return null;\n    }\n    TemplateContext conseqContext = GeneratorUtil.createConsequenceContext(inputNode, new DefaultTemplateContext(pattern, null, inputNode), environment.getReductionContext(), ruleConsequence, inputNode, environment.getGenerator());\n\n    List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(ruleConsequence, inputNode, ruleNode, environment.getReductionContext(), environment.getGenerator());\n    if (nodeAndMappingNamePairs == null) {\n      environment.getGenerator().showErrorMessage(inputNode, null, ruleConsequence, \"error processing reduction rule consequence\");\n      return null;\n    }\n\n    List<SNode> result = new ArrayList<SNode>(nodeAndMappingNamePairs.size());\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n      SNode templateNode = nodeAndMappingNamePair.o1;\n      String mappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : ruleMappingName;\n      try {\n        result.addAll(templateProcessor.apply(mappingName, templateNode, conseqContext));\n      } catch (DismissTopMappingRuleException e) {\n        throw e;\n      } catch (TemplateProcessingFailureException e) {\n        environment.getGenerator().showErrorMessage(inputNode, templateNode, ruleNode, \"error processing reduction rule\");\n      } catch (GenerationFailureException e) {\n        throw e;\n      } catch (GenerationCanceledException e) {\n        throw e;\n      } catch (Throwable t) {\n        environment.getGenerator().getLogger().handleException(t);\n        environment.getGenerator().showErrorMessage(inputNode, templateNode, ruleNode, \"error processing reduction rule\");\n      }\n    }\n    return result;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public String getApplicableConcept() {\n        return NameUtil.nodeFQName(this.applicableConcept);\n    }","id":88666,"modified_method":"@Override\n  public String getApplicableConcept() {\n    return this.applicableConcept;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateReductionRuleInterpreted(SNode ruleNode) {\n        this.ruleNode = ruleNode;\n        this.applicableConcept = RuleUtil.getBaseRuleApplicableConcept(ruleNode);\n        this.baseRuleCondition = RuleUtil.getBaseRuleCondition(ruleNode);\n    }","id":88667,"modified_method":"public TemplateReductionRuleInterpreted(SNode ruleNode) {\n    this.ruleNode = ruleNode;\n    this.applicableConcept = NameUtil.nodeFQName(RuleUtil.getBaseRuleApplicableConcept(ruleNode));\n    this.baseRuleCondition = RuleUtil.getBaseRuleCondition(ruleNode);\n    this.ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n    private Collection<SNode> apply(TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n            throws DismissTopMappingRuleException, AbandonRuleInputException, GenerationFailureException, GenerationCanceledException {\n\n        String ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n        SNode ruleConsequence = RuleUtil.getReductionRuleConsequence(ruleNode);\n        if (ruleConsequence == null) {\n            environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"error processing reduction rule: no rule consequence\");\n            return null;\n        }\n        TemplateContext conseqContext = GeneratorUtil.createConsequenceContext(context.getInput(), context, environment.getReductionContext(), ruleConsequence, context.getInput(), environment.getGenerator());\n\n        List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(ruleConsequence, context.getInput(), ruleNode, environment.getReductionContext(), environment.getGenerator());\n        if (nodeAndMappingNamePairs == null) {\n            environment.getGenerator().showErrorMessage(context.getInput(), null, ruleConsequence, \"error processing reduction rule consequence\");\n            return null;\n        }\n\n        List<SNode> result = new ArrayList<SNode>(nodeAndMappingNamePairs.size());\n        TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n        for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n            SNode templateNode = nodeAndMappingNamePair.o1;\n            String mappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : ruleMappingName;\n            try {\n                result.addAll(templateProcessor.processTemplateNode(mappingName, templateNode, conseqContext));\n            } catch (DismissTopMappingRuleException e) {\n                throw e;\n            } catch (TemplateProcessingFailureException e) {\n                environment.getGenerator().showErrorMessage(context.getInput(), templateNode, ruleNode, \"error processing reduction rule\");\n            } catch (GenerationFailureException e) {\n                throw e;\n            } catch (GenerationCanceledException e) {\n                throw e;\n            } catch (Throwable t) {\n                environment.getGenerator().getLogger().handleException(t);\n                environment.getGenerator().showErrorMessage(context.getInput(), templateNode, ruleNode, \"error processing reduction rule\");\n            }\n        }\n        return result;\n    }","id":88668,"modified_method":"@Nullable\n  private Collection<SNode> apply(TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws DismissTopMappingRuleException, AbandonRuleInputException, GenerationFailureException, GenerationCanceledException {\n\n    SNode ruleConsequence = RuleUtil.getReductionRuleConsequence(ruleNode);\n    if (ruleConsequence == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"error processing reduction rule: no rule consequence\");\n      return null;\n    }\n    TemplateContext conseqContext = GeneratorUtil.createConsequenceContext(context.getInput(), context, environment.getReductionContext(), ruleConsequence, context.getInput(), environment.getGenerator());\n\n    List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(ruleConsequence, context.getInput(), ruleNode, environment.getReductionContext(), environment.getGenerator());\n    if (nodeAndMappingNamePairs == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleConsequence, \"error processing reduction rule consequence\");\n      return null;\n    }\n\n    List<SNode> result = new ArrayList<SNode>(nodeAndMappingNamePairs.size());\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n      SNode templateNode = nodeAndMappingNamePair.o1;\n      String mappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : ruleMappingName;\n      try {\n        result.addAll(templateProcessor.apply(mappingName, templateNode, conseqContext));\n      } catch (DismissTopMappingRuleException e) {\n        throw e;\n      } catch (TemplateProcessingFailureException e) {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateNode, ruleNode, \"error processing reduction rule\");\n      } catch (GenerationFailureException e) {\n        throw e;\n      } catch (GenerationCanceledException e) {\n        throw e;\n      } catch (Throwable t) {\n        environment.getGenerator().getLogger().handleException(t);\n        environment.getGenerator().showErrorMessage(context.getInput(), templateNode, ruleNode, \"error processing reduction rule\");\n      }\n    }\n    return result;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isApplicable(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationFailureException {\n    SNode condition = RuleUtil.getBaseRuleCondition(ruleNode);\n    if (condition == null) {\n      return true;\n    }\n\n    String methodName = TemplateFunctionMethodName.baseMappingRule_Condition(condition);\n    try {\n      return (Boolean) QueryMethodGenerated.invoke(\n        methodName,\n        environment.getGenerator().getGeneratorSessionContext(),\n        new BaseMappingRuleContext(context.getInput(), ruleNode, environment.getGenerator()),\n        ruleNode.getModel(),\n        true);\n    } catch (ClassNotFoundException e) {\n      environment.getGenerator().getLogger().warning(condition, \"cannot find condition method '\" + methodName + \"' : evaluate to FALSE\");\n    } catch (NoSuchMethodException e) {\n      environment.getGenerator().getLogger().warning(condition, \"cannot find condition method '\" + methodName + \"' : evaluate to FALSE\");\n    } catch (Throwable t) {\n      environment.getGenerator().getLogger().handleException(t);\n      environment.getGenerator().getLogger().error(condition, \"error executing condition \" + methodName + \" (see exception)\");\n      throw new GenerationFailureException(t);\n    }\n    return false;\n  }","id":88669,"modified_method":"@Override\n  public boolean isApplicable(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationFailureException {\n    try {\n      if(conditionMethod == null) {\n        return true;\n      }\n\n      return (Boolean) QueryMethodGenerated.invoke(\n        conditionMethod,\n        environment.getGenerator().getGeneratorSessionContext(),\n        new BaseMappingRuleContext(context.getInput(), ruleNode, environment.getGenerator()),\n        ruleNode.getModel(),\n        true);\n    } catch (ClassNotFoundException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + conditionMethod + \"' : evaluate to FALSE\");\n    } catch (NoSuchMethodException e) {\n      environment.getGenerator().getLogger().warning(ruleNode, \"cannot find condition method '\" + conditionMethod + \"' : evaluate to FALSE\");\n    } catch (Throwable t) {\n      environment.getGenerator().getLogger().handleException(t);\n      environment.getGenerator().getLogger().error(ruleNode, \"error executing condition \" + conditionMethod + \" (see exception)\");\n      throw new GenerationFailureException(t);\n    }\n    return false;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String getApplicableConcept() {\n    return NameUtil.nodeFQName(this.applicableConcept);\n  }","id":88670,"modified_method":"@Override\n  public String getApplicableConcept() {\n    return this.applicableConcept;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> apply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    SNode templateNode = RuleUtil.getRootRuleTemplateNode(ruleNode);\n    if (templateNode != null) {\n      String ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n\n      return new TemplateProcessor(environment.getGenerator(), environment.getReductionContext())\n        .processTemplateNode(ruleMappingName, templateNode, context);\n    } else {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"no template is defined for the rule\");\n    }\n    return null;\n  }","id":88671,"modified_method":"@Override\n  public Collection<SNode> apply(TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    if (templateNode != null) {\n      return new TemplateProcessor(environment.getGenerator(), environment.getReductionContext())\n        .apply(ruleMappingName, templateNode, context);\n    } else {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"no template is defined for the rule\");\n    }\n    return null;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TemplateRootMappingRuleInterpreted(SNode rule) {\n    ruleNode = rule;\n    applicableConcept = RuleUtil.getBaseRuleApplicableConcept(rule);\n  }","id":88672,"modified_method":"public TemplateRootMappingRuleInterpreted(SNode rule) {\n    ruleNode = rule;\n    applicableConcept = NameUtil.nodeFQName(RuleUtil.getBaseRuleApplicableConcept(rule));\n\n    SNode condition = RuleUtil.getBaseRuleCondition(ruleNode);\n    conditionMethod = condition == null ? null : TemplateFunctionMethodName.baseMappingRule_Condition(condition);\n\n    ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n    templateNode = RuleUtil.getRootRuleTemplateNode(ruleNode);\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> applyDefault(TemplateExecutionEnvironment environment, SNodePointer templateSwitch, String mappingName, TemplateContext context) throws GenerationException {\n    SNode defaultConsequence = RuleUtil.getSwitchDefaultConsequence(mySwitch);\n    if (defaultConsequence == null) {\n      SNodePointer modifies = getModifiesSwitch();\n      if (modifies == null) {\n        return null;\n      }\n      TemplateSwitchMapping switchMapping = environment.getGenerator().getSwitch(modifies);\n      if (switchMapping == null) {\n        return null;\n      }\n      return switchMapping.applyDefault(environment, templateSwitch, mappingName, context);\n    }\n\n    List<SNode> collection = new ArrayList<SNode>();\n    try {\n      List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(defaultConsequence, context.getInput(), templateSwitch.getNode(), environment.getReductionContext(), environment.getGenerator());\n      if (nodeAndMappingNamePairs == null) {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateSwitch.getNode(), defaultConsequence, \"error processing $SWITCH$/default\");\n        return null;\n      }\n\n      for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n        SNode altTemplateNode = nodeAndMappingNamePair.o1;\n        String innerMappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;\n        try {\n          TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n          collection.addAll(templateProcessor.processTemplateNode(innerMappingName, altTemplateNode, context));\n        } catch (TemplateProcessingFailureException e) {\n          environment.getGenerator().showErrorMessage(context.getInput(), templateSwitch.getNode(), \"error processing template fragment\");\n        }\n      }\n    } catch (AbandonRuleInputException e) {\n      // it's ok. just ignore\n    }\n    return collection;\n  }","id":88673,"modified_method":"@Override\n  public Collection<SNode> applyDefault(TemplateExecutionEnvironment environment, SNodePointer templateSwitch, String mappingName, TemplateContext context) throws GenerationException {\n    SNode defaultConsequence = RuleUtil.getSwitchDefaultConsequence(mySwitch);\n    if (defaultConsequence == null) {\n      SNodePointer modifies = getModifiesSwitch();\n      if (modifies == null) {\n        return null;\n      }\n      TemplateSwitchMapping switchMapping = environment.getGenerator().getSwitch(modifies);\n      if (switchMapping == null) {\n        return null;\n      }\n      return switchMapping.applyDefault(environment, templateSwitch, mappingName, context);\n    }\n\n    List<SNode> collection = new ArrayList<SNode>();\n    try {\n      List<Pair<SNode, String>> nodeAndMappingNamePairs = GeneratorUtilEx.getTemplateNodesFromRuleConsequence(defaultConsequence, context.getInput(), templateSwitch.getNode(), environment.getReductionContext(), environment.getGenerator());\n      if (nodeAndMappingNamePairs == null) {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateSwitch.getNode(), defaultConsequence, \"error processing $SWITCH$/default\");\n        return null;\n      }\n\n      for (Pair<SNode, String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {\n        SNode altTemplateNode = nodeAndMappingNamePair.o1;\n        String innerMappingName = nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;\n        try {\n          TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n          collection.addAll(templateProcessor.apply(innerMappingName, altTemplateNode, context));\n        } catch (TemplateProcessingFailureException e) {\n          environment.getGenerator().showErrorMessage(context.getInput(), templateSwitch.getNode(), \"error processing template fragment\");\n        }\n      }\n    } catch (AbandonRuleInputException e) {\n      // it's ok. just ignore\n    }\n    return collection;\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void weaveTemplateDeclaration_intern(SNode template, SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (template == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n\n    List<SNode> templateFragments = GeneratorUtilEx.getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      environment.getGenerator().showErrorMessage(context.getInput(), template, ruleNode, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    checkTemplateFragmentsForWeaving(template, templateFragments, environment.getGenerator());\n\n    String ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n\n    // for each template fragment create output nodes\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (SNode templateFragment : templateFragments) {\n      SNode templateFragmentNode = templateFragment.getParent();\n      SNode contextParentNode = null;\n      try {\n        contextParentNode = environment.getReductionContext().getQueryExecutor().getContextNodeForTemplateFragment(templateFragmentNode, outputContextNode, context);\n      } catch (Exception e) {\n        environment.getGenerator().getLogger().handleException(e);\n      }\n      if (contextParentNode != null) {\n        try {\n          List<SNode> outputNodesToWeave = templateProcessor.processTemplateNode(\n            GeneratorUtilEx.getMappingName(templateFragment, ruleMappingName),\n            templateFragmentNode, context);\n          String childRole = templateFragmentNode.getRole_();\n          for (SNode outputNodeToWeave : outputNodesToWeave) {\n            environment.weaveNode(contextParentNode, childRole, outputNodeToWeave, new SNodePointer(templateFragment), context.getInput());\n          }\n        } catch (DismissTopMappingRuleException e) {\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"wrong template: dismission of weaving rule is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          // FIXME\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"error processing template fragment\");\n          environment.getGenerator().getLogger().info(contextParentNode, \" -- was output context node:\");\n        }\n      } else {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"couldn't define 'context' for template fragment\");\n      }\n    }\n  }","id":88674,"modified_method":"private void weaveTemplateDeclaration_intern(SNode template, SNode outputContextNode, @NotNull TemplateContext context, @NotNull TemplateExecutionEnvironment environment)\n    throws GenerationFailureException, GenerationCanceledException {\n\n    if (template == null) {\n      environment.getGenerator().showErrorMessage(context.getInput(), null, ruleNode, \"couldn't evaluate weaving rule: no template\");\n      return;\n    }\n\n    List<SNode> templateFragments = GeneratorUtilEx.getTemplateFragments(template);\n    if (templateFragments.isEmpty()) {\n      environment.getGenerator().showErrorMessage(context.getInput(), template, ruleNode, \"nothing to weave: no template fragments found in template\");\n      return;\n    }\n\n    // check fragments: all fragments with <default context> should have the same parent\n    checkTemplateFragmentsForWeaving(template, templateFragments, environment.getGenerator());\n\n    String ruleMappingName = RuleUtil.getBaseRuleLabel(ruleNode);\n\n    // for each template fragment create output nodes\n    TemplateProcessor templateProcessor = new TemplateProcessor(environment.getGenerator(), environment.getReductionContext());\n    for (SNode templateFragment : templateFragments) {\n      SNode templateFragmentNode = templateFragment.getParent();\n      SNode contextParentNode = null;\n      try {\n        contextParentNode = environment.getReductionContext().getQueryExecutor().getContextNodeForTemplateFragment(templateFragmentNode, outputContextNode, context);\n      } catch (Exception e) {\n        environment.getGenerator().getLogger().handleException(e);\n      }\n      if (contextParentNode != null) {\n        try {\n          List<SNode> outputNodesToWeave = templateProcessor.apply(\n            GeneratorUtilEx.getMappingName(templateFragment, ruleMappingName),\n            templateFragmentNode, context);\n          String childRole = templateFragmentNode.getRole_();\n          for (SNode outputNodeToWeave : outputNodesToWeave) {\n            environment.weaveNode(contextParentNode, childRole, outputNodeToWeave, new SNodePointer(templateFragment), context.getInput());\n          }\n        } catch (DismissTopMappingRuleException e) {\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"wrong template: dismission of weaving rule is not supported\");\n        } catch (TemplateProcessingFailureException e) {\n          // FIXME\n          environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"error processing template fragment\");\n          environment.getGenerator().getLogger().info(contextParentNode, \" -- was output context node:\");\n        }\n      } else {\n        environment.getGenerator().showErrorMessage(context.getInput(), templateFragment, ruleNode, \"couldn't define 'context' for template fragment\");\n      }\n    }\n  }","commit_id":"cfbb1f913c1a5ce13bb3d5566b5fa56e3618d78f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(AnActionEvent event) {\n    removeAll();\n    ActionEventData data = new ActionEventData(event);\n\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    TreeNode treeNode = MPSDataKeys.LOGICAL_VIEW_NODE.getData(dataContext);\n    if (!(treeNode instanceof PackageNode)) {\n      myPackage = null;\n    } else {\n      final PackageNode node = (PackageNode) treeNode;\n      myPackage = node.getPackage();\n    }\n\n    List<Language> modelLanguages = data.getModelDescriptor() == null ? new ArrayList<Language>() : data.getModelDescriptor().getSModel().getLanguages(data.getOperationContext().getScope());\n    if (modelLanguages.size() == 0) {\n      add(new BaseAction(\"<NO LANGUAGES>\") {\n        protected void doExecute(AnActionEvent e) {\n        }\n      });\n    }\n\n    LanguageAspect aspect = Language.getModelAspect(data.getModelDescriptor());\n    if (aspect != null) {\n      ModuleReference ref = aspect.getMainLanguage();\n      Language lang = data.getScope().getLanguage(ref);\n      modelLanguages.remove(lang);\n\n      for (ConceptDeclaration conceptDeclaration : lang.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(data.getOperationContext(), NameUtil.nodeFQName(conceptDeclaration), data.getModelDescriptor().getSModel())) {\n          add(newRootNodeAction(new SNodePointer(conceptDeclaration), data.getModelDescriptor()));\n        }\n      }\n\n      addSeparator();\n    }\n\n\n    Collections.sort(modelLanguages, new ToStringComparator());\n\n    List<Language> languagesWithRoots = new ArrayList<Language>();\n    for (final Language language : modelLanguages) {\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(data.getOperationContext(), NameUtil.nodeFQName(conceptDeclaration), data.getModelDescriptor().getSModel())) {\n          languagesWithRoots.add(language);\n          break;\n        }\n      }\n    }\n\n    boolean plain = myPlain || (languagesWithRoots.size() == 1 && aspect == null);\n\n    for (final Language language : languagesWithRoots) {\n      String name = language.getNamespace();\n      Icon icon = IconManager.getIconForNamespace(language.getNamespace());\n      BaseGroup langRootsGroup;\n\n      if (!plain) {\n        langRootsGroup = new BaseGroup(name, name, icon);\n        langRootsGroup.setPopup(true);\n      } else {\n        langRootsGroup = this;\n      }\n\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(data.getOperationContext(), NameUtil.nodeFQName(conceptDeclaration), data.getModelDescriptor().getSModel())) {\n          langRootsGroup.add(newRootNodeAction(new SNodePointer(conceptDeclaration), data.getModelDescriptor()));\n        }\n      }\n      if (!plain) {\n        this.add(langRootsGroup);\n      } else {\n        this.addSeparator();\n      }\n    }\n\n\n    Integer selectedItemsCount = MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE.getData(event.getDataContext());\n    boolean enabled = selectedItemsCount != null && selectedItemsCount == 1;\n\n    setEnabledState(event.getPresentation(), enabled);\n  }","id":88675,"modified_method":"public void doUpdate(AnActionEvent event) {\n    removeAll();\n\n    ActionEventData data = new ActionEventData(event);\n    SModelDescriptor modelDescriptor = data.getModelDescriptor();\n    if (modelDescriptor==null){\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    IScope scope = data.getScope();\n    IOperationContext context = data.getOperationContext();\n    Integer selectedItemsCount = MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE.getData(event.getDataContext());\n    boolean isJavaStubModel = SModelStereotype.JAVA_STUB.equals(modelDescriptor.getStereotype());\n    boolean singleItemSelected = selectedItemsCount != null && selectedItemsCount == 1;\n    if (scope == null || context == null  || isJavaStubModel || !singleItemSelected) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    setEnabledState(event.getPresentation(), true);\n\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    TreeNode treeNode = MPSDataKeys.LOGICAL_VIEW_NODE.getData(dataContext);\n    if (!(treeNode instanceof PackageNode)) {\n      myPackage = null;\n    } else {\n      final PackageNode node = (PackageNode) treeNode;\n      myPackage = node.getPackage();\n    }\n\n    List<Language> modelLanguages = modelDescriptor.getSModel().getLanguages(scope);\n    if (modelLanguages.size() == 0) {\n      add(new BaseAction(\"<NO LANGUAGES>\") {\n        protected void doExecute(AnActionEvent e) {\n        }\n      });\n    }\n\n    LanguageAspect aspect = Language.getModelAspect(modelDescriptor);\n    if (aspect != null) {\n      ModuleReference ref = aspect.getMainLanguage();\n      Language lang = scope.getLanguage(ref);\n      modelLanguages.remove(lang);\n\n      for (ConceptDeclaration conceptDeclaration : lang.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          add(newRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n\n      addSeparator();\n    }\n\n\n    Collections.sort(modelLanguages, new ToStringComparator());\n\n    List<Language> languagesWithRoots = new ArrayList<Language>();\n    for (final Language language : modelLanguages) {\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          languagesWithRoots.add(language);\n          break;\n        }\n      }\n    }\n\n    boolean plain = myPlain || (languagesWithRoots.size() == 1 && aspect == null);\n\n    for (final Language language : languagesWithRoots) {\n      String name = language.getNamespace();\n      Icon icon = IconManager.getIconForNamespace(language.getNamespace());\n      BaseGroup langRootsGroup;\n\n      if (!plain) {\n        langRootsGroup = new BaseGroup(name, name, icon);\n        langRootsGroup.setPopup(true);\n      } else {\n        langRootsGroup = this;\n      }\n\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          langRootsGroup.add(newRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n      if (!plain) {\n        this.add(langRootsGroup);\n      } else {\n        this.addSeparator();\n      }\n    }\n  }","commit_id":"63ef824f5bc89a152c7ec06cd26c436616c1bb50","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doInit() {\n    this.removeAllChildren();\n    SNode n = getSNode();\n    if (n == null) return;\n\n    if (showPropertiesAndReferences()) {\n      add(new PropertiesTreeNode(getOperationContext(), n));\n      add(new ReferencesTreeNode(getOperationContext(), n));\n    }\n\n    List<SNode> children = n.getChildren();\n    List<SNode> filteredChildren = CollectionUtil.filter(children, myCondition);\n    for (SNode childNode : filteredChildren) {\n      add(getSModelModelTreeNode().createSNodeTreeNode(childNode, childNode.getRole_(), getOperationContext()));\n    }\n\n    DefaultTreeModel treeModel = (DefaultTreeModel) getTree().getModel();\n    treeModel.nodeStructureChanged(this);\n    myInitialized = true;\n  }","id":88676,"modified_method":"protected void doInit() {\n    this.removeAllChildren();\n    SNode n = getSNode();\n    if (n == null) return;\n\n    if (showPropertiesAndReferences()) {\n      add(new PropertiesTreeNode(getOperationContext(), n));\n      add(new ReferencesTreeNode(getOperationContext(), n));\n    }\n\n    List<SNode> children = n.getChildren();\n    List<SNode> filteredChildren = CollectionUtil.filter(children, myCondition);\n    SModelTreeNode sModelTreeNode = getSModelModelTreeNode();\n    for (SNode childNode : filteredChildren) {\n      SNodeTreeNode child = sModelTreeNode == null ? new SNodeTreeNode(childNode, childNode.getRole_(), getOperationContext()) \n        : sModelTreeNode.createSNodeTreeNode(childNode, childNode.getRole_(), getOperationContext());\n      add(child);\n    }\n\n    DefaultTreeModel treeModel = (DefaultTreeModel) getTree().getModel();\n    treeModel.nodeStructureChanged(this);\n    myInitialized = true;\n  }","commit_id":"73d7f16624b175e42b27786f5f0f8e1c418bb99c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EquationItem(SNode node1, SNode node2) {\n    //  setBackground(Color.CYAN);\n      setLayout(new GridBagLayout());\n      GridBagConstraints constraints = new GridBagConstraints();\n      constraints.gridy = 0;\n      constraints.weighty = 0;\n\n      constraints.gridx = 0;\n      constraints.weightx = 0;\n      constraints.fill = GridBagConstraints.NONE;\n      constraints.anchor = GridBagConstraints.NORTHWEST;\n      add(new SNodeTree(node1), constraints);\n\n      constraints.gridx = 1;\n      constraints.weightx = 1;\n      constraints.fill = GridBagConstraints.BOTH;\n      constraints.anchor = GridBagConstraints.CENTER;\n      add(new JLabel(\"==\", null, SwingConstants.CENTER), constraints);\n\n      constraints.gridx = 2;\n      constraints.weightx = 0;\n      constraints.fill = GridBagConstraints.NONE;\n      constraints.anchor = GridBagConstraints.NORTHEAST;\n      add(new SNodeTree(node2), constraints);\n    }","id":88677,"modified_method":"public EquationItem(SNode node1, SNode node2) {\n\n      setLayout(new GridBagLayout());\n      GridBagConstraints constraints = new GridBagConstraints();\n      constraints.gridy = 0;\n      constraints.weighty = 0;\n\n      constraints.gridx = 0;\n      constraints.weightx = 0;\n      constraints.fill = GridBagConstraints.NONE;\n      constraints.anchor = GridBagConstraints.NORTHWEST;\n      myNodeTree1 = new SNodeTree(node1);\n      add(myNodeTree1, constraints);\n\n      constraints.gridx = 1;\n      constraints.weightx = 1;\n      constraints.fill = GridBagConstraints.BOTH;\n      constraints.anchor = GridBagConstraints.CENTER;\n      add(new JLabel(\"==\", null, SwingConstants.CENTER), constraints);\n\n      constraints.gridx = 2;\n      constraints.weightx = 0;\n      constraints.fill = GridBagConstraints.NONE;\n      constraints.anchor = GridBagConstraints.NORTHEAST;\n      myNodeTree2 = new SNodeTree(node2);\n      add(myNodeTree2, constraints);\n\n      setBackground(myNodeTree1.getBackground());\n      myNodeTree1.rebuildNow();\n      myNodeTree2.rebuildNow();\n    }","commit_id":"73d7f16624b175e42b27786f5f0f8e1c418bb99c","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode method = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", true, false);\n      SNode declClassifier = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      if ((declClassifier != null)) {\n        ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(declClassifier)), IClassifiersSearchScope.INSTANCE_METHOD);\n        List<BaseMethodDeclaration> list = scope.getOverriddenMethods(((InstanceMethodDeclaration)SNodeOperations.getAdapter(method)));\n        if (ListSequence.fromList(list).count() > 0) {\n          SNode overriden = ((SNode)ListSequence.fromList(list).getElement(0).getNode());\n          editorContext.getOperationContext().getComponent(MPSEditorOpener.class).openNode(overriden);\n        }\n      }\n    }","id":88678,"modified_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode method = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", true, false);\n      SNode declClassifier = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      if ((declClassifier != null)) {\n        ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(declClassifier)), IClassifiersSearchScope.INSTANCE_METHOD);\n        List<BaseMethodDeclaration> list = scope.getOverriddenMethods(((InstanceMethodDeclaration)SNodeOperations.getAdapter(method)));\n        SNode overriden = ((SNode)BaseAdapter.fromAdapter(ListSequence.fromList(list).first()));\n        if (overriden != null) {\n          IOperationContext context = editorContext.getOperationContext();\n          context.getComponent(MPSEditorOpener.class).editNode(overriden, context);\n        }\n      }\n    }","commit_id":"3f08f9ac6ca525bb9ce6f0aa2df70241f045bdec","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected XWikiContext initializeXWikiContext(ActionMapping mapping, ActionForm form, \n        HttpServletRequest req, HttpServletResponse resp) throws XWikiException, ServletException\n    {\n        String action = mapping.getName();\n\n        XWikiRequest request = new XWikiServletRequest(req);\n        XWikiResponse response = new XWikiServletResponse(resp);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servlet.getServletContext()));\n\n        // Add the form to the context\n        context.setForm((XWikiForm) form);\n\n        // Initialize the Container component which is the new of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }","id":88679,"modified_method":"protected XWikiContext initializeXWikiContext(ActionMapping mapping, ActionForm form, \n        HttpServletRequest req, HttpServletResponse resp) throws XWikiException, ServletException\n    {\n        String action = mapping.getName();\n\n        XWikiRequest request = new XWikiServletRequest(req);\n        XWikiResponse response = new XWikiServletResponse(resp);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servlet.getServletContext()));\n\n        // This code is already called by struts.\n        // However struts will also set all the parameters of the form data\n        // directly from the request objects.\n        // However because of bug http://jira.xwiki.org/jira/browse/XWIKI-2422\n        // We need to perform encoding of windows-1252 chars in ISO mode\n        // So we need to make sure this code is called\n        // TODO: completely get rid of struts so that we control this part of the code and can reduce drastically the\n        // number of calls\n        if (form != null) {\n            form.reset(mapping, request);\n        }\n\n        // Add the form to the context\n        context.setForm((XWikiForm) form);\n\n        // Initialize the Container component which is the new of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }","commit_id":"8a1b566bcb4cf2cc4f7cc4887c8c8acc9f61ad38","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Map getParameterMap() {\r\n        return request.getParameterMap();\r\n    }","id":88680,"modified_method":"public Map getParameterMap() {\r\n        Map newMap = new HashMap();\r\n        Map map = request.getParameterMap();\r\n        Iterator it = map.keySet().iterator();\r\n        while (it.hasNext()) {\r\n           String key = (String) it.next();\r\n           Object value = map.get(key);\r\n           if (value instanceof String)\r\n             newMap.put(key, filterString((String) value));\r\n           else if (value instanceof String[])\r\n             newMap.put(key, filterStringArray((String[]) value));\r\n           else\r\n             newMap.put(key, value);\r\n        }\r\n        return map;\r\n    }","commit_id":"8a1b566bcb4cf2cc4f7cc4887c8c8acc9f61ad38","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String[] getParameterValues(String s) {\r\n        return request.getParameterValues(s);\r\n    }","id":88681,"modified_method":"public String[] getParameterValues(String s) {\r\n        String[] origResult = request.getParameterValues(s);\r\n        return filterStringArray(origResult);\r\n    }","commit_id":"8a1b566bcb4cf2cc4f7cc4887c8c8acc9f61ad38","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String get(String name) {\r\n        return request.getParameter(name);\r\n    }","id":88682,"modified_method":"public String get(String name) {\r\n        return filterString(request.getParameter(name));\r\n    }","commit_id":"8a1b566bcb4cf2cc4f7cc4887c8c8acc9f61ad38","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getParameter(String s) {\r\n        return request.getParameter(s);\r\n    }","id":88683,"modified_method":"public String getParameter(String s) {\r\n        return filterString(request.getParameter(s));\r\n    }","commit_id":"8a1b566bcb4cf2cc4f7cc4887c8c8acc9f61ad38","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Object invoke(Class clazz, Object[] args) {\r\n\t\tObject map = args.length > 0 ? args[0] : null;\r\n        Object instance;\r\n        if(applicationContext!=null && applicationContext.containsBean(clazz.getName())) {\r\n            instance = applicationContext.getBean(clazz.getName());\r\n        }\r\n        else {\r\n\r\n            try {\r\n                instance = clazz.newInstance();\r\n            } catch (InstantiationException e1) {\r\n                throw new GrailsDomainException(\"Error instantiated class [\" + clazz + \"]: \" + e1.getMessage(),e1);\r\n            } catch (IllegalAccessException e1) {\r\n                throw new GrailsDomainException(\"Illegal access instantiated class [\" + clazz + \"]: \" + e1.getMessage(),e1);\r\n            }\r\n        }\r\n\r\n\r\n        if (map !=null) {\r\n            if(map instanceof GrailsParameterMap) {\r\n                GrailsParameterMap parameterMap = (GrailsParameterMap)map;\r\n                HttpServletRequest request = parameterMap.getRequest();\r\n\r\n                ServletRequestDataBinder dataBinder = GrailsDataBinder.createBinder(instance, instance.getClass().getName(),request);\r\n                dataBinder.bind(request);\r\n                return instance;\r\n            }\r\n            else if (map instanceof HttpServletRequest) {\r\n                HttpServletRequest request = (HttpServletRequest)map;\r\n                ServletRequestDataBinder dataBinder = GrailsDataBinder.createBinder(instance, instance.getClass().getName(),request);\r\n                dataBinder.bind(request);\r\n                return instance;\r\n            }\r\n            else if(map instanceof Map) {\r\n\r\n                DataBinder dataBinder = new DataBinder(instance);\r\n                Map m = convertPotentialGStrings((Map)map);\r\n                PropertyValues pv = new MutablePropertyValues(m);\r\n                dataBinder.bind(pv);\r\n            }\r\n        }\r\n        return instance;\r\n\t}","id":88684,"modified_method":"public Object invoke(Class clazz, Object[] args) {\r\n\t\tObject map = args.length > 0 ? args[0] : null;\r\n        Object instance;\r\n        if(applicationContext!=null && applicationContext.containsBean(clazz.getName())) {\r\n            instance = applicationContext.getBean(clazz.getName());\r\n        }\r\n        else {\r\n\r\n            try {\r\n                instance = clazz.newInstance();\r\n            } catch (InstantiationException e1) {\r\n                throw new GrailsDomainException(\"Error instantiated class [\" + clazz + \"]: \" + e1.getMessage(),e1);\r\n            } catch (IllegalAccessException e1) {\r\n                throw new GrailsDomainException(\"Illegal access instantiated class [\" + clazz + \"]: \" + e1.getMessage(),e1);\r\n            }\r\n        }\r\n\r\n\r\n        if (map !=null) {\r\n            if(map instanceof GrailsParameterMap) {\r\n                GrailsParameterMap parameterMap = (GrailsParameterMap)map;\r\n                HttpServletRequest request = parameterMap.getRequest();\r\n\r\n                GrailsDataBinder dataBinder = GrailsDataBinder.createBinder(instance, instance.getClass().getName(),request);\r\n                dataBinder.bind(parameterMap);\r\n                return instance;\r\n            }\r\n            else if (map instanceof HttpServletRequest) {\r\n                HttpServletRequest request = (HttpServletRequest)map;\r\n                ServletRequestDataBinder dataBinder = GrailsDataBinder.createBinder(instance, instance.getClass().getName(),request);\r\n                dataBinder.bind(request);\r\n                return instance;\r\n            }\r\n            else if(map instanceof Map) {\r\n\r\n                DataBinder dataBinder = new DataBinder(instance);\r\n                Map m = convertPotentialGStrings((Map)map);\r\n                PropertyValues pv = new MutablePropertyValues(m);\r\n                dataBinder.bind(pv);\r\n            }\r\n        }\r\n        return instance;\r\n\t}","commit_id":"969ea2bc35571ef393b68f720ee17113d17d93df","url":"https://github.com/grails/grails-core"},{"original_method":"public void bind(ServletRequest request, String prefix) {\n    \tMutablePropertyValues mpvs;\n    \tif (prefix != null) {\n    \t\tmpvs = new ServletRequestParameterPropertyValues(request, prefix, PREFIX_SEPERATOR);\n    \t} else {\n            mpvs = new ServletRequestParameterPropertyValues(request);\n    \t}\n\n        checkStructuredDateDefinitions(mpvs);\n        autoCreateIfPossible(mpvs);\n        bindAssociations(mpvs);\n\n        if (request instanceof MultipartHttpServletRequest) {\n\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\tbindMultipartFiles(multipartRequest.getFileMap(), mpvs);\n\t\t}\n        super.doBind(mpvs);\n    }","id":88685,"modified_method":"public void bind(ServletRequest request, String prefix) {\n    \tMutablePropertyValues mpvs;\n    \tif (prefix != null) {\n    \t\tmpvs = new ServletRequestParameterPropertyValues(request, prefix, PREFIX_SEPERATOR);\n    \t} else {\n            mpvs = new ServletRequestParameterPropertyValues(request);\n    \t}\n\n        bindWithRequestAndPropertyValues(request, mpvs);\n    }","commit_id":"969ea2bc35571ef393b68f720ee17113d17d93df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Method that auto-creates the a type if it is null and is possible to auto-create\n     *\n     * @param mpvs A MutablePropertyValues instance\n     */\n    protected void autoCreateIfPossible(MutablePropertyValues mpvs) {\n        PropertyValue[] pvs = mpvs.getPropertyValues();\n        for (int i = 0; i < pvs.length; i++) {\n            PropertyValue pv = pvs[i];\n\n            String propertyName = pv.getName();\n            //super.\n            \n            if(propertyName.indexOf('.') > -1) {\n                propertyName = propertyName.split(\"\\\\.\")[0];\n            }\n            Class type = bean.getPropertyType(propertyName);\n            LOG.debug(\"Checking if auto-create is possible for property [\"+propertyName+\"] and type [\"+type+\"]\");\n            if(type != null) {\n                if(GroovyObject.class.isAssignableFrom(type)) {\n                    if(bean.getPropertyValue(propertyName) == null) {\n                        if(bean.isWritableProperty(propertyName)) {\n                            try {\n                                MetaClass mc = InvokerHelper\n                                                    .getInstance()\n                                                    .getMetaRegistry()\n                                                    .getMetaClass(type);\n                                if(mc!=null) {\n                                    Object created = mc.invokeStaticMethod(type.getName(),CreateDynamicMethod.METHOD_NAME, new Object[0]);\n                                    bean.setPropertyValue(propertyName,created);\n                                }\n                            }\n                            catch(MissingMethodException mme) {\n                                LOG.warn(\"Unable to auto-create type, 'create' method not found\");\n                            }\n                            catch(GroovyRuntimeException gre) {\n                                LOG.warn(\"Unable to auto-create type, Groovy Runtime error: \" + gre.getMessage(),gre) ;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":88686,"modified_method":"/**\n     * Method that auto-creates the a type if it is null and is possible to auto-create\n     *\n     * @param mpvs A MutablePropertyValues instance\n     */\n    protected void autoCreateIfPossible(MutablePropertyValues mpvs) {\n        PropertyValue[] pvs = mpvs.getPropertyValues();\n        for (int i = 0; i < pvs.length; i++) {\n            PropertyValue pv = pvs[i];\n\n            String propertyName = pv.getName();\n            //super.\n            \n            if(propertyName.indexOf('.') > -1) {\n                propertyName = propertyName.split(\"\\\\.\")[0];\n            }\n            Class type = bean.getPropertyType(propertyName);\n            LOG.debug(\"Checking if auto-create is possible for property [\"+propertyName+\"] and type [\"+type+\"]\");\n            if(type != null) {\n                if(GroovyObject.class.isAssignableFrom(type)) {\n                    if(bean.getPropertyValue(propertyName) == null) {\n                        if(bean.isWritableProperty(propertyName)) {\n                            try {\n                                MetaClass mc = InvokerHelper\n                                                    .getInstance()\n                                                    .getMetaRegistry()\n                                                    .getMetaClass(type);\n                                if(mc!=null) {\n                                    Object created = mc.invokeStaticMethod(type,CreateDynamicMethod.METHOD_NAME, new Object[0]);\n                                    bean.setPropertyValue(propertyName,created);\n                                }\n                            }\n                            catch(MissingMethodException mme) {\n                                LOG.warn(\"Unable to auto-create type, 'create' method not found\");\n                            }\n                            catch(GroovyRuntimeException gre) {\n                                LOG.warn(\"Unable to auto-create type, Groovy Runtime error: \" + gre.getMessage(),gre) ;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"969ea2bc35571ef393b68f720ee17113d17d93df","url":"https://github.com/grails/grails-core"},{"original_method":"public GrailsParameterMap(HttpServletRequest request) {\n\t\tsuper();\n\n\t\tthis.request = request;\n\t\tthis.parameterMap = new HashMap();\n\t\tfor (Iterator it = request.getParameterMap().keySet().iterator(); it.hasNext(); ){\n\t\t\tObject key = it.next();\n\t\t\tparameterMap.put(key, request.getParameterMap().get(key));\n\t\t}\n\t}","id":88687,"modified_method":"/**\n     * Creates a GrailsParameterMap populating from the given request object\n     * @param request The request object\n     */\n    public GrailsParameterMap(HttpServletRequest request) {\n\t\tsuper();\n\n\t\tthis.request = request;\n\t\tthis.parameterMap = new HashMap();\n        final Map requestMap = request.getParameterMap();\n        for (Iterator it = requestMap.keySet().iterator(); it.hasNext(); ){\n\t\t\tString key = (String) it.next();\n\t\t\tparameterMap.put(key, requestMap.get(key));\n            processNestedKeys(request, requestMap, key, key ,parameterMap);\n        }\n\t}","commit_id":"969ea2bc35571ef393b68f720ee17113d17d93df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Sets the property on the specified object with the specified value. The\n\t * value is expected to be a Map containing OGNL expressions for the keys\n\t * and objects for the values.\n\t * \n\t * @param object The target object\n\t * @param newValue The value to set\n\t */\n\tpublic void set(Object object, Object newValue) {\n\t\tif(newValue == null)\n\t\t\treturn;\n\t\t\n\t\tif(newValue instanceof GrailsParameterMap) {\n\t\t\tGrailsParameterMap parameterMap = (GrailsParameterMap)newValue;\n\t\t\tHttpServletRequest request = parameterMap.getRequest();\n\t\t\tServletRequestDataBinder dataBinder = GrailsDataBinder.createBinder(object, object.getClass().getName(),request); \n\t\t\tdataBinder.bind(request);\n\t\t}\n\t\telse if(newValue instanceof Map) {\n\t\t\t\n\t\t\tMap propertyMap = (Map)newValue;\n            GrailsDataBinder binder = GrailsDataBinder.createBinder(object, object.getClass().getName());\n            binder.bind(new MutablePropertyValues(propertyMap));\t\t\t\n\t\t}\n\t\telse {\n\t\t\tthrow new MissingPropertyException(PROPERTY_NAME,object.getClass());\n\t\t}\n\t}","id":88688,"modified_method":"/**\n\t * Sets the property on the specified object with the specified value. The\n\t * value is expected to be a Map containing OGNL expressions for the keys\n\t * and objects for the values.\n\t * \n\t * @param object The target object\n\t * @param newValue The value to set\n\t */\n\tpublic void set(Object object, Object newValue) {\n\t\tif(newValue == null)\n\t\t\treturn;\n\t\t\n\t\tif(newValue instanceof GrailsParameterMap) {\n\t\t\tGrailsParameterMap parameterMap = (GrailsParameterMap)newValue;\n\t\t\tHttpServletRequest request = parameterMap.getRequest();\n\t\t\tGrailsDataBinder dataBinder = GrailsDataBinder.createBinder(object, object.getClass().getName(),request); \n\t\t\tdataBinder.bind(parameterMap);\n\t\t}\n\t\telse if(newValue instanceof Map) {\n\t\t\t\n\t\t\tMap propertyMap = (Map)newValue;\n            GrailsDataBinder binder = GrailsDataBinder.createBinder(object, object.getClass().getName());\n            binder.bind(new MutablePropertyValues(propertyMap));\t\t\t\n\t\t}\n\t\telse {\n\t\t\tthrow new MissingPropertyException(PROPERTY_NAME,object.getClass());\n\t\t}\n\t}","commit_id":"969ea2bc35571ef393b68f720ee17113d17d93df","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * @see wicket.request.IRequestCodingStrategy#decode(wicket.Request)\n\t */\n\tpublic final RequestParameters decode(final Request request)\n\t{\n\t\tfinal RequestParameters parameters = new RequestParameters();\n\t\tfinal String pathInfo = getRequestPath(request);\n\t\tparameters.setPath(pathInfo);\n\t\taddInterfaceParameters(request, parameters);\n\t\taddBookmarkablePageParameters(request, parameters);\n\t\taddResourceParameters(request, parameters);\n\t\tparameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));\n\t\tparameters.setParameters(request.getParameterMap());\n\t\treturn parameters;\n\t}","id":88689,"modified_method":"/**\n\t * @see wicket.request.IRequestCodingStrategy#decode(wicket.Request)\n\t */\n\tpublic final RequestParameters decode(final Request request)\n\t{\n\t\tfinal RequestParameters parameters = new RequestParameters();\n\t\tfinal String pathInfo = getRequestPath(request);\n\t\tparameters.setPath(pathInfo);\n\t\taddInterfaceParameters(request, parameters);\n\t\taddBookmarkablePageParameters(request, parameters);\n\t\taddResourceParameters(request, parameters);\n\t\tparameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));\n\t\tMap map = request.getParameterMap();\n\t\tIterator iterator = map.keySet().iterator();\n\t\twhile (iterator.hasNext())\n\t\t{\n\t\t\tString key = (String)iterator.next();\n\t\t\tif(key.startsWith(NAME_SPACE))\n\t\t\t{\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\t\tparameters.setParameters(map);\n\t\treturn parameters;\n\t}","commit_id":"d0bd83b903b3f4d8cd259c8bba310ee0eacfc556","url":"https://github.com/apache/wicket"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    protected CheckstyleExecutorRequest createRequest()\n            throws MavenReportException\n    {\n        CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();\n        request.setAggregate( true )\n            .setReactorProjects( reactorProjects )\n            .setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )\n            .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )\n            .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )\n            .setLog( getLog() ).setProject( project ).setSourceDirectory( sourceDirectory ).setResources( resources )\n            .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )\n            .setTestSourceDirectory( testSourceDirectory ).setConfigLocation( configLocation )\n            .setPropertyExpansion( propertyExpansion ).setHeaderLocation( headerLocation )\n            .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )\n            .setEncoding( encoding ).setPropertiesLocation( propertiesLocation );\n        return request;\n    }","id":88690,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    protected CheckstyleExecutorRequest createRequest()\n            throws MavenReportException\n    {\n        CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();\n        request.setAggregate(true)\n            .setReactorProjects(reactorProjects)\n            .setConsoleListener(getConsoleListener()).setConsoleOutput(consoleOutput)\n            .setExcludes(excludes).setFailsOnError(failsOnError).setIncludes(includes)\n            .setIncludeResources( includeResources )\n            .setIncludeTestResources( includeTestResources )\n            .setResourceIncludes( resourceIncludes )\n            .setResourceExcludes( resourceExcludes )\n            .setIncludeTestSourceDirectory(includeTestSourceDirectory).setListener( getListener() )\n            .setLog( getLog() ).setProject( project ).setSourceDirectory( sourceDirectory ).setResources( resources )\n            .setTestResources( testResources )\n            .setStringOutputStream(stringOutputStream).setSuppressionsLocation( suppressionsLocation )\n            .setTestSourceDirectory( testSourceDirectory ).setConfigLocation( configLocation )\n            .setPropertyExpansion( propertyExpansion ).setHeaderLocation( headerLocation )\n            .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )\n            .setEncoding( encoding ).setPropertiesLocation( propertiesLocation );\n        return request;\n    }","commit_id":"0b1a17a1b471685225604e7a2d09c05fd40d0f36","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    protected CheckstyleExecutorRequest createRequest()\n            throws MavenReportException\n    {\n        CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();\n        request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )\n            .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )\n            .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )\n            .setLog( getLog() ).setProject( project ).setSourceDirectory( sourceDirectory ).setResources( resources )\n            .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )\n            .setTestSourceDirectory( testSourceDirectory ).setConfigLocation( configLocation )\n            .setPropertyExpansion( propertyExpansion ).setHeaderLocation( headerLocation )\n            .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )\n            .setEncoding( encoding ).setPropertiesLocation( propertiesLocation );\n        return request;\n    }","id":88691,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    protected CheckstyleExecutorRequest createRequest()\n            throws MavenReportException\n    {\n        CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();\n        request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )\n            .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )\n            .setResourceIncludes( resourceIncludes )\n            .setResourceExcludes( resourceExcludes )\n            .setIncludeResources( includeResources )\n            .setIncludeTestResources( includeTestResources )\n            .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )\n            .setLog( getLog() ).setProject( project ).setSourceDirectory( sourceDirectory ).setResources( resources )\n            .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )\n            .setTestSourceDirectory( testSourceDirectory ).setConfigLocation( configLocation )\n            .setPropertyExpansion( propertyExpansion ).setHeaderLocation( headerLocation )\n            .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )\n            .setEncoding( encoding ).setPropertiesLocation( propertiesLocation );\n        return request;\n    }","commit_id":"0b1a17a1b471685225604e7a2d09c05fd40d0f36","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n\n        if ( !skip )\n        {\n\n            if ( !skipExec )\n            {\n\n                ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\n                try\n                {\n                    CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();\n                    request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )\n                        .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )\n                        .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )\n                        .setLog( getLog() ).setProject( project ).setSourceDirectory( sourceDirectory ).setResources( resources )\n                        .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )\n                        .setTestSourceDirectory( testSourceDirectory ).setConfigLocation( configLocation )\n                        .setPropertyExpansion( propertyExpansion ).setHeaderLocation( headerLocation )\n                        .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )\n                        .setEncoding( encoding ).setPropertiesLocation( propertiesLocation );\n\n                    checkstyleExecutor.executeCheckstyle( request );\n\n                }\n                catch ( CheckstyleException e )\n                {\n                    throw new MojoExecutionException( \"Failed during checkstyle configuration\", e );\n                }\n                catch ( CheckstyleExecutorException e )\n                {\n                    throw new MojoExecutionException( \"Failed during checkstyle execution\", e );\n                }\n                finally\n                {\n                    //be sure to restore original context classloader\n                    Thread.currentThread().setContextClassLoader( currentClassLoader );\n                }\n\n            }\n            if ( !\"xml\".equals( outputFileFormat ) )\n            {\n                throw new MojoExecutionException( \"Output format is '\" + outputFileFormat\n                    + \"', checkstyle:check requires format to be 'xml'.\" );\n            }\n\n            if ( !outputFile.exists() )\n            {\n                getLog().info(\n                               \"Unable to perform checkstyle:check, \"\n                                   + \"unable to find checkstyle:checkstyle outputFile.\" );\n                return;\n            }\n\n            try\n            {\n                XmlPullParser xpp = new MXParser();\n                Reader freader = ReaderFactory.newXmlReader( outputFile );\n                BufferedReader breader = new BufferedReader( freader );\n                xpp.setInput( breader );\n\n                int violations = countViolations( xpp );\n                if ( violations > maxAllowedViolations )\n                {\n                    if ( failOnViolation )\n                    {\n                        String msg = \"You have \" + violations + \" Checkstyle violation\"\n                            + ( ( violations > 1 ) ? \"s\" : \"\" ) + \".\";\n                        if ( maxAllowedViolations > 0 )\n                        {\n                            msg += \" The maximum number of allowed violations is \" + maxAllowedViolations + \".\";\n                        }\n                        throw new MojoFailureException( msg );\n                    }\n\n                    getLog().warn( \"checkstyle:check violations detected but failOnViolation set to false\" );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Unable to read Checkstyle results xml: \"\n                    + outputFile.getAbsolutePath(), e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new MojoExecutionException( \"Unable to read Checkstyle results xml: \"\n                    + outputFile.getAbsolutePath(), e );\n            }\n        }\n    }","id":88692,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n\n        if ( !skip )\n        {\n\n            if ( !skipExec )\n            {\n\n                ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n\n                try\n                {\n                    CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();\n                    request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )\n                        .setExcludes(excludes).setFailsOnError(failsOnError).setIncludes(includes)\n                        .setResourceIncludes( resourceIncludes )\n                        .setResourceExcludes( resourceExcludes )\n                        .setIncludeResources( includeResources )\n                        .setIncludeTestResources( includeTestResources )\n                        .setIncludeTestSourceDirectory(includeTestSourceDirectory).setListener(getListener())\n                        .setLog(getLog()).setProject(project).setSourceDirectory(sourceDirectory).setResources(resources)\n                        .setStringOutputStream(stringOutputStream).setSuppressionsLocation(suppressionsLocation)\n                        .setTestSourceDirectory(testSourceDirectory).setConfigLocation(configLocation)\n                        .setPropertyExpansion(propertyExpansion).setHeaderLocation(headerLocation)\n                        .setCacheFile(cacheFile).setSuppressionsFileExpression(suppressionsFileExpression)\n                        .setEncoding(encoding).setPropertiesLocation(propertiesLocation);\n                    checkstyleExecutor.executeCheckstyle(request);\n\n                }\n                catch ( CheckstyleException e )\n                {\n                    throw new MojoExecutionException( \"Failed during checkstyle configuration\", e );\n                }\n                catch ( CheckstyleExecutorException e )\n                {\n                    throw new MojoExecutionException( \"Failed during checkstyle execution\", e );\n                }\n                finally\n                {\n                    //be sure to restore original context classloader\n                    Thread.currentThread().setContextClassLoader( currentClassLoader );\n                }\n\n            }\n            if ( !\"xml\".equals( outputFileFormat ) )\n            {\n                throw new MojoExecutionException( \"Output format is '\" + outputFileFormat\n                    + \"', checkstyle:check requires format to be 'xml'.\" );\n            }\n\n            if ( !outputFile.exists() )\n            {\n                getLog().info(\n                               \"Unable to perform checkstyle:check, \"\n                                   + \"unable to find checkstyle:checkstyle outputFile.\" );\n                return;\n            }\n\n            try\n            {\n                XmlPullParser xpp = new MXParser();\n                Reader freader = ReaderFactory.newXmlReader( outputFile );\n                BufferedReader breader = new BufferedReader( freader );\n                xpp.setInput( breader );\n\n                int violations = countViolations( xpp );\n                if ( violations > maxAllowedViolations )\n                {\n                    if ( failOnViolation )\n                    {\n                        String msg = \"You have \" + violations + \" Checkstyle violation\"\n                            + ( ( violations > 1 ) ? \"s\" : \"\" ) + \".\";\n                        if ( maxAllowedViolations > 0 )\n                        {\n                            msg += \" The maximum number of allowed violations is \" + maxAllowedViolations + \".\";\n                        }\n                        throw new MojoFailureException( msg );\n                    }\n\n                    getLog().warn( \"checkstyle:check violations detected but failOnViolation set to false\" );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Unable to read Checkstyle results xml: \"\n                    + outputFile.getAbsolutePath(), e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new MojoExecutionException( \"Unable to read Checkstyle results xml: \"\n                    + outputFile.getAbsolutePath(), e );\n            }\n        }\n    }","commit_id":"0b1a17a1b471685225604e7a2d09c05fd40d0f36","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addFilesToProcess( CheckstyleExecutorRequest request, StringBuilder excludesStr, File sourceDirectory,\n                                    List<Resource> resources, File testSourceDirectory, List<File> files )\n        throws IOException\n    {\n        if ( sourceDirectory != null && sourceDirectory.exists() )\n        {\n            final List sourceFiles = FileUtils.getFiles( sourceDirectory,\n                                                         request.getIncludes(),\n                                                         excludesStr.toString() );\n            files.addAll( sourceFiles );\n            getLogger().debug( \"Added \" + sourceFiles.size() + \" source files found in '\"\n                    + sourceDirectory.getAbsolutePath() + \"'.\" );\n        }\n\n        if ( request.isIncludeTestSourceDirectory() && ( testSourceDirectory != null )\n            && ( testSourceDirectory.exists() ) && ( testSourceDirectory.isDirectory() ) )\n        {\n            final List testSourceFiles = FileUtils.getFiles( testSourceDirectory, request.getIncludes(),\n                                                             excludesStr.toString() );\n            files.addAll( testSourceFiles );\n            getLogger().debug( \"Added \" + testSourceFiles.size() + \" test source files found in '\"\n                    + testSourceDirectory.getAbsolutePath() + \"'.\" );\n        }\n\n        // @todo Should we add a check to see if resources should be included or not, similar to request.isIncludeTestSourceDirectory()?\n        if ( resources != null )\n        {\n            for ( Resource resource : resources )\n            {\n                if ( resource.getDirectory() != null )\n                {\n                    File resourcesDirectory = new File( resource.getDirectory() );\n                    if ( resourcesDirectory.exists() && resourcesDirectory.isDirectory() )\n                    {\n                        // @todo Perhaps extend the functionality in the future so that the included types of files can be configured. For now it is hard-coded to properties files.\n                        List resourceFiles = FileUtils.getFiles( resourcesDirectory, \"**/*.properties\", null );\n                        files.addAll( resourceFiles );\n                        getLogger().debug( \"Added \" + resourceFiles.size() + \" resource files found in '\"\n                                + resourcesDirectory.getAbsolutePath() + \"'.\" );\n                    }\n                    else\n                    {\n                        getLogger().debug( \"The resources directory '\" + resourcesDirectory.getAbsolutePath()\n                                + \"' does not exist or is not a directory.\" );\n                    }\n                }\n            }\n        }\n        else\n        {\n            getLogger().debug( \"No resources found in this project.\" );\n        }\n    }","id":88693,"modified_method":"private void addFilesToProcess( CheckstyleExecutorRequest request, File sourceDirectory,\n                                   List<Resource> resources, List<Resource> testResources, List<File> files, File testSourceDirectory )\n        throws IOException\n    {\n        if ( sourceDirectory != null && sourceDirectory.exists() )\n        {\n            final List sourceFiles = FileUtils.getFiles( sourceDirectory,\n                                                         request.getIncludes(),\n                                                         request.getExcludes() );\n            files.addAll( sourceFiles );\n            getLogger().debug( \"Added \" + sourceFiles.size() + \" source files found in '\"\n                    + sourceDirectory.getAbsolutePath() + \"'.\" );\n        }\n\n        if ( request.isIncludeTestSourceDirectory() && ( testSourceDirectory != null )\n            && ( testSourceDirectory.exists() ) && ( testSourceDirectory.isDirectory() ) )\n        {\n            final List testSourceFiles = FileUtils.getFiles( testSourceDirectory, request.getIncludes(),\n                                                             request.getExcludes() );\n            files.addAll( testSourceFiles );\n            getLogger().debug( \"Added \" + testSourceFiles.size() + \" test source files found in '\"\n                    + testSourceDirectory.getAbsolutePath() + \"'.\" );\n        }\n\n        if ( resources != null && request.isIncludeResources() )\n        {\n            addResourceFilesToProcess( request, resources, files );\n        }\n        else\n        {\n            getLogger().debug( \"No resources found in this project.\" );\n        }\n\n        if ( testResources != null && request.isIncludeTestResources() )\n        {\n            addResourceFilesToProcess( request, testResources, files );\n        }\n        else\n        {\n            getLogger().debug( \"No test resources found in this project.\" );\n        }\n    }","commit_id":"0b1a17a1b471685225604e7a2d09c05fd40d0f36","url":"https://github.com/apache/maven-plugins"},{"original_method":"private File[] getFilesToProcess( CheckstyleExecutorRequest request )\n        throws IOException\n    {\n        StringBuilder excludesStr = new StringBuilder();\n\n        if ( StringUtils.isNotEmpty( request.getExcludes() ) )\n        {\n            excludesStr.append( request.getExcludes() );\n        }\n\n        String[] defaultExcludes = FileUtils.getDefaultExcludes();\n        for (String defaultExclude : defaultExcludes) {\n            if (excludesStr.length() > 0) {\n                excludesStr.append(\",\");\n            }\n\n            excludesStr.append(defaultExclude);\n        }\n\n        File sourceDirectory = request.getSourceDirectory();\n\n        List<File> files = new ArrayList<File>();\n        if ( request.isAggregate() )\n        {\n            for ( MavenProject project : request.getReactorProjects() )\n            {\n                addFilesToProcess( request, excludesStr, new File( project.getBuild().getSourceDirectory() ),\n                                   project.getResources(), new File( project.getBuild().getTestSourceDirectory() ),\n                                   files );\n            }\n        }\n        else\n        {\n            addFilesToProcess( request, excludesStr, sourceDirectory, request.getResources(),\n                               request.getTestSourceDirectory(), files );\n        }\n\n        getLogger().debug( \"Added \" + files.size() + \" files to process.\" );\n\n        return files.toArray(new File[files.size()]);\n    }","id":88694,"modified_method":"private File[] getFilesToProcess( CheckstyleExecutorRequest request )\n        throws IOException\n    {\n        StringBuilder excludesStr = new StringBuilder();\n\n        if ( StringUtils.isNotEmpty( request.getExcludes() ) )\n        {\n            excludesStr.append( request.getExcludes() );\n        }\n\n        String[] defaultExcludes = FileUtils.getDefaultExcludes();\n        for (String defaultExclude : defaultExcludes) {\n            if (excludesStr.length() > 0) {\n                excludesStr.append(\",\");\n            }\n\n            excludesStr.append(defaultExclude);\n        }\n\n        File sourceDirectory = request.getSourceDirectory();\n\n        List<File> files = new ArrayList<File>();\n        if ( request.isAggregate() )\n        {\n            for ( MavenProject project : request.getReactorProjects() )\n            {\n                addFilesToProcess( request, new File( project.getBuild().getSourceDirectory() ),\n                                   project.getResources(), project.getTestResources(),\n                                   files, new File( project.getBuild().getTestSourceDirectory() )\n                );\n            }\n        }\n        else\n        {\n            addFilesToProcess( request, sourceDirectory, request.getResources(),\n                request.getTestResources(), files, request.getTestSourceDirectory() );\n        }\n\n        getLogger().debug( \"Added \" + files.size() + \" files to process.\" );\n\n        return files.toArray( new File[files.size()] );\n    }","commit_id":"0b1a17a1b471685225604e7a2d09c05fd40d0f36","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method to get the list of files where the PMD tool will be executed\n     *\n     * @return a List of the files where the PMD tool will be executed\n     * @throws java.io.IOException\n     */\n    protected Map getFilesToProcess( )\n        throws IOException\n    {\n        String sourceXref = constructXRefLocation( false );\n        String testXref = includeTests ? constructXRefLocation( true ) : \"\";\n        \n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return Collections.EMPTY_MAP;\n        }\n\n        if ( excludeRoots == null )\n        {\n            excludeRoots = Collections.EMPTY_LIST;\n        }\n        List excludeRootFiles = new ArrayList(excludeRoots.size());\n        \n        for (Iterator it = excludeRoots.iterator(); it.hasNext();) \n        {\n            String root = (String)it.next();\n            File file = new File(root);\n            if ( file.exists()\n                && file.isDirectory())\n            {\n                excludeRootFiles.add(file);\n            }\n        }\n        \n        List directories = new ArrayList(compileSourceRoots);\n        List testdirectories = new ArrayList();\n        if ( includeTests )\n        {\n            testdirectories.addAll(testSourceRoots);\n        }\n        if ( aggregate )\n        {\n            for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n            {\n                MavenProject localProject = (MavenProject) i.next();\n                directories.addAll(localProject.getCompileSourceRoots());\n                if ( includeTests )\n                {\n                    testdirectories.addAll(localProject.getTestCompileSourceRoots());\n                }\n            }\n  \n        }\n        \n        String excluding = getIncludeExcludeString( excludes );\n        String including = getIncludeExcludeString( includes );\n        Map files = new TreeMap();\n        \n        if ( \"\".equals(including) )\n        {\n            including = \"**/*.java\";\n        }\n\n        StringBuffer excludesStr = new StringBuffer();\n        if ( StringUtils.isNotEmpty( excluding ) )\n        {\n            excludesStr.append( excluding );\n        }\n        String[] defaultExcludes = FileUtils.getDefaultExcludes();\n        for ( int i = 0; i < defaultExcludes.length; i++ )\n        {\n            if ( excludesStr.length() > 0 )\n            {\n                excludesStr.append( \",\" );\n            }\n            excludesStr.append( defaultExcludes[i] );\n        }\n        getLog().debug( \"Excluded files: '\" + excludesStr + \"'\" );\n\n        for ( Iterator it = directories.iterator(); it.hasNext();)\n        {\n            String root = (String)it.next();\n            File sourceDirectory = new File(root);\n            if ( sourceDirectory.exists()\n                && sourceDirectory.isDirectory()\n                && !excludeRootFiles.contains(sourceDirectory))\n            {\n                List newfiles = FileUtils.getFiles( sourceDirectory, including, excludesStr.toString() );\n                for ( Iterator it2 = newfiles.iterator(); it2.hasNext(); )\n                {\n                    files.put( it2.next(), new Object[] { sourceDirectory , sourceXref });\n                }\n            }\n        }        \n        for ( Iterator it = testdirectories.iterator(); it.hasNext();)\n        {\n            String root = (String)it.next();\n            File testDirectory = new File(root);\n            if ( testDirectory.exists()\n                && testDirectory.isDirectory()\n                && !excludeRootFiles.contains(testDirectory))\n            {\n                List newfiles = FileUtils.getFiles( testDirectory, including, excludesStr.toString() );\n                for ( Iterator it2 = newfiles.iterator(); it2.hasNext(); )\n                {\n                    files.put( it2.next(), new Object[] { testDirectory , testXref });\n                }\n            }\n        }        \n        return files;\n    }","id":88695,"modified_method":"/**\n     * Convenience method to get the list of files where the PMD tool will be executed\n     *\n     * @return a List of the files where the PMD tool will be executed\n     * @throws java.io.IOException\n     */\n    protected Map getFilesToProcess( )\n        throws IOException\n    {\n        String sourceXref = constructXRefLocation( false );\n        String testXref = includeTests ? constructXRefLocation( true ) : \"\";\n        \n        if ( aggregate && !project.isExecutionRoot() )\n        {\n            return Collections.EMPTY_MAP;\n        }\n\n        if ( excludeRoots == null )\n        {\n            excludeRoots = Collections.EMPTY_LIST;\n        }\n        List excludeRootFiles = new ArrayList(excludeRoots.size());\n        \n        for (Iterator it = excludeRoots.iterator(); it.hasNext();) \n        {\n            String root = (String)it.next();\n            File file = new File(root);\n            if ( file.exists()\n                && file.isDirectory())\n            {\n                excludeRootFiles.add(file);\n            }\n        }\n        \n        List directories = new ArrayList();\n        \n        for ( Iterator i = compileSourceRoots.iterator(); i.hasNext(); )\n        {\n            String root = (String) i.next();\n            File sroot = new File(root);\n            directories.add( new PmdFileInfo( project, sroot, sourceXref) );\n        }\n        \n        if ( includeTests )\n        {\n            for ( Iterator i = testSourceRoots.iterator(); i.hasNext(); )\n            {\n                String root = (String) i.next();\n                File sroot = new File(root);\n                directories.add( new PmdFileInfo( project, sroot, testXref) );\n            }\n        }\n        if ( aggregate )\n        {\n            for ( Iterator i = reactorProjects.iterator(); i.hasNext(); )\n            {\n                MavenProject localProject = (MavenProject) i.next();\n                for ( Iterator i2 = localProject.getCompileSourceRoots().iterator(); i2.hasNext(); )\n                {\n                    String root = (String) i2.next();\n                    File sroot = new File(root);\n                    directories.add( new PmdFileInfo( localProject, sroot, sourceXref) );\n                }\n                if ( includeTests )\n                {\n                    for ( Iterator i2 = localProject.getTestCompileSourceRoots().iterator(); i2.hasNext(); )\n                    {\n                        String root = (String) i2.next();\n                        File sroot = new File(root);\n                        directories.add( new PmdFileInfo( localProject, sroot, testXref) );\n                    }\n                }\n            }\n  \n        }\n        \n        String excluding = getIncludeExcludeString( excludes );\n        String including = getIncludeExcludeString( includes );\n        Map files = new TreeMap();\n        \n        if ( \"\".equals(including) )\n        {\n            including = \"**/*.java\";\n        }\n\n        StringBuffer excludesStr = new StringBuffer();\n        if ( StringUtils.isNotEmpty( excluding ) )\n        {\n            excludesStr.append( excluding );\n        }\n        String[] defaultExcludes = FileUtils.getDefaultExcludes();\n        for ( int i = 0; i < defaultExcludes.length; i++ )\n        {\n            if ( excludesStr.length() > 0 )\n            {\n                excludesStr.append( \",\" );\n            }\n            excludesStr.append( defaultExcludes[i] );\n        }\n        getLog().debug( \"Excluded files: '\" + excludesStr + \"'\" );\n\n        for ( Iterator it = directories.iterator(); it.hasNext();)\n        {\n            PmdFileInfo finfo = (PmdFileInfo) it.next();\n            File sourceDirectory = finfo.getSourceDirectory();\n            if ( sourceDirectory.exists()\n                && sourceDirectory.isDirectory()\n                && !excludeRootFiles.contains(sourceDirectory))\n            {\n                List newfiles = FileUtils.getFiles( sourceDirectory, including, excludesStr.toString() );\n                for ( Iterator it2 = newfiles.iterator(); it2.hasNext(); )\n                {\n                    files.put( it2.next(), finfo);\n                }\n            }\n        }        \n                \n        return files;\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip && canGenerateReport() )\n        {         \n            CPD cpd = new CPD(minimumTokens, new JavaLanguage());\n            Map files = null;\n            try\n            {\n                files = getFilesToProcess( );\n                for ( Iterator it = files.keySet().iterator(); it.hasNext(); ) \n                {\n                    cpd.add( (File) it.next() );\n                }\n            }\n            catch (IOException e)\n            {\n                throw new MavenReportException(e.getMessage(), e);\n            }\n            cpd.go();\n\n            CpdReportGenerator gen =\n                new CpdReportGenerator( getSink(), files, getBundle( locale ) );\n            gen.generate( cpd.getMatches() );\n\n            if ( !isHtml() )\n            {\n                Renderer r = createRenderer();\n                String buffer = r.render( cpd.getMatches() );\n                try\n                {\n                    targetDirectory.mkdirs();\n                    Writer writer = new FileWriter( new File( targetDirectory, \"cpd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n                    \n                    \n                    File siteDir = new File(targetDirectory, \"site\");\n                    siteDir.mkdirs();\n                    writer = new FileWriter( new File( siteDir,\n                                                         \"cpd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n                    \n                }\n                catch ( IOException ioe )\n                {\n                    throw new MavenReportException( ioe.getMessage(), ioe );\n                }\n            }\n        }\n    }","id":88696,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip && canGenerateReport() )\n        {         \n            CPD cpd = new CPD(minimumTokens, new JavaLanguage());\n            Map files = null;\n            try\n            {\n                files = getFilesToProcess( );\n                for ( Iterator it = files.keySet().iterator(); it.hasNext(); ) \n                {\n                    cpd.add( (File) it.next() );\n                }\n            }\n            catch (IOException e)\n            {\n                throw new MavenReportException(e.getMessage(), e);\n            }\n            cpd.go();\n\n            CpdReportGenerator gen =\n                new CpdReportGenerator( getSink(), files, getBundle( locale ), aggregate );\n            gen.generate( cpd.getMatches() );\n\n            if ( !isHtml() )\n            {\n                Renderer r = createRenderer();\n                String buffer = r.render( cpd.getMatches() );\n                try\n                {\n                    targetDirectory.mkdirs();\n                    Writer writer = new FileWriter( new File( targetDirectory, \"cpd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n                    \n                    \n                    File siteDir = new File(targetDirectory, \"site\");\n                    siteDir.mkdirs();\n                    writer = new FileWriter( new File( siteDir,\n                                                         \"cpd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n                    \n                }\n                catch ( IOException ioe )\n                {\n                    throw new MavenReportException( ioe.getMessage(), ioe );\n                }\n            }\n        }\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method that generates the contents of the CPD report\n     *\n     * @param matches\n     */\n    public void generate( Iterator matches )\n    {\n        beginDocument();\n\n        if ( !matches.hasNext() )\n        {\n            sink.text( \"CPD found no problems in your source code.\" );            \n        }\n\n        while ( matches.hasNext() )\n        {\n            Match match = (Match) matches.next();\n            String filename1 = match.getFirstMark().getTokenSrcID();\n            \n            File file = new File( filename1 );\n            Object fileInfo[] = (Object[]) fileMap.get( file );\n            File sourceDirectory = (File) fileInfo[0];\n            String xrefLocation = (String) fileInfo[1];\n            \n            filename1 = StringUtils.substring( filename1, sourceDirectory.getAbsolutePath().length() + 1 );\n\n            String filename2 = match.getSecondMark().getTokenSrcID();\n            file = new File( filename2 );\n            fileInfo = (Object[]) fileMap.get( file );\n            sourceDirectory = (File) fileInfo[0];\n            String xrefLocation2 = (String) fileInfo[1];\n            filename2 = StringUtils.substring( filename2, sourceDirectory.getAbsolutePath().length() + 1 );\n\n            String code = match.getSourceCodeSlice();\n            int line1 = match.getFirstMark().getBeginLine();\n            int line2 = match.getSecondMark().getBeginLine();\n\n            sink.paragraph();\n            sink.table();\n            sink.tableRow();\n            sink.tableHeaderCell();\n            sink.text( bundle.getString( \"report.cpd.column.file\" ) );\n            sink.tableHeaderCell_();\n            sink.tableHeaderCell();\n            sink.text( bundle.getString( \"report.cpd.column.line\" ) );\n            sink.tableHeaderCell_();\n            sink.tableRow_();\n\n            // File 1\n            sink.tableRow();\n            sink.tableCell();\n            sink.text( filename1 );\n            sink.tableCell_();\n            sink.tableCell();\n\n            if ( xrefLocation != null )\n            {\n                sink.link( xrefLocation + \"/\" + filename1.replaceAll( \"\\\\.java$\", \".html\" ).replace( '\\\\', '/' ) + \"#\" +\n                    line1 );\n            }\n            sink.text( String.valueOf( line1 ) );\n            if ( xrefLocation != null )\n            {\n                sink.link_();\n            }\n\n            sink.tableCell_();\n            sink.tableRow_();\n\n            // File 2\n            sink.tableRow();\n            sink.tableCell();\n            sink.text( filename2 );\n            sink.tableCell_();\n            sink.tableCell();\n            if ( xrefLocation != null )\n            {\n                sink.link( xrefLocation2 + \"/\" + filename2.replaceAll( \"\\\\.java$\", \".html\" ).replace( '\\\\', '/' ) + \"#\" +\n                    line2 );\n            }\n            sink.text( String.valueOf( line2 ) );\n            if ( xrefLocation != null )\n            {\n                sink.link_();\n            }\n            sink.tableCell_();\n            sink.tableRow_();\n\n            // Source snippet\n            sink.tableRow();\n\n            // TODO Cleaner way to do this?\n            sink.rawText( \"<td colspan='2'>\" );\n            sink.verbatim( false );\n            sink.text( code );\n            sink.verbatim_();\n            sink.rawText( \"<\/td>\" );\n            sink.tableRow_();\n            sink.table();\n            sink.paragraph_();\n        }\n\n        sink.section1_();\n        sink.body_();\n        sink.flush();\n        sink.close();\n    }","id":88697,"modified_method":"/**\n     * Method that generates the contents of the CPD report\n     *\n     * @param matches\n     */\n    public void generate( Iterator matches )\n    {\n        beginDocument();\n\n        if ( !matches.hasNext() )\n        {\n            sink.text( \"CPD found no problems in your source code.\" );            \n        }\n\n        while ( matches.hasNext() )\n        {\n            Match match = (Match) matches.next();\n            String filename1 = match.getFirstMark().getTokenSrcID();\n            \n            File file = new File( filename1 );\n            PmdFileInfo fileInfo = (PmdFileInfo) fileMap.get( file );\n            File sourceDirectory = fileInfo.getSourceDirectory();\n            String xrefLocation = fileInfo.getXrefLocation();\n            MavenProject projectFile1 = fileInfo.getProject();\n            \n            filename1 = StringUtils.substring( filename1, sourceDirectory.getAbsolutePath().length() + 1 );\n\n            String filename2 = match.getSecondMark().getTokenSrcID();\n            file = new File( filename2 );\n            fileInfo = (PmdFileInfo) fileMap.get( file );\n            sourceDirectory = fileInfo.getSourceDirectory();\n            String xrefLocation2 = fileInfo.getXrefLocation();\n            filename2 = StringUtils.substring( filename2, sourceDirectory.getAbsolutePath().length() + 1 );\n            MavenProject projectFile2 = fileInfo.getProject();\n\n            String code = match.getSourceCodeSlice();\n            int line1 = match.getFirstMark().getBeginLine();\n            int line2 = match.getSecondMark().getBeginLine();\n\n            sink.paragraph();\n            sink.table();\n            sink.tableRow();\n            sink.tableHeaderCell();\n            sink.text( bundle.getString( \"report.cpd.column.file\" ) );\n            sink.tableHeaderCell_();\n            if ( aggregate )\n            {\n                sink.tableHeaderCell();\n                sink.text( bundle.getString( \"report.cpd.column.project\" ) );\n                sink.tableHeaderCell_();\n            }\n            sink.tableHeaderCell();\n            sink.text( bundle.getString( \"report.cpd.column.line\" ) );\n            sink.tableHeaderCell_();\n            sink.tableRow_();\n\n            // File 1\n            sink.tableRow();\n            sink.tableCell();\n            sink.text( filename1 );\n            sink.tableCell_();\n            if ( aggregate )\n            {\n                sink.tableCell();\n                sink.text( projectFile1.getName() );\n                sink.tableCell_();\n            }\n            sink.tableCell();\n\n            if ( xrefLocation != null )\n            {\n                sink.link( xrefLocation + \"/\" + filename1.replaceAll( \"\\\\.java$\", \".html\" ).replace( '\\\\', '/' ) + \"#\" +\n                    line1 );\n            }\n            sink.text( String.valueOf( line1 ) );\n            if ( xrefLocation != null )\n            {\n                sink.link_();\n            }\n\n            sink.tableCell_();\n            sink.tableRow_();\n\n            // File 2\n            sink.tableRow();\n            sink.tableCell();\n            sink.text( filename2 );\n            sink.tableCell_();\n            if ( aggregate )\n            {\n                sink.tableCell();\n                sink.text( projectFile2.getName() );\n                sink.tableCell_();\n            }\n            sink.tableCell();\n            \n            \n            \n            if ( xrefLocation != null )\n            {\n                sink.link( xrefLocation2 + \"/\" + filename2.replaceAll( \"\\\\.java$\", \".html\" ).replace( '\\\\', '/' ) + \"#\" +\n                    line2 );\n            }\n            sink.text( String.valueOf( line2 ) );\n            if ( xrefLocation != null )\n            {\n                sink.link_();\n            }\n            sink.tableCell_();\n            sink.tableRow_();\n\n            // Source snippet\n            sink.tableRow();\n\n            \n            int colspan = 2;\n            if ( aggregate ) {\n                colspan = 3;\n            }        \n            // TODO Cleaner way to do this?\n            sink.rawText( \"<td colspan='\" + colspan + \"'>\" );\n            sink.verbatim( false );\n            sink.text( code );\n            sink.verbatim_();\n            sink.rawText( \"<\/td>\" );\n            sink.tableRow_();\n            sink.table();\n            sink.paragraph_();\n        }\n\n        sink.section1_();\n        sink.body_();\n        sink.flush();\n        sink.close();\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"public CpdReportGenerator( Sink sink, Map fileMap, ResourceBundle bundle )\n    {\n        this.sink = sink;\n        this.fileMap = fileMap;\n        this.bundle = bundle;\n    }","id":88698,"modified_method":"public CpdReportGenerator( Sink sink, Map fileMap, ResourceBundle bundle, boolean aggregate )\n    {\n        this.sink = sink;\n        this.fileMap = fileMap;\n        this.bundle = bundle;\n        this.aggregate = aggregate;\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale) */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip && canGenerateReport() )\n        {\n            Sink sink = getSink();\n\n            PMD pmd = getPMD();\n            RuleContext ruleContext = new RuleContext();\n            Report report = new Report();\n            // TODO: use source roots instead\n            PmdReportListener reportSink = new PmdReportListener( sink, getBundle( locale ) );\n\n            report.addListener( reportSink );\n            ruleContext.setReport( report );\n            reportSink.beginDocument();\n\n            RuleSetFactory ruleSetFactory = new RuleSetFactory();\n            ruleSetFactory.setMinimumPriority( this.minimumPriority );\n            RuleSet[] sets = new RuleSet[rulesets.length];\n            try\n            {\n                for ( int idx = 0; idx < rulesets.length; idx++ )\n                {\n                    String set = rulesets[idx];\n                    getLog().debug( \"Preparing ruleset: \" + set );\n                    File ruleset = locator.resolveLocation( set, getLocationTemp( set ) );\n                    InputStream rulesInput = null;\n                    if ( null == ruleset)\n                    {\n                        //  workaround bug in resource manager when run in reporting mode\n                        rulesInput = this.getClass().getClassLoader().getResourceAsStream( set );\n                    }\n                    else\n                    {\n                        rulesInput = new FileInputStream( ruleset );\n                    }\n                    if ( null == rulesInput )\n                    {\n                        throw new MavenReportException( \"Cold not resolve \" + set );\n                    }\n\n                    sets[idx] = ruleSetFactory.createRuleSet( rulesInput );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n\n            boolean hasEncoding = sourceEncoding != null;\n\n            Map files;\n            try\n            {\n                files = getFilesToProcess( );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Can't get file list\", e );\n            }\n\n            for ( Iterator i = files.entrySet().iterator(); i.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) i.next();\n                File file = (File) entry.getKey();\n                Object fileInfo[] = (Object[]) entry.getValue();\n                File sourceDir = (File) fileInfo[0];\n                String xrefLoc = (String) fileInfo[1];\n\n                // TODO: lazily call beginFile in case there are no rules\n\n                reportSink.beginFile( file , sourceDir );\n                reportSink.setXrefLocation( xrefLoc );\n                ruleContext.setSourceCodeFilename( file.getAbsolutePath() );\n                for ( int idx = 0; idx < rulesets.length; idx++ )\n                {\n                    try\n                    {\n                        // PMD closes this Reader even though it did not open it so we have\n                        // to open a new one with every call to processFile().\n                        Reader reader = hasEncoding ? new InputStreamReader( new FileInputStream( file ),\n                                                                             sourceEncoding ) : new FileReader( file );\n                        pmd.processFile( reader, sets[idx], ruleContext );\n                    }\n                    catch ( UnsupportedEncodingException e1 )\n                    {\n                        throw new MavenReportException( \"Encoding '\" + sourceEncoding + \"' is not supported.\", e1 );\n                    }\n                    catch ( FileNotFoundException e2 )\n                    {\n                        getLog().warn( \"Error opening source file: \" + file );\n                        reportSink.ruleViolationAdded(\n                            new ProcessingErrorRuleViolation( file, e2.getLocalizedMessage() ) );\n                    }\n                    catch ( Exception e3 )\n                    {\n                        getLog().warn( \"Failure executing PMD for: \" + file, e3 );\n                        reportSink.ruleViolationAdded(\n                            new ProcessingErrorRuleViolation( file, e3.getLocalizedMessage() ) );\n                    }\n                }\n                reportSink.endFile( file );\n            }\n\n            reportSink.endDocument();\n\n            if ( !isHtml() )\n            {\n                // Use the PMD renderers to render in any format aside from HTML.\n                Renderer r = createRenderer();\n                String buffer = r.render( report );\n                try\n                {\n                    Writer writer = new FileWriter( new File( targetDirectory, \"pmd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n\n                    File siteDir = new File(targetDirectory, \"site\");\n                    siteDir.mkdirs();\n                    writer = new FileWriter( new File( siteDir,\n                                                         \"pmd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n                }\n                catch ( IOException ioe )\n                {\n                    throw new MavenReportException( ioe.getMessage(), ioe );\n                }\n            }\n        }\n    }","id":88699,"modified_method":"/** @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale) */\n    public void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        if ( !skip && canGenerateReport() )\n        {\n            Sink sink = getSink();\n\n            PMD pmd = getPMD();\n            RuleContext ruleContext = new RuleContext();\n            Report report = new Report();\n            // TODO: use source roots instead\n            PmdReportListener reportSink = new PmdReportListener( sink, getBundle( locale ), aggregate );\n\n            report.addListener( reportSink );\n            ruleContext.setReport( report );\n            reportSink.beginDocument();\n\n            RuleSetFactory ruleSetFactory = new RuleSetFactory();\n            ruleSetFactory.setMinimumPriority( this.minimumPriority );\n            RuleSet[] sets = new RuleSet[rulesets.length];\n            try\n            {\n                for ( int idx = 0; idx < rulesets.length; idx++ )\n                {\n                    String set = rulesets[idx];\n                    getLog().debug( \"Preparing ruleset: \" + set );\n                    File ruleset = locator.resolveLocation( set, getLocationTemp( set ) );\n                    InputStream rulesInput = null;\n                    if ( null == ruleset)\n                    {\n                        //  workaround bug in resource manager when run in reporting mode\n                        rulesInput = this.getClass().getClassLoader().getResourceAsStream( set );\n                    }\n                    else\n                    {\n                        rulesInput = new FileInputStream( ruleset );\n                    }\n                    if ( null == rulesInput )\n                    {\n                        throw new MavenReportException( \"Cold not resolve \" + set );\n                    }\n\n                    sets[idx] = ruleSetFactory.createRuleSet( rulesInput );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( e.getMessage(), e );\n            }\n\n            boolean hasEncoding = sourceEncoding != null;\n\n            Map files;\n            try\n            {\n                files = getFilesToProcess( );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Can't get file list\", e );\n            }\n\n            for ( Iterator i = files.entrySet().iterator(); i.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) i.next();\n                File file = (File) entry.getKey();\n                PmdFileInfo fileInfo = (PmdFileInfo) entry.getValue();\n                File sourceDir = fileInfo.getSourceDirectory();\n\n                // TODO: lazily call beginFile in case there are no rules\n\n                reportSink.beginFile( file , fileInfo );\n                ruleContext.setSourceCodeFilename( file.getAbsolutePath() );\n                for ( int idx = 0; idx < rulesets.length; idx++ )\n                {\n                    try\n                    {\n                        // PMD closes this Reader even though it did not open it so we have\n                        // to open a new one with every call to processFile().\n                        Reader reader = hasEncoding ? new InputStreamReader( new FileInputStream( file ),\n                                                                             sourceEncoding ) : new FileReader( file );\n                        pmd.processFile( reader, sets[idx], ruleContext );\n                    }\n                    catch ( UnsupportedEncodingException e1 )\n                    {\n                        throw new MavenReportException( \"Encoding '\" + sourceEncoding + \"' is not supported.\", e1 );\n                    }\n                    catch ( FileNotFoundException e2 )\n                    {\n                        getLog().warn( \"Error opening source file: \" + file );\n                        reportSink.ruleViolationAdded(\n                            new ProcessingErrorRuleViolation( file, e2.getLocalizedMessage() ) );\n                    }\n                    catch ( Exception e3 )\n                    {\n                        getLog().warn( \"Failure executing PMD for: \" + file, e3 );\n                        reportSink.ruleViolationAdded(\n                            new ProcessingErrorRuleViolation( file, e3.getLocalizedMessage() ) );\n                    }\n                }\n                reportSink.endFile( file );\n            }\n\n            reportSink.endDocument();\n\n            if ( !isHtml() )\n            {\n                // Use the PMD renderers to render in any format aside from HTML.\n                Renderer r = createRenderer();\n                String buffer = r.render( report );\n                try\n                {\n                    Writer writer = new FileWriter( new File( targetDirectory, \"pmd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n\n                    File siteDir = new File(targetDirectory, \"site\");\n                    siteDir.mkdirs();\n                    writer = new FileWriter( new File( siteDir,\n                                                         \"pmd.\" + format ) );\n                    writer.write( buffer, 0, buffer.length() );\n                    writer.close();\n                }\n                catch ( IOException ioe )\n                {\n                    throw new MavenReportException( ioe.getMessage(), ioe );\n                }\n            }\n        }\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void outputLineLink( int line )\r\n    {\r\n        if ( xrefLocation != null )\r\n        {\r\n            sink.link( xrefLocation + \"/\" + currentFilename.replaceAll( \"\\\\.java$\", \".html\" ) + \"#\" + line );\r\n        }\r\n        sink.text( String.valueOf( line ) );\r\n        if ( xrefLocation != null )\r\n        {\r\n            sink.link_();\r\n        }\r\n    }","id":88700,"modified_method":"private void outputLineLink( int line )\r\n    {\r\n        String xrefLocation = fileInfo.getXrefLocation();\r\n        if ( xrefLocation != null )\r\n        {\r\n            sink.link( xrefLocation + \"/\" + currentFilename.replaceAll( \"\\\\.java$\", \".html\" ) + \"#\" + line );\r\n        }\r\n        sink.text( String.valueOf( line ) );\r\n        if ( xrefLocation != null )\r\n        {\r\n            sink.link_();\r\n        }\r\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"public PmdReportListener( Sink sink, ResourceBundle bundle )\r\n    {\r\n        this.sink = sink;\r\n        this.bundle = bundle;\r\n    }","id":88701,"modified_method":"public PmdReportListener( Sink sink, ResourceBundle bundle, boolean aggregate )\r\n    {\r\n        this.sink = sink;\r\n        this.bundle = bundle;\r\n        this.aggregate = aggregate;\r\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void ruleViolationAdded( IRuleViolation ruleViolation )\r\n    {\r\n        if ( !fileInitialized )\r\n        {\r\n            sink.section2();\r\n            sink.sectionTitle2();\r\n            sink.text( currentFilename );\r\n            sink.sectionTitle2_();\r\n\r\n            sink.table();\r\n            sink.tableRow();\r\n            sink.tableHeaderCell();\r\n            sink.text( bundle.getString( \"report.pmd.column.violation\" ) );\r\n            sink.tableHeaderCell_();\r\n            sink.tableHeaderCell();\r\n            sink.text( bundle.getString( \"report.pmd.column.line\" ) );\r\n            sink.tableHeaderCell_();\r\n            sink.tableRow_();\r\n\r\n            fileInitialized = true;\r\n        }\r\n        violations.add( ruleViolation );\r\n    }","id":88702,"modified_method":"public void ruleViolationAdded( IRuleViolation ruleViolation )\r\n    {\r\n        if ( !fileInitialized )\r\n        {\r\n            sink.section2();\r\n            sink.sectionTitle2();\r\n            String title = currentFilename;\r\n            if ( aggregate ) \r\n            {\r\n                title = fileInfo.getProject().getName() + \" - \" + currentFilename;\r\n            }\r\n            sink.text( title );\r\n            sink.sectionTitle2_();\r\n\r\n            sink.table();\r\n            sink.tableRow();\r\n            sink.tableHeaderCell();\r\n            sink.text( bundle.getString( \"report.pmd.column.violation\" ) );\r\n            sink.tableHeaderCell_();\r\n            sink.tableHeaderCell();\r\n            sink.text( bundle.getString( \"report.pmd.column.line\" ) );\r\n            sink.tableHeaderCell_();\r\n            sink.tableRow_();\r\n\r\n            fileInitialized = true;\r\n        }\r\n        violations.add( ruleViolation );\r\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void beginFile( File file, File sourceDir )\r\n    {\r\n        currentFilename = StringUtils.substring( file.getAbsolutePath(), sourceDir.getAbsolutePath().length() + 1 );\r\n        currentFilename = StringUtils.replace( currentFilename, \"\\\\\", \"/\" );\r\n        fileInitialized = false;\r\n    }","id":88703,"modified_method":"public void beginFile( File file, PmdFileInfo finfo )\r\n    {\r\n        fileInfo = finfo;\r\n        currentFilename = StringUtils.substring( file.getAbsolutePath(),\r\n                                                 finfo.getSourceDirectory().getAbsolutePath().length() + 1 );\r\n        currentFilename = StringUtils.replace( currentFilename, \"\\\\\", \"/\" );\r\n        fileInitialized = false;\r\n    }","commit_id":"b595b78be3ee6938204a6bca6b6fa070a0ee9511","url":"https://github.com/apache/maven-plugins"},{"original_method":"public JavaClass getNextClass() throws IOException, InterruptedException {\n\t\t\tfor (;;) {\n\t\t\t\tZipEntry zipEntry = zipInputStream.getNextEntry();\n\t\t\t\tif (zipEntry == null)\n\t\t\t\t\treturn null;\n\n\t\t\t\ttry {\n\t\t\t\t\tString entryName = zipEntry.getName();\n\t\t\t\t\tString fileExtension = getFileExtension(entryName);\n\t\t\t\t\tif (fileExtension != null) {\n\t\t\t\t\t\tif (fileExtension.equals(\".class\")) {\n\t\t\t\t\t\t\treturn parseClass(url.toString(), new NoCloseInputStream(zipInputStream), entryName);\n\t\t\t\t\t\t} else if (archiveExtensionSet.contains(fileExtension)) {\n\t\t\t\t\t\t\t// TODO: add nested archive to archive work list\n\t\t\t\t\t\t} else if (fileExtension.equals(\".java\")) {\n\t\t\t\t\t\t\tcontainsSourceFiles = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tzipInputStream.closeEntry();\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":88704,"modified_method":"public JavaClass getNextClass() throws IOException, InterruptedException {\n\t\t\tfor (;;) {\n\t\t\t\tZipEntry zipEntry = zipInputStream.getNextEntry();\n\t\t\t\tif (zipEntry == null)\n\t\t\t\t\treturn null;\n\n\t\t\t\ttry {\n\t\t\t\t\tString entryName = zipEntry.getName();\n\t\t\t\t\tString fileExtension = getFileExtension(entryName);\n\t\t\t\t\tif (fileExtension != null) {\n\t\t\t\t\t\tif (fileExtension.equals(\".class\")) {\n\t\t\t\t\t\t\treturn parseClass(url.toString(), new NoCloseInputStream(zipInputStream), entryName);\n\t\t\t\t\t\t} else if (archiveExtensionSet.contains(fileExtension)) {\n\t\t\t\t\t\t\t// Add nested archive to archive work list\n\t\t\t\t\t\t\tArchiveWorkListItem nestedItem =\n\t\t\t\t\t\t\t\tnew ArchiveWorkListItem(\"jar:\" + url.toString() + \"!/\" + entryName, false);\n\t\t\t\t\t\t\tarchiveWorkList.addFirst(nestedItem);\n\t\t\t\t\t\t} else if (fileExtension.equals(\".java\")) {\n\t\t\t\t\t\t\tcontainsSourceFiles = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tzipInputStream.closeEntry();\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"a594f69b7f29f5cbdb617980c69071c2c58a9c06","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Add all classes contained in given file to the BCEL Repository.\n\t *\n\t * @param fileName            the file, which may be a jar/zip archive, a single class file,\n\t *                            or a directory to be recursively searched for class files\n\t * @param archiveWorkList     work list of archives to analyze: this method\n\t *                            may add to the work list if it finds nested archives\n\t * @param repositoryClassList a List to which all classes found in\n\t *                            the archive or directory are added, so we later know\n\t *                            which files to analyze\n\t */\n\tprivate void addFileToRepository(String fileName, List<String> archiveWorkList, List<String> repositoryClassList)\n\t        throws IOException, InterruptedException {\n\n\t\ttry {\n\t\t\tClassProducer classProducer;\n\n\t\t\t// Create a URL for the filename.\n\t\t\t// The protocol defaults to \"file\" if not explicitly\n\t\t\t// specified in the filename.\n\t\t\tString protocol = getURLProtocol(fileName);\n\t\t\tif (protocol == null) {\n\t\t\t\tprotocol = \"file\";\n\t\t\t\tfileName = \"file:\" + fileName;\n\t\t\t}\n\t\t\tURL url = new URL(fileName);\n\n\t\t\t// Figure out the file extension\n\t\t\tString fileExtension = null;\n\t\t\tint lastDot = fileName.lastIndexOf('.');\n\t\t\tif (lastDot >= 0) {\n\t\t\t\tfileExtension = fileName.substring(lastDot);\n\t\t\t}\n\n\t\t\t// Create the ClassProducer\n\t\t\tif (fileExtension != null && archiveExtensionSet.contains(fileExtension))\n\t\t\t\tclassProducer = new ZipClassProducer(url);\n\t\t\telse if (fileExtension != null && fileExtension.equals(\".class\"))\n\t\t\t\tclassProducer = new SingleClassProducer(url);\n\t\t\telse if (protocol.equals(\"file\")) {\n\t\t\t\t// Assume it's a directory\n\t\t\t\tfileName = fileName.substring(\"file:\".length());\n\t\t\t\tFile dir = new File(fileName);\n\t\t\t\tif (!dir.isDirectory())\n\t\t\t\t\tthrow new IOException(\"Path \" + fileName + \" is not an archive, class file, or directory\");\n\t\t\t\tclassProducer = new DirectoryClassProducer(fileName);\n\t\t\t} else\n\t\t\t\tthrow new IOException(\"URL \" + fileName + \" is not an archive, class file, or directory\");\n\n\t\t\t// Load all referenced classes into the Repository\n\t\t\tfor (; ;) {\n\t\t\t\tif (Thread.interrupted())\n\t\t\t\t\tthrow new InterruptedException();\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass jclass = classProducer.getNextClass();\n\t\t\t\t\tif (jclass == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (DEBUG) System.out.println(\"Scanned \" + jclass.getClassName());\n\t\t\t\t\tRepository.addClass(jclass);\n\t\t\t\t\trepositoryClassList.add(jclass.getClassName());\n\t\t\t\t} catch (ClassFormatException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tbugReporter.logError(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprogressCallback.finishArchive();\n\n\t\t\t// If the archive or directory scanned contained source files,\n\t\t\t// add it to the end of the source path.\n\t\t\tif (classProducer.containsSourceFiles())\n\t\t\t\tproject.addSourceDir(fileName);\n\n\t\t} catch (IOException e) {\n\t\t\t// You'd think that the message for a FileNotFoundException would include\n\t\t\t// the filename, but you'd be wrong.  So, we'll add it explicitly.\n\t\t\tthrow new IOException(\"Could not analyze \" + fileName + \": \" + e.getMessage());\n\t\t}\n\t}","id":88705,"modified_method":"/**\n\t * Add all classes contained in given file to the BCEL Repository.\n\t *\n\t * @param item                work list item representing the file, which may be a jar/zip\n\t *                            archive, a single class file, or a directory to be recursively\n\t *                            searched for class files\n\t * @param archiveWorkList     work list of archives to analyze: this method\n\t *                            may add to the work list if it finds nested archives\n\t * @param repositoryClassList a List to which all classes found in\n\t *                            the archive or directory are added, so we later know\n\t *                            which files to analyze\n\t */\n\tprivate void addFileToRepository(ArchiveWorkListItem item,\n\t\t\tLinkedList<ArchiveWorkListItem> archiveWorkList, List<String> repositoryClassList)\n\t        throws IOException, InterruptedException {\n\n\t\tString fileName = item.getFileName();\n\n\t\ttry {\n\t\t\tClassProducer classProducer;\n\n\t\t\t// Create a URL for the filename.\n\t\t\t// The protocol defaults to \"file\" if not explicitly\n\t\t\t// specified in the filename.\n\t\t\tString protocol = getURLProtocol(fileName);\n\t\t\tif (protocol == null) {\n\t\t\t\tprotocol = \"file\";\n\t\t\t\tfileName = \"file:\" + fileName;\n\t\t\t}\n\t\t\tURL url = new URL(fileName);\n\n\t\t\t// Figure out the file extension\n\t\t\tString fileExtension = null;\n\t\t\tint lastDot = fileName.lastIndexOf('.');\n\t\t\tif (lastDot >= 0) {\n\t\t\t\tfileExtension = fileName.substring(lastDot);\n\t\t\t}\n\n\t\t\t// Create the ClassProducer\n\t\t\tif (fileExtension != null && archiveExtensionSet.contains(fileExtension))\n\t\t\t\tclassProducer = new ZipClassProducer(url, archiveWorkList);\n\t\t\telse if (fileExtension != null && fileExtension.equals(\".class\"))\n\t\t\t\tclassProducer = new SingleClassProducer(url);\n\t\t\telse if (protocol.equals(\"file\")) {\n\t\t\t\t// Assume it's a directory\n\t\t\t\tfileName = fileName.substring(\"file:\".length());\n\t\t\t\tFile dir = new File(fileName);\n\t\t\t\tif (!dir.isDirectory())\n\t\t\t\t\tthrow new IOException(\"Path \" + fileName + \" is not an archive, class file, or directory\");\n\t\t\t\tclassProducer = new DirectoryClassProducer(fileName);\n\t\t\t} else\n\t\t\t\tthrow new IOException(\"URL \" + fileName + \" is not an archive, class file, or directory\");\n\n\t\t\t// Load all referenced classes into the Repository\n\t\t\tfor (; ;) {\n\t\t\t\tif (Thread.interrupted())\n\t\t\t\t\tthrow new InterruptedException();\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass jclass = classProducer.getNextClass();\n\t\t\t\t\tif (jclass == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (DEBUG) System.out.println(\"Scanned \" + jclass.getClassName());\n\t\t\t\t\tRepository.addClass(jclass);\n\t\t\t\t\trepositoryClassList.add(jclass.getClassName());\n\t\t\t\t} catch (ClassFormatException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tbugReporter.logError(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.isExplicit())\n\t\t\t\tprogressCallback.finishArchive();\n\n\t\t\t// If the archive or directory scanned contained source files,\n\t\t\t// add it to the end of the source path.\n\t\t\tif (classProducer.containsSourceFiles())\n\t\t\t\tproject.addSourceDir(fileName);\n\n\t\t} catch (IOException e) {\n\t\t\t// You'd think that the message for a FileNotFoundException would include\n\t\t\t// the filename, but you'd be wrong.  So, we'll add it explicitly.\n\t\t\tthrow new IOException(\"Could not analyze \" + fileName + \": \" + e.getMessage());\n\t\t}\n\t}","commit_id":"a594f69b7f29f5cbdb617980c69071c2c58a9c06","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Execute FindBugs on the Project.\n\t * All bugs found are reported to the BugReporter object which was set\n\t * when this object was constructed.\n\t *\n\t * @throws java.io.IOException  if an I/O exception occurs analyzing one of the files\n\t * @throws InterruptedException if the thread is interrupted while conducting the analysis\n\t */\n\tpublic void execute() throws java.io.IOException, InterruptedException {\n\t\t// Configure the analysis context\n\t\tanalysisContext = new AnalysisContext(bugReporter);\n\t\tanalysisContext.setSourcePath(project.getSourceDirList());\n\n\t\t// Give the BugReporter a reference to this object,\n\t\t// in case it wants to access information such\n\t\t// as the AnalysisContext\n\t\tbugReporter.setEngine(this);\n\n\t\t// Create detectors\n\t\tcreateDetectors();\n\n\t\t// Clear the repository of classes\n\t\tclearRepository();\n\n\t\t// Get list of files to analyze.\n\t\t// Note that despite the name getJarFileArray(),\n\t\t// they can also be zip files, directories,\n\t\t// and single class files.\n\t\tLinkedList<String> archiveWorkList = new LinkedList<String>();\n\t\tarchiveWorkList.addAll(project.getJarFileList());\n\n\t\t// Report how many archives/directories/files will be analyzed,\n\t\t// for progress dialog in GUI\n\t\tprogressCallback.reportNumberOfArchives(archiveWorkList.size());\n\n\t\t// Keep track of the names of all classes to be analyzed\n\t\tList<String> repositoryClassList = new LinkedList<String>();\n\n\t\t// Add all classes in analyzed archives/directories/files\n\t\twhile (!archiveWorkList.isEmpty()) {\n\t\t\tString archive = archiveWorkList.removeFirst();\n\t\t\taddFileToRepository(archive, archiveWorkList, repositoryClassList);\n\t\t}\n\n\t\t// Callback for progress dialog: analysis is starting\n\t\tprogressCallback.startAnalysis(repositoryClassList.size());\n\n\t\t// Examine all classes for bugs.\n\t\t// Don't examine the same class more than once.\n\t\t// (The user might specify two jar files that contain\n\t\t// the same class.)\n\t\tSet<String> examinedClassSet = new HashSet<String>();\n\t\tfor (Iterator<String> i = repositoryClassList.iterator(); i.hasNext();) {\n\t\t\tString className = i.next();\n\t\t\tif (examinedClassSet.add(className))\n\t\t\t\texamineClass(className);\n\t\t}\n\n\t\t// Callback for progress dialog: analysis finished\n\t\tprogressCallback.finishPerClassAnalysis();\n\n\t\t// Force any detectors which defer work until all classes have\n\t\t// been seen to do that work.\n\t\tthis.reportFinal();\n\n\t\t// Flush any queued bug reports\n\t\tbugReporter.finish();\n\n\t\t// Flush any queued error reports\n\t\tbugReporter.reportQueuedErrors();\n\t}","id":88706,"modified_method":"/**\n\t * Execute FindBugs on the Project.\n\t * All bugs found are reported to the BugReporter object which was set\n\t * when this object was constructed.\n\t *\n\t * @throws java.io.IOException  if an I/O exception occurs analyzing one of the files\n\t * @throws InterruptedException if the thread is interrupted while conducting the analysis\n\t */\n\tpublic void execute() throws java.io.IOException, InterruptedException {\n\t\t// Configure the analysis context\n\t\tanalysisContext = new AnalysisContext(bugReporter);\n\t\tanalysisContext.setSourcePath(project.getSourceDirList());\n\n\t\t// Give the BugReporter a reference to this object,\n\t\t// in case it wants to access information such\n\t\t// as the AnalysisContext\n\t\tbugReporter.setEngine(this);\n\n\t\t// Create detectors\n\t\tcreateDetectors();\n\n\t\t// Clear the repository of classes\n\t\tclearRepository();\n\n\t\t// Get list of files to analyze.\n\t\t// Note that despite the name getJarFileArray(),\n\t\t// they can also be zip files, directories,\n\t\t// and single class files.\n\t\tLinkedList<ArchiveWorkListItem> archiveWorkList = new LinkedList<ArchiveWorkListItem>();\n\t\t//archiveWorkList.addAll(project.getJarFileList());\n\t\tfor (Iterator<String> i = project.getJarFileList().iterator(); i.hasNext(); ) {\n\t\t\tString fileName = i.next();\n\t\t\tarchiveWorkList.add(new ArchiveWorkListItem(fileName, true));\n\t\t}\n\n\t\t// Report how many archives/directories/files will be analyzed,\n\t\t// for progress dialog in GUI\n\t\tprogressCallback.reportNumberOfArchives(archiveWorkList.size());\n\n\t\t// Keep track of the names of all classes to be analyzed\n\t\tList<String> repositoryClassList = new LinkedList<String>();\n\n\t\t// Add all classes in analyzed archives/directories/files\n\t\twhile (!archiveWorkList.isEmpty()) {\n\t\t\tArchiveWorkListItem item = archiveWorkList.removeFirst();\n\t\t\taddFileToRepository(item, archiveWorkList, repositoryClassList);\n\t\t}\n\n\t\t// Callback for progress dialog: analysis is starting\n\t\tprogressCallback.startAnalysis(repositoryClassList.size());\n\n\t\t// Examine all classes for bugs.\n\t\t// Don't examine the same class more than once.\n\t\t// (The user might specify two jar files that contain\n\t\t// the same class.)\n\t\tSet<String> examinedClassSet = new HashSet<String>();\n\t\tfor (Iterator<String> i = repositoryClassList.iterator(); i.hasNext();) {\n\t\t\tString className = i.next();\n\t\t\tif (examinedClassSet.add(className))\n\t\t\t\texamineClass(className);\n\t\t}\n\n\t\t// Callback for progress dialog: analysis finished\n\t\tprogressCallback.finishPerClassAnalysis();\n\n\t\t// Force any detectors which defer work until all classes have\n\t\t// been seen to do that work.\n\t\tthis.reportFinal();\n\n\t\t// Flush any queued bug reports\n\t\tbugReporter.finish();\n\n\t\t// Flush any queued error reports\n\t\tbugReporter.reportQueuedErrors();\n\t}","commit_id":"a594f69b7f29f5cbdb617980c69071c2c58a9c06","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Populate an analysis run's tree model for given sort order.\n     */\n    private void populateAnalysisRunTreeModel(AnalysisRun analysisRun, final String groupBy) {\n        //System.out.println(\"Populating bug tree for order \" + groupBy);\n        \n        // Set busy cursor - this is potentially a time-consuming operation\n        Cursor orig = this.getCursor();\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        \n        final DefaultTreeModel bugTreeModel = analysisRun.getTreeModel(groupBy);\n        final DefaultMutableTreeNode bugRootNode = (DefaultMutableTreeNode) bugTreeModel.getRoot();\n        \n        // Delete all children from root node\n        bugRootNode.removeAllChildren();\n        \n        // Sort the instances\n        TreeSet<BugInstance> sortedCollection = new TreeSet<BugInstance>(getBugInstanceComparator(groupBy));\n        sortedCollection.addAll(analysisRun.getBugInstances());\n        \n        // The grouper callback is what actually adds the group and bug\n        // nodes to the tree.\n        Grouper.Callback<BugInstance> callback = new Grouper.Callback<BugInstance>() {\n            private BugInstanceGroup currentGroup;\n            private DefaultMutableTreeNode currentGroupNode;\n            \n            public void startGroup(BugInstance member) {\n                String groupName;\n                if (groupBy == GROUP_BY_CLASS)\n                    groupName = member.getPrimaryClass().getClassName();\n                else if (groupBy == GROUP_BY_PACKAGE) {\n                    groupName = member.getPrimaryClass().getPackageName();\n                    if (groupName.equals(\"\"))\n                        groupName = \"Unnamed package\";\n                } else if (groupBy == GROUP_BY_BUG_TYPE) {\n                    String desc = member.toString();\n                    String shortBugType = desc.substring(0, desc.indexOf(':'));\n                    String bugTypeDescription = I18N.instance().getBugTypeDescription(shortBugType);\n                    groupName = shortBugType + \": \" + bugTypeDescription;\n                } else\n                    throw new IllegalStateException(\"Unknown sort order: \" + groupBy);\n                currentGroup = new BugInstanceGroup(groupBy, groupName);\n                currentGroupNode = new DefaultMutableTreeNode(currentGroup);\n                bugTreeModel.insertNodeInto(currentGroupNode, bugRootNode, bugRootNode.getChildCount());\n                \n                insertIntoGroup(member);\n            }\n            \n            public void addToGroup(BugInstance member) {\n                insertIntoGroup(member);\n            }\n            \n            private void insertIntoGroup(BugInstance member) {\n                currentGroup.incrementMemberCount();\n                DefaultMutableTreeNode bugNode = new BugTreeNode(member);\n                bugTreeModel.insertNodeInto(bugNode, currentGroupNode, currentGroupNode.getChildCount());\n                \n                // Insert annotations\n                Iterator j = member.annotationIterator();\n                while (j.hasNext()) {\n                    BugAnnotation annotation = (BugAnnotation) j.next();\n                    DefaultMutableTreeNode annotationNode = new DefaultMutableTreeNode(annotation);\n                    bugTreeModel.insertNodeInto(annotationNode, bugNode,  bugNode.getChildCount());\n                }\n                \n            }\n        };\n        \n        // Create the grouper, and execute it to populate the bug tree\n        Grouper<BugInstance> grouper = new Grouper<BugInstance>(callback);\n        Comparator<BugInstance> groupComparator = getGroupComparator(groupBy);\n        grouper.group(sortedCollection, groupComparator);\n        \n        // Let the tree know it needs to update itself\n        bugTreeModel.nodeStructureChanged(bugRootNode);\n        \n        // Now we're done\n        this.setCursor(orig);\n    }","id":88707,"modified_method":"/**\n     * Populate an analysis run's tree model for given sort order.\n     */\n    private void populateAnalysisRunTreeModel(AnalysisRun analysisRun, final String groupBy) {\n        //System.out.println(\"Populating bug tree for order \" + groupBy);\n        \n        // Set busy cursor - this is potentially a time-consuming operation\n        Cursor orig = this.getCursor();\n        this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n        \n        final DefaultTreeModel bugTreeModel = analysisRun.getTreeModel(groupBy);\n        final DefaultMutableTreeNode bugRootNode = (DefaultMutableTreeNode) bugTreeModel.getRoot();\n        \n        // Delete all children from root node\n        bugRootNode.removeAllChildren();\n        \n        // Sort the instances (considering only those that meet the\n        // priority threshold)\n        TreeSet<BugInstance> sortedCollection = new TreeSet<BugInstance>(getBugInstanceComparator(groupBy));\n        for (Iterator<BugInstance> i = analysisRun.getBugInstances().iterator(); i.hasNext(); ) {\n            BugInstance bugInstance = i.next();\n            if (bugInstance.getPriority() <= priorityThreshold)\n                sortedCollection.add(bugInstance);\n        }\n        \n        // The grouper callback is what actually adds the group and bug\n        // nodes to the tree.\n        Grouper.Callback<BugInstance> callback = new Grouper.Callback<BugInstance>() {\n            private BugInstanceGroup currentGroup;\n            private DefaultMutableTreeNode currentGroupNode;\n            \n            public void startGroup(BugInstance member) {\n                String groupName;\n                if (groupBy == GROUP_BY_CLASS)\n                    groupName = member.getPrimaryClass().getClassName();\n                else if (groupBy == GROUP_BY_PACKAGE) {\n                    groupName = member.getPrimaryClass().getPackageName();\n                    if (groupName.equals(\"\"))\n                        groupName = \"Unnamed package\";\n                } else if (groupBy == GROUP_BY_BUG_TYPE) {\n                    String desc = member.toString();\n                    String shortBugType = desc.substring(0, desc.indexOf(':'));\n                    String bugTypeDescription = I18N.instance().getBugTypeDescription(shortBugType);\n                    groupName = shortBugType + \": \" + bugTypeDescription;\n                } else\n                    throw new IllegalStateException(\"Unknown sort order: \" + groupBy);\n                currentGroup = new BugInstanceGroup(groupBy, groupName);\n                currentGroupNode = new DefaultMutableTreeNode(currentGroup);\n                bugTreeModel.insertNodeInto(currentGroupNode, bugRootNode, bugRootNode.getChildCount());\n                \n                insertIntoGroup(member);\n            }\n            \n            public void addToGroup(BugInstance member) {\n                insertIntoGroup(member);\n            }\n            \n            private void insertIntoGroup(BugInstance member) {\n                currentGroup.incrementMemberCount();\n                DefaultMutableTreeNode bugNode = new BugTreeNode(member);\n                bugTreeModel.insertNodeInto(bugNode, currentGroupNode, currentGroupNode.getChildCount());\n                \n                // Insert annotations\n                Iterator j = member.annotationIterator();\n                while (j.hasNext()) {\n                    BugAnnotation annotation = (BugAnnotation) j.next();\n                    DefaultMutableTreeNode annotationNode = new DefaultMutableTreeNode(annotation);\n                    bugTreeModel.insertNodeInto(annotationNode, bugNode,  bugNode.getChildCount());\n                }\n                \n            }\n        };\n        \n        // Create the grouper, and execute it to populate the bug tree\n        Grouper<BugInstance> grouper = new Grouper<BugInstance>(callback);\n        Comparator<BugInstance> groupComparator = getGroupComparator(groupBy);\n        grouper.group(sortedCollection, groupComparator);\n        \n        // Let the tree know it needs to update itself\n        bugTreeModel.nodeStructureChanged(bugRootNode);\n        \n        // Now we're done\n        this.setCursor(orig);\n    }","commit_id":"8136dd565396b8a5978ecd9dcb8c8073bc20fb55","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    private void initComponents() {//GEN-BEGIN:initComponents\n        java.awt.GridBagConstraints gridBagConstraints;\n\n        consoleSplitter = new javax.swing.JSplitPane();\n        viewPanel = new javax.swing.JPanel();\n        emptyPanel = new javax.swing.JPanel();\n        reportPanel = new javax.swing.JPanel();\n        editProjectPanel = new javax.swing.JPanel();\n        jarFileLabel = new javax.swing.JLabel();\n        jarNameTextField = new javax.swing.JTextField();\n        addJarButton = new javax.swing.JButton();\n        jarFileListLabel = new javax.swing.JLabel();\n        sourceDirLabel = new javax.swing.JLabel();\n        srcDirTextField = new javax.swing.JTextField();\n        addSourceDirButton = new javax.swing.JButton();\n        sourceDirListLabel = new javax.swing.JLabel();\n        removeJarButton = new javax.swing.JButton();\n        removeSrcDirButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        browseJarButton = new javax.swing.JButton();\n        browseSrcDirButton = new javax.swing.JButton();\n        editProjectLabel = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n        findBugsButton = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n        jarFileListScrollPane = new javax.swing.JScrollPane();\n        jarFileList = new javax.swing.JList();\n        sourceDirListScrollPane = new javax.swing.JScrollPane();\n        sourceDirList = new javax.swing.JList();\n        classpathEntryLabel = new javax.swing.JLabel();\n        classpathEntryListLabel = new javax.swing.JLabel();\n        classpathEntryTextField = new javax.swing.JTextField();\n        browseClasspathEntryButton = new javax.swing.JButton();\n        addClasspathEntryButton = new javax.swing.JButton();\n        removeClasspathEntryButton = new javax.swing.JButton();\n        classpathEntryListScrollPane = new javax.swing.JScrollPane();\n        classpathEntryList = new javax.swing.JList();\n        jSeparator5 = new javax.swing.JSeparator();\n        bugTreePanel = new javax.swing.JPanel();\n        bugTreeBugDetailsSplitter = new javax.swing.JSplitPane();\n        groupByTabbedPane = new javax.swing.JTabbedPane();\n        byClassScrollPane = new javax.swing.JScrollPane();\n        byClassBugTree = new javax.swing.JTree();\n        byPackageScrollPane = new javax.swing.JScrollPane();\n        byPackageBugTree = new javax.swing.JTree();\n        byBugTypeScrollPane = new javax.swing.JScrollPane();\n        byBugTypeBugTree = new javax.swing.JTree();\n        bugDetailsTabbedPane = new javax.swing.JTabbedPane();\n        bugDescriptionScrollPane = new javax.swing.JScrollPane();\n        bugDescriptionEditorPane = new javax.swing.JEditorPane();\n        sourceTextAreaScrollPane = new javax.swing.JScrollPane();\n        sourceTextArea = new javax.swing.JTextArea();\n        annotationTextAreaScrollPane = new javax.swing.JScrollPane();\n        annotationTextArea = new javax.swing.JTextArea();\n        consoleScrollPane = new javax.swing.JScrollPane();\n        consoleMessageArea = new javax.swing.JTextArea();\n        theMenuBar = new javax.swing.JMenuBar();\n        fileMenu = new javax.swing.JMenu();\n        newProjectItem = new javax.swing.JMenuItem();\n        openProjectItem = new javax.swing.JMenuItem();\n        saveProjectItem = new javax.swing.JMenuItem();\n        saveProjectAsItem = new javax.swing.JMenuItem();\n        reloadProjectItem = new javax.swing.JMenuItem();\n        closeProjectItem = new javax.swing.JMenuItem();\n        jSeparator3 = new javax.swing.JSeparator();\n        loadBugsItem = new javax.swing.JMenuItem();\n        saveBugsItem = new javax.swing.JMenuItem();\n        jSeparator6 = new javax.swing.JSeparator();\n        exitItem = new javax.swing.JMenuItem();\n        viewMenu = new javax.swing.JMenu();\n        viewConsoleItem = new javax.swing.JCheckBoxMenuItem();\n        viewBugDetailsItem = new javax.swing.JCheckBoxMenuItem();\n        fullDescriptionsItem = new javax.swing.JCheckBoxMenuItem();\n        settingsMenu = new javax.swing.JMenu();\n        configureDetectorsItem = new javax.swing.JMenuItem();\n        helpMenu = new javax.swing.JMenu();\n        aboutItem = new javax.swing.JMenuItem();\n\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                exitForm(evt);\n            }\n        });\n\n        consoleSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        consoleSplitter.setResizeWeight(1.0);\n        consoleSplitter.setOneTouchExpandable(true);\n        consoleSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                consoleSplitterPropertyChange(evt);\n            }\n        });\n\n        viewPanel.setLayout(new java.awt.CardLayout());\n\n        viewPanel.add(emptyPanel, \"EmptyPanel\");\n\n        viewPanel.add(reportPanel, \"ReportPanel\");\n\n        editProjectPanel.setLayout(new java.awt.GridBagLayout());\n\n        jarFileLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileLabel.setText(\"Archive or directory:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileLabel, gridBagConstraints);\n\n        jarNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jarNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(jarNameTextField, gridBagConstraints);\n\n        addJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addJarButton.setText(\"Add\");\n        addJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addJarButton, gridBagConstraints);\n\n        jarFileListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileListLabel.setText(\"Archives/directories:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListLabel, gridBagConstraints);\n\n        sourceDirLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirLabel.setText(\"Source directory:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirLabel, gridBagConstraints);\n\n        srcDirTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                srcDirTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(srcDirTextField, gridBagConstraints);\n\n        addSourceDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addSourceDirButton.setText(\"Add\");\n        addSourceDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addSourceDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addSourceDirButton, gridBagConstraints);\n\n        sourceDirListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirListLabel.setText(\"Source directories:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListLabel, gridBagConstraints);\n\n        removeJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeJarButton.setText(\"Remove\");\n        removeJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeJarButton, gridBagConstraints);\n\n        removeSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeSrcDirButton.setText(\"Remove\");\n        removeSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeSrcDirButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 5;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator1, gridBagConstraints);\n\n        browseJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseJarButton.setText(\"Browse\");\n        browseJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseJarButton, gridBagConstraints);\n\n        browseSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseSrcDirButton.setText(\"Browse\");\n        browseSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseSrcDirButton, gridBagConstraints);\n\n        editProjectLabel.setBackground(new java.awt.Color(0, 0, 204));\n        editProjectLabel.setFont(new java.awt.Font(\"Dialog\", 1, 24));\n        editProjectLabel.setForeground(new java.awt.Color(255, 255, 255));\n        editProjectLabel.setText(\"Project\");\n        editProjectLabel.setOpaque(true);\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        editProjectPanel.add(editProjectLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 2;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator2, gridBagConstraints);\n\n        findBugsButton.setMnemonic('B');\n        findBugsButton.setText(\"Find Bugs!\");\n        findBugsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findBugsButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 13;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(findBugsButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 8;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator4, gridBagConstraints);\n\n        jarFileListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        jarFileList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        jarFileList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jarFileListScrollPane.setViewportView(jarFileList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListScrollPane, gridBagConstraints);\n\n        sourceDirListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        sourceDirList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        sourceDirList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        sourceDirListScrollPane.setViewportView(sourceDirList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.2;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListScrollPane, gridBagConstraints);\n\n        classpathEntryLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        classpathEntryLabel.setText(\"Classpath entry:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 3);\n        editProjectPanel.add(classpathEntryLabel, gridBagConstraints);\n\n        classpathEntryListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        classpathEntryListLabel.setText(\"Classpath entries:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 10;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 3);\n        editProjectPanel.add(classpathEntryListLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(classpathEntryTextField, gridBagConstraints);\n\n        browseClasspathEntryButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseClasspathEntryButton.setText(\"Browse\");\n        browseClasspathEntryButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseClasspathEntryButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 9;\n        editProjectPanel.add(browseClasspathEntryButton, gridBagConstraints);\n\n        addClasspathEntryButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addClasspathEntryButton.setText(\"Add\");\n        addClasspathEntryButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addClasspathEntryButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(addClasspathEntryButton, gridBagConstraints);\n\n        removeClasspathEntryButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeClasspathEntryButton.setText(\"Remove\");\n        removeClasspathEntryButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeClasspathEntryButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 10;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(removeClasspathEntryButton, gridBagConstraints);\n\n        classpathEntryListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        classpathEntryList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        classpathEntryList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        classpathEntryListScrollPane.setViewportView(classpathEntryList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 10;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.2;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(classpathEntryListScrollPane, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 12;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);\n        editProjectPanel.add(jSeparator5, gridBagConstraints);\n\n        viewPanel.add(editProjectPanel, \"EditProjectPanel\");\n\n        bugTreePanel.setLayout(new java.awt.GridBagLayout());\n\n        bugTreeBugDetailsSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        bugTreeBugDetailsSplitter.setResizeWeight(1.0);\n        bugTreeBugDetailsSplitter.setOneTouchExpandable(true);\n        bugTreeBugDetailsSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                bugTreeBugDetailsSplitterPropertyChange(evt);\n            }\n        });\n\n        byClassScrollPane.setViewportView(byClassBugTree);\n\n        groupByTabbedPane.addTab(\"By Class\", byClassScrollPane);\n\n        byPackageScrollPane.setViewportView(byPackageBugTree);\n\n        groupByTabbedPane.addTab(\"By Package\", byPackageScrollPane);\n\n        byBugTypeScrollPane.setViewportView(byBugTypeBugTree);\n\n        groupByTabbedPane.addTab(\"By Bug Type\", byBugTypeScrollPane);\n\n        bugTreeBugDetailsSplitter.setTopComponent(groupByTabbedPane);\n\n        bugDescriptionEditorPane.setEditable(false);\n        bugDescriptionScrollPane.setViewportView(bugDescriptionEditorPane);\n\n        bugDetailsTabbedPane.addTab(\"Details\", bugDescriptionScrollPane);\n\n        sourceTextAreaScrollPane.setMinimumSize(new java.awt.Dimension(22, 180));\n        sourceTextAreaScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        sourceTextArea.setEditable(false);\n        sourceTextArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        sourceTextArea.setEnabled(false);\n        sourceTextAreaScrollPane.setViewportView(sourceTextArea);\n\n        bugDetailsTabbedPane.addTab(\"Source code\", sourceTextAreaScrollPane);\n\n        annotationTextAreaScrollPane.setViewportView(annotationTextArea);\n\n        bugDetailsTabbedPane.addTab(\"Annotations\", annotationTextAreaScrollPane);\n\n        bugTreeBugDetailsSplitter.setBottomComponent(bugDetailsTabbedPane);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 1;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        bugTreePanel.add(bugTreeBugDetailsSplitter, gridBagConstraints);\n\n        viewPanel.add(bugTreePanel, \"BugTree\");\n\n        consoleSplitter.setTopComponent(viewPanel);\n\n        consoleScrollPane.setMinimumSize(new java.awt.Dimension(22, 100));\n        consoleScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        consoleMessageArea.setBackground(new java.awt.Color(204, 204, 204));\n        consoleMessageArea.setEditable(false);\n        consoleMessageArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        consoleMessageArea.setMinimumSize(new java.awt.Dimension(0, 0));\n        consoleMessageArea.setAutoscrolls(false);\n        consoleScrollPane.setViewportView(consoleMessageArea);\n\n        consoleSplitter.setBottomComponent(consoleScrollPane);\n\n        getContentPane().add(consoleSplitter, java.awt.BorderLayout.CENTER);\n\n        theMenuBar.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.setMnemonic('F');\n        fileMenu.setText(\"File\");\n        fileMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.addMenuListener(new javax.swing.event.MenuListener() {\n            public void menuCanceled(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuDeselected(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuSelected(javax.swing.event.MenuEvent evt) {\n                fileMenuMenuSelected(evt);\n            }\n        });\n\n        newProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setMnemonic('N');\n        newProjectItem.setText(\"New Project\");\n        newProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(newProjectItem);\n\n        openProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        openProjectItem.setMnemonic('O');\n        openProjectItem.setText(\"Open Project\");\n        openProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                openProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(openProjectItem);\n\n        saveProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveProjectItem.setMnemonic('S');\n        saveProjectItem.setText(\"Save Project\");\n        saveProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveProjectItem);\n\n        saveProjectAsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveProjectAsItem.setMnemonic('A');\n        saveProjectAsItem.setText(\"Save Project As\");\n        saveProjectAsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveProjectAsItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveProjectAsItem);\n\n        reloadProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        reloadProjectItem.setMnemonic('R');\n        reloadProjectItem.setText(\"Reload Project\");\n        reloadProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                reloadProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(reloadProjectItem);\n\n        closeProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        closeProjectItem.setMnemonic('C');\n        closeProjectItem.setText(\"Close Project\");\n        closeProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                closeProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(closeProjectItem);\n\n        fileMenu.add(jSeparator3);\n\n        loadBugsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        loadBugsItem.setMnemonic('L');\n        loadBugsItem.setText(\"Load Bugs\");\n        loadBugsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                loadBugsItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(loadBugsItem);\n\n        saveBugsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveBugsItem.setMnemonic('B');\n        saveBugsItem.setText(\"Save Bugs\");\n        saveBugsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveBugsItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveBugsItem);\n\n        fileMenu.add(jSeparator6);\n\n        exitItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        exitItem.setMnemonic('X');\n        exitItem.setText(\"Exit\");\n        exitItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(exitItem);\n\n        theMenuBar.add(fileMenu);\n\n        viewMenu.setMnemonic('V');\n        viewMenu.setText(\"View\");\n        viewMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewMenu.addMenuListener(new javax.swing.event.MenuListener() {\n            public void menuCanceled(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuDeselected(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuSelected(javax.swing.event.MenuEvent evt) {\n                viewMenuMenuSelected(evt);\n            }\n        });\n\n        viewConsoleItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setMnemonic('C');\n        viewConsoleItem.setText(\"Console\");\n        viewConsoleItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewConsoleItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewConsoleItem);\n\n        viewBugDetailsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewBugDetailsItem.setMnemonic('D');\n        viewBugDetailsItem.setSelected(true);\n        viewBugDetailsItem.setText(\"Bug Details\");\n        viewBugDetailsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewBugDetailsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewBugDetailsItem);\n\n        fullDescriptionsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fullDescriptionsItem.setMnemonic('F');\n        fullDescriptionsItem.setSelected(true);\n        fullDescriptionsItem.setText(\"Full Descriptions\");\n        fullDescriptionsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fullDescriptionsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(fullDescriptionsItem);\n\n        theMenuBar.add(viewMenu);\n\n        settingsMenu.setMnemonic('S');\n        settingsMenu.setText(\"Settings\");\n        settingsMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        configureDetectorsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        configureDetectorsItem.setMnemonic('C');\n        configureDetectorsItem.setText(\"Configure Detectors...\");\n        configureDetectorsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                configureDetectorsItemActionPerformed(evt);\n            }\n        });\n\n        settingsMenu.add(configureDetectorsItem);\n\n        theMenuBar.add(settingsMenu);\n\n        helpMenu.setMnemonic('H');\n        helpMenu.setText(\"Help\");\n        helpMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setMnemonic('A');\n        aboutItem.setText(\"About\");\n        aboutItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                aboutItemActionPerformed(evt);\n            }\n        });\n\n        helpMenu.add(aboutItem);\n\n        theMenuBar.add(helpMenu);\n\n        setJMenuBar(theMenuBar);\n\n        pack();\n    }","id":88708,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    private void initComponents() {//GEN-BEGIN:initComponents\n        java.awt.GridBagConstraints gridBagConstraints;\n\n        consoleSplitter = new javax.swing.JSplitPane();\n        viewPanel = new javax.swing.JPanel();\n        emptyPanel = new javax.swing.JPanel();\n        reportPanel = new javax.swing.JPanel();\n        editProjectPanel = new javax.swing.JPanel();\n        jarFileLabel = new javax.swing.JLabel();\n        jarNameTextField = new javax.swing.JTextField();\n        addJarButton = new javax.swing.JButton();\n        jarFileListLabel = new javax.swing.JLabel();\n        sourceDirLabel = new javax.swing.JLabel();\n        srcDirTextField = new javax.swing.JTextField();\n        addSourceDirButton = new javax.swing.JButton();\n        sourceDirListLabel = new javax.swing.JLabel();\n        removeJarButton = new javax.swing.JButton();\n        removeSrcDirButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        browseJarButton = new javax.swing.JButton();\n        browseSrcDirButton = new javax.swing.JButton();\n        editProjectLabel = new javax.swing.JLabel();\n        jSeparator2 = new javax.swing.JSeparator();\n        findBugsButton = new javax.swing.JButton();\n        jSeparator4 = new javax.swing.JSeparator();\n        jarFileListScrollPane = new javax.swing.JScrollPane();\n        jarFileList = new javax.swing.JList();\n        sourceDirListScrollPane = new javax.swing.JScrollPane();\n        sourceDirList = new javax.swing.JList();\n        classpathEntryLabel = new javax.swing.JLabel();\n        classpathEntryListLabel = new javax.swing.JLabel();\n        classpathEntryTextField = new javax.swing.JTextField();\n        browseClasspathEntryButton = new javax.swing.JButton();\n        addClasspathEntryButton = new javax.swing.JButton();\n        removeClasspathEntryButton = new javax.swing.JButton();\n        classpathEntryListScrollPane = new javax.swing.JScrollPane();\n        classpathEntryList = new javax.swing.JList();\n        jSeparator5 = new javax.swing.JSeparator();\n        bugTreePanel = new javax.swing.JPanel();\n        bugTreeBugDetailsSplitter = new javax.swing.JSplitPane();\n        groupByTabbedPane = new javax.swing.JTabbedPane();\n        byClassScrollPane = new javax.swing.JScrollPane();\n        byClassBugTree = new javax.swing.JTree();\n        byPackageScrollPane = new javax.swing.JScrollPane();\n        byPackageBugTree = new javax.swing.JTree();\n        byBugTypeScrollPane = new javax.swing.JScrollPane();\n        byBugTypeBugTree = new javax.swing.JTree();\n        bugDetailsTabbedPane = new javax.swing.JTabbedPane();\n        bugDescriptionScrollPane = new javax.swing.JScrollPane();\n        bugDescriptionEditorPane = new javax.swing.JEditorPane();\n        sourceTextAreaScrollPane = new javax.swing.JScrollPane();\n        sourceTextArea = new javax.swing.JTextArea();\n        annotationTextAreaScrollPane = new javax.swing.JScrollPane();\n        annotationTextArea = new javax.swing.JTextArea();\n        consoleScrollPane = new javax.swing.JScrollPane();\n        consoleMessageArea = new javax.swing.JTextArea();\n        theMenuBar = new javax.swing.JMenuBar();\n        fileMenu = new javax.swing.JMenu();\n        newProjectItem = new javax.swing.JMenuItem();\n        openProjectItem = new javax.swing.JMenuItem();\n        saveProjectItem = new javax.swing.JMenuItem();\n        saveProjectAsItem = new javax.swing.JMenuItem();\n        reloadProjectItem = new javax.swing.JMenuItem();\n        closeProjectItem = new javax.swing.JMenuItem();\n        jSeparator3 = new javax.swing.JSeparator();\n        loadBugsItem = new javax.swing.JMenuItem();\n        saveBugsItem = new javax.swing.JMenuItem();\n        jSeparator6 = new javax.swing.JSeparator();\n        exitItem = new javax.swing.JMenuItem();\n        viewMenu = new javax.swing.JMenu();\n        viewConsoleItem = new javax.swing.JCheckBoxMenuItem();\n        viewBugDetailsItem = new javax.swing.JCheckBoxMenuItem();\n        fullDescriptionsItem = new javax.swing.JCheckBoxMenuItem();\n        jSeparator7 = new javax.swing.JSeparator();\n        lowPriorityButton = new javax.swing.JRadioButtonMenuItem();\n        mediumPriorityButton = new javax.swing.JRadioButtonMenuItem();\n        highPriorityButton = new javax.swing.JRadioButtonMenuItem();\n        settingsMenu = new javax.swing.JMenu();\n        configureDetectorsItem = new javax.swing.JMenuItem();\n        helpMenu = new javax.swing.JMenu();\n        aboutItem = new javax.swing.JMenuItem();\n\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowClosing(java.awt.event.WindowEvent evt) {\n                exitForm(evt);\n            }\n        });\n\n        consoleSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        consoleSplitter.setResizeWeight(1.0);\n        consoleSplitter.setOneTouchExpandable(true);\n        consoleSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                consoleSplitterPropertyChange(evt);\n            }\n        });\n\n        viewPanel.setLayout(new java.awt.CardLayout());\n\n        viewPanel.add(emptyPanel, \"EmptyPanel\");\n\n        viewPanel.add(reportPanel, \"ReportPanel\");\n\n        editProjectPanel.setLayout(new java.awt.GridBagLayout());\n\n        jarFileLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileLabel.setText(\"Archive or directory:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileLabel, gridBagConstraints);\n\n        jarNameTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jarNameTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(jarNameTextField, gridBagConstraints);\n\n        addJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addJarButton.setText(\"Add\");\n        addJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addJarButton, gridBagConstraints);\n\n        jarFileListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileListLabel.setText(\"Archives/directories:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListLabel, gridBagConstraints);\n\n        sourceDirLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirLabel.setText(\"Source directory:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirLabel, gridBagConstraints);\n\n        srcDirTextField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                srcDirTextFieldActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(srcDirTextField, gridBagConstraints);\n\n        addSourceDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addSourceDirButton.setText(\"Add\");\n        addSourceDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addSourceDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(addSourceDirButton, gridBagConstraints);\n\n        sourceDirListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirListLabel.setText(\"Source directories:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListLabel, gridBagConstraints);\n\n        removeJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeJarButton.setText(\"Remove\");\n        removeJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeJarButton, gridBagConstraints);\n\n        removeSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeSrcDirButton.setText(\"Remove\");\n        removeSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(removeSrcDirButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 5;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator1, gridBagConstraints);\n\n        browseJarButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseJarButton.setText(\"Browse\");\n        browseJarButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseJarButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 3;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseJarButton, gridBagConstraints);\n\n        browseSrcDirButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseSrcDirButton.setText(\"Browse\");\n        browseSrcDirButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseSrcDirButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(browseSrcDirButton, gridBagConstraints);\n\n        editProjectLabel.setBackground(new java.awt.Color(0, 0, 204));\n        editProjectLabel.setFont(new java.awt.Font(\"Dialog\", 1, 24));\n        editProjectLabel.setForeground(new java.awt.Color(255, 255, 255));\n        editProjectLabel.setText(\"Project\");\n        editProjectLabel.setOpaque(true);\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        editProjectPanel.add(editProjectLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 2;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator2, gridBagConstraints);\n\n        findBugsButton.setMnemonic('B');\n        findBugsButton.setText(\"Find Bugs!\");\n        findBugsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findBugsButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 13;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(findBugsButton, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 8;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\n        editProjectPanel.add(jSeparator4, gridBagConstraints);\n\n        jarFileListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        jarFileList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        jarFileList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        jarFileList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        jarFileListScrollPane.setViewportView(jarFileList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 4;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.6;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(jarFileListScrollPane, gridBagConstraints);\n\n        sourceDirListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        sourceDirList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        sourceDirList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        sourceDirList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\n        sourceDirListScrollPane.setViewportView(sourceDirList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 7;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.2;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(sourceDirListScrollPane, gridBagConstraints);\n\n        classpathEntryLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        classpathEntryLabel.setText(\"Classpath entry:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 3);\n        editProjectPanel.add(classpathEntryLabel, gridBagConstraints);\n\n        classpathEntryListLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        classpathEntryListLabel.setText(\"Classpath entries:\");\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 10;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 3);\n        editProjectPanel.add(classpathEntryListLabel, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(classpathEntryTextField, gridBagConstraints);\n\n        browseClasspathEntryButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        browseClasspathEntryButton.setText(\"Browse\");\n        browseClasspathEntryButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                browseClasspathEntryButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 2;\n        gridBagConstraints.gridy = 9;\n        editProjectPanel.add(browseClasspathEntryButton, gridBagConstraints);\n\n        addClasspathEntryButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        addClasspathEntryButton.setText(\"Add\");\n        addClasspathEntryButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addClasspathEntryButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 9;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(addClasspathEntryButton, gridBagConstraints);\n\n        removeClasspathEntryButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        removeClasspathEntryButton.setText(\"Remove\");\n        removeClasspathEntryButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeClasspathEntryButtonActionPerformed(evt);\n            }\n        });\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 3;\n        gridBagConstraints.gridy = 10;\n        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n        editProjectPanel.add(removeClasspathEntryButton, gridBagConstraints);\n\n        classpathEntryListScrollPane.setPreferredSize(new java.awt.Dimension(259, 1));\n        classpathEntryList.setBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\n        classpathEntryList.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        classpathEntryListScrollPane.setViewportView(classpathEntryList);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 1;\n        gridBagConstraints.gridy = 10;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weighty = 0.2;\n        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);\n        editProjectPanel.add(classpathEntryListScrollPane, gridBagConstraints);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 12;\n        gridBagConstraints.gridwidth = 4;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);\n        editProjectPanel.add(jSeparator5, gridBagConstraints);\n\n        viewPanel.add(editProjectPanel, \"EditProjectPanel\");\n\n        bugTreePanel.setLayout(new java.awt.GridBagLayout());\n\n        bugTreeBugDetailsSplitter.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);\n        bugTreeBugDetailsSplitter.setResizeWeight(1.0);\n        bugTreeBugDetailsSplitter.setOneTouchExpandable(true);\n        bugTreeBugDetailsSplitter.addPropertyChangeListener(new java.beans.PropertyChangeListener() {\n            public void propertyChange(java.beans.PropertyChangeEvent evt) {\n                bugTreeBugDetailsSplitterPropertyChange(evt);\n            }\n        });\n\n        byClassScrollPane.setViewportView(byClassBugTree);\n\n        groupByTabbedPane.addTab(\"By Class\", byClassScrollPane);\n\n        byPackageScrollPane.setViewportView(byPackageBugTree);\n\n        groupByTabbedPane.addTab(\"By Package\", byPackageScrollPane);\n\n        byBugTypeScrollPane.setViewportView(byBugTypeBugTree);\n\n        groupByTabbedPane.addTab(\"By Bug Type\", byBugTypeScrollPane);\n\n        bugTreeBugDetailsSplitter.setTopComponent(groupByTabbedPane);\n\n        bugDescriptionEditorPane.setEditable(false);\n        bugDescriptionScrollPane.setViewportView(bugDescriptionEditorPane);\n\n        bugDetailsTabbedPane.addTab(\"Details\", bugDescriptionScrollPane);\n\n        sourceTextAreaScrollPane.setMinimumSize(new java.awt.Dimension(22, 180));\n        sourceTextAreaScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        sourceTextArea.setEditable(false);\n        sourceTextArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        sourceTextArea.setEnabled(false);\n        sourceTextAreaScrollPane.setViewportView(sourceTextArea);\n\n        bugDetailsTabbedPane.addTab(\"Source code\", sourceTextAreaScrollPane);\n\n        annotationTextAreaScrollPane.setViewportView(annotationTextArea);\n\n        bugDetailsTabbedPane.addTab(\"Annotations\", annotationTextAreaScrollPane);\n\n        bugTreeBugDetailsSplitter.setBottomComponent(bugDetailsTabbedPane);\n\n        gridBagConstraints = new java.awt.GridBagConstraints();\n        gridBagConstraints.gridx = 0;\n        gridBagConstraints.gridy = 1;\n        gridBagConstraints.gridwidth = 2;\n        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        bugTreePanel.add(bugTreeBugDetailsSplitter, gridBagConstraints);\n\n        viewPanel.add(bugTreePanel, \"BugTree\");\n\n        consoleSplitter.setTopComponent(viewPanel);\n\n        consoleScrollPane.setMinimumSize(new java.awt.Dimension(22, 100));\n        consoleScrollPane.setPreferredSize(new java.awt.Dimension(0, 100));\n        consoleMessageArea.setBackground(new java.awt.Color(204, 204, 204));\n        consoleMessageArea.setEditable(false);\n        consoleMessageArea.setFont(new java.awt.Font(\"Lucida Sans Typewriter\", 0, 12));\n        consoleMessageArea.setMinimumSize(new java.awt.Dimension(0, 0));\n        consoleMessageArea.setAutoscrolls(false);\n        consoleScrollPane.setViewportView(consoleMessageArea);\n\n        consoleSplitter.setBottomComponent(consoleScrollPane);\n\n        getContentPane().add(consoleSplitter, java.awt.BorderLayout.CENTER);\n\n        theMenuBar.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.setMnemonic('F');\n        fileMenu.setText(\"File\");\n        fileMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fileMenu.addMenuListener(new javax.swing.event.MenuListener() {\n            public void menuCanceled(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuDeselected(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuSelected(javax.swing.event.MenuEvent evt) {\n                fileMenuMenuSelected(evt);\n            }\n        });\n\n        newProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        newProjectItem.setMnemonic('N');\n        newProjectItem.setText(\"New Project\");\n        newProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                newProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(newProjectItem);\n\n        openProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        openProjectItem.setMnemonic('O');\n        openProjectItem.setText(\"Open Project\");\n        openProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                openProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(openProjectItem);\n\n        saveProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveProjectItem.setMnemonic('S');\n        saveProjectItem.setText(\"Save Project\");\n        saveProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveProjectItem);\n\n        saveProjectAsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveProjectAsItem.setMnemonic('A');\n        saveProjectAsItem.setText(\"Save Project As\");\n        saveProjectAsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveProjectAsItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveProjectAsItem);\n\n        reloadProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        reloadProjectItem.setMnemonic('R');\n        reloadProjectItem.setText(\"Reload Project\");\n        reloadProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                reloadProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(reloadProjectItem);\n\n        closeProjectItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        closeProjectItem.setMnemonic('C');\n        closeProjectItem.setText(\"Close Project\");\n        closeProjectItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                closeProjectItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(closeProjectItem);\n\n        fileMenu.add(jSeparator3);\n\n        loadBugsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        loadBugsItem.setMnemonic('L');\n        loadBugsItem.setText(\"Load Bugs\");\n        loadBugsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                loadBugsItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(loadBugsItem);\n\n        saveBugsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        saveBugsItem.setMnemonic('B');\n        saveBugsItem.setText(\"Save Bugs\");\n        saveBugsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveBugsItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(saveBugsItem);\n\n        fileMenu.add(jSeparator6);\n\n        exitItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        exitItem.setMnemonic('X');\n        exitItem.setText(\"Exit\");\n        exitItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                exitItemActionPerformed(evt);\n            }\n        });\n\n        fileMenu.add(exitItem);\n\n        theMenuBar.add(fileMenu);\n\n        viewMenu.setMnemonic('V');\n        viewMenu.setText(\"View\");\n        viewMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewMenu.addMenuListener(new javax.swing.event.MenuListener() {\n            public void menuCanceled(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuDeselected(javax.swing.event.MenuEvent evt) {\n            }\n            public void menuSelected(javax.swing.event.MenuEvent evt) {\n                viewMenuMenuSelected(evt);\n            }\n        });\n\n        viewConsoleItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewConsoleItem.setMnemonic('C');\n        viewConsoleItem.setText(\"Console\");\n        viewConsoleItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewConsoleItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewConsoleItem);\n\n        viewBugDetailsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        viewBugDetailsItem.setMnemonic('D');\n        viewBugDetailsItem.setSelected(true);\n        viewBugDetailsItem.setText(\"Bug Details\");\n        viewBugDetailsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                viewBugDetailsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(viewBugDetailsItem);\n\n        fullDescriptionsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        fullDescriptionsItem.setMnemonic('F');\n        fullDescriptionsItem.setSelected(true);\n        fullDescriptionsItem.setText(\"Full Descriptions\");\n        fullDescriptionsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                fullDescriptionsItemActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(fullDescriptionsItem);\n\n        viewMenu.add(jSeparator7);\n\n        lowPriorityButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        lowPriorityButton.setMnemonic('L');\n        lowPriorityButton.setText(\"Low priority\");\n        lowPriorityButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                lowPriorityButtonActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(lowPriorityButton);\n\n        mediumPriorityButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        mediumPriorityButton.setMnemonic('M');\n        mediumPriorityButton.setSelected(true);\n        mediumPriorityButton.setText(\"Medium priority\");\n        mediumPriorityButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                mediumPriorityButtonActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(mediumPriorityButton);\n\n        highPriorityButton.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        highPriorityButton.setMnemonic('H');\n        highPriorityButton.setText(\"High priority\");\n        highPriorityButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                highPriorityButtonActionPerformed(evt);\n            }\n        });\n\n        viewMenu.add(highPriorityButton);\n\n        theMenuBar.add(viewMenu);\n\n        settingsMenu.setMnemonic('S');\n        settingsMenu.setText(\"Settings\");\n        settingsMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        configureDetectorsItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        configureDetectorsItem.setMnemonic('C');\n        configureDetectorsItem.setText(\"Configure Detectors...\");\n        configureDetectorsItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                configureDetectorsItemActionPerformed(evt);\n            }\n        });\n\n        settingsMenu.add(configureDetectorsItem);\n\n        theMenuBar.add(settingsMenu);\n\n        helpMenu.setMnemonic('H');\n        helpMenu.setText(\"Help\");\n        helpMenu.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setFont(new java.awt.Font(\"Dialog\", 0, 12));\n        aboutItem.setMnemonic('A');\n        aboutItem.setText(\"About\");\n        aboutItem.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                aboutItemActionPerformed(evt);\n            }\n        });\n\n        helpMenu.add(aboutItem);\n\n        theMenuBar.add(helpMenu);\n\n        setJMenuBar(theMenuBar);\n\n        pack();\n    }","commit_id":"8136dd565396b8a5978ecd9dcb8c8073bc20fb55","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * This is called from the constructor to perform post-initialization\n     * of the components in the form.\n     */\n    private void postInitComponents() {\n        logger = new ConsoleLogger(this);\n        \n        viewPanelLayout = (CardLayout) viewPanel.getLayout();\n        \n        // Console starts out disabled\n        consoleSplitter.setDividerLocation(1.0);\n        \n        // List of bug group tabs.\n        // This must be in the same order as GROUP_BY_ORDER_LIST!\n        bugTreeList = new JTree[]{byClassBugTree, byPackageBugTree, byBugTypeBugTree};\n        \n        // Configure bug trees\n        for (int i = 0; i < bugTreeList.length; ++i) {\n            JTree bugTree = bugTreeList[i];\n            bugTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n            bugTree.setCellRenderer(bugCellRenderer);\n            bugTree.setRootVisible(false);\n            bugTree.setShowsRootHandles(true);\n            bugTree.addTreeSelectionListener(new TreeSelectionListener() {\n                public void valueChanged(TreeSelectionEvent e) {\n                    bugTreeSelectionChanged(e);\n                }\n            });\n        }\n        \n        jarFileList.setModel(new DefaultListModel());\n        sourceDirList.setModel(new DefaultListModel());\n        classpathEntryList.setModel(new DefaultListModel());\n        \n        // We use a special highlight painter to ensure that the highlights cover\n        // complete source lines, even though the source text doesn't\n        // fill the lines completely.\n        final Highlighter.HighlightPainter painter =\n        new DefaultHighlighter.DefaultHighlightPainter(sourceTextArea.getSelectionColor()) {\n            public Shape paintLayer(Graphics g, int offs0, int offs1,\n            Shape bounds, JTextComponent c, View view) {\n                try {\n                    Shape extent = view.modelToView(offs0, Position.Bias.Forward, offs1, Position.Bias.Backward, bounds);\n                    Rectangle rect = extent.getBounds();\n                    rect.x = 0;\n                    rect.width = bounds.getBounds().width;\n                    g.setColor(getColor());\n                    g.fillRect(rect.x, rect.y, rect.width, rect.height);\n                    return rect;\n                } catch (BadLocationException e) {\n                    return null;\n                }\n            }\n        };\n        Highlighter sourceHighlighter = new DefaultHighlighter() {\n            public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p)\n            throws BadLocationException {\n                return super.addHighlight(p0, p1, painter);\n            }\n        };\n        sourceTextArea.setHighlighter(sourceHighlighter);\n        \n        updateTitle(getCurrentProject());\n    }","id":88709,"modified_method":"/**\n     * This is called from the constructor to perform post-initialization\n     * of the components in the form.\n     */\n    private void postInitComponents() {\n        logger = new ConsoleLogger(this);\n        \n        viewPanelLayout = (CardLayout) viewPanel.getLayout();\n        \n        // Console starts out disabled\n        consoleSplitter.setDividerLocation(1.0);\n        \n        // List of bug group tabs.\n        // This must be in the same order as GROUP_BY_ORDER_LIST!\n        bugTreeList = new JTree[]{byClassBugTree, byPackageBugTree, byBugTypeBugTree};\n        \n        // Configure bug trees\n        for (int i = 0; i < bugTreeList.length; ++i) {\n            JTree bugTree = bugTreeList[i];\n            bugTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n            bugTree.setCellRenderer(bugCellRenderer);\n            bugTree.setRootVisible(false);\n            bugTree.setShowsRootHandles(true);\n            bugTree.addTreeSelectionListener(new TreeSelectionListener() {\n                public void valueChanged(TreeSelectionEvent e) {\n                    bugTreeSelectionChanged(e);\n                }\n            });\n        }\n        \n        jarFileList.setModel(new DefaultListModel());\n        sourceDirList.setModel(new DefaultListModel());\n        classpathEntryList.setModel(new DefaultListModel());\n        \n        // We use a special highlight painter to ensure that the highlights cover\n        // complete source lines, even though the source text doesn't\n        // fill the lines completely.\n        final Highlighter.HighlightPainter painter =\n        new DefaultHighlighter.DefaultHighlightPainter(sourceTextArea.getSelectionColor()) {\n            public Shape paintLayer(Graphics g, int offs0, int offs1,\n            Shape bounds, JTextComponent c, View view) {\n                try {\n                    Shape extent = view.modelToView(offs0, Position.Bias.Forward, offs1, Position.Bias.Backward, bounds);\n                    Rectangle rect = extent.getBounds();\n                    rect.x = 0;\n                    rect.width = bounds.getBounds().width;\n                    g.setColor(getColor());\n                    g.fillRect(rect.x, rect.y, rect.width, rect.height);\n                    return rect;\n                } catch (BadLocationException e) {\n                    return null;\n                }\n            }\n        };\n        Highlighter sourceHighlighter = new DefaultHighlighter() {\n            public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p)\n            throws BadLocationException {\n                return super.addHighlight(p0, p1, painter);\n            }\n        };\n        sourceTextArea.setHighlighter(sourceHighlighter);\n        \n        updateTitle(getCurrentProject());\n        \n        priorityThreshold = Detector.NORMAL_PRIORITY;\n    }","commit_id":"8136dd565396b8a5978ecd9dcb8c8073bc20fb55","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void testCollection(CConfiguration config) throws IOException {\n\n    String logtag = \"a:b:c\";\n    int lengthOfOne = String.format(\"%s [%s] %s\\n\", logtag, \"ERROR\",\n        makeMessage(10000)).getBytes(LogFileWriter.charsetUtf8).length;\n\n    // start a log collector with 3 instances and space for 11 messages each\n    // (file rolls after a message is logged, hence the extra 2 bytes make\n    // space for an extra message.\n    config.setInt(LogConfiguration.CFG_ROLL_INSTANCES, 3);\n    config.setInt(LogConfiguration.CFG_ROLL_THRESHOLD, 10 * lengthOfOne + 2);\n    LogCollector collector = new LogCollector(config);\n\n    // write 5 messages, they should all be in the same file\n    for (int i = 0; i < 5; i++) {\n      collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(i)));\n    }\n\n    // this should return only one message\n    List<String> lines = collector.tail(logtag, lengthOfOne + 10);\n    Assert.assertEquals(1, lines.size());\n\n    // this should return 3 messages\n    lines = collector.tail(logtag, 3 * lengthOfOne + 10);\n    Assert.assertEquals(3, lines.size());\n\n    // this should return only 5 messages\n    lines = collector.tail(logtag, 10 * lengthOfOne + 10);\n    Assert.assertEquals(5, lines.size());\n\n    // write 6 more messages, this should roll the log after the last one\n    for (int i = 5; i < 11; i++) {\n      collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(i)));\n    }\n\n    // this should return only one message, and that is the last one: 10\n    lines = collector.tail(logtag, lengthOfOne + 10);\n    Assert.assertEquals(1, lines.size());\n    Assert.assertTrue(lines.get(0).contains(makeMessage(10)));\n\n    // write 1 more message, this should start writing to the next file\n    collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(11)));\n\n    // this should return two messages: 10 + 11\n    lines = collector.tail(logtag, 2 * lengthOfOne + 10);\n    Assert.assertEquals(2, lines.size());\n    Assert.assertTrue(lines.get(0).contains(makeMessage(10)));\n    Assert.assertTrue(lines.get(1).contains(makeMessage(11)));\n\n    // write 24 more messages, this should now roll and evict some\n    for (int i = 12; i < 36; i++) {\n      collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(i)));\n    }\n\n    // read across all instances: the current file has 3, the others 11\n    // hence reading 16 should read across all 3 files\n    lines = collector.tail(logtag, 16 * lengthOfOne + 10);\n    Assert.assertEquals(16, lines.size());\n    for (int i = 0; i < 16; i++) {\n      Assert.assertTrue(lines.get(i).contains(makeMessage(i + 20)));\n    }\n\n    // read past the last instance: the current file has 3, the others 11\n    // hence reading 27 should exceed the 3 files\n    lines = collector.tail(logtag, 27 * lengthOfOne + 10);\n    Assert.assertEquals(25, lines.size());\n    for (int i = 0; i < 25; i++) {\n      Assert.assertTrue(lines.get(i).contains(makeMessage(i + 11)));\n    }\n\n    // close the log collector and reopen it\n    collector.close();\n    collector = new LogCollector(config);\n\n    // verify that the state is the same with the new collector\n    lines = collector.tail(logtag, 27 * lengthOfOne + 10);\n    Assert.assertEquals(25, lines.size());\n    for (int i = 0; i < 25; i++) {\n      Assert.assertTrue(lines.get(i).contains(makeMessage(i + 11)));\n    }\n\n    // write 1 more message, this should append to the current file\n    collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(36)));\n\n\n    // verify that append works and we see an additional message\n    // - if it rolls, then we lose messages\n    // - if it fails, then we don't see the new message\n    lines = collector.tail(logtag, 27 * lengthOfOne + 10);\n    // the local file system append() does not work. Hence we roll the\n    // log when re-opening the collector and lose one file (11 messages)\n    // TODO how terrible! it defeats the purpose of the FileSystem abstraction\n    // TODO fix this as soon as append works for local fs\n    if (FileSystem.get(config) instanceof LocalFileSystem) {\n      Assert.assertEquals(15, lines.size());\n      for (int i = 0; i < 15; i++) {\n        Assert.assertTrue(lines.get(i).contains(makeMessage(i + 22)));\n      }\n    } else {\n      Assert.assertEquals(26, lines.size());\n      for (int i = 0; i < 26; i++) {\n        Assert.assertTrue(lines.get(i).contains(makeMessage(i + 11)));\n      }\n    }\n  }","id":88710,"modified_method":"private void testCollection(CConfiguration config) throws IOException {\n\n    String logtag = \"a:b:c\";\n    int lengthOfOne = String.format(\"%s [%s] %s\\n\", logtag, \"ERROR\",\n        makeMessage(10000)).getBytes(LogFileWriter.charsetUtf8).length;\n\n    // start a log collector with 3 instances and space for 11 messages each\n    // (file rolls after a message is logged, hence the extra 2 bytes make\n    // space for an extra message.\n    config.setInt(LogConfiguration.CFG_ROLL_INSTANCES, 3);\n    config.setInt(LogConfiguration.CFG_ROLL_THRESHOLD, 10 * lengthOfOne + 2);\n    LogCollector collector = new LogCollector(config);\n\n    // write 5 messages, they should all be in the same file\n    for (int i = 0; i < 5; i++) {\n      collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(i)));\n    }\n\n    // this should return only one message\n    List<String> lines = collector.tail(logtag, lengthOfOne + 10);\n    Assert.assertEquals(1, lines.size());\n\n    // this should return 3 messages\n    lines = collector.tail(logtag, 3 * lengthOfOne + 10);\n    Assert.assertEquals(3, lines.size());\n\n    // this should return only 5 messages\n    lines = collector.tail(logtag, 10 * lengthOfOne + 10);\n    Assert.assertEquals(5, lines.size());\n\n    // test that we can also read with another instance of the collector\n    LogCollector collector2 = new LogCollector(config);\n    // this should return only one message\n    lines = collector2.tail(logtag, lengthOfOne + 10);\n    Assert.assertEquals(1, lines.size());\n\n\n    // write 6 more messages, this should roll the log after the last one\n    for (int i = 5; i < 11; i++) {\n      collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(i)));\n    }\n\n    // this should return only one message, and that is the last one: 10\n    lines = collector.tail(logtag, lengthOfOne + 10);\n    Assert.assertEquals(1, lines.size());\n    Assert.assertTrue(lines.get(0).contains(makeMessage(10)));\n\n    // write 1 more message, this should start writing to the next file\n    collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(11)));\n\n    // this should return two messages: 10 + 11\n    lines = collector.tail(logtag, 2 * lengthOfOne + 10);\n    Assert.assertEquals(2, lines.size());\n    Assert.assertTrue(lines.get(0).contains(makeMessage(10)));\n    Assert.assertTrue(lines.get(1).contains(makeMessage(11)));\n\n    // write 24 more messages, this should now roll and evict some\n    for (int i = 12; i < 36; i++) {\n      collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(i)));\n    }\n\n    // read across all instances: the current file has 3, the others 11\n    // hence reading 16 should read across all 3 files\n    lines = collector.tail(logtag, 16 * lengthOfOne + 10);\n    Assert.assertEquals(16, lines.size());\n    for (int i = 0; i < 16; i++) {\n      Assert.assertTrue(lines.get(i).contains(makeMessage(i + 20)));\n    }\n\n    // read past the last instance: the current file has 3, the others 11\n    // hence reading 27 should exceed the 3 files\n    lines = collector.tail(logtag, 27 * lengthOfOne + 10);\n    Assert.assertEquals(25, lines.size());\n    for (int i = 0; i < 25; i++) {\n      Assert.assertTrue(lines.get(i).contains(makeMessage(i + 11)));\n    }\n\n    // close the log collector and reopen it\n    collector.close();\n    collector = new LogCollector(config);\n\n    // verify that the state is the same with the new collector\n    lines = collector.tail(logtag, 27 * lengthOfOne + 10);\n    Assert.assertEquals(25, lines.size());\n    for (int i = 0; i < 25; i++) {\n      Assert.assertTrue(lines.get(i).contains(makeMessage(i + 11)));\n    }\n\n    // write 1 more message, this should append to the current file\n    collector.log(new LogEvent(logtag, \"ERROR\", makeMessage(36)));\n\n\n    // verify that append works and we see an additional message\n    // - if it rolls, then we lose messages\n    // - if it fails, then we don't see the new message\n    lines = collector.tail(logtag, 27 * lengthOfOne + 10);\n    // the local file system append() does not work. Hence we roll the\n    // log when re-opening the collector and lose one file (11 messages)\n    // TODO how terrible! it defeats the purpose of the FileSystem abstraction\n    // TODO fix this as soon as append works for local fs\n    if (FileSystem.get(config) instanceof LocalFileSystem) {\n      Assert.assertEquals(15, lines.size());\n      for (int i = 0; i < 15; i++) {\n        Assert.assertTrue(lines.get(i).contains(makeMessage(i + 22)));\n      }\n    } else {\n      Assert.assertEquals(26, lines.size());\n      for (int i = 0; i < 26; i++) {\n        Assert.assertTrue(lines.get(i).contains(makeMessage(i + 11)));\n      }\n    }\n  }","commit_id":"dfc9231476f8b1adfbb3050ff7db6122fbeb826e","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Recursive method to tail the log. Reads from the current log file\n   * instance (i), and if that does not have sufficient size, recurses to the\n   * next older instance (i+1). If the caller knows the size of the current\n   * file (i), he can pass it via the fileSize parameter.\n   * @param lines A list of log lines to append read lines to\n   * @param i The current log file instance to start reading from\n   * @param size number of bytes to read at most\n   * @param sizeHint if known, the caller should pass in the length of the\n   *                 current log file instance. This helps to seek to the end\n   *                 of a file that has not been closed yet (and hence file\n   *                 status does not reflect its correct size). Only needed\n   *                 at instance 0. Otherwise (for recursive calls) this is\n   *                 -1, and the file size will be obatained via file status.\n   * @return The list of lines read\n   * @throws IOException if reading goes badly wrong\n   */\n  private List<String> tail(ArrayList<String> lines, int i, long size,\n                            long sizeHint)\n      throws IOException {\n\n    // get the path of the current log file instance (xxx.log[.i])\n    Path path = new Path(config.getLogFilePath(), makeFileName(i));\n\n    // check for its existence, if it does not exist, return empty list\n    if (!fileSystem.exists(path)) return lines;\n    FileStatus status = fileSystem.getFileStatus(path);\n    if (!status.isFile()) return lines;\n\n    long fileSize = sizeHint < 0 ? status.getLen() : sizeHint;\n    long seekPos = 0;\n    long bytesToRead = size;\n    if (fileSize >= size) {\n      // if size of currentFile is sufficient, we need to seek to the\n      // position that is size bytes from the end of the file.\n      seekPos = fileSize - size;\n    } else {\n      // if size of current file is less than limit, make a recursive\n      // call to tail for previous file\n      tail(lines, i + 1, size - fileSize, -1);\n      bytesToRead = fileSize;\n    }\n\n    // open current file for reading\n    FSDataInputStream input = fileSystem.open(path);\n    // seek into latest file\n    if (seekPos > 0) {\n      input.seek(seekPos);\n    }\n\n    // read to the end of current file\n    byte[] bytes = new byte[(int)bytesToRead];\n    input.readFully(bytes);\n\n    int pos = 0;\n    if (seekPos > 0) {\n      // if we seeked into the file, then we are likely in the middle of the\n      // line, and we want to skip up to the first new line\n      while (pos < bytesToRead && bytes[pos] != '\\n') pos++;\n      pos++; // now we are just after the first new line\n    }\n\n    // read lines until the end of the buffer\n    while (pos < bytesToRead) {\n      int start = pos;\n      while (pos < bytesToRead && bytes[pos] != '\\n') pos++;\n      // now we are at end of file or at the new line\n      if (pos != start) { // ignore empty lines\n        String line = new String(bytes, start, pos - start,\n            LogFileWriter.charsetUtf8);\n        lines.add(line);\n      }\n      pos++; // skip the new line character\n    }\n    return lines;\n  }","id":88711,"modified_method":"/**\n   * Recursive method to tail the log. Reads from the current log file\n   * instance (i), and if that does not have sufficient size, recurses to the\n   * next older instance (i+1). If the caller knows the size of the current\n   * file (i), he can pass it via the fileSize parameter.\n   * @param lines A list of log lines to append read lines to\n   * @param i The current log file instance to start reading from\n   * @param size number of bytes to read at most\n   * @param sizeHint if known, the caller should pass in the length of the\n   *                 current log file instance. This helps to seek to the end\n   *                 of a file that has not been closed yet (and hence file\n   *                 status does not reflect its correct size). Only needed\n   *                 at instance 0. Otherwise (for recursive calls) this is\n   *                 -1, and the file size will be obatained via file status.\n   * @return The list of lines read\n   * @throws IOException if reading goes badly wrong\n   */\n  private List<String> tail(ArrayList<String> lines, int i, long size,\n                            long sizeHint)\n      throws IOException {\n\n    // get the path of the current log file instance (xxx.log[.i])\n    Path path = new Path(config.getLogFilePath(), makeFileName(i));\n\n    // check for its existence, if it does not exist, return empty list\n    if (!fileSystem.exists(path)) return lines;\n    FileStatus status = fileSystem.getFileStatus(path);\n    if (!status.isFile()) return lines;\n\n    long fileSize;\n    if (sizeHint >= 0) fileSize = sizeHint;\n    else if (i > 0) fileSize = status.getLen();\n    else fileSize = determineTrueFileSize(path, status);\n\n    long seekPos = 0;\n    long bytesToRead = size;\n    if (fileSize >= size) {\n      // if size of currentFile is sufficient, we need to seek to the\n      // position that is size bytes from the end of the file.\n      seekPos = fileSize - size;\n    } else {\n      // if size of current file is less than limit, make a recursive\n      // call to tail for previous file\n      tail(lines, i + 1, size - fileSize, -1);\n      bytesToRead = fileSize;\n    }\n\n    // open current file for reading\n    FSDataInputStream input = fileSystem.open(path);\n    // seek into latest file\n    if (seekPos > 0) {\n      input.seek(seekPos);\n    }\n\n    // read to the end of current file\n    byte[] bytes = new byte[(int)bytesToRead];\n    input.readFully(bytes);\n\n    int pos = 0;\n    if (seekPos > 0) {\n      // if we seeked into the file, then we are likely in the middle of the\n      // line, and we want to skip up to the first new line\n      while (pos < bytesToRead && bytes[pos] != '\\n') pos++;\n      pos++; // now we are just after the first new line\n    }\n\n    // read lines until the end of the buffer\n    while (pos < bytesToRead) {\n      int start = pos;\n      while (pos < bytesToRead && bytes[pos] != '\\n') pos++;\n      // now we are at end of file or at the new line\n      if (pos != start) { // ignore empty lines\n        String line = new String(bytes, start, pos - start,\n            LogFileWriter.charsetUtf8);\n        lines.add(line);\n      }\n      pos++; // skip the new line character\n    }\n    return lines;\n  }","commit_id":"dfc9231476f8b1adfbb3050ff7db6122fbeb826e","url":"https://github.com/caskdata/cdap"},{"original_method":"public Nfs3FileAttributes() {\n    this(NfsFileType.NFSREG, 0, (short)0, 0, 0, 0, 0, 0, 0, 0);\n  }","id":88712,"modified_method":"public Nfs3FileAttributes() {\n    this(NfsFileType.NFSREG, 1, (short)0, 0, 0, 0, 0, 0, 0, 0, new Specdata3());\n  }","commit_id":"2cc868dede3187ef3e122e878b8ee0882c82dc81","url":"https://github.com/apache/hadoop"},{"original_method":"public Nfs3FileAttributes(NfsFileType nfsType, int nlink, short mode, int uid,\n      int gid, long size, long fsid, long fileId, long mtime, long atime) {\n    this.type = nfsType.toValue();\n    this.mode = mode;\n    this.nlink = (type == NfsFileType.NFSDIR.toValue()) ? (nlink + 2) : 1;\n    this.uid = uid;\n    this.gid = gid;\n    this.size = size;\n    if(type == NfsFileType.NFSDIR.toValue()) {\n      this.size = getDirSize(nlink);\n    }\n    this.used = this.size;\n    this.rdev = new Specdata3();\n    this.fsid = fsid;\n    this.fileId = fileId;\n    this.mtime = new NfsTime(mtime);\n    this.atime = atime != 0 ? new NfsTime(atime) : this.mtime;\n    this.ctime = this.mtime;\n  }","id":88713,"modified_method":"public Nfs3FileAttributes(NfsFileType nfsType, int nlink, short mode, int uid,\n      int gid, long size, long fsid, long fileId, long mtime, long atime, Specdata3 rdev) {\n    this.type = nfsType.toValue();\n    this.mode = mode;\n    this.nlink = nlink;\n    this.uid = uid;\n    this.gid = gid;\n    this.size = size;\n    this.used = this.size;\n    this.rdev = new Specdata3();\n    this.fsid = fsid;\n    this.fileId = fileId;\n    this.mtime = new NfsTime(mtime);\n    this.atime = atime != 0 ? new NfsTime(atime) : this.mtime;\n    this.ctime = this.mtime;\n    this.rdev = rdev;\n  }","commit_id":"2cc868dede3187ef3e122e878b8ee0882c82dc81","url":"https://github.com/apache/hadoop"},{"original_method":"public static Nfs3FileAttributes deserialize(XDR xdr) {\n    Nfs3FileAttributes attr = new Nfs3FileAttributes();\n    attr.type = xdr.readInt();\n    attr.mode = xdr.readInt();\n    attr.nlink = xdr.readInt();\n    attr.uid = xdr.readInt();\n    attr.gid = xdr.readInt();\n    attr.size = xdr.readHyper();\n    attr.used = xdr.readHyper();\n    // Ignore rdev\n    xdr.readInt();\n    xdr.readInt();\n    attr.rdev = new Specdata3();\n    attr.fsid = xdr.readHyper();\n    attr.fileId = xdr.readHyper();\n    attr.atime = NfsTime.deserialize(xdr);\n    attr.mtime = NfsTime.deserialize(xdr);\n    attr.ctime = NfsTime.deserialize(xdr);\n    return attr;\n  }","id":88714,"modified_method":"public static Nfs3FileAttributes deserialize(XDR xdr) {\n    Nfs3FileAttributes attr = new Nfs3FileAttributes();\n    attr.type = xdr.readInt();\n    attr.mode = xdr.readInt();\n    attr.nlink = xdr.readInt();\n    attr.uid = xdr.readInt();\n    attr.gid = xdr.readInt();\n    attr.size = xdr.readHyper();\n    attr.used = xdr.readHyper();\n    attr.rdev = new Specdata3(xdr.readInt(), xdr.readInt());\n    attr.fsid = xdr.readHyper();\n    attr.fileId = xdr.readHyper();\n    attr.atime = NfsTime.deserialize(xdr);\n    attr.mtime = NfsTime.deserialize(xdr);\n    attr.ctime = NfsTime.deserialize(xdr);\n    return attr;\n  }","commit_id":"2cc868dede3187ef3e122e878b8ee0882c82dc81","url":"https://github.com/apache/hadoop"},{"original_method":"public static Nfs3FileAttributes getNfs3FileAttrFromFileStatus(\n      HdfsFileStatus fs, IdMappingServiceProvider iug) {\n    /**\n     * Some 32bit Linux client has problem with 64bit fileId: it seems the 32bit\n     * client takes only the lower 32bit of the fileId and treats it as signed\n     * int. When the 32th bit is 1, the client considers it invalid.\n     */\n    NfsFileType fileType = fs.isDir() ? NfsFileType.NFSDIR : NfsFileType.NFSREG;\n    fileType = fs.isSymlink() ? NfsFileType.NFSLNK : fileType;\n    \n    return new Nfs3FileAttributes(fileType, fs.getChildrenNum(), fs\n        .getPermission().toShort(), iug.getUidAllowingUnknown(fs.getOwner()),\n        iug.getGidAllowingUnknown(fs.getGroup()), fs.getLen(), 0 /* fsid */,\n        fs.getFileId(), fs.getModificationTime(), fs.getAccessTime());\n  }","id":88715,"modified_method":"public static Nfs3FileAttributes getNfs3FileAttrFromFileStatus(\n      HdfsFileStatus fs, IdMappingServiceProvider iug) {\n    /**\n     * Some 32bit Linux client has problem with 64bit fileId: it seems the 32bit\n     * client takes only the lower 32bit of the fileId and treats it as signed\n     * int. When the 32th bit is 1, the client considers it invalid.\n     */\n    NfsFileType fileType = fs.isDir() ? NfsFileType.NFSDIR : NfsFileType.NFSREG;\n    fileType = fs.isSymlink() ? NfsFileType.NFSLNK : fileType;\n    int nlink = (fileType == NfsFileType.NFSDIR) ? fs.getChildrenNum() + 2 : 1;\n    long size = (fileType == NfsFileType.NFSDIR) ? getDirSize(fs\n        .getChildrenNum()) : fs.getLen();\n    return new Nfs3FileAttributes(fileType, nlink,\n        fs.getPermission().toShort(), iug.getUidAllowingUnknown(fs.getOwner()),\n        iug.getGidAllowingUnknown(fs.getGroup()), size, 0 /* fsid */,\n        fs.getFileId(), fs.getModificationTime(), fs.getAccessTime(),\n        new Nfs3FileAttributes.Specdata3());\n  }","commit_id":"2cc868dede3187ef3e122e878b8ee0882c82dc81","url":"https://github.com/apache/hadoop"},{"original_method":"public static WccAttr getWccAttr(DFSClient client, String fileIdPath)\n      throws IOException {\n    HdfsFileStatus fstat = getFileStatus(client, fileIdPath);\n    if (fstat == null) {\n      return null;\n    }\n\n    long size = fstat.isDir() ? Nfs3FileAttributes.getDirSize(fstat\n        .getChildrenNum()) : fstat.getLen();\n    return new WccAttr(size, new NfsTime(fstat.getModificationTime()),\n        new NfsTime(fstat.getModificationTime()));\n  }","id":88716,"modified_method":"public static WccAttr getWccAttr(DFSClient client, String fileIdPath)\n      throws IOException {\n    HdfsFileStatus fstat = getFileStatus(client, fileIdPath);\n    if (fstat == null) {\n      return null;\n    }\n\n    long size = fstat.isDir() ? getDirSize(fstat.getChildrenNum()) : fstat\n        .getLen();\n    return new WccAttr(size, new NfsTime(fstat.getModificationTime()),\n        new NfsTime(fstat.getModificationTime()));\n  }","commit_id":"2cc868dede3187ef3e122e878b8ee0882c82dc81","url":"https://github.com/apache/hadoop"},{"original_method":"protected Set<Class> processFileUrl(URL url, String basepath, Class clazz) throws IOException\n    {\n        Set<Class> set = new HashSet<Class>();\n        String urlBase = url.getFile();\n        urlBase = URLDecoder.decode(urlBase);\n\n        Collection<File> files = FileUtils.listFiles(new File(urlBase), new String[]{\"class\"}, true);\n        for (File file : files)\n        {\n            try\n            {\n                ClassReader reader = new ClassReader(new FileInputStream(file));\n                ClassScanner visitor = getScanner(clazz);\n                reader.accept(visitor, 0);\n                if (visitor.isMatch())\n                {\n                    Class c = loadClass(visitor.getClassName());\n                    if (c != null)\n                    {\n                        set.add(c);\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    Throwable t = ExceptionHelper.getRootException(e);\n                    logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                }\n            }\n        }\n        return set;\n    }","id":88717,"modified_method":"protected Set<Class> processFileUrl(URL url, String basepath, Class clazz) throws IOException\n    {\n        Set<Class> set = new HashSet<Class>();\n        String urlBase = url.getFile();\n        urlBase = URLDecoder.decode(urlBase);\n\n        Collection<File> files = FileUtils.listFiles(new File(urlBase), new String[]{\"class\"}, true);\n        for (File file : files)\n        {\n            try\n            {\n                InputStream classStream = new FileInputStream(file);\n                ClassReader reader = new ClassReader(classStream);\n                classStream.close();\n                \n                ClassScanner visitor = getScanner(clazz);\n                reader.accept(visitor, 0);\n                if (visitor.isMatch())\n                {\n                    Class c = loadClass(visitor.getClassName());\n                    if (c != null)\n                    {\n                        set.add(c);\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    Throwable t = ExceptionHelper.getRootException(e);\n                    logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                }\n            }\n        }\n        return set;\n    }","commit_id":"03ee5949d9d0113ca57eb79d74b3a8ca335f8b70","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Set<Class> processJarUrl(URL url, String basepath, Class clazz) throws IOException\n    {\n        Set<Class> set = new HashSet<Class>();\n        String path = url.getFile().substring(5, url.getFile().indexOf(\"!\"));\n        path = URLDecoder.decode(path);\n        JarFile jar = new JarFile(path);\n\n        for (Enumeration entries = jar.entries(); entries.hasMoreElements();)\n        {\n            JarEntry entry = (JarEntry) entries.nextElement();\n            if (entry.getName().startsWith(basepath) && entry.getName().endsWith(\".class\"))\n            {\n                try\n                {\n                    String name = entry.getName();\n                    //Ignore anonymous\n                    // TODO RM what about the other anonymous classes like $2, $3 ?\n                    if (name.contains(\"$1\"))\n                    {\n                        continue;\n                    }\n                    URL classURL = classLoader.getResource(name);\n                    ClassReader reader = new ClassReader(classURL.openStream());\n                    ClassScanner visitor = getScanner(clazz);\n                    reader.accept(visitor, 0);\n                    if (visitor.isMatch())\n                    {\n                        Class c = loadClass(visitor.getClassName());\n                        if (c != null)\n                        {\n                            set.add(c);\n                        }\n                    }\n                }\n                catch (Exception e)\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        Throwable t = ExceptionHelper.getRootException(e);\n                        logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                    }\n                }\n            }\n        }\n        return set;\n    }","id":88718,"modified_method":"protected Set<Class> processJarUrl(URL url, String basepath, Class clazz) throws IOException\n    {\n        Set<Class> set = new HashSet<Class>();\n        String path = url.getFile().substring(5, url.getFile().indexOf(\"!\"));\n        path = URLDecoder.decode(path);\n        JarFile jar = new JarFile(path);\n\n        for (Enumeration entries = jar.entries(); entries.hasMoreElements();)\n        {\n            JarEntry entry = (JarEntry) entries.nextElement();\n            if (entry.getName().startsWith(basepath) && entry.getName().endsWith(\".class\"))\n            {\n                try\n                {\n                    String name = entry.getName();\n                    //Ignore anonymous\n                    // TODO RM what about the other anonymous classes like $2, $3 ?\n                    if (name.contains(\"$1\"))\n                    {\n                        continue;\n                    }\n                    \n                    URL classURL = classLoader.getResource(name);\n                    InputStream classStream = classURL.openStream();\n                    ClassReader reader = new ClassReader(classStream);\n                    classStream.close();\n                    \n                    ClassScanner visitor = getScanner(clazz);\n                    reader.accept(visitor, 0);\n                    if (visitor.isMatch())\n                    {\n                        Class c = loadClass(visitor.getClassName());\n                        if (c != null)\n                        {\n                            set.add(c);\n                        }\n                    }\n                }\n                catch (Exception e)\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        Throwable t = ExceptionHelper.getRootException(e);\n                        logger.debug(String.format(\"%s: caused by: %s\", e.toString(), t.toString()));\n                    }\n                }\n            }\n        }\n        jar.close();\n        \n        return set;\n    }","commit_id":"03ee5949d9d0113ca57eb79d74b3a8ca335f8b70","url":"https://github.com/mulesoft/mule"},{"original_method":"public void visit(int i, int i1, String s, String s1, String superName, String[] interfaces)\n    {\n\n        if(superName==null)\n        {\n            return;\n        }\n        else if(superName.replaceAll(\"/\",\".\").equals(implementationClass.getName()))\n        {\n            match = true;\n            className = s;\n        }\n        else\n        {\n            try\n            {\n                ImplementationClassScanner scanner = new ImplementationClassScanner(implementationClass);\n                URL classURL = getClassURL(superName);\n                ClassReader r = new ClassReader(classURL.openStream());\n                r.accept(scanner, 0);\n                match = scanner.isMatch();\n                className = scanner.getClassName();\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n\n        }\n    }","id":88719,"modified_method":"public void visit(int i, int i1, String s, String s1, String superName, String[] interfaces)\n    {\n\n        if(superName==null)\n        {\n            return;\n        }\n        else if(superName.replaceAll(\"/\",\".\").equals(implementationClass.getName()))\n        {\n            match = true;\n            className = s;\n        }\n        else\n        {\n            try\n            {\n                ImplementationClassScanner scanner = new ImplementationClassScanner(implementationClass);\n                URL classURL = getClassURL(superName);\n                InputStream classStream = classURL.openStream();\n                ClassReader r = new ClassReader(classStream);\n                classStream.close();\n                \n                r.accept(scanner, 0);\n                match = scanner.isMatch();\n                className = scanner.getClassName();\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n\n        }\n    }","commit_id":"03ee5949d9d0113ca57eb79d74b3a8ca335f8b70","url":"https://github.com/mulesoft/mule"},{"original_method":"protected ClassScanner scan(String name)\n    {\n        try\n        {\n            InterfaceClassScanner scanner = new InterfaceClassScanner(interfaceClass, classLoader);\n            URL clasURL = getClassURL(name);\n            ClassReader r = new ClassReader(clasURL.openStream());\n            r.accept(scanner, 0);\n            return scanner;\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(name, e);\n        }\n    }","id":88720,"modified_method":"protected ClassScanner scan(String name)\n    {\n        try\n        {\n            InterfaceClassScanner scanner = new InterfaceClassScanner(interfaceClass, classLoader);\n            URL classURL = getClassURL(name);\n            \n            InputStream classStream = classURL.openStream();\n            ClassReader r = new ClassReader(classStream);\n            classStream.close(); \n            \n            r.accept(scanner, 0);\n            return scanner;\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(name, e);\n        }\n    }","commit_id":"03ee5949d9d0113ca57eb79d74b3a8ca335f8b70","url":"https://github.com/mulesoft/mule"},{"original_method":"public boolean accept(AnnotationInfo info)\n    {\n        try\n        {\n            URL classUrl = getClassURL(info.getClassName());\n            if(classUrl==null)\n            {\n                logger.debug(\"Failed to load annotation class: \" + info);\n                return false;\n            }\n            ClassReader r = new ClassReader(classUrl.openStream());\n          \n            MetaAnnotationScanner scanner = new MetaAnnotationScanner(new AnnotationTypeFilter(annotation));\n            r.accept(scanner, 0);\n\n            return scanner.getClassAnnotations().size() == 1;\n        }\n        catch (IOException e)\n        {\n            logger.debug(e);\n            return false;\n        }\n    }","id":88721,"modified_method":"public boolean accept(AnnotationInfo info)\n    {\n        try\n        {\n            URL classUrl = getClassURL(info.getClassName());\n            if (classUrl == null)\n            {\n                logger.debug(\"Failed to load annotation class: \" + info);\n                return false;\n            }\n            \n            InputStream classStream = classUrl.openStream();\n            ClassReader r = new ClassReader(classStream);\n            classStream.close();\n          \n            MetaAnnotationScanner scanner = new MetaAnnotationScanner(new AnnotationTypeFilter(annotation));\n            r.accept(scanner, 0);\n\n            return scanner.getClassAnnotations().size() == 1;\n        }\n        catch (IOException e)\n        {\n            logger.debug(e);\n            return false;\n        }\n    }","commit_id":"03ee5949d9d0113ca57eb79d74b3a8ca335f8b70","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        ClearIndicesCacheRequest clearIndicesCacheRequest = new ClearIndicesCacheRequest(RestActions.splitIndices(request.param(\"index\")));\n        clearIndicesCacheRequest.listenerThreaded(false);\n        clearIndicesCacheRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        try {\n            clearIndicesCacheRequest.filterCache(request.paramAsBoolean(\"filter\", clearIndicesCacheRequest.filterCache()));\n            clearIndicesCacheRequest.fieldDataCache(request.paramAsBoolean(\"field_data\", clearIndicesCacheRequest.fieldDataCache()));\n            clearIndicesCacheRequest.idCache(request.paramAsBoolean(\"id\", clearIndicesCacheRequest.idCache()));\n            clearIndicesCacheRequest.bloomCache(request.paramAsBoolean(\"bloom\", clearIndicesCacheRequest.bloomCache()));\n            clearIndicesCacheRequest.fields(request.paramAsStringArray(\"fields\", clearIndicesCacheRequest.fields()));\n\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operationThreading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n            }\n            clearIndicesCacheRequest.operationThreading(operationThreading);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n        client.admin().indices().clearCache(clearIndicesCacheRequest, new ActionListener<ClearIndicesCacheResponse>() {\n            @Override\n            public void onResponse(ClearIndicesCacheResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88722,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        ClearIndicesCacheRequest clearIndicesCacheRequest = new ClearIndicesCacheRequest(RestActions.splitIndices(request.param(\"index\")));\n        clearIndicesCacheRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            clearIndicesCacheRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        try {\n            clearIndicesCacheRequest.filterCache(request.paramAsBoolean(\"filter\", clearIndicesCacheRequest.filterCache()));\n            clearIndicesCacheRequest.fieldDataCache(request.paramAsBoolean(\"field_data\", clearIndicesCacheRequest.fieldDataCache()));\n            clearIndicesCacheRequest.idCache(request.paramAsBoolean(\"id\", clearIndicesCacheRequest.idCache()));\n            clearIndicesCacheRequest.bloomCache(request.paramAsBoolean(\"bloom\", clearIndicesCacheRequest.bloomCache()));\n            clearIndicesCacheRequest.fields(request.paramAsStringArray(\"fields\", clearIndicesCacheRequest.fields()));\n\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operationThreading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n            }\n            clearIndicesCacheRequest.operationThreading(operationThreading);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n        client.admin().indices().clearCache(clearIndicesCacheRequest, new ActionListener<ClearIndicesCacheResponse>() {\n            @Override\n            public void onResponse(ClearIndicesCacheResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        CountRequest countRequest = new CountRequest(RestActions.splitIndices(request.param(\"index\")));\n        countRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        countRequest.listenerThreaded(false);\n        try {\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n            }\n            countRequest.operationThreading(operationThreading);\n            if (request.hasContent()) {\n                countRequest.query(request.content(), request.contentUnsafe());\n            } else {\n                String source = request.param(\"source\");\n                if (source != null) {\n                    countRequest.query(source);\n                } else {\n                    BytesReference querySource = RestActions.parseQuerySource(request);\n                    if (querySource != null) {\n                        countRequest.query(querySource, false);\n                    }\n                }\n            }\n            countRequest.queryHint(request.param(\"query_hint\"));\n            countRequest.routing(request.param(\"routing\"));\n            countRequest.minScore(request.paramAsFloat(\"min_score\", DEFAULT_MIN_SCORE));\n            countRequest.types(splitTypes(request.param(\"type\")));\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.count(countRequest, new ActionListener<CountResponse>() {\n            @Override\n            public void onResponse(CountResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"count\", response.count());\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88723,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        CountRequest countRequest = new CountRequest(RestActions.splitIndices(request.param(\"index\")));\n        if (request.hasParam(\"ignore_indices\")) {\n            countRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        countRequest.listenerThreaded(false);\n        try {\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n            }\n            countRequest.operationThreading(operationThreading);\n            if (request.hasContent()) {\n                countRequest.query(request.content(), request.contentUnsafe());\n            } else {\n                String source = request.param(\"source\");\n                if (source != null) {\n                    countRequest.query(source);\n                } else {\n                    BytesReference querySource = RestActions.parseQuerySource(request);\n                    if (querySource != null) {\n                        countRequest.query(querySource, false);\n                    }\n                }\n            }\n            countRequest.queryHint(request.param(\"query_hint\"));\n            countRequest.routing(request.param(\"routing\"));\n            countRequest.minScore(request.paramAsFloat(\"min_score\", DEFAULT_MIN_SCORE));\n            countRequest.types(splitTypes(request.param(\"type\")));\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.count(countRequest, new ActionListener<CountResponse>() {\n            @Override\n            public void onResponse(CountResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"count\", response.count());\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        FlushRequest flushRequest = new FlushRequest(RestActions.splitIndices(request.param(\"index\")));\n        flushRequest.listenerThreaded(false);\n        flushRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operationThreading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n        }\n        flushRequest.operationThreading(operationThreading);\n        flushRequest.refresh(request.paramAsBoolean(\"refresh\", flushRequest.refresh()));\n        flushRequest.full(request.paramAsBoolean(\"full\", flushRequest.full()));\n        flushRequest.force(request.paramAsBoolean(\"force\", flushRequest.force()));\n        client.admin().indices().flush(flushRequest, new ActionListener<FlushResponse>() {\n            @Override\n            public void onResponse(FlushResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88724,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        FlushRequest flushRequest = new FlushRequest(RestActions.splitIndices(request.param(\"index\")));\n        flushRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            flushRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operationThreading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n        }\n        flushRequest.operationThreading(operationThreading);\n        flushRequest.refresh(request.paramAsBoolean(\"refresh\", flushRequest.refresh()));\n        flushRequest.full(request.paramAsBoolean(\"full\", flushRequest.full()));\n        flushRequest.force(request.paramAsBoolean(\"force\", flushRequest.force()));\n        client.admin().indices().flush(flushRequest, new ActionListener<FlushResponse>() {\n            @Override\n            public void onResponse(FlushResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        GatewaySnapshotRequest gatewaySnapshotRequest = new GatewaySnapshotRequest(RestActions.splitIndices(request.param(\"index\")));\n        gatewaySnapshotRequest.listenerThreaded(false);\n        gatewaySnapshotRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        client.admin().indices().gatewaySnapshot(gatewaySnapshotRequest, new ActionListener<GatewaySnapshotResponse>() {\n            @Override\n            public void onResponse(GatewaySnapshotResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88725,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        GatewaySnapshotRequest gatewaySnapshotRequest = new GatewaySnapshotRequest(RestActions.splitIndices(request.param(\"index\")));\n        gatewaySnapshotRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            gatewaySnapshotRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        client.admin().indices().gatewaySnapshot(gatewaySnapshotRequest, new ActionListener<GatewaySnapshotResponse>() {\n            @Override\n            public void onResponse(GatewaySnapshotResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        IndicesSegmentsRequest indicesSegmentsRequest = new IndicesSegmentsRequest(splitIndices(request.param(\"index\")));\n        indicesSegmentsRequest.listenerThreaded(false);\n        indicesSegmentsRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n        }\n        indicesSegmentsRequest.operationThreading(operationThreading);\n        client.admin().indices().segments(indicesSegmentsRequest, new ActionListener<IndicesSegmentResponse>() {\n            @Override\n            public void onResponse(IndicesSegmentResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n                    buildBroadcastShardsHeader(builder, response);\n                    response.toXContent(builder, request);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88726,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        IndicesSegmentsRequest indicesSegmentsRequest = new IndicesSegmentsRequest(splitIndices(request.param(\"index\")));\n        indicesSegmentsRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            indicesSegmentsRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n        }\n        indicesSegmentsRequest.operationThreading(operationThreading);\n        client.admin().indices().segments(indicesSegmentsRequest, new ActionListener<IndicesSegmentResponse>() {\n            @Override\n            public void onResponse(IndicesSegmentResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n                    buildBroadcastShardsHeader(builder, response);\n                    response.toXContent(builder, request);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest();\n        indicesStatsRequest.listenerThreaded(false);\n        indicesStatsRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        boolean clear = request.paramAsBoolean(\"clear\", false);\n        if (clear) {\n            indicesStatsRequest.clear();\n        }\n        boolean all = request.paramAsBoolean(\"all\", false);\n        if (all) {\n            indicesStatsRequest.all();\n        }\n        indicesStatsRequest.indices(splitIndices(request.param(\"index\")));\n        indicesStatsRequest.types(splitTypes(request.param(\"types\")));\n        if (request.hasParam(\"groups\")) {\n            indicesStatsRequest.groups(Strings.splitStringByCommaToArray(request.param(\"groups\")));\n        }\n        indicesStatsRequest.docs(request.paramAsBoolean(\"docs\", indicesStatsRequest.docs()));\n        indicesStatsRequest.store(request.paramAsBoolean(\"store\", indicesStatsRequest.store()));\n        indicesStatsRequest.indexing(request.paramAsBoolean(\"indexing\", indicesStatsRequest.indexing()));\n        indicesStatsRequest.search(request.paramAsBoolean(\"search\", indicesStatsRequest.search()));\n        indicesStatsRequest.get(request.paramAsBoolean(\"get\", indicesStatsRequest.get()));\n        indicesStatsRequest.merge(request.paramAsBoolean(\"merge\", indicesStatsRequest.merge()));\n        indicesStatsRequest.refresh(request.paramAsBoolean(\"refresh\", indicesStatsRequest.refresh()));\n        indicesStatsRequest.flush(request.paramAsBoolean(\"flush\", indicesStatsRequest.flush()));\n        indicesStatsRequest.warmer(request.paramAsBoolean(\"warmer\", indicesStatsRequest.warmer()));\n\n        client.admin().indices().stats(indicesStatsRequest, new ActionListener<IndicesStats>() {\n            @Override\n            public void onResponse(IndicesStats response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n                    buildBroadcastShardsHeader(builder, response);\n                    response.toXContent(builder, request);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88727,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest();\n        indicesStatsRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            indicesStatsRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        boolean clear = request.paramAsBoolean(\"clear\", false);\n        if (clear) {\n            indicesStatsRequest.clear();\n        }\n        boolean all = request.paramAsBoolean(\"all\", false);\n        if (all) {\n            indicesStatsRequest.all();\n        }\n        indicesStatsRequest.indices(splitIndices(request.param(\"index\")));\n        indicesStatsRequest.types(splitTypes(request.param(\"types\")));\n        if (request.hasParam(\"groups\")) {\n            indicesStatsRequest.groups(Strings.splitStringByCommaToArray(request.param(\"groups\")));\n        }\n        indicesStatsRequest.docs(request.paramAsBoolean(\"docs\", indicesStatsRequest.docs()));\n        indicesStatsRequest.store(request.paramAsBoolean(\"store\", indicesStatsRequest.store()));\n        indicesStatsRequest.indexing(request.paramAsBoolean(\"indexing\", indicesStatsRequest.indexing()));\n        indicesStatsRequest.search(request.paramAsBoolean(\"search\", indicesStatsRequest.search()));\n        indicesStatsRequest.get(request.paramAsBoolean(\"get\", indicesStatsRequest.get()));\n        indicesStatsRequest.merge(request.paramAsBoolean(\"merge\", indicesStatsRequest.merge()));\n        indicesStatsRequest.refresh(request.paramAsBoolean(\"refresh\", indicesStatsRequest.refresh()));\n        indicesStatsRequest.flush(request.paramAsBoolean(\"flush\", indicesStatsRequest.flush()));\n        indicesStatsRequest.warmer(request.paramAsBoolean(\"warmer\", indicesStatsRequest.warmer()));\n\n        client.admin().indices().stats(indicesStatsRequest, new ActionListener<IndicesStats>() {\n            @Override\n            public void onResponse(IndicesStats response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n                    buildBroadcastShardsHeader(builder, response);\n                    response.toXContent(builder, request);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        IndicesStatusRequest indicesStatusRequest = new IndicesStatusRequest(splitIndices(request.param(\"index\")));\n        indicesStatusRequest.listenerThreaded(false);\n        indicesStatusRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        indicesStatusRequest.recovery(request.paramAsBoolean(\"recovery\", indicesStatusRequest.recovery()));\n        indicesStatusRequest.snapshot(request.paramAsBoolean(\"snapshot\", indicesStatusRequest.snapshot()));\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n        }\n        indicesStatusRequest.operationThreading(operationThreading);\n        client.admin().indices().status(indicesStatusRequest, new ActionListener<IndicesStatusResponse>() {\n            @Override\n            public void onResponse(IndicesStatusResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n                    buildBroadcastShardsHeader(builder, response);\n                    response.toXContent(builder, request, settingsFilter);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88728,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        IndicesStatusRequest indicesStatusRequest = new IndicesStatusRequest(splitIndices(request.param(\"index\")));\n        indicesStatusRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            indicesStatusRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        indicesStatusRequest.recovery(request.paramAsBoolean(\"recovery\", indicesStatusRequest.recovery()));\n        indicesStatusRequest.snapshot(request.paramAsBoolean(\"snapshot\", indicesStatusRequest.snapshot()));\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n        }\n        indicesStatusRequest.operationThreading(operationThreading);\n        client.admin().indices().status(indicesStatusRequest, new ActionListener<IndicesStatusResponse>() {\n            @Override\n            public void onResponse(IndicesStatusResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n                    buildBroadcastShardsHeader(builder, response);\n                    response.toXContent(builder, request, settingsFilter);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\n        multiSearchRequest.listenerThreaded(false);\n\n        String[] indices = RestActions.splitIndices(request.param(\"index\"));\n        String[] types = RestActions.splitTypes(request.param(\"type\"));\n        IgnoreIndices ignoreIndices = IgnoreIndices.fromString(request.param(\"ignore_indices\"));\n\n        try {\n            multiSearchRequest.add(request.content(), request.contentUnsafe(), indices, types, request.param(\"search_type\"), ignoreIndices);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.multiSearch(multiSearchRequest, new ActionListener<MultiSearchResponse>() {\n            @Override\n            public void onResponse(MultiSearchResponse response) {\n                try {\n                    XContentBuilder builder = restContentBuilder(request);\n                    builder.startObject();\n                    response.toXContent(builder, request);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88729,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\n        multiSearchRequest.listenerThreaded(false);\n\n        String[] indices = RestActions.splitIndices(request.param(\"index\"));\n        String[] types = RestActions.splitTypes(request.param(\"type\"));\n        IgnoreIndices ignoreIndices = null;\n        if (request.hasParam(\"ignore_indices\")) {\n            IgnoreIndices.fromString(request.param(\"ignore_indices\"));\n        }\n\n        try {\n            multiSearchRequest.add(request.content(), request.contentUnsafe(), indices, types, request.param(\"search_type\"), ignoreIndices);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.multiSearch(multiSearchRequest, new ActionListener<MultiSearchResponse>() {\n            @Override\n            public void onResponse(MultiSearchResponse response) {\n                try {\n                    XContentBuilder builder = restContentBuilder(request);\n                    builder.startObject();\n                    response.toXContent(builder, request);\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        OptimizeRequest optimizeRequest = new OptimizeRequest(RestActions.splitIndices(request.param(\"index\")));\n        optimizeRequest.listenerThreaded(false);\n        optimizeRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        try {\n            optimizeRequest.waitForMerge(request.paramAsBoolean(\"wait_for_merge\", optimizeRequest.waitForMerge()));\n            optimizeRequest.maxNumSegments(request.paramAsInt(\"max_num_segments\", optimizeRequest.maxNumSegments()));\n            optimizeRequest.onlyExpungeDeletes(request.paramAsBoolean(\"only_expunge_deletes\", optimizeRequest.onlyExpungeDeletes()));\n            optimizeRequest.flush(request.paramAsBoolean(\"flush\", optimizeRequest.flush()));\n            optimizeRequest.refresh(request.paramAsBoolean(\"refresh\", optimizeRequest.refresh()));\n\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n            }\n            optimizeRequest.operationThreading(operationThreading);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n        client.admin().indices().optimize(optimizeRequest, new ActionListener<OptimizeResponse>() {\n            @Override\n            public void onResponse(OptimizeResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88730,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        OptimizeRequest optimizeRequest = new OptimizeRequest(RestActions.splitIndices(request.param(\"index\")));\n        optimizeRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            optimizeRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        try {\n            optimizeRequest.waitForMerge(request.paramAsBoolean(\"wait_for_merge\", optimizeRequest.waitForMerge()));\n            optimizeRequest.maxNumSegments(request.paramAsInt(\"max_num_segments\", optimizeRequest.maxNumSegments()));\n            optimizeRequest.onlyExpungeDeletes(request.paramAsBoolean(\"only_expunge_deletes\", optimizeRequest.onlyExpungeDeletes()));\n            optimizeRequest.flush(request.paramAsBoolean(\"flush\", optimizeRequest.flush()));\n            optimizeRequest.refresh(request.paramAsBoolean(\"refresh\", optimizeRequest.refresh()));\n\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n            }\n            optimizeRequest.operationThreading(operationThreading);\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n        client.admin().indices().optimize(optimizeRequest, new ActionListener<OptimizeResponse>() {\n            @Override\n            public void onResponse(OptimizeResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        RefreshRequest refreshRequest = new RefreshRequest(RestActions.splitIndices(request.param(\"index\")));\n        refreshRequest.listenerThreaded(false);\n        refreshRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n        }\n        refreshRequest.operationThreading(operationThreading);\n        client.admin().indices().refresh(refreshRequest, new ActionListener<RefreshResponse>() {\n            @Override\n            public void onResponse(RefreshResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88731,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        RefreshRequest refreshRequest = new RefreshRequest(RestActions.splitIndices(request.param(\"index\")));\n        refreshRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            refreshRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n        if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n            // since we don't spawn, don't allow no_threads, but change it to a single thread\n            operationThreading = BroadcastOperationThreading.THREAD_PER_SHARD;\n        }\n        refreshRequest.operationThreading(operationThreading);\n        client.admin().indices().refresh(refreshRequest, new ActionListener<RefreshResponse>() {\n            @Override\n            public void onResponse(RefreshResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"ok\", true);\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private SearchRequest parseSearchRequest(RestRequest request) {\n        String[] indices = RestActions.splitIndices(request.param(\"index\"));\n        SearchRequest searchRequest = new SearchRequest(indices);\n        // get the content, and put it in the body\n        if (request.hasContent()) {\n            searchRequest.source(request.content(), request.contentUnsafe());\n        } else {\n            String source = request.param(\"source\");\n            if (source != null) {\n                searchRequest.source(source);\n            }\n        }\n        // add extra source based on the request parameters\n        searchRequest.extraSource(parseSearchSource(request));\n\n        searchRequest.searchType(request.param(\"search_type\"));\n\n        String scroll = request.param(\"scroll\");\n        if (scroll != null) {\n            searchRequest.scroll(new Scroll(parseTimeValue(scroll, null)));\n        }\n\n        searchRequest.types(RestActions.splitTypes(request.param(\"type\")));\n        searchRequest.queryHint(request.param(\"query_hint\"));\n        searchRequest.routing(request.param(\"routing\"));\n        searchRequest.preference(request.param(\"preference\"));\n        searchRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n\n        return searchRequest;\n    }","id":88732,"modified_method":"private SearchRequest parseSearchRequest(RestRequest request) {\n        String[] indices = RestActions.splitIndices(request.param(\"index\"));\n        SearchRequest searchRequest = new SearchRequest(indices);\n        // get the content, and put it in the body\n        if (request.hasContent()) {\n            searchRequest.source(request.content(), request.contentUnsafe());\n        } else {\n            String source = request.param(\"source\");\n            if (source != null) {\n                searchRequest.source(source);\n            }\n        }\n        // add extra source based on the request parameters\n        searchRequest.extraSource(parseSearchSource(request));\n\n        searchRequest.searchType(request.param(\"search_type\"));\n\n        String scroll = request.param(\"scroll\");\n        if (scroll != null) {\n            searchRequest.scroll(new Scroll(parseTimeValue(scroll, null)));\n        }\n\n        searchRequest.types(RestActions.splitTypes(request.param(\"type\")));\n        searchRequest.queryHint(request.param(\"query_hint\"));\n        searchRequest.routing(request.param(\"routing\"));\n        searchRequest.preference(request.param(\"preference\"));\n        if (request.hasParam(\"ignore_indices\")) {\n            searchRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n\n        return searchRequest;\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        ValidateQueryRequest validateQueryRequest = new ValidateQueryRequest(RestActions.splitIndices(request.param(\"index\")));\n        validateQueryRequest.listenerThreaded(false);\n        validateQueryRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        try {\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n            }\n            validateQueryRequest.operationThreading(operationThreading);\n            if (request.hasContent()) {\n                validateQueryRequest.query(request.content(), request.contentUnsafe());\n            } else {\n                String source = request.param(\"source\");\n                if (source != null) {\n                    validateQueryRequest.query(source);\n                } else {\n                    BytesReference querySource = RestActions.parseQuerySource(request);\n                    if (querySource != null) {\n                        validateQueryRequest.query(querySource, false);\n                    }\n                }\n            }\n            validateQueryRequest.types(splitTypes(request.param(\"type\")));\n            if (request.paramAsBoolean(\"explain\", false)) {\n                validateQueryRequest.explain(true);\n            } else {\n                validateQueryRequest.explain(false);\n            }\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.admin().indices().validateQuery(validateQueryRequest, new ActionListener<ValidateQueryResponse>() {\n            @Override\n            public void onResponse(ValidateQueryResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"valid\", response.valid());\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    if (response.queryExplanations() != null && !response.queryExplanations().isEmpty()) {\n                        builder.startArray(\"explanations\");\n                        for (QueryExplanation explanation : response.queryExplanations()) {\n                            builder.startObject();\n                            if (explanation.index() != null) {\n                                builder.field(\"index\", explanation.index(), XContentBuilder.FieldCaseConversion.NONE);\n                            }\n                            builder.field(\"valid\", explanation.valid());\n                            if (explanation.error() != null) {\n                                builder.field(\"error\", explanation.error());\n                            }\n                            if (explanation.explanation() != null) {\n                                builder.field(\"explanation\", explanation.explanation());\n                            }\n                            builder.endObject();\n                        }\n                        builder.endArray();\n                    }\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":88733,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        ValidateQueryRequest validateQueryRequest = new ValidateQueryRequest(RestActions.splitIndices(request.param(\"index\")));\n        validateQueryRequest.listenerThreaded(false);\n        if (request.hasParam(\"ignore_indices\")) {\n            validateQueryRequest.ignoreIndices(IgnoreIndices.fromString(request.param(\"ignore_indices\")));\n        }\n        try {\n            BroadcastOperationThreading operationThreading = BroadcastOperationThreading.fromString(request.param(\"operation_threading\"), BroadcastOperationThreading.SINGLE_THREAD);\n            if (operationThreading == BroadcastOperationThreading.NO_THREADS) {\n                // since we don't spawn, don't allow no_threads, but change it to a single thread\n                operationThreading = BroadcastOperationThreading.SINGLE_THREAD;\n            }\n            validateQueryRequest.operationThreading(operationThreading);\n            if (request.hasContent()) {\n                validateQueryRequest.query(request.content(), request.contentUnsafe());\n            } else {\n                String source = request.param(\"source\");\n                if (source != null) {\n                    validateQueryRequest.query(source);\n                } else {\n                    BytesReference querySource = RestActions.parseQuerySource(request);\n                    if (querySource != null) {\n                        validateQueryRequest.query(querySource, false);\n                    }\n                }\n            }\n            validateQueryRequest.types(splitTypes(request.param(\"type\")));\n            if (request.paramAsBoolean(\"explain\", false)) {\n                validateQueryRequest.explain(true);\n            } else {\n                validateQueryRequest.explain(false);\n            }\n        } catch (Exception e) {\n            try {\n                XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                channel.sendResponse(new XContentRestResponse(request, BAD_REQUEST, builder.startObject().field(\"error\", e.getMessage()).endObject()));\n            } catch (IOException e1) {\n                logger.error(\"Failed to send failure response\", e1);\n            }\n            return;\n        }\n\n        client.admin().indices().validateQuery(validateQueryRequest, new ActionListener<ValidateQueryResponse>() {\n            @Override\n            public void onResponse(ValidateQueryResponse response) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"valid\", response.valid());\n\n                    buildBroadcastShardsHeader(builder, response);\n\n                    if (response.queryExplanations() != null && !response.queryExplanations().isEmpty()) {\n                        builder.startArray(\"explanations\");\n                        for (QueryExplanation explanation : response.queryExplanations()) {\n                            builder.startObject();\n                            if (explanation.index() != null) {\n                                builder.field(\"index\", explanation.index(), XContentBuilder.FieldCaseConversion.NONE);\n                            }\n                            builder.field(\"valid\", explanation.valid());\n                            if (explanation.error() != null) {\n                                builder.field(\"error\", explanation.error());\n                            }\n                            if (explanation.explanation() != null) {\n                                builder.field(\"explanation\", explanation.explanation());\n                            }\n                            builder.endObject();\n                        }\n                        builder.endArray();\n                    }\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","commit_id":"33e7d769cad8720c8c5d69a07c20a27baa4bab0b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"void dispose() {\r\n\t\trun = false;\r\n\t\ttry {\r\n\t\t\tthread.join();\r\n\t\t} catch (InterruptedException e) {\r\n\t\t}\r\n\t}","id":88734,"modified_method":"void dispose() {\r\n\t\trun = false;\r\n\t\ttry {\r\n\t\t\tif(thread != null)\r\n\t\t\t\tthread.join();\r\n\t\t\tif(line != null)\r\n\t\t\t\tline.close();\t\t\t\r\n\t\t} \r\n\t\tcatch (InterruptedException e) {\r\n\t\t}\r\n\t}","commit_id":"fae7683b0f4ab96e6c3fd95ee2d97bc51bc27693","url":"https://github.com/libgdx/libgdx"},{"original_method":"void dispose ( ) {\r\n\t\trun = false;\r\n\t\ttry {\r\n\t\t\tthread.join();\r\n\t\t} catch (InterruptedException e) {\r\n\t\t}\r\n\t}","id":88735,"modified_method":"void dispose ( ) {\r\n\t\trun = false;\r\n\t\ttry {\r\n\t\t\tif(thread != null)\r\n\t\t\t\tthread.join();\r\n\t\t\tif(line != null)\r\n\t\t\t\tline.close();\r\n\t\t} catch (InterruptedException e) {\r\n\t\t}\r\n\t}","commit_id":"fae7683b0f4ab96e6c3fd95ee2d97bc51bc27693","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88736,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"907498b0b6f47d134b8968d5edb006e527e983b9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88737,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"907498b0b6f47d134b8968d5edb006e527e983b9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88738,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"907498b0b6f47d134b8968d5edb006e527e983b9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88739,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"907498b0b6f47d134b8968d5edb006e527e983b9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88740,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"907498b0b6f47d134b8968d5edb006e527e983b9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Nullable\n  @Override\n  public String getName() {\n    return String.format(\"(%s) -> %s\",\n                         StringUtil.join(myParameterTypes,\n                                         new Function<PyType, String>() {\n                                           @Override\n                                           public String fun(PyType type) {\n                                             return type != null ? type.getName() : PyNames.UNKNOWN_TYPE;\n                                           }\n                                         },\n                                         \", \"),\n                         myReturnType != null ? myReturnType.getName() : PyNames.UNKNOWN_TYPE);\n  }","id":88741,"modified_method":"@Nullable\n  @Override\n  public String getName() {\n    return String.format(\"(%s) -> %s\",\n                         myParameterTypes != null ?\n                         StringUtil.join(myParameterTypes,\n                                         new Function<PyType, String>() {\n                                           @Override\n                                           public String fun(PyType type) {\n                                             return type != null ? type.getName() : PyNames.UNKNOWN_TYPE;\n                                           }\n                                         },\n                                         \", \") :\n                         \"...\",\n                         myReturnType != null ? myReturnType.getName() : PyNames.UNKNOWN_TYPE);\n  }","commit_id":"0d29b7b0e8c168715258b0ba094e871a5a8c8ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void collectGenerics(@Nullable PyType type, @NotNull TypeEvalContext context, @NotNull Set<PyGenericType> collected,\n                                      @NotNull Set<PyType> visited) {\n    if (visited.contains(type)) {\n      return;\n    }\n    visited.add(type);\n    if (type instanceof PyGenericType) {\n      collected.add((PyGenericType)type);\n    }\n    else if (type instanceof PyUnionType) {\n      final PyUnionType union = (PyUnionType)type;\n      for (PyType t : union.getMembers()) {\n        collectGenerics(t, context, collected, visited);\n      }\n    }\n    else if (type instanceof PyCollectionType) {\n      final PyCollectionType collection = (PyCollectionType)type;\n      collectGenerics(collection.getElementType(context), context, collected, visited);\n    }\n    else if (type instanceof PyTupleType) {\n      final PyTupleType tuple = (PyTupleType)type;\n      final int n = tuple.getElementCount();\n      for (int i = 0; i < n; i++) {\n        collectGenerics(tuple.getElementType(i), context, collected, visited);\n      }\n    }\n  }","id":88742,"modified_method":"private static void collectGenerics(@Nullable PyType type, @NotNull TypeEvalContext context, @NotNull Set<PyGenericType> collected,\n                                      @NotNull Set<PyType> visited) {\n    if (visited.contains(type)) {\n      return;\n    }\n    visited.add(type);\n    if (type instanceof PyGenericType) {\n      collected.add((PyGenericType)type);\n    }\n    else if (type instanceof PyUnionType) {\n      final PyUnionType union = (PyUnionType)type;\n      for (PyType t : union.getMembers()) {\n        collectGenerics(t, context, collected, visited);\n      }\n    }\n    else if (type instanceof PyCollectionType) {\n      final PyCollectionType collection = (PyCollectionType)type;\n      collectGenerics(collection.getElementType(context), context, collected, visited);\n    }\n    else if (type instanceof PyTupleType) {\n      final PyTupleType tuple = (PyTupleType)type;\n      final int n = tuple.getElementCount();\n      for (int i = 0; i < n; i++) {\n        collectGenerics(tuple.getElementType(i), context, collected, visited);\n      }\n    }\n    else if (type instanceof PyCallableType) {\n      final PyCallableType callable = (PyCallableType)type;\n      final List<PyType> parameters = callable.getParameterTypes(context);\n      if (parameters != null) {\n        for (PyType parameter : parameters) {\n          collectGenerics(parameter, context, collected, visited);\n        }\n      }\n      collectGenerics(callable.getCallType(context, null), context, collected, visited);\n    }\n  }","commit_id":"0d29b7b0e8c168715258b0ba094e871a5a8c8ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PyType substitute(@Nullable PyType type, @NotNull Map<PyGenericType, PyType> substitutions,\n                                  @NotNull TypeEvalContext context) {\n    if (hasGenerics(type, context)) {\n      if (type instanceof PyGenericType) {\n        return substitutions.get((PyGenericType)type);\n      }\n      else if (type instanceof PyUnionType) {\n        final PyUnionType union = (PyUnionType)type;\n        final List<PyType> results = new ArrayList<PyType>();\n        for (PyType t : union.getMembers()) {\n          final PyType subst = substitute(t, substitutions, context);\n          results.add(subst);\n        }\n        return PyUnionType.union(results);\n      }\n      else if (type instanceof PyCollectionTypeImpl) {\n        final PyCollectionTypeImpl collection = (PyCollectionTypeImpl)type;\n        final PyType elem = collection.getElementType(context);\n        final PyType subst = substitute(elem, substitutions, context);\n        return new PyCollectionTypeImpl(collection.getPyClass(), collection.isDefinition(), subst);\n      }\n      else if (type instanceof PyTupleType) {\n        final PyTupleType tuple = (PyTupleType)type;\n        final int n = tuple.getElementCount();\n        final List<PyType> results = new ArrayList<PyType>();\n        for (int i = 0; i < n; i++) {\n          final PyType subst = substitute(tuple.getElementType(i), substitutions, context);\n          results.add(subst);\n        }\n        return new PyTupleType((PyTupleType)type, results.toArray(new PyType[results.size()]));\n      }\n    }\n    return type;\n  }","id":88743,"modified_method":"@Nullable\n  public static PyType substitute(@Nullable PyType type, @NotNull Map<PyGenericType, PyType> substitutions,\n                                  @NotNull TypeEvalContext context) {\n    if (hasGenerics(type, context)) {\n      if (type instanceof PyGenericType) {\n        return substitutions.get((PyGenericType)type);\n      }\n      else if (type instanceof PyUnionType) {\n        final PyUnionType union = (PyUnionType)type;\n        final List<PyType> results = new ArrayList<PyType>();\n        for (PyType t : union.getMembers()) {\n          final PyType subst = substitute(t, substitutions, context);\n          results.add(subst);\n        }\n        return PyUnionType.union(results);\n      }\n      else if (type instanceof PyCollectionTypeImpl) {\n        final PyCollectionTypeImpl collection = (PyCollectionTypeImpl)type;\n        final PyType elem = collection.getElementType(context);\n        final PyType subst = substitute(elem, substitutions, context);\n        return new PyCollectionTypeImpl(collection.getPyClass(), collection.isDefinition(), subst);\n      }\n      else if (type instanceof PyTupleType) {\n        final PyTupleType tuple = (PyTupleType)type;\n        final int n = tuple.getElementCount();\n        final List<PyType> results = new ArrayList<PyType>();\n        for (int i = 0; i < n; i++) {\n          final PyType subst = substitute(tuple.getElementType(i), substitutions, context);\n          results.add(subst);\n        }\n        return new PyTupleType((PyTupleType)type, results.toArray(new PyType[results.size()]));\n      }\n      else if (type instanceof PyCallableType) {\n        final PyCallableType callable = (PyCallableType)type;\n        List<PyType> substParams = null;\n        final List<PyType> parameters = callable.getParameterTypes(context);\n        if (parameters != null) {\n          substParams = new ArrayList<PyType>();\n          for (PyType parameter : parameters) {\n            substParams.add(substitute(parameter, substitutions, context));\n          }\n        }\n        final PyType substResult = substitute(callable.getCallType(context, null), substitutions, context);\n        return new PyCallableTypeImpl(substParams, substResult);\n      }\n    }\n    return type;\n  }","commit_id":"0d29b7b0e8c168715258b0ba094e871a5a8c8ec0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88744,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"75f069ca61a070937f5208098c27da1380294f85","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88745,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"75f069ca61a070937f5208098c27da1380294f85","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88746,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"75f069ca61a070937f5208098c27da1380294f85","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88747,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"75f069ca61a070937f5208098c27da1380294f85","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88748,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"75f069ca61a070937f5208098c27da1380294f85","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88749,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"f5246ec20a8e76f59dd07a263a209da17ae52982","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88750,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"f5246ec20a8e76f59dd07a263a209da17ae52982","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88751,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"f5246ec20a8e76f59dd07a263a209da17ae52982","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88752,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"f5246ec20a8e76f59dd07a263a209da17ae52982","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88753,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"f5246ec20a8e76f59dd07a263a209da17ae52982","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public WebFrame(File file, int width) {\n    //setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n\n    String[] lines = PApplet.loadStrings(file);\n    String content = PApplet.join(lines, \"\\n\");\n\n    int high = getContentHeight(width, content);\n    editorPane = new JEditorPane(\"text/html\", content);\n    editorPane.setEditable(false);\n    editorPane.setPreferredSize(new Dimension(width, high));\n    getContentPane().add(editorPane);\n\n    Toolkit.registerWindowCloseKeys(getRootPane(), new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        handleClose();\n      }\n    });\n\n    editorKit = (HTMLEditorKit) editorPane.getEditorKit();\n    editorKit.setAutoFormSubmission(false);\n\n    Object title = editorPane.getDocument().getProperty(\"title\");\n    if (title instanceof String) {\n      setTitle((String) title);\n    }\n\n    editorPane.addHyperlinkListener(new HyperlinkListener() {\n      @Override\n      public void hyperlinkUpdate(HyperlinkEvent e) {\n        //System.out.println(e);\n        if (e instanceof FormSubmitEvent) {\n          //System.out.println(\"got submit event\");\n          String result = ((FormSubmitEvent) e).getData();\n          StringDict dict = new StringDict();\n          String[] pairs = result.split(\"&\");\n          for (String pair : pairs) {\n            String[] pieces = pair.split(\"=\");\n            String attr = PApplet.urlDecode(pieces[0]);\n            String valu = PApplet.urlDecode(pieces[1]);\n            dict.set(attr, valu);\n          }\n          //dict.print();\n          handleSubmit(dict);\n\n        } else if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n          //System.out.println(\"clicked \" + e.getURL());\n          handleLink(e.getURL().toExternalForm());\n        }\n      }\n    });\n    pack();\n    setLocationRelativeTo(null);\n    //setVisible(true);\n  }","id":88754,"modified_method":"public WebFrame(File file, int width) {\n    //setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);\n\n    String content = \"Could not load \" + file.getAbsolutePath();\n    if (file != null) {\n      String[] lines = PApplet.loadStrings(file);\n      content = PApplet.join(lines, \"\\n\");\n    }\n\n    int high = getContentHeight(width, content);\n    editorPane = new JEditorPane(\"text/html\", content);\n    editorPane.setEditable(false);\n    editorPane.setPreferredSize(new Dimension(width, high));\n    getContentPane().add(editorPane);\n\n    Toolkit.registerWindowCloseKeys(getRootPane(), new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        handleClose();\n      }\n    });\n\n    editorKit = (HTMLEditorKit) editorPane.getEditorKit();\n    editorKit.setAutoFormSubmission(false);\n\n    Object title = editorPane.getDocument().getProperty(\"title\");\n    if (title instanceof String) {\n      setTitle((String) title);\n    }\n\n    editorPane.addHyperlinkListener(new HyperlinkListener() {\n      @Override\n      public void hyperlinkUpdate(HyperlinkEvent e) {\n        //System.out.println(e);\n        if (e instanceof FormSubmitEvent) {\n          //System.out.println(\"got submit event\");\n          String result = ((FormSubmitEvent) e).getData();\n          StringDict dict = new StringDict();\n          String[] pairs = result.split(\"&\");\n          for (String pair : pairs) {\n            String[] pieces = pair.split(\"=\");\n            String attr = PApplet.urlDecode(pieces[0]);\n            String valu = PApplet.urlDecode(pieces[1]);\n            dict.set(attr, valu);\n          }\n          //dict.print();\n          handleSubmit(dict);\n\n        } else if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n          //System.out.println(\"clicked \" + e.getURL());\n          handleLink(e.getURL().toExternalForm());\n        }\n      }\n    });\n    pack();\n    setLocationRelativeTo(null);\n    //setVisible(true);\n  }","commit_id":"f9c248f0e06a53ffd35b5f5f9484cc7072cd2526","url":"https://github.com/processing/processing"},{"original_method":"static private File getIndexFile(boolean sketchbook) {\n    String filename =\n      \"welcome/\" + (sketchbook ? \"sketchbook.html\" : \"generic.html\");\n    // eventually this will be correct\n    //File indexFile = Base.getLibFile(filename);\n    // version when running from command line for editing\n    File htmlFile = new File(\"../build/shared/lib/\" + filename);\n    if (!htmlFile.exists()) {\n      // processing/build/macosx/work/Processing.app/Contents/Java\n      // version for Scott to use for OS X debugging\n      htmlFile = Base.getContentFile(\"../../../../../shared/lib/\" + filename);\n    }\n    return htmlFile;\n  }","id":88755,"modified_method":"static private File getIndexFile(boolean sketchbook) {\n    String filename =\n      \"welcome/\" + (sketchbook ? \"sketchbook.html\" : \"generic.html\");\n\n    // version when running from command line for editing\n    File htmlFile = new File(\"../build/shared/lib/\" + filename);\n    if (htmlFile.exists()) {\n      return htmlFile;\n    }\n    // processing/build/macosx/work/Processing.app/Contents/Java\n    // version for Scott to use for OS X debugging\n    htmlFile = Base.getContentFile(\"../../../../../shared/lib/\" + filename);\n    if (htmlFile.exists()) {\n      return htmlFile;\n    }\n\n    try {\n      return Base.getLibFile(filename);\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    }\n  }","commit_id":"f9c248f0e06a53ffd35b5f5f9484cc7072cd2526","url":"https://github.com/processing/processing"},{"original_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping JobHistoryEventHandler. \"\n        + \"Size of the outstanding queue size is \" + eventQueue.size());\n    stopped = true;\n    //do not interrupt while event handling is in progress\n    synchronized(lock) {\n      eventHandlingThread.interrupt();\n    }\n\n    try {\n      eventHandlingThread.join();\n    } catch (InterruptedException ie) {\n      LOG.info(\"Interruped Exception while stopping\", ie);\n    }\n    //write all the events remaining in queue\n    Iterator<JobHistoryEvent> it = eventQueue.iterator();\n    while(it.hasNext()) {\n      JobHistoryEvent ev = it.next();\n      LOG.info(\"In stop, writing event \" + ev.getType());\n      handleEvent(ev);\n    }\n    \n    //close all file handles\n    for (MetaInfo mi : fileMap.values()) {\n      try {\n        mi.closeWriter();\n      } catch (IOException e) {\n        LOG.info(\"Exception while closing file \" + e.getMessage());\n      }\n    }\n    LOG.info(\"Stopped JobHistoryEventHandler. super.stop()\");\n    super.stop();\n  }","id":88756,"modified_method":"@Override\n  public void stop() {\n    LOG.info(\"Stopping JobHistoryEventHandler. \"\n        + \"Size of the outstanding queue size is \" + eventQueue.size());\n    stopped = true;\n    //do not interrupt while event handling is in progress\n    synchronized(lock) {\n      if (eventHandlingThread != null)\n        eventHandlingThread.interrupt();\n    }\n\n    try {\n      if (eventHandlingThread != null)\n        eventHandlingThread.join();\n    } catch (InterruptedException ie) {\n      LOG.info(\"Interruped Exception while stopping\", ie);\n    }\n\n    // Cancel all timers - so that they aren't invoked during or after\n    // the metaInfo object is wrapped up.\n    for (MetaInfo mi : fileMap.values()) {\n      try {\n        mi.shutDownTimer();\n      } catch (IOException e) {\n        LOG.info(\"Exception while cancelling delayed flush timer. \"\n            + \"Likely caused by a failed flush \" + e.getMessage());\n      }\n    }\n\n    //write all the events remaining in queue\n    Iterator<JobHistoryEvent> it = eventQueue.iterator();\n    while(it.hasNext()) {\n      JobHistoryEvent ev = it.next();\n      LOG.info(\"In stop, writing event \" + ev.getType());\n      handleEvent(ev);\n    }\n    \n    //close all file handles\n    for (MetaInfo mi : fileMap.values()) {\n      try {\n        mi.closeWriter();\n      } catch (IOException e) {\n        LOG.info(\"Exception while closing file \" + e.getMessage());\n      }\n    }\n    LOG.info(\"Stopped JobHistoryEventHandler. super.stop()\");\n    super.stop();\n  }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"MetaInfo(Path historyFile, Path conf, EventWriter writer, \n             String user, String jobName, JobId jobId) {\n      this.historyFile = historyFile;\n      this.confFile = conf;\n      this.writer = writer;\n      this.jobIndexInfo = new JobIndexInfo(-1, -1, user, jobName, jobId, -1, -1,\n          null);\n      this.jobSummary = new JobSummary();\n    }","id":88757,"modified_method":"MetaInfo(Path historyFile, Path conf, EventWriter writer, String user,\n        String jobName, JobId jobId) {\n      this.historyFile = historyFile;\n      this.confFile = conf;\n      this.writer = writer;\n      this.jobIndexInfo =\n          new JobIndexInfo(-1, -1, user, jobName, jobId, -1, -1, null);\n      this.jobSummary = new JobSummary();\n      this.flushTimer = new Timer(\"FlushTimer\", true);\n    }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"void writeEvent(HistoryEvent event) throws IOException {\n      synchronized (lock) {\n      if (writer != null) {\n        writer.write(event);\n        writer.flush();\n      }\n    }\n  }","id":88758,"modified_method":"void writeEvent(HistoryEvent event) throws IOException {\n      synchronized (lock) {\n        if (writer != null) {\n          writer.write(event);\n          processEventForFlush(event);\n          maybeFlush(event);\n        }\n      }\n    }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void handle(JobHistoryEvent event) {\n    try {\n      eventQueue.put(event);\n    } catch (InterruptedException e) {\n      throw new YarnException(e);\n    }\n  }","id":88759,"modified_method":"@Override\n  public void handle(JobHistoryEvent event) {\n    try {\n      if (isJobCompletionEvent(event.getHistoryEvent())) {\n        // When the job is complete, flush slower but write faster.\n        maxUnflushedCompletionEvents =\n            maxUnflushedCompletionEvents * postJobCompletionMultiplier;\n      }\n\n      eventQueue.put(event);\n    } catch (InterruptedException e) {\n      throw new YarnException(e);\n    }\n  }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"private void moveToDoneNow(Path fromPath, Path toPath) throws IOException {\n    // check if path exists, in case of retries it may not exist\n    if (stagingDirFS.exists(fromPath)) {\n      LOG.info(\"Moving \" + fromPath.toString() + \" to \" + toPath.toString());\n      // TODO temporarily removing the existing dst\n      if (doneDirFS.exists(toPath)) {\n        doneDirFS.delete(toPath, true);\n      }\n      boolean copied = FileUtil.copy(stagingDirFS, fromPath, doneDirFS, toPath,\n          false, conf);\n\n      if (copied)\n        LOG.info(\"Copied to done location: \" + toPath);\n      else \n          LOG.info(\"copy failed\");\n      doneDirFS.setPermission(toPath, new FsPermission(\n          JobHistoryUtils.HISTORY_INTERMEDIATE_FILE_PERMISSIONS));\n      \n      stagingDirFS.delete(fromPath, false);\n    }\n    }","id":88760,"modified_method":"private void moveToDoneNow(Path fromPath, Path toPath) throws IOException {\n    // check if path exists, in case of retries it may not exist\n    if (stagingDirFS.exists(fromPath)) {\n      LOG.info(\"Moving \" + fromPath.toString() + \" to \" + toPath.toString());\n      // TODO temporarily removing the existing dst\n      if (doneDirFS.exists(toPath)) {\n        doneDirFS.delete(toPath, true);\n      }\n      boolean copied = FileUtil.copy(stagingDirFS, fromPath, doneDirFS, toPath,\n          false, getConfig());\n\n      if (copied)\n        LOG.info(\"Copied to done location: \" + toPath);\n      else \n          LOG.info(\"copy failed\");\n      doneDirFS.setPermission(toPath, new FsPermission(\n          JobHistoryUtils.HISTORY_INTERMEDIATE_FILE_PERMISSIONS));\n      \n      stagingDirFS.delete(fromPath, false);\n    }\n    }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void init(Configuration conf) {\n\n    this.conf = conf;\n\n    String stagingDirStr = null;\n    String doneDirStr = null;\n    String userDoneDirStr = null;\n    try {\n      stagingDirStr = JobHistoryUtils.getConfiguredHistoryStagingDirPrefix(conf);\n      doneDirStr =\n          JobHistoryUtils.getConfiguredHistoryIntermediateDoneDirPrefix(conf);\n      userDoneDirStr =\n          JobHistoryUtils.getHistoryIntermediateDoneDirForUser(conf);\n    } catch (IOException e) {\n      LOG.error(\"Failed while getting the configured log directories\", e);\n      throw new YarnException(e);\n    }\n\n    //Check for the existence of the history staging dir. Maybe create it. \n    try {\n      stagingDirPath =\n          FileSystem.get(conf).makeQualified(new Path(stagingDirStr));\n      stagingDirFS = FileSystem.get(stagingDirPath.toUri(), conf);\n      mkdir(stagingDirFS, stagingDirPath, new FsPermission(\n          JobHistoryUtils.HISTORY_STAGING_DIR_PERMISSIONS));\n    } catch (IOException e) {\n      LOG.error(\"Failed while checking for/creating  history staging path: [\"\n          + stagingDirPath + \"]\", e);\n      throw new YarnException(e);\n    }\n\n    //Check for the existence of intermediate done dir.\n    Path doneDirPath = null;\n    try {\n      doneDirPath = FileSystem.get(conf).makeQualified(new Path(doneDirStr));\n      doneDirFS = FileSystem.get(doneDirPath.toUri(), conf);\n      // This directory will be in a common location, or this may be a cluster\n      // meant for a single user. Creating based on the conf. Should ideally be\n      // created by the JobHistoryServer or as part of deployment.\n      if (!doneDirFS.exists(doneDirPath)) {\n      if (JobHistoryUtils.shouldCreateNonUserDirectory(conf)) {\n        LOG.info(\"Creating intermediate history logDir: [\"\n            + doneDirPath\n            + \"] + based on conf. Should ideally be created by the JobHistoryServer: \"\n            + MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR);\n          mkdir(\n              doneDirFS,\n              doneDirPath,\n              new FsPermission(\n            JobHistoryUtils.HISTORY_INTERMEDIATE_DONE_DIR_PERMISSIONS\n                .toShort()));\n          // TODO Temporary toShort till new FsPermission(FsPermissions)\n          // respects\n        // sticky\n      } else {\n          String message = \"Not creating intermediate history logDir: [\"\n                + doneDirPath\n                + \"] based on conf: \"\n                + MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR\n                + \". Either set to true or pre-create this directory with\" +\n                \" appropriate permissions\";\n        LOG.error(message);\n        throw new YarnException(message);\n      }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Failed checking for the existance of history intermediate \" +\n      \t\t\"done directory: [\" + doneDirPath + \"]\");\n      throw new YarnException(e);\n    }\n\n    //Check/create user directory under intermediate done dir.\n    try {\n      doneDirPrefixPath =\n          FileSystem.get(conf).makeQualified(new Path(userDoneDirStr));\n      mkdir(doneDirFS, doneDirPrefixPath, new FsPermission(\n          JobHistoryUtils.HISTORY_INTERMEDIATE_USER_DIR_PERMISSIONS));\n    } catch (IOException e) {\n      LOG.error(\"Error creating user intermediate history done directory: [ \"\n          + doneDirPrefixPath + \"]\", e);\n      throw new YarnException(e);\n    }\n\n    super.init(conf);\n  }","id":88761,"modified_method":"@Override\n  public void init(Configuration conf) {\n\n    String stagingDirStr = null;\n    String doneDirStr = null;\n    String userDoneDirStr = null;\n    try {\n      stagingDirStr = JobHistoryUtils.getConfiguredHistoryStagingDirPrefix(conf);\n      doneDirStr =\n          JobHistoryUtils.getConfiguredHistoryIntermediateDoneDirPrefix(conf);\n      userDoneDirStr =\n          JobHistoryUtils.getHistoryIntermediateDoneDirForUser(conf);\n    } catch (IOException e) {\n      LOG.error(\"Failed while getting the configured log directories\", e);\n      throw new YarnException(e);\n    }\n\n    //Check for the existence of the history staging dir. Maybe create it. \n    try {\n      stagingDirPath =\n          FileSystem.get(conf).makeQualified(new Path(stagingDirStr));\n      stagingDirFS = FileSystem.get(stagingDirPath.toUri(), conf);\n      mkdir(stagingDirFS, stagingDirPath, new FsPermission(\n          JobHistoryUtils.HISTORY_STAGING_DIR_PERMISSIONS));\n    } catch (IOException e) {\n      LOG.error(\"Failed while checking for/creating  history staging path: [\"\n          + stagingDirPath + \"]\", e);\n      throw new YarnException(e);\n    }\n\n    //Check for the existence of intermediate done dir.\n    Path doneDirPath = null;\n    try {\n      doneDirPath = FileSystem.get(conf).makeQualified(new Path(doneDirStr));\n      doneDirFS = FileSystem.get(doneDirPath.toUri(), conf);\n      // This directory will be in a common location, or this may be a cluster\n      // meant for a single user. Creating based on the conf. Should ideally be\n      // created by the JobHistoryServer or as part of deployment.\n      if (!doneDirFS.exists(doneDirPath)) {\n      if (JobHistoryUtils.shouldCreateNonUserDirectory(conf)) {\n        LOG.info(\"Creating intermediate history logDir: [\"\n            + doneDirPath\n            + \"] + based on conf. Should ideally be created by the JobHistoryServer: \"\n            + MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR);\n          mkdir(\n              doneDirFS,\n              doneDirPath,\n              new FsPermission(\n            JobHistoryUtils.HISTORY_INTERMEDIATE_DONE_DIR_PERMISSIONS\n                .toShort()));\n          // TODO Temporary toShort till new FsPermission(FsPermissions)\n          // respects\n        // sticky\n      } else {\n          String message = \"Not creating intermediate history logDir: [\"\n                + doneDirPath\n                + \"] based on conf: \"\n                + MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR\n                + \". Either set to true or pre-create this directory with\" +\n                \" appropriate permissions\";\n        LOG.error(message);\n        throw new YarnException(message);\n      }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Failed checking for the existance of history intermediate \" +\n      \t\t\"done directory: [\" + doneDirPath + \"]\");\n      throw new YarnException(e);\n    }\n\n    //Check/create user directory under intermediate done dir.\n    try {\n      doneDirPrefixPath =\n          FileSystem.get(conf).makeQualified(new Path(userDoneDirStr));\n      mkdir(doneDirFS, doneDirPrefixPath, new FsPermission(\n          JobHistoryUtils.HISTORY_INTERMEDIATE_USER_DIR_PERMISSIONS));\n    } catch (IOException e) {\n      LOG.error(\"Error creating user intermediate history done directory: [ \"\n          + doneDirPrefixPath + \"]\", e);\n      throw new YarnException(e);\n    }\n\n    // Maximum number of unflushed completion-events that can stay in the queue\n    // before flush kicks in.\n    maxUnflushedCompletionEvents =\n        conf.getInt(MRJobConfig.MR_AM_HISTORY_MAX_UNFLUSHED_COMPLETE_EVENTS,\n            MRJobConfig.DEFAULT_MR_AM_HISTORY_MAX_UNFLUSHED_COMPLETE_EVENTS);\n    // We want to cut down flushes after job completes so as to write quicker,\n    // so we increase maxUnflushedEvents post Job completion by using the\n    // following multiplier.\n    postJobCompletionMultiplier =\n        conf.getInt(\n            MRJobConfig.MR_AM_HISTORY_JOB_COMPLETE_UNFLUSHED_MULTIPLIER,\n            MRJobConfig.DEFAULT_MR_AM_HISTORY_JOB_COMPLETE_UNFLUSHED_MULTIPLIER);\n    // Max time until which flush doesn't take place.\n    flushTimeout =\n        conf.getLong(MRJobConfig.MR_AM_HISTORY_COMPLETE_EVENT_FLUSH_TIMEOUT_MS,\n            MRJobConfig.DEFAULT_MR_AM_HISTORY_COMPLETE_EVENT_FLUSH_TIMEOUT_MS);\n    minQueueSizeForBatchingFlushes =\n        conf.getInt(\n            MRJobConfig.MR_AM_HISTORY_USE_BATCHED_FLUSH_QUEUE_SIZE_THRESHOLD,\n            MRJobConfig.DEFAULT_MR_AM_HISTORY_USE_BATCHED_FLUSH_QUEUE_SIZE_THRESHOLD);\n    \n    super.init(conf);\n  }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Create an event writer for the Job represented by the jobID.\n   * Writes out the job configuration to the log directory.\n   * This should be the first call to history for a job\n   * \n   * @param jobId the jobId.\n   * @throws IOException\n   */\n  protected void setupEventWriter(JobId jobId)\n      throws IOException {\n    if (stagingDirPath == null) {\n      LOG.error(\"Log Directory is null, returning\");\n      throw new IOException(\"Missing Log Directory for History\");\n    }\n\n    MetaInfo oldFi = fileMap.get(jobId);\n    Configuration conf = getConfig();\n\n    // TODO Ideally this should be written out to the job dir\n    // (.staging/jobid/files - RecoveryService will need to be patched)\n    Path historyFile = JobHistoryUtils.getStagingJobHistoryFile(\n        stagingDirPath, jobId, startCount);\n    String user = UserGroupInformation.getCurrentUser().getShortUserName();\n    if (user == null) {\n      throw new IOException(\n          \"User is null while setting up jobhistory eventwriter\");\n    }\n\n    String jobName = context.getJob(jobId).getName();\n    EventWriter writer = (oldFi == null) ? null : oldFi.writer;\n \n    Path logDirConfPath =\n        JobHistoryUtils.getStagingConfFile(stagingDirPath, jobId, startCount);\n    if (writer == null) {\n      try {\n        FSDataOutputStream out = stagingDirFS.create(historyFile, true);\n        writer = new EventWriter(out);\n        LOG.info(\"Event Writer setup for JobId: \" + jobId + \", File: \"\n            + historyFile);\n      } catch (IOException ioe) {\n        LOG.info(\"Could not create log file: [\" + historyFile + \"] + for job \"\n            + \"[\" + jobName + \"]\");\n        throw ioe;\n      }\n      \n      //Write out conf only if the writer isn't already setup.\n      if (conf != null) {\n        // TODO Ideally this should be written out to the job dir\n        // (.staging/jobid/files - RecoveryService will need to be patched)\n        FSDataOutputStream jobFileOut = null;\n        try {\n          if (logDirConfPath != null) {\n            jobFileOut = stagingDirFS.create(logDirConfPath, true);\n            conf.writeXml(jobFileOut);\n            jobFileOut.close();\n          }\n        } catch (IOException e) {\n          LOG.info(\"Failed to write the job configuration file\", e);\n          throw e;\n        }\n      }\n    }\n\n    MetaInfo fi = new MetaInfo(historyFile, logDirConfPath, writer,\n        user, jobName, jobId);\n    fi.getJobSummary().setJobId(jobId);\n    fileMap.put(jobId, fi);\n  }","id":88762,"modified_method":"/**\n   * Create an event writer for the Job represented by the jobID.\n   * Writes out the job configuration to the log directory.\n   * This should be the first call to history for a job\n   * \n   * @param jobId the jobId.\n   * @throws IOException\n   */\n  protected void setupEventWriter(JobId jobId)\n      throws IOException {\n    if (stagingDirPath == null) {\n      LOG.error(\"Log Directory is null, returning\");\n      throw new IOException(\"Missing Log Directory for History\");\n    }\n\n    MetaInfo oldFi = fileMap.get(jobId);\n    Configuration conf = getConfig();\n\n    // TODO Ideally this should be written out to the job dir\n    // (.staging/jobid/files - RecoveryService will need to be patched)\n    Path historyFile = JobHistoryUtils.getStagingJobHistoryFile(\n        stagingDirPath, jobId, startCount);\n    String user = UserGroupInformation.getCurrentUser().getShortUserName();\n    if (user == null) {\n      throw new IOException(\n          \"User is null while setting up jobhistory eventwriter\");\n    }\n\n    String jobName = context.getJob(jobId).getName();\n    EventWriter writer = (oldFi == null) ? null : oldFi.writer;\n \n    Path logDirConfPath =\n        JobHistoryUtils.getStagingConfFile(stagingDirPath, jobId, startCount);\n    if (writer == null) {\n      try {\n        writer = createEventWriter(historyFile);\n        LOG.info(\"Event Writer setup for JobId: \" + jobId + \", File: \"\n            + historyFile);\n      } catch (IOException ioe) {\n        LOG.info(\"Could not create log file: [\" + historyFile + \"] + for job \"\n            + \"[\" + jobName + \"]\");\n        throw ioe;\n      }\n      \n      //Write out conf only if the writer isn't already setup.\n      if (conf != null) {\n        // TODO Ideally this should be written out to the job dir\n        // (.staging/jobid/files - RecoveryService will need to be patched)\n        FSDataOutputStream jobFileOut = null;\n        try {\n          if (logDirConfPath != null) {\n            jobFileOut = stagingDirFS.create(logDirConfPath, true);\n            conf.writeXml(jobFileOut);\n            jobFileOut.close();\n          }\n        } catch (IOException e) {\n          LOG.info(\"Failed to write the job configuration file\", e);\n          throw e;\n        }\n      }\n    }\n\n    MetaInfo fi = new MetaInfo(historyFile, logDirConfPath, writer,\n        user, jobName, jobId);\n    fi.getJobSummary().setJobId(jobId);\n    fileMap.put(jobId, fi);\n  }","commit_id":"74697f231772a556884feaf1c986631d02a9ae4e","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n    public List<SnapshotVO> listSnapshots(ListSnapshotsCmd cmd) {\n        Long volumeId = cmd.getVolumeId();\n        Boolean isRecursive = cmd.isRecursive();\n        Long projectId = cmd.getProjectId();\n\n        // Verify parameters\n        if (volumeId != null) {\n            VolumeVO volume = _volsDao.findById(volumeId);\n            if (volume != null) {\n                _accountMgr.checkAccess(UserContext.current().getCaller(), null, volume);\n            }\n        }\n\n        Account caller = UserContext.current().getCaller();\n        Long domainId = cmd.getDomainId();\n        String accountName = cmd.getAccountName();\n        List<Long> permittedAccounts = new ArrayList<Long>();\n        if ((caller == null) || _accountMgr.isAdmin(caller.getType())) {\n            if (domainId != null) {\n                if ((caller != null) && !_domainDao.isChildDomain(caller.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Unable to list templates for domain \" + domainId + \", permission denied.\");\n                }\n            } else if ((caller != null) && ((caller.getType() == Account.ACCOUNT_TYPE_DOMAIN_ADMIN) || (caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN))) {\n                domainId = caller.getDomainId();\n                isRecursive = true;\n            }\n\n            if (domainId != null && accountName != null) {\n                Account userAccount = _accountDao.findActiveAccount(accountName, domainId);\n                if (userAccount != null) {\n                    permittedAccounts.add(userAccount.getId());\n                } else {\n                    throw new InvalidParameterValueException(\"Could not find account:\" + accountName + \" in domain:\" + domainId);\n                }\n            }\n        } else {\n            permittedAccounts.add(caller.getId());\n        }\n\n        if (isRecursive == null) {\n            isRecursive = false;\n        }\n        \n        //set project information\n        boolean skipProjectSnapshots = true;\n        if (projectId != null) {\n        \tif (projectId == -1) {\n                permittedAccounts.addAll(_projectMgr.listPermittedProjectAccounts(caller.getId()));\n        \t} else {\n        \t\tpermittedAccounts.clear();\n                Project project = _projectMgr.getProject(projectId);\n                if (project == null) {\n                    throw new InvalidParameterValueException(\"Unable to find project by id \" + projectId);\n                }\n                if (!_projectMgr.canAccessProjectAccount(caller, project.getProjectAccountId())) {\n                    throw new InvalidParameterValueException(\"Account \" + caller + \" can't access project id=\" + projectId);\n                }\n                permittedAccounts.add(project.getProjectAccountId());\n        \t}\n        \tskipProjectSnapshots = false;\n        }\n\n        Object name = cmd.getSnapshotName();\n        Object id = cmd.getId();\n        Object keyword = cmd.getKeyword();\n        Object snapshotTypeStr = cmd.getSnapshotType();\n        Object intervalTypeStr = cmd.getIntervalType();\n\n        Filter searchFilter = new Filter(SnapshotVO.class, \"created\", false, cmd.getStartIndex(), cmd.getPageSizeVal());\n        SearchBuilder<SnapshotVO> sb = _snapshotDao.createSearchBuilder();\n        sb.and(\"status\", sb.entity().getStatus(), SearchCriteria.Op.EQ);\n        sb.and(\"volumeId\", sb.entity().getVolumeId(), SearchCriteria.Op.EQ);\n        sb.and(\"name\", sb.entity().getName(), SearchCriteria.Op.LIKE);\n        sb.and(\"id\", sb.entity().getId(), SearchCriteria.Op.EQ);\n        sb.and(\"accountId\", sb.entity().getAccountId(), SearchCriteria.Op.IN);\n        sb.and(\"snapshotTypeEQ\", sb.entity().getsnapshotType(), SearchCriteria.Op.IN);\n        sb.and(\"snapshotTypeNEQ\", sb.entity().getsnapshotType(), SearchCriteria.Op.NEQ);\n\n        if ((permittedAccounts.isEmpty()) && (domainId != null)) {\n            // if accountId isn't specified, we can do a domain match for the admin case\n            SearchBuilder<AccountVO> accountSearch = _accountDao.createSearchBuilder();\n            sb.join(\"accountSearch\", accountSearch, sb.entity().getAccountId(), accountSearch.entity().getId(), JoinType.INNER);\n\n            SearchBuilder<DomainVO> domainSearch = _domainDao.createSearchBuilder();\n            if (isRecursive) {\n                domainSearch.and(\"path\", domainSearch.entity().getPath(), SearchCriteria.Op.LIKE);\n            } else {\n                domainSearch.and(\"path\", domainSearch.entity().getPath(), SearchCriteria.Op.EQ);\n            }\n            accountSearch.join(\"domainSearch\", domainSearch, accountSearch.entity().getDomainId(), domainSearch.entity().getId(), JoinType.INNER);\n        }\n        \n        if (skipProjectSnapshots) {\n        \tSearchBuilder<AccountVO> accountSearch = _accountDao.createSearchBuilder();\n       \t \taccountSearch.and(\"type\", accountSearch.entity().getType(), SearchCriteria.Op.NEQ);\n       \t \tsb.join(\"accountSearch\", accountSearch, sb.entity().getAccountId(), accountSearch.entity().getId(), JoinBuilder.JoinType.INNER);\n        }\n\n        SearchCriteria<SnapshotVO> sc = sb.create();\n        \n        if (skipProjectSnapshots) {\n        \tsc.setJoinParameters(\"accountSearch\", \"type\", Account.ACCOUNT_TYPE_PROJECT);\n        }\n\n        if (volumeId != null) {\n            sc.setParameters(\"volumeId\", volumeId);\n        }\n\n        if (name != null) {\n            sc.setParameters(\"name\", \"%\" + name + \"%\");\n        }\n\n        if (id != null) {\n            sc.setParameters(\"id\", id);\n        }\n\n        if (keyword != null) {\n            SearchCriteria<SnapshotVO> ssc = _snapshotDao.createSearchCriteria();\n            ssc.addOr(\"name\", SearchCriteria.Op.LIKE, \"%\" + keyword + \"%\");\n            sc.addAnd(\"name\", SearchCriteria.Op.SC, ssc);\n        }\n\n        if (!permittedAccounts.isEmpty()) {\n            sc.setParameters(\"accountId\", permittedAccounts.toArray());\n        } else if (domainId != null) {\n            DomainVO domain = _domainDao.findById(domainId);\n            SearchCriteria<?> joinSearch = sc.getJoin(\"accountSearch\");\n            if (isRecursive) {\n                joinSearch.setJoinParameters(\"domainSearch\", \"path\", domain.getPath() + \"%\");\n            } else {\n                joinSearch.setJoinParameters(\"domainSearch\", \"path\", domain.getPath());\n            }\n        }\n\n        if (snapshotTypeStr != null) {\n            Type snapshotType = SnapshotVO.getSnapshotType((String) snapshotTypeStr);\n            if (snapshotType == null) {\n                throw new InvalidParameterValueException(\"Unsupported snapshot type \" + snapshotTypeStr);\n            }\n            if (snapshotType == Type.RECURRING) {\n                sc.setParameters(\"snapshotTypeEQ\", Type.HOURLY.ordinal(), Type.DAILY.ordinal(), Type.WEEKLY.ordinal(), Type.MONTHLY.ordinal());\n            } else {\n                sc.setParameters(\"snapshotTypeEQ\", snapshotType.ordinal());\n            }\n        } else if (intervalTypeStr != null && volumeId != null) {\n            Type type = SnapshotVO.getSnapshotType((String) intervalTypeStr);\n            if (type == null) {\n                throw new InvalidParameterValueException(\"Unsupported snapstho interval type \" + intervalTypeStr);\n            }\n            sc.setParameters(\"snapshotTypeEQ\", type.ordinal());\n        } else {\n            // Show only MANUAL and RECURRING snapshot types\n            sc.setParameters(\"snapshotTypeNEQ\", Snapshot.Type.TEMPLATE.ordinal());\n        }\n\n        return _snapshotDao.search(sc, searchFilter);\n    }","id":88763,"modified_method":"@Override\n    public List<SnapshotVO> listSnapshots(ListSnapshotsCmd cmd) {\n        Long volumeId = cmd.getVolumeId();\n        Boolean isRecursive = cmd.isRecursive();\n        Long projectId = cmd.getProjectId();\n\n        // Verify parameters\n        if (volumeId != null) {\n            VolumeVO volume = _volsDao.findById(volumeId);\n            if (volume != null) {\n                _accountMgr.checkAccess(UserContext.current().getCaller(), null, volume);\n            }\n        }\n\n        Account caller = UserContext.current().getCaller();\n        Long domainId = cmd.getDomainId();\n        String accountName = cmd.getAccountName();\n        List<Long> permittedAccounts = new ArrayList<Long>();\n        if ((caller == null) || _accountMgr.isAdmin(caller.getType())) {\n            if (domainId != null) {\n                if ((caller != null) && !_domainDao.isChildDomain(caller.getDomainId(), domainId)) {\n                    throw new PermissionDeniedException(\"Unable to list templates for domain \" + domainId + \", permission denied.\");\n                }\n            } else if ((caller != null) && ((caller.getType() == Account.ACCOUNT_TYPE_DOMAIN_ADMIN) || (caller.getType() == Account.ACCOUNT_TYPE_RESOURCE_DOMAIN_ADMIN))) {\n                domainId = caller.getDomainId();\n                isRecursive = true;\n            }\n\n            if (domainId != null && accountName != null) {\n                Account userAccount = _accountDao.findActiveAccount(accountName, domainId);\n                if (userAccount != null) {\n                    permittedAccounts.add(userAccount.getId());\n                } else {\n                    throw new InvalidParameterValueException(\"Could not find account:\" + accountName + \" in domain:\" + domainId);\n                }\n            }\n        } else {\n            permittedAccounts.add(caller.getId());\n        }\n\n        if (isRecursive == null) {\n            isRecursive = false;\n        }\n        \n        //set project information\n        boolean skipProjectSnapshots = true;\n        if (projectId != null) {\n        \tif (projectId == -1) {\n                permittedAccounts.addAll(_projectMgr.listPermittedProjectAccounts(caller.getId()));\n        \t} else {\n        \t\tpermittedAccounts.clear();\n                Project project = _projectMgr.getProject(projectId);\n                if (project == null) {\n                    throw new InvalidParameterValueException(\"Unable to find project by id \" + projectId);\n                }\n                if (!_projectMgr.canAccessProjectAccount(caller, project.getProjectAccountId())) {\n                    throw new InvalidParameterValueException(\"Account \" + caller + \" can't access project id=\" + projectId);\n                }\n                permittedAccounts.add(project.getProjectAccountId());\n        \t}\n        \tskipProjectSnapshots = false;\n        }\n\n        Object name = cmd.getSnapshotName();\n        Object id = cmd.getId();\n        Object keyword = cmd.getKeyword();\n        Object snapshotTypeStr = cmd.getSnapshotType();\n        Object intervalTypeStr = cmd.getIntervalType();\n\n        Filter searchFilter = new Filter(SnapshotVO.class, \"created\", false, cmd.getStartIndex(), cmd.getPageSizeVal());\n        SearchBuilder<SnapshotVO> sb = _snapshotDao.createSearchBuilder();\n        sb.and(\"status\", sb.entity().getStatus(), SearchCriteria.Op.EQ);\n        sb.and(\"volumeId\", sb.entity().getVolumeId(), SearchCriteria.Op.EQ);\n        sb.and(\"name\", sb.entity().getName(), SearchCriteria.Op.LIKE);\n        sb.and(\"id\", sb.entity().getId(), SearchCriteria.Op.EQ);\n        sb.and(\"accountId\", sb.entity().getAccountId(), SearchCriteria.Op.IN);\n        sb.and(\"snapshotTypeEQ\", sb.entity().getsnapshotType(), SearchCriteria.Op.IN);\n        sb.and(\"snapshotTypeNEQ\", sb.entity().getsnapshotType(), SearchCriteria.Op.NEQ);\n\n        SearchBuilder<AccountVO> accountSearch = null;\n        if ((permittedAccounts.isEmpty()) && (domainId != null)) {\n            // if accountId isn't specified, we can do a domain match for the admin case\n            accountSearch = _accountDao.createSearchBuilder();\n            sb.join(\"accountSearch\", accountSearch, sb.entity().getAccountId(), accountSearch.entity().getId(), JoinType.INNER);\n            SearchBuilder<DomainVO> domainSearch = _domainDao.createSearchBuilder();\n            if (isRecursive) {\n                domainSearch.and(\"path\", domainSearch.entity().getPath(), SearchCriteria.Op.LIKE);\n            } else {\n                domainSearch.and(\"path\", domainSearch.entity().getPath(), SearchCriteria.Op.EQ);\n            }\n            accountSearch.join(\"domainSearch\", domainSearch, accountSearch.entity().getDomainId(), domainSearch.entity().getId(), JoinType.INNER);\n        }\n        \n        if (skipProjectSnapshots) {\n        \tif(accountSearch == null){\n        \t\taccountSearch = _accountDao.createSearchBuilder();\n       \t \t\tsb.join(\"accountSearch\", accountSearch, sb.entity().getAccountId(), accountSearch.entity().getId(), JoinBuilder.JoinType.INNER);\n        \t}\n        \taccountSearch.and(\"type\", accountSearch.entity().getType(), SearchCriteria.Op.NEQ);\n        }\n\n        SearchCriteria<SnapshotVO> sc = sb.create();\n        \n        if (skipProjectSnapshots) {\n        \tsc.setJoinParameters(\"accountSearch\", \"type\", Account.ACCOUNT_TYPE_PROJECT);\n        }\n\n        if (volumeId != null) {\n            sc.setParameters(\"volumeId\", volumeId);\n        }\n\n        if (name != null) {\n            sc.setParameters(\"name\", \"%\" + name + \"%\");\n        }\n\n        if (id != null) {\n            sc.setParameters(\"id\", id);\n        }\n\n        if (keyword != null) {\n            SearchCriteria<SnapshotVO> ssc = _snapshotDao.createSearchCriteria();\n            ssc.addOr(\"name\", SearchCriteria.Op.LIKE, \"%\" + keyword + \"%\");\n            sc.addAnd(\"name\", SearchCriteria.Op.SC, ssc);\n        }\n\n        if (!permittedAccounts.isEmpty()) {\n            sc.setParameters(\"accountId\", permittedAccounts.toArray());\n        } else if (domainId != null) {\n            DomainVO domain = _domainDao.findById(domainId);\n            SearchCriteria<?> joinSearch = sc.getJoin(\"accountSearch\");\n            if (isRecursive) {\n                joinSearch.setJoinParameters(\"domainSearch\", \"path\", domain.getPath() + \"%\");\n            } else {\n                joinSearch.setJoinParameters(\"domainSearch\", \"path\", domain.getPath());\n            }\n        }\n\n        if (snapshotTypeStr != null) {\n            Type snapshotType = SnapshotVO.getSnapshotType((String) snapshotTypeStr);\n            if (snapshotType == null) {\n                throw new InvalidParameterValueException(\"Unsupported snapshot type \" + snapshotTypeStr);\n            }\n            if (snapshotType == Type.RECURRING) {\n                sc.setParameters(\"snapshotTypeEQ\", Type.HOURLY.ordinal(), Type.DAILY.ordinal(), Type.WEEKLY.ordinal(), Type.MONTHLY.ordinal());\n            } else {\n                sc.setParameters(\"snapshotTypeEQ\", snapshotType.ordinal());\n            }\n        } else if (intervalTypeStr != null && volumeId != null) {\n            Type type = SnapshotVO.getSnapshotType((String) intervalTypeStr);\n            if (type == null) {\n                throw new InvalidParameterValueException(\"Unsupported snapstho interval type \" + intervalTypeStr);\n            }\n            sc.setParameters(\"snapshotTypeEQ\", type.ordinal());\n        } else {\n            // Show only MANUAL and RECURRING snapshot types\n            sc.setParameters(\"snapshotTypeNEQ\", Snapshot.Type.TEMPLATE.ordinal());\n        }\n\n        return _snapshotDao.search(sc, searchFilter);\n    }","commit_id":"ff14d09a8dc692b91e727e56575a7d72589dc654","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"name\", name)\n      .add(\"type\", type)\n      .add(\"properties\", Joiner.on(\",\").withKeyValueSeparator(\"=\").join(properties))\n      .add(\"datasetSpecs\", Joiner.on(\",\").withKeyValueSeparator(\"=\").join(datasetSpecs))\n      .toString();\n  }","id":88764,"modified_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"name\", name)\n      .add(\"type\", type)\n      .add(\"properties\", properties == null ? null : Joiner.on(\",\").withKeyValueSeparator(\"=\").join(properties))\n      .add(\"datasetSpecs\", datasetSpecs == null ? null : Joiner.on(\",\").withKeyValueSeparator(\"=\").join(datasetSpecs))\n      .toString();\n  }","commit_id":"d4d871ff4f62cf77d3cb770a3f9bbffbdd4830ea","url":"https://github.com/caskdata/cdap"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88765,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"3477043d70f50018d7ebdb6364bb51e103c42ca6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88766,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"3477043d70f50018d7ebdb6364bb51e103c42ca6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88767,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"3477043d70f50018d7ebdb6364bb51e103c42ca6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88768,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"3477043d70f50018d7ebdb6364bb51e103c42ca6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88769,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"3477043d70f50018d7ebdb6364bb51e103c42ca6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88770,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"009ff0a3db25e36c5bb4f7dd6352fa42ddfc48fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88771,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"009ff0a3db25e36c5bb4f7dd6352fa42ddfc48fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88772,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"009ff0a3db25e36c5bb4f7dd6352fa42ddfc48fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88773,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"009ff0a3db25e36c5bb4f7dd6352fa42ddfc48fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88774,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"009ff0a3db25e36c5bb4f7dd6352fa42ddfc48fb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * Simply joins the items in the list with \".\" period\n     *\n     * @param digits\n     */\n    protected static String joinDigitString( List digits )\n    {\n        return StringUtils.join( digits.iterator(), DIGIT_SEPARATOR_STRING );\n    }","id":88775,"modified_method":"/**\n     * Simply joins the items in the list with \".\" period\n     *\n     * @param digits\n     */\n    protected static String joinDigitString( List digits )\n    {\n        return digits != null ? StringUtils.join( digits.iterator(), DIGIT_SEPARATOR_STRING ) : null;\n    }","commit_id":"21e6481c9384cea3bfd6ad4f2953561e5504a77e","url":"https://github.com/apache/maven-plugins"},{"original_method":"public VersionInfo getNextVersion()\n    {\n        List digits = new ArrayList( this.digits );\n        String annotationRevision = this.annotationRevision;\n        if ( StringUtils.isNumeric( annotationRevision ) )\n        {\n            annotationRevision = incrementVersionString( annotationRevision );\n        }\n        else\n        {\n            digits.set( digits.size() - 1, incrementVersionString( (String) digits.get( digits.size() - 1 ) ) );\n        }\n\n        return new DefaultVersionInfo( digits, annotation, annotationRevision, buildSpecifier, annotationSeparator,\n                                       annotationRevSeparator, buildSeparator );\n    }","id":88776,"modified_method":"public VersionInfo getNextVersion()\n    {\n        DefaultVersionInfo version = null;\n        if ( digits != null )\n        {\n            List digits = new ArrayList( this.digits );\n            String annotationRevision = this.annotationRevision;\n            if ( StringUtils.isNumeric( annotationRevision ) )\n            {\n                annotationRevision = incrementVersionString( annotationRevision );\n            }\n            else\n            {\n                digits.set( digits.size() - 1, incrementVersionString( (String) digits.get( digits.size() - 1 ) ) );\n            }\n\n            version = new DefaultVersionInfo( digits, annotation, annotationRevision, buildSpecifier,\n                                              annotationSeparator, annotationRevSeparator, buildSeparator );\n        }\n        return version;\n    }","commit_id":"21e6481c9384cea3bfd6ad4f2953561e5504a77e","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testParseSnapshotVersion()\n        throws Exception\n    {\n        checkParsing( \"1.0-beta-4-SNAPSHOT\", \"1.0\", \"beta\", \"4\", \"SNAPSHOT\" );\n        checkParsing( \"1.0-beta-4_SNAPSHOT\", \"1.0\", \"beta\", \"4\", \"SNAPSHOT\" );\n    }","id":88777,"modified_method":"public void testParseSnapshotVersion()\n        throws Exception\n    {\n        checkParsing( \"SNAPSHOT\", null, null, null, \"SNAPSHOT\" );\n        checkParsing( \"1.0-beta-4-SNAPSHOT\", \"1.0\", \"beta\", \"4\", \"SNAPSHOT\" );\n        checkParsing( \"1.0-beta-4_SNAPSHOT\", \"1.0\", \"beta\", \"4\", \"SNAPSHOT\" );\n    }","commit_id":"21e6481c9384cea3bfd6ad4f2953561e5504a77e","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testNextVersion()\n        throws Exception\n    {\n        checkNextVersion( \"1\", \"2\" );\n        checkNextVersion( \"1.01\", \"1.02\" );\n        checkNextVersion( \"1.9\", \"1.10\" );\n        checkNextVersion( \"1.09\", \"1.10\" );\n        checkNextVersion( \"1.009\", \"1.010\" );\n\n        checkNextVersion( \"1.99\", \"1.100\" );\n    }","id":88778,"modified_method":"public void testNextVersion()\n        throws Exception\n    {\n        VersionInfo v = new DefaultVersionInfo( \"SNAPSHOT\" );\n        assertNull( v.getNextVersion() );\n\n        checkNextVersion( \"1\", \"2\" );\n        checkNextVersion( \"1.01\", \"1.02\" );\n        checkNextVersion( \"1.9\", \"1.10\" );\n        checkNextVersion( \"1.09\", \"1.10\" );\n        checkNextVersion( \"1.009\", \"1.010\" );\n\n        checkNextVersion( \"1.99\", \"1.100\" );\n    }","commit_id":"21e6481c9384cea3bfd6ad4f2953561e5504a77e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n         * Waits for the completion of the process.\n         */\n        @Override\n        public int join() throws InterruptedException, IOException {\n            try {\n                int r = proc.waitFor();\n                // see http://hudson.gotdns.com/wiki/display/HUDSON/Spawning+processes+from+build\n                // problems like that shows up as inifinite wait in join(), which confuses great many users.\n                // So let's do a timed wait here and try to diagnose the problem\n                copier.join(10*1000);\n                copier2.join(10*1000);\n                if(copier.isAlive() || copier2.isAlive()) {\n                    // looks like handles are leaking.\n                    // closing these handles should terminate the threads.\n                    String msg = \"Process leaked file descriptors. See http://hudson.gotdns.com/wiki/display/HUDSON/Spawning+processes+from+build for more information\";\n                    Throwable e = new Exception().fillInStackTrace();\n                    LOGGER.log(Level.WARNING,msg,e);\n\n                    // doing proc.getInputStream().close() hangs in FileInputStream.close0()\n                    // it could be either because another thread is blocking on read, or\n                    // it could be a bug in Windows JVM. Who knows.\n                    // so I'm abandoning the idea of closing the stream\n//                    try {\n//                        proc.getInputStream().close();\n//                    } catch (IOException x) {\n//                        LOGGER.log(Level.FINE,\"stdin termination failed\",x);\n//                    }\n//                    try {\n//                        proc.getErrorStream().close();\n//                    } catch (IOException x) {\n//                        LOGGER.log(Level.FINE,\"stderr termination failed\",x);\n//                    }\n                    out.write(msg.getBytes());\n                    out.write('\\n');\n                }\n                return r;\n            } catch (InterruptedException e) {\n                // aborting. kill the process\n                destroy();\n                throw e;\n            }\n        }","id":88779,"modified_method":"/**\n         * Waits for the completion of the process.\n         */\n        @Override\n        public int join() throws InterruptedException, IOException {\n            try {\n                int r = proc.waitFor();\n                // see http://hudson.gotdns.com/wiki/display/HUDSON/Spawning+processes+from+build\n                // problems like that shows up as inifinite wait in join(), which confuses great many users.\n                // So let's do a timed wait here and try to diagnose the problem\n                copier.join(10*1000);\n                if(copier2!=null)   copier2.join(10*1000);\n                if(copier.isAlive() || (copier2!=null && copier2.isAlive())) {\n                    // looks like handles are leaking.\n                    // closing these handles should terminate the threads.\n                    String msg = \"Process leaked file descriptors. See http://hudson.gotdns.com/wiki/display/HUDSON/Spawning+processes+from+build for more information\";\n                    Throwable e = new Exception().fillInStackTrace();\n                    LOGGER.log(Level.WARNING,msg,e);\n\n                    // doing proc.getInputStream().close() hangs in FileInputStream.close0()\n                    // it could be either because another thread is blocking on read, or\n                    // it could be a bug in Windows JVM. Who knows.\n                    // so I'm abandoning the idea of closing the stream\n//                    try {\n//                        proc.getInputStream().close();\n//                    } catch (IOException x) {\n//                        LOGGER.log(Level.FINE,\"stdin termination failed\",x);\n//                    }\n//                    try {\n//                        proc.getErrorStream().close();\n//                    } catch (IOException x) {\n//                        LOGGER.log(Level.FINE,\"stderr termination failed\",x);\n//                    }\n                    out.write(msg.getBytes());\n                    out.write('\\n');\n                }\n                return r;\n            } catch (InterruptedException e) {\n                // aborting. kill the process\n                destroy();\n                throw e;\n            }\n        }","commit_id":"a6684093da3fe7aba85e1dd2410cda3217fb6d37","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88780,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"31fa1ede7ccbfa8ececa674000e8d441b83715a7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88781,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"31fa1ede7ccbfa8ececa674000e8d441b83715a7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88782,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"31fa1ede7ccbfa8ececa674000e8d441b83715a7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88783,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"31fa1ede7ccbfa8ececa674000e8d441b83715a7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88784,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"31fa1ede7ccbfa8ececa674000e8d441b83715a7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static StandaloneMain create(String webAppPath, CConfiguration cConf, Configuration hConf) {\n    // This is needed to use LocalJobRunner with fixes (we have it in app-fabric).\n    // For the modified local job runner\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n    // Due to incredibly stupid design of Limits class, once it is initialized, it keeps its settings. We\n    // want to make sure it uses our settings in this hConf, so we have to force it initialize here before\n    // someone else initializes it.\n    Limits.init(hConf);\n\n    File localDataDir = new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR));\n    hConf.set(Constants.CFG_LOCAL_DATA_DIR, localDataDir.getAbsolutePath());\n    hConf.set(Constants.AppFabric.OUTPUT_DIR, cConf.get(Constants.AppFabric.OUTPUT_DIR));\n    hConf.set(\"hadoop.tmp.dir\", new File(localDataDir, cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsolutePath());\n\n    // Windows specific requirements\n    if (OSDetector.isWindows()) {\n      String userDir = System.getProperty(\"user.dir\");\n      System.load(userDir + Joiner.on(File.separator).join(\"lib\", \"native\", \"hadoop.dll\"));\n    }\n\n    //Run dataset service on random port\n    List<Module> modules = createPersistentModules(cConf, hConf, webAppPath);\n\n    return new StandaloneMain(modules, cConf, webAppPath);\n  }","id":88785,"modified_method":"public static StandaloneMain create(String webAppPath, CConfiguration cConf, Configuration hConf) {\n    // This is needed to use LocalJobRunner with fixes (we have it in app-fabric).\n    // For the modified local job runner\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n    // Due to incredibly stupid design of Limits class, once it is initialized, it keeps its settings. We\n    // want to make sure it uses our settings in this hConf, so we have to force it initialize here before\n    // someone else initializes it.\n    Limits.init(hConf);\n\n    File localDataDir = new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR));\n    hConf.set(Constants.CFG_LOCAL_DATA_DIR, localDataDir.getAbsolutePath());\n    hConf.set(Constants.AppFabric.OUTPUT_DIR, cConf.get(Constants.AppFabric.OUTPUT_DIR));\n    hConf.set(\"hadoop.tmp.dir\", new File(localDataDir, cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsolutePath());\n\n    // Windows specific requirements\n    if (OSDetector.isWindows()) {\n      // not set anywhere by the project, expected to be set from IDEs if running from the project instead of sdk\n      // hadoop.dll is at cdap-unit-test\\src\\main\\resources\\hadoop.dll for some reason\n      String hadoopDLLPath = System.getProperty(\"hadoop.dll.path\");\n      if (hadoopDLLPath != null) {\n        System.load(hadoopDLLPath);\n      } else {\n        // this is where it is when the standalone sdk is built\n        String userDir = System.getProperty(\"user.dir\");\n        System.load(Joiner.on(File.separator).join(userDir, \"lib\", \"native\", \"hadoop.dll\"));\n      }\n    }\n\n    //Run dataset service on random port\n    List<Module> modules = createPersistentModules(cConf, hConf, webAppPath);\n\n    return new StandaloneMain(modules, cConf, webAppPath);\n  }","commit_id":"fb5be983ba6f085128011a771185ac9010ed7db5","url":"https://github.com/caskdata/cdap"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88786,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"a19ec3e83c218b88fd5e61842ee8dc87e7fe672b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88787,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"a19ec3e83c218b88fd5e61842ee8dc87e7fe672b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88788,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"a19ec3e83c218b88fd5e61842ee8dc87e7fe672b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88789,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"a19ec3e83c218b88fd5e61842ee8dc87e7fe672b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88790,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"a19ec3e83c218b88fd5e61842ee8dc87e7fe672b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88791,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"5a25e360da3ecf3e9f9e692b73a1e459cddf3872","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88792,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"5a25e360da3ecf3e9f9e692b73a1e459cddf3872","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88793,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"5a25e360da3ecf3e9f9e692b73a1e459cddf3872","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88794,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"5a25e360da3ecf3e9f9e692b73a1e459cddf3872","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88795,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"5a25e360da3ecf3e9f9e692b73a1e459cddf3872","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Entry(String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","id":88796,"modified_method":"public Entry(String tokensRegex, String[] regex, String type, Set<String> overwritableTypes, double priority) {\n      this.tokensRegex = tokensRegex;\n      this.regex = regex;\n      this.type = type.intern();\n      this.overwritableTypes = overwritableTypes;\n      this.priority = priority;\n    }","commit_id":"a060b0c7a3433a75cd3c86345bcf7fe7ff591254","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String p:entry.regex) {\n        CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n        if (posTagPattern != null) {\n          c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n        }\n        nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n      }\n      TokenSequencePattern pattern = TokenSequencePattern.compile(\n              new SequencePattern.SequencePatternExpr(nodePatterns));\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","id":88797,"modified_method":"private MultiPatternMatcher<CoreMap> createPatternMatcher() {\n    // Convert to tokensregex pattern\n    int patternFlags = ignoreCase? Pattern.CASE_INSENSITIVE:0;\n    Env env = TokenSequencePattern.getNewEnv();\n    env.setDefaultStringPatternFlags(patternFlags);\n    NodePattern<String> posTagPattern = (validPosPattern != null && PosMatchType.MATCH_ALL_TOKENS.equals(posMatchType))?\n            new CoreMapNodePattern.StringAnnotationRegexPattern(validPosPattern):null;\n    List<TokenSequencePattern> patterns = new ArrayList<TokenSequencePattern>(entries.size());\n    for (Entry entry:entries) {\n      TokenSequencePattern pattern;\n      if (entry.tokensRegex != null) {\n        // TODO: posTagPatterns...\n        pattern = TokenSequencePattern.compile(env, entry.tokensRegex);\n      } else {\n        List<SequencePattern.PatternExpr> nodePatterns = new ArrayList<SequencePattern.PatternExpr>();\n        for (String p:entry.regex) {\n          CoreMapNodePattern c = CoreMapNodePattern.valueOf(p, patternFlags);\n          if (posTagPattern != null) {\n            c.add(CoreAnnotations.PartOfSpeechAnnotation.class, posTagPattern);\n          }\n          nodePatterns.add(new SequencePattern.NodePatternExpr(c));\n        }\n        pattern = TokenSequencePattern.compile(\n                new SequencePattern.SequencePatternExpr(nodePatterns));\n      }\n      pattern.setPriority(entry.priority);\n      patterns.add(pattern);\n      patternToEntry.put(pattern, entry);\n    }\n    return TokenSequencePattern.getMultiPatternMatcher(patterns);\n  }","commit_id":"a060b0c7a3433a75cd3c86345bcf7fe7ff591254","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String mapping = properties.getProperty(name + \".mapping\", DefaultPaths.DEFAULT_REGEXNER_RULES);\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    BufferedReader rd = null;\n    try {\n      rd = IOUtils.readerFromString(mapping);\n      entries = readEntries(name, mapping, rd, noDefaultOverwriteLabels, ignoreCase, verbose);\n    } catch (IOException e) {\n      throw new RuntimeIOException(\"Couldn't read TokensRegexNER from \" + mapping, e);\n    } finally {\n      IOUtils.closeIgnoringExceptions(rd);\n    }\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","id":88798,"modified_method":"public TokensRegexNERAnnotator(String name, Properties properties) {\n    String backgroundSymbol = properties.getProperty(name + \".backgroundSymbol\",\n            SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL + \",MISC\");\n    String[] backgroundSymbols = backgroundSymbol.split(\"\\\\s*,\\\\s*\");\n    String[] mappings = PropertiesUtils.getStringArray(properties, name + \".mapping\",\n            new String[] { DefaultPaths.DEFAULT_REGEXNER_RULES} );\n    String validPosRegex = properties.getProperty(name + \".validpospattern\");\n    this.posMatchType = PosMatchType.valueOf(properties.getProperty(name + \".posmatchtype\",\n            DEFAULT_POS_MATCH_TYPE.name()));\n    boolean overwriteMyLabels = true;\n\n    this.noDefaultOverwriteLabels = CollectionUtils.asSet(PropertiesUtils.getStringArray(properties, name + \".noDefaultOverwriteLabels\"));\n    this.ignoreCase = PropertiesUtils.getBool(properties, name + \".ignorecase\", false);\n    this.verbose = PropertiesUtils.getBool(properties, name + \".verbose\", false);\n\n    if (validPosRegex != null && !validPosRegex.equals(\"\")) {\n      validPosPattern = Pattern.compile(validPosRegex);\n    } else {\n      validPosPattern = null;\n    }\n    entries = readEntries(name, noDefaultOverwriteLabels, ignoreCase, verbose, mappings);\n    multiPatternMatcher = createPatternMatcher();\n    myLabels = Generics.newHashSet();\n    // Can always override background or none.\n    for (String s:backgroundSymbols)\n      myLabels.add(s);\n    myLabels.add(null);\n    if (overwriteMyLabels) {\n      for (Entry entry: entries) myLabels.add(entry.type);\n    }\n  }","commit_id":"a060b0c7a3433a75cd3c86345bcf7fe7ff591254","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public String toString() {\n      return \"Entry{\" + StringUtils.join(regex) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","id":88799,"modified_method":"public String toString() {\n      return \"Entry{\" + ((tokensRegex != null)? tokensRegex:StringUtils.join(regex)) + ' ' + type + ' ' + overwritableTypes + ' ' + priority + '}';\n    }","commit_id":"a060b0c7a3433a75cd3c86345bcf7fe7ff591254","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   *  Creates a combined list of Entries using the provided mapping file, and sorts them by\n   *  first by priority, then the number of tokens in the regex.\n   *\n   *  @param mapping The Reader containing RegexNER mappings. It's lines are counted from 1\n   *  @return a sorted list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    List<Entry> entries = new ArrayList<Entry>();\n    TrieMap<String,Entry> seenRegexes = new TrieMap<String,Entry>();\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String[] regexes = split[0].trim().split(\"\\\\s+\");\n      String[] key = regexes;\n      if (ignoreCase) {\n        key = new String[regexes.length];\n        for (int i = 0; i < regexes.length; i++) {\n          key[i] = regexes[i].toLowerCase();\n        }\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = null;\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          entry = new Entry(regexes, type, overwritableTypes, priority);\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      } else {\n        entry = new Entry(regexes, type, overwritableTypes, priority);\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + entries.size() + \" unique entries out of \" + lineCount + \" from \" + mappingFilename);\n    // System.err.println(entries);\n    return entries;\n  }","id":88800,"modified_method":"/**\n   *  Reads a list of Entries from a mapping file and update the given entries.\n   *  Line numbers start from 1.\n   *\n   *  @return the updated list of Entries\n   */\n  private static List<Entry> readEntries(String annotatorName,\n                                         List<Entry> entries,\n                                         TrieMap<String,Entry> seenRegexes,\n                                         String mappingFilename,\n                                         BufferedReader mapping,\n                                         Set<String> noDefaultOverwriteLabels,\n                                         boolean ignoreCase, boolean verbose) throws IOException {\n    int origEntriesSize = entries.size();\n    int isTokensRegex = 0;\n    int lineCount = 0;\n    for (String line; (line = mapping.readLine()) != null; ) {\n      lineCount ++;\n      String[] split = line.split(\"\\t\");\n      if (split.length < 2 || split.length > 4)\n        throw new IllegalArgumentException(\"Provided mapping file is in wrong format\");\n\n      String regex = split[0].trim();\n      String tokensRegex = null;\n      String[] regexes = null;\n      if (regex.startsWith(\"( \") && regex.endsWith(\" )\")) {\n        // Tokens regex\n        tokensRegex = regex;\n      } else {\n        regexes = regex.split(\"\\\\s+\");\n      }\n      String[] key = (regexes != null)? regexes: new String[] { tokensRegex };\n      if (ignoreCase) {\n        String[] norm = new String[key.length];\n        for (int i = 0; i < key.length; i++) {\n          norm[i] = key[i].toLowerCase();\n        }\n        key = norm;\n      }\n      String type = split[1].trim();\n\n      Set<String> overwritableTypes = Generics.newHashSet();\n      double priority = 0.0;\n\n      if (split.length >= 3) {\n        overwritableTypes.addAll(Arrays.asList(split[2].trim().split(\",\")));\n      }\n      if (split.length == 4) {\n        try {\n          priority = Double.parseDouble(split[3].trim());\n        } catch(NumberFormatException e) {\n          throw new IllegalArgumentException(\"ERROR: Invalid line \" + lineCount\n                  + \" in regexner file \" + mappingFilename + \": \\\"\" + line + \"\\\"!\", e);\n        }\n      }\n\n      Entry entry = new Entry(tokensRegex, regexes, type, overwritableTypes, priority);\n      if (seenRegexes.containsKey(key)) {\n        Entry oldEntry = seenRegexes.get(key);\n        if (priority > oldEntry.priority) {\n          logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                  \": Replace duplicate entry (higher priority): old=\" + oldEntry + \", new=\" + entry);\n        } else {\n          if (!oldEntry.type.equals(type)) {\n            if (verbose) {\n              logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                      \": Ignoring duplicate entry: \" + split[0] + \", old type = \" + oldEntry.type + \", new type = \" + type);\n            }\n          }\n          continue;\n        }\n      }\n\n      // Print some warning about the type\n      int commaPos = entry.type.indexOf(',');\n      if (commaPos > 0) {\n        // Strip the \",\" and just take first type\n        String newType = entry.type.substring(0, commaPos).trim();\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry has multiple type \" + entry + \", taking type to be \" + newType);\n        entry.type = newType;\n      }\n\n      // Print some warning if label belongs to noDefaultOverwriteLabels but there is no overwritable types\n      if (entry.overwritableTypes.isEmpty() && noDefaultOverwriteLabels.contains(entry.type)) {\n        logger.warn(\"TokensRegexNERAnnotator \" + annotatorName +\n                \": Entry doesn't have overwriteable types \" + entry + \", but entry type is in noDefaultOverwriteLabels\");\n      }\n\n      entries.add(entry);\n      seenRegexes.put(key, entry);\n      if (entry.tokensRegex != null) isTokensRegex++;\n    }\n\n    logger.log(\"TokensRegexNERAnnotator \" + annotatorName +\n            \": Read \" + (entries.size() - origEntriesSize) + \" unique entries out of \" + lineCount + \" from \" + mappingFilename\n       + \", \" + isTokensRegex + \" TokensRegex patterns.\");\n    return entries;\n  }","commit_id":"a060b0c7a3433a75cd3c86345bcf7fe7ff591254","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n\t * Creates a prefix for a url.\n\t * @param cycle\n\t *            The web request cycle\n\t * @return Prefix for URLs including the context path and servlet path.\n\t */\n\tprivate StringBuffer urlPrefix(final WebRequestCycle cycle)\n\t{\t\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tfinal WebRequest request = cycle.getWebRequest();\n\t\tif (request != null)\n\t\t{\n\t\t\tfinal String contextPath = request.getContextPath();\n\t\t\tbuffer.append(contextPath);\n\t\t\tbuffer.append(((WebRequest)request).getServletPath());\n\t\t}\n\n\t\treturn buffer;\n\t}","id":88801,"modified_method":"/**\n\t * Creates a prefix for a url.\n\t * @param cycle\n\t *            The web request cycle\n\t * @return Prefix for URLs including the context path and servlet path.\n\t */\n\tprivate StringBuffer urlPrefix(final WebRequestCycle cycle)\n\t{\t\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tfinal WebRequest request = cycle.getWebRequest();\n\t\tif (request != null)\n\t\t{\n\t\t\tfinal String contextPath = request.getContextPath();\n\t\t\tbuffer.append(contextPath);\n\t\t\tString path = ((WebRequest)request).getServletPath();\n\t\t\tif(path == null || \"\".equals(path)) path = \"/\";\n\t\t\tbuffer.append(path);\n\t\t}\n\n\t\treturn buffer;\n\t}","commit_id":"8e5b85d3bbc0e4cfcdf06563dde40ce0c734b8d8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a prefix for a url.\n\t * @return Prefix for URLs including the context path and servlet path.\n\t */\n\tprotected StringBuffer urlPrefix()\n\t{\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tfinal WebRequest request = getWebRequest();\n\t\tif (request != null)\n\t\t{\n\t\t\tfinal String contextPath = request.getContextPath();\n\t\t\tbuffer.append(contextPath);\n\t\t\tbuffer.append(((WebRequest)request).getServletPath());\n\t\t}\n\n\t\treturn buffer;\n\t}","id":88802,"modified_method":"/**\n\t * Creates a prefix for a url.\n\t * @return Prefix for URLs including the context path and servlet path.\n\t */\n\tprotected StringBuffer urlPrefix()\n\t{\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tfinal WebRequest request = getWebRequest();\n\t\tif (request != null)\n\t\t{\n\t\t\tfinal String contextPath = request.getContextPath();\n\t\t\tbuffer.append(contextPath);\n\t\t\tString path = ((WebRequest)request).getServletPath();\n\t\t\tif(path == null || \"\".equals(path)) path = \"/\";\n\t\t\tbuffer.append(path);\t\t\t\n\t\t}\n\n\t\treturn buffer;\n\t}","commit_id":"8e5b85d3bbc0e4cfcdf06563dde40ce0c734b8d8","url":"https://github.com/apache/wicket"},{"original_method":"private String getResourcePath(String resource, boolean testExist)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = getSkinFolder() + resource;\n\n        // Prevent inclusion of templates from other directories\n        String normalizedResource = URI.create(resourcePath).normalize().toString();\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\", normalizedResource);\n\n            return null;\n        }\n\n        if (testExist) {\n            // Check if the resource exist\n            if (this.environment.getResource(resourcePath) == null) {\n                return null;\n            }\n        }\n\n        return resourcePath;\n    }","id":88803,"modified_method":"private String getResourcePath(String resource, boolean testExist)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n\n        // Prevent inclusion of templates from other directories\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\", normalizedResource);\n\n            return null;\n        }\n\n        if (testExist) {\n            // Check if the resource exist\n            if (this.environment.getResource(resourcePath) == null) {\n                return null;\n            }\n        }\n\n        return resourcePath;\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createResourceURL(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            File targetFile = new File(getFilesystemExportContext().getExportDir(), \"resources/\" + filename);\n            if (!targetFile.exists()) {\n                if (!targetFile.getParentFile().exists()) {\n                    targetFile.getParentFile().mkdirs();\n                }\n\n                // Step 1: Copy the resource\n                // If forceSkinAction is false then there's no velocity in the resource and we can just copy it simply.\n                // Otherwise we need to go through the Skin Action to perform the rendering.\n                if (forceSkinAction) {\n                    // Extract the first path as the wiki page\n                    int pos = filename.indexOf('/', 0);\n                    String page = filename.substring(0, pos);\n                    renderSkinFile(\"resource/\" + filename, \"resources\", page, context.getDatabase(), targetFile,\n                        StringUtils.countMatches(filename, \"/\") + 1, context);\n                } else {\n                    FileOutputStream fos = new FileOutputStream(targetFile);\n                    InputStream source = context.getEngineContext().getResourceAsStream(\"/resources/\" + filename);\n                    IOUtils.copy(source, fos);\n                    fos.close();\n                }\n            }\n\n            StringBuffer newPath = new StringBuffer(\"file://\");\n\n            // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n            adjustCSSPath(newPath);\n\n            newPath.append(\"resources\");\n\n            addFileName(newPath, filename, false, context);\n\n            return new URL(newPath.toString());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create skin URL\", e);\n        }\n\n        return super.createResourceURL(filename, forceSkinAction, context);\n    }","id":88804,"modified_method":"@Override\n    public URL createResourceURL(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            File targetFile = new File(getFilesystemExportContext().getExportDir(), \"resources/\" + filename);\n            if (!targetFile.exists()) {\n                if (!targetFile.getParentFile().exists()) {\n                    targetFile.getParentFile().mkdirs();\n                }\n\n                // Step 1: Copy the resource\n                // If forceSkinAction is false then there's no velocity in the resource and we can just copy it simply.\n                // Otherwise we need to go through the Skin Action to perform the rendering.\n                if (forceSkinAction) {\n                    // Extract the first path as the wiki page\n                    int pos = filename.indexOf('/', 0);\n                    String page = filename.substring(0, pos);\n                    renderSkinFile(\"resource/\" + filename, \"resources\", page, context.getDatabase(), targetFile,\n                        StringUtils.countMatches(filename, \"/\") + 1, context);\n                } else {\n                    FileOutputStream fos = new FileOutputStream(targetFile);\n                    InputStream source = context.getEngineContext().getResourceAsStream(\"/resources/\" + filename);\n                    IOUtils.copy(source, fos);\n                    fos.close();\n                }\n            }\n\n            StringBuilder newPath = new StringBuilder(\"file://\");\n\n            // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n            adjustCSSPath(newPath);\n\n            newPath.append(\"resources\");\n\n            addFileName(newPath, filename, false, context);\n\n            return new URL(newPath.toString());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create skin URL\", e);\n        }\n\n        return super.createResourceURL(filename, forceSkinAction, context);\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createSkinURL(String filename, String skin, XWikiContext context)\n    {\n        try {\n            getFilesystemExportContext().addNeededSkin(skin);\n\n            StringBuffer newPath = new StringBuffer(\"file://\");\n\n            // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n            adjustCSSPath(newPath);\n\n            newPath.append(\"skins/\");\n            newPath.append(skin);\n\n            addFileName(newPath, filename, false, context);\n\n            return new URL(newPath.toString());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create skin URL\", e);\n        }\n\n        return super.createSkinURL(filename, skin, context);\n    }","id":88805,"modified_method":"@Override\n    public URL createSkinURL(String filename, String skin, XWikiContext context)\n    {\n        try {\n            getFilesystemExportContext().addNeededSkin(skin);\n\n            StringBuilder newPath = new StringBuilder(\"file://\");\n\n            // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n            adjustCSSPath(newPath);\n\n            newPath.append(\"skins/\");\n            newPath.append(skin);\n\n            addFileName(newPath, filename, false, context);\n\n            return new URL(newPath.toString());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create skin URL\", e);\n        }\n\n        return super.createSkinURL(filename, skin, context);\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void adjustCSSPath(StringBuffer path)\n    {\n        path.append(StringUtils.repeat(\"../\", getFilesystemExportContext().getCSSParentLevel()));\n    }","id":88806,"modified_method":"private void adjustCSSPath(StringBuilder path)\n    {\n        path.append(StringUtils.repeat(\"../\", getFilesystemExportContext().getCSSParentLevel()));\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public URL createSkinURL(String fileName, String spaces, String name, String wikiId, XWikiContext context,\n        boolean skipSkinDirectory)\n    {\n        URL skinURL;\n        if (wikiId == null) {\n            skinURL = super.createSkinURL(fileName, spaces, name, context);\n        } else {\n            skinURL = super.createSkinURL(fileName, spaces, name, wikiId, context);\n        }\n\n        if (!\"skins\".equals(spaces)) {\n            return skinURL;\n        }\n\n        try {\n            getFilesystemExportContext().addNeededSkin(name);\n\n            StringBuffer filePathBuffer = new StringBuffer();\n            if (!skipSkinDirectory) {\n                filePathBuffer.append(\"skins/\");\n                filePathBuffer.append(name);\n                filePathBuffer.append(\"/\");\n            }\n            filePathBuffer.append(fileName);\n\n            String filePath = filePathBuffer.toString();\n\n            if (!getFilesystemExportContext().hasExportedSkinFile(filePath)) {\n                getFilesystemExportContext().addExportedSkinFile(filePath);\n\n                File file = new File(getFilesystemExportContext().getExportDir(), filePath);\n                if (!file.exists()) {\n                    // Make sure the folder exists\n                    File folder = file.getParentFile();\n                    if (!folder.exists()) {\n                        folder.mkdirs();\n                    }\n                    renderSkinFile(skinURL.getPath(), spaces, name, wikiId, file, StringUtils.countMatches(filePath, \"/\"),\n                        context);\n                }\n\n                followCssImports(file, spaces, name, wikiId, context);\n            }\n\n            StringBuffer newPath = new StringBuffer(\"file://\");\n\n            // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n            adjustCSSPath(newPath);\n\n            newPath.append(filePath);\n\n            skinURL = new URL(newPath.toString());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create skin URL\", e);\n        }\n\n        return skinURL;\n    }","id":88807,"modified_method":"public URL createSkinURL(String fileName, String spaces, String name, String wikiId, XWikiContext context,\n        boolean skipSkinDirectory)\n    {\n        URL skinURL;\n        if (wikiId == null) {\n            skinURL = super.createSkinURL(fileName, spaces, name, context);\n        } else {\n            skinURL = super.createSkinURL(fileName, spaces, name, wikiId, context);\n        }\n\n        if (!\"skins\".equals(spaces)) {\n            return skinURL;\n        }\n\n        try {\n            getFilesystemExportContext().addNeededSkin(name);\n\n            StringBuffer filePathBuffer = new StringBuffer();\n            if (!skipSkinDirectory) {\n                filePathBuffer.append(\"skins/\");\n                filePathBuffer.append(name);\n                filePathBuffer.append(\"/\");\n            }\n            filePathBuffer.append(fileName);\n\n            String filePath = filePathBuffer.toString();\n\n            if (!getFilesystemExportContext().hasExportedSkinFile(filePath)) {\n                getFilesystemExportContext().addExportedSkinFile(filePath);\n\n                File file = new File(getFilesystemExportContext().getExportDir(), filePath);\n                if (!file.exists()) {\n                    // Make sure the folder exists\n                    File folder = file.getParentFile();\n                    if (!folder.exists()) {\n                        folder.mkdirs();\n                    }\n                    renderSkinFile(skinURL.getPath(), spaces, name, wikiId, file, StringUtils.countMatches(filePath, \"/\"),\n                        context);\n                }\n\n                followCssImports(file, spaces, name, wikiId, context);\n            }\n\n            StringBuilder newPath = new StringBuilder(\"file://\");\n\n            // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n            adjustCSSPath(newPath);\n\n            newPath.append(filePath);\n\n            skinURL = new URL(newPath.toString());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create skin URL\", e);\n        }\n\n        return skinURL;\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Generate an url targeting attachment in provided wiki page.\n     *\n     * @param filename the name of the attachment.\n     * @param spaces a serialized space reference which can contain one or several spaces (e.g. \"space1.space2\"). If\n     *        a space name contains a dot (\".\") it must be passed escaped as in \"space1\\.with\\.dot.space2\"\n     * @param name the name of the page containing the attachment.\n     * @param xwikidb the wiki of the page containing the attachment.\n     * @param context the XWiki context.\n     * @return the generated url.\n     * @throws XWikiException error when retrieving document attachment.\n     * @throws IOException error when retrieving document attachment.\n     * @throws URISyntaxException when retrieving document attachment.\n     */\n    private URL createAttachmentURL(String filename, String spaces, String name, String xwikidb, XWikiContext context)\n        throws XWikiException, IOException, URISyntaxException\n    {\n        String db = (xwikidb == null ? context.getWikiId() : xwikidb);\n        DocumentReference documentReference =\n            new DocumentReference(db, this.legacySpaceResolver.resolve(spaces), name);\n        String serializedReference = this.pathEntityReferenceSerializer.serialize(\n            new AttachmentReference(filename, documentReference));\n        String path = \"attachment/\" + serializedReference;\n\n        File file = new File(getFilesystemExportContext().getExportDir(), path);\n        if (!file.exists()) {\n            XWikiDocument doc = context.getWiki().getDocument(documentReference, context);\n            XWikiAttachment attachment = doc.getAttachment(filename);\n            file.getParentFile().mkdirs();\n            FileOutputStream fos = new FileOutputStream(file);\n            IOUtils.copy(attachment.getContentInputStream(context), fos);\n            fos.close();\n        }\n\n        StringBuffer newPath = new StringBuffer(\"file://\");\n\n        // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n        adjustCSSPath(newPath);\n\n        newPath.append(path);\n\n        // Since the returned URL is used in HTML links, we need to escape \"%\" characters so that browsers don't decode\n        // for example %2E as \".\" by default which would lead to the browser not finding the file on the filesystem.\n        return new URL(newPath.toString().replaceAll(\"%\", \"%25\"));\n    }","id":88808,"modified_method":"/**\n     * Generate an url targeting attachment in provided wiki page.\n     *\n     * @param filename the name of the attachment.\n     * @param spaces a serialized space reference which can contain one or several spaces (e.g. \"space1.space2\"). If\n     *        a space name contains a dot (\".\") it must be passed escaped as in \"space1\\.with\\.dot.space2\"\n     * @param name the name of the page containing the attachment.\n     * @param xwikidb the wiki of the page containing the attachment.\n     * @param context the XWiki context.\n     * @return the generated url.\n     * @throws XWikiException error when retrieving document attachment.\n     * @throws IOException error when retrieving document attachment.\n     * @throws URISyntaxException when retrieving document attachment.\n     */\n    private URL createAttachmentURL(String filename, String spaces, String name, String xwikidb, XWikiContext context)\n        throws XWikiException, IOException, URISyntaxException\n    {\n        String db = (xwikidb == null ? context.getWikiId() : xwikidb);\n        DocumentReference documentReference =\n            new DocumentReference(db, this.legacySpaceResolver.resolve(spaces), name);\n        String serializedReference = this.pathEntityReferenceSerializer.serialize(\n            new AttachmentReference(filename, documentReference));\n        String path = \"attachment/\" + serializedReference;\n\n        File file = new File(getFilesystemExportContext().getExportDir(), path);\n        if (!file.exists()) {\n            XWikiDocument doc = context.getWiki().getDocument(documentReference, context);\n            XWikiAttachment attachment = doc.getAttachment(filename);\n            file.getParentFile().mkdirs();\n            FileOutputStream fos = new FileOutputStream(file);\n            IOUtils.copy(attachment.getContentInputStream(context), fos);\n            fos.close();\n        }\n\n        StringBuilder newPath = new StringBuilder(\"file://\");\n\n        // Adjust path for links inside CSS files (since they need to be relative to the CSS file they're in).\n        adjustCSSPath(newPath);\n\n        newPath.append(path);\n\n        // Since the returned URL is used in HTML links, we need to escape \"%\" characters so that browsers don't decode\n        // for example %2E as \".\" by default which would lead to the browser not finding the file on the filesystem.\n        return new URL(newPath.toString().replaceAll(\"%\", \"%25\"));\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Converts a URL to a relative URL if it's a XWiki URL (keeping only the path + query string + anchor) and leave\n     * the URL unchanged if it's an external URL.\n     * <p>\n     * An URL is considered to be external if its server component doesn't match the server of the current request URL.\n     * This means that URLs are made relative with respect to the current request URL rather than the current wiki set\n     * on the XWiki context. Let's take an example:\n     *\n     * <pre>\n     * {@code\n     * request URL: http://playground.xwiki.org/xwiki/bin/view/Sandbox/TestURL\n     * current wiki: code (code.xwiki.org)\n     * URL (1): http://code.xwiki.org/xwiki/bin/view/Main/WebHome\n     * URL (2): http://playground.xwiki.org/xwiki/bin/view/Spage/Page\n     * \n     * The result will be:\n     * (1) http://code.xwiki.org/xwiki/bin/view/Main/WebHome\n     * (2) /xwiki/bin/view/Spage/Page\n     * }\n     * <\/pre>\n     *\n     * @param url the URL to convert\n     * @return the converted URL as a string\n     * @see com.xpn.xwiki.web.XWikiDefaultURLFactory#getURL(java.net.URL, com.xpn.xwiki.XWikiContext)\n     */\n    @Override\n    public String getURL(URL url, XWikiContext context)\n    {\n        String relativeURL = \"\";\n\n        try {\n            if (url != null) {\n                String surl = url.toString();\n\n                if (!surl.startsWith(this.serverURL.toString())) {\n                    // External URL: leave it as is.\n                    relativeURL = surl;\n                } else {\n                    // Internal XWiki URL: convert to relative.\n                    StringBuffer sbuf = new StringBuffer(url.getPath());\n                    String querystring = url.getQuery();\n                    if (!StringUtils.isEmpty(querystring)) {\n                        sbuf.append(\"?\");\n                        sbuf.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, \"&\"), \"&amp;\"));\n                        // sbuf.append(querystring.replaceAll(\"&\",\"&amp;\"));\n                    }\n\n                    String anchor = url.getRef();\n                    if (!StringUtils.isEmpty(anchor)) {\n                        sbuf.append(\"#\");\n                        sbuf.append(anchor);\n                    }\n\n                    relativeURL = sbuf.toString();\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create URL\", e);\n        }\n\n        return StringUtils.defaultIfEmpty(relativeURL, \"/\");\n    }","id":88809,"modified_method":"/**\n     * Converts a URL to a relative URL if it's a XWiki URL (keeping only the path + query string + anchor) and leave\n     * the URL unchanged if it's an external URL.\n     * <p>\n     * An URL is considered to be external if its server component doesn't match the server of the current request URL.\n     * This means that URLs are made relative with respect to the current request URL rather than the current wiki set\n     * on the XWiki context. Let's take an example:\n     *\n     * <pre>\n     * {@code\n     * request URL: http://playground.xwiki.org/xwiki/bin/view/Sandbox/TestURL\n     * current wiki: code (code.xwiki.org)\n     * URL (1): http://code.xwiki.org/xwiki/bin/view/Main/WebHome\n     * URL (2): http://playground.xwiki.org/xwiki/bin/view/Spage/Page\n     * \n     * The result will be:\n     * (1) http://code.xwiki.org/xwiki/bin/view/Main/WebHome\n     * (2) /xwiki/bin/view/Spage/Page\n     * }\n     * <\/pre>\n     *\n     * @param url the URL to convert\n     * @return the converted URL as a string\n     * @see com.xpn.xwiki.web.XWikiDefaultURLFactory#getURL(java.net.URL, com.xpn.xwiki.XWikiContext)\n     */\n    @Override\n    public String getURL(URL url, XWikiContext context)\n    {\n        String relativeURL = \"\";\n\n        try {\n            if (url != null) {\n                String surl = url.toString();\n\n                if (!surl.startsWith(this.serverURL.toString())) {\n                    // External URL: leave it as is.\n                    relativeURL = surl;\n                } else {\n                    // Internal XWiki URL: convert to relative.\n                    StringBuilder relativeURLBuilder = new StringBuilder(url.getPath());\n                    String querystring = url.getQuery();\n                    if (!StringUtils.isEmpty(querystring)) {\n                        relativeURLBuilder.append(\"?\").append(\n                            StringUtils.removeEnd(StringUtils.removeEnd(querystring, \"&\"), \"&amp;\"));\n                    }\n\n                    String anchor = url.getRef();\n                    if (!StringUtils.isEmpty(anchor)) {\n                        relativeURLBuilder.append(\"#\").append(anchor);\n                    }\n\n                    relativeURL = relativeURLBuilder.toString();\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create URL\", e);\n        }\n\n        return StringUtils.defaultIfEmpty(relativeURL, \"/\");\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createResourceURL(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        if (forceSkinAction) {\n            addServletPath(newpath, context.getWikiId(), context);\n            addAction(newpath, null, \"skin\", context);\n        }\n        newpath.append(\"resources\");\n        addFileName(newpath, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(context), newpath.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","id":88810,"modified_method":"@Override\n    public URL createResourceURL(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        StringBuilder path = new StringBuilder(this.contextPath);\n        if (forceSkinAction) {\n            addServletPath(path, context.getWikiId(), context);\n            addAction(path, null, \"skin\", context);\n        }\n        path.append(\"resources\");\n        addFileName(path, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(context), path.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createSkinURL(String filename, String spaces, String name, String xwikidb, XWikiContext context)\n    {\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        addServletPath(newpath, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(newpath, null, \"skin\", context);\n        addSpaces(newpath, spaceReference, \"skin\", context);\n        addName(newpath, name, \"skin\", context);\n        addFileName(newpath, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(xwikidb, context), newpath.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","id":88811,"modified_method":"@Override\n    public URL createSkinURL(String filename, String spaces, String name, String xwikidb, XWikiContext context)\n    {\n        StringBuilder path = new StringBuilder(this.contextPath);\n        addServletPath(path, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(path, null, \"skin\", context);\n        addSpaces(path, spaceReference, \"skin\", context);\n        addName(path, name, \"skin\", context);\n        addFileName(path, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(xwikidb, context), path.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public URL createAttachmentRevisionURL(String filename, String spaces, String name, String revision,\n        long recycleId, String querystring, String xwikidb, XWikiContext context)\n    {\n        String action = \"downloadrev\";\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        addServletPath(newpath, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(newpath, spaceReference, action, context);\n        addSpaces(newpath, spaceReference, action, context);\n        addName(newpath, name, action, context);\n        addFileName(newpath, filename, context);\n\n        String qstring = \"rev=\" + revision;\n        if (recycleId >= 0) {\n            qstring += \"&rid=\" + recycleId;\n        }\n        if (!StringUtils.isEmpty(querystring)) {\n            qstring += \"&\" + querystring;\n        }\n        newpath.append(\"?\");\n        newpath.append(StringUtils.removeEnd(StringUtils.removeEnd(qstring, \"&\"), \"&amp;\"));\n\n        try {\n            return normalizeURL(new URL(getServerURL(xwikidb, context), newpath.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","id":88812,"modified_method":"public URL createAttachmentRevisionURL(String filename, String spaces, String name, String revision,\n        long recycleId, String querystring, String xwikidb, XWikiContext context)\n    {\n        String action = \"downloadrev\";\n        StringBuilder path = new StringBuilder(this.contextPath);\n        addServletPath(path, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(path, spaceReference, action, context);\n        addSpaces(path, spaceReference, action, context);\n        addName(path, name, action, context);\n        addFileName(path, filename, context);\n\n        String qstring = \"rev=\" + revision;\n        if (recycleId >= 0) {\n            qstring += \"&rid=\" + recycleId;\n        }\n        if (!StringUtils.isEmpty(querystring)) {\n            qstring += \"&\" + querystring;\n        }\n        path.append(\"?\");\n        path.append(StringUtils.removeEnd(StringUtils.removeEnd(qstring, \"&\"), \"&amp;\"));\n\n        try {\n            return normalizeURL(new URL(getServerURL(xwikidb, context), path.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public URL createTemplateURL(String filename, XWikiContext context)\n    {\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        newpath.append(\"templates\");\n        addFileName(newpath, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(context), newpath.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","id":88813,"modified_method":"public URL createTemplateURL(String fileName, XWikiContext context)\n    {\n        StringBuilder path = new StringBuilder(this.contextPath);\n        path.append(\"templates\");\n        addFileName(path, fileName, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(context), path.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void addSpaces(StringBuffer newpath, EntityReference spaceReference, String action, XWikiContext context)\n    {\n        for (EntityReference reference : spaceReference.getReversedReferenceChain()) {\n            appendSpacePathSegment(newpath, reference, context);\n        }\n    }","id":88814,"modified_method":"private void addSpaces(StringBuilder path, EntityReference spaceReference, String action, XWikiContext context)\n    {\n        for (EntityReference reference : spaceReference.getReversedReferenceChain()) {\n            appendSpacePathSegment(path, reference, context);\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createSkinURL(String filename, String skin, XWikiContext context)\n    {\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        newpath.append(\"skins/\");\n        newpath.append(skin);\n        addFileName(newpath, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(context), newpath.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","id":88815,"modified_method":"@Override\n    public URL createSkinURL(String filename, String skin, XWikiContext context)\n    {\n        StringBuilder path = new StringBuilder(this.contextPath);\n        path.append(\"skins/\");\n        path.append(skin);\n        addFileName(path, filename, false, context);\n        try {\n            return normalizeURL(new URL(getServerURL(context), path.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            return null;\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void addServletPath(StringBuffer newpath, String xwikidb, XWikiContext context)\n    {\n        if (xwikidb == null) {\n            xwikidb = context.getWikiId();\n        }\n\n        String spath = context.getWiki().getServletPath(xwikidb, context);\n        newpath.append(spath);\n    }","id":88816,"modified_method":"private void addServletPath(StringBuilder path, String xwikidb, XWikiContext context)\n    {\n        if (xwikidb == null) {\n            xwikidb = context.getWikiId();\n        }\n\n        path.append(context.getWiki().getServletPath(xwikidb, context));\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void addAction(StringBuffer newpath, EntityReference spaceReference, String action, XWikiContext context)\n    {\n        boolean showViewAction = context.getWiki().showViewAction(context);\n\n        // - Always output the action if it's not \"view\" or if showViewAction is true\n        // - Output \"view/<first space name>\" when the first space name is an action name and the action is View\n        // (and showViewAction = false)\n        if ((!\"view\".equals(action) || (showViewAction))\n            || (!showViewAction && spaceReference != null && \"view\".equals(action)\n            && this.actionLister.listActions().contains(\n                spaceReference.extractFirstReference(EntityType.SPACE).getName())))\n        {\n            newpath.append(action);\n            newpath.append(\"/\");\n        }\n    }","id":88817,"modified_method":"private void addAction(StringBuilder path, EntityReference spaceReference, String action, XWikiContext context)\n    {\n        boolean showViewAction = context.getWiki().showViewAction(context);\n\n        // - Always output the action if it's not \"view\" or if showViewAction is true\n        // - Output \"view/<first space name>\" when the first space name is an action name and the action is View\n        // (and showViewAction = false)\n        if ((!\"view\".equals(action) || (showViewAction))\n            || (!showViewAction && spaceReference != null && \"view\".equals(action)\n            && this.actionLister.listActions().contains(\n                spaceReference.extractFirstReference(EntityType.SPACE).getName())))\n        {\n            path.append(action).append(\"/\");\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createAttachmentURL(String filename, String spaces, String name, String action, String querystring,\n        String xwikidb, XWikiContext context)\n    {\n        if ((context != null) && \"viewrev\".equals(context.getAction()) && context.get(\"rev\") != null\n            && isContextDoc(xwikidb, spaces, name, context)) {\n            try {\n                String docRevision = context.get(\"rev\").toString();\n                XWikiAttachment attachment =\n                    findAttachmentForDocRevision(context.getDoc(), docRevision, filename, context);\n                if (attachment == null) {\n                    action = \"viewattachrev\";\n                } else {\n                    long arbId = findDeletedAttachmentForDocRevision(context.getDoc(), docRevision, filename, context);\n                    return createAttachmentRevisionURL(filename, spaces, name, attachment.getVersion(), arbId,\n                        querystring, xwikidb, context);\n                }\n            } catch (XWikiException e) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Exception while trying to get attachment version !\", e);\n                }\n            }\n        }\n\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        addServletPath(newpath, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(newpath, spaceReference, action, context);\n        addSpaces(newpath, spaceReference, action, context);\n        addName(newpath, name, action, context);\n        addFileName(newpath, filename, context);\n\n        if (!StringUtils.isEmpty(querystring)) {\n            newpath.append(\"?\");\n            newpath.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, \"&\"), \"&amp;\"));\n        }\n\n        try {\n            return normalizeURL(new URL(getServerURL(xwikidb, context), newpath.toString()), context);\n        } catch (Exception e) {\n            return null;\n        }\n    }","id":88818,"modified_method":"@Override\n    public URL createAttachmentURL(String filename, String spaces, String name, String action, String querystring,\n        String xwikidb, XWikiContext context)\n    {\n        if ((context != null) && \"viewrev\".equals(context.getAction()) && context.get(\"rev\") != null\n            && isContextDoc(xwikidb, spaces, name, context)) {\n            try {\n                String docRevision = context.get(\"rev\").toString();\n                XWikiAttachment attachment =\n                    findAttachmentForDocRevision(context.getDoc(), docRevision, filename, context);\n                if (attachment == null) {\n                    action = \"viewattachrev\";\n                } else {\n                    long arbId = findDeletedAttachmentForDocRevision(context.getDoc(), docRevision, filename, context);\n                    return createAttachmentRevisionURL(filename, spaces, name, attachment.getVersion(), arbId,\n                        querystring, xwikidb, context);\n                }\n            } catch (XWikiException e) {\n                if (LOGGER.isErrorEnabled()) {\n                    LOGGER.error(\"Exception while trying to get attachment version !\", e);\n                }\n            }\n        }\n\n        StringBuilder path = new StringBuilder(this.contextPath);\n        addServletPath(path, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(path, spaceReference, action, context);\n        addSpaces(path, spaceReference, action, context);\n        addName(path, name, action, context);\n        addFileName(path, filename, context);\n\n        if (!StringUtils.isEmpty(querystring)) {\n            path.append(\"?\");\n            path.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, \"&\"), \"&amp;\"));\n        }\n\n        try {\n            return normalizeURL(new URL(getServerURL(xwikidb, context), path.toString()), context);\n        } catch (Exception e) {\n            return null;\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void addFileName(StringBuffer newpath, String filename, boolean encode, XWikiContext context)\n    {\n        newpath.append(\"/\");\n        if (encode) {\n            newpath.append(encode(filename, context).replace(\"+\", \"%20\"));\n        } else {\n            newpath.append(filename);\n        }\n    }","id":88819,"modified_method":"protected void addFileName(StringBuilder path, String fileName, boolean encode, XWikiContext context)\n    {\n        path.append(\"/\");\n        if (encode) {\n            // Encode the given file name as a single path segment.\n            path.append(encode(fileName, context).replace(\"+\", \"%20\"));\n        } else {\n            try {\n                // The given file name is actually a file path and so we need to encode each path segment separately.\n                path.append(new URI(null, null, fileName, null));\n            } catch (URISyntaxException e) {\n                LOGGER.debug(\"Failed to encode the file path [{}]. Root cause: [{}]\", fileName,\n                    ExceptionUtils.getRootCauseMessage(e));\n                // Use the raw file path as a fall-back.\n                path.append(fileName);\n            }\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void addName(StringBuffer newpath, String name, String action, XWikiContext context)\n    {\n        XWiki xwiki = context.getWiki();\n        if ((xwiki.useDefaultAction(context))\n            || (!name.equals(xwiki.getDefaultPage(context)) || (!\"view\".equals(action)))) {\n            newpath.append(encode(name, context));\n        }\n    }","id":88820,"modified_method":"private void addName(StringBuilder path, String name, String action, XWikiContext context)\n    {\n        XWiki xwiki = context.getWiki();\n        if ((xwiki.useDefaultAction(context))\n            || (!name.equals(xwiki.getDefaultPage(context)) || (!\"view\".equals(action)))) {\n            path.append(encode(name, context));\n        }\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void appendSpacePathSegment(StringBuffer newpath, EntityReference spaceReference, XWikiContext context)\n    {\n        newpath.append(encode(spaceReference.getName(), context));\n        newpath.append('/');\n    }","id":88821,"modified_method":"private void appendSpacePathSegment(StringBuilder path, EntityReference spaceReference, XWikiContext context)\n    {\n        path.append(encode(spaceReference.getName(), context)).append('/');\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public URL createURL(String spaces, String name, String action, String querystring, String anchor, String xwikidb,\n        XWikiContext context)\n    {\n        // Action and Query String transformers\n        if ((\"view\".equals(action)) && (context.getLinksAction() != null)) {\n            action = context.getLinksAction();\n        }\n        if (context.getLinksQueryString() != null) {\n            if (querystring == null) {\n                querystring = context.getLinksQueryString();\n            } else {\n                querystring = querystring + \"&\" + context.getLinksQueryString();\n            }\n        }\n\n        StringBuffer newpath = new StringBuffer(this.contextPath);\n        addServletPath(newpath, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(newpath, spaceReference, action, context);\n        addSpaces(newpath, spaceReference, action, context);\n        addName(newpath, name, action, context);\n\n        if (!StringUtils.isEmpty(querystring)) {\n            newpath.append(\"?\");\n            newpath.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, \"&\"), \"&amp;\"));\n            // newpath.append(querystring.replaceAll(\"&\",\"&amp;\"));\n        }\n\n        if (!StringUtils.isEmpty(anchor)) {\n            newpath.append(\"#\");\n            newpath.append(encode(anchor, context));\n        }\n\n        URL result;\n        try {\n            result = normalizeURL(new URL(getServerURL(xwikidb, context), newpath.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            result = null;\n        }\n\n        return result;\n    }","id":88822,"modified_method":"@Override\n    public URL createURL(String spaces, String name, String action, String querystring, String anchor, String xwikidb,\n        XWikiContext context)\n    {\n        // Action and Query String transformers\n        if ((\"view\".equals(action)) && (context.getLinksAction() != null)) {\n            action = context.getLinksAction();\n        }\n        if (context.getLinksQueryString() != null) {\n            if (querystring == null) {\n                querystring = context.getLinksQueryString();\n            } else {\n                querystring = querystring + \"&\" + context.getLinksQueryString();\n            }\n        }\n\n        StringBuilder path = new StringBuilder(this.contextPath);\n        addServletPath(path, xwikidb, context);\n\n        // Parse the spaces list into Space References\n        EntityReference spaceReference = this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE);\n\n        addAction(path, spaceReference, action, context);\n        addSpaces(path, spaceReference, action, context);\n        addName(path, name, action, context);\n\n        if (!StringUtils.isEmpty(querystring)) {\n            path.append(\"?\");\n            path.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, \"&\"), \"&amp;\"));\n            // newpath.append(querystring.replaceAll(\"&\",\"&amp;\"));\n        }\n\n        if (!StringUtils.isEmpty(anchor)) {\n            path.append(\"#\");\n            path.append(encode(anchor, context));\n        }\n\n        URL result;\n        try {\n            result = normalizeURL(new URL(getServerURL(xwikidb, context), path.toString()), context);\n        } catch (MalformedURLException e) {\n            // This should not happen\n            result = null;\n        }\n\n        return result;\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void addFileName(StringBuffer newpath, String filename, XWikiContext context)\n    {\n        addFileName(newpath, filename, true, context);\n    }","id":88823,"modified_method":"protected void addFileName(StringBuilder path, String fileName, XWikiContext context)\n    {\n        addFileName(path, fileName, true, context);\n    }","commit_id":"dbfe97fe9097924452046edf5e4492d5cc186dcc","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void visit(Tree.SequenceEnumeration literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                // Continue the visit to collect the elements\n                Unit unit = literal.getUnit();\n                ProducedType iteratedType = unit.getIteratedType(literal.getTypeModel());\n                TypeDeclaration declaration = iteratedType.getDeclaration();\n                LiteralAnnotationTerm factory;\n                if (unit.getStringDeclaration().equals(declaration)) {\n                    factory = new StringLiteralAnnotationTerm(null);\n                } else if (unit.getIntegerDeclaration().equals(declaration)) {\n                    factory = new IntegerLiteralAnnotationTerm(0);\n                } else if (unit.getCharacterDeclaration().equals(declaration)) {\n                    factory = new CharacterLiteralAnnotationTerm(0);\n                } else if (unit.getBooleanDeclaration().equals(declaration)) {\n                    factory = new BooleanLiteralAnnotationTerm(false);\n                } else if (unit.getFloatDeclaration().equals(declaration)) {\n                    factory = new FloatLiteralAnnotationTerm(0.0);\n                } else if (Decl.isEnumeratedTypeWithAnonCases(iteratedType)) {\n                    factory = new ObjectLiteralAnnotationTerm(null);\n                } else {//if (iteratedType.isExactly(unit.getMetamodelDeclarationDeclaration().getType())) {\n                    factory = new DeclarationLiteralAnnotationTerm(null);\n                } /*else {\n                    throw new RuntimeException();\n                }*/\n                this.elements = new CollectionLiteralAnnotationTerm(factory);\n                literal.visitChildren(this);\n                this.term = this.elements;\n                this.elements = null;\n                ((CollectionLiteralAnnotationTerm)this.term).setTerm(literal);\n                appendLiteralArgument(literal, (CollectionLiteralAnnotationTerm)term);\n            }\n        }\n    }","id":88824,"modified_method":"public void visit(Tree.SequenceEnumeration literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                // Continue the visit to collect the elements\n                Unit unit = literal.getUnit();\n                ProducedType iteratedType = unit.getIteratedType(literal.getTypeModel());\n                TypeDeclaration declaration = iteratedType.getDeclaration();\n                LiteralAnnotationTerm factory;\n                if (unit.getStringDeclaration().equals(declaration)) {\n                    factory = new StringLiteralAnnotationTerm(null);\n                } else if (unit.getIntegerDeclaration().equals(declaration)) {\n                    factory = new IntegerLiteralAnnotationTerm(0, null);\n                } else if (unit.getCharacterDeclaration().equals(declaration)) {\n                    factory = new CharacterLiteralAnnotationTerm(0);\n                } else if (unit.getBooleanDeclaration().equals(declaration)) {\n                    factory = new BooleanLiteralAnnotationTerm(false);\n                } else if (unit.getFloatDeclaration().equals(declaration)) {\n                    factory = new FloatLiteralAnnotationTerm(0.0);\n                } else if (Decl.isEnumeratedTypeWithAnonCases(iteratedType)) {\n                    factory = new ObjectLiteralAnnotationTerm(null);\n                } else {//if (iteratedType.isExactly(unit.getMetamodelDeclarationDeclaration().getType())) {\n                    factory = new DeclarationLiteralAnnotationTerm(null);\n                } /*else {\n                    throw new RuntimeException();\n                }*/\n                this.elements = new CollectionLiteralAnnotationTerm(factory);\n                literal.visitChildren(this);\n                this.term = this.elements;\n                this.elements = null;\n                ((CollectionLiteralAnnotationTerm)this.term).setTerm(literal);\n                appendLiteralArgument(literal, (CollectionLiteralAnnotationTerm)term);\n            }\n        }\n    }","commit_id":"68245415e9b9199744e1ada57b04a253dd2f5d5e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(Tree.NaturalLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                try {\n                    LiteralAnnotationTerm argument = new IntegerLiteralAnnotationTerm(ExpressionTransformer.literalValue(literal));\n                    argument.setTerm(literal);\n                    appendLiteralArgument(literal, argument);\n                } catch (ErroneousException e) {\n                    // Ignore it: The ExpressionTransformer will produce an error later in codegen\n                }\n            }\n        }\n    }","id":88825,"modified_method":"public void visit(Tree.NaturalLiteral literal) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                try {\n                    LiteralAnnotationTerm argument = new IntegerLiteralAnnotationTerm(ExpressionTransformer.literalValue(literal), parameter().getModel().getType());\n                    argument.setTerm(literal);\n                    appendLiteralArgument(literal, argument);\n                } catch (ErroneousException e) {\n                    // Ignore it: The ExpressionTransformer will produce an error later in codegen\n                }\n            }\n        }\n    }","commit_id":"68245415e9b9199744e1ada57b04a253dd2f5d5e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void visit(Tree.NegativeOp op) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                try {\n                    if (op.getTerm() instanceof Tree.NaturalLiteral) {\n                        LiteralAnnotationTerm argument = new IntegerLiteralAnnotationTerm(ExpressionTransformer.literalValue(op));\n                        argument.setTerm(op);\n                        appendLiteralArgument(op, argument);\n                    } else if (op.getTerm() instanceof Tree.FloatLiteral) {\n                        LiteralAnnotationTerm argument = new FloatLiteralAnnotationTerm(-ExpressionTransformer.literalValue((Tree.FloatLiteral)op.getTerm()));\n                        argument.setTerm(op);\n                        appendLiteralArgument(op, argument);\n                    }\n                } catch (ErroneousException e) {\n                    // Ignore it: The ExpressionTransformer will produce an error later in codegen\n                }\n            }\n        }\n    }","id":88826,"modified_method":"public void visit(Tree.NegativeOp op) {\n        if (annotationConstructor != null) {\n            if (checkingArguments || checkingDefaults){\n                try {\n                    if (op.getTerm() instanceof Tree.NaturalLiteral) {\n                        LiteralAnnotationTerm argument = new IntegerLiteralAnnotationTerm(ExpressionTransformer.literalValue(op), parameter().getModel().getType());\n                        argument.setTerm(op);\n                        appendLiteralArgument(op, argument);\n                    } else if (op.getTerm() instanceof Tree.FloatLiteral) {\n                        LiteralAnnotationTerm argument = new FloatLiteralAnnotationTerm(-ExpressionTransformer.literalValue((Tree.FloatLiteral)op.getTerm()));\n                        argument.setTerm(op);\n                        appendLiteralArgument(op, argument);\n                    }\n                } catch (ErroneousException e) {\n                    // Ignore it: The ExpressionTransformer will produce an error later in codegen\n                }\n            }\n        }\n    }","commit_id":"68245415e9b9199744e1ada57b04a253dd2f5d5e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public IntegerLiteralAnnotationTerm(long value) {\n        super();\n        this.value = value;\n    }","id":88827,"modified_method":"public IntegerLiteralAnnotationTerm(long value, ProducedType producedType) {\n        super();\n        this.value = value;\n        this.producedType = producedType;\n    }","commit_id":"68245415e9b9199744e1ada57b04a253dd2f5d5e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public JCExpression makeLiteral(ExpressionTransformer exprGen) {\n        return exprGen.make().Literal(value);\n    }","id":88828,"modified_method":"@Override\n    public JCExpression makeLiteral(ExpressionTransformer exprGen) {\n        return producedType != null && \"int\".equals(producedType.getUnderlyingType()) ? exprGen.make().Literal((int)value) : exprGen.make().Literal(value);\n    }","commit_id":"68245415e9b9199744e1ada57b04a253dd2f5d5e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected abstract JCStatement transformInnermostElse(Cond transformedCond);","id":88829,"modified_method":"protected abstract JCStatement transformInnermostElse(Cond transformedCond, java.util.List<Condition> rest);","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public IfCondList(java.util.List<Condition> conditions, Block thenPart,\n                Block elsePart) {\n            super(conditions, thenPart);\n            this.elsePart = elsePart;\n        }","id":88830,"modified_method":"protected abstract JCStatement transformIntermediateElse(Cond transformedCond, java.util.List<Condition> rest);","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        public List<JCStatement> getResult() {\n            List<JCStatement> stmts = transformList(conditions);\n            ListBuffer<JCStatement> result = ListBuffer.lb();\n            result.append(makeVar(messageSb, make().Type(syms().stringType), makeNull()));\n            result.appendList(varDecls);\n            result.appendList(stmts);\n            JCExpression message = prependFailureMessage(appendLocation(messageSb.makeIdent(), ass), ass);\n            result.append(make().If(\n                    make().Binary(JCTree.NE, messageSb.makeIdent(), makeNull()), \n                    makeThrowAssertionFailure(message), null));\n            return result.toList();   \n        }","id":88831,"modified_method":"@Override\n        public List<JCStatement> getResult() {\n            List<JCStatement> stmts = transformList(conditions);\n            ListBuffer<JCStatement> result = ListBuffer.lb();\n            if (isMulti()) {\n                result.append(makeVar(messageSb, make().Type(syms().stringType), makeNull()));\n            }\n            result.appendList(varDecls);\n            result.appendList(stmts);\n            JCExpression message = prependFailureMessage(appendLocation(messageSb.makeIdent(), ass), ass);\n            JCThrow throw_ = makeThrowAssertionFailure(message);\n            if (isMulti()) {\n                result.append(make().If(\n                        make().Binary(JCTree.NE, messageSb.makeIdent(), makeNull()), \n                        throw_, null));\n            }\n            return result.toList();   \n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected List<JCStatement> transformCommon(Cond cond, List<JCStatement> stmts, java.util.List<Tree.Condition> rest) {\n            if (cond.hasAliasedVariable()) {\n                unassignedResultVars = unassignedResultVars.append(cond);\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        cond.getVariableName().asName(), \n                        cond.makeTypeExpr(), null);\n                varDecls.append(resultVarDecl);\n                stmts = stmts.prepend(make().Exec(make().Assign(cond.getVariableName().makeIdent(), cond.makeResultExpr())));\n            }\n            List<JCStatement> elseStmts = List.<JCStatement>nil();\n            for (Cond resultVar : unassignedResultVars) {\n                \n                elseStmts = elseStmts.append(make().Exec(make().Assign(resultVar.getVariableName().makeIdent(), \n                        ((SpecialFormCond)resultVar).makeDefaultExpr())));    \n            }\n            elseStmts = elseStmts.append(make().If(make().Binary(JCTree.EQ, messageSb.makeIdent(), makeNull()), \n                    make().Exec(make().Assign(messageSb.makeIdent(), make().Literal(\"\"))), \n                    null));\n            elseStmts = elseStmts.append(\n                    make().Exec(appendViolation(messageSb, cond)));\n            for (Tree.Condition condition : rest) {\n                Cond forwardCond = this.conds.get(condition);\n                if (!forwardCond.hasResultDecl()) {\n                    elseStmts = elseStmts.append(\n                        make().If(make().Unary(JCTree.NOT, forwardCond.makeTest()),\n                                make().Exec(appendViolation(messageSb, forwardCond)),\n                                        null));\n                } else {\n                    break;\n                }\n            }\n            \n            \n            stmts = List.<JCStatement>of(make().If(\n                    cond.makeTest(), \n                    make().Block(0, stmts), \n                    elseStmts.isEmpty() ? null : make().Block(0, elseStmts)));\n            \n            if (cond.makeTestVarDecl(0, true) != null) {\n                stmts = stmts.prepend(cond.makeTestVarDecl(0, true));\n            }\n            return stmts;\n        }","id":88832,"modified_method":"@Override\n        protected List<JCStatement> transformCommon(Cond cond, \n                java.util.List<Condition> rest, \n                JCExpression test, List<JCStatement> stmts, JCStatement elseBlock) {\n            if (cond.hasResultDecl()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        cond.getVariableName().asName(), \n                        cond.makeTypeExpr(), \n                        null);\n                // Note we capture the substitution here, because it won't be \n                // in scope when we generate the default assignment branches.\n                unassignedResultVars.put(cond, \n                        cond.getVariableName().capture());\n                varDecls.append(resultVarDecl);\n                stmts = stmts.prepend(make().Exec(make().Assign(cond.getVariableName().makeIdent(), cond.makeResultExpr())));\n            }\n            \n            if (isMulti()) {\n                List<JCStatement> elseStmts = ((JCBlock)elseBlock).getStatements();\n                for (Cond unassigned : unassignedResultVars.keySet()) {\n                    elseStmts = elseStmts.prepend(\n                            make().Exec(make().Assign(unassignedResultVars.get(unassigned).makeIdent(), \n                            ((SpecialFormCond)unassigned).makeDefaultExpr())));\n                }\n                elseBlock = make().Block(0, elseStmts);\n            }\n            stmts = List.<JCStatement>of(make().If(\n                    test, \n                    make().Block(0, stmts), \n                    elseBlock));\n            \n            if (cond.makeTestVarDecl(0, true) != null) {\n                stmts = stmts.prepend(cond.makeTestVarDecl(0, true));\n            }\n            return stmts;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected JCStatement transformInnermostElse(Cond transformedCond) {\n            return make().Break(null);\n        }","id":88833,"modified_method":"@Override\n        protected JCStatement transformInnermostElse(Cond transformedCond, java.util.List<Condition> rest) {\n            return make().Break(null);\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected JCStatement transformInnermostElse(Cond transformedCond) {\n            JCBlock elseBlock = null;\n            if (!isDeferred()) {\n                elseBlock = transform(this.elsePart);\n            }\n            return elseBlock;\n        }","id":88834,"modified_method":"@Override\n        protected JCStatement transformInnermostElse(Cond transformedCond, java.util.List<Condition> rest) {\n            JCBlock elseBlock = null;\n            if (!isDeferred()) {\n                elseBlock = transform(this.elsePart);\n            }\n            return elseBlock;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected List<JCStatement> transformInnermost(Tree.Condition condition) {\n            Cond transformedCond = transformCondition(condition, null);\n            List<JCStatement> stmts = List.<JCStatement>nil();\n            return transformCommon(transformedCond, stmts, Collections.<Tree.Condition>emptyList());\n        }","id":88835,"modified_method":"@Override\n        protected List<JCStatement> transformInnermostThen(Cond cond) {\n            return List.nil();\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected final List<JCStatement> transformInnermost(Condition condition) {\n            Cond transformedCond = transformCondition(condition, thenPart);\n            // Note: The innermost test happens outside the substitution scope\n            JCExpression test = transformedCond.makeTest();\n            JCStatement elseBlock = transformInnermostElse(transformedCond);\n            Substitution subs = getSubstitution(transformedCond);\n            List<JCStatement> stmts = transformInnermostThen(transformedCond);\n            stmts = transformCommon(transformedCond, test, stmts, elseBlock);\n            if (subs != null) {\n                subs.remove();\n            }\n            return stmts;\n        }","id":88836,"modified_method":"@Override\n        protected final List<JCStatement> transformInnermost(Condition condition) {\n            Cond transformedCond = transformCondition(condition, thenPart);\n            // Note: The innermost test happens outside the substitution scope\n            JCExpression test = transformedCond.makeTest();\n            java.util.List<Condition> rest = Collections.<Condition>emptyList();\n            JCStatement elseBlock = transformInnermostElse(transformedCond, rest);\n            Substitution subs = getSubstitution(transformedCond);\n            List<JCStatement> stmts = transformInnermostThen(transformedCond);\n            stmts = transformCommon(transformedCond, rest, test, \n                    stmts, elseBlock);\n            if (subs != null) {\n                subs.remove();\n            }\n            return stmts;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public AssertCondList(Tree.Assertion ass) {\n            super(ass.getConditionList().getConditions(), null);\n            this.ass = ass;\n            this.conds = new HashMap<>(ass.getConditionList().getConditions().size());\n            for (Tree.Condition condition : ass.getConditionList().getConditions()) {\n                this.conds.put(condition, transformCondition(condition, null));   \n            }\n        }","id":88837,"modified_method":"public AssertCondList(Tree.Assertion ass) {\n            super(ass.getConditionList().getConditions(), null);\n            this.ass = ass;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected List<JCStatement> transformIntermediate(Condition condition, java.util.List<Condition> rest) {\n            Cond intermediate = transformCondition(condition, null);\n            JCExpression test = intermediate.makeTest();\n            Substitution subs = getSubstitution(intermediate);\n            List<JCStatement> stmts = transformList(rest);\n            stmts = transformCommon(intermediate, test, stmts, transformIntermediateElse());\n            if (subs != null) {\n                subs.remove();\n            }\n            return stmts;\n        }","id":88838,"modified_method":"@Override\n        protected List<JCStatement> transformIntermediate(Condition condition, java.util.List<Condition> rest) {\n            Cond intermediate = transformCondition(condition, null);\n            JCExpression test = intermediate.makeTest();\n            Substitution subs = getSubstitution(intermediate);\n            List<JCStatement> stmts = transformList(rest);\n            JCStatement intermediateElse = transformIntermediateElse(intermediate, rest);\n            stmts = transformCommon(intermediate, rest, test, \n                    stmts, intermediateElse);\n            if (subs != null) {\n                subs.remove();\n            }\n            return stmts;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected List<JCStatement> transformIntermediate(Tree.Condition condition, java.util.List<Tree.Condition> rest) {\n            return transformCommon(transformCondition(condition, null), transformList(rest), rest);\n        }","id":88839,"modified_method":"@Override\n        protected JCStatement transformIntermediateElse(Cond cond, java.util.List<Condition> rest) {\n            return transformCommonElse(cond, rest);\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected abstract List<JCStatement> transformCommon(Cond transformedCond, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock);","id":88840,"modified_method":"protected abstract List<JCStatement> transformCommon(Cond transformedCond, java.util.List<Condition> rest, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock);","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected List<JCStatement> transformCommon(Cond transformedCond, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock) {\n            if (transformedCond.makeTestVarDecl(0, false) != null) {\n                varDecls.append(transformedCond.makeTestVarDecl(0, false));\n            }\n            if (transformedCond.hasResultDecl()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        transformedCond.getVariableName().asName(), \n                        transformedCond.makeTypeExpr(), \n                        transformedCond.makeResultExpr());\n                stmts = stmts.prepend(resultVarDecl);\n            }\n            JCStatement elsePart = elseBlock;\n            stmts = List.<JCStatement>of(make().If(\n                    test, \n                    make().Block(0, stmts), \n                    elsePart));\n            return stmts;\n        }","id":88841,"modified_method":"@Override\n        protected List<JCStatement> transformCommon(Cond transformedCond, \n                java.util.List<Condition> rest, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock) {\n            if (transformedCond.makeTestVarDecl(0, false) != null) {\n                varDecls.append(transformedCond.makeTestVarDecl(0, false));\n            }\n            if (transformedCond.hasResultDecl()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        transformedCond.getVariableName().asName(), \n                        transformedCond.makeTypeExpr(), \n                        transformedCond.makeResultExpr());\n                stmts = stmts.prepend(resultVarDecl);\n            }\n            JCStatement elsePart = elseBlock;\n            stmts = List.<JCStatement>of(make().If(\n                    test, \n                    make().Block(0, stmts), \n                    elsePart));\n            return stmts;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"List<JCStatement> transform(Tree.Assertion ass) {\n        java.util.List<Condition> conditions = ass.getConditionList().getConditions();\n        if (conditions.size() == 1) {\n            return transformSingleAssertion(ass, conditions);\n        } else {\n            return new AssertCondList(ass).getResult();\n        }    \n    }","id":88842,"modified_method":"List<JCStatement> transform(Tree.Assertion ass) {\n        return new AssertCondList(ass).getResult();        \n    }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        protected List<JCStatement> transformCommon(Cond transformedCond, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock) {\n            if (transformedCond.makeTestVarDecl(0, false) != null) {\n                varDecls.append(transformedCond.makeTestVarDecl(0, false));\n            }\n            if (transformedCond.hasResultDecl()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        transformedCond.getVariableName().asName(), \n                        transformedCond.makeTypeExpr(), \n                        isDeferred() ? null : transformedCond.makeResultExpr());\n                if (isDeferred()) {\n                    // Note we capture the substitution here, because it won't be \n                    // in scope when we generate the default assignment branches.\n                    unassignedResultVars.put(transformedCond, \n                            transformedCond.getVariableName().capture());\n                    varDecls.append(resultVarDecl);\n                    stmts = stmts.prepend(make().Exec(make().Assign(transformedCond.getVariableName().makeIdent(), transformedCond.makeResultExpr())));\n                } else {\n                    stmts = stmts.prepend(resultVarDecl);\n                }\n            }\n            JCStatement elsePart;\n            if (isDeferred()) {\n                List<JCStatement> assignDefault = List.<JCStatement>nil();\n                for (Cond unassigned : unassignedResultVars.keySet()) {\n                    assignDefault = assignDefault.append(\n                            make().Exec(make().Assign(unassignedResultVars.get(unassigned).makeIdent(), \n                            ((SpecialFormCond)unassigned).makeDefaultExpr())));\n                }\n                elsePart = assignDefault.isEmpty() ? null : make().Block(0, assignDefault);\n            } else {\n                elsePart = elseBlock;\n            }\n            stmts = List.<JCStatement>of(make().If(\n                    test, \n                    make().Block(0, stmts), \n                    elsePart));\n            return stmts;\n        }","id":88843,"modified_method":"@Override\n        protected List<JCStatement> transformCommon(Cond transformedCond, \n                java.util.List<Condition> rest, JCExpression test, List<JCStatement> stmts, JCStatement elseBlock) {\n            if (transformedCond.makeTestVarDecl(0, false) != null) {\n                varDecls.append(transformedCond.makeTestVarDecl(0, false));\n            }\n            if (transformedCond.hasResultDecl()) {\n                JCVariableDecl resultVarDecl = make().VarDef(make().Modifiers(Flags.FINAL), \n                        transformedCond.getVariableName().asName(), \n                        transformedCond.makeTypeExpr(), \n                        isDeferred() ? null : transformedCond.makeResultExpr());\n                if (isDeferred()) {\n                    // Note we capture the substitution here, because it won't be \n                    // in scope when we generate the default assignment branches.\n                    unassignedResultVars.put(transformedCond, \n                            transformedCond.getVariableName().capture());\n                    varDecls.append(resultVarDecl);\n                    stmts = stmts.prepend(make().Exec(make().Assign(transformedCond.getVariableName().makeIdent(), transformedCond.makeResultExpr())));\n                } else {\n                    stmts = stmts.prepend(resultVarDecl);\n                }\n            }\n            JCStatement elsePart;\n            if (isDeferred()) {\n                List<JCStatement> assignDefault = List.<JCStatement>nil();\n                for (Cond unassigned : unassignedResultVars.keySet()) {\n                    assignDefault = assignDefault.append(\n                            make().Exec(make().Assign(unassignedResultVars.get(unassigned).makeIdent(), \n                            ((SpecialFormCond)unassigned).makeDefaultExpr())));\n                }\n                elsePart = assignDefault.isEmpty() ? null : make().Block(0, assignDefault);\n            } else {\n                elsePart = elseBlock;\n            }\n            stmts = List.<JCStatement>of(make().If(\n                    test, \n                    make().Block(0, stmts), \n                    elsePart));\n            return stmts;\n        }","commit_id":"7d0fc77ddfd71cb26225901ae205a9d98064d359","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tannotationModel.addAnnotationModelListener(this);\n\t\tthis.xtextDocument = xtextDocument;\n\t}","id":88844,"modified_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tif (annotationModel != null)\n\t\t\tannotationModel.addAnnotationModelListener(this);\n\t\tthis.xtextDocument = xtextDocument;\n\t}","commit_id":"baf4873f7160ba9f63957f2df3f61580c7a02c35","url":"https://github.com/eclipse/xtext"},{"original_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tannotationModel.addAnnotationModelListener(this);\n\t\tthis.xtextDocument = xtextDocument;\n\t}","id":88845,"modified_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tif (annotationModel != null)\n\t\t\tannotationModel.addAnnotationModelListener(this);\n\t\tthis.xtextDocument = xtextDocument;\n\t}","commit_id":"e7c1350ea65a00318bb1db10b012304d995f86ff","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprotected Severity getSeverity(XtextEditor xtextEditor) {\n\t\tIAnnotationModel model = xtextEditor.getInternalSourceViewer().getAnnotationModel();\n\t\tIterator<Annotation> iterator = model.getAnnotationIterator();\n\t\tboolean hasWarnings = false;\n\t\twhile (iterator.hasNext()) {\n\t\t\tIssue issue = issueUtil.getIssueFromAnnotation(iterator.next());\n\t\t\tif (issue != null) {\n\t\t\t\tif (issue.getSeverity() == Severity.ERROR) {\n\t\t\t\t\treturn Severity.ERROR;\n\t\t\t\t} else if (issue.getSeverity() == Severity.WARNING) {\n\t\t\t\t\thasWarnings = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasWarnings?Severity.WARNING:null;\n\t}","id":88846,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprotected Severity getSeverity(XtextEditor xtextEditor) {\n\t\tIAnnotationModel model = xtextEditor.getInternalSourceViewer().getAnnotationModel();\n\t\tif (model != null) {\n\t\t\tIterator<Annotation> iterator = model.getAnnotationIterator();\n\t\t\tboolean hasWarnings = false;\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tIssue issue = issueUtil.getIssueFromAnnotation(iterator.next());\n\t\t\t\tif (issue != null) {\n\t\t\t\t\tif (issue.getSeverity() == Severity.ERROR) {\n\t\t\t\t\t\treturn Severity.ERROR;\n\t\t\t\t\t} else if (issue.getSeverity() == Severity.WARNING) {\n\t\t\t\t\t\thasWarnings = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hasWarnings?Severity.WARNING:null;\n\t\t}\n\t\treturn null;\n\t}","commit_id":"2c9858fe4139cee3673b2d52d867d3736a023380","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void afterCreatePartControl(XtextEditor xtextEditor) {\n\t\teditor = xtextEditor;\n\t\tdefaultImage = xtextEditor.getDefaultImage();\n\t\tupdateEditorImage(xtextEditor);\n\t\tannotationModel = xtextEditor.getInternalSourceViewer().getAnnotationModel();\n\t\tannotationModel.addAnnotationModelListener(this);\n\t}","id":88847,"modified_method":"@Override\n\tpublic void afterCreatePartControl(XtextEditor xtextEditor) {\n\t\teditor = xtextEditor;\n\t\tdefaultImage = xtextEditor.getDefaultImage();\n\t\tupdateEditorImage(xtextEditor);\n\t\tannotationModel = xtextEditor.getInternalSourceViewer().getAnnotationModel();\n\t\tif (annotationModel != null)\n\t\t\tannotationModel.addAnnotationModelListener(this);\n\t}","commit_id":"2c9858fe4139cee3673b2d52d867d3736a023380","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n   * Tests the capability to fall back to a ufs stream when getting a tachyon stream fails.\n   */\n  @Test\n  public void failToUnderFsTest() throws IOException {\n    mInfo.setIsPersisted(true).setUfsPath(\"testUfsPath\");\n    mTestStream = new FileInStream(mInfo, InStreamOptions.defaults());\n    Whitebox.setInternalState(mTestStream, \"mContext\", mContext);\n\n    Mockito.when(mBlockStore.getInStream(1L)).thenThrow(new IOException(\"test IOException\"));\n    UnderFileSystem ufs = ClientMockUtils.mockUnderFileSystem(Mockito.eq(\"testUfsPath\"));\n    InputStream stream = Mockito.mock(InputStream.class);\n    Mockito.when(ufs.open(\"testUfsPath\")).thenReturn(stream);\n    Mockito.when(stream.skip(BLOCK_LENGTH)).thenReturn(BLOCK_LENGTH);\n    Mockito.when(stream.skip(BLOCK_LENGTH / 2)).thenReturn(BLOCK_LENGTH / 2);\n\n    mTestStream.seek(BLOCK_LENGTH + (BLOCK_LENGTH / 2));\n    Mockito.verify(ufs, Mockito.times(1)).open(\"testUfsPath\");\n    Mockito.verify(stream, Mockito.times(1)).skip(100);\n    Mockito.verify(stream, Mockito.times(1)).skip(50);\n  }","id":88848,"modified_method":"/**\n   * Tests the capability to fall back to a ufs stream when getting a tachyon stream fails.\n   */\n  @Test\n  public void failToUnderFsTest() throws IOException {\n    mInfo.setIsPersisted(true).setUfsPath(\"testUfsPath\");\n    Whitebox.setInternalState(FileSystemContext.class, \"INSTANCE\", mContext);\n    mTestStream = new FileInStream(mInfo, InStreamOptions.defaults());\n\n    Mockito.when(mBlockStore.getInStream(1L)).thenThrow(new IOException(\"test IOException\"));\n    UnderFileSystem ufs = ClientMockUtils.mockUnderFileSystem(Mockito.eq(\"testUfsPath\"));\n    InputStream stream = Mockito.mock(InputStream.class);\n    Mockito.when(ufs.open(\"testUfsPath\")).thenReturn(stream);\n    Mockito.when(stream.skip(BLOCK_LENGTH)).thenReturn(BLOCK_LENGTH);\n    Mockito.when(stream.skip(BLOCK_LENGTH / 2)).thenReturn(BLOCK_LENGTH / 2);\n\n    mTestStream.seek(BLOCK_LENGTH + (BLOCK_LENGTH / 2));\n    Mockito.verify(ufs, Mockito.times(1)).open(\"testUfsPath\");\n    Mockito.verify(stream, Mockito.times(1)).skip(100);\n    Mockito.verify(stream, Mockito.times(1)).skip(50);\n  }","commit_id":"8c59ef96c29e034cb9247f7beb8c1a407dd54021","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n  public void before() throws IOException {\n    mInfo = new FileInfo().setBlockSizeBytes(BLOCK_LENGTH).setLength(FILE_LENGTH);\n\n    ClientTestUtils.setSmallBufferSizes();\n\n    mContext = PowerMockito.mock(FileSystemContext.class);\n    mBlockStore = PowerMockito.mock(TachyonBlockStore.class);\n    Mockito.when(mContext.getTachyonBlockStore()).thenReturn(mBlockStore);\n\n    // Set up BufferedBlockInStreams and caching streams\n    mCacheStreams = Lists.newArrayList();\n    List<Long> blockIds = Lists.newArrayList();\n    for (int i = 0; i < NUM_STREAMS; i ++) {\n      blockIds.add((long) i);\n      mCacheStreams.add(new TestBufferedBlockOutStream(i, BLOCK_LENGTH));\n      Mockito.when(mBlockStore.getInStream(i)).thenAnswer(new Answer<BufferedBlockInStream>() {\n        @Override\n        public BufferedBlockInStream answer(InvocationOnMock invocation) throws Throwable {\n          long i = (Long) invocation.getArguments()[0];\n          return new TestBufferedBlockInStream(i, (int) (i * BLOCK_LENGTH), BLOCK_LENGTH);\n        }\n      });\n\n      Mockito\n          .when(\n              mBlockStore.getOutStream(Mockito.eq((long) i), Mockito.eq(-1L), Mockito.anyString()))\n          .thenReturn(mCacheStreams.get(i));\n    }\n    mInfo.setBlockIds(blockIds);\n\n    mTestStream = new FileInStream(mInfo, new InStreamOptions.Builder(ClientContext.getConf())\n        .setTachyonStorageType(TachyonStorageType.PROMOTE).build());\n    Whitebox.setInternalState(mTestStream, \"mContext\", mContext);\n  }","id":88849,"modified_method":"@Before\n  public void before() throws IOException {\n    mInfo = new FileInfo().setBlockSizeBytes(BLOCK_LENGTH).setLength(FILE_LENGTH);\n\n    ClientTestUtils.setSmallBufferSizes();\n\n    mContext = PowerMockito.mock(FileSystemContext.class);\n    mBlockStore = PowerMockito.mock(TachyonBlockStore.class);\n    Mockito.when(mContext.getTachyonBlockStore()).thenReturn(mBlockStore);\n\n    // Set up BufferedBlockInStreams and caching streams\n    mCacheStreams = Lists.newArrayList();\n    List<Long> blockIds = Lists.newArrayList();\n    for (int i = 0; i < NUM_STREAMS; i ++) {\n      blockIds.add((long) i);\n      mCacheStreams.add(new TestBufferedBlockOutStream(i, BLOCK_LENGTH));\n      Mockito.when(mBlockStore.getInStream(i)).thenAnswer(new Answer<BufferedBlockInStream>() {\n        @Override\n        public BufferedBlockInStream answer(InvocationOnMock invocation) throws Throwable {\n          long i = (Long) invocation.getArguments()[0];\n          return new TestBufferedBlockInStream(i, (int) (i * BLOCK_LENGTH), BLOCK_LENGTH);\n        }\n      });\n\n      Mockito\n          .when(\n              mBlockStore.getOutStream(Mockito.eq((long) i), Mockito.eq(-1L), Mockito.anyString()))\n          .thenReturn(mCacheStreams.get(i));\n    }\n    mInfo.setBlockIds(blockIds);\n\n    Whitebox.setInternalState(FileSystemContext.class, \"INSTANCE\", mContext);\n    mTestStream = new FileInStream(mInfo, new InStreamOptions.Builder(ClientContext.getConf())\n        .setTachyonStorageType(TachyonStorageType.PROMOTE).build());\n  }","commit_id":"8c59ef96c29e034cb9247f7beb8c1a407dd54021","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void close() throws IOException {\n    if (mClosed) {\n      return;\n    }\n    if (mCurrentBlockOutStream != null) {\n      mPreviousBlockOutStreams.add(mCurrentBlockOutStream);\n    }\n\n    Boolean canComplete = false;\n    if (mUnderStorageType.isSyncPersist()) {\n      if (mCanceled) {\n        // TODO(yupeng): Handle this special case in under storage integrations.\n        mUnderStorageOutputStream.close();\n        String tmpPath = PathUtils.temporaryFileName(mFileId, mNonce, mUfsPath);\n        UnderFileSystem ufs = UnderFileSystem.get(tmpPath, ClientContext.getConf());\n        if (!ufs.exists(tmpPath)) {\n          FileInfo fileInfo = getFileInfo();\n          mUfsPath = fileInfo.getUfsPath();\n          tmpPath = PathUtils.temporaryFileName(mFileId, mNonce, mUfsPath);\n        }\n        ufs.delete(tmpPath, false);\n      } else {\n        mUnderStorageOutputStream.flush();\n        mUnderStorageOutputStream.close();\n        WorkerClient workerClient = mBlockStoreContext.acquireWorkerClient();\n        try {\n          // TODO(yupeng): Investigate if this RPC can be moved to master.\n          workerClient.persistFile(mFileId, mNonce, mUfsPath);\n        } finally {\n          mBlockStoreContext.releaseWorkerClient(workerClient);\n        }\n        canComplete = true;\n      }\n    }\n\n    if (mTachyonStorageType.isStore()) {\n      try {\n        if (mCanceled) {\n          for (BufferedBlockOutStream bos : mPreviousBlockOutStreams) {\n            bos.cancel();\n          }\n        } else {\n          for (BufferedBlockOutStream bos : mPreviousBlockOutStreams) {\n            bos.close();\n          }\n          canComplete = true;\n        }\n      } catch (IOException ioe) {\n        handleCacheWriteException(ioe);\n      }\n    }\n\n    if (canComplete) {\n      FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n      try {\n        masterClient.completeFile(mFileId);\n      } catch (TachyonException e) {\n        throw new IOException(e);\n      } finally {\n        mContext.releaseMasterClient(masterClient);\n      }\n    }\n    mClosed = true;\n  }","id":88850,"modified_method":"@Override\n  public void close() throws IOException {\n    if (mClosed) {\n      return;\n    }\n    if (mCurrentBlockOutStream != null) {\n      mPreviousBlockOutStreams.add(mCurrentBlockOutStream);\n    }\n\n    Boolean canComplete = false;\n    if (mUnderStorageType.isSyncPersist()) {\n      if (mCanceled) {\n        // TODO(yupeng): Handle this special case in under storage integrations.\n        mUnderStorageOutputStream.close();\n        String tmpPath = PathUtils.temporaryFileName(mFileId, mNonce, mUfsPath);\n        UnderFileSystem ufs = UnderFileSystem.get(tmpPath, ClientContext.getConf());\n        if (!ufs.exists(tmpPath)) {\n          FileInfo fileInfo = getFileInfo();\n          mUfsPath = fileInfo.getUfsPath();\n          tmpPath = PathUtils.temporaryFileName(mFileId, mNonce, mUfsPath);\n        }\n        ufs.delete(tmpPath, false);\n      } else {\n        mUnderStorageOutputStream.flush();\n        mUnderStorageOutputStream.close();\n        WorkerClient workerClient = BlockStoreContext.INSTANCE.acquireWorkerClient();\n        try {\n          // TODO(yupeng): Investigate if this RPC can be moved to master.\n          workerClient.persistFile(mFileId, mNonce, mUfsPath);\n        } finally {\n          BlockStoreContext.INSTANCE.releaseWorkerClient(workerClient);\n        }\n        canComplete = true;\n      }\n    }\n\n    if (mTachyonStorageType.isStore()) {\n      try {\n        if (mCanceled) {\n          for (BufferedBlockOutStream bos : mPreviousBlockOutStreams) {\n            bos.cancel();\n          }\n        } else {\n          for (BufferedBlockOutStream bos : mPreviousBlockOutStreams) {\n            bos.close();\n          }\n          canComplete = true;\n        }\n      } catch (IOException ioe) {\n        handleCacheWriteException(ioe);\n      }\n    }\n\n    if (canComplete) {\n      FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n      try {\n        masterClient.completeFile(mFileId);\n      } catch (TachyonException e) {\n        throw new IOException(e);\n      } finally {\n        mContext.releaseMasterClient(masterClient);\n      }\n    }\n    mClosed = true;\n  }","commit_id":"89d7143ef416ccf82c7a621c60e085821ffcbd9e","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new file output stream.\n   *\n   * @param fileId the file id\n   * @param options the client options\n   * @throws IOException if an I/O error occurs\n   */\n  public FileOutStream(long fileId, OutStreamOptions options) throws IOException {\n    this(fileId, options, FileSystemContext.INSTANCE);\n  }","id":88851,"modified_method":"/**\n   * Creates a new file output stream.\n   *\n   * @param fileId the file id\n   * @param options the client options\n   * @throws IOException if an I/O error occurs\n   */\n  public FileOutStream(long fileId, OutStreamOptions options) throws IOException {\n    mFileId = fileId;\n    mNonce = ClientContext.getRandomNonNegativeLong();\n    mBlockSize = options.getBlockSizeBytes();\n    mTachyonStorageType = options.getTachyonStorageType();\n    mUnderStorageType = options.getUnderStorageType();\n    mContext = FileSystemContext.INSTANCE;\n    mPreviousBlockOutStreams = new LinkedList<BufferedBlockOutStream>();\n    if (mUnderStorageType.isSyncPersist()) {\n      FileInfo fileInfo = getFileInfo();\n      mUfsPath = fileInfo.getUfsPath();\n      String fileName = PathUtils.temporaryFileName(fileId, mNonce, mUfsPath);\n      UnderFileSystem ufs = UnderFileSystem.get(fileName, ClientContext.getConf());\n      // TODO(jiri): Implement collection of temporary files left behind by dead clients.\n      mUnderStorageOutputStream = ufs.create(fileName, (int) mBlockSize);\n    } else {\n      mUfsPath = null;\n      mUnderStorageOutputStream = null;\n    }\n    mClosed = false;\n    mCanceled = false;\n    mHostname = options.getHostname();\n    mShouldCacheCurrentBlock = mTachyonStorageType.isStore();\n  }","commit_id":"89d7143ef416ccf82c7a621c60e085821ffcbd9e","url":"https://github.com/amplab/tachyon"},{"original_method":"private FileOutStream createTestStream(long fileId, OutStreamOptions options) throws IOException {\n    // Cannot use Whitebox to set mFileSystemContext because it needs to be mocked during the\n    // constructor\n    FileOutStream stream = new FileOutStream(FILE_ID, options, mFileSystemContext);\n    Whitebox.setInternalState(stream, \"mBlockStoreContext\", mBlockStoreContext);\n    return stream;\n  }","id":88852,"modified_method":"private FileOutStream createTestStream(long fileId, OutStreamOptions options) throws IOException {\n    Whitebox.setInternalState(BlockStoreContext.class, \"INSTANCE\", mBlockStoreContext);\n    Whitebox.setInternalState(FileSystemContext.class, \"INSTANCE\", mFileSystemContext);\n    FileOutStream stream = new FileOutStream(FILE_ID, options);\n    return stream;\n  }","commit_id":"89d7143ef416ccf82c7a621c60e085821ffcbd9e","url":"https://github.com/amplab/tachyon"},{"original_method":"public VoltTable[] run(short partitionValue) {\n        voltQueueSQL(insert, partitionValue + 1, partitionValue + 1, partitionValue + 1);\n        return voltExecuteSQL(true);\n    }","id":88853,"modified_method":"public long run(short partitionValue) {\n        // basically, try 1000 different partition keys and assume one of them\n        // is partitioned wrong\n        for (int i = 0; i < 1000; i++) {\n            voltQueueSQL(insert, partitionValue + i, partitionValue + i, partitionValue + i);\n            voltExecuteSQL();\n        }\n        return 0;\n    }","commit_id":"4c626373a17e0584adbf73ea31ea578909c3284d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(short partitionValue) {\n        voltQueueSQL(update, partitionValue + 1, partitionValue);\n        return voltExecuteSQL(true);\n    }","id":88854,"modified_method":"public long run(short partitionValue) {\n        // basically, try 1000 different partition keys and assume one of them\n        // is partitioned wrong\n        for (int i = 0; i < 1000; i++) {\n            voltQueueSQL(update, partitionValue + i, partitionValue);\n            voltExecuteSQL();\n        }\n        return 0;\n    }","commit_id":"4c626373a17e0584adbf73ea31ea578909c3284d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testWrongPartitioning() throws IOException, ProcCallException {\n        // Restrict to clustered tests (configured with > 1 partition)\n        LocalCluster config = (LocalCluster)this.getServerConfig();\n        int sites = config.m_siteCount;\n        int nodes = config.m_hostCount;\n        int k = config.m_kfactor;\n        int parts = (nodes * sites) / (k + 1);\n        if (parts == 1) {\n            return;\n        }\n\n        Client client = getClient();\n\n        // test mispartitioned insert\n        try {\n            client.callProcedure(MispartitionedInsert.class.getSimpleName(), 0);\n            fail();\n        }\n        catch (Exception e) {\n            System.err.println(\"==========\");\n            e.printStackTrace();\n            System.err.println(\"==========\");\n\n            // check for the expected error\n            assertTrue(e.getMessage().contains(\"Mispartitioned tuple\"));\n        }\n\n        // test mispartitioned update\n        client.callProcedure(\"NEW_ORDER.insert\", 0, 0, 0);\n        try {\n            client.callProcedure(MispartitionedUpdate.class.getSimpleName(), 0);\n            fail();\n        }\n        catch (Exception e) {\n            System.err.println(\"==========\");\n            e.printStackTrace();\n            System.err.println(\"==========\");\n\n            // check for the expected error\n            assertTrue(e.getMessage().contains(\"An update to a partitioning column\"));\n        }\n    }","id":88855,"modified_method":"public void testWrongPartitioning() throws IOException, ProcCallException {\n        // Restrict to clustered tests (configured with > 1 partition)\n        LocalCluster config = (LocalCluster)this.getServerConfig();\n        int sites = config.m_siteCount;\n        int nodes = config.m_hostCount;\n        int k = config.m_kfactor;\n        int parts = (nodes * sites) / (k + 1);\n        if (parts == 1) {\n            return;\n        }\n\n        Client client = getClient();\n\n        // test mispartitioned insert\n        try {\n            client.callProcedure(MispartitionedInsert.class.getSimpleName(), 0);\n            fail();\n        }\n        catch (Exception e) {\n            System.err.println(\"==========\");\n            System.err.println(\"Following stacktrace is expected:\");\n            e.printStackTrace();\n            System.err.println(\"==========\");\n\n            // check for the expected error\n            assertTrue(e.getMessage().contains(\"Mispartitioned tuple\"));\n        }\n\n        // test mispartitioned update\n        client.callProcedure(\"NEW_ORDER.insert\", 0, 0, 0);\n        try {\n            client.callProcedure(MispartitionedUpdate.class.getSimpleName(), 0);\n            fail();\n        }\n        catch (Exception e) {\n            System.err.println(\"==========\");\n            System.err.println(\"Following stacktrace is expected:\");\n            e.printStackTrace();\n            System.err.println(\"==========\");\n\n            // check for the expected error\n            assertTrue(e.getMessage().contains(\"An update to a partitioning column\"));\n        }\n    }","commit_id":"4c626373a17e0584adbf73ea31ea578909c3284d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(AsyncBenchmark.class.getCanonicalName())\n                .add(\"display-interval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"pool-size\", \"pool_size\", \"Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).\", 100000)\n                .add(\"preload\", \"preload\", \"Whether the data store should be initialized with default values before the benchmark is run (true|false).\", true)\n                .add(\"get-put-ratio\", \"get_put_ratio\", \"Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1\", 0.95)\n                .add(\"key-size\", \"key_size\", \"Size of the keys in number of characters. Max: 250\", 50)\n                .add(\"min-value-size\", \"min_value_size\", \"Minimum size for the value blob (in bytes, uncompressed). Max: 1048576\", 1000)\n                .add(\"max-value-size\", \"max_value_size\", \"Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576\", 1000)\n                .add(\"use-compression\", \"use_compression\", \"Whether value blobs should be compressed (GZip) for storage in the database (true|false).\", false)\n                .add(\"rate-limit\", \"rate_limit\", \"Rate limit to start from (number of transactions per second).\", 100000)\n                .add(\"auto-tune\", \"auto_tune\", \"Flag indicating whether the benchmark should self-tune the transaction rate for a target execution latency (true|false).\", \"true\")\n                .add(\"latency-target\", \"latency_target\", \"Execution latency to target to tune transaction rate (in milliseconds).\", 10.0d)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            long displayInterval   = apph.longValue(\"display-interval\");\n            long duration          = apph.longValue(\"duration\");\n            String servers         = apph.stringValue(\"servers\");\n            int port               = apph.intValue(\"port\");\n            double getPutRatio     = apph.doubleValue(\"get-put-ratio\");\n            int poolSize           = apph.intValue(\"pool-size\");\n            boolean preload        = apph.booleanValue(\"preload\");\n            int keySize            = apph.intValue(\"key-size\");\n            int minValueSize       = apph.intValue(\"min-value-size\");\n            int maxValueSize       = apph.intValue(\"max-value-size\");\n            boolean useCompression = apph.booleanValue(\"use-compression\");\n            long rateLimit         = apph.longValue(\"rate-limit\");\n            boolean autoTune       = apph.booleanValue(\"auto-tune\");\n            double latencyTarget   = apph.doubleValue(\"latency-target\");\n\n\n            // Validate parameters\n            apph.validate(\"pool-size\", (poolSize > 0))\n                .validate(\"get-put-ratio\", (getPutRatio >= 0) && (getPutRatio <= 1))\n                .validate(\"key-size\", (keySize > 0) && (keySize < 251))\n                .validate(\"min-value-size\", (minValueSize > 0) && (minValueSize < 1048576))\n                .validate(\"max-value-size\", (maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize))\n                .validate(\"rate-limit\", (rateLimit > 0))\n                .validate(\"latency-target\", (latencyTarget > 0))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to servers: %s at port: %d\\n\", servers, port);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = ClientConnectionPool.get(servers, port);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(keySize, minValueSize, maxValueSize, poolSize, useCompression);\n\n            // Initialize the store\n            if (preload)\n            {\n                System.out.print(\"Initializing data store... \");\n                Con.execute(\"Initialize\", poolSize, processor.KeyFormat, processor.generateForStore().getStoreValue());\n                System.out.println(\" Done.\");\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    System.out.print(Con.getStatistics(\"Get\", \"Put\"));\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Pick the transaction rate limiter helping object to use based on user request (rate limiting or latency targeting)\n            IRateLimiter limiter = null;\n            if (autoTune)\n                limiter = (IRateLimiter)new LatencyLimiter(Con, \"Get\", latencyTarget, rateLimit);\n            else\n                limiter = (IRateLimiter)new RateLimiter(rateLimit);\n\n            // Run the benchmark loop for the requested duration\n            long endTime = System.currentTimeMillis() + (1000l * duration);\n            Random rand = new Random();\n            while (endTime > System.currentTimeMillis())\n            {\n                // Decide whether to perform a GET or PUT operation\n                if (rand.nextDouble() < getPutRatio)\n                {\n                    // Get a key/value pair, asynchronously\n                    Con.executeAsync(new ProcedureCallback()\n                    {\n                        @Override\n                        public void clientCallback(ClientResponse response) throws Exception\n                        {\n                            // Track the result of the operation (Success, Failure, Payload traffic...)\n                            if (response.getStatus() == ClientResponse.SUCCESS)\n                            {\n                                final VoltTable pairData = response.getResults()[0];\n                                // Cache miss (Key does not exist)\n                                if (pairData.getRowCount() == 0)\n                                    GetStoreResults.incrementAndGet(1);\n                                else\n                                {\n                                    final PayloadProcessor.Pair pair = processor.retrieveFromStore(pairData.fetchRow(0).getString(0), pairData.fetchRow(0).getVarbinary(1));\n                                    GetStoreResults.incrementAndGet(0);\n                                    GetCompressionResults.addAndGet(0, pair.getStoreValueLength());\n                                    GetCompressionResults.addAndGet(1, pair.getRawValueLength());\n                                }\n                            }\n                            else\n                                GetStoreResults.incrementAndGet(1);\n                        }\n                    }\n                    , \"Get\"\n                    , processor.generateRandomKeyForRetrieval()\n                    );\n                }\n                else\n                {\n                    // Put a key/value pair, asynchronously\n                    final PayloadProcessor.Pair pair = processor.generateForStore();\n                    Con.executeAsync(new ProcedureCallback()\n                    {\n                        final long StoreValueLength;\n                        final long RawValueLength;\n                        {\n                            this.StoreValueLength = pair.getStoreValueLength();\n                            this.RawValueLength = pair.getRawValueLength();\n                        }\n                        @Override\n                        public void clientCallback(ClientResponse response) throws Exception\n                        {\n                            // Track the result of the operation (Success, Failure, Payload traffic...)\n                            if (response.getStatus() == ClientResponse.SUCCESS)\n                                PutStoreResults.incrementAndGet(0);\n                            else\n                                PutStoreResults.incrementAndGet(1);\n                            PutCompressionResults.addAndGet(0, this.StoreValueLength);\n                            PutCompressionResults.addAndGet(1, this.RawValueLength);\n                        }\n                    }\n                    , \"Put\"\n                    , pair.Key\n                    , pair.getStoreValue()\n                    );\n                }\n\n                // Use the limiter to throttle client activity\n                limiter.throttle();\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics(\"Get\", \"Put\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics().toString(false));\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","id":88856,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(AsyncBenchmark.class.getCanonicalName())\n                .add(\"display-interval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"pool-size\", \"pool_size\", \"Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).\", 100000)\n                .add(\"preload\", \"preload\", \"Whether the data store should be initialized with default values before the benchmark is run (true|false).\", true)\n                .add(\"get-put-ratio\", \"get_put_ratio\", \"Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1\", 0.95)\n                .add(\"key-size\", \"key_size\", \"Size of the keys in number of characters. Max: 250\", 50)\n                .add(\"min-value-size\", \"min_value_size\", \"Minimum size for the value blob (in bytes, uncompressed). Max: 1048576\", 1000)\n                .add(\"max-value-size\", \"max_value_size\", \"Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576\", 1000)\n                .add(\"use-compression\", \"use_compression\", \"Whether value blobs should be compressed (GZip) for storage in the database (true|false).\", false)\n                .add(\"rate-limit\", \"rate_limit\", \"Rate limit to start from (number of transactions per second).\", 100000)\n                .add(\"auto-tune\", \"auto_tune\", \"Flag indicating whether the benchmark should self-tune the transaction rate for a target execution latency (true|false).\", \"true\")\n                .add(\"latency-target\", \"latency_target\", \"Execution latency to target to tune transaction rate (in milliseconds).\", 10.0d)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            long displayInterval   = apph.longValue(\"display-interval\");\n            long duration          = apph.longValue(\"duration\");\n            String servers         = apph.stringValue(\"servers\");\n            int port               = apph.intValue(\"port\");\n            double getPutRatio     = apph.doubleValue(\"get-put-ratio\");\n            int poolSize           = apph.intValue(\"pool-size\");\n            boolean preload        = apph.booleanValue(\"preload\");\n            int keySize            = apph.intValue(\"key-size\");\n            int minValueSize       = apph.intValue(\"min-value-size\");\n            int maxValueSize       = apph.intValue(\"max-value-size\");\n            boolean useCompression = apph.booleanValue(\"use-compression\");\n            long rateLimit         = apph.longValue(\"rate-limit\");\n            boolean autoTune       = apph.booleanValue(\"auto-tune\");\n            double latencyTarget   = apph.doubleValue(\"latency-target\");\n\n\n            // Validate parameters\n            apph.validate(\"pool-size\", (poolSize > 0))\n                .validate(\"get-put-ratio\", (getPutRatio >= 0) && (getPutRatio <= 1))\n                .validate(\"key-size\", (keySize > 0) && (keySize < 251))\n                .validate(\"min-value-size\", (minValueSize > 0) && (minValueSize < 1048576))\n                .validate(\"max-value-size\", (maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize))\n                .validate(\"rate-limit\", (rateLimit > 0))\n                .validate(\"latency-target\", (latencyTarget > 0))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to servers: %s at port: %d\\n\", servers, port);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = ClientConnectionPool.get(servers, port);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(keySize, minValueSize, maxValueSize, poolSize, useCompression);\n\n            // Initialize the store\n            if (preload)\n            {\n                System.out.print(\"Initializing data store... \");\n                for(int i=0;i<poolSize;i+=1000)\n                    Con.execute(\"Initialize\", i, Math.min(i+1000,poolSize), processor.KeyFormat, processor.generateForStore().getStoreValue());\n                System.out.println(\" Done.\");\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    System.out.print(Con.getStatistics(\"Get\", \"Put\"));\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Pick the transaction rate limiter helping object to use based on user request (rate limiting or latency targeting)\n            IRateLimiter limiter = null;\n            if (autoTune)\n                limiter = (IRateLimiter)new LatencyLimiter(Con, \"Get\", latencyTarget, rateLimit);\n            else\n                limiter = (IRateLimiter)new RateLimiter(rateLimit);\n\n            // Run the benchmark loop for the requested duration\n            long endTime = System.currentTimeMillis() + (1000l * duration);\n            Random rand = new Random();\n            while (endTime > System.currentTimeMillis())\n            {\n                // Decide whether to perform a GET or PUT operation\n                if (rand.nextDouble() < getPutRatio)\n                {\n                    // Get a key/value pair, asynchronously\n                    Con.executeAsync(new ProcedureCallback()\n                    {\n                        @Override\n                        public void clientCallback(ClientResponse response) throws Exception\n                        {\n                            // Track the result of the operation (Success, Failure, Payload traffic...)\n                            if (response.getStatus() == ClientResponse.SUCCESS)\n                            {\n                                final VoltTable pairData = response.getResults()[0];\n                                // Cache miss (Key does not exist)\n                                if (pairData.getRowCount() == 0)\n                                    GetStoreResults.incrementAndGet(1);\n                                else\n                                {\n                                    final PayloadProcessor.Pair pair = processor.retrieveFromStore(pairData.fetchRow(0).getString(0), pairData.fetchRow(0).getVarbinary(1));\n                                    GetStoreResults.incrementAndGet(0);\n                                    GetCompressionResults.addAndGet(0, pair.getStoreValueLength());\n                                    GetCompressionResults.addAndGet(1, pair.getRawValueLength());\n                                }\n                            }\n                            else\n                                GetStoreResults.incrementAndGet(1);\n                        }\n                    }\n                    , \"Get\"\n                    , processor.generateRandomKeyForRetrieval()\n                    );\n                }\n                else\n                {\n                    // Put a key/value pair, asynchronously\n                    final PayloadProcessor.Pair pair = processor.generateForStore();\n                    Con.executeAsync(new ProcedureCallback()\n                    {\n                        final long StoreValueLength;\n                        final long RawValueLength;\n                        {\n                            this.StoreValueLength = pair.getStoreValueLength();\n                            this.RawValueLength = pair.getRawValueLength();\n                        }\n                        @Override\n                        public void clientCallback(ClientResponse response) throws Exception\n                        {\n                            // Track the result of the operation (Success, Failure, Payload traffic...)\n                            if (response.getStatus() == ClientResponse.SUCCESS)\n                                PutStoreResults.incrementAndGet(0);\n                            else\n                                PutStoreResults.incrementAndGet(1);\n                            PutCompressionResults.addAndGet(0, this.StoreValueLength);\n                            PutCompressionResults.addAndGet(1, this.RawValueLength);\n                        }\n                    }\n                    , \"Put\"\n                    , pair.Key\n                    , pair.getStoreValue()\n                    );\n                }\n\n                // Use the limiter to throttle client activity\n                limiter.throttle();\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics(\"Get\", \"Put\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics().toString(false));\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","commit_id":"9894251fe3e965ed7c7aa5be15dbe1825f5a380b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public long run(int poolSize, String keyFormat, byte[] defaultValue)\n    {\n        // Wipe out the data store to re-initialize\n        voltQueueSQL(cleanStmt);\n        voltExecuteSQL();\n\n        // Initialize the data store with given parameters\n        int batchSize = 0;\n        for(int i=0;i<poolSize;i++)\n        {\n            voltQueueSQL(insertStmt, String.format(keyFormat, i), defaultValue);\n            batchSize++;\n            if (batchSize > 499) // We can batch up to 500 statements to push in one single execution call\n            {\n                voltExecuteSQL();\n                batchSize = 0;\n            }\n        }\n        // Make sure we post the last batch!\n        if (batchSize > 0)\n            voltExecuteSQL(true);\n\n        return poolSize;\n    }","id":88857,"modified_method":"public long run(int startIndex, int stopIndex, String keyFormat, byte[] defaultValue)\n    {\n        // Wipe out the data store to re-initialize\n        if (startIndex == 0)\n        {\n            voltQueueSQL(cleanStmt);\n            voltExecuteSQL();\n        }\n\n        // Initialize the data store with given parameters\n        int batchSize = 0;\n        for(int i=startIndex;i<stopIndex;i++)\n        {\n            voltQueueSQL(insertStmt, String.format(keyFormat, i), defaultValue);\n            batchSize++;\n            if (batchSize > 499) // We can batch up to 500 statements to push in one single execution call\n            {\n                voltExecuteSQL();\n                batchSize = 0;\n            }\n        }\n        // Make sure we post the last batch!\n        if (batchSize > 0)\n            voltExecuteSQL(true);\n\n        return stopIndex;\n    }","commit_id":"9894251fe3e965ed7c7aa5be15dbe1825f5a380b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(AsyncBenchmark.class.getCanonicalName())\n                .add(\"threads\", \"thread_count\", \"Number of concurrent threads attacking the database.\", 1)\n                .add(\"display-interval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"pool-size\", \"pool_size\", \"Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).\", 100000)\n                .add(\"preload\", \"preload\", \"Whether the data store should be initialized with default values before the benchmark is run (true|false).\", true)\n                .add(\"get-put-ratio\", \"get_put_ratio\", \"Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1\", 0.95)\n                .add(\"key-size\", \"key_size\", \"Size of the keys in number of characters. Max: 250\", 50)\n                .add(\"min-value-size\", \"min_value_size\", \"Minimum size for the value blob (in bytes, uncompressed). Max: 1048576\", 1000)\n                .add(\"max-value-size\", \"max_value_size\", \"Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576\", 1000)\n                .add(\"use-compression\", \"use_compression\", \"Whether value blobs should be compressed (GZip) for storage in the database (true|false).\", false)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            int threadCount        = apph.intValue(\"threads\");\n            long displayInterval   = apph.longValue(\"display-interval\");\n            long duration          = apph.longValue(\"duration\");\n            String servers         = apph.stringValue(\"servers\");\n            int port               = apph.intValue(\"port\");\n            double getPutRatio     = apph.doubleValue(\"get-put-ratio\");\n            int poolSize           = apph.intValue(\"pool-size\");\n            boolean preload        = apph.booleanValue(\"preload\");\n            int keySize            = apph.intValue(\"key-size\");\n            int minValueSize       = apph.intValue(\"min-value-size\");\n            int maxValueSize       = apph.intValue(\"max-value-size\");\n            boolean useCompression = apph.booleanValue(\"use-compression\");\n\n\n            // Validate parameters\n            apph.validate(\"threads\", (threadCount > 0))\n                .validate(\"pool-size\", (poolSize > 0))\n                .validate(\"get-put-ratio\", (getPutRatio >= 0) && (getPutRatio <= 1))\n                .validate(\"key-size\", (keySize > 0) && (keySize < 251))\n                .validate(\"min-value-size\", (minValueSize > 0) && (minValueSize < 1048576))\n                .validate(\"max-value-size\", (maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We need only do this once, to \"hot cache\" the JDBC driver reference so the JVM may realize it's there.\n            Class.forName(\"org.voltdb.jdbc.Driver\");\n\n            // Prepare the JDBC URL for the VoltDB driver\n            String url = \"jdbc:voltdb://\" + servers + \":\" + port;\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to: %s\\n\", url);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = DriverManager.getConnection(url, \"\", \"\");\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(keySize, minValueSize, maxValueSize, poolSize, useCompression);\n\n            // Initialize the store\n            if (preload)\n            {\n                System.out.print(\"Initializing data store... \");\n                final CallableStatement initializeCS = Con.prepareCall(\"{call Initialize(?,?,?)}\");\n                initializeCS.setInt(1, poolSize);\n                initializeCS.setString(2, processor.KeyFormat);\n                initializeCS.setBytes(3, processor.generateForStore().getStoreValue());\n                initializeCS.executeUpdate();\n                System.out.println(\" Done.\");\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    try { System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(\"Get\", \"Put\")); } catch(Exception x) {}\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < threadCount; i++)\n                threads.add(new Thread(new ClientThread(url, processor, duration, getPutRatio)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(\"Get\", \"Put\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics().toString(false));\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","id":88858,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(AsyncBenchmark.class.getCanonicalName())\n                .add(\"threads\", \"thread_count\", \"Number of concurrent threads attacking the database.\", 1)\n                .add(\"display-interval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"pool-size\", \"pool_size\", \"Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).\", 100000)\n                .add(\"preload\", \"preload\", \"Whether the data store should be initialized with default values before the benchmark is run (true|false).\", true)\n                .add(\"get-put-ratio\", \"get_put_ratio\", \"Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1\", 0.95)\n                .add(\"key-size\", \"key_size\", \"Size of the keys in number of characters. Max: 250\", 50)\n                .add(\"min-value-size\", \"min_value_size\", \"Minimum size for the value blob (in bytes, uncompressed). Max: 1048576\", 1000)\n                .add(\"max-value-size\", \"max_value_size\", \"Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576\", 1000)\n                .add(\"use-compression\", \"use_compression\", \"Whether value blobs should be compressed (GZip) for storage in the database (true|false).\", false)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            int threadCount        = apph.intValue(\"threads\");\n            long displayInterval   = apph.longValue(\"display-interval\");\n            long duration          = apph.longValue(\"duration\");\n            String servers         = apph.stringValue(\"servers\");\n            int port               = apph.intValue(\"port\");\n            double getPutRatio     = apph.doubleValue(\"get-put-ratio\");\n            int poolSize           = apph.intValue(\"pool-size\");\n            boolean preload        = apph.booleanValue(\"preload\");\n            int keySize            = apph.intValue(\"key-size\");\n            int minValueSize       = apph.intValue(\"min-value-size\");\n            int maxValueSize       = apph.intValue(\"max-value-size\");\n            boolean useCompression = apph.booleanValue(\"use-compression\");\n\n\n            // Validate parameters\n            apph.validate(\"threads\", (threadCount > 0))\n                .validate(\"pool-size\", (poolSize > 0))\n                .validate(\"get-put-ratio\", (getPutRatio >= 0) && (getPutRatio <= 1))\n                .validate(\"key-size\", (keySize > 0) && (keySize < 251))\n                .validate(\"min-value-size\", (minValueSize > 0) && (minValueSize < 1048576))\n                .validate(\"max-value-size\", (maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We need only do this once, to \"hot cache\" the JDBC driver reference so the JVM may realize it's there.\n            Class.forName(\"org.voltdb.jdbc.Driver\");\n\n            // Prepare the JDBC URL for the VoltDB driver\n            String url = \"jdbc:voltdb://\" + servers + \":\" + port;\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to: %s\\n\", url);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = DriverManager.getConnection(url, \"\", \"\");\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(keySize, minValueSize, maxValueSize, poolSize, useCompression);\n\n            // Initialize the store\n            if (preload)\n            {\n                System.out.print(\"Initializing data store... \");\n                final CallableStatement initializeCS = Con.prepareCall(\"{call Initialize(?,?,?,?)}\");\n                for(int i=0;i<poolSize;i+=1000)\n                {\n                    initializeCS.setInt(1, i);\n                    initializeCS.setInt(2, Math.min(i+1000,poolSize));\n                    initializeCS.setString(3, processor.KeyFormat);\n                    initializeCS.setBytes(4, processor.generateForStore().getStoreValue());\n                    initializeCS.executeUpdate();\n                }\n                System.out.println(\" Done.\");\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    try { System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(\"Get\", \"Put\")); } catch(Exception x) {}\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < threadCount; i++)\n                threads.add(new Thread(new ClientThread(url, processor, duration, getPutRatio)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(\"Get\", \"Put\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics().toString(false));\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","commit_id":"9894251fe3e965ed7c7aa5be15dbe1825f5a380b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(AsyncBenchmark.class.getCanonicalName())\n                .add(\"threads\", \"thread_count\", \"Number of concurrent threads attacking the database.\", 1)\n                .add(\"display-interval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"pool-size\", \"pool_size\", \"Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).\", 100000)\n                .add(\"preload\", \"preload\", \"Whether the data store should be initialized with default values before the benchmark is run (true|false).\", true)\n                .add(\"get-put-ratio\", \"get_put_ratio\", \"Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1\", 0.95)\n                .add(\"key-size\", \"key_size\", \"Size of the keys in number of characters. Max: 250\", 50)\n                .add(\"min-value-size\", \"min_value_size\", \"Minimum size for the value blob (in bytes, uncompressed). Max: 1048576\", 1000)\n                .add(\"max-value-size\", \"max_value_size\", \"Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576\", 1000)\n                .add(\"use-compression\", \"use_compression\", \"Whether value blobs should be compressed (GZip) for storage in the database (true|false).\", false)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            int threadCount        = apph.intValue(\"threads\");\n            long displayInterval   = apph.longValue(\"display-interval\");\n            long duration          = apph.longValue(\"duration\");\n            String servers         = apph.stringValue(\"servers\");\n            int port               = apph.intValue(\"port\");\n            double getPutRatio     = apph.doubleValue(\"get-put-ratio\");\n            int poolSize           = apph.intValue(\"pool-size\");\n            boolean preload        = apph.booleanValue(\"preload\");\n            int keySize            = apph.intValue(\"key-size\");\n            int minValueSize       = apph.intValue(\"min-value-size\");\n            int maxValueSize       = apph.intValue(\"max-value-size\");\n            boolean useCompression = apph.booleanValue(\"use-compression\");\n\n\n            // Validate parameters\n            apph.validate(\"threads\", (threadCount > 0))\n                .validate(\"pool-size\", (poolSize > 0))\n                .validate(\"get-put-ratio\", (getPutRatio >= 0) && (getPutRatio <= 1))\n                .validate(\"key-size\", (keySize > 0) && (keySize < 251))\n                .validate(\"min-value-size\", (minValueSize > 0) && (minValueSize < 1048576))\n                .validate(\"max-value-size\", (maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to servers: %s at port: %d\\n\", servers, port);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = ClientConnectionPool.get(servers, port);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(keySize, minValueSize, maxValueSize, poolSize, useCompression);\n\n            // Initialize the store\n            if (preload)\n            {\n                System.out.print(\"Initializing data store... \");\n                Con.execute(\"Initialize\", poolSize, processor.KeyFormat, processor.generateForStore().getStoreValue());\n                System.out.println(\" Done.\");\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    System.out.print(Con.getStatistics(\"Get\", \"Put\"));\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < threadCount; i++)\n                threads.add(new Thread(new ClientThread(servers, port, processor, duration, getPutRatio)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics(\"Get\", \"Put\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics().toString(false));\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","id":88859,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(AsyncBenchmark.class.getCanonicalName())\n                .add(\"threads\", \"thread_count\", \"Number of concurrent threads attacking the database.\", 1)\n                .add(\"display-interval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"pool-size\", \"pool_size\", \"Size of the pool of keys to work with (10,00, 10,000, 100,000 items, etc.).\", 100000)\n                .add(\"preload\", \"preload\", \"Whether the data store should be initialized with default values before the benchmark is run (true|false).\", true)\n                .add(\"get-put-ratio\", \"get_put_ratio\", \"Ratio of GET versus PUT operations: 1.0 => 100% GETs; 0.0 => 0% GETs; 0.95 => 95% GETs, 5% PUTs. Value between 0 and 1\", 0.95)\n                .add(\"key-size\", \"key_size\", \"Size of the keys in number of characters. Max: 250\", 50)\n                .add(\"min-value-size\", \"min_value_size\", \"Minimum size for the value blob (in bytes, uncompressed). Max: 1048576\", 1000)\n                .add(\"max-value-size\", \"max_value_size\", \"Maximum size for the value blob (in bytes, uncompressed) - set equal to min-value-size for constant size. Max: 1048576\", 1000)\n                .add(\"use-compression\", \"use_compression\", \"Whether value blobs should be compressed (GZip) for storage in the database (true|false).\", false)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            int threadCount        = apph.intValue(\"threads\");\n            long displayInterval   = apph.longValue(\"display-interval\");\n            long duration          = apph.longValue(\"duration\");\n            String servers         = apph.stringValue(\"servers\");\n            int port               = apph.intValue(\"port\");\n            double getPutRatio     = apph.doubleValue(\"get-put-ratio\");\n            int poolSize           = apph.intValue(\"pool-size\");\n            boolean preload        = apph.booleanValue(\"preload\");\n            int keySize            = apph.intValue(\"key-size\");\n            int minValueSize       = apph.intValue(\"min-value-size\");\n            int maxValueSize       = apph.intValue(\"max-value-size\");\n            boolean useCompression = apph.booleanValue(\"use-compression\");\n\n\n            // Validate parameters\n            apph.validate(\"threads\", (threadCount > 0))\n                .validate(\"pool-size\", (poolSize > 0))\n                .validate(\"get-put-ratio\", (getPutRatio >= 0) && (getPutRatio <= 1))\n                .validate(\"key-size\", (keySize > 0) && (keySize < 251))\n                .validate(\"min-value-size\", (minValueSize > 0) && (minValueSize < 1048576))\n                .validate(\"max-value-size\", (maxValueSize > 0) && (maxValueSize < 1048576) && (maxValueSize >= minValueSize))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to servers: %s at port: %d\\n\", servers, port);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = ClientConnectionPool.get(servers, port);\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(keySize, minValueSize, maxValueSize, poolSize, useCompression);\n\n            // Initialize the store\n            if (preload)\n            {\n                System.out.print(\"Initializing data store... \");\n                for(int i=0;i<poolSize;i+=1000)\n                    Con.execute(\"Initialize\", i, Math.min(i+1000,poolSize), processor.KeyFormat, processor.generateForStore().getStoreValue());\n                System.out.println(\" Done.\");\n            }\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    System.out.print(Con.getStatistics(\"Get\", \"Put\"));\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < threadCount; i++)\n                threads.add(new Thread(new ClientThread(servers, port, processor, duration, getPutRatio)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*keySize)/(134217728d*(double)duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics(\"Get\", \"Put\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.getStatistics().toString(false));\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","commit_id":"9894251fe3e965ed7c7aa5be15dbe1825f5a380b","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n\t * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)\n\t */\n\tpublic void start(BundleContext context) throws Exception {\n\t\t//Setting basic variabile used by everyone\n        \n \t\tActivator.bc = context;\t\t\t\t\n\t\t\n\t    String levelStr = (String) Util.getPropertyDefault(context,\"felix.upnpbase.log\",\"2\");\t    \n\t\tActivator.logger = new Logger(levelStr);\n\t    String cyberLog = (String) Util.getPropertyDefault(context,\"felix.upnpbase.cyberlink.log\",\"false\");\n\t    Activator.logger.setCyberDebug(cyberLog);\n\n        UPnP.setEnable(UPnP.USE_ONLY_IPV4_ADDR);\n        UPnP.setDisable(UPnP.USE_LOOPBACK_ADDR);\n\t\t\n\t\t//Setting up Base Driver Exporter\n\t\tthis.queue = new RootDeviceExportingQueue();\n\t\tthis.producerDeviceToExport = new RootDeviceListener(queue);\n\t\tproducerDeviceToExport.activate();\n\t\tconsumerDeviceToExport = new ThreadExporter(queue);\n\t\tnew Thread(consumerDeviceToExport, \"upnp.basedriver.Exporter\").start();\n\n\t\t//Setting up Base Driver Importer\n\t\tthis.notifierQueue = new NotifierQueue();\n\t\tthis.subQueue = new SubscriptionQueue();\n\t\tctrl = new MyCtrlPoint(context, subQueue, notifierQueue);\n\t\t\n\t\t//Enable CyberLink re-new for Event\n\t\tctrl.setNMPRMode(true);\n\t\t\t\n\t\tthis.monitor=new Monitor();\n\t\tthis.notifier = new Notifier(notifierQueue,monitor);\n\t\tthis.subScriber = new SubScriber(ctrl, subQueue,monitor);\n\t\t\n\t\tctrl.start();\n\t\tsubScriber.start();\n\t\tnotifier.start();\n        \n        doControllerRegistration();\n        \n\t}","id":88860,"modified_method":"/**\n\t * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)\n\t */\n\tpublic void start(BundleContext context) throws Exception {\n\t\t//Setting basic variabile used by everyone\n        \n \t\tActivator.bc = context;\t\t\t\t\n\t\t\n \t\t//\n \t\t// Debugger configuration\n \t\t//\n\t    String levelStr = Util.getPropertyDefault(context,BASEDRIVER_LOG_PROP,\"2\");\t    \n\t\tActivator.logger = new Logger(levelStr);\n\t\t\n\t    String cyberLog = Util.getPropertyDefault(context,CYBERDOMO_LOG_PROP,\"false\");\n\t    Activator.logger.setCyberDebug(cyberLog);\n\t    \n\t    \n \t\t//\n\t    // NET configuration\n\t   \t//\n\t    String useOnlyIPV4 = Util.getPropertyDefault(context,NET_ONLY_IPV4_PROP,\"true\");\n    \tif (useOnlyIPV4.equalsIgnoreCase(\"true\"))\n            UPnP.setEnable(UPnP.USE_ONLY_IPV4_ADDR);\n    \telse\n    \t\tUPnP.setDisable(UPnP.USE_ONLY_IPV4_ADDR);\n    \t\n       \tString useOnlyIPV6 = Util.getPropertyDefault(context,NET_ONLY_IPV6_PROP,\"false\");\n    \tif (useOnlyIPV6.equalsIgnoreCase(\"true\"))\n            UPnP.setEnable(UPnP.USE_ONLY_IPV6_ADDR);\n    \telse\n    \t\tUPnP.setDisable(UPnP.USE_ONLY_IPV6_ADDR);\n\n       \tString useLoopback = Util.getPropertyDefault(context,NET_USE_LOOPBACK_PROP,\"false\");\n    \tif (useLoopback.equalsIgnoreCase(\"true\"))\n            UPnP.setEnable(UPnP.USE_LOOPBACK_ADDR);\n    \telse\n    \t\tUPnP.setDisable(UPnP.USE_LOOPBACK_ADDR);\n\n    \t//\n    \t// Exporter configuration\t\t\n       \t//\n    \tString useExporter = Util.getPropertyDefault(context,EXPORTER_ENABLED_PROP,\"true\");\n       \tif (useExporter.equalsIgnoreCase(\"true\")){\n\t\t\t//Setting up Base Driver Exporter\n\t\t\tthis.queue = new RootDeviceExportingQueue();\n\t\t\tthis.producerDeviceToExport = new RootDeviceListener(queue);\n\t\t\tproducerDeviceToExport.activate();\n\t\t\tconsumerDeviceToExport = new ThreadExporter(queue);\n\t\t\tnew Thread(consumerDeviceToExport, \"upnp.basedriver.Exporter\").start();\n       \t}\n\n    \t//\n       \t// Importer configuration\t\t\n      \t//\n       \tString useImporter = Util.getPropertyDefault(context,IMPORTER_ENABLED_PROP,\"true\");\n       \tif (useImporter.equalsIgnoreCase(\"true\")){\n\t\t\t//Setting up Base Driver Importer\n\t\t\tthis.notifierQueue = new NotifierQueue();\n\t\t\tthis.subQueue = new SubscriptionQueue();\n\t\t\tctrl = new MyCtrlPoint(context, subQueue, notifierQueue);\n\t\t\t\n\t\t\t//Enable CyberLink re-new for Event\n\t\t\tctrl.setNMPRMode(true);\n\t\t\t\t\n\t\t\tthis.monitor=new Monitor();\n\t\t\tthis.notifier = new Notifier(notifierQueue,monitor);\n\t\t\tthis.subScriber = new SubScriber(ctrl, subQueue,monitor);\n\t\t\t\n\t\t\tctrl.start();\n\t\t\tsubScriber.start();\n\t\t\tnotifier.start();\n       \t}\n        \n        doControllerRegistration();\n        \n\t}","commit_id":"fe2bc84d5300e49f9664150ccb83b6379501bbae","url":"https://github.com/apache/felix"},{"original_method":"/**\n\t * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n\t */\n\tpublic void stop(BundleContext context) throws Exception {\n        \n        drvControllerRegistrar.unregister();\n        \n\t\t//Setting up Base Driver Exporter\n\t\tconsumerDeviceToExport.end();\n\t\tconsumerDeviceToExport.cleanUp();\n\t\tproducerDeviceToExport.deactive();\n\n\t\t//Setting up Base Driver Importer\n\t\tctrl.stop();\n\t\tsubScriber.close();\n\t\tnotifier.close();\n\t\tActivator.logger.close();\n\t\tActivator.logger=null;\n\t\tActivator.bc = null;\n\t}","id":88861,"modified_method":"/**\n\t * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n\t */\n\tpublic void stop(BundleContext context) throws Exception {\n        \n        drvControllerRegistrar.unregister();\n        \n\t\t//Base Driver Exporter\n        if (consumerDeviceToExport != null) {\n\t\t\tconsumerDeviceToExport.end();\n\t\t\tconsumerDeviceToExport.cleanUp();\n\t\t\tproducerDeviceToExport.deactive();\n        }\n\n\t\t//Base Driver Importer\n        if (ctrl != null){\n\t\t\tctrl.stop();\n\t\t\tsubScriber.close();\n\t\t\tnotifier.close();\n        }\n        \n\t\tActivator.logger.close();\n\t\tActivator.logger=null;\n\t\tActivator.bc = null;\n\t}","commit_id":"fe2bc84d5300e49f9664150ccb83b6379501bbae","url":"https://github.com/apache/felix"},{"original_method":"public String getSCPDURL(String udn, String serviceId) {\r\n        if (udn == null || udn.equals(\"\") )  throw new IllegalArgumentException(\"Invalid udn paramenter\");\r\n        if (serviceId == null || serviceId.equals(\"\") )  throw new IllegalArgumentException(\"Invalid serviceId paramenter\");\r\n        Device device= myCtrl.getDevice(udn);\r\n        if (device == null) {\r\n            logger.WARNING(\"getSCPDURL():: No device data available for UDN: \"+udn);\r\n            return null;\r\n        }\r\n        Service service = device.getService(serviceId);\r\n        if (service == null) {\r\n            logger.WARNING(\"getSCPDURL():: No service data available for serviceId:\"+serviceId + \" of UDN \" + udn);\r\n            return null;\r\n        }\r\n        String scpd = service.getSCPDURL().trim();\r\n        return resolveRelativeLink(device,scpd);\r\n    }","id":88862,"modified_method":"public String getSCPDURL(String udn, String serviceId) {\r\n    \tif (myCtrl == null){\r\n    \t\tlogger.WARNING(\"UPnP Importer is disabled. getSCPDURL() is not available\");\r\n    \t\treturn null;\r\n    \t}\r\n        if (udn == null || udn.equals(\"\") )  throw new IllegalArgumentException(\"Invalid udn paramenter\");\r\n        if (serviceId == null || serviceId.equals(\"\") )  throw new IllegalArgumentException(\"Invalid serviceId paramenter\");\r\n        Device device= myCtrl.getDevice(udn);\r\n        if (device == null) {\r\n            logger.WARNING(\"getSCPDURL():: No device data available for UDN: \"+udn);\r\n            return null;\r\n        }\r\n        Service service = device.getService(serviceId);\r\n        if (service == null) {\r\n            logger.WARNING(\"getSCPDURL():: No service data available for serviceId:\"+serviceId + \" of UDN \" + udn);\r\n            return null;\r\n        }\r\n        String scpd = service.getSCPDURL().trim();\r\n        return resolveRelativeLink(device,scpd);\r\n    }","commit_id":"fe2bc84d5300e49f9664150ccb83b6379501bbae","url":"https://github.com/apache/felix"},{"original_method":"public String resolveRelativeUrl(String udn, String link) {\r\n        if (udn == null || udn.equals(\"\"))  throw new IllegalArgumentException(\"Invalid udn paramenter\");\r\n        Device device = myCtrl.getDevice(udn);\r\n        return resolveRelativeLink(device,link);        \r\n    }","id":88863,"modified_method":"public String resolveRelativeUrl(String udn, String link) {\r\n       \tif (myCtrl == null){\r\n    \t\tlogger.WARNING(\"UPnP Importer is disabled. resolveRelativeUrl() is not available\");\r\n    \t\treturn null;\r\n    \t}\r\n       if (udn == null || udn.equals(\"\"))  throw new IllegalArgumentException(\"Invalid udn paramenter\");\r\n        Device device = myCtrl.getDevice(udn);\r\n        if (device == null) {\r\n            logger.WARNING(\"resolveRelativeUrl():: No device data available for UDN: \"+udn);\r\n            return null;\r\n        }\r\n        return resolveRelativeLink(device,link);        \r\n    }","commit_id":"fe2bc84d5300e49f9664150ccb83b6379501bbae","url":"https://github.com/apache/felix"},{"original_method":"public void search(String target) {\r\n        myCtrl.search(target);       \r\n    }","id":88864,"modified_method":"public void search(String target) {\r\n       \tif (myCtrl == null){\r\n    \t\tlogger.WARNING(\"UPnP Importer is disabled. resolveRelativeUrl() is not available\");\r\n    \t\treturn ;\r\n    \t}\r\n       myCtrl.search(target);       \r\n    }","commit_id":"fe2bc84d5300e49f9664150ccb83b6379501bbae","url":"https://github.com/apache/felix"},{"original_method":"public String getLocationURL(String udn) {\r\n        if (udn == null || udn.equals(\"\"))  throw new IllegalArgumentException(\"Invalid udn paramenter\");\r\n        Device device = myCtrl.getDevice(udn);\r\n        if (device == null) logger.WARNING(\"getLocationURL():: No device data available for UDN:\"+udn);\r\n        return myCtrl.getDevice(udn).getLocation();\r\n    }","id":88865,"modified_method":"public String getLocationURL(String udn) {\r\n    \tif (myCtrl == null){\r\n    \t\tlogger.WARNING(\"UPnP Importer is disabled. getLocationURL is not available\");\r\n    \t\treturn null;\r\n    \t}\r\n        if (udn == null || udn.equals(\"\"))  throw new IllegalArgumentException(\"Invalid udn paramenter\");\r\n        Device device = myCtrl.getDevice(udn);\r\n        if (device == null) {\r\n        \tlogger.WARNING(\"getLocationURL():: No device data available for UDN:\"+udn);\r\n        \treturn null;\r\n        }\r\n        return device.getLocation();\r\n    }","commit_id":"fe2bc84d5300e49f9664150ccb83b6379501bbae","url":"https://github.com/apache/felix"},{"original_method":"@Override\n\tpublic void updateFileEntry(\n\t\t\tlong userId, FileEntry fileEntry, FileVersion sourceFileVersion,\n\t\t\tFileVersion destinationFileVersion, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (!DLAppHelperThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, destinationFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\tProcessorCapability processorCapability =\n\t\t\tnew LiferayProcessorCapability();\n\n\t\tif (sourceFileVersion == null) {\n\t\t\tprocessorCapability.generateNew(fileEntry);\n\t\t}\n\t\telse {\n\t\t\tprocessorCapability.copyPrevious(sourceFileVersion);\n\t\t}\n\t}","id":88866,"modified_method":"@Override\n\tpublic void updateFileEntry(\n\t\t\tlong userId, FileEntry fileEntry, FileVersion sourceFileVersion,\n\t\t\tFileVersion destinationFileVersion, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tif (!DLAppHelperThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, destinationFileVersion,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\t}","commit_id":"ea77c618c274dc0a1f0376030c4753c8eb0e223d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion(true));\n\n\t\treturn fileEntry;\n\t}","id":88867,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion(true));\n\t\t_processorCapability.generateNew(fileEntry);\n\n\t\treturn fileEntry;\n\t}","commit_id":"ea77c618c274dc0a1f0376030c4753c8eb0e223d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion(true));\n\n\t\treturn fileEntry;\n\t}","id":88868,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry oldFileEntry = null;\n\t\tFileVersion oldFileVersion = null;\n\n\t\tif (is == null) {\n\t\t\toldFileEntry = getFileEntry(fileEntryId);\n\t\t\toldFileVersion = oldFileEntry.getLatestFileVersion(true);\n\t\t}\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\tif (is == null) {\n\t\t\t_processorCapability.copyPrevious(oldFileVersion);\n\t\t}\n\t\telse {\n\t\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion(true));\n\t\t\t_processorCapability.generateNew(fileEntry);\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"ea77c618c274dc0a1f0376030c4753c8eb0e223d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileVersion cancelCheckOut(long fileEntryId) throws PortalException {\n\t\tFileEntry fileEntry = getFileEntry(fileEntryId);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion());\n\n\t\treturn super.cancelCheckOut(fileEntryId);\n\t}","id":88869,"modified_method":"@Override\n\tpublic FileVersion cancelCheckOut(long fileEntryId) throws PortalException {\n\t\tFileEntry fileEntry = getFileEntry(fileEntryId);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion());\n\n\t\tFileVersion fileVersion = super.cancelCheckOut(fileEntryId);\n\n\t\t_processorCapability.generateNew(fileEntry);\n\n\t\treturn fileVersion;\n\t}","commit_id":"ea77c618c274dc0a1f0376030c4753c8eb0e223d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\tif (is != null) {\n\t\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion());\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":88870,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry oldFileEntry = null;\n\t\tFileVersion oldFileVersion = null;\n\n\t\tif (is == null) {\n\t\t\toldFileEntry = getFileEntry(fileEntryId);\n\t\t\toldFileVersion = oldFileEntry.getLatestFileVersion(true);\n\t\t}\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, is, size, serviceContext);\n\n\t\tif (is == null) {\n\t\t\t_processorCapability.copyPrevious(oldFileVersion);\n\t\t}\n\t\telse {\n\t\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion());\n\t\t\t_processorCapability.generateNew(fileEntry);\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"ea77c618c274dc0a1f0376030c4753c8eb0e223d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion());\n\n\t\treturn fileEntry;\n\t}","id":88871,"modified_method":"@Override\n\tpublic FileEntry updateFileEntry(\n\t\t\tlong userId, long fileEntryId, String sourceFileName,\n\t\t\tString mimeType, String title, String description, String changeLog,\n\t\t\tboolean majorVersion, File file, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = super.updateFileEntry(\n\t\t\tuserId, fileEntryId, sourceFileName, mimeType, title, description,\n\t\t\tchangeLog, majorVersion, file, serviceContext);\n\n\t\t_processorCapability.cleanUp(fileEntry.getLatestFileVersion());\n\t\t_processorCapability.generateNew(fileEntry);\n\n\t\treturn fileEntry;\n\t}","commit_id":"ea77c618c274dc0a1f0376030c4753c8eb0e223d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void fireChange( ConfigurableProperty t, Object newValue ) throws ConfigurablePropertyException {\n      try {\n        if ( newValue instanceof String  ) {\n          final Integer newDuration = Integer.parseInt((String) newValue);\n          if(newDuration < 1)\n            throw new Exception(\"Duration must be larger than 0\");\n          if(newDuration == Integer.parseInt((String)t.getValue()))\n            return;\n          \n          cachedEntities.cleanUp();\n          cachedEntities.invalidateAll();\n          cachedEntities = null;\n        }\n      } catch ( final Exception e ) {\n        throw new ConfigurablePropertyException(\"Could not update cache dueration due to: \" + e.getMessage());\n      }\n    }","id":88872,"modified_method":"@Override\n    public void fireChange( ConfigurableProperty t, Object newValue ) throws ConfigurablePropertyException {\n      try {\n        if ( newValue instanceof String  ) {\n          final Integer newDuration = Integer.parseInt((String) newValue);\n          if(newDuration < 1)\n            throw new Exception(\"Duration must be larger than 0\");\n          if(newDuration == Integer.parseInt((String)t.getValue()))\n            return;\n          if (cachedEntities != null) {\n            cachedEntities.cleanUp();\n            cachedEntities.invalidateAll();\n            cachedEntities = null;\n          }\n        }\n      } catch ( final Exception e ) {\n        throw new ConfigurablePropertyException(\"Could not update cache dueration due to: \" + e.getMessage());\n      }\n    }","commit_id":"c4e3e19b24c6a07da66e80692873ebdb01f4cbec","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public synchronized void loadMap(RotatedTileBox tileRect, List<IMapDownloaderCallback> notifyList) {\n\t\tinterrupted = false;\n\t\tif (currentRenderingContext != null) {\n\t\t\tcurrentRenderingContext = null;\n\t\t}\n\t\ttry {\n\t\t\t// find selected rendering type\n\t\t\tOsmandApplication app = ((OsmandApplication) context.getApplicationContext());\n\t\t\tboolean nightMode = app.getDaynightHelper().isNightMode();\n\t\t\t// boolean moreDetail = prefs.SHOW_MORE_MAP_DETAIL.get();\n\t\t\tRenderingRulesStorage storage = app.getRendererRegistry().getCurrentSelectedRenderer();\n\t\t\tRenderingRuleSearchRequest renderingReq = new RenderingRuleSearchRequest(storage);\n\t\t\trenderingReq.setBooleanFilter(renderingReq.ALL.R_NIGHT_MODE, nightMode);\n\t\t\tfor (RenderingRuleProperty customProp : storage.PROPS.getCustomRules()) {\n\t\t\t\tif (customProp.isBoolean()) {\n\t\t\t\t\tCommonPreference<Boolean> pref = prefs.getCustomRenderBooleanProperty(customProp.getAttrName());\n\t\t\t\t\trenderingReq.setBooleanFilter(customProp, pref.get());\n\t\t\t\t} else {\n\t\t\t\t\tCommonPreference<String> settings = prefs.getCustomRenderProperty(customProp.getAttrName());\n\t\t\t\t\tString res = settings.get();\n\t\t\t\t\tif (!Algorithms.isEmpty(res)) {\n\t\t\t\t\t\tif (customProp.isString()) {\n\t\t\t\t\t\t\trenderingReq.setStringFilter(customProp, res);\n\t\t\t\t\t\t} else if (customProp.isBoolean()) {\n\t\t\t\t\t\t\trenderingReq.setBooleanFilter(customProp, \"true\".equalsIgnoreCase(res));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trenderingReq.setIntFilter(customProp, Integer.parseInt(res));\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trenderingReq.saveState();\n\t\t\tNativeOsmandLibrary nativeLib = !prefs.SAFE_MODE.get() ? NativeOsmandLibrary.getLibrary(storage, context) : null;\n\n\t\t\t// prevent editing\n\t\t\trequestedBox = new RotatedTileBox(tileRect);\n\n\t\t\t// calculate data box\n\t\t\tQuadRect dataBox = requestedBox.getLatLonBounds();\n\t\t\tlong now = System.currentTimeMillis();\n\n\t\t\tif (cObjectsBox.left > dataBox.left || cObjectsBox.top > dataBox.top || cObjectsBox.right < dataBox.right\n\t\t\t\t\t|| cObjectsBox.bottom < dataBox.bottom || (nativeLib != null) == (cNativeObjects == null)) {\n\t\t\t\t// increase data box in order for rotate\n\t\t\t\tif ((dataBox.right - dataBox.left) > (dataBox.top - dataBox.bottom)) {\n\t\t\t\t\tdouble wi = (dataBox.right - dataBox.left) * .2;\n\t\t\t\t\tdataBox.left -= wi;\n\t\t\t\t\tdataBox.right += wi;\n\t\t\t\t} else {\n\t\t\t\t\tdouble hi = (dataBox.top - dataBox.bottom) * .2;\n\t\t\t\t\tdataBox.top += hi;\n\t\t\t\t\tdataBox.bottom -= hi;\n\t\t\t\t}\n\t\t\t\tvalidateLatLonBox(dataBox);\n\t\t\t\tboolean loaded;\n\t\t\t\tif(nativeLib != null) {\n\t\t\t\t\tcObjects = new LinkedList<BinaryMapDataObject>();\n\t\t\t\t\tloaded = loadVectorDataNative(dataBox, requestedBox.getZoom(), renderingReq, nativeLib);\n\t\t\t\t} else {\n\t\t\t\t\tcNativeObjects = null;\n\t\t\t\t\tloaded = loadVectorData(dataBox, requestedBox.getZoom(), renderingReq);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif (!loaded || checkWhetherInterrupted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal long searchTime = System.currentTimeMillis() - now;\n\n\t\t\tcurrentRenderingContext = new OsmandRenderer.RenderingContext(context);\n\t\t\trenderingReq.clearState();\n\t\t\trenderingReq.setIntFilter(renderingReq.ALL.R_MINZOOM, requestedBox.getZoom());\n\t\t\tif(renderingReq.searchRenderingAttribute(RenderingRuleStorageProperties.A_DEFAULT_COLOR)) {\n\t\t\t\tcurrentRenderingContext.defaultColor = renderingReq.getIntPropertyValue(renderingReq.ALL.R_ATTR_COLOR_VALUE);\n\t\t\t}\n\t\t\trenderingReq.clearState();\n\t\t\trenderingReq.setIntFilter(renderingReq.ALL.R_MINZOOM, requestedBox.getZoom());\n\t\t\tif(renderingReq.searchRenderingAttribute(RenderingRuleStorageProperties.A_SHADOW_RENDERING)) {\n\t\t\t\tcurrentRenderingContext.shadowRenderingMode = renderingReq.getIntPropertyValue(renderingReq.ALL.R_ATTR_INT_VALUE);\n\t\t\t\tcurrentRenderingContext.shadowRenderingColor = renderingReq.getIntPropertyValue(renderingReq.ALL.R_SHADOW_COLOR);\n\t\t\t}\n\t\t\t// final QuadPoint lt = requestedBox.getLeftTopTilePoint();\n\t\t\tLatLon lt = requestedBox.getLeftTopLatLon();\n\t\t\tfinal float mapDensity = (float) Math.pow(2, requestedBox.getZoomScale());\n\t\t\tfinal float tileDivisor = (float) MapUtils.getPowZoom(31 - requestedBox.getZoom() -\n\t\t\t\t\t\trequestedBox.getZoomScale());\n\t\t\tcurrentRenderingContext.leftX = MapUtils.get31TileNumberX(lt.getLongitude()) / tileDivisor;\n\t\t\tcurrentRenderingContext.topY = MapUtils.get31TileNumberY(lt.getLatitude()) / tileDivisor;\n\t\t\tcurrentRenderingContext.zoom = requestedBox.getZoom();\n\t\t\tcurrentRenderingContext.rotate = requestedBox.getRotate();\n\t\t\tcurrentRenderingContext.width = requestedBox.getPixWidth();\n\t\t\tcurrentRenderingContext.height = requestedBox.getPixHeight();\n\t\t\tcurrentRenderingContext.nightMode = nightMode;\n\t\t\tcurrentRenderingContext.useEnglishNames = prefs.USE_ENGLISH_NAMES.get();\n\t\t\tcurrentRenderingContext.setDensityValue(mapDensity);\n\t\t\t// init rendering context\n\t\t\tcurrentRenderingContext.tileDivisor = tileDivisor;\n\t\t\tif (checkWhetherInterrupted()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnow = System.currentTimeMillis();\n\t\t\tBitmap bmp;\n\t\t\tboolean transparent = false;\n\t\t\tRenderingRuleProperty rr = storage.PROPS.get(\"noPolygons\");\n\t\t\tif (rr != null) {\n\t\t\t\ttransparent = renderingReq.getIntPropertyValue(rr) > 0;\n\t\t\t}\n\n\t\t\t// 1. generate image step by step\n\t\t\tBitmap reuse = prevBmp;\n\t\t\tthis.prevBmp = this.bmp;\n\t\t\tthis.prevBmpLocation = this.bmpLocation;\n\t\t\tif (reuse != null && reuse.getWidth() == currentRenderingContext.width && reuse.getHeight() == currentRenderingContext.height) {\n\t\t\t\tbmp = reuse;\n\t\t\t\tbmp.eraseColor(currentRenderingContext.defaultColor);\n\t\t\t} else {\n\t\t\t\tif(reuse != null){\n\t\t\t\t\tlog.error(String.format(\"Create new image ? %d != %d (w) %d != %d (h) \", currentRenderingContext.width, reuse.getWidth(), currentRenderingContext.height, reuse.getHeight()));\n\t\t\t\t}\n\t\t\t\tbmp = Bitmap.createBitmap(currentRenderingContext.width, currentRenderingContext.height, Config.RGB_565);\n\t\t\t}\n\t\t\tthis.bmp = bmp;\n\t\t\tthis.bmpLocation = tileRect;\n\t\t\t\n\t\t\tif(nativeLib != null) {\n\t\t\t\trenderer.generateNewBitmapNative(currentRenderingContext, nativeLib, cNativeObjects, bmp, renderingReq, notifyList);\n\t\t\t} else {\n\t\t\t\trenderer.generateNewBitmap(currentRenderingContext, cObjects, bmp, renderingReq, notifyList);\n\t\t\t}\n\t\t\t// Force to use rendering request in order to prevent Garbage Collector when it is used in C++\n\t\t\tif(renderingReq != null){\n\t\t\t\tlog.info(\"Debug :\" + renderingReq != null);\t\t\t\t\n\t\t\t}\n\t\t\tString renderingDebugInfo = currentRenderingContext.renderingDebugInfo;\n\t\t\tcurrentRenderingContext.ended = true;\n\t\t\tif (checkWhetherInterrupted()) {\n\t\t\t\t// revert if it was interrupted \n\t\t\t\t// (be smart a bit do not revert if road already drawn) \n\t\t\t\tif(currentRenderingContext.lastRenderedKey < 35) {\n\t\t\t\t\treuse = this.bmp;\n\t\t\t\t\tthis.bmp = this.prevBmp;\n\t\t\t\t\tthis.bmpLocation = this.prevBmpLocation;\n\t\t\t\t\tthis.prevBmp = reuse;\n\t\t\t\t\tthis.prevBmpLocation = null;\n\t\t\t\t}\n\t\t\t\tcurrentRenderingContext = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurrentRenderingContext = null;\n\n\t\t\t// 2. replace whole image\n\t\t\t// keep cache\n\t\t\t// this.prevBmp = null;\n\t\t\tthis.prevBmpLocation = null;\n\t\t\tif (prefs.DEBUG_RENDERING_INFO.get() && OsmandPlugin.getEnabledPlugin(OsmandDevelopmentPlugin.class) != null) {\n\t\t\t\tString timeInfo = \"Searching: \" + searchTime + \" ms\"; //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$\n\t\t\t\tif (renderingDebugInfo != null) {\n\t\t\t\t\ttimeInfo += \"\\n\" + renderingDebugInfo;\n\t\t\t\t}\n\t\t\t\tfinal String msg = timeInfo;\n\t\t\t\tlog.info(msg);\n\t\t\t\thandler.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tAccessibleToast.makeText(context, msg, Toast.LENGTH_LONG).show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (RuntimeException e) {\n\t\t\tlog.error(\"Runtime memory exception\", e); //$NON-NLS-1$\n\t\t\thandler.post(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tAccessibleToast.makeText(context, R.string.rendering_exception, Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (OutOfMemoryError e) {\n\t\t\tlog.error(\"Out of memory error\", e); //$NON-NLS-1$\n\t\t\tcObjects = new ArrayList<BinaryMapDataObject>();\n\t\t\tcObjectsBox = new QuadRect();\n\t\t\thandler.post(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n//\t\t\t\t\tActivityManager activityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\t\t\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\t\t\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\t\t\t\tint avl = (int) (memoryInfo.availMem / (1 << 20));\n\t\t\t\t\tint max = (int) (Runtime.getRuntime().maxMemory() / (1 << 20)); \n\t\t\t\t\tint avl = (int) (Runtime.getRuntime().freeMemory() / (1 << 20));\n\t\t\t\t\tString s = \" (\" + avl + \" MB available of \" + max  + \") \";\n\t\t\t\t\tAccessibleToast.makeText(context, context.getString(R.string.rendering_out_of_memory) + s , Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t});\n\t\t} finally {\n\t\t\tif(currentRenderingContext != null) {\n\t\t\t\tcurrentRenderingContext.ended = true;\n\t\t\t}\n\t\t}\n\n\t}","id":88873,"modified_method":"public synchronized void loadMap(RotatedTileBox tileRect, List<IMapDownloaderCallback> notifyList) {\n\t\tinterrupted = false;\n\t\tif (currentRenderingContext != null) {\n\t\t\tcurrentRenderingContext = null;\n\t\t}\n\t\ttry {\n\t\t\t// find selected rendering type\n\t\t\tOsmandApplication app = ((OsmandApplication) context.getApplicationContext());\n\t\t\tboolean nightMode = app.getDaynightHelper().isNightMode();\n\t\t\t// boolean moreDetail = prefs.SHOW_MORE_MAP_DETAIL.get();\n\t\t\tRenderingRulesStorage storage = app.getRendererRegistry().getCurrentSelectedRenderer();\n\t\t\tRenderingRuleSearchRequest renderingReq = new RenderingRuleSearchRequest(storage);\n\t\t\trenderingReq.setBooleanFilter(renderingReq.ALL.R_NIGHT_MODE, nightMode);\n\t\t\tfor (RenderingRuleProperty customProp : storage.PROPS.getCustomRules()) {\n\t\t\t\tif (customProp.isBoolean()) {\n\t\t\t\t\tCommonPreference<Boolean> pref = prefs.getCustomRenderBooleanProperty(customProp.getAttrName());\n\t\t\t\t\trenderingReq.setBooleanFilter(customProp, pref.get());\n\t\t\t\t} else {\n\t\t\t\t\tCommonPreference<String> settings = prefs.getCustomRenderProperty(customProp.getAttrName());\n\t\t\t\t\tString res = settings.get();\n\t\t\t\t\tif (!Algorithms.isEmpty(res)) {\n\t\t\t\t\t\tif (customProp.isString()) {\n\t\t\t\t\t\t\trenderingReq.setStringFilter(customProp, res);\n\t\t\t\t\t\t} else if (customProp.isBoolean()) {\n\t\t\t\t\t\t\trenderingReq.setBooleanFilter(customProp, \"true\".equalsIgnoreCase(res));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trenderingReq.setIntFilter(customProp, Integer.parseInt(res));\n\t\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trenderingReq.saveState();\n\t\t\tNativeOsmandLibrary nativeLib = !prefs.SAFE_MODE.get() ? NativeOsmandLibrary.getLibrary(storage, context) : null;\n\n\t\t\t// prevent editing\n\t\t\trequestedBox = new RotatedTileBox(tileRect);\n\n\t\t\t// calculate data box\n\t\t\tQuadRect dataBox = requestedBox.getLatLonBounds();\n\t\t\tlong now = System.currentTimeMillis();\n\n\t\t\tif (cObjectsBox.left > dataBox.left || cObjectsBox.top > dataBox.top || cObjectsBox.right < dataBox.right\n\t\t\t\t\t|| cObjectsBox.bottom < dataBox.bottom || (nativeLib != null) == (cNativeObjects == null)) {\n\t\t\t\t// increase data box in order for rotate\n\t\t\t\tif ((dataBox.right - dataBox.left) > (dataBox.top - dataBox.bottom)) {\n\t\t\t\t\tdouble wi = (dataBox.right - dataBox.left) * .2;\n\t\t\t\t\tdataBox.left -= wi;\n\t\t\t\t\tdataBox.right += wi;\n\t\t\t\t} else {\n\t\t\t\t\tdouble hi = (dataBox.top - dataBox.bottom) * .2;\n\t\t\t\t\tdataBox.top += hi;\n\t\t\t\t\tdataBox.bottom -= hi;\n\t\t\t\t}\n\t\t\t\tvalidateLatLonBox(dataBox);\n\t\t\t\tboolean loaded;\n\t\t\t\tif(nativeLib != null) {\n\t\t\t\t\tcObjects = new LinkedList<BinaryMapDataObject>();\n\t\t\t\t\tloaded = loadVectorDataNative(dataBox, requestedBox.getZoom(), renderingReq, nativeLib);\n\t\t\t\t} else {\n\t\t\t\t\tcNativeObjects = null;\n\t\t\t\t\tloaded = loadVectorData(dataBox, requestedBox.getZoom(), renderingReq);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif (!loaded || checkWhetherInterrupted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal long searchTime = System.currentTimeMillis() - now;\n\n\t\t\tcurrentRenderingContext = new OsmandRenderer.RenderingContext(context);\n\t\t\trenderingReq.clearState();\n\t\t\trenderingReq.setIntFilter(renderingReq.ALL.R_MINZOOM, requestedBox.getZoom());\n\t\t\tif(renderingReq.searchRenderingAttribute(RenderingRuleStorageProperties.A_DEFAULT_COLOR)) {\n\t\t\t\tcurrentRenderingContext.defaultColor = renderingReq.getIntPropertyValue(renderingReq.ALL.R_ATTR_COLOR_VALUE);\n\t\t\t}\n\t\t\trenderingReq.clearState();\n\t\t\trenderingReq.setIntFilter(renderingReq.ALL.R_MINZOOM, requestedBox.getZoom());\n\t\t\tif(renderingReq.searchRenderingAttribute(RenderingRuleStorageProperties.A_SHADOW_RENDERING)) {\n\t\t\t\tcurrentRenderingContext.shadowRenderingMode = renderingReq.getIntPropertyValue(renderingReq.ALL.R_ATTR_INT_VALUE);\n\t\t\t\tcurrentRenderingContext.shadowRenderingColor = renderingReq.getIntPropertyValue(renderingReq.ALL.R_SHADOW_COLOR);\n\t\t\t}\n\t\t\t// final QuadPoint lt = requestedBox.getLeftTopTilePoint();\n\t\t\tLatLon lt = requestedBox.getLeftTopLatLon();\n\t\t\tfinal float mapDensity = (float) Math.pow(2, requestedBox.getZoomScale());\n\t\t\tfinal float tileDivisor = (float) MapUtils.getPowZoom(31 - requestedBox.getZoom() -\n\t\t\t\t\t\trequestedBox.getZoomScale());\n\t\t\tcurrentRenderingContext.leftX = MapUtils.get31TileNumberX(lt.getLongitude()) / tileDivisor;\n\t\t\tcurrentRenderingContext.topY = MapUtils.get31TileNumberY(lt.getLatitude()) / tileDivisor;\n\t\t\tcurrentRenderingContext.zoom = requestedBox.getZoom();\n\t\t\tcurrentRenderingContext.rotate = requestedBox.getRotate();\n\t\t\tcurrentRenderingContext.width = requestedBox.getPixWidth();\n\t\t\tcurrentRenderingContext.height = requestedBox.getPixHeight();\n\t\t\tcurrentRenderingContext.nightMode = nightMode;\n\t\t\tcurrentRenderingContext.useEnglishNames = prefs.USE_ENGLISH_NAMES.get();\n\t\t\tcurrentRenderingContext.setDensityValue(mapDensity);\n\t\t\tcurrentRenderingContext.screenDensityRatio = mapDensity / Math.max(1, requestedBox.getDensity()) ;\n\t\t\t// init rendering context\n\t\t\tcurrentRenderingContext.tileDivisor = tileDivisor;\n\t\t\tif (checkWhetherInterrupted()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnow = System.currentTimeMillis();\n\t\t\tBitmap bmp;\n\t\t\tboolean transparent = false;\n\t\t\tRenderingRuleProperty rr = storage.PROPS.get(\"noPolygons\");\n\t\t\tif (rr != null) {\n\t\t\t\ttransparent = renderingReq.getIntPropertyValue(rr) > 0;\n\t\t\t}\n\n\t\t\t// 1. generate image step by step\n\t\t\tBitmap reuse = prevBmp;\n\t\t\tthis.prevBmp = this.bmp;\n\t\t\tthis.prevBmpLocation = this.bmpLocation;\n\t\t\tif (reuse != null && reuse.getWidth() == currentRenderingContext.width && reuse.getHeight() == currentRenderingContext.height) {\n\t\t\t\tbmp = reuse;\n\t\t\t\tbmp.eraseColor(currentRenderingContext.defaultColor);\n\t\t\t} else {\n\t\t\t\tif(reuse != null){\n\t\t\t\t\tlog.error(String.format(\"Create new image ? %d != %d (w) %d != %d (h) \", currentRenderingContext.width, reuse.getWidth(), currentRenderingContext.height, reuse.getHeight()));\n\t\t\t\t}\n\t\t\t\tbmp = Bitmap.createBitmap(currentRenderingContext.width, currentRenderingContext.height, Config.RGB_565);\n\t\t\t}\n\t\t\tthis.bmp = bmp;\n\t\t\tthis.bmpLocation = tileRect;\n\t\t\t\n\t\t\tif(nativeLib != null) {\n\t\t\t\trenderer.generateNewBitmapNative(currentRenderingContext, nativeLib, cNativeObjects, bmp, renderingReq, notifyList);\n\t\t\t} else {\n\t\t\t\trenderer.generateNewBitmap(currentRenderingContext, cObjects, bmp, renderingReq, notifyList);\n\t\t\t}\n\t\t\t// Force to use rendering request in order to prevent Garbage Collector when it is used in C++\n\t\t\tif(renderingReq != null){\n\t\t\t\tlog.info(\"Debug :\" + renderingReq != null);\t\t\t\t\n\t\t\t}\n\t\t\tString renderingDebugInfo = currentRenderingContext.renderingDebugInfo;\n\t\t\tcurrentRenderingContext.ended = true;\n\t\t\tif (checkWhetherInterrupted()) {\n\t\t\t\t// revert if it was interrupted \n\t\t\t\t// (be smart a bit do not revert if road already drawn) \n\t\t\t\tif(currentRenderingContext.lastRenderedKey < 35) {\n\t\t\t\t\treuse = this.bmp;\n\t\t\t\t\tthis.bmp = this.prevBmp;\n\t\t\t\t\tthis.bmpLocation = this.prevBmpLocation;\n\t\t\t\t\tthis.prevBmp = reuse;\n\t\t\t\t\tthis.prevBmpLocation = null;\n\t\t\t\t}\n\t\t\t\tcurrentRenderingContext = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurrentRenderingContext = null;\n\n\t\t\t// 2. replace whole image\n\t\t\t// keep cache\n\t\t\t// this.prevBmp = null;\n\t\t\tthis.prevBmpLocation = null;\n\t\t\tif (prefs.DEBUG_RENDERING_INFO.get() && OsmandPlugin.getEnabledPlugin(OsmandDevelopmentPlugin.class) != null) {\n\t\t\t\tString timeInfo = \"Searching: \" + searchTime + \" ms\"; //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$\n\t\t\t\tif (renderingDebugInfo != null) {\n\t\t\t\t\ttimeInfo += \"\\n\" + renderingDebugInfo;\n\t\t\t\t}\n\t\t\t\tfinal String msg = timeInfo;\n\t\t\t\tlog.info(msg);\n\t\t\t\thandler.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tAccessibleToast.makeText(context, msg, Toast.LENGTH_LONG).show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (RuntimeException e) {\n\t\t\tlog.error(\"Runtime memory exception\", e); //$NON-NLS-1$\n\t\t\thandler.post(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tAccessibleToast.makeText(context, R.string.rendering_exception, Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (OutOfMemoryError e) {\n\t\t\tlog.error(\"Out of memory error\", e); //$NON-NLS-1$\n\t\t\tcObjects = new ArrayList<BinaryMapDataObject>();\n\t\t\tcObjectsBox = new QuadRect();\n\t\t\thandler.post(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n//\t\t\t\t\tActivityManager activityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\t\t\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\t\t\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\t\t\t\tint avl = (int) (memoryInfo.availMem / (1 << 20));\n\t\t\t\t\tint max = (int) (Runtime.getRuntime().maxMemory() / (1 << 20)); \n\t\t\t\t\tint avl = (int) (Runtime.getRuntime().freeMemory() / (1 << 20));\n\t\t\t\t\tString s = \" (\" + avl + \" MB available of \" + max  + \") \";\n\t\t\t\t\tAccessibleToast.makeText(context, context.getString(R.string.rendering_out_of_memory) + s , Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t});\n\t\t} finally {\n\t\t\tif(currentRenderingContext != null) {\n\t\t\t\tcurrentRenderingContext.ended = true;\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"963abd78fd9d8506d855496bdbeb5c949c5df0fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, boolean area, RenderingContext rc){\n\t\tRenderingRuleProperty rColor;\n\t\tRenderingRuleProperty rStrokeW;\n\t\tRenderingRuleProperty rCap;\n\t\tRenderingRuleProperty rPathEff;\n\t\t\n\t\tif (ind == 0) {\n\t\t\trColor = req.ALL.R_COLOR;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH;\n\t\t\trCap = req.ALL.R_CAP;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT;\n\t\t} else if(ind == 1){\n\t\t\trColor = req.ALL.R_COLOR_2;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_2;\n\t\t\trCap = req.ALL.R_CAP_2;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_2;\n\t\t} else if(ind == -1){\n\t\t\trColor = req.ALL.R_COLOR_0;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_0;\n\t\t\trCap = req.ALL.R_CAP_0;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_0;\n\t\t} else if(ind == -2){\n\t\t\trColor = req.ALL.R_COLOR__1;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH__1;\n\t\t\trCap = req.ALL.R_CAP__1;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT__1;\n\t\t} else {\n\t\t\trColor = req.ALL.R_COLOR_3;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_3;\n\t\t\trCap = req.ALL.R_CAP_3;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_3;\n\t\t}\n\t\tif(area){\n\t\t\tif(!req.isSpecified(rColor) && !req.isSpecified(req.ALL.R_SHADER)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setShader(null);\n\t\t\tp.setColorFilter(null);\n\t\t\tp.clearShadowLayer();\n\t\t\tp.setStyle(Style.FILL_AND_STROKE);\n\t\t\tp.setStrokeWidth(0);\n\t\t} else {\n\t\t\tif(!req.isSpecified(rStrokeW)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setShader(null);\n\t\t\tp.setColorFilter(null);\n\t\t\tp.clearShadowLayer();\n\t\t\tp.setStyle(Style.STROKE);\n\t\t\tp.setStrokeWidth(rc.getComplexValue(req, rStrokeW, 0));\n\t\t\tString cap = req.getStringPropertyValue(rCap);\n\t\t\tif(!Algorithms.isEmpty(cap)){\n\t\t\t\tp.setStrokeCap(Cap.valueOf(cap.toUpperCase()));\n\t\t\t} else {\n\t\t\t\tp.setStrokeCap(Cap.BUTT);\n\t\t\t}\n\t\t\tString pathEffect = req.getStringPropertyValue(rPathEff);\n\t\t\tif (!Algorithms.isEmpty(pathEffect)) {\n\t\t\t\tp.setPathEffect(getDashEffect(pathEffect));\n\t\t\t} else {\n\t\t\t\tp.setPathEffect(null);\n\t\t\t}\n\t\t}\n\t\tp.setColor(req.getIntPropertyValue(rColor));\n\t\tif(ind == 0){\n\t\t\tString resId = req.getStringPropertyValue(req.ALL.R_SHADER);\n\t\t\tif(resId != null){\n\t\t\t\tp.setShader(getShader(resId));\n\t\t\t}\n\t\t\t// do not check shadow color here\n\t\t\tif(rc.shadowRenderingMode == 1) {\n\t\t\t\tint shadowColor = req.getIntPropertyValue(req.ALL.R_SHADOW_COLOR);\n\t\t\t\tif(shadowColor == 0) {\n\t\t\t\t\tshadowColor = rc.shadowRenderingColor;\n\t\t\t\t}\n\t\t\t\tint shadowRadius = (int) rc.getComplexValue(req, req.ALL.R_SHADOW_RADIUS, 0);\n\t\t\t\tif (shadowColor == 0) {\n\t\t\t\t\tshadowRadius = 0;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"Shadow radius \" + shadowRadius);\n\t\t\t\tp.setShadowLayer(shadowRadius, 0, 0, shadowColor);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}","id":88874,"modified_method":"private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, boolean area, RenderingContext rc){\n\t\tRenderingRuleProperty rColor;\n\t\tRenderingRuleProperty rStrokeW;\n\t\tRenderingRuleProperty rCap;\n\t\tRenderingRuleProperty rPathEff;\n\t\t\n\t\tif (ind == 0) {\n\t\t\trColor = req.ALL.R_COLOR;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH;\n\t\t\trCap = req.ALL.R_CAP;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT;\n\t\t} else if(ind == 1){\n\t\t\trColor = req.ALL.R_COLOR_2;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_2;\n\t\t\trCap = req.ALL.R_CAP_2;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_2;\n\t\t} else if(ind == -1){\n\t\t\trColor = req.ALL.R_COLOR_0;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_0;\n\t\t\trCap = req.ALL.R_CAP_0;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_0;\n\t\t} else if(ind == -2){\n\t\t\trColor = req.ALL.R_COLOR__1;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH__1;\n\t\t\trCap = req.ALL.R_CAP__1;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT__1;\n\t\t} else {\n\t\t\trColor = req.ALL.R_COLOR_3;\n\t\t\trStrokeW = req.ALL.R_STROKE_WIDTH_3;\n\t\t\trCap = req.ALL.R_CAP_3;\n\t\t\trPathEff = req.ALL.R_PATH_EFFECT_3;\n\t\t}\n\t\tif(area){\n\t\t\tif(!req.isSpecified(rColor) && !req.isSpecified(req.ALL.R_SHADER)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setShader(null);\n\t\t\tp.setColorFilter(null);\n\t\t\tp.clearShadowLayer();\n\t\t\tp.setStyle(Style.FILL_AND_STROKE);\n\t\t\tp.setStrokeWidth(0);\n\t\t} else {\n\t\t\tif(!req.isSpecified(rStrokeW)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp.setShader(null);\n\t\t\tp.setColorFilter(null);\n\t\t\tp.clearShadowLayer();\n\t\t\tp.setStyle(Style.STROKE);\n\t\t\tp.setStrokeWidth(rc.getComplexValue(req, rStrokeW, 0));\n\t\t\tString cap = req.getStringPropertyValue(rCap);\n\t\t\tif(!Algorithms.isEmpty(cap)){\n\t\t\t\tp.setStrokeCap(Cap.valueOf(cap.toUpperCase()));\n\t\t\t} else {\n\t\t\t\tp.setStrokeCap(Cap.BUTT);\n\t\t\t}\n\t\t\tString pathEffect = req.getStringPropertyValue(rPathEff);\n\t\t\tif (!Algorithms.isEmpty(pathEffect)) {\n\t\t\t\tp.setPathEffect(getDashEffect(pathEffect));\n\t\t\t} else {\n\t\t\t\tp.setPathEffect(null);\n\t\t\t}\n\t\t}\n\t\tp.setColor(req.getIntPropertyValue(rColor));\n\t\tif(ind == 0){\n\t\t\tString resId = req.getStringPropertyValue(req.ALL.R_SHADER);\n\t\t\tif(resId != null){\n\t\t\t\tp.setShader(getShader(resId));\n\t\t\t}\n\t\t\t// do not check shadow color here\n\t\t\tif(rc.shadowRenderingMode == 1) {\n\t\t\t\tint shadowColor = req.getIntPropertyValue(req.ALL.R_SHADOW_COLOR);\n\t\t\t\tif(shadowColor == 0) {\n\t\t\t\t\tshadowColor = rc.shadowRenderingColor;\n\t\t\t\t}\n\t\t\t\tint shadowRadius = (int) rc.getComplexValue(req, req.ALL.R_SHADOW_RADIUS, 0);\n\t\t\t\tif (shadowColor == 0) {\n\t\t\t\t\tshadowRadius = 0;\n\t\t\t\t}\n\t\t\t\tp.setShadowLayer(shadowRadius, 0, 0, shadowColor);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}","commit_id":"963abd78fd9d8506d855496bdbeb5c949c5df0fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.iconsToDraw, new Comparator<IconDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(IconDrawInfo object1, IconDrawInfo object2) {\n\t\t\t\treturn object1.iconOrder - object2.iconOrder;\n\t\t\t}\n\t\t});\n\t\tint skewConstant = (int) rc.getDensityValue(16);\n\t\tint iconsW = rc.width / skewConstant;\n\t\tint iconsH = rc.height / skewConstant;\n\t\tint[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getSmallPoiIcon(context, icon.resId);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint z = (((int) icon.x / skewConstant) + ((int) icon.y / skewConstant) * iconsW);\n\t\t\t\t\t\tint i = z / 32;\n\t\t\t\t\t\tif (i >= alreadyDrawnIcons.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ind = alreadyDrawnIcons[i];\n\t\t\t\t\t\tint b = z % 32;\n\t\t\t\t\t\t// check bit b if it is set\n\t\t\t\t\t\tif (((ind >> b) & 1) == 0) {\n\t\t\t\t\t\t\talreadyDrawnIcons[i] = ind | (1 << b);\n\t\t\t\t\t\t\tcv.drawBitmap(ico, icon.x - ico.getWidth() / 2,\n\t\t\t\t\t\t\t\t\ticon.y - ico.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","id":88875,"modified_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.iconsToDraw, new Comparator<IconDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(IconDrawInfo object1, IconDrawInfo object2) {\n\t\t\t\treturn object1.iconOrder - object2.iconOrder;\n\t\t\t}\n\t\t});\n\t\tint skewConstant = (int) rc.getDensityValue(16);\n\t\tint iconsW = rc.width / skewConstant;\n\t\tint iconsH = rc.height / skewConstant;\n\t\tint[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, icon.resId);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint z = (((int) icon.x / skewConstant) + ((int) icon.y / skewConstant) * iconsW);\n\t\t\t\t\t\tint i = z / 32;\n\t\t\t\t\t\tif (i >= alreadyDrawnIcons.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ind = alreadyDrawnIcons[i];\n\t\t\t\t\t\tint b = z % 32;\n\t\t\t\t\t\t// check bit b if it is set\n\t\t\t\t\t\tif (((ind >> b) & 1) == 0) {\n\t\t\t\t\t\t\talreadyDrawnIcons[i] = ind | (1 << b);\n\t\t\t\t\t\t\tfloat left = icon.x - ico.getWidth() / 2 * rc.screenDensityRatio;\n\t\t\t\t\t\t\tfloat top = icon.y - ico.getHeight() / 2 * rc.screenDensityRatio;\n\t\t\t\t\t\t\tif(rc.screenDensityRatio != 1f){\n\t\t\t\t\t\t\t\tRectF rf = new RectF(left, top, left + ico.getWidth() * rc.screenDensityRatio , \n\t\t\t\t\t\t\t\t\t\ttop + ico.getHeight() * rc.screenDensityRatio);\n\t\t\t\t\t\t\t\tRect src = new Rect(0, 0, ico.getWidth(), ico\n\t\t\t\t\t\t\t\t\t\t.getHeight());\n\t\t\t\t\t\t\t\tcv.drawBitmap(ico, src, rf, paintIcon);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcv.drawBitmap(ico, left, top, paintIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","commit_id":"963abd78fd9d8506d855496bdbeb5c949c5df0fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings nightMode) {\n\t\tif (tb.getZoom() >= startZoom) {\n\t\t\tobjects.clear();\n\t\t\tfinal QuadRect latLonBounds = tb.getLatLonBounds();\n\t\t\tresourceManager.searchAmenitiesAsync(latLonBounds.top, latLonBounds.left, latLonBounds.bottom,\n\t\t\t\t\tlatLonBounds.right, tb.getZoom(), filter, objects);\n\t\t\tint r = getRadiusPoi(tb);\n\t\t\tfor (Amenity o : objects) {\n\t\t\t\tint x = tb.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tint y = tb.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tcanvas.drawCircle(x, y, r, pointAltUI);\n\t\t\t\tcanvas.drawCircle(x, y, r, point);\n\t\t\t\tString id = null;\n\t\t\t\tStringBuilder tag = new StringBuilder();\n\t\t\t\tStringBuilder value = new StringBuilder();\n\t\t\t\tMapRenderingTypes.getDefault().getAmenityTagValue(o.getType(), o.getSubType(), tag, value);\n\t\t\t\tif (RenderingIcons.containsIcon(tag + \"_\" + value)) {\n\t\t\t\t\tid = tag + \"_\" + value;\n\t\t\t\t} else if(RenderingIcons.containsIcon(tag.toString())){\n\t\t\t\t\tid = tag.toString();\n\t\t\t\t} \n\t\t\t\tif(id != null){\n\t\t\t\t\tBitmap bmp = RenderingIcons.getSmallPoiIcon(view.getContext(), id);\n\t\t\t\t\tif(bmp != null){\n\t\t\t\t\t\tcanvas.drawBitmap(bmp, x - bmp.getWidth() / 2, y - bmp.getHeight() / 2, paintIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (view.getSettings().SHOW_POI_LABEL.get()) {\n\t\t\t\tTIntHashSet set = new TIntHashSet();\n\t\t\t\tfor (Amenity o : objects) {\n\t\t\t\t\tint x = tb.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint y = tb.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint tx = tb.getPixXFromLonNoRot(o.getLocation().getLongitude());\n\t\t\t\t\tint ty = tb.getPixYFromLatNoRot(o.getLocation().getLatitude());\n\t\t\t\t\tString name = o.getName(view.getSettings().USE_ENGLISH_NAMES.get());\n\t\t\t\t\tif (name != null && name.length() > 0) {\n\t\t\t\t\t\tint lines = 0;\n\t\t\t\t\t\twhile (lines < TEXT_LINES) {\n\t\t\t\t\t\t\tif (set.contains(division(tx, ty, 0, lines)) ||\n\t\t\t\t\t\t\t\t\tset.contains(division(tx, ty, -1, lines)) || set.contains(division(tx, ty, +1, lines))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lines == 0) {\n\t\t\t\t\t\t\t// drawWrappedText(canvas, \"...\", paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdrawWrappedText(canvas, name, paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2,\n\t\t\t\t\t\t\t\t\tlines);\n\t\t\t\t\t\t\twhile (lines > 0) {\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, -1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 0, lines - 1));\n\t\t\t\t\t\t\t\tlines--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":88876,"modified_method":"@Override\n\tpublic void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings nightMode) {\n\t\tif (tb.getZoom() >= startZoom) {\n\t\t\tobjects.clear();\n\t\t\tfinal QuadRect latLonBounds = tb.getLatLonBounds();\n\t\t\tresourceManager.searchAmenitiesAsync(latLonBounds.top, latLonBounds.left, latLonBounds.bottom,\n\t\t\t\t\tlatLonBounds.right, tb.getZoom(), filter, objects);\n\t\t\tint r = getRadiusPoi(tb);\n\t\t\tfor (Amenity o : objects) {\n\t\t\t\tint x = tb.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tint y = tb.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\tcanvas.drawCircle(x, y, r, pointAltUI);\n\t\t\t\tcanvas.drawCircle(x, y, r, point);\n\t\t\t\tString id = null;\n\t\t\t\tStringBuilder tag = new StringBuilder();\n\t\t\t\tStringBuilder value = new StringBuilder();\n\t\t\t\tMapRenderingTypes.getDefault().getAmenityTagValue(o.getType(), o.getSubType(), tag, value);\n\t\t\t\tif (RenderingIcons.containsIcon(tag + \"_\" + value)) {\n\t\t\t\t\tid = tag + \"_\" + value;\n\t\t\t\t} else if(RenderingIcons.containsIcon(tag.toString())){\n\t\t\t\t\tid = tag.toString();\n\t\t\t\t} \n\t\t\t\tif(id != null){\n\t\t\t\t\tBitmap bmp = RenderingIcons.getIcon(view.getContext(), id);\n\t\t\t\t\tif(bmp != null){\n\t\t\t\t\t\tcanvas.drawBitmap(bmp, x - bmp.getWidth() / 2, y - bmp.getHeight() / 2, paintIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (view.getSettings().SHOW_POI_LABEL.get()) {\n\t\t\t\tTIntHashSet set = new TIntHashSet();\n\t\t\t\tfor (Amenity o : objects) {\n\t\t\t\t\tint x = tb.getPixXFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint y = tb.getPixYFromLatLon(o.getLocation().getLatitude(), o.getLocation().getLongitude());\n\t\t\t\t\tint tx = tb.getPixXFromLonNoRot(o.getLocation().getLongitude());\n\t\t\t\t\tint ty = tb.getPixYFromLatNoRot(o.getLocation().getLatitude());\n\t\t\t\t\tString name = o.getName(view.getSettings().USE_ENGLISH_NAMES.get());\n\t\t\t\t\tif (name != null && name.length() > 0) {\n\t\t\t\t\t\tint lines = 0;\n\t\t\t\t\t\twhile (lines < TEXT_LINES) {\n\t\t\t\t\t\t\tif (set.contains(division(tx, ty, 0, lines)) ||\n\t\t\t\t\t\t\t\t\tset.contains(division(tx, ty, -1, lines)) || set.contains(division(tx, ty, +1, lines))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlines++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lines == 0) {\n\t\t\t\t\t\t\t// drawWrappedText(canvas, \"...\", paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdrawWrappedText(canvas, name, paintTextIcon.getTextSize(), x, y + r + 2 + paintTextIcon.getTextSize() / 2,\n\t\t\t\t\t\t\t\t\tlines);\n\t\t\t\t\t\t\twhile (lines > 0) {\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, -1, lines - 1));\n\t\t\t\t\t\t\t\tset.add(division(tx, ty, 0, lines - 1));\n\t\t\t\t\t\t\t\tlines--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"963abd78fd9d8506d855496bdbeb5c949c5df0fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static Bitmap getIcon(Context ctx, String s) {\n\t\tif (!iconsBmp.containsKey(s)) {\n\t\t\tInteger resId = icons.get(s);\n\t\t\tif (resId != null) {\n\t\t\t\tif (dm == null) {\n\t\t\t\t\tdm = new DisplayMetrics();\n\t\t\t\t\tWindowManager wmgr = (WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE);\n\t\t\t\t\twmgr.getDefaultDisplay().getMetrics(dm);\n\t\t\t\t}\n//\t\t\t\tBitmapFactory.Options options = new BitmapFactory.Options();\n//\t            options.inScaled = false;\n//\t            options.inTargetDensity = dm.densityDpi;\n//\t\t\t\toptions.inDensity = dm.densityDpi;\n\t\t\t\tBitmap bmp = BitmapFactory.decodeResource(ctx.getResources(), resId, null);\n//\t\t\t\tBitmap bmp = UnscaledBitmapLoader.loadFromResource(ctx.getResources(), resId.intValue(), null, dm);\n\t\t\t\ticonsBmp.put(s, bmp);\n\t\t\t} else {\n\t\t\t\ticonsBmp.put(s, null);\n\t\t\t}\n\t\t}\n\t\treturn iconsBmp.get(s);\n\t}","id":88877,"modified_method":"public static Bitmap getIcon(Context ctx, String s) {\n\t\tif (!iconsBmp.containsKey(s)) {\n\t\t\tInteger resId = icons.get(s);\n\t\t\tif (resId != null) {\n\t\t\t\tBitmap bmp = BitmapFactory.decodeResource(ctx.getResources(), resId, null);\n\t\t\t\ticonsBmp.put(s, bmp);\n\t\t\t} else {\n\t\t\t\ticonsBmp.put(s, null);\n\t\t\t}\n\t\t}\n\t\treturn iconsBmp.get(s);\n\t}","commit_id":"963abd78fd9d8506d855496bdbeb5c949c5df0fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {\n\t\tint size = rc.textToDraw.size();\n\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(TextDrawInfo object1, TextDrawInfo object2) {\n\t\t\t\treturn object1.textOrder - object2.textOrder;\n\t\t\t}\n\t\t});\n\t\tQuadRect r = new QuadRect(0, 0, rc.width, rc.height);\n\t\tr.inset(-100, -100);\n\t\tQuadTree<TextDrawInfo> nonIntersectedBounds = new QuadTree<TextDrawInfo>(r, 4, 0.6f);\n\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tTextDrawInfo text = rc.textToDraw.get(i);\n\t\t\tif (text.text != null && text.text.length() > 0) {\n\t\t\t\tif (useEnglishNames) {\n\t\t\t\t\ttext.text = Junidecode.unidecode(text.text);\n\t\t\t\t}\n\n\t\t\t\t// sest text size before finding intersection (it is used there)\n\t\t\t\tfloat textSize = text.textSize;\n\t\t\t\tpaintText.setTextSize(textSize);\n\t\t\t\tpaintText.setFakeBoldText(text.bold);\n\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t// align center y\n\t\t\t\ttext.centerY += (-paintText.ascent());\n\n\t\t\t\t// calculate if there is intersection\n\t\t\t\tboolean intersects = findTextIntersection(cv, rc, nonIntersectedBounds, text);\n\t\t\t\tif (!intersects) {\n\t\t\t\t\tif (text.drawOnPath != null) {\n\t\t\t\t\t\tif (text.textShadow > 0) {\n\t\t\t\t\t\t\tpaintText.setColor(Color.WHITE);\n\t\t\t\t\t\t\tpaintText.setStyle(Style.STROKE);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2 + text.textShadow);\n\t\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t\t\t// reset\n\t\t\t\t\t\t\tpaintText.setStyle(Style.FILL);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2);\n\t\t\t\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (text.shieldRes != null) {\n\t\t\t\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, text.shieldRes);\n\t\t\t\t\t\t\tif (ico != null) {\n\t\t\t\t\t\t\t\tfloat left = text.centerX - ico.getWidth() / 2\n\t\t\t\t\t\t\t\t\t\t- 0.5f;\n\t\t\t\t\t\t\t\tfloat top = text.centerY - ico.getHeight() / 2\n\t\t\t\t\t\t\t\t\t\t- rc.getDensityValue(4.5f);\n\t\t\t\t\t\t\t\tcv.drawBitmap(ico, left, top, paintIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawWrappedText(cv, text, textSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":88878,"modified_method":"public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {\n\t\tint size = rc.textToDraw.size();\n\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(TextDrawInfo object1, TextDrawInfo object2) {\n\t\t\t\treturn object1.textOrder - object2.textOrder;\n\t\t\t}\n\t\t});\n\t\tQuadRect r = new QuadRect(0, 0, rc.width, rc.height);\n\t\tr.inset(-100, -100);\n\t\tQuadTree<TextDrawInfo> nonIntersectedBounds = new QuadTree<TextDrawInfo>(r, 4, 0.6f);\n\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tTextDrawInfo text = rc.textToDraw.get(i);\n\t\t\tif (text.text != null && text.text.length() > 0) {\n\t\t\t\tif (useEnglishNames) {\n\t\t\t\t\ttext.text = Junidecode.unidecode(text.text);\n\t\t\t\t}\n\n\t\t\t\t// sest text size before finding intersection (it is used there)\n\t\t\t\tfloat textSize = text.textSize;\n\t\t\t\tpaintText.setTextSize(textSize);\n\t\t\t\tpaintText.setFakeBoldText(text.bold);\n\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t// align center y\n\t\t\t\ttext.centerY += (-paintText.ascent());\n\n\t\t\t\t// calculate if there is intersection\n\t\t\t\tboolean intersects = findTextIntersection(cv, rc, nonIntersectedBounds, text);\n\t\t\t\tif (!intersects) {\n\t\t\t\t\tif (text.drawOnPath != null) {\n\t\t\t\t\t\tif (text.textShadow > 0) {\n\t\t\t\t\t\t\tpaintText.setColor(Color.WHITE);\n\t\t\t\t\t\t\tpaintText.setStyle(Style.STROKE);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2 + text.textShadow);\n\t\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t\t\t// reset\n\t\t\t\t\t\t\tpaintText.setStyle(Style.FILL);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2);\n\t\t\t\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (text.shieldRes != null) {\n\t\t\t\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, text.shieldRes);\n\t\t\t\t\t\t\tif (ico != null) {\n\t\t\t\t\t\t\t\tfloat left = text.centerX - ico.getWidth() / 2 * rc.screenDensityRatio\n\t\t\t\t\t\t\t\t\t\t- 0.5f;\n\t\t\t\t\t\t\t\tfloat top = text.centerY - ico.getHeight() / 2 * rc.screenDensityRatio\n\t\t\t\t\t\t\t\t\t\t- rc.getDensityValue(4.5f);\n\t\t\t\t\t\t\t\tif(rc.screenDensityRatio != 1f){\n\t\t\t\t\t\t\t\t\tRectF rf = new RectF(left, top, left + ico.getWidth() * rc.screenDensityRatio , \n\t\t\t\t\t\t\t\t\t\t\ttop + ico.getHeight() * rc.screenDensityRatio);\n\t\t\t\t\t\t\t\t\tRect src = new Rect(0, 0, ico.getWidth(), ico\n\t\t\t\t\t\t\t\t\t\t\t.getHeight());\n\t\t\t\t\t\t\t\t\tcv.drawBitmap(ico, src, rf, paintIcon);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcv.drawBitmap(ico, left, top, paintIcon);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawWrappedText(cv, text, textSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"963abd78fd9d8506d855496bdbeb5c949c5df0fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\tint skewConstant = (int) rc.getDensityValue(16);\n\t\tint iconsW = rc.width / skewConstant;\n\t\tint iconsH = rc.height / skewConstant;\n\t\tint[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, icon.resId);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint z = (((int) icon.x / skewConstant) + ((int) icon.y / skewConstant) * iconsW);\n\t\t\t\t\t\tint i = z / 32;\n\t\t\t\t\t\tif (i >= alreadyDrawnIcons.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ind = alreadyDrawnIcons[i];\n\t\t\t\t\t\tint b = z % 32;\n\t\t\t\t\t\t// check bit b if it is set\n\t\t\t\t\t\tif (((ind >> b) & 1) == 0) {\n\t\t\t\t\t\t\talreadyDrawnIcons[i] = ind | (1 << b);\n\t\t\t\t\t\t\tcv.drawBitmap(ico, icon.x - ico.getWidth() / 2, icon.y - ico.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","id":88879,"modified_method":"private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {\n\t\tint skewConstant = (int) rc.getDensityValue(16);\n\t\tint iconsW = rc.width / skewConstant;\n\t\tint iconsH = rc.height / skewConstant;\n\t\tint[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];\n\t\tfor (IconDrawInfo icon : rc.iconsToDraw) {\n\t\t\tif (icon.resId != null) {\n\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, icon.resId);\n\t\t\t\tif (ico != null) {\n\t\t\t\t\tif (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {\n\t\t\t\t\t\tint z = (((int) icon.x / skewConstant) + ((int) icon.y / skewConstant) * iconsW);\n\t\t\t\t\t\tint i = z / 32;\n\t\t\t\t\t\tif (i >= alreadyDrawnIcons.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ind = alreadyDrawnIcons[i];\n\t\t\t\t\t\tint b = z % 32;\n\t\t\t\t\t\t// check bit b if it is set\n\t\t\t\t\t\tif (((ind >> b) & 1) == 0) {\n\t\t\t\t\t\t\talreadyDrawnIcons[i] = ind | (1 << b);\n\t\t\t\t\t\t\tif(rc.highResMode) {\n\t\t\t\t\t\t\t\tfloat left = icon.x - rc.getDensityValue(ico.getWidth() / 2);\n\t\t\t\t\t\t\t\tfloat top = icon.y - rc.getDensityValue(ico.getHeight() / 2);\n\t\t\t\t\t\t\t\tcv.drawBitmap(ico, null, new RectF(left, top, left + rc.getDensityValue(ico.getWidth()), top\n\t\t\t\t\t\t\t\t\t\t+ rc.getDensityValue(ico.getHeight())), paintIcon);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcv.drawBitmap(ico, icon.x - ico.getWidth() / 2, icon.y - ico.getHeight() / 2, paintIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc.interrupted) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","commit_id":"2a2c5567a08af4057fc6ca7ec7f04eb9e2953732","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void createTextDrawInfo(RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair, float xMid, float yMid,\n\t\t\tPath path, PointF[] points, String name, boolean ref) {\n\t\trender.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);\n\t\trender.setIntFilter(render.ALL.R_TEXT_LENGTH, name.length());\n\t\trender.setBooleanFilter(render.ALL.R_REF, ref);\n\t\tif(render.search(RenderingRulesStorage.TEXT_RULES)){\n\t\t\tif(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0){\n\t\t\t\tTextDrawInfo text = new TextDrawInfo(name);\n\t\t\t\ttext.fillProperties(render, xMid, yMid);\n\t\t\t\tpaintText.setTextSize(text.textSize);\n\t\t\t\tRect bs = new Rect();\n\t\t\t\tpaintText.getTextBounds(name, 0, name.length(), bs);\n\t\t\t\ttext.bounds = new RectF(bs);\n\t\t\t\ttext.bounds.inset(-rc.getDensityValue(3), -rc.getDensityValue(10));\n\t\t\t\tboolean display = true;\n\t\t\t\tif(path != null) {\n\t\t\t\t\ttext.drawOnPath = path;\n\t\t\t\t\tdisplay = calculatePathToRotate(rc, text, points, \n\t\t\t\t\t\t\trender.getIntPropertyValue(render.ALL.R_TEXT_ON_PATH, 0) != 0);\n\t\t\t\t}\n\t\t\t\tif(text.drawOnPath == null) {\n\t\t\t\t\ttext.bounds.offset(text.centerX, text.centerY);\n\t\t\t\t\t// shift to match alignment\n\t\t\t\t\ttext.bounds.offset(-text.bounds.width()/2, 0);\n\t\t\t\t} else {\n\t\t\t\t\ttext.bounds.offset(text.centerX - text.bounds.width()/2, text.centerY - text.bounds.height()/2);\n\t\t\t\t}\n\t\t\t\tif(display) {\n\t\t\t\t\trc.textToDraw.add(text);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":88880,"modified_method":"private void createTextDrawInfo(RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair, float xMid, float yMid,\n\t\t\tPath path, PointF[] points, String name, boolean ref) {\n\t\trender.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);\n\t\trender.setIntFilter(render.ALL.R_TEXT_LENGTH, name.length());\n\t\trender.setBooleanFilter(render.ALL.R_REF, ref);\n\t\tif(render.search(RenderingRulesStorage.TEXT_RULES)){\n\t\t\tif(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0){\n\t\t\t\tTextDrawInfo text = new TextDrawInfo(name);\n\t\t\t\ttext.fillProperties(render, xMid, yMid);\n\t\t\t\tpaintText.setTextSize(rc.getDensityValue(text.textSize));\n\t\t\t\tRect bs = new Rect();\n\t\t\t\tpaintText.getTextBounds(name, 0, name.length(), bs);\n\t\t\t\ttext.bounds = new RectF(bs);\n\t\t\t\ttext.bounds.inset(-rc.getDensityValue(3), -rc.getDensityValue(10));\n\t\t\t\tboolean display = true;\n\t\t\t\tif(path != null) {\n\t\t\t\t\ttext.drawOnPath = path;\n\t\t\t\t\tdisplay = calculatePathToRotate(rc, text, points, \n\t\t\t\t\t\t\trender.getIntPropertyValue(render.ALL.R_TEXT_ON_PATH, 0) != 0);\n\t\t\t\t}\n\t\t\t\tif(text.drawOnPath == null) {\n\t\t\t\t\ttext.bounds.offset(text.centerX, text.centerY);\n\t\t\t\t\t// shift to match alignment\n\t\t\t\t\ttext.bounds.offset(-text.bounds.width()/2, 0);\n\t\t\t\t} else {\n\t\t\t\t\ttext.bounds.offset(text.centerX - text.bounds.width()/2, text.centerY - text.bounds.height()/2);\n\t\t\t\t}\n\t\t\t\tif(display) {\n\t\t\t\t\trc.textToDraw.add(text);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"2a2c5567a08af4057fc6ca7ec7f04eb9e2953732","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {\n\t\tint size = rc.textToDraw.size();\n\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(TextDrawInfo object1, TextDrawInfo object2) {\n\t\t\t\treturn object1.textOrder - object2.textOrder;\n\t\t\t}\n\t\t});\n\t\tRectF r = new RectF(0, 0, rc.width, rc.height);\n\t\tr.inset(-100, -100);\n\t\tQuadTree<TextDrawInfo> nonIntersectedBounds = new QuadTree<TextDrawInfo>(r, 4, 0.6f);\n\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tTextDrawInfo text = rc.textToDraw.get(i);\n\t\t\tif (text.text != null && text.text.length() > 0) {\n\t\t\t\tif (useEnglishNames) {\n\t\t\t\t\ttext.text = Junidecode.unidecode(text.text);\n\t\t\t\t}\n\n\t\t\t\t// sest text size before finding intersection (it is used there)\n\t\t\t\tfloat textSize = rc.getDensityValue(text.textSize);\n\t\t\t\tpaintText.setTextSize(textSize);\n\t\t\t\tpaintText.setFakeBoldText(text.bold);\n\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t// align center y\n\t\t\t\ttext.centerY += (-paintText.ascent());\n\n\t\t\t\t// calculate if there is intersection\n\t\t\t\tboolean intersects = findTextIntersection(cv, rc, nonIntersectedBounds, text);\n\t\t\t\tif (!intersects) {\n\t\t\t\t\tif (text.drawOnPath != null) {\n\t\t\t\t\t\tif (text.textShadow > 0) {\n\t\t\t\t\t\t\tpaintText.setColor(Color.WHITE);\n\t\t\t\t\t\t\tpaintText.setStyle(Style.STROKE);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2 + text.textShadow);\n\t\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t\t\t// reset\n\t\t\t\t\t\t\tpaintText.setStyle(Style.FILL);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2);\n\t\t\t\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (text.shieldRes != null) {\n\t\t\t\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, text.shieldRes);\n\t\t\t\t\t\t\tif (ico != null) {\n\t\t\t\t\t\t\t\tcv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f,\n\t\t\t\t\t\t\t\t\t\ttext.centerY - ico.getHeight() / 2 - rc.getDensityValue(4.5f), paintIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawWrappedText(cv, text, textSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":88881,"modified_method":"public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {\n\t\tint size = rc.textToDraw.size();\n\n\t\t// 1. Sort text using text order\n\t\tCollections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {\n\t\t\t@Override\n\t\t\tpublic int compare(TextDrawInfo object1, TextDrawInfo object2) {\n\t\t\t\treturn object1.textOrder - object2.textOrder;\n\t\t\t}\n\t\t});\n\t\tRectF r = new RectF(0, 0, rc.width, rc.height);\n\t\tr.inset(-100, -100);\n\t\tQuadTree<TextDrawInfo> nonIntersectedBounds = new QuadTree<TextDrawInfo>(r, 4, 0.6f);\n\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tTextDrawInfo text = rc.textToDraw.get(i);\n\t\t\tif (text.text != null && text.text.length() > 0) {\n\t\t\t\tif (useEnglishNames) {\n\t\t\t\t\ttext.text = Junidecode.unidecode(text.text);\n\t\t\t\t}\n\n\t\t\t\t// sest text size before finding intersection (it is used there)\n\t\t\t\tfloat textSize = rc.getDensityValue(text.textSize);\n\t\t\t\tpaintText.setTextSize(textSize);\n\t\t\t\tpaintText.setFakeBoldText(text.bold);\n\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t// align center y\n\t\t\t\ttext.centerY += (-paintText.ascent());\n\n\t\t\t\t// calculate if there is intersection\n\t\t\t\tboolean intersects = findTextIntersection(cv, rc, nonIntersectedBounds, text);\n\t\t\t\tif (!intersects) {\n\t\t\t\t\tif (text.drawOnPath != null) {\n\t\t\t\t\t\tif (text.textShadow > 0) {\n\t\t\t\t\t\t\tpaintText.setColor(Color.WHITE);\n\t\t\t\t\t\t\tpaintText.setStyle(Style.STROKE);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2 + text.textShadow);\n\t\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t\t\t// reset\n\t\t\t\t\t\t\tpaintText.setStyle(Style.FILL);\n\t\t\t\t\t\t\tpaintText.setStrokeWidth(2);\n\t\t\t\t\t\t\tpaintText.setColor(text.textColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (text.shieldRes != null) {\n\t\t\t\t\t\t\tBitmap ico = RenderingIcons.getIcon(context, text.shieldRes);\n\t\t\t\t\t\t\tif (ico != null) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (rc.highResMode) {\n\t\t\t\t\t\t\t\t\tfloat left = text.centerX - rc.getDensityValue(ico.getWidth() / 2) - 0.5f;\n\t\t\t\t\t\t\t\t\tfloat top = text.centerY - rc.getDensityValue(ico.getHeight() / 2) - rc.getDensityValue(4.5f);\n\t\t\t\t\t\t\t\t\tRect rec = new Rect(0, 0, ico.getWidth(), ico.getHeight());\n\t\t\t\t\t\t\t\t\tcv.drawBitmap(ico, rec,\n\t\t\t\t\t\t\t\t\t\t\tnew RectF(left, top, left + rc.getDensityValue(ico.getWidth()), top\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ rc.getDensityValue(ico.getHeight())), paintIcon);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfloat left = text.centerX - ico.getWidth() / 2 - 0.5f;\n\t\t\t\t\t\t\t\t\tfloat top = text.centerY - ico.getHeight() / 2 - rc.getDensityValue(4.5f);\n\t\t\t\t\t\t\t\t\tcv.drawBitmap(ico, left, top, paintIcon);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawWrappedText(cv, text, textSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"2a2c5567a08af4057fc6ca7ec7f04eb9e2953732","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n    public AclPolicyResponse createAclPolicyResponse(AclPolicy policy) {\r\n        AclPolicyResponse response = new AclPolicyResponse();\r\n        response.setId(policy.getUuid());\r\n        response.setName(policy.getName());\r\n        response.setDescription(policy.getDescription());\r\n        String domainPath = policy.getPath();\r\n        if (domainPath != null) {\r\n            DomainVO domain = _domainDao.findDomainByPath(domainPath);\r\n            if (domain != null) {\r\n                response.setDomainId(domain.getUuid());\r\n                response.setDomainName(domain.getName());\r\n            }\r\n        }\r\n        long accountId = policy.getAccountId();\r\n        AccountVO owner = _accountDao.findById(accountId);\r\n        if (owner != null) {\r\n            response.setAccountName(owner.getAccountName());\r\n        }\r\n        // find permissions associated with this policy\r\n        List<AclPolicyPermission> permissions = _iamSrv.listPolicyPermissions(policy.getId());\r\n        if (permissions != null && permissions.size() > 0) {\r\n            for (AclPolicyPermission permission : permissions) {\r\n                AclPermissionResponse perm = new AclPermissionResponse();\r\n                perm.setAction(permission.getAction());\r\n                perm.setEntityType(AclEntityType.valueOf(permission.getEntityType()));\r\n                perm.setScope(PermissionScope.valueOf(permission.getScope()));\r\n                perm.setScopeId(permission.getScopeId());\r\n                perm.setPermission(permission.getPermission());\r\n                response.addPermission(perm);\r\n            }\r\n        }\r\n        response.setObjectName(\"aclpolicy\");\r\n        return response;\r\n    }","id":88882,"modified_method":"@Override\r\n    public AclPolicyResponse createAclPolicyResponse(AclPolicy policy) {\r\n        AclPolicyResponse response = new AclPolicyResponse();\r\n        response.setId(policy.getUuid());\r\n        response.setName(policy.getName());\r\n        response.setDescription(policy.getDescription());\r\n        String domainPath = policy.getPath();\r\n        if (domainPath != null) {\r\n            DomainVO domain = _domainDao.findDomainByPath(domainPath);\r\n            if (domain != null) {\r\n                response.setDomainId(domain.getUuid());\r\n                response.setDomainName(domain.getName());\r\n            }\r\n        }\r\n        long accountId = policy.getAccountId();\r\n        AccountVO owner = _accountDao.findById(accountId);\r\n        if (owner != null) {\r\n            response.setAccountName(owner.getAccountName());\r\n        }\r\n        // find permissions associated with this policy\r\n        List<AclPolicyPermission> permissions = _iamSrv.listPolicyPermissions(policy.getId());\r\n        if (permissions != null && permissions.size() > 0) {\r\n            for (AclPolicyPermission permission : permissions) {\r\n                AclPermissionResponse perm = new AclPermissionResponse();\r\n                perm.setAction(permission.getAction());\r\n                if (permission.getEntityType() != null) {\r\n                    perm.setEntityType(AclEntityType.valueOf(permission.getEntityType()));\r\n                }\r\n                if (permission.getScope() != null) {\r\n                    perm.setScope(PermissionScope.valueOf(permission.getScope()));\r\n                }\r\n                perm.setScopeId(permission.getScopeId());\r\n                perm.setPermission(permission.getPermission());\r\n                response.addPermission(perm);\r\n            }\r\n        }\r\n        response.setObjectName(\"aclpolicy\");\r\n        return response;\r\n    }","commit_id":"4b75fa806ab2d6394a34eabe05aa9fd3c96990c1","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public StoragePoolResponse newStoragePoolResponse(StoragePoolJoinVO pool) {\n        StoragePoolResponse poolResponse = new StoragePoolResponse();\n        poolResponse.setId(pool.getUuid());\n        poolResponse.setName(pool.getName());\n        poolResponse.setState(pool.getStatus());\n        poolResponse.setPath(pool.getPath());\n        poolResponse.setIpAddress(pool.getHostAddress());\n        poolResponse.setZoneId(pool.getZoneUuid());\n        poolResponse.setZoneName(pool.getZoneName());\n        poolResponse.setType(pool.getPoolType().toString());\n        poolResponse.setPodId(pool.getPodUuid());\n        poolResponse.setPodName(pool.getPodName());\n        poolResponse.setCreated(pool.getCreated());\n        poolResponse.setScope(pool.getScope().toString());\n        if (pool.getHypervisor() != null) {\n            poolResponse.setHypervisor(pool.getHypervisor().toString());\n        }\n\n        long allocatedSize = pool.getUsedCapacity() + pool.getReservedCapacity();\n        poolResponse.setDiskSizeTotal(pool.getCapacityBytes());\n        poolResponse.setDiskSizeAllocated(allocatedSize);\n        poolResponse.setCapacityIops(pool.getCapacityIops());\n\n        // TODO: StatsCollector does not persist data\n        StorageStats stats = ApiDBUtils.getStoragePoolStatistics(pool.getId());\n        if (stats != null) {\n            Long used = stats.getByteUsed();\n            poolResponse.setDiskSizeUsed(used);\n        }\n\n        poolResponse.setClusterId(pool.getClusterUuid());\n        poolResponse.setClusterName(pool.getClusterName());\n        poolResponse.setTags(pool.getTag());\n\n        // set async job\n        if (pool.getJobId() != null) {\n            poolResponse.setJobId(pool.getJobUuid());\n            poolResponse.setJobStatus(pool.getJobStatus());\n        }\n\n        poolResponse.setObjectName(\"storagepool\");\n        return poolResponse;\n    }","id":88883,"modified_method":"@Override\n    public StoragePoolResponse newStoragePoolResponse(StoragePoolJoinVO pool) {\n        StoragePoolResponse poolResponse = new StoragePoolResponse();\n        poolResponse.setId(pool.getUuid());\n        poolResponse.setName(pool.getName());\n        poolResponse.setState(pool.getStatus());\n        poolResponse.setPath(pool.getPath());\n        poolResponse.setIpAddress(pool.getHostAddress());\n        poolResponse.setZoneId(pool.getZoneUuid());\n        poolResponse.setZoneName(pool.getZoneName());\n        poolResponse.setType(pool.getPoolType().toString());\n        poolResponse.setPodId(pool.getPodUuid());\n        poolResponse.setPodName(pool.getPodName());\n        poolResponse.setCreated(pool.getCreated());\n        if (pool.getScope() != null) {\n            poolResponse.setScope(pool.getScope().toString());\n        }\n        if (pool.getHypervisor() != null) {\n            poolResponse.setHypervisor(pool.getHypervisor().toString());\n        }\n\n        long allocatedSize = pool.getUsedCapacity() + pool.getReservedCapacity();\n        poolResponse.setDiskSizeTotal(pool.getCapacityBytes());\n        poolResponse.setDiskSizeAllocated(allocatedSize);\n        poolResponse.setCapacityIops(pool.getCapacityIops());\n\n        // TODO: StatsCollector does not persist data\n        StorageStats stats = ApiDBUtils.getStoragePoolStatistics(pool.getId());\n        if (stats != null) {\n            Long used = stats.getByteUsed();\n            poolResponse.setDiskSizeUsed(used);\n        }\n\n        poolResponse.setClusterId(pool.getClusterUuid());\n        poolResponse.setClusterName(pool.getClusterName());\n        poolResponse.setTags(pool.getTag());\n\n        // set async job\n        if (pool.getJobId() != null) {\n            poolResponse.setJobId(pool.getJobUuid());\n            poolResponse.setJobStatus(pool.getJobStatus());\n        }\n\n        poolResponse.setObjectName(\"storagepool\");\n        return poolResponse;\n    }","commit_id":"13fc4690fc39ebded2cf80895d8fd3a622c5b957","url":"https://github.com/apache/cloudstack"},{"original_method":"private void doReplacement(final ReplacementInfoImpl info,\n                             final PsiElement elementToReplace,\n                             final String replacementToMake,\n                             final PsiElement elementParent) {\n    boolean listContext = false;\n\n    try {\n      if (context == null) context = new ReplacementContext(options, project);\n      context.replacementInfo = info;\n\n      PsiElement el = findRealSubstitutionElement(elementToReplace);\n      listContext = isListContext(el);\n\n      PsiElement[] statements = MatcherImplUtil.createTreeFromText(\n        replacementToMake,\n        el instanceof PsiMember && !isSymbolReplacement(el, context)?\n        MatcherImplUtil.TreeContext.Class :\n        MatcherImplUtil.TreeContext.Block,\n        options.getMatchOptions().getFileType(),\n        project\n      );\n\n\n      if (listContext) {\n        if (statements.length > 1) {\n          elementParent.addRangeBefore(statements[0],statements[statements.length-1],elementToReplace);\n        } else if (statements.length==1) {\n          PsiElement replacement = getMatchExpr(statements[0], elementToReplace);\n\n          handleModifierList(el, replacement, context);\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          if (replacement instanceof PsiTryStatement) {\n            final List<PsiCodeBlock> unmatchedCatchBlocks = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_BLOCK_CONTENT_VAR_KEY);\n            final List<PsiParameter> unmatchedCatchParams = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_PARAM_CONTENT_VAR_KEY);\n            final PsiCatchSection[] catches = ((PsiTryStatement)replacement).getCatchSections();\n\n            if (unmatchedCatchBlocks!=null && unmatchedCatchParams!=null) {\n              for(int i = unmatchedCatchBlocks.size()-1; i >= 0; --i) {\n                final PsiParameter parameter = unmatchedCatchParams.get(i);\n                final PsiCatchSection catchSection = PsiManager.getInstance(project).getElementFactory().createCatchSection(\n                  (PsiClassType)parameter.getType(),\n                  parameter.getName(),\n                  null\n                );\n\n                catchSection.getCatchBlock().replace(\n                  unmatchedCatchBlocks.get(i)\n                );\n                replacement.addAfter(\n                  catchSection, catches[catches.length-1]\n                );\n                replacement.addBefore(createWhiteSpace(replacement), replacement.getLastChild());\n              }\n            }\n          }\n\n          final PsiElement inserted = elementParent.addBefore(replacement,elementToReplace);\n\n          if (replacement instanceof PsiComment &&\n               ( elementParent instanceof PsiIfStatement ||\n                 elementParent instanceof PsiLoopStatement\n               )\n              ) {\n            elementParent.addAfter(createSemicolon(replacement),inserted);\n          }\n        }\n      } else if (statements.length > 0) {\n        int i = 0;\n        while( true ) {    // if it goes out of bounds then deep error happens\n          if (!(statements[i] instanceof PsiComment ||\n                statements[i] instanceof PsiWhiteSpace\n          )\n            ) {\n            break;\n          }\n          ++i;\n        }\n\n        if (i != 0) {\n          elementParent.addRangeBefore(statements[0],statements[i-1],el);\n        }\n        PsiElement replacement = getMatchExpr(statements[i], elementToReplace);\n\n        if (replacement instanceof PsiStatement &&\n            !(replacement.getLastChild() instanceof PsiJavaToken)\n           ) {\n          // assert w/o ;\n          final PsiElement prevLastChildInParent = replacement.getLastChild().getPrevSibling();\n\n          if (prevLastChildInParent != null) {\n            elementParent.addRangeBefore(replacement.getFirstChild(), prevLastChildInParent,el);\n          } else {\n            elementParent.addBefore(replacement.getFirstChild(), el);\n          }\n\n          el.getNode().getTreeParent().removeChild(el.getNode());\n        } else {\n          // preserve comments\n          handleModifierList(el, replacement, context);\n\n          if (replacement instanceof PsiClass) {\n            // modifier list\n            final PsiStatement[] searchStatements = context.getCodeBlock().getStatements();\n            if (searchStatements.length > 0 &&\n                searchStatements[0] instanceof PsiDeclarationStatement &&\n                ((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0] instanceof PsiClass\n               ) {\n              final PsiClass replaceClazz = (PsiClass)replacement;\n              final PsiClass queryClazz = (PsiClass)((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0];\n              final PsiClass clazz = (PsiClass)el;\n\n              if (replaceClazz.getExtendsList().getTextLength() == 0 &&\n                  queryClazz.getExtendsList().getTextLength() == 0 &&\n                  clazz.getExtendsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getExtendsList().getPrevSibling(),replaceClazz.getExtendsList()); // whitespace\n                replaceClazz.getExtendsList().addRange(\n                  clazz.getExtendsList().getFirstChild(),clazz.getExtendsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getImplementsList().getTextLength() == 0 &&\n                  queryClazz.getImplementsList().getTextLength() == 0 &&\n                  clazz.getImplementsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getImplementsList().getPrevSibling(),replaceClazz.getImplementsList()); // whitespace\n                replaceClazz.getImplementsList().addRange(\n                  clazz.getImplementsList().getFirstChild(),\n                  clazz.getImplementsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getTypeParameterList().getTextLength() == 0 &&\n                  queryClazz.getTypeParameterList().getTextLength() == 0 &&\n                  clazz.getTypeParameterList().getTextLength() != 0\n                  ) {\n                // skip < and >\n                replaceClazz.getTypeParameterList().replace(\n                  clazz.getTypeParameterList()\n                );\n              }\n            }\n          }\n\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          el.replace(replacement);\n        }\n      } else {\n        final PsiElement nextSibling = el.getNextSibling();\n        el.delete();\n        if(nextSibling.isValid()){\n          if (nextSibling instanceof PsiWhiteSpace) {\n            nextSibling.delete();\n          }\n        }\n      }\n\n    } catch(IncorrectOperationException ex) {\n      ex.printStackTrace();\n    }\n\n    if (listContext) {\n      for (SmartPsiElementPointer aMatchesPtrList : info.matchesPtrList) {\n        try {\n          PsiElement element = findRealSubstitutionElement(\n            aMatchesPtrList.getElement()\n          );\n\n          PsiElement firstToDelete = element;\n          PsiElement lastToDelete = element;\n          PsiElement prevSibling = element.getPrevSibling();\n          PsiElement nextSibling = element.getNextSibling();\n\n          if (prevSibling instanceof PsiWhiteSpace) {\n            firstToDelete = prevSibling;\n            prevSibling = prevSibling != null ? prevSibling.getPrevSibling(): null;\n          } else if (prevSibling == null && nextSibling instanceof PsiWhiteSpace) {\n            lastToDelete = nextSibling;\n          }\n\n          if (element instanceof PsiExpression) {\n            final PsiElement parent = element.getParent().getParent();\n            if ((parent instanceof PsiCall ||\n                 parent instanceof PsiAnonymousClass\n                ) &&\n                prevSibling instanceof PsiJavaToken &&\n                ((PsiJavaToken)prevSibling).getTokenType() == ElementType.COMMA\n               ) {\n              firstToDelete = prevSibling;\n            }\n          }\n\n          element.getParent().deleteChildRange(firstToDelete,lastToDelete);\n        }\n        catch (IncorrectOperationException ex) {\n          ex.printStackTrace();\n        }\n      }\n    }\n  }","id":88884,"modified_method":"private void doReplacement(final ReplacementInfoImpl info,\n                             final PsiElement elementToReplace,\n                             final String replacementToMake,\n                             final PsiElement elementParent) {\n    boolean listContext = false;\n\n    try {\n      if (context == null) context = new ReplacementContext(options, project);\n      context.replacementInfo = info;\n\n      PsiElement el = findRealSubstitutionElement(elementToReplace);\n      listContext = isListContext(el);\n\n      PsiElement[] statements = MatcherImplUtil.createTreeFromText(\n        replacementToMake,\n        el instanceof PsiMember && !isSymbolReplacement(el, context)?\n        MatcherImplUtil.TreeContext.Class :\n        MatcherImplUtil.TreeContext.Block,\n        options.getMatchOptions().getFileType(),\n        project\n      );\n\n\n      if (listContext) {\n        if (statements.length > 1) {\n          elementParent.addRangeBefore(statements[0],statements[statements.length-1],elementToReplace);\n        } else if (statements.length==1) {\n          PsiElement replacement = getMatchExpr(statements[0], elementToReplace);\n\n          handleModifierList(el, replacement, context);\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          if (replacement instanceof PsiTryStatement) {\n            final List<PsiCodeBlock> unmatchedCatchBlocks = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_BLOCK_CONTENT_VAR_KEY);\n            final List<PsiParameter> unmatchedCatchParams = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_PARAM_CONTENT_VAR_KEY);\n            final PsiCatchSection[] catches = ((PsiTryStatement)replacement).getCatchSections();\n\n            if (unmatchedCatchBlocks!=null && unmatchedCatchParams!=null) {\n              for(int i = unmatchedCatchBlocks.size()-1; i >= 0; --i) {\n                final PsiParameter parameter = unmatchedCatchParams.get(i);\n                final PsiCatchSection catchSection = PsiManager.getInstance(project).getElementFactory().createCatchSection(\n                  (PsiClassType)parameter.getType(),\n                  parameter.getName(),\n                  null\n                );\n\n                catchSection.getCatchBlock().replace(\n                  unmatchedCatchBlocks.get(i)\n                );\n                replacement.addAfter(\n                  catchSection, catches[catches.length-1]\n                );\n                replacement.addBefore(createWhiteSpace(replacement), replacement.getLastChild());\n              }\n            }\n          }\n\n          try {\n            final PsiElement inserted = elementParent.addBefore(replacement,elementToReplace);\n\n            if (replacement instanceof PsiComment &&\n                 ( elementParent instanceof PsiIfStatement ||\n                   elementParent instanceof PsiLoopStatement\n                 )\n                ) {\n              elementParent.addAfter(createSemicolon(replacement),inserted);\n            }\n          }\n          catch (IncorrectOperationException e) {\n            elementToReplace.replace(replacement);\n          }\n        }\n      } else if (statements.length > 0) {\n        int i = 0;\n        while( true ) {    // if it goes out of bounds then deep error happens\n          if (!(statements[i] instanceof PsiComment ||\n                statements[i] instanceof PsiWhiteSpace\n          )\n            ) {\n            break;\n          }\n          ++i;\n        }\n\n        if (i != 0) {\n          elementParent.addRangeBefore(statements[0],statements[i-1],el);\n        }\n        PsiElement replacement = getMatchExpr(statements[i], elementToReplace);\n\n        if (replacement instanceof PsiStatement &&\n            !(replacement.getLastChild() instanceof PsiJavaToken)\n           ) {\n          // assert w/o ;\n          final PsiElement prevLastChildInParent = replacement.getLastChild().getPrevSibling();\n\n          if (prevLastChildInParent != null) {\n            elementParent.addRangeBefore(replacement.getFirstChild(), prevLastChildInParent,el);\n          } else {\n            elementParent.addBefore(replacement.getFirstChild(), el);\n          }\n\n          el.getNode().getTreeParent().removeChild(el.getNode());\n        } else {\n          // preserve comments\n          handleModifierList(el, replacement, context);\n\n          if (replacement instanceof PsiClass) {\n            // modifier list\n            final PsiStatement[] searchStatements = context.getCodeBlock().getStatements();\n            if (searchStatements.length > 0 &&\n                searchStatements[0] instanceof PsiDeclarationStatement &&\n                ((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0] instanceof PsiClass\n               ) {\n              final PsiClass replaceClazz = (PsiClass)replacement;\n              final PsiClass queryClazz = (PsiClass)((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0];\n              final PsiClass clazz = (PsiClass)el;\n\n              if (replaceClazz.getExtendsList().getTextLength() == 0 &&\n                  queryClazz.getExtendsList().getTextLength() == 0 &&\n                  clazz.getExtendsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getExtendsList().getPrevSibling(),replaceClazz.getExtendsList()); // whitespace\n                replaceClazz.getExtendsList().addRange(\n                  clazz.getExtendsList().getFirstChild(),clazz.getExtendsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getImplementsList().getTextLength() == 0 &&\n                  queryClazz.getImplementsList().getTextLength() == 0 &&\n                  clazz.getImplementsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getImplementsList().getPrevSibling(),replaceClazz.getImplementsList()); // whitespace\n                replaceClazz.getImplementsList().addRange(\n                  clazz.getImplementsList().getFirstChild(),\n                  clazz.getImplementsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getTypeParameterList().getTextLength() == 0 &&\n                  queryClazz.getTypeParameterList().getTextLength() == 0 &&\n                  clazz.getTypeParameterList().getTextLength() != 0\n                  ) {\n                // skip < and >\n                replaceClazz.getTypeParameterList().replace(\n                  clazz.getTypeParameterList()\n                );\n              }\n            }\n          }\n\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          el.replace(replacement);\n        }\n      } else {\n        final PsiElement nextSibling = el.getNextSibling();\n        el.delete();\n        if(nextSibling.isValid()){\n          if (nextSibling instanceof PsiWhiteSpace) {\n            nextSibling.delete();\n          }\n        }\n      }\n\n    } catch(IncorrectOperationException ex) {\n      ex.printStackTrace();\n    }\n\n    if (listContext) {\n      for (SmartPsiElementPointer aMatchesPtrList : info.matchesPtrList) {\n        try {\n          PsiElement element = findRealSubstitutionElement(\n            aMatchesPtrList.getElement()\n          );\n\n          if (element == null) continue;\n          PsiElement firstToDelete = element;\n          PsiElement lastToDelete = element;\n          PsiElement prevSibling = element.getPrevSibling();\n          PsiElement nextSibling = element.getNextSibling();\n\n          if (prevSibling instanceof PsiWhiteSpace) {\n            firstToDelete = prevSibling;\n            prevSibling = prevSibling != null ? prevSibling.getPrevSibling(): null;\n          } else if (prevSibling == null && nextSibling instanceof PsiWhiteSpace) {\n            lastToDelete = nextSibling;\n          }\n\n          if (element instanceof PsiExpression) {\n            final PsiElement parent = element.getParent().getParent();\n            if ((parent instanceof PsiCall ||\n                 parent instanceof PsiAnonymousClass\n                ) &&\n                prevSibling instanceof PsiJavaToken &&\n                ((PsiJavaToken)prevSibling).getTokenType() == ElementType.COMMA\n               ) {\n              firstToDelete = prevSibling;\n            }\n          }\n\n          element.getParent().deleteChildRange(firstToDelete,lastToDelete);\n        }\n        catch (IncorrectOperationException ex) {\n          ex.printStackTrace();\n        }\n      }\n    }\n  }","commit_id":"cee14d1ee30ec5edb469ea9b55dec83084f01779","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String testReplace(String in, String what, String by, ReplaceOptions options,boolean filePattern) {\n    this.options = options;\n    this.options.getMatchOptions().setSearchPattern(what);\n    this.options.setReplacement(by);\n    replacementBuilder=null;\n    context = null;\n\n    this.options.getMatchOptions().clearVariableConstraints();\n    MatcherImplUtil.transform(this.options.getMatchOptions());\n\n    checkSupportedReplacementPattern(\n      project,\n      this.options.getMatchOptions().getSearchPattern(),\n      by,\n      this.options.getMatchOptions().getFileType()\n    );\n\n    Matcher matcher = new Matcher(project);\n    try {\n      PsiElement[] elements = MatcherImplUtil.createTreeFromText(\n        in,\n        filePattern ? MatcherImplUtil.TreeContext.File : MatcherImplUtil.TreeContext.Block,\n        this.options.getMatchOptions().getFileType(),\n        project\n      );\n      PsiElement firstElement = elements[0];\n      PsiElement lastElement = elements[elements.length-1];\n      PsiElement parent = firstElement.getParent();\n\n      this.options.getMatchOptions().setScope(\n        new LocalSearchScope(parent)\n      );\n\n      this.options.getMatchOptions().setResultIsContextMatch(true);\n      CollectingMatchResultSink sink = new CollectingMatchResultSink();\n\n      matcher.testFindMatches(sink,this.options.getMatchOptions());\n\n      final List<ReplacementInfo> resultPtrList = new LinkedList<ReplacementInfo>();\n\n      for (final MatchResult result : sink.getMatches()) {\n        resultPtrList.add(buildReplacement(result));\n      }\n\n      sink.getMatches().clear();\n\n      int startOffset = firstElement.getTextRange().getStartOffset();\n      int endOffset = filePattern ?0: parent.getTextLength() - (lastElement.getTextRange().getEndOffset());\n\n      // get nodes from text may contain\n      PsiElement prevSibling = firstElement.getPrevSibling();\n      if (prevSibling instanceof PsiWhiteSpace) {\n        startOffset -= prevSibling.getTextLength() - 1;\n      }\n\n      PsiElement nextSibling = lastElement.getNextSibling();\n      if (nextSibling instanceof PsiWhiteSpace) {\n        endOffset -= nextSibling.getTextLength() - 1;\n      }\n\n      replaceAll(resultPtrList);\n\n      String result = parent.getText();\n      result = result.substring(startOffset);\n      result = result.substring(0,result.length() - endOffset);\n\n      return result;\n    } catch(Exception ex) {\n      ex.printStackTrace( );\n      return \"\";\n    }\n  }","id":88885,"modified_method":"protected String testReplace(String in, String what, String by, ReplaceOptions options,boolean filePattern) {\n    this.options = options;\n    this.options.getMatchOptions().setSearchPattern(what);\n    this.options.setReplacement(by);\n    replacementBuilder=null;\n    context = null;\n\n    this.options.getMatchOptions().clearVariableConstraints();\n    MatcherImplUtil.transform(this.options.getMatchOptions());\n\n    checkSupportedReplacementPattern(\n      project,\n      this.options.getMatchOptions().getSearchPattern(),\n      by,\n      this.options.getMatchOptions().getFileType()\n    );\n\n    Matcher matcher = new Matcher(project);\n    try {\n      PsiElement firstElement, lastElement, parent;\n\n      if (options.getMatchOptions().getScope() == null) {\n        PsiElement[] elements = MatcherImplUtil.createTreeFromText(\n          in,\n          filePattern ? MatcherImplUtil.TreeContext.File : MatcherImplUtil.TreeContext.Block,\n          this.options.getMatchOptions().getFileType(),\n          project\n        );\n\n        firstElement = elements[0];\n        lastElement = elements[elements.length-1];\n        parent = firstElement.getParent();\n\n        this.options.getMatchOptions().setScope(\n          new LocalSearchScope(parent)\n        );\n      } else {\n        parent = ((LocalSearchScope)options.getMatchOptions().getScope()).getScope()[0];\n        firstElement = parent.getFirstChild();\n        lastElement = parent.getLastChild();\n      }\n\n      this.options.getMatchOptions().setResultIsContextMatch(true);\n      CollectingMatchResultSink sink = new CollectingMatchResultSink();\n\n      matcher.testFindMatches(sink,this.options.getMatchOptions());\n\n      final List<ReplacementInfo> resultPtrList = new LinkedList<ReplacementInfo>();\n\n      for (final MatchResult result : sink.getMatches()) {\n        resultPtrList.add(buildReplacement(result));\n      }\n\n      sink.getMatches().clear();\n\n      int startOffset = firstElement.getTextRange().getStartOffset();\n      int endOffset = filePattern ?0: parent.getTextLength() - (lastElement.getTextRange().getEndOffset());\n\n      // get nodes from text may contain\n      PsiElement prevSibling = firstElement.getPrevSibling();\n      if (prevSibling instanceof PsiWhiteSpace) {\n        startOffset -= prevSibling.getTextLength() - 1;\n      }\n\n      PsiElement nextSibling = lastElement.getNextSibling();\n      if (nextSibling instanceof PsiWhiteSpace) {\n        endOffset -= nextSibling.getTextLength() - 1;\n      }\n\n      replaceAll(resultPtrList);\n\n      String result = parent.getText();\n      result = result.substring(startOffset);\n      result = result.substring(0,result.length() - endOffset);\n\n      return result;\n    } catch(Exception ex) {\n      ex.printStackTrace( );\n      return \"\";\n    } finally {\n      options.getMatchOptions().setScope(null);\n    }\n  }","commit_id":"cee14d1ee30ec5edb469ea9b55dec83084f01779","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Start the gateway. This will also start the Consumer and all the Connectors\n   *\n   * @throws ServerException If there is no Consumer, or whatever Exception a\n   *                         connector throws during start().\n   */\n  public void start(String[] args, CConfiguration conf) throws\n    ServerException {\n\n    // Start gateway v2\n    gatewayV2.startAndWait();\n\n    // Configure ourselves first\n    configure(conf);\n\n    // Check we are in the correct state\n    if (this.consumer == null) {\n      ServerException es =\n        new ServerException(\"Cannot start Gateway without a Consumer.\");\n      LOG.error(es.getMessage());\n      throw es;\n\n    }\n    if (this.executor == null) {\n      ServerException es =\n        new ServerException(\n          \"Cannot start Gateway without an Operation Executor.\");\n      LOG.error(es.getMessage());\n      throw es;\n    }\n\n    LOG.info(\"Gateway Starting up.\");\n\n    // Start our event consumer\n    this.consumer.startConsumer();\n\n    // Now start all our Connectors\n    for (Connector connector : this.connectorList) {\n\n      // First, perform connector-type specific initialization\n      // For a collector, set the Consumer for its events\n      // For an accessor, set the operations executor for access to data fabric\n      // TODO: This should probably be done in the addConnector method?\n      if (connector instanceof Collector) {\n        ((Collector) connector).setConsumer(this.consumer);\n      }\n      if (connector instanceof MetaDataServiceAware) {\n        connector.setMetadataService(this.mds);\n      }\n      if (connector instanceof MetaDataStoreAware) {\n        ((MetaDataStoreAware) connector).setMetadataStore(this.metaDataStore);\n      }\n      // for many unit-tests it is null. We will figure out better strategy around injection for unit-tests and fix it\n      if (store != null && connector instanceof StoreAware) {\n        ((StoreAware) connector).setStore(this.store);\n      }\n      if (connector instanceof DataAccessor) {\n        DataAccessor dataAccessor = (DataAccessor) connector;\n        dataAccessor.setExecutor(this.executor);\n        dataAccessor.setLocationFactory(this.locationFactory);\n        dataAccessor.setDataSetAccessor(this.dataSetAccessor);\n        dataAccessor.setTxSystemClient(this.txSystemClient);\n      }\n      if (connector instanceof LogReaderAware) {\n        ((LogReaderAware) connector).setLogReader(logReader);\n      }\n      // all connectors get the meta data service\n      connector.setMetadataService(this.mds);\n\n      connector.setGatewayMetrics(this.gatewayMetrics);\n\n      try {\n        connector.start();\n      } catch (Exception e) {\n        throw new ServerException(e.getMessage());\n      }\n\n      LOG.info(\" Started \" + connector.getName() + \" connector\");\n    }\n  }","id":88886,"modified_method":"/**\n   * Start the gateway. This will also start the Consumer and all the Connectors\n   *\n   * @throws ServerException If there is no Consumer, or whatever Exception a\n   *                         connector throws during start().\n   */\n  public void start(String[] args, CConfiguration conf) throws\n    ServerException {\n\n    // Start gateway v2\n    if (gatewayV2 != null) {\n      gatewayV2.startAndWait();\n    } else {\n      LOG.warn(\"Gateway v2 is null, not starting it.\");\n    }\n\n    // Configure ourselves first\n    configure(conf);\n\n    // Check we are in the correct state\n    if (this.consumer == null) {\n      ServerException es =\n        new ServerException(\"Cannot start Gateway without a Consumer.\");\n      LOG.error(es.getMessage());\n      throw es;\n\n    }\n    if (this.executor == null) {\n      ServerException es =\n        new ServerException(\n          \"Cannot start Gateway without an Operation Executor.\");\n      LOG.error(es.getMessage());\n      throw es;\n    }\n\n    LOG.info(\"Gateway Starting up.\");\n\n    // Start our event consumer\n    this.consumer.startConsumer();\n\n    // Now start all our Connectors\n    for (Connector connector : this.connectorList) {\n\n      // First, perform connector-type specific initialization\n      // For a collector, set the Consumer for its events\n      // For an accessor, set the operations executor for access to data fabric\n      // TODO: This should probably be done in the addConnector method?\n      if (connector instanceof Collector) {\n        ((Collector) connector).setConsumer(this.consumer);\n      }\n      if (connector instanceof MetaDataServiceAware) {\n        connector.setMetadataService(this.mds);\n      }\n      if (connector instanceof MetaDataStoreAware) {\n        ((MetaDataStoreAware) connector).setMetadataStore(this.metaDataStore);\n      }\n      // for many unit-tests it is null. We will figure out better strategy around injection for unit-tests and fix it\n      if (store != null && connector instanceof StoreAware) {\n        ((StoreAware) connector).setStore(this.store);\n      }\n      if (connector instanceof DataAccessor) {\n        DataAccessor dataAccessor = (DataAccessor) connector;\n        dataAccessor.setExecutor(this.executor);\n        dataAccessor.setLocationFactory(this.locationFactory);\n        dataAccessor.setDataSetAccessor(this.dataSetAccessor);\n        dataAccessor.setTxSystemClient(this.txSystemClient);\n      }\n      if (connector instanceof LogReaderAware) {\n        ((LogReaderAware) connector).setLogReader(logReader);\n      }\n      // all connectors get the meta data service\n      connector.setMetadataService(this.mds);\n\n      connector.setGatewayMetrics(this.gatewayMetrics);\n\n      try {\n        connector.start();\n      } catch (Exception e) {\n        throw new ServerException(e.getMessage());\n      }\n\n      LOG.info(\" Started \" + connector.getName() + \" connector\");\n    }\n  }","commit_id":"db8f771a50f3dc0d1a9f27853adc5f2193066d87","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Stop the gateway. This will first stop all our Connectors, and then stop\n   * the Consumer.\n   */\n  public void stop(boolean now) throws ServerException {\n\n    LOG.info(\"Gateway Shutting down\");\n\n    gatewayV2.stopAndWait();\n\n    // Stop all our connectors\n    for (Connector connector : this.connectorList) {\n      try {\n        connector.stop();\n      } catch (Exception e) {\n        throw new ServerException(e.getMessage());\n      }\n      LOG.info(\" \" + connector.getName() + \" stopped\");\n    }\n\n    // Stop the consumer\n    this.consumer.stopConsumer();\n    LOG.info(\" Consumer stopped\");\n\n    LOG.info(\"Gateway successfully shut down\");\n\n  }","id":88887,"modified_method":"/**\n   * Stop the gateway. This will first stop all our Connectors, and then stop\n   * the Consumer.\n   */\n  public void stop(boolean now) throws ServerException {\n\n    LOG.info(\"Gateway Shutting down\");\n\n    if (gatewayV2 != null) {\n      gatewayV2.stopAndWait();\n    }\n\n    // Stop all our connectors\n    for (Connector connector : this.connectorList) {\n      try {\n        connector.stop();\n      } catch (Exception e) {\n        throw new ServerException(e.getMessage());\n      }\n      LOG.info(\" \" + connector.getName() + \" stopped\");\n    }\n\n    // Stop the consumer\n    this.consumer.stopConsumer();\n    LOG.info(\" Consumer stopped\");\n\n    LOG.info(\"Gateway successfully shut down\");\n\n  }","commit_id":"db8f771a50f3dc0d1a9f27853adc5f2193066d87","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Our main method.\n   *\n   * @param args Our command line options\n   */\n  public static void main(String[] args) {\n\n    // Set up our Guice injections\n    Injector injector = Guice.createInjector(\n      new GatewayModules().getNoopModules(),\n      new DataFabricModules().getNoopModules());\n\n    // Get our fully wired Gateway\n    Gateway theGateway = injector.getInstance(Gateway.class);\n\n    // Now, initialize the Gateway\n    try {\n\n      // Load our configuration from our resource files\n      CConfiguration configuration = CConfiguration.create();\n\n      // Start the gateway!\n      theGateway.start(null, configuration);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    try {\n      Thread.sleep(1000000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","id":88888,"modified_method":"/**\n   * Our main method.\n   *\n   * @param args Our command line options\n   */\n  public static void main(String[] args) {\n\n    // Load our configuration from our resource files\n    CConfiguration configuration = CConfiguration.create();\n\n    // Set up our Guice injections\n    Injector injector = Guice.createInjector(\n      new GatewayModules(configuration).getNoopModules(),\n      new DataFabricModules().getNoopModules());\n\n    // Get our fully wired Gateway\n    Gateway theGateway = injector.getInstance(Gateway.class);\n\n    // Now, initialize the Gateway\n    try {\n\n      // Start the gateway!\n      theGateway.start(null, configuration);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    try {\n      Thread.sleep(1000000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"db8f771a50f3dc0d1a9f27853adc5f2193066d87","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Our main method.\n   *\n   * @param args Our command line options\n   */\n  public static void main(String[] args) {\n\n    // Set up our Guice injections\n    Injector injector = Guice.createInjector(\n      new GatewayModules().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules());\n\n    // Get our fully wired Gateway\n    Gateway theGateway = injector.getInstance(Gateway.class);\n\n    // Now, initialize the Gateway\n    try {\n\n      // Load our configuration from our resource files\n      CConfiguration configuration = CConfiguration.create();\n\n      // Start the gateway!\n      theGateway.start(null, configuration);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    try {\n      Thread.sleep(1000000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","id":88889,"modified_method":"/**\n   * Our main method.\n   *\n   * @param args Our command line options\n   */\n  public static void main(String[] args) {\n\n    // Load our configuration from our resource files\n    CConfiguration configuration = CConfiguration.create();\n\n    // Set up our Guice injections\n    Injector injector = Guice.createInjector(\n      new GatewayModules(configuration).getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules());\n\n    // Get our fully wired Gateway\n    Gateway theGateway = injector.getInstance(Gateway.class);\n\n    // Now, initialize the Gateway\n    try {\n\n      // Start the gateway!\n      theGateway.start(null, configuration);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    try {\n      Thread.sleep(1000000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"db8f771a50f3dc0d1a9f27853adc5f2193066d87","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Start the service.\n   */\n  protected void startUp(String[] args) throws Exception {\n    logAppenderInitializer.initialize();\n\n    File zkDir = new File(configuration.get(Constants.CFG_LOCAL_DATA_DIR) + \"/zookeeper\");\n    //noinspection ResultOfMethodCallIgnored\n    zkDir.mkdir();\n    zookeeper = InMemoryZKServer.builder().setDataDir(zkDir).build();\n    zookeeper.startAndWait();\n\n    configuration.set(Constants.Zookeeper.QUORUM, zookeeper.getConnectionStr());\n\n    // Start all the services.\n    txService.startAndWait();\n    metricsCollectionService.startAndWait();\n    datasetService.startAndWait();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric.\");\n    }\n\n    gatewayV2.startAndWait();\n    metricsQueryService.startAndWait();\n    router.startAndWait();\n    flumeCollector.startAndWait();\n    webCloudAppService.startAndWait();\n    streamHttpService.startAndWait();\n\n    // it is important to respect that order: metastore, then HiveServer\n    hiveMetastore.startAndWait();\n    hiveServer.startAndWait();\n\n    if (externalAuthenticationServer != null) {\n      externalAuthenticationServer.startAndWait();\n    }\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    System.out.println(\"Continuuity Reactor started successfully\");\n    System.out.println(\"Connect to dashboard at http://\" + hostname + \":9999\");\n  }","id":88890,"modified_method":"/**\n   * Start the service.\n   */\n  protected void startUp(String[] args) throws Exception {\n    logAppenderInitializer.initialize();\n\n    File zkDir = new File(configuration.get(Constants.CFG_LOCAL_DATA_DIR) + \"/zookeeper\");\n    //noinspection ResultOfMethodCallIgnored\n    zkDir.mkdir();\n    zookeeper = InMemoryZKServer.builder().setDataDir(zkDir).build();\n    zookeeper.startAndWait();\n\n    configuration.set(Constants.Zookeeper.QUORUM, zookeeper.getConnectionStr());\n\n    // Start all the services.\n    txService.startAndWait();\n    metricsCollectionService.startAndWait();\n    datasetService.startAndWait();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric.\");\n    }\n\n    gatewayV2.startAndWait();\n    metricsQueryService.startAndWait();\n    router.startAndWait();\n    flumeCollector.startAndWait();\n    webCloudAppService.startAndWait();\n    streamHttpService.startAndWait();\n\n    if (hiveMetastore != null && hiveServer != null) {\n      // it is important to respect that order: metastore, then HiveServer\n      hiveMetastore.startAndWait();\n      hiveServer.startAndWait();\n    }\n\n    if (externalAuthenticationServer != null) {\n      externalAuthenticationServer.startAndWait();\n    }\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    System.out.println(\"Continuuity Reactor started successfully\");\n    System.out.println(\"Connect to dashboard at http://\" + hostname + \":9999\");\n  }","commit_id":"d91d81118fc3fcac9a15af0f882000d3b6e9f456","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Shutdown the service.\n   */\n  public void shutDown() {\n    LOG.info(\"Shutting down reactor...\");\n\n    streamHttpService.stopAndWait();\n    webCloudAppService.stopAndWait();\n    flumeCollector.stopAndWait();\n    router.stopAndWait();\n    gatewayV2.stopAndWait();\n    metricsQueryService.stopAndWait();\n    appFabricServer.stopAndWait();\n    txService.stopAndWait();\n    datasetService.stopAndWait();\n    if (externalAuthenticationServer != null) {\n      externalAuthenticationServer.stopAndWait();\n    }\n    zookeeper.stopAndWait();\n    logAppenderInitializer.close();\n    hiveServer.stopAndWait();\n    hiveMetastore.stopAndWait();\n  }","id":88891,"modified_method":"/**\n   * Shutdown the service.\n   */\n  public void shutDown() {\n    LOG.info(\"Shutting down reactor...\");\n\n    streamHttpService.stopAndWait();\n    webCloudAppService.stopAndWait();\n    flumeCollector.stopAndWait();\n    router.stopAndWait();\n    gatewayV2.stopAndWait();\n    metricsQueryService.stopAndWait();\n    appFabricServer.stopAndWait();\n    txService.stopAndWait();\n    datasetService.stopAndWait();\n    if (externalAuthenticationServer != null) {\n      externalAuthenticationServer.stopAndWait();\n    }\n    zookeeper.stopAndWait();\n    logAppenderInitializer.close();\n    if (hiveMetastore != null && hiveServer != null) {\n      hiveServer.stopAndWait();\n      hiveMetastore.stopAndWait();\n    }\n  }","commit_id":"d91d81118fc3fcac9a15af0f882000d3b6e9f456","url":"https://github.com/caskdata/cdap"},{"original_method":"public SingleNodeMain(List<Module> modules, CConfiguration configuration, String webAppPath) {\n    this.configuration = configuration;\n    this.webCloudAppService = new WebCloudAppService(webAppPath);\n\n    Injector injector = Guice.createInjector(modules);\n    txService = injector.getInstance(InMemoryTransactionService.class);\n    router = injector.getInstance(NettyRouter.class);\n    gatewayV2 = injector.getInstance(Gateway.class);\n    metricsQueryService = injector.getInstance(MetricsQueryService.class);\n    flumeCollector = injector.getInstance(NettyFlumeCollector.class);\n    appFabricServer = injector.getInstance(AppFabricServer.class);\n    logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n    datasetService = injector.getInstance(DatasetService.class);\n\n    streamHttpService = injector.getInstance(StreamHttpService.class);\n\n    hiveMetastore = injector.getInstance(InMemoryHiveMetastore.class);\n    hiveServer = injector.getInstance(HiveServer.class);\n\n    boolean securityEnabled = configuration.getBoolean(Constants.Security.CFG_SECURITY_ENABLED);\n    if (securityEnabled) {\n      externalAuthenticationServer = injector.getInstance(ExternalAuthenticationServer.class);\n    }\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        try {\n          shutDown();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to shutdown\", e);\n          // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n          System.err.println(\"Failed to shutdown: \" + e.getMessage());\n          e.printStackTrace(System.err);\n        }\n      }\n    });\n  }","id":88892,"modified_method":"public SingleNodeMain(List<Module> modules, CConfiguration configuration, String webAppPath) {\n    this.configuration = configuration;\n    this.webCloudAppService = new WebCloudAppService(webAppPath);\n\n    Injector injector = Guice.createInjector(modules);\n    txService = injector.getInstance(InMemoryTransactionService.class);\n    router = injector.getInstance(NettyRouter.class);\n    gatewayV2 = injector.getInstance(Gateway.class);\n    metricsQueryService = injector.getInstance(MetricsQueryService.class);\n    flumeCollector = injector.getInstance(NettyFlumeCollector.class);\n    appFabricServer = injector.getInstance(AppFabricServer.class);\n    logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n    datasetService = injector.getInstance(DatasetService.class);\n\n    streamHttpService = injector.getInstance(StreamHttpService.class);\n\n    boolean exploreEnabled = configuration.getBoolean(Constants.Hive.EXPLORE_ENABLED,\n                                                      Constants.Hive.DEFAULT_EXPLORE_ENABLED);\n    if (exploreEnabled) {\n      hiveMetastore = injector.getInstance(InMemoryHiveMetastore.class);\n      hiveServer = injector.getInstance(HiveServer.class);\n    }\n\n    boolean securityEnabled = configuration.getBoolean(Constants.Security.CFG_SECURITY_ENABLED);\n    if (securityEnabled) {\n      externalAuthenticationServer = injector.getInstance(ExternalAuthenticationServer.class);\n    }\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        try {\n          shutDown();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to shutdown\", e);\n          // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n          System.err.println(\"Failed to shutdown: \" + e.getMessage());\n          e.printStackTrace(System.err);\n        }\n      }\n    });\n  }","commit_id":"d91d81118fc3fcac9a15af0f882000d3b6e9f456","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Lists all datasets.\n   *\n   * @return list of {@link DatasetMeta}s.\n   * @throws IOException if a network error occurred\n   */\n  public List<DatasetSpecification> list() throws IOException {\n    URL url = config.resolveURL(\"data/datasets\");\n    HttpResponse response = restClient.execute(HttpMethod.GET, url);\n    return ObjectResponse.fromJsonBody(response, new TypeToken<List<DatasetSpecification>>() { }).getResponseObject();\n  }","id":88893,"modified_method":"/**\n   * Lists all datasets.\n   *\n   * @return list of {@link DatasetSpecification}.\n   * @throws IOException if a network error occurred\n   */\n  public List<DatasetSpecification> list() throws IOException {\n    URL url = config.resolveURL(\"data/datasets\");\n    HttpResponse response = restClient.execute(HttpMethod.GET, url);\n    return ObjectResponse.fromJsonBody(response, new TypeToken<List<DatasetSpecification>>() { }).getResponseObject();\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testAll() throws Exception {\n    int numBaseModules = moduleClient.list().size();\n    int numBaseTypes = typeClient.list().size();\n    Assert.assertEquals(0, datasetClient.list().size());\n\n    LOG.info(\"Adding Dataset module\");\n    File moduleJarFile = createAppJarFile(FakeDatasetModule.class);\n    moduleClient.add(FakeDatasetModule.NAME, FakeDatasetModule.class.getName(), moduleJarFile);\n    Assert.assertEquals(numBaseModules + 1, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes + 2, typeClient.list().size());\n\n    LOG.info(\"Checking that the new Dataset module exists\");\n    DatasetModuleMeta datasetModuleMeta = moduleClient.get(FakeDatasetModule.NAME);\n    Assert.assertNotNull(datasetModuleMeta);\n    Assert.assertEquals(FakeDatasetModule.NAME, datasetModuleMeta.getName());\n\n    LOG.info(\"Checking that the new Dataset type exists\");\n    DatasetTypeMeta datasetTypeMeta = typeClient.get(FakeDataset.TYPE_NAME);\n    Assert.assertNotNull(datasetTypeMeta);\n    Assert.assertEquals(FakeDataset.TYPE_NAME, datasetTypeMeta.getName());\n\n    datasetTypeMeta = typeClient.get(FakeDataset.class.getName());\n    Assert.assertNotNull(datasetTypeMeta);\n    Assert.assertEquals(FakeDataset.class.getName(), datasetTypeMeta.getName());\n\n    LOG.info(\"Creating, truncating, and deleting dataset of new Dataset type\");\n    Assert.assertEquals(0, datasetClient.list().size());\n    datasetClient.create(\"testDataset\", FakeDataset.TYPE_NAME);\n    Assert.assertEquals(1, datasetClient.list().size());\n    datasetClient.truncate(\"testDataset\");\n    datasetClient.delete(\"testDataset\");\n    Assert.assertEquals(0, datasetClient.list().size());\n\n    LOG.info(\"Creating and deleting multiple Datasets\");\n    datasetClient.create(\"testDataset1\", FakeDataset.TYPE_NAME);\n    datasetClient.create(\"testDataset2\", FakeDataset.TYPE_NAME);\n    datasetClient.create(\"testDataset3\", FakeDataset.TYPE_NAME);\n    Assert.assertEquals(3, datasetClient.list().size());\n    datasetClient.deleteAll();\n    Assert.assertEquals(0, datasetClient.list().size());\n\n    LOG.info(\"Deleting Dataset module\");\n    moduleClient.delete(FakeDatasetModule.NAME);\n    Assert.assertEquals(numBaseModules, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes, typeClient.list().size());\n\n    LOG.info(\"Adding Dataset module and then deleting all Dataset modules\");\n    moduleClient.add(\"testModule1\", FakeDatasetModule.class.getName(), moduleJarFile);\n    Assert.assertEquals(numBaseModules + 1, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes + 2, typeClient.list().size());\n    moduleClient.deleteAll();\n    Assert.assertEquals(numBaseModules, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes, typeClient.list().size());\n  }","id":88894,"modified_method":"@Test\n  public void testAll() throws Exception {\n    int numBaseModules = moduleClient.list().size();\n    int numBaseTypes = typeClient.list().size();\n\n    LOG.info(\"Adding Dataset module\");\n    File moduleJarFile = createAppJarFile(FakeDatasetModule.class);\n    moduleClient.add(FakeDatasetModule.NAME, FakeDatasetModule.class.getName(), moduleJarFile);\n    Assert.assertEquals(numBaseModules + 1, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes + 2, typeClient.list().size());\n\n    LOG.info(\"Checking that the new Dataset module exists\");\n    DatasetModuleMeta datasetModuleMeta = moduleClient.get(FakeDatasetModule.NAME);\n    Assert.assertNotNull(datasetModuleMeta);\n    Assert.assertEquals(FakeDatasetModule.NAME, datasetModuleMeta.getName());\n\n    LOG.info(\"Checking that the new Dataset type exists\");\n    DatasetTypeMeta datasetTypeMeta = typeClient.get(FakeDataset.TYPE_NAME);\n    Assert.assertNotNull(datasetTypeMeta);\n    Assert.assertEquals(FakeDataset.TYPE_NAME, datasetTypeMeta.getName());\n\n    datasetTypeMeta = typeClient.get(FakeDataset.class.getName());\n    Assert.assertNotNull(datasetTypeMeta);\n    Assert.assertEquals(FakeDataset.class.getName(), datasetTypeMeta.getName());\n\n    LOG.info(\"Creating, truncating, and deleting dataset of new Dataset type\");\n    // Before creating dataset, there are some system datasets already exist\n    int numBaseDataset = datasetClient.list().size();\n\n    datasetClient.create(\"testDataset\", FakeDataset.TYPE_NAME);\n    Assert.assertEquals(numBaseDataset + 1, datasetClient.list().size());\n    datasetClient.truncate(\"testDataset\");\n    datasetClient.delete(\"testDataset\");\n    Assert.assertEquals(numBaseDataset, datasetClient.list().size());\n\n    LOG.info(\"Creating and deleting multiple Datasets\");\n    for (int i = 1; i <= 3; i++) {\n      datasetClient.create(\"testDataset\" + i, FakeDataset.TYPE_NAME);\n    }\n    Assert.assertEquals(numBaseDataset + 3, datasetClient.list().size());\n    for (int i = 1; i <= 3; i++) {\n      datasetClient.delete(\"testDataset\" + i);\n    }\n    Assert.assertEquals(numBaseDataset, datasetClient.list().size());\n\n    LOG.info(\"Deleting Dataset module\");\n    moduleClient.delete(FakeDatasetModule.NAME);\n    Assert.assertEquals(numBaseModules, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes, typeClient.list().size());\n\n    LOG.info(\"Adding Dataset module and then deleting all Dataset modules\");\n    moduleClient.add(\"testModule1\", FakeDatasetModule.class.getName(), moduleJarFile);\n    Assert.assertEquals(numBaseModules + 1, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes + 2, typeClient.list().size());\n    moduleClient.deleteAll();\n    Assert.assertEquals(numBaseModules, moduleClient.list().size());\n    Assert.assertEquals(numBaseTypes, typeClient.list().size());\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"public FakeDataset(String instanceName, KeyValueTable table) {\n    super(instanceName, table);\n  }","id":88895,"modified_method":"public FakeDataset(String instanceName, KeyValueTable table) {\n    super(instanceName, table);\n    this.table = table;\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Gets the status of a system service.\n   *\n   * @param serviceName Name of the system service\n   * @return status of the system service\n   * @throws IOException if a network error occurred\n   * @throws NotFoundException if the system service with the specified name could not be found\n   * @throws BadRequestException if the operation was not valid for the system service\n   */\n  public String getSystemServiceStatus(String serviceName) throws IOException, NotFoundException, BadRequestException {\n    URL url = config.resolveURL(String.format(\"system/services/%s/status\", serviceName));\n    HttpResponse response = restClient.execute(HttpMethod.GET, url, HttpURLConnection.HTTP_NOT_FOUND,\n                                               HttpURLConnection.HTTP_BAD_REQUEST);\n    String responseBody = new String(response.getResponseBody());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotFoundException(\"system service\", serviceName);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST) {\n      throw new BadRequestException(responseBody);\n    }\n    return responseBody;\n  }","id":88896,"modified_method":"/**\n   * Gets the status of a system service.\n   *\n   * @param serviceName Name of the system service\n   * @return status of the system service\n   * @throws IOException if a network error occurred\n   * @throws NotFoundException if the system service with the specified name could not be found\n   * @throws BadRequestException if the operation was not valid for the system service\n   */\n  public String getSystemServiceStatus(String serviceName) throws IOException, NotFoundException, BadRequestException {\n    URL url = config.resolveURL(String.format(\"system/services/%s/status\", serviceName));\n    HttpResponse response = restClient.execute(HttpMethod.GET, url, HttpURLConnection.HTTP_NOT_FOUND,\n                                               HttpURLConnection.HTTP_BAD_REQUEST);\n    String responseBody = new String(response.getResponseBody());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotFoundException(\"system service\", serviceName);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST) {\n      throw new BadRequestException(responseBody);\n    }\n    Map<String, String> status = GSON.fromJson(responseBody, new TypeToken<Map<String, String>>() { }.getType());\n    return status.get(\"status\");\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Start the service.\n   */\n  public void startUp() throws Exception {\n    // todo: REACTOR-682\n//    logAppenderInitializer.initialize();\n\n    // Start all the services.\n    txService.startAndWait();\n    metricsCollectionService.startAndWait();\n    datasetService.startAndWait();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric\");\n    }\n\n    gatewayV2.startAndWait();\n    metricsQueryService.startAndWait();\n    router.startAndWait();\n    flumeCollector.startAndWait();\n    webCloudAppService.startAndWait();\n    streamHttpService.startAndWait();\n\n    if (externalAuthenticationServer != null) {\n      externalAuthenticationServer.startAndWait();\n    }\n\n    if (exploreExecutorService != null) {\n      exploreExecutorService.startAndWait();\n    }\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    System.out.println(\"Application Server started successfully\");\n    System.out.println(\"Connect to dashboard at http://\" + hostname + \":9999\");\n  }","id":88897,"modified_method":"/**\n   * Start the service.\n   */\n  public void startUp() throws Exception {\n    // todo: REACTOR-682\n//    logAppenderInitializer.initialize();\n\n    // Start all the services.\n    txService.startAndWait();\n    metricsCollectionService.startAndWait();\n    datasetService.startAndWait();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric\");\n    }\n\n    gatewayV2.startAndWait();\n    metricsQueryService.startAndWait();\n    router.startAndWait();\n    flumeCollector.startAndWait();\n    if (webCloudAppService != null) {\n      webCloudAppService.startAndWait();\n    }\n    streamHttpService.startAndWait();\n\n    if (externalAuthenticationServer != null) {\n      externalAuthenticationServer.startAndWait();\n    }\n\n    if (exploreExecutorService != null) {\n      exploreExecutorService.startAndWait();\n    }\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    System.out.println(\"Application Server started successfully\");\n    System.out.println(\"Connect to dashboard at http://\" + hostname + \":9999\");\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * The root of all goodness!\n   *\n   * @param inMemory\n   * @param webAppPath\n   */\n  public static SingleNodeMain createSingleNodeMain(boolean inMemory, String webAppPath) {\n    CConfiguration cConf = CConfiguration.create();\n\n    // This is needed to use LocalJobRunner with fixes (we have it in app-fabric).\n    // For the modified local job runner\n    Configuration hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n    // Due to incredibly stupid design of Limits class, once it is initialized, it keeps its settings. We\n    // want to make sure it uses our settings in this hConf, so we have to force it initialize here before\n    // someone else initializes it.\n    Limits.init(hConf);\n\n    File localDataDir = new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR));\n    hConf.set(Constants.CFG_LOCAL_DATA_DIR, localDataDir.getAbsolutePath());\n    hConf.set(Constants.AppFabric.OUTPUT_DIR, cConf.get(Constants.AppFabric.OUTPUT_DIR));\n    hConf.set(\"hadoop.tmp.dir\", new File(localDataDir, cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsolutePath());\n\n    // Windows specific requirements\n    if (OSDetector.isWindows()) {\n      String userDir = System.getProperty(\"user.dir\");\n      System.load(userDir + \"/lib/native/hadoop.dll\");\n    }\n\n    //Run gateway on random port and forward using router.\n    cConf.setInt(Constants.Gateway.PORT, 0);\n\n    //Run dataset service on random port\n    List<Module> modules = inMemory ? createInMemoryModules(cConf, hConf)\n      : createPersistentModules(cConf, hConf);\n\n    return new SingleNodeMain(modules, cConf, webAppPath);\n  }","id":88898,"modified_method":"/**\n   * The root of all goodness!\n   *\n   * @param inMemory\n   * @param webAppPath\n   */\n  public static SingleNodeMain createSingleNodeMain(boolean inMemory, String webAppPath) {\n    return createSingleNodeMain(inMemory, webAppPath, CConfiguration.create(), new Configuration());\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"public SingleNodeMain(List<Module> modules, CConfiguration configuration, String webAppPath) {\n    this.webCloudAppService = new WebCloudAppService(webAppPath);\n\n    Injector injector = Guice.createInjector(modules);\n    txService = injector.getInstance(InMemoryTransactionService.class);\n    router = injector.getInstance(NettyRouter.class);\n    gatewayV2 = injector.getInstance(Gateway.class);\n    metricsQueryService = injector.getInstance(MetricsQueryService.class);\n    flumeCollector = injector.getInstance(NettyFlumeCollector.class);\n    appFabricServer = injector.getInstance(AppFabricServer.class);\n    logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n    datasetService = injector.getInstance(DatasetService.class);\n\n    streamHttpService = injector.getInstance(StreamHttpService.class);\n\n    boolean securityEnabled = configuration.getBoolean(Constants.Security.CFG_SECURITY_ENABLED);\n    if (securityEnabled) {\n      externalAuthenticationServer = injector.getInstance(ExternalAuthenticationServer.class);\n    }\n\n    boolean exploreEnabled = configuration.getBoolean(Constants.Explore.EXPLORE_ENABLED);\n    if (exploreEnabled) {\n      ExploreServiceUtils.checkHiveSupportWithoutSecurity(this.getClass().getClassLoader());\n      exploreExecutorService = injector.getInstance(ExploreExecutorService.class);\n    }\n\n    exploreClient = injector.getInstance(ExploreClient.class);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        try {\n          shutDown();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to shutdown\", e);\n          // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n          System.err.println(\"Failed to shutdown: \" + e.getMessage());\n          e.printStackTrace(System.err);\n        }\n      }\n    });\n  }","id":88899,"modified_method":"private SingleNodeMain(List<Module> modules, CConfiguration configuration, String webAppPath) {\n    this.webCloudAppService = (webAppPath == null) ? null : new WebCloudAppService(webAppPath);\n\n    Injector injector = Guice.createInjector(modules);\n    txService = injector.getInstance(InMemoryTransactionService.class);\n    router = injector.getInstance(NettyRouter.class);\n    gatewayV2 = injector.getInstance(Gateway.class);\n    metricsQueryService = injector.getInstance(MetricsQueryService.class);\n    flumeCollector = injector.getInstance(NettyFlumeCollector.class);\n    appFabricServer = injector.getInstance(AppFabricServer.class);\n    logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n    datasetService = injector.getInstance(DatasetService.class);\n\n    streamHttpService = injector.getInstance(StreamHttpService.class);\n\n    boolean securityEnabled = configuration.getBoolean(Constants.Security.CFG_SECURITY_ENABLED);\n    if (securityEnabled) {\n      externalAuthenticationServer = injector.getInstance(ExternalAuthenticationServer.class);\n    }\n\n    boolean exploreEnabled = configuration.getBoolean(Constants.Explore.EXPLORE_ENABLED);\n    if (exploreEnabled) {\n      ExploreServiceUtils.checkHiveSupportWithoutSecurity(this.getClass().getClassLoader());\n      exploreExecutorService = injector.getInstance(ExploreExecutorService.class);\n    }\n\n    exploreClient = injector.getInstance(ExploreClient.class);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        try {\n          shutDown();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to shutdown\", e);\n          // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n          System.err.println(\"Failed to shutdown: \" + e.getMessage());\n          e.printStackTrace(System.err);\n        }\n      }\n    });\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Shutdown the service.\n   */\n  public void shutDown() {\n    LOG.info(\"Shutting down the Application Server\");\n\n    try {\n      // order matters: first shut down web app 'cause it will stop working after router is down\n      webCloudAppService.stopAndWait();\n      //  shut down router, gateway and flume, to stop all incoming traffic\n      router.stopAndWait();\n      gatewayV2.stopAndWait();\n      flumeCollector.stopAndWait();\n      // now the stream writer and the explore service (they need tx)\n      streamHttpService.stopAndWait();\n      if (exploreExecutorService != null) {\n        exploreExecutorService.stopAndWait();\n      }\n      exploreClient.close();\n      // app fabric will also stop all programs\n      appFabricServer.stopAndWait();\n      // all programs are stopped: dataset service, metrics, transactions can stop now\n      datasetService.stopAndWait();\n      metricsQueryService.stopAndWait();\n      txService.stopAndWait();\n      // auth service is on the side anyway\n      if (externalAuthenticationServer != null) {\n        externalAuthenticationServer.stopAndWait();\n      }\n      // todo: REACTOR-682\n//      logAppenderInitializer.close();\n\n    } catch (Throwable e) {\n      LOG.error(\"Exception during shutdown\", e);\n      // we can't do much but exit. Because there was an exception, some non-daemon threads may still be running.\n      // therefore System.exit() won't do it, we need to farce a halt.\n      Runtime.getRuntime().halt(1);\n    }\n  }","id":88900,"modified_method":"/**\n   * Shutdown the service.\n   */\n  public void shutDown() {\n    LOG.info(\"Shutting down the Application Server\");\n\n    try {\n      // order matters: first shut down web app 'cause it will stop working after router is down\n      if (webCloudAppService != null) {\n        webCloudAppService.stopAndWait();\n      }\n      //  shut down router, gateway and flume, to stop all incoming traffic\n      router.stopAndWait();\n      gatewayV2.stopAndWait();\n      flumeCollector.stopAndWait();\n      // now the stream writer and the explore service (they need tx)\n      streamHttpService.stopAndWait();\n      if (exploreExecutorService != null) {\n        exploreExecutorService.stopAndWait();\n      }\n      exploreClient.close();\n      // app fabric will also stop all programs\n      appFabricServer.stopAndWait();\n      // all programs are stopped: dataset service, metrics, transactions can stop now\n      datasetService.stopAndWait();\n      metricsQueryService.stopAndWait();\n      txService.stopAndWait();\n      // auth service is on the side anyway\n      if (externalAuthenticationServer != null) {\n        externalAuthenticationServer.stopAndWait();\n      }\n      // todo: REACTOR-682\n//      logAppenderInitializer.close();\n\n    } catch (Throwable e) {\n      LOG.error(\"Exception during shutdown\", e);\n      // we can't do much but exit. Because there was an exception, some non-daemon threads may still be running.\n      // therefore System.exit() won't do it, we need to farce a halt.\n      Runtime.getRuntime().halt(1);\n    }\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void setUp() throws Throwable {\n    try {\n      singleNodeMain = SingleNodeMain.createSingleNodeMain(true);\n      singleNodeMain.startUp();\n    } catch (Throwable e) {\n      System.err.println(\"Failed to start singlenode. \" + e.getMessage());\n      LOG.error(\"Failed to start singlenode\", e);\n      if (singleNodeMain != null) {\n        singleNodeMain.shutDown();\n      }\n      throw e;\n    }\n  }","id":88901,"modified_method":"@Before\n  public void setUp() throws Throwable {\n    try {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.CFG_LOCAL_DATA_DIR, tmpFolder.newFolder().getAbsolutePath());\n\n      // Start singlenode without UI\n      singleNodeMain = SingleNodeMain.createSingleNodeMain(true, null, cConf, new Configuration());\n      singleNodeMain.startUp();\n    } catch (Throwable e) {\n      LOG.error(\"Failed to start singlenode\", e);\n      if (singleNodeMain != null) {\n        singleNodeMain.shutDown();\n      }\n      throw e;\n    }\n  }","commit_id":"47f10dbf193a6c7b9cb6314ea3d2503977e0330a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void createAndShowGUI(final String path, boolean skipSizeCheck)\n            throws IOException {\n\n        JTextArea log = new JTextArea(5, 20);\n        log.setMargin(new Insets(5, 5, 5, 5));\n        log.setLineWrap(true);\n        log.setEditable(false);\n\n        final NodeStoreTree treePanel = new NodeStoreTree(path, log, skipSizeCheck);\n\n        final JFrame frame = new JFrame(\"Explore \" + path + \" @head\");\n        frame.addWindowListener(new java.awt.event.WindowAdapter() {\n            @Override\n            public void windowClosing(java.awt.event.WindowEvent windowEvent) {\n                IOUtils.closeQuietly(treePanel);\n                System.exit(0);\n            }\n        });\n\n        JPanel content = new JPanel(new GridBagLayout());\n\n        GridBagConstraints c = new GridBagConstraints();\n        c.fill = GridBagConstraints.BOTH;\n        c.weightx = 1;\n        c.weighty = 1;\n\n        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n                new JScrollPane(treePanel), new JScrollPane(log));\n        splitPane.setDividerLocation(0.3);\n        content.add(new JScrollPane(splitPane), c);\n        frame.getContentPane().add(content);\n\n        JMenuBar menuBar = new JMenuBar();\n        menuBar.setMargin(new Insets(2, 2, 2, 2));\n\n        JMenuItem menuReopen = new JMenuItem(\"Reopen\");\n        menuReopen.setMnemonic(KeyEvent.VK_R);\n        menuReopen.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                try {\n                    treePanel.reopen();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n\n        JMenuItem menuCompaction = new JMenuItem(\"Time Machine\");\n        menuCompaction.setMnemonic(KeyEvent.VK_T);\n        menuCompaction.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                List<String> revs = new ArrayList<String>();\n\n                File journal = new File(path, \"journal.log\");\n                if (!journal.exists()) {\n                    return;\n                }\n\n                JournalReader journalReader = null;\n                try {\n                    journalReader = new JournalReader(journal);\n                    try {\n                        revs = Lists.newArrayList(journalReader.iterator());\n                    } finally {\n                        journalReader.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return;\n                } finally {\n                    try {\n                        if (journalReader != null) {\n                            journalReader.close();\n                        }\n                    } catch (IOException e) {\n                    }\n                }\n\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"Revert to a specified revision\", \"Time Machine\",\n                        JOptionPane.PLAIN_MESSAGE, null, revs.toArray(),\n                        revs.get(0));\n                if (s != null && treePanel.revert(s)) {\n                    frame.setTitle(\"Explore \" + path + \" @\" + s);\n                }\n            }\n        });\n\n        JMenuItem menuRefs = new JMenuItem(\"Tar File Info\");\n        menuRefs.setMnemonic(KeyEvent.VK_I);\n        menuRefs.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                List<String> tarFiles = new ArrayList<String>();\n                for (File f : new File(path).listFiles()) {\n                    if (f.getName().endsWith(\".tar\")) {\n                        tarFiles.add(f.getName());\n                    }\n                }\n\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"Choose a tar file\", \"Tar File Info\",\n                        JOptionPane.PLAIN_MESSAGE, null, tarFiles.toArray(),\n                        tarFiles.get(0));\n                if (s != null) {\n                    treePanel.printTarInfo(s);\n                    return;\n                }\n            }\n        });\n\n        JMenuItem menuSCR = new JMenuItem(\"Segment Content Refs\");\n        menuSCR.setMnemonic(KeyEvent.VK_R);\n        menuSCR.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"Segment Content Ref\\nUsage: <segmentId>\",\n                        \"Segment Content Ref\", JOptionPane.PLAIN_MESSAGE);\n                if (s != null) {\n                    treePanel.printDependenciesToSegment(s);\n                    return;\n                }\n            }\n        });\n\n        JMenuItem menuDiff = new JMenuItem(\"SegmentNodeState diff\");\n        menuDiff.setMnemonic(KeyEvent.VK_D);\n        menuDiff.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"SegmentNodeState diff\\nUsage: <recordId> <recordId> [<path>]\",\n                        \"SegmentNodeState diff\", JOptionPane.PLAIN_MESSAGE);\n                if (s != null) {\n                    treePanel.printDiff(s);\n                    return;\n                }\n            }\n        });\n\n        menuBar.add(menuReopen);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuCompaction);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuRefs);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuSCR);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuDiff);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n\n        frame.setJMenuBar(menuBar);\n        frame.pack();\n        frame.setSize(960, 720);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n\n    }","id":88902,"modified_method":"private void createAndShowGUI(final String path, boolean skipSizeCheck)\n            throws IOException {\n\n        JTextArea log = new JTextArea(5, 20);\n        log.setMargin(new Insets(5, 5, 5, 5));\n        log.setLineWrap(true);\n        log.setEditable(false);\n\n        final NodeStoreTree treePanel = new NodeStoreTree(path, log, skipSizeCheck);\n\n        final JFrame frame = new JFrame(\"Explore \" + path + \" @head\");\n        frame.addWindowListener(new java.awt.event.WindowAdapter() {\n            @Override\n            public void windowClosing(java.awt.event.WindowEvent windowEvent) {\n                IOUtils.closeQuietly(treePanel);\n                System.exit(0);\n            }\n        });\n\n        JPanel content = new JPanel(new GridBagLayout());\n\n        GridBagConstraints c = new GridBagConstraints();\n        c.fill = GridBagConstraints.BOTH;\n        c.weightx = 1;\n        c.weighty = 1;\n\n        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n                new JScrollPane(treePanel), new JScrollPane(log));\n        splitPane.setDividerLocation(0.3);\n        content.add(new JScrollPane(splitPane), c);\n        frame.getContentPane().add(content);\n\n        JMenuBar menuBar = new JMenuBar();\n        menuBar.setMargin(new Insets(2, 2, 2, 2));\n\n        JMenuItem menuReopen = new JMenuItem(\"Reopen\");\n        menuReopen.setMnemonic(KeyEvent.VK_R);\n        menuReopen.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                try {\n                    treePanel.reopen();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n\n        JMenuItem menuCompaction = new JMenuItem(\"Time Machine\");\n        menuCompaction.setMnemonic(KeyEvent.VK_T);\n        menuCompaction.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                List<String> revs = new ArrayList<String>();\n\n                File journal = new File(path, \"journal.log\");\n                if (!journal.exists()) {\n                    return;\n                }\n\n                JournalReader journalReader = null;\n                try {\n                    journalReader = new JournalReader(journal);\n                    try {\n                        revs = Lists.newArrayList(journalReader.iterator());\n                    } finally {\n                        journalReader.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return;\n                } finally {\n                    try {\n                        if (journalReader != null) {\n                            journalReader.close();\n                        }\n                    } catch (IOException e) {\n                    }\n                }\n\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"Revert to a specified revision\", \"Time Machine\",\n                        JOptionPane.PLAIN_MESSAGE, null, revs.toArray(),\n                        revs.get(0));\n                if (s != null && treePanel.revert(s)) {\n                    frame.setTitle(\"Explore \" + path + \" @\" + s);\n                }\n            }\n        });\n\n        JMenuItem menuRefs = new JMenuItem(\"Tar File Info\");\n        menuRefs.setMnemonic(KeyEvent.VK_I);\n        menuRefs.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                List<String> tarFiles = new ArrayList<String>();\n                for (File f : new File(path).listFiles()) {\n                    if (f.getName().endsWith(\".tar\")) {\n                        tarFiles.add(f.getName());\n                    }\n                }\n\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"Choose a tar file\", \"Tar File Info\",\n                        JOptionPane.PLAIN_MESSAGE, null, tarFiles.toArray(),\n                        tarFiles.get(0));\n                if (s != null) {\n                    treePanel.printTarInfo(s);\n                    return;\n                }\n            }\n        });\n\n        JMenuItem menuSCR = new JMenuItem(\"Segment Refs\");\n        menuSCR.setMnemonic(KeyEvent.VK_R);\n        menuSCR.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"Segment References\\nUsage: <segmentId>\",\n                        \"Segment References\", JOptionPane.PLAIN_MESSAGE);\n                if (s != null) {\n                    treePanel.printDependenciesToSegment(s);\n                    return;\n                }\n            }\n        });\n\n        JMenuItem menuDiff = new JMenuItem(\"SegmentNodeState diff\");\n        menuDiff.setMnemonic(KeyEvent.VK_D);\n        menuDiff.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent ev) {\n                String s = (String) JOptionPane.showInputDialog(frame,\n                        \"SegmentNodeState diff\\nUsage: <recordId> <recordId> [<path>]\",\n                        \"SegmentNodeState diff\", JOptionPane.PLAIN_MESSAGE);\n                if (s != null) {\n                    treePanel.printDiff(s);\n                    return;\n                }\n            }\n        });\n\n        menuBar.add(menuReopen);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuCompaction);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuRefs);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuSCR);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n        menuBar.add(menuDiff);\n        menuBar.add(new JSeparator(JSeparator.VERTICAL));\n\n        frame.setJMenuBar(menuBar);\n        frame.pack();\n        frame.setSize(960, 720);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeState getState() {\n            if (state != null) {\n                return state;\n            }\n            NodeState s = loadState();\n            if (cacheNodeState) {\n                state = s;\n            }\n            return s;\n        }","id":88903,"modified_method":"public NodeState getState() {\n            return loadState();\n        }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private String toString(PropertyState ps, int index, String tarFile) {\n        if (ps.getType().tag() == PropertyType.BINARY) {\n            Blob b = ps.getValue(Type.BINARY, index);\n            String info = \"<\";\n            info += b.getClass().getSimpleName() + \";\";\n            info += \"ref:\" + safeGetReference(b) + \";\";\n            info += \"id:\" + b.getContentIdentity() + \";\";\n            info += safeGetLength(b) + \">\";\n            for (SegmentId sid : SegmentBlob.getBulkSegmentIds(b)) {\n                info += newline + \"        Bulk Segment Id \" + sid;\n                String f = getFile(sid);\n                if (!f.equals(tarFile)) {\n                    info += \" in \" + f;\n                }\n            }\n\n            return info;\n        } else if (ps.getType().tag() == PropertyType.STRING) {\n            return displayString(ps.getValue(Type.STRING, index));\n        } else {\n            return ps.getValue(Type.STRING, index);\n        }\n    }","id":88904,"modified_method":"private String toString(PropertyState ps, int index, String tarFile) {\n        if (ps.getType().tag() == BINARY) {\n            Blob b = ps.getValue(Type.BINARY, index);\n            String info = \"<\";\n            info += b.getClass().getSimpleName() + \";\";\n            info += \"ref:\" + safeGetReference(b) + \";\";\n            info += \"id:\" + b.getContentIdentity() + \";\";\n            info += safeGetLength(b) + \">\";\n            for (SegmentId sid : SegmentBlob.getBulkSegmentIds(b)) {\n                info += newline + \"        Bulk Segment Id \" + sid;\n                String f = getFile(sid);\n                if (!f.equals(tarFile)) {\n                    info += \" in \" + f;\n                }\n            }\n\n            return info;\n        } else if (ps.getType().tag() == STRING) {\n            return displayString(ps.getValue(Type.STRING, index));\n        } else {\n            return ps.getValue(Type.STRING, index);\n        }\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void updateStats(DefaultMutableTreeNode parent) {\n        NamePathModel model = (NamePathModel) parent.getUserObject();\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(model.getPath());\n        sb.append(newline);\n\n        NodeState state = model.getState();\n        String tarFile = \"\";\n\n        if (state instanceof SegmentNodeState) {\n            SegmentNodeState s = (SegmentNodeState) state;\n            RecordId recordId = s.getRecordId();\n            sb.append(\"Record \" + recordId);\n            tarFile = getFile(recordId);\n            if (tarFile.length() > 0) {\n                sb.append(\" in \" + tarFile);\n            }\n            sb.append(newline);\n\n            RecordId templateId = SegmentNodeStateHelper.getTemplateId(s);\n            String f = getFile(templateId);\n            sb.append(\"TemplateId \");\n            sb.append(templateId);\n            if (!f.equals(tarFile)) {\n                sb.append(\" in \" + f);\n            }\n            sb.append(newline);\n        }\n\n        sb.append(\"Size: \");\n        sb.append(\"  direct: \");\n        sb.append(FileUtils.byteCountToDisplaySize(model.getSize()[0]));\n        sb.append(\";  linked: \");\n        sb.append(FileUtils.byteCountToDisplaySize(model.getSize()[1]));\n        sb.append(newline);\n\n        sb.append(\"Properties (count: \" + state.getPropertyCount() + \")\");\n        sb.append(newline);\n        Map<String, String> propLines = new TreeMap<String, String>();\n        for (PropertyState ps : state.getProperties()) {\n            StringBuilder l = new StringBuilder();\n            l.append(\"  - \" + ps.getName() + \" = {\" + ps.getType() + \"} \");\n            if (ps.getType().isArray()) {\n                int count = ps.count();\n                l.append(\"(count \" + count + \") [\");\n\n                String separator = \", \";\n                int max = 50;\n                if (ps.getType() == Type.BINARIES) {\n                    separator = newline + \"      \";\n                    max = Integer.MAX_VALUE;\n                    l.append(separator);\n                }\n                for (int i = 0; i < Math.min(count, max); i++) {\n                    if (i > 0) {\n                        l.append(separator);\n                    }\n                    l.append(toString(ps, i, tarFile));\n                }\n                if (count > max) {\n                    l.append(\", ... (\" + count + \" values)\");\n                }\n                if (ps.getType() == Type.BINARIES) {\n                    l.append(separator);\n                }\n                l.append(\"]\");\n\n            } else {\n                l.append(toString(ps, 0, tarFile));\n            }\n            if (ps instanceof SegmentPropertyState) {\n                RecordId rid = ((SegmentPropertyState) ps).getRecordId();\n                l.append(\" (\" + rid);\n                String f = getFile(rid);\n                if (!f.equals(tarFile)) {\n                    l.append(\" in \" + f);\n                }\n                l.append(\")\");\n            } else {\n                l.append(\" (\" + ps.getClass().getSimpleName() + \")\");\n            }\n            propLines.put(ps.getName(), l.toString());\n        }\n\n        for (String l : propLines.values()) {\n            sb.append(l);\n            sb.append(newline);\n        }\n\n        sb.append(\"Child nodes (count: \" + state.getChildNodeCount(Long.MAX_VALUE)\n                + \")\");\n        sb.append(newline);\n        Map<String, String> childLines = new TreeMap<String, String>();\n        for (ChildNodeEntry ce : state.getChildNodeEntries()) {\n            StringBuilder l = new StringBuilder();\n            l.append(\"  + \" + ce.getName());\n            NodeState c = ce.getNodeState();\n            if (c instanceof SegmentNodeState) {\n                RecordId rid = ((SegmentNodeState) c).getRecordId();\n                l.append(\" (\" + rid);\n                String f = getFile(rid);\n                if (!f.equals(tarFile)) {\n                    l.append(\" in \" + f);\n                }\n                l.append(\")\");\n            } else {\n                l.append(\" (\" + c.getClass().getSimpleName() + \")\");\n            }\n            childLines.put(ce.getName(), l.toString());\n        }\n        for (String l : childLines.values()) {\n            sb.append(l);\n            sb.append(newline);\n        }\n\n        if (\"/\".equals(model.getPath())) {\n            sb.append(\"File Reader Index\");\n            sb.append(newline);\n\n            List<String> files = newArrayList(store.getTarReaderIndex()\n                    .keySet());\n            Collections.sort(files);\n\n            for (String path : files) {\n                sb.append(path);\n                sb.append(newline);\n            }\n            sb.append(\"----------\");\n        }\n\n        setText(sb.toString());\n    }","id":88905,"modified_method":"private void updateStats(DefaultMutableTreeNode parent) {\n        NamePathModel model = (NamePathModel) parent.getUserObject();\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(model.getPath());\n        sb.append(newline);\n\n        NodeState state = model.getState();\n        String tarFile = \"\";\n\n        if (state instanceof SegmentNodeState) {\n            SegmentNodeState s = (SegmentNodeState) state;\n            RecordId recordId = s.getRecordId();\n            sb.append(\"Record \" + recordId);\n            tarFile = getFile(recordId);\n            if (tarFile.length() > 0) {\n                sb.append(\" in \" + tarFile);\n            }\n            sb.append(newline);\n\n            RecordId templateId = getTemplateId(s);\n            String f = getFile(templateId);\n            sb.append(\"TemplateId \");\n            sb.append(templateId);\n            if (!f.equals(tarFile)) {\n                sb.append(\" in \" + f);\n            }\n            sb.append(newline);\n        }\n\n        sb.append(\"Size: \");\n        sb.append(\"  direct: \");\n        sb.append(byteCountToDisplaySize(model.getSize()[0]));\n        sb.append(\";  linked: \");\n        sb.append(byteCountToDisplaySize(model.getSize()[1]));\n        sb.append(newline);\n\n        sb.append(\"Properties (count: \" + state.getPropertyCount() + \")\");\n        sb.append(newline);\n        Map<String, String> propLines = newTreeMap();\n        for (PropertyState ps : state.getProperties()) {\n            StringBuilder l = new StringBuilder();\n            l.append(\"  - \" + ps.getName() + \" = {\" + ps.getType() + \"} \");\n            if (ps.getType().isArray()) {\n                int count = ps.count();\n                l.append(\"(count \" + count + \") [\");\n\n                String separator = \", \";\n                int max = 50;\n                if (ps.getType() == Type.BINARIES) {\n                    separator = newline + \"      \";\n                    max = Integer.MAX_VALUE;\n                    l.append(separator);\n                }\n                for (int i = 0; i < Math.min(count, max); i++) {\n                    if (i > 0) {\n                        l.append(separator);\n                    }\n                    l.append(toString(ps, i, tarFile));\n                }\n                if (count > max) {\n                    l.append(\", ... (\" + count + \" values)\");\n                }\n                if (ps.getType() == Type.BINARIES) {\n                    l.append(separator);\n                }\n                l.append(\"]\");\n\n            } else {\n                l.append(toString(ps, 0, tarFile));\n            }\n            if (ps instanceof SegmentPropertyState) {\n                RecordId rid = ((SegmentPropertyState) ps).getRecordId();\n                l.append(\" (\" + rid);\n                String f = getFile(rid);\n                if (!f.equals(tarFile)) {\n                    l.append(\" in \" + f);\n                }\n                l.append(\")\");\n            } else {\n                l.append(\" (\" + ps.getClass().getSimpleName() + \")\");\n            }\n            propLines.put(ps.getName(), l.toString());\n        }\n\n        for (String l : propLines.values()) {\n            sb.append(l);\n            sb.append(newline);\n        }\n\n        sb.append(\"Child nodes (count: \"\n                + state.getChildNodeCount(Long.MAX_VALUE) + \")\");\n        sb.append(newline);\n        Map<String, String> childLines = newTreeMap();\n        for (ChildNodeEntry ce : state.getChildNodeEntries()) {\n            StringBuilder l = new StringBuilder();\n            l.append(\"  + \" + ce.getName());\n            NodeState c = ce.getNodeState();\n            if (c instanceof SegmentNodeState) {\n                RecordId rid = ((SegmentNodeState) c).getRecordId();\n                l.append(\" (\" + rid);\n                String f = getFile(rid);\n                if (!f.equals(tarFile)) {\n                    l.append(\" in \" + f);\n                }\n                l.append(\")\");\n            } else {\n                l.append(\" (\" + c.getClass().getSimpleName() + \")\");\n            }\n            childLines.put(ce.getName(), l.toString());\n        }\n        for (String l : childLines.values()) {\n            sb.append(l);\n            sb.append(newline);\n        }\n\n        if (\"/\".equals(model.getPath())) {\n            sb.append(\"File Reader Index\");\n            sb.append(newline);\n\n            for (String path : getTarFiles(store)) {\n                sb.append(path);\n                sb.append(newline);\n            }\n            sb.append(\"----------\");\n        }\n\n        setText(sb.toString());\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void refreshModel() {\n        index = store.getTarReaderIndex();\n        sizeCache = new HashMap<RecordIdKey, Long[]>();\n        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(\n                new NamePathModel(\"/\", \"/\", store.getHead(), sizeCache,\n                        skipSizeCheck, store, cacheNodeState), true);\n        treeModel = new DefaultTreeModel(rootNode);\n        addChildren(rootNode);\n        tree.setModel(treeModel);\n    }","id":88906,"modified_method":"private void refreshModel() {\n        index = store.getTarReaderIndex();\n        sizeCache = newHashMap();\n        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(\n                new NamePathModel(\"/\", \"/\", store.getHead(), sizeCache,\n                        skipSizeCheck, store), true);\n        treeModel = new DefaultTreeModel(rootNode);\n        addChildren(rootNode);\n        tree.setModel(treeModel);\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private String safeGetLength(Blob b) {\n        try {\n            return FileUtils.byteCountToDisplaySize(b.length());\n        } catch (IllegalStateException e) {\n            // missing BlobStore probably\n        }\n        return \"[BlobStore not available]\";\n    }","id":88907,"modified_method":"private String safeGetLength(Blob b) {\n        try {\n            return byteCountToDisplaySize(b.length());\n        } catch (IllegalStateException e) {\n            // missing BlobStore probably\n        }\n        return \"[BlobStore not available]\";\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static void filterNodeStates(Set<UUID> uuids, List<String> paths,\n            SegmentNodeState state, String path) {\n        Set<String> localPaths = new TreeSet<String>();\n        for (PropertyState ps : state.getProperties()) {\n            if (ps instanceof SegmentPropertyState) {\n                SegmentPropertyState sps = (SegmentPropertyState) ps;\n                RecordId recordId = sps.getRecordId();\n                UUID id = recordId.getSegmentId().asUUID();\n                if (uuids.contains(id)) {\n                    if (ps.getType().tag() == PropertyType.STRING) {\n                        // only shows the first value, do we need more?\n                        String val = displayString(ps.getValue(Type.STRING, 0));\n                        localPaths.add(path + ps.getName() + \" = \" + val\n                                + \" [SegmentPropertyState<\" + ps.getType()\n                                + \">@\" + recordId + \"]\");\n                    } else {\n                        localPaths.add(path + ps + \" [SegmentPropertyState<\"\n                                + ps.getType() + \">@\" + recordId + \"]\");\n                    }\n\n                }\n                if (ps.getType().tag() == PropertyType.BINARY) {\n                    //look for extra segment references\n                    for (int i = 0; i < ps.count(); i++) {\n                        Blob b = ps.getValue(Type.BINARY, i);\n                        for (SegmentId sbid : SegmentBlob.getBulkSegmentIds(b)) {\n                            UUID bid = sbid.asUUID();\n                            if (!bid.equals(id) && uuids.contains(bid)) {\n                                localPaths.add(path + ps\n                                        + \" [SegmentPropertyState<\"\n                                        + ps.getType() + \">@\" + recordId + \"]\");\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        RecordId stateId = state.getRecordId();\n        if (uuids.contains(stateId.getSegmentId().asUUID())) {\n            localPaths.add(path + \" [SegmentNodeState@\" + stateId + \"]\");\n        }\n\n        RecordId templateId = SegmentNodeStateHelper.getTemplateId(state);\n        if (uuids.contains(templateId.getSegmentId().asUUID())) {\n            localPaths.add(path + \"[Template@\" + templateId + \"]\");\n        }\n        paths.addAll(localPaths);\n        for (ChildNodeEntry ce : state.getChildNodeEntries()) {\n            NodeState c = ce.getNodeState();\n            if (c instanceof SegmentNodeState) {\n                filterNodeStates(uuids, paths, (SegmentNodeState) c,\n                        path + ce.getName() + \"/\");\n            }\n        }\n    }","id":88908,"modified_method":"public static void filterNodeStates(Set<UUID> uuids, List<String> paths,\n            SegmentNodeState state, String path) {\n        Set<String> localPaths = newTreeSet();\n        for (PropertyState ps : state.getProperties()) {\n            if (ps instanceof SegmentPropertyState) {\n                SegmentPropertyState sps = (SegmentPropertyState) ps;\n                RecordId recordId = sps.getRecordId();\n                UUID id = recordId.getSegmentId().asUUID();\n                if (uuids.contains(id)) {\n                    if (ps.getType().tag() == STRING) {\n                        // only shows the first value, do we need more?\n                        String val = displayString(ps.getValue(Type.STRING, 0));\n                        localPaths.add(path + ps.getName() + \" = \" + val\n                                + \" [SegmentPropertyState<\" + ps.getType()\n                                + \">@\" + recordId + \"]\");\n                    } else {\n                        localPaths.add(path + ps + \" [SegmentPropertyState<\"\n                                + ps.getType() + \">@\" + recordId + \"]\");\n                    }\n\n                }\n                if (ps.getType().tag() == BINARY) {\n                    // look for extra segment references\n                    for (int i = 0; i < ps.count(); i++) {\n                        Blob b = ps.getValue(Type.BINARY, i);\n                        for (SegmentId sbid : SegmentBlob.getBulkSegmentIds(b)) {\n                            UUID bid = sbid.asUUID();\n                            if (!bid.equals(id) && uuids.contains(bid)) {\n                                localPaths.add(path + ps\n                                        + \" [SegmentPropertyState<\"\n                                        + ps.getType() + \">@\" + recordId + \"]\");\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        RecordId stateId = state.getRecordId();\n        if (uuids.contains(stateId.getSegmentId().asUUID())) {\n            localPaths.add(path + \" [SegmentNodeState@\" + stateId + \"]\");\n        }\n\n        RecordId templateId = getTemplateId(state);\n        if (uuids.contains(templateId.getSegmentId().asUUID())) {\n            localPaths.add(path + \"[Template@\" + templateId + \"]\");\n        }\n        paths.addAll(localPaths);\n        for (ChildNodeEntry ce : state.getChildNodeEntries()) {\n            NodeState c = ce.getNodeState();\n            if (c instanceof SegmentNodeState) {\n                filterNodeStates(uuids, paths, (SegmentNodeState) c,\n                        path + ce.getName() + \"/\");\n            }\n        }\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void printDependenciesToSegment(String sid) {\n        if (sid == null || sid.length() == 0) {\n            return;\n        }\n        UUID id = null;\n        try {\n            id = UUID.fromString(sid.trim());\n        } catch (IllegalArgumentException e) {\n            setText(e.getMessage());\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"SegmentNodeState references to \" + id);\n        sb.append(newline);\n        for (Entry<String, Set<UUID>> e : store.getTarReaderIndex().entrySet()) {\n            if (e.getValue().contains(id)) {\n                sb.append(\"Tar file: \" + e.getKey());\n                sb.append(newline);\n                break;\n            }\n        }\n\n        List<String> paths = newArrayList();\n        filterNodeStates(newHashSet(id), paths, store.getHead(), \"/\");\n        if (!paths.isEmpty()) {\n            sb.append(\"Repository content references:\");\n            sb.append(newline);\n            for (String p : paths) {\n                sb.append(p);\n                sb.append(newline);\n            }\n        }\n        setText(sb.toString());\n    }","id":88909,"modified_method":"public void printDependenciesToSegment(String sid) {\n        if (sid == null || sid.length() == 0) {\n            return;\n        }\n        UUID id = null;\n        try {\n            id = UUID.fromString(sid.trim());\n        } catch (IllegalArgumentException e) {\n            setText(e.getMessage());\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"References to segment \" + id);\n        sb.append(newline);\n        for (Entry<String, Set<UUID>> e : index.entrySet()) {\n            if (e.getValue().contains(id)) {\n                sb.append(\"Tar file: \" + e.getKey());\n                sb.append(newline);\n                break;\n            }\n        }\n\n        List<String> paths = newArrayList();\n        filterNodeStates(newHashSet(id), paths, store.getHead(), \"/\");\n        if (!paths.isEmpty()) {\n            sb.append(\"Repository content references:\");\n            sb.append(newline);\n            for (String p : paths) {\n                sb.append(p);\n                sb.append(newline);\n            }\n        }\n\n        Map<UUID, Set<Entry<UUID, String>>> links = newHashMap();\n        try {\n            getGcRoots(store, id, links);\n        } catch (IOException e) {\n            sb.append(newline);\n            sb.append(e.getMessage());\n        }\n        if (!links.isEmpty()) {\n            sb.append(\"Segment GC roots:\");\n            sb.append(newline);\n            printGcRoots(sb, links, id, \"  \", \"  \");\n        }\n\n        setText(sb.toString());\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private NodeState loadState() {\n            NodeState n = store.getHead();\n            for (String p : PathUtils.elements(path)) {\n                n = n.getChildNode(p);\n            }\n            return n;\n        }","id":88910,"modified_method":"private NodeState loadState() {\n            NodeState n = store.getHead();\n            for (String p : elements(path)) {\n                n = n.getChildNode(p);\n            }\n            return n;\n        }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NamePathModel(String name, String path, NodeState state,\n                Map<RecordIdKey, Long[]> sizeCache, boolean skipSizeCheck,\n                FileStore store, boolean cacheNodeState) {\n            this.store = store;\n            this.name = name;\n            this.path = path;\n            this.skipSizeCheck = skipSizeCheck;\n            if (!skipSizeCheck && state instanceof SegmentNodeState) {\n                this.size = exploreSize((SegmentNodeState) state, sizeCache);\n            }\n            this.cacheNodeState = cacheNodeState;\n            if (cacheNodeState) {\n                this.state = state;\n            }\n        }","id":88911,"modified_method":"public NamePathModel(String name, String path, NodeState state,\n                Map<RecordIdKey, Long[]> sizeCache, boolean skipSizeCheck,\n                FileStore store) {\n            this.store = store;\n            this.name = name;\n            this.path = path;\n            this.skipSizeCheck = skipSizeCheck;\n            if (!skipSizeCheck && state instanceof SegmentNodeState) {\n                this.size = exploreSize((SegmentNodeState) state, sizeCache);\n            }\n        }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void printTarInfo(String file) {\n        if (file == null || file.length() == 0) {\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n\n        Set<UUID> uuids = newHashSet();\n        for (Entry<String, Set<UUID>> e : store.getTarReaderIndex().entrySet()) {\n            if (e.getKey().endsWith(file)) {\n                sb.append(\"SegmentNodeState references to \" + e.getKey());\n                sb.append(newline);\n                uuids = e.getValue();\n                break;\n            }\n        }\n\n        Set<UUID> inMem = intersection(getReferencedUUIDs(store), uuids);\n        if (!inMem.isEmpty()) {\n            sb.append(\"In Memory segment references: \");\n            sb.append(newline);\n            sb.append(inMem);\n            sb.append(newline);\n        }\n\n        List<String> paths = newArrayList();\n        filterNodeStates(uuids, paths, store.getHead(), \"/\");\n        if (!paths.isEmpty()) {\n            sb.append(\"Repository content references:\");\n            sb.append(newline);\n            for (String p : paths) {\n                sb.append(p);\n                sb.append(newline);\n            }\n        }\n\n        sb.append(newline);\n        try {\n            Map<UUID, List<UUID>> graph = store.getTarGraph(file);\n            sb.append(\"Tar graph:\").append(newline);\n            for (Entry<UUID, List<UUID>> entry : graph.entrySet()) {\n                sb.append(entry.getKey()).append('=').append(entry.getValue()).append(newline);\n            }\n            sb.append(newline);\n        } catch (IOException e) {\n            sb.append(\"Error getting tar graph:\").append(e).append(newline);\n        }\n\n        setText(sb.toString());\n    }","id":88912,"modified_method":"public void printTarInfo(String file) {\n        if (file == null || file.length() == 0) {\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n\n        Set<UUID> uuids = newHashSet();\n        for (Entry<String, Set<UUID>> e : index.entrySet()) {\n            if (e.getKey().endsWith(file)) {\n                sb.append(\"SegmentNodeState references to \"\n                        + new File(e.getKey()).getName());\n                sb.append(newline);\n                uuids = e.getValue();\n                break;\n            }\n        }\n\n        Set<UUID> inMem = intersection(getReferencedUUIDs(store), uuids);\n        if (!inMem.isEmpty()) {\n            sb.append(\"In Memory segment references: \");\n            sb.append(newline);\n            sb.append(inMem);\n            sb.append(newline);\n        }\n\n        List<String> paths = newArrayList();\n        filterNodeStates(uuids, paths, store.getHead(), \"/\");\n        if (!paths.isEmpty()) {\n            sb.append(\"Repository content references:\");\n            sb.append(newline);\n            for (String p : paths) {\n                sb.append(p);\n                sb.append(newline);\n            }\n        }\n\n        sb.append(newline);\n        try {\n            Map<UUID, List<UUID>> graph = store.getTarGraph(file);\n            sb.append(\"Tar graph:\").append(newline);\n            for (Entry<UUID, List<UUID>> entry : graph.entrySet()) {\n                sb.append(entry.getKey()).append('=').append(entry.getValue())\n                        .append(newline);\n            }\n            sb.append(newline);\n        } catch (IOException e) {\n            sb.append(\"Error getting tar graph:\").append(e).append(newline);\n        }\n\n        setText(sb.toString());\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeStoreTree(String path, JTextArea log, boolean skipSizeCheck)\n            throws IOException {\n        super(new GridLayout(1, 0));\n        this.path = path;\n        this.log = log;\n        this.skipSizeCheck = skipSizeCheck;\n\n        tree = new JTree();\n        tree.getSelectionModel().setSelectionMode(\n                TreeSelectionModel.SINGLE_TREE_SELECTION);\n        tree.setShowsRootHandles(true);\n        tree.addTreeSelectionListener(this);\n        tree.setExpandsSelectedPaths(true);\n\n        refreshStore();\n        refreshModel();\n\n        JScrollPane scrollPane = new JScrollPane(tree);\n        add(scrollPane);\n    }","id":88913,"modified_method":"public NodeStoreTree(String path, JTextArea log, boolean skipSizeCheck)\n            throws IOException {\n        super(new GridLayout(1, 0));\n        this.path = path;\n        this.log = log;\n        this.skipSizeCheck = skipSizeCheck;\n\n        tree = new JTree();\n        tree.getSelectionModel().setSelectionMode(SINGLE_TREE_SELECTION);\n        tree.setShowsRootHandles(true);\n        tree.addTreeSelectionListener(this);\n        tree.setExpandsSelectedPaths(true);\n\n        refreshStore();\n        refreshModel();\n\n        JScrollPane scrollPane = new JScrollPane(tree);\n        add(scrollPane);\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private String getFile(SegmentId segmentId) {\n        for (Entry<String, Set<UUID>> path2Uuid : index.entrySet()) {\n            for (UUID uuid : path2Uuid.getValue()) {\n                if (uuid.getMostSignificantBits() == segmentId\n                        .getMostSignificantBits()\n                        && uuid.getLeastSignificantBits() == segmentId\n                                .getLeastSignificantBits()) {\n                    return new File(path2Uuid.getKey()).getName();\n                }\n            }\n        }\n        return \"\";\n    }","id":88914,"modified_method":"private String getFile(SegmentId segmentId) {\n        for (Entry<String, Set<UUID>> path2Uuid : index.entrySet()) {\n            for (UUID uuid : path2Uuid.getValue()) {\n                if (uuid.equals(segmentId.asUUID())) {\n                    return new File(path2Uuid.getKey()).getName();\n                }\n            }\n        }\n        return \"\";\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void addChildren(DefaultMutableTreeNode parent) {\n        NamePathModel model = (NamePathModel) parent.getUserObject();\n        if (model.isLoaded()) {\n            return;\n        }\n\n        List<NamePathModel> kids = newArrayList();\n        for (ChildNodeEntry ce : model.getState().getChildNodeEntries()) {\n            NamePathModel c = new NamePathModel(ce.getName(), PathUtils.concat(\n                    model.getPath(), ce.getName()), ce.getNodeState(),\n                    sizeCache, skipSizeCheck, store, cacheNodeState);\n            kids.add(c);\n        }\n        Collections.sort(kids);\n        for (NamePathModel c : kids) {\n            DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(c,\n                    true);\n            treeModel.insertNodeInto(childNode, parent, parent.getChildCount());\n        }\n        model.loaded();\n    }","id":88915,"modified_method":"private void addChildren(DefaultMutableTreeNode parent) {\n        NamePathModel model = (NamePathModel) parent.getUserObject();\n        if (model.isLoaded()) {\n            return;\n        }\n\n        List<NamePathModel> kids = newArrayList();\n        for (ChildNodeEntry ce : model.getState().getChildNodeEntries()) {\n            NamePathModel c = new NamePathModel(ce.getName(), concat(\n                    model.getPath(), ce.getName()), ce.getNodeState(),\n                    sizeCache, skipSizeCheck, store);\n            kids.add(c);\n        }\n        sort(kids);\n        for (NamePathModel c : kids) {\n            DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(c,\n                    true);\n            treeModel.insertNodeInto(childNode, parent, parent.getChildCount());\n        }\n        model.loaded();\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void printDiff(String input) {\n        StringBuilder sb = new StringBuilder();\n        if (input == null || input.trim().length() == 0) {\n            sb.append(\"Unknown argument: \");\n            sb.append(input);\n            sb.append(newline);\n            setText(\"Usage <recordId> <recordId> [<path>]\");\n            return;\n        }\n\n        String[] tokens = input.trim().split(\" \");\n        if (tokens.length != 2 && tokens.length != 3) {\n            sb.append(\"Unknown argument: \");\n            sb.append(input);\n            sb.append(newline);\n            setText(\"Usage <recordId> <recordId> [<path>]\");\n            return;\n        }\n        RecordId id1 = null;\n        RecordId id2 = null;\n        try {\n            id1 = RecordId.fromString(store.getTracker(), tokens[0]);\n            id2 = RecordId.fromString(store.getTracker(), tokens[1]);\n        } catch (IllegalArgumentException ex) {\n            sb.append(\"Unknown argument: \");\n            sb.append(input);\n            sb.append(newline);\n            sb.append(\"Error: \");\n            sb.append(ex.getMessage());\n            sb.append(newline);\n            setText(sb.toString());\n            return;\n        }\n        String path = \"/\";\n        if (tokens.length == 3) {\n            path = tokens[2];\n        }\n\n        NodeState node1 = new SegmentNodeState(id1);\n        NodeState node2 = new SegmentNodeState(id2);\n        for (String name : PathUtils.elements(path)) {\n            node1 = node1.getChildNode(name);\n            node2 = node2.getChildNode(name);\n        }\n\n        sb.append(\"SegmentNodeState diff \");\n        sb.append(id1);\n        sb.append(\" vs \");\n        sb.append(id2);\n        sb.append(\" at \");\n        sb.append(path);\n        sb.append(newline);\n        sb.append(\"--------\");\n        sb.append(newline);\n        sb.append(JsopBuilder.prettyPrint(JsopDiff.diffToJsop(node1, node2)));\n        setText(sb.toString());\n    }","id":88916,"modified_method":"public void printDiff(String input) {\n        StringBuilder sb = new StringBuilder();\n        if (input == null || input.trim().length() == 0) {\n            sb.append(\"Unknown argument: \");\n            sb.append(input);\n            sb.append(newline);\n            setText(\"Usage <recordId> <recordId> [<path>]\");\n            return;\n        }\n\n        String[] tokens = input.trim().split(\" \");\n        if (tokens.length != 2 && tokens.length != 3) {\n            sb.append(\"Unknown argument: \");\n            sb.append(input);\n            sb.append(newline);\n            setText(\"Usage <recordId> <recordId> [<path>]\");\n            return;\n        }\n        RecordId id1 = null;\n        RecordId id2 = null;\n        try {\n            id1 = RecordId.fromString(store.getTracker(), tokens[0]);\n            id2 = RecordId.fromString(store.getTracker(), tokens[1]);\n        } catch (IllegalArgumentException ex) {\n            sb.append(\"Unknown argument: \");\n            sb.append(input);\n            sb.append(newline);\n            sb.append(\"Error: \");\n            sb.append(ex.getMessage());\n            sb.append(newline);\n            setText(sb.toString());\n            return;\n        }\n        String path = \"/\";\n        if (tokens.length == 3) {\n            path = tokens[2];\n        }\n\n        NodeState node1 = new SegmentNodeState(id1);\n        NodeState node2 = new SegmentNodeState(id2);\n        for (String name : elements(path)) {\n            node1 = node1.getChildNode(name);\n            node2 = node2.getChildNode(name);\n        }\n\n        sb.append(\"SegmentNodeState diff \");\n        sb.append(id1);\n        sb.append(\" vs \");\n        sb.append(id2);\n        sb.append(\" at \");\n        sb.append(path);\n        sb.append(newline);\n        sb.append(\"--------\");\n        sb.append(newline);\n        sb.append(prettyPrint(diffToJsop(node1, node2)));\n        setText(sb.toString());\n    }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public String toString() {\n            if (skipSizeCheck) {\n                return name;\n            }\n            if (size[1] > 0) {\n                return name + \" (\" + FileUtils.byteCountToDisplaySize(size[0])\n                        + \";\" + FileUtils.byteCountToDisplaySize(size[1]) + \")\";\n            }\n            if (size[0] > 0) {\n                return name + \" (\" + FileUtils.byteCountToDisplaySize(size[0])\n                        + \")\";\n            }\n            return name;\n        }","id":88917,"modified_method":"@Override\n        public String toString() {\n            if (skipSizeCheck) {\n                return name;\n            }\n            if (size[1] > 0) {\n                return name + \" (\" + byteCountToDisplaySize(size[0]) + \";\"\n                        + byteCountToDisplaySize(size[1]) + \")\";\n            }\n            if (size[0] > 0) {\n                return name + \" (\" + byteCountToDisplaySize(size[0]) + \")\";\n            }\n            return name;\n        }","commit_id":"5aa10a158e20dc4b156d802bbed5cadd0dd50eb0","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void loadDirectoryProject(MockProject project, VirtualFile projectDir) throws IOException, JDOMException,\n                                                                                           InvalidDataException {\n    VirtualFile dotIdea = projectDir.findChild(Project.DIRECTORY_STORE_FOLDER);\n    if (dotIdea == null)\n      throw new FileNotFoundException(\"Missing '\" + Project.DIRECTORY_STORE_FOLDER + \"' in \" + projectDir.getPath());\n\n    VirtualFile modulesXml = dotIdea.findChild(\"modules.xml\");\n    if (modulesXml == null)\n      throw new FileNotFoundException(\"Missing 'modules.xml' in \" + dotIdea.getPath());\n\n    TreeMap<String, Element> storageData = loadStorageFile(project, modulesXml);\n    final Element moduleManagerState = storageData.get(\"ProjectModuleManager\");\n    if (moduleManagerState == null) {\n      throw new JDOMException(\"cannot find ProjectModuleManager state in modules.xml\");\n    }\n    final CoreModuleManager moduleManager = (CoreModuleManager)ModuleManager.getInstance(project);\n    moduleManager.loadState(moduleManagerState);\n\n    VirtualFile miscXml = dotIdea.findChild(\"misc.xml\");\n    if (miscXml == null)\n      throw new FileNotFoundException(\"Missing 'misc.xml' in \" + dotIdea.getPath());\n    storageData = loadStorageFile(project, miscXml);\n    final Element projectRootManagerState = storageData.get(\"ProjectRootManager\");\n    if (projectRootManagerState == null) {\n      throw new JDOMException(\"cannot find ProjectRootManager state in misc.xml\");\n    }\n    ((ProjectRootManagerImpl) ProjectRootManager.getInstance(project)).loadState(projectRootManagerState);\n\n    VirtualFile libraries = dotIdea.findChild(\"libraries\");\n    if (libraries != null) {\n      Map<String, Element> data = DirectoryStorageUtil.loadFrom(libraries, PathMacroManager.getInstance(project).createTrackingSubstitutor());\n      Element libraryTable = DefaultStateSerializer.deserializeState(DirectoryStorageUtil.getCompositeState(data, new ProjectLibraryTable.LibraryStateSplitter()), Element.class, null);\n      ((LibraryTableBase) ProjectLibraryTable.getInstance(project)).loadState(libraryTable);\n    }\n\n    moduleManager.loadModules();\n    project.projectOpened();\n  }","id":88918,"modified_method":"private static void loadDirectoryProject(MockProject project, @NotNull VirtualFile dotIdea) throws IOException, JDOMException {\n    VirtualFile modulesXml = dotIdea.findChild(\"modules.xml\");\n    if (modulesXml == null)\n      throw new FileNotFoundException(\"Missing 'modules.xml' in \" + dotIdea.getPath());\n\n    TreeMap<String, Element> storageData = loadStorageFile(project, modulesXml);\n    final Element moduleManagerState = storageData.get(\"ProjectModuleManager\");\n    if (moduleManagerState == null) {\n      throw new JDOMException(\"cannot find ProjectModuleManager state in modules.xml\");\n    }\n    final CoreModuleManager moduleManager = (CoreModuleManager)ModuleManager.getInstance(project);\n    moduleManager.loadState(moduleManagerState);\n\n    VirtualFile miscXml = dotIdea.findChild(\"misc.xml\");\n    if (miscXml != null) {\n      storageData = loadStorageFile(project, miscXml);\n      final Element projectRootManagerState = storageData.get(\"ProjectRootManager\");\n      if (projectRootManagerState == null) {\n        throw new JDOMException(\"cannot find ProjectRootManager state in misc.xml\");\n      }\n      ((ProjectRootManagerImpl)ProjectRootManager.getInstance(project)).loadState(projectRootManagerState);\n    }\n\n    VirtualFile libraries = dotIdea.findChild(\"libraries\");\n    if (libraries != null) {\n      Map<String, Element> data = DirectoryStorageUtil.loadFrom(libraries, PathMacroManager.getInstance(project).createTrackingSubstitutor());\n      Element libraryTable = DefaultStateSerializer.deserializeState(DirectoryStorageUtil.getCompositeState(data, new ProjectLibraryTable.LibraryStateSplitter()), Element.class, null);\n      ((LibraryTableBase) ProjectLibraryTable.getInstance(project)).loadState(libraryTable);\n    }\n\n    moduleManager.loadModules();\n    project.projectOpened();\n  }","commit_id":"bcdcf092486432e6c3c66797b1944920b0bd4797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean loadProject(MockProject project, @NotNull VirtualFile virtualFile)\n    throws IOException, JDOMException, InvalidDataException {\n    if (virtualFile.isDirectory() && virtualFile.findChild(Project.DIRECTORY_STORE_FOLDER) != null) {\n      project.setBaseDir(virtualFile);\n      loadDirectoryProject(project, virtualFile);\n      return true;\n    }\n\n    // TODO load .ipr\n    return false;\n  }","id":88919,"modified_method":"public static boolean loadProject(MockProject project, @NotNull VirtualFile virtualFile) throws IOException, JDOMException {\n    VirtualFile ideaDir = ProjectKt.getProjectStoreDirectory(virtualFile);\n    if (ideaDir != null) {\n      project.setBaseDir(virtualFile);\n      loadDirectoryProject(project, ideaDir);\n      return true;\n    }\n\n    // TODO load .ipr\n    return false;\n  }","commit_id":"bcdcf092486432e6c3c66797b1944920b0bd4797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Simply listen on I2P port, and thread connections\n\t * \n\t * @throws RuntimeException \n\t */\n\tpublic void run() throws RuntimeException {\n\t\tboolean g = false;\n\t\tI2PSocket sessSocket = null;\n\n\t\t// needed to hack in this method :-/\n\t\tserverSocket.setSoTimeout(1000);\n\t\tif(info.exists(\"INPORT\")) {\n\t\t\ttgwatch = 2;\n\t\t}\n\t\twhile(info.get(\"RUNNING\").equals(Boolean.TRUE)) {\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tsessSocket = serverSocket.accept();\n\t\t\t\t\tg = true;\n\t\t\t\t} catch(ConnectException ce) {\n\t\t\t\t\tg = false;\n\t\t\t\t} catch (SocketTimeoutException ste) {\n\t\t\t\t\tg = false;\n\t\t\t\t}\n\t\t\t\tif(g) {\n\t\t\t\t\tg = false;\n\t\t\t\t\t// toss the connection to a new thread.\n\t\t\t\t\tI2PtoTCP conn_c = new I2PtoTCP(sessSocket, info);\n\t\t\t\t\tThread t = new Thread(conn_c, \"BOBI2PtoTCP\");\n\t\t\t\t\tt.start();\n\t\t\t\t}\n\n\t\t\t} catch(I2PException e) {\n\t\t\t\tSystem.out.println(\"Exception \"+e);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tserverSocket.close();\n\t\t} catch(I2PException e) {\n\t\t\t// nop\n\t\t}\n\n\t\twhile(Thread.activeCount() > tgwatch) { // wait for all threads in our threadgroup to finish\n//\t\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t} catch(Exception e) {\n\t\t\t\t// nop\n\t\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t// need to kill off the socket manager too.\n\t\tI2PSession session = socketManager.getSession();\n\t\tif(session != null) {\n\t\t\ttry {\n\t\t\t\tsession.destroySession();\n\t\t\t} catch(I2PSessionException ex) {\n\t\t\t\t// nop\n\t\t\t}\n//\t\t\tSystem.out.println(\"destroySession Thread count \" + Thread.activeCount());\n\t\t}\n\n\n\t}","id":88920,"modified_method":"/**\n\t * Simply listen on I2P port, and thread connections\n\t *\n\t * @throws RuntimeException\n\t */\n\tpublic void run() throws RuntimeException {\n\t\tboolean g = false;\n\t\tI2PSocket sessSocket = null;\n\n\t\tserverSocket.setSoTimeout(1000);\n\t\tdatabase.getReadLock();\n\t\tinfo.getReadLock();\n\t\tif(info.exists(\"INPORT\")) {\n\t\t\ttgwatch = 2;\n\t\t}\n\t\tinfo.releaseReadLock();\n\t\tdatabase.releaseReadLock();\n\t\tboolean spin = true;\n\t\twhile(spin) {\n\n\t\t\tdatabase.getReadLock();\n\t\t\tinfo.getReadLock();\n\t\t\tspin = info.get(\"RUNNING\").equals(Boolean.TRUE);\n\t\t\tinfo.releaseReadLock();\n\t\t\tdatabase.releaseReadLock();\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tsessSocket = serverSocket.accept();\n\t\t\t\t\tg = true;\n\t\t\t\t} catch(ConnectException ce) {\n\t\t\t\t\tg = false;\n\t\t\t\t} catch(SocketTimeoutException ste) {\n\t\t\t\t\tg = false;\n\t\t\t\t}\n\t\t\t\tif(g) {\n\t\t\t\t\tg = false;\n\t\t\t\t\t// toss the connection to a new thread.\n\t\t\t\t\tI2PtoTCP conn_c = new I2PtoTCP(sessSocket, info, database);\n\t\t\t\t\tThread t = new Thread(conn_c, \"BOBI2PtoTCP\");\n\t\t\t\t\tt.start();\n\t\t\t\t}\n\n\t\t\t} catch(I2PException e) {\n\t\t\t//\tSystem.out.println(\"Exception \" + e);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tserverSocket.close();\n\t\t} catch(I2PException e) {\n\t\t\t// nop\n\t\t}\n\n\t\twhile(Thread.activeCount() > tgwatch) { // wait for all threads in our threadgroup to finish\n//\t\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t} catch(Exception e) {\n\t\t\t\t// nop\n\t\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t// need to kill off the socket manager too.\n\t\tI2PSession session = socketManager.getSession();\n\t\tif(session != null) {\n\t\t\ttry {\n\t\t\t\tsession.destroySession();\n\t\t\t} catch(I2PSessionException ex) {\n\t\t\t\t// nop\n\t\t\t}\n//\t\t\tSystem.out.println(\"destroySession Thread count \" + Thread.activeCount());\n\t\t}\n\n\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Constructor\n\t * @param S\n\t * @param info\n\t * @param _log\n\t */\n\tI2Plistener(I2PSocketManager S, nickname info, Log _log) {\n\t\tthis.info = info;\n\t\tthis._log = _log;\n\t\tthis.socketManager = S;\n\t\tserverSocket = socketManager.getServerSocket();\n\t\ttgwatch = 1;\n\t}","id":88921,"modified_method":"/**\n\t * Constructor\n\t * @param S\n\t * @param info\n\t * @param database\n\t * @param _log\n\t */\n\tI2Plistener(I2PSocketManager S, nickname info, nickname database, Log _log) {\n\t\tthis.database = database;\n\t\tthis.info = info;\n\t\tthis._log = _log;\n\t\tthis.socketManager = S;\n\t\tserverSocket = socketManager.getServerSocket();\n\t\ttgwatch = 1;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * I2P stream to TCP stream thread starter\n\t * \n\t */\n\tpublic void run() {\n\n\t\ttry {\n\t\t\tsock = new Socket(info.get(\"OUTHOST\").toString(), Integer.parseInt(info.get(\"OUTPORT\").toString()));\n\t\t\t// make readers/writers\n\t\t\tInputStream in = sock.getInputStream();\n\t\t\tOutputStream out = sock.getOutputStream();\n\t\t\tInputStream Iin = I2P.getInputStream();\n\t\t\tOutputStream Iout = I2P.getOutputStream();\n\t\t\tI2P.setReadTimeout(0); // temp bugfix, this *SHOULD* be the default\n\n\t\t\tif(info.get(\"QUIET\").equals(Boolean.FALSE)) {\n\t\t\t\t// tell who is connecting\n\t\t\t\tout.write(I2P.getPeerDestination().toBase64().getBytes());\n\t\t\t\tout.write(10); // nl\n\t\t\t\tout.flush(); // not really needed, but...\n\t\t\t}\n\t\t\t// setup to cross the streams\n\t\t\tTCPio conn_c = new TCPio(in, Iout, info); // app -> I2P\n\t\t\tTCPio conn_a = new TCPio(Iin, out, info); // I2P -> app\n\t\t\tThread t = new Thread(conn_c, \"TCPioA\");\n\t\t\tThread q = new Thread(conn_a, \"TCPioB\");\n\t\t\t// Fire!\n\t\t\tt.start();\n\t\t\tq.start();\n\t\t\twhile(t.isAlive() && q.isAlive()) { // AND is used here to kill off the other thread\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(10); //sleep for 10 ms\n\t\t\t\t} catch(InterruptedException e) {\n\t\t\t\t\t// nop\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch(Exception e) {\n\t\t}\n\t\ttry {\n\t\t\tI2P.close();\n\t\t} catch(Exception e) {\n\t\t}\n\t\ttry {\n\t\t\tsock.close();\n\t\t} catch(Exception e) {\n\t\t}\n\t}","id":88922,"modified_method":"/**\n\t * I2P stream to TCP stream thread starter\n\t * \n\t */\n\tpublic void run() {\n\n\t\ttry {\n\t\t\tdatabase.getReadLock();\n\t\t\tinfo.getReadLock();\n\t\t\tString host = info.get(\"OUTHOST\").toString();\n\t\t\tint port = Integer.parseInt(info.get(\"OUTPORT\").toString());\n\t\t\tboolean tell = info.get(\"QUIET\").equals(Boolean.FALSE);\n\t\t\tinfo.releaseReadLock();\n\t\t\tdatabase.releaseReadLock();\n\t\t\tsock = new Socket(host, port);\n\t\t\t// make readers/writers\n\t\t\tInputStream in = sock.getInputStream();\n\t\t\tOutputStream out = sock.getOutputStream();\n\t\t\tInputStream Iin = I2P.getInputStream();\n\t\t\tOutputStream Iout = I2P.getOutputStream();\n\t\t\tI2P.setReadTimeout(0); // temp bugfix, this *SHOULD* be the default\n\n\t\t\tif(tell) {\n\t\t\t\t// tell who is connecting\n\t\t\t\tout.write(I2P.getPeerDestination().toBase64().getBytes());\n\t\t\t\tout.write(10); // nl\n\t\t\t\tout.flush(); // not really needed, but...\n\t\t\t}\n\t\t\t// setup to cross the streams\n\t\t\tTCPio conn_c = new TCPio(in, Iout, info, database); // app -> I2P\n\t\t\tTCPio conn_a = new TCPio(Iin, out, info, database); // I2P -> app\n\t\t\tThread t = new Thread(conn_c, \"TCPioA\");\n\t\t\tThread q = new Thread(conn_a, \"TCPioB\");\n\t\t\t// Fire!\n\t\t\tt.start();\n\t\t\tq.start();\n\t\t\twhile(t.isAlive() && q.isAlive()) { // AND is used here to kill off the other thread\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(10); //sleep for 10 ms\n\t\t\t\t} catch(InterruptedException e) {\n\t\t\t\t\t// nop\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch(Exception e) {\n\t\t}\n\t\ttry {\n\t\t\tI2P.close();\n\t\t} catch(Exception e) {\n\t\t}\n\t\ttry {\n\t\t\tsock.close();\n\t\t} catch(Exception e) {\n\t\t}\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param I2Psock\n\t * @param db\n\t */\n\tI2PtoTCP(I2PSocket I2Psock, nickname db) {\n\t\tthis.I2P = I2Psock;\n\t\tthis.info = db;\n\t}","id":88923,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param I2Psock\n\t * @param info\n\t * @param database\n\t */\n\tI2PtoTCP(I2PSocket I2Psock, nickname info, nickname database) {\n\t\tthis.I2P = I2Psock;\n\t\tthis.info = info;\n\t\tthis.database = database;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param info\n\t * @param _log\n\t * @throws net.i2p.I2PException\n\t * @throws java.io.IOException\n\t */\n\tMUXlisten(nickname info, Log _log) throws I2PException, IOException {\n\t\tthis.info = info;\n\t\tthis._log = _log;\n\t\tthis.info.add(\"STARTING\", Boolean.TRUE);\n\n\t\tN = this.info.get(\"NICKNAME\").toString();\n\t\tprikey = new ByteArrayInputStream((byte[])info.get(\"KEYS\"));\n\t\tsocketManager = I2PSocketManagerFactory.createManager(prikey, (Properties)info.get(\"PROPERTIES\"));\n\t}","id":88924,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param info\n\t * @param database\n\t * @param _log\n\t * @throws net.i2p.I2PException\n\t * @throws java.io.IOException\n\t */\n\tMUXlisten(nickname database, nickname info, Log _log) throws I2PException, IOException {\n\t\tthis.database = database;\n\t\tthis.info = info;\n\t\tthis._log = _log;\n\n\t\tthis.database.getReadLock();\n\t\tthis.info.getReadLock();\n\t\tN = this.info.get(\"NICKNAME\").toString();\n\t\tprikey = new ByteArrayInputStream((byte[])info.get(\"KEYS\"));\n\t\tProperties Q = (Properties)info.get(\"PROPERTIES\");\n\t\tthis.database.releaseReadLock();\n\t\tthis.info.releaseReadLock();\n\n\t\tthis.database.getWriteLock();\n\t\tthis.info.getWriteLock();\n\t\tthis.info.add(\"STARTING\", Boolean.TRUE);\n\t\tthis.info.releaseWriteLock();\n\t\tthis.database.releaseWriteLock();\n\t\t\n\t\tsocketManager = I2PSocketManagerFactory.createManager(prikey, Q);\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * MUX sockets, fire off a thread to connect, get destination info, and do I/O\n\t * \n\t */\n\tpublic void run() {\n\n\t\ttg = new ThreadGroup(N);\n\t\tinfo.add(\"RUNNING\", Boolean.TRUE);\n\t\tinfo.add(\"STARTING\", Boolean.FALSE);\n\n\t\t// toss the connections to a new threads.\n\t\t// will wrap with TCP and UDP when UDP works\n\t\tif(info.exists(\"OUTPORT\")) {\n\t\t\t// I2P -> TCP\n\t\t\tI2Plistener conn = new I2Plistener(socketManager, info, _log);\n\t\t\tThread t = new Thread(tg, conn, \"BOBI2Plistener \" + N);\n\t\t\tt.start();\n\t\t}\n\t\tif(info.exists(\"INPORT\")) {\n\t\t\t// TCP -> I2P\n\t\t\tTCPlistener conn = new TCPlistener(socketManager, info, _log);\n\t\t\tThread q = new Thread(tg, conn,\"BOBTCPlistener\" + N);\n\t\t\tq.start();\n\t\t}\n\n\t\twhile(info.get(\"STOPPING\").equals(Boolean.FALSE)) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t} catch(InterruptedException e) {\n\t\t\t\t// nop\n\t\t\t}\n\t\t}\n\n\t\tinfo.add(\"RUNNING\", Boolean.FALSE);\n\t\t// wait for child threads and thread groups to die\n\t\twhile (tg.activeCount() + tg.activeGroupCount() != 0) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t} catch(InterruptedException ex) {\n\t\t\t\t// nop\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tsocketManager.destroySocketManager();\n\t\ttg.destroy();\n\t\t// Zap reference to the ThreadGroup so the JVM can GC it.\n\t\ttg = null;\n\t\tinfo.add(\"STOPPING\", Boolean.FALSE);\n\t\tinfo.add(\"STARTING\", Boolean.FALSE);\n\n\t}","id":88925,"modified_method":"/**\n\t * MUX sockets, fire off a thread to connect, get destination info, and do I/O\n\t * \n\t */\n\tpublic void run() {\n\n\t\tthis.database.getWriteLock();\n\t\tthis.info.getWriteLock();\n\t\tinfo.add(\"RUNNING\", Boolean.TRUE);\n\t\tinfo.add(\"STARTING\", Boolean.FALSE);\n\t\tthis.info.releaseWriteLock();\n\t\tthis.database.releaseWriteLock();\n\n\t\ttry {\n\t\t\ttg = new ThreadGroup(N);\n\n\t\t\t// toss the connections to a new threads.\n\t\t\t// will wrap with TCP and UDP when UDP works\n\t\t\tthis.database.getReadLock();\n\t\t\tthis.info.getReadLock();\n\t\t\tboolean go_out = info.exists(\"OUTPORT\");\n\t\t\tboolean come_in = info.exists(\"INPORT\");\n\t\t\tthis.database.releaseReadLock();\n\t\t\tthis.info.releaseReadLock();\n\n\t\t\tif(go_out) {\n\t\t\t\t// I2P -> TCP\n\t\t\t\tI2Plistener conn = new I2Plistener(socketManager, info, database, _log);\n\t\t\t\tThread t = new Thread(tg, conn, \"BOBI2Plistener \" + N);\n\t\t\t\tt.start();\n\t\t\t}\n\n\t\t\tif(come_in) {\n\t\t\t\t// TCP -> I2P\n\t\t\t\tTCPlistener conn = new TCPlistener(socketManager, info, database, _log);\n\t\t\t\tThread q = new Thread(tg, conn, \"BOBTCPlistener\" + N);\n\t\t\t\tq.start();\n\t\t\t}\n\n\t\t\tboolean spin = true;\n\t\t\twhile(spin) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t\t} catch(InterruptedException e) {\n\t\t\t\t\t// nop\n\t\t\t\t}\n\n\t\t\t\tthis.database.getReadLock();\n\t\t\t\tthis.info.getReadLock();\n\t\t\t\tspin = info.get(\"STOPPING\").equals(Boolean.FALSE);\n\t\t\t\tthis.database.releaseReadLock();\n\t\t\t\tthis.info.releaseReadLock();\n\t\t\t}\n\n\t\t\tthis.database.getWriteLock();\n\t\t\tthis.info.getWriteLock();\n\t\t\tinfo.add(\"RUNNING\", Boolean.FALSE);\n\t\t\tthis.info.releaseWriteLock();\n\t\t\tthis.database.releaseWriteLock();\n\n\t\t\t// wait for child threads and thread groups to die\n\t\t\twhile(tg.activeCount() + tg.activeGroupCount() != 0) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t\t} catch(InterruptedException ex) {\n\t\t\t\t\t// nop\n\t\t\t\t}\n\t\t\t}\n\t\t\ttg.destroy();\n\t\t\t// Zap reference to the ThreadGroup so the JVM can GC it.\n\t\t\ttg = null;\n\t\t} catch(Exception e) {\n\t\t}\n\n\t\tsocketManager.destroySocketManager();\n\t\t// zero out everything, just incase.\n\t\tthis.database.getWriteLock();\n\t\tthis.info.getWriteLock();\n\t\tinfo.add(\"STARTING\", Boolean.FALSE);\n\t\tinfo.add(\"STOPPING\", Boolean.FALSE);\n\t\tinfo.add(\"RUNNING\", Boolean.FALSE);\n\t\tthis.info.releaseWriteLock();\n\t\tthis.database.releaseWriteLock();\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Copy from source to destination...\n\t * and yes, we are totally OK to block here on writes,\n\t * The OS has buffers, and I intend to use them.\n\t * \n\t */\n\tpublic void run() {\n\t\tint b;\n\t\tbyte a[] = new byte[1];\n\t\ttry {\n\t\t\twhile(info.get(\"RUNNING\").equals(Boolean.TRUE)) {\n\t\t\t\tb = Ain.read(a, 0, 1);\n\t\t\t\t// System.out.println(info.get(\"NICKNAME\").toString() + \" \" + b);\n\t\t\t\tif(b > 0) {\n\t\t\t\t\tAout.write(a,0,1);\n\t\t\t\t\t// Aout.flush(); too slow!\n\t\t\t\t} else if(b == 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Thread.yield();\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch(InterruptedException ex) {\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* according to the specs:\n\t\t\t\t\t * \n\t\t\t\t\t * The total number of bytes read into the buffer, \n\t\t\t\t\t * or -1 if there is no more data because the end of \n\t\t\t\t\t * the stream has been reached.\n\t\t\t\t\t * \n\t\t\t\t\t */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(IOException e) {\n\t\t}\n\t}","id":88926,"modified_method":"/**\n\t * Copy from source to destination...\n\t * and yes, we are totally OK to block here on writes,\n\t * The OS has buffers, and I intend to use them.\n\t * \n\t */\n\tpublic void run() {\n\t\tint b;\n\t\tbyte a[] = new byte[1];\n\t\tboolean spin = true;\n\t\ttry {\n\t\t\twhile(spin) {\n\t\t\t\tdatabase.getReadLock();\n\t\t\t\tinfo.getReadLock();\n\t\t\t\tspin = info.get(\"RUNNING\").equals(Boolean.TRUE);\n\t\t\t\tinfo.releaseReadLock();\n\t\t\t\tdatabase.releaseReadLock();\n\n\t\t\t\tb = Ain.read(a, 0, 1);\n\t\t\t\t// System.out.println(info.get(\"NICKNAME\").toString() + \" \" + b);\n\t\t\t\tif(b > 0) {\n\t\t\t\t\tAout.write(a, 0, 1);\n\t\t\t\t// Aout.flush(); too slow!\n\t\t\t\t} else if(b == 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Thread.yield();\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch(InterruptedException ex) {\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* according to the specs:\n\t\t\t\t\t * \n\t\t\t\t\t * The total number of bytes read into the buffer, \n\t\t\t\t\t * or -1 if there is no more data because the end of \n\t\t\t\t\t * the stream has been reached.\n\t\t\t\t\t * \n\t\t\t\t\t */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t}\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param Ain\n\t * @param Aout\n\t * @param db\n\t */\n\tTCPio(InputStream Ain, OutputStream Aout, nickname db) {\n\t\tthis.Ain = Ain;\n\t\tthis.Aout = Aout;\n\t\tthis.info = db;\n\t}","id":88927,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param Ain\n\t * @param Aout\n\t * @param info\n\t * @param database\n\t */\n\tTCPio(InputStream Ain, OutputStream Aout, nickname info, nickname database) {\n\t\tthis.Ain = Ain;\n\t\tthis.Aout = Aout;\n\t\tthis.info = info;\n\t\tthis.database = database;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Constructor\n\t * @param S\n\t * @param info\n\t * @param _log\n\t */\n\tTCPlistener(I2PSocketManager S, nickname info, Log _log) {\n\t\tthis.info = info;\n\t\tthis._log = _log;\n\t\tthis.socketManager = S;\n\t\ttgwatch = 1;\n\t}","id":88928,"modified_method":"/**\n\t * Constructor\n\t * @param S\n\t * @param info\n\t * @param database\n\t * @param _log\n\t */\n\tTCPlistener(I2PSocketManager S, nickname info, nickname database, Log _log) {\n\t\tthis.database = database;\n\t\tthis.info = info;\n\t\tthis._log = _log;\n\t\tthis.socketManager = S;\n\t\ttgwatch = 1;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Simply listen on TCP port, and thread connections\n\t * @throws java.lang.RuntimeException\n\t */\n\tpublic void run() throws RuntimeException {\n\t\tboolean g = false;\n\t\tif(info.exists(\"OUTPORT\")) {\n\t\t\ttgwatch = 2;\n\t\t}\n\t\ttry {\n//\t\t\tSystem.out.println(\"Starting thread count \" + Thread.activeCount());\n\t\t\tServerSocket listener = new ServerSocket(Integer.parseInt(info.get(\"INPORT\").toString()), backlog, InetAddress.getByName(info.get(\"INHOST\").toString()));\n\t\t\tSocket server = new Socket();\n\t\t\tlistener.setSoTimeout(1000);\n\t\t\twhile(info.get(\"RUNNING\").equals(Boolean.TRUE)) {\n//\t\t\t\tSystem.out.println(\"Thread count \" + Thread.activeCount());\n\t\t\t\ttry {\n\t\t\t\t\tserver = listener.accept();\n\t\t\t\t\tg = true;\n\t\t\t\t} catch(SocketTimeoutException ste) {\n\t\t\t\t\tg = false;\n\t\t\t\t}\n\t\t\t\tif(g) {\n\t\t\t\t\t// toss the connection to a new thread.\n\t\t\t\t\tTCPtoI2P conn_c = new TCPtoI2P(socketManager, server, info);\n\t\t\t\t\tThread t = new Thread(conn_c, \"BOBTCPtoI2P\");\n\t\t\t\t\tt.start();\n\t\t\t\t\tg = false;\n\t\t\t\t} \n\t\t\t}\n\t\t\tlistener.close();\n\t\t} catch(IOException ioe) {\n\t\t\t// throw new RuntimeException(ioe);\n\t\t}\n\n//System.out.println(\"STOP!\");\n\n\t\twhile(Thread.activeCount() > tgwatch) { // wait for all threads in our threadgroup to finish\n//\t\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t} catch(Exception e) {\n\t\t\t\t// nop\n\t\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t// need to kill off the socket manager too.\n\t\tI2PSession session = socketManager.getSession();\n\t\tif(session != null) {\n\t\t\ttry {\n\t\t\t\tsession.destroySession();\n\t\t\t} catch(I2PSessionException ex) {\n\t\t\t\t// nop\n\t\t\t}\n//\t\t\tSystem.out.println(\"destroySession Thread count \" + Thread.activeCount());\n\t\t}\n\t}","id":88929,"modified_method":"/**\n\t * Simply listen on TCP port, and thread connections\n\t * @throws java.lang.RuntimeException\n\t */\n\tpublic void run() throws RuntimeException {\n\t\tboolean g = false;\n\t\t\t\tdatabase.getReadLock();\n\t\tinfo.getReadLock();\n\t\tif(info.exists(\"OUTPORT\")) {\n\t\t\ttgwatch = 2;\n\t\t}\n\t\ttry {\n//\t\t\tSystem.out.println(\"Starting thread count \" + Thread.activeCount());\n\t\t\tServerSocket listener = new ServerSocket(Integer.parseInt(info.get(\"INPORT\").toString()), backlog, InetAddress.getByName(info.get(\"INHOST\").toString()));\n\t\t\tSocket server = new Socket();\n\t\t\tlistener.setSoTimeout(1000);\n\t\tinfo.releaseReadLock();\n\t\tdatabase.releaseReadLock();\n\t\tboolean spin = true;\n\t\twhile(spin) {\n\t\t\tdatabase.getReadLock();\n\t\t\tinfo.getReadLock();\n\t\t\tspin = info.get(\"RUNNING\").equals(Boolean.TRUE);\n\t\t\tinfo.releaseReadLock();\n\t\t\tdatabase.releaseReadLock();\n//\t\t\t\tSystem.out.println(\"Thread count \" + Thread.activeCount());\n\t\t\t\ttry {\n\t\t\t\t\tserver = listener.accept();\n\t\t\t\t\tg = true;\n\t\t\t\t} catch(SocketTimeoutException ste) {\n\t\t\t\t\tg = false;\n\t\t\t\t}\n\t\t\t\tif(g) {\n\t\t\t\t\t// toss the connection to a new thread.\n\t\t\t\t\tTCPtoI2P conn_c = new TCPtoI2P(socketManager, server, info, database);\n\t\t\t\t\tThread t = new Thread(conn_c, \"BOBTCPtoI2P\");\n\t\t\t\t\tt.start();\n\t\t\t\t\tg = false;\n\t\t\t\t} \n\t\t\t}\n\t\t\tlistener.close();\n\t\t} catch(IOException ioe) {\n\t\t\t// throw new RuntimeException(ioe);\n\t\t}\n\n//System.out.println(\"STOP!\");\n\n\t\twhile(Thread.activeCount() > tgwatch) { // wait for all threads in our threadgroup to finish\n//\t\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000); //sleep for 1000 ms (One second)\n\t\t\t} catch(Exception e) {\n\t\t\t\t// nop\n\t\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"STOP Thread count \" + Thread.activeCount());\n\t\t// need to kill off the socket manager too.\n\t\tI2PSession session = socketManager.getSession();\n\t\tif(session != null) {\n\t\t\ttry {\n\t\t\t\tsession.destroySession();\n\t\t\t} catch(I2PSessionException ex) {\n\t\t\t\t// nop\n\t\t\t}\n//\t\t\tSystem.out.println(\"destroySession Thread count \" + Thread.activeCount());\n\t\t}\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * TCP stream to I2P stream thread starter\n\t */\n\tpublic void run() {\n\t\tString line, input;\n\n\t\ttry {\n\n\t\t\tInputStream in = sock.getInputStream();\n\t\t\tOutputStream out = sock.getOutputStream();\n\t\t\ttry {\n\t\t\t\tline = Lread(in);\n\t\t\t\tinput = line.toLowerCase();\n\t\t\t\tDestination dest = null;\n\n\t\t\t\tif(input.endsWith(\".i2p\")) {\n\t\t\t\t\tdest = I2PTunnel.destFromName(input);\n\t\t\t\t\tline = dest.toBase64();\n\t\t\t\t}\n\t\t\t\tdest = new Destination();\n\t\t\t\tdest.fromBase64(line);\n\n\t\t\t\ttry {\n\t\t\t\t\t// get a client socket\n\t\t\t\t\tI2P = socketManager.connect(dest);\n\t\t\t\t\tI2P.setReadTimeout(0); // temp bugfix, this *SHOULD* be the default\n\t\t\t\t\t// make readers/writers\n\t\t\t\t\tInputStream Iin = I2P.getInputStream();\n\t\t\t\t\tOutputStream Iout = I2P.getOutputStream();\n\t\t\t\t\t// setup to cross the streams\n\t\t\t\t\tTCPio conn_c = new TCPio(in, Iout, info); // app -> I2P\n\t\t\t\t\tTCPio conn_a = new TCPio(Iin, out, info); // I2P -> app\n\t\t\t\t\tThread t = new Thread(conn_c, \"TCPioA\");\n\t\t\t\t\tThread q = new Thread(conn_a, \"TCPioB\");\n\t\t\t\t\t// Fire!\n\t\t\t\t\tt.start();\n\t\t\t\t\tq.start();\n\t\t\t\t\twhile(t.isAlive() && q.isAlive()) { // AND is used here to kill off the other thread\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10); //sleep for 10 ms\n\t\t\t\t\t\t} catch(InterruptedException e) {\n\t\t\t\t\t\t\t// nop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} catch(I2PException e) {\t\t\t\t\t\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t} catch(ConnectException e) {\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t} catch(NoRouteToHostException e) {\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t} catch(InterruptedIOException e) {\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t}\n\n\t\t\t} catch(Exception e) {\n\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t}\n\t\t} catch(IOException ioe) {\n\t\t}\n\t\ttry {\n\t\t\tI2P.close();\n\t\t} catch(Exception e) {\n\t\t}\n\n\t\ttry {\n\t\t\tsock.close();\n\t\t} catch(Exception e) {\n\t\t}\n\t}","id":88930,"modified_method":"/**\n\t * TCP stream to I2P stream thread starter\n\t */\n\tpublic void run() {\n\t\tString line, input;\n\n\t\ttry {\n\n\t\t\tInputStream in = sock.getInputStream();\n\t\t\tOutputStream out = sock.getOutputStream();\n\t\t\ttry {\n\t\t\t\tline = Lread(in);\n\t\t\t\tinput = line.toLowerCase();\n\t\t\t\tDestination dest = null;\n\n\t\t\t\tif(input.endsWith(\".i2p\")) {\n\t\t\t\t\tdest = I2PTunnel.destFromName(input);\n\t\t\t\t\tline = dest.toBase64();\n\t\t\t\t}\n\t\t\t\tdest = new Destination();\n\t\t\t\tdest.fromBase64(line);\n\n\t\t\t\ttry {\n\t\t\t\t\t// get a client socket\n\t\t\t\t\tI2P = socketManager.connect(dest);\n\t\t\t\t\tI2P.setReadTimeout(0); // temp bugfix, this *SHOULD* be the default\n\t\t\t\t\t// make readers/writers\n\t\t\t\t\tInputStream Iin = I2P.getInputStream();\n\t\t\t\t\tOutputStream Iout = I2P.getOutputStream();\n\t\t\t\t\t// setup to cross the streams\n\t\t\t\t\tTCPio conn_c = new TCPio(in, Iout, info, database); // app -> I2P\n\t\t\t\t\tTCPio conn_a = new TCPio(Iin, out, info, database); // I2P -> app\n\t\t\t\t\tThread t = new Thread(conn_c, \"TCPioA\");\n\t\t\t\t\tThread q = new Thread(conn_a, \"TCPioB\");\n\t\t\t\t\t// Fire!\n\t\t\t\t\tt.start();\n\t\t\t\t\tq.start();\n\t\t\t\t\twhile(t.isAlive() && q.isAlive()) { // AND is used here to kill off the other thread\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(10); //sleep for 10 ms\n\t\t\t\t\t\t} catch(InterruptedException e) {\n\t\t\t\t\t\t\t// nop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} catch(I2PException e) {\t\t\t\t\t\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t} catch(ConnectException e) {\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t} catch(NoRouteToHostException e) {\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t} catch(InterruptedIOException e) {\n\t\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t\t}\n\n\t\t\t} catch(Exception e) {\n\t\t\t\tEmsg(\"ERROR \" + e.toString(), out);\n\t\t\t}\n\t\t} catch(IOException ioe) {\n\t\t}\n\t\ttry {\n\t\t\tI2P.close();\n\t\t} catch(Exception e) {\n\t\t}\n\n\t\ttry {\n\t\t\tsock.close();\n\t\t} catch(Exception e) {\n\t\t}\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Constructor\n\t * @param i2p\n\t * @param socket\n\t * @param db\n\t */\n\tTCPtoI2P(I2PSocketManager i2p, Socket socket, nickname db) {\n\t\tthis.sock = socket;\n\t\tthis.info = db;\n\t\tthis.socketManager = i2p;\n\t}","id":88931,"modified_method":"/**\n\t * Constructor\n\t * @param i2p\n\t * @param socket\n\t * @param info\n\t * @param database \n\t */\n\tTCPtoI2P(I2PSocketManager i2p, Socket socket, nickname info, nickname database) {\n\t\tthis.sock = socket;\n\t\tthis.info = info;\n\t\tthis.database = database;\n\t\tthis.socketManager = i2p;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Is this nickname's tunnel active?\n\t *\n\t * @param Arg\n\t * @return true if the tunnel is active\n\t */\n\tpublic boolean tunnelactive(nickname Arg) {\n\t\treturn (Arg.get(P_STARTING).equals(Boolean.TRUE) ||\n\t\t\tArg.get(P_STOPPING).equals(Boolean.TRUE) ||\n\t\t\tArg.get(P_RUNNING).equals(Boolean.TRUE));\n\n\t}","id":88932,"modified_method":"/**\n\t * Is this nickname's tunnel active?\n\t *\n\t * @param Arg\n\t * @return true if the tunnel is active\n\t */\n\tpublic boolean tunnelactive(nickname Arg) {\n\t\trlock(Arg);\n\t\tboolean retval = (Arg.get(P_STARTING).equals(Boolean.TRUE) ||\n\t\t\tArg.get(P_STOPPING).equals(Boolean.TRUE) ||\n\t\t\tArg.get(P_RUNNING).equals(Boolean.TRUE));\n\t\trunlock(Arg);\n\t\treturn retval;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Try to print info from the database\n\t *\n\t * @param out\n\t * @param info\n\t * @param key\n\t */\n\tpublic void trypnt(PrintStream out, nickname info, Object key) {\n\t\tout.print(\" \" + key + \": \");\n\t\tif(info.exists(key)) {\n\t\t\tout.print(info.get(key));\n\t\t} else {\n\t\t\tout.print(\"not_set\");\n\t\t}\n\t}","id":88933,"modified_method":"/**\n\t * Try to print info from the database\n\t *\n\t * @param out\n\t * @param info\n\t * @param key\n\t */\n\tpublic void trypnt(PrintStream out, nickname info, Object key) {\n\t\trlock(info);\n\t\ttry {\n\t\t\tout.print(\" \" + key + \": \");\n\t\t\tif(info.exists(key)) {\n\t\t\t\tout.print(info.get(key));\n\t\t\t} else {\n\t\t\t\tout.print(\"not_set\");\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t}\n\t\trunlock(info);\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Dump various information from the database\n\t *\n\t * @param out\n\t * @param info\n\t */\n\tpublic void nickprint(PrintStream out, nickname info) {\n\t\ttrypnt(out, info, P_NICKNAME);\n\t\ttrypnt(out, info, P_STARTING);\n\t\ttrypnt(out, info, P_RUNNING);\n\t\ttrypnt(out, info, P_STOPPING);\n\t\ttfpnt(out, info, P_KEYS);\n\t\ttrypnt(out, info, P_QUIET);\n\t\ttrypnt(out, info, P_INPORT);\n\t\ttrypnt(out, info, P_INHOST);\n\t\ttrypnt(out, info, P_OUTPORT);\n\t\ttrypnt(out, info, P_OUTHOST);\n\t\tout.println();\n\n\t}","id":88934,"modified_method":"/**\n\t * Dump various information from the database\n\t *\n\t * @param out\n\t * @param info\n\t */\n\tpublic void nickprint(PrintStream out, nickname info) {\n\t\trlock(info);\n\t\ttrypnt(out, info, P_NICKNAME);\n\t\ttrypnt(out, info, P_STARTING);\n\t\ttrypnt(out, info, P_RUNNING);\n\t\ttrypnt(out, info, P_STOPPING);\n\t\ttfpnt(out, info, P_KEYS);\n\t\ttrypnt(out, info, P_QUIET);\n\t\ttrypnt(out, info, P_INPORT);\n\t\ttrypnt(out, info, P_INHOST);\n\t\ttrypnt(out, info, P_OUTPORT);\n\t\ttrypnt(out, info, P_OUTHOST);\n\t\ttry {\n\t\t\tout.println();\n\t\t} catch(Exception e) {\n\t\t}\n\t\trunlock(info);\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Print true or false if an object exists\n\t *\n\t * @param out\n\t * @param info\n\t * @param key\n\t */\n\tpublic void tfpnt(PrintStream out, nickname info, Object key) {\n\t\tout.print(\" \" + key + \": \");\n\t\tout.print(info.exists(key));\n\t}","id":88935,"modified_method":"/**\n\t * Print true or false if an object exists\n\t *\n\t * @param out\n\t * @param info\n\t * @param key\n\t */\n\tpublic void tfpnt(PrintStream out, nickname info, Object key) {\n\t\trlock(info);\n\t\ttry {\n\t\t\tout.print(\" \" + key + \": \");\n\t\t\tout.print(info.exists(key));\n\t\t} catch(Exception e) {\n\t\t}\n\t\trunlock(info);\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * The actual parser.\n\t * It probabbly needs a rewrite into functions, but I kind-of like inline code.\n\t *\n\t */\n\tpublic void run() {\n\t\tdk = ns = ip = op = false;\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server.getInputStream()));\n\t\t\tPrintStream out = new PrintStream(server.getOutputStream());\n\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\tout.println(\"BOB \" + BOBversion);\n\t\t\tout.println(\"OK\");\n\t\t\twhile((line = in.readLine()) != null) {\n\t\t\t\tSystem.gc(); // yes, this does make a huge difference...\n\t\t\t\tStringTokenizer token = new StringTokenizer(line, \" \"); // use a space as a delimiter\n\t\t\t\tString Command = \"\";\n\t\t\t\tString Arg = \"\";\n\t\t\t\tnickname info;\n\n\t\t\t\tif(token.countTokens() != 0) {\n\t\t\t\t\tCommand = token.nextToken();\n\t\t\t\t\tCommand = Command.toLowerCase();\n\t\t\t\t\tif(token.countTokens() != 0) {\n\t\t\t\t\t\tArg = token.nextToken();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tArg = \"\";\n\t\t\t\t\t}\n\t\t\t\t\t// The rest of the tokens are considered junk,\n\t\t\t\t\t// and discarded without any warnings.\n\n\t\t\t\t\tif(Command.equals(C_help)) {\n\t\t\t\t\t\tfor(int i = 0; !C_ALL[i][0].equals(\" \"); i++) {\n\t\t\t\t\t\t\tif(C_ALL[i][0].equalsIgnoreCase(Arg)) {\n\t\t\t\t\t\t\t\tout.println(\"OK \" + C_ALL[i][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_getdest)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(dk) {\n\t\t\t\t\t\t\t\tout.println(\"OK \" + nickinfo.get(P_DEST));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tout.println(\"ERROR keys not set.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_list)) {\n\t\t\t\t\t\t// Produce a formatted list of all nicknames\n\t\t\t\t\t\tfor(int i = 0; i < database.getcount(); i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tinfo = (nickname)database.getnext(i);\n\t\t\t\t\t\t\t} catch(RuntimeException b) {\n\t\t\t\t\t\t\t\tbreak; // something bad happened.\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tout.print(\"DATA\");\n\t\t\t\t\t\t\tnickprint(out, info);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.println(\"OK Listing done\");\n\t\t\t\t\t} else if(Command.equals(C_quit)) {\n\t\t\t\t\t\t// End the command session\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if(Command.equals(C_newkeys)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t// Make a new PublicKey and PrivateKey\n\t\t\t\t\t\t\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\t\t\t\t\t\t\td = I2PClientFactory.createClient().createDestination(prikey);\n\t\t\t\t\t\t\t\t\tdk = true;\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_KEYS, prikey.toByteArray());\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_DEST, d.toBase64());\n\t\t\t\t\t\t\t\t\t// System.out.println(prikey.toByteArray().length);\n\t\t\t\t\t\t\t\t\tout.println(\"OK \" + nickinfo.get(P_DEST));\n\t\t\t\t\t\t\t\t} catch(IOException ioe) {\n\t\t\t\t\t\t\t\t\tBOB.error(\"Error generating keys\" + ioe);\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR generating keys\");\n\t\t\t\t\t\t\t\t} catch(I2PException ipe) {\n\t\t\t\t\t\t\t\t\tBOB.error(\"Error generating keys\" + ipe);\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR generating keys\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_getkeys)) {\n\t\t\t\t\t\t// Return public key\n\t\t\t\t\t\tif(dk) {\n\t\t\t\t\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\t\t\t\t\tprikey.write(((byte[])nickinfo.get(P_KEYS)));\n\t\t\t\t\t\t\tout.println(\"OK \" + net.i2p.data.Base64.encode(prikey.toByteArray()));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout.println(\"ERROR no public key has been set\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_quiet)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnickinfo.add(P_QUIET, new Boolean(Boolean.parseBoolean(Arg) == true));\n\t\t\t\t\t\t\t\tout.println(\"OK Quiet set\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_setkeys)) {\n\t\t\t\t\t\t// Set the nickname to a privatekey in BASE64 format\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\t\t\t\t\t\t\tprikey.write(net.i2p.data.Base64.decode(Arg));\n\t\t\t\t\t\t\t\t\td.fromBase64(Arg);\n\t\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\t\tArg = \"\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((Arg.length() == 884) && is64ok(Arg)) {\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_KEYS, prikey.toByteArray());\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_DEST, d.toBase64());\n\t\t\t\t\t\t\t\t\tout.println(\"OK \" + nickinfo.get(P_DEST));\n\t\t\t\t\t\t\t\t\tdk = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR not in BASE64 format\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_setnick)) {\n\t\t\t\t\t\tns = dk = ip = op = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnickinfo = (nickname)database.get(Arg);\n\t\t\t\t\t\t\tif(!tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tnickinfo = null;\n\t\t\t\t\t\t\t\tns = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(RuntimeException b) {\n\t\t\t\t\t\t\tnickinfo = null;\n\t\t\t\t\t\t\tns = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Clears and Sets the initial nickname structure to work with\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tnickinfo = new nickname();\n\t\t\t\t\t\t\tdatabase.add(Arg, nickinfo);\n\t\t\t\t\t\t\tnickinfo.add(P_NICKNAME, Arg);\n\t\t\t\t\t\t\tnickinfo.add(P_STARTING, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_RUNNING, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_STOPPING, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_QUIET, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_INHOST, \"localhost\");\n\t\t\t\t\t\t\tnickinfo.add(P_OUTHOST, \"localhost\");\n\t\t\t\t\t\t\tProperties Q = props;\n\t\t\t\t\t\t\tQ.setProperty(\"inbound.nickname\", (String)nickinfo.get(P_NICKNAME));\n\t\t\t\t\t\t\tQ.setProperty(\"outbound.nickname\", (String)nickinfo.get(P_NICKNAME));\n\t\t\t\t\t\t\tnickinfo.add(P_PROPERTIES, Q);\n\t\t\t\t\t\t\tout.println(\"OK Nickname set to \" + Arg);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_option)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tStringTokenizer otoken = new StringTokenizer(Arg, \"=\"); // use a space as a delimiter\n\t\t\t\t\t\t\t\tif(otoken.countTokens() != 2) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR to many or no options.\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString pname = otoken.nextToken();\n\t\t\t\t\t\t\t\t\tString pval = otoken.nextToken();\n\t\t\t\t\t\t\t\t\tProperties Q = (Properties)nickinfo.get(P_PROPERTIES);\n\t\t\t\t\t\t\t\t\tQ.setProperty(pname, pval);\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_PROPERTIES, Q);\n\t\t\t\t\t\t\t\t\tout.println(\"OK \" + pname + \" set to \" + pval);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_getnick)) {\n\t\t\t\t\t\t// Get the nickname to work with...\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnickinfo = (nickname)database.get(Arg);\n\t\t\t\t\t\t\tns = true;\n\t\t\t\t\t\t} catch(RuntimeException b) {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tdk = nickinfo.exists(P_KEYS);\n\t\t\t\t\t\t\tip = nickinfo.exists(P_INPORT);\n\t\t\t\t\t\t\top = nickinfo.exists(P_OUTPORT);\n\t\t\t\t\t\t\t// Finally say OK.\n\t\t\t\t\t\t\tout.println(\"OK Nickname set to \" + Arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_inport)) {\n\t\t\t\t\t\t// Set the nickname inbound TO the router port\n\t\t\t\t\t\t// app --> BOB\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tint prt;\n\t\t\t\t\t\t\t\tnickinfo.kill(P_INPORT);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprt = Integer.parseInt(Arg);\n\t\t\t\t\t\t\t\t\tif(prt > 1 && prt < 65536) {\n\t\t\t\t\t\t\t\t\t\tnickinfo.add(P_INPORT, new Integer(prt));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR not a number\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tip = nickinfo.exists(P_INPORT);\n\t\t\t\t\t\t\t\tif(ip) {\n\t\t\t\t\t\t\t\t\tout.println(\"OK inbound port set\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR port out of range\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_outport)) {\n\t\t\t\t\t\t// Set the nickname outbound FROM the router port\n\t\t\t\t\t\t// BOB --> app\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tint prt;\n\t\t\t\t\t\t\t\tnickinfo.kill(P_OUTPORT);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprt = Integer.parseInt(Arg);\n\t\t\t\t\t\t\t\t\tif(prt > 1 && prt < 65536) {\n\t\t\t\t\t\t\t\t\t\tnickinfo.add(P_OUTPORT, new Integer(prt));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR not a number\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tip = nickinfo.exists(P_OUTPORT);\n\t\t\t\t\t\t\t\tif(ip) {\n\t\t\t\t\t\t\t\t\tout.println(\"OK outbound port set\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR port out of range\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_inhost)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnickinfo.add(P_INHOST, Arg);\n\t\t\t\t\t\t\t\tout.println(\"OK inhost set\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_outhost)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnickinfo.add(P_OUTHOST, Arg);\n\t\t\t\t\t\t\t\tout.println(\"OK outhost set\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_show)) {\n\t\t\t\t\t\t// Get the current nickname properties\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tout.print(\"OK\");\n\t\t\t\t\t\t\tnickprint(out, nickinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_start)) {\n\t\t\t\t\t\t// Start the tunnel, if we have all the information\n\t\t\t\t\t\tif(ns && dk && (ip || op)) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tMUXlisten tunnel;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttunnel = new MUXlisten(nickinfo, _log);\n\t\t\t\t\t\t\t\t\tThread t = new Thread(tunnel);\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_STARTING, Boolean.TRUE);\n\t\t\t\t\t\t\t\t\tt.start();\n\t\t\t\t\t\t\t\t\tout.println(\"OK tunnel starting\");\n\t\t\t\t\t\t\t\t} catch(I2PException e) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR starting tunnel: \" + e);\n\t\t\t\t\t\t\t\t} catch(IOException e) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR starting tunnel: \" + e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout.println(\"ERROR tunnel settings incomplete\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_stop)) {\n\t\t\t\t\t\t// Stop the tunnel, if it is running\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(nickinfo.get(P_RUNNING).equals(Boolean.TRUE) && nickinfo.get(P_STOPPING).equals(Boolean.FALSE)) {\n\t\t\t\t\t\t\t\tnickinfo.add(P_STOPPING, Boolean.TRUE);\n\t\t\t\t\t\t\t\tout.println(\"OK tunnel stopping\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is inactive\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_clear)) {\n\t\t\t\t\t\t// Clear use of the nickname if stopped\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdatabase.kill(nickinfo.get(P_NICKNAME));\n\t\t\t\t\t\t\t\tdk = ns = ip = op = false;\n\t\t\t\t\t\t\t\tout.println(\"OK cleared\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_status)) {\n\t\t\t\t\t\tif(database.exists(Arg)) {\n\t\t\t\t\t\t\t// Show status of a nickname\n\t\t\t\t\t\t\tout.print(\"OK \");\n\t\t\t\t\t\t\tttlpnt(out, database, Arg);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(\"ERROR UNKNOWN COMMAND! Try help\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Say goodbye.\n\n\t\t\tout.println(\"OK Bye!\");\n\n\t\t\tserver.close();\n\t\t} catch(IOException ioe) {\n\t\t\tBOB.warn(\"IOException on socket listen: \" + ioe);\n\t\t\tioe.printStackTrace();\n\t\t}\n\t}","id":88936,"modified_method":"/**\n\t * The actual parser.\n\t * It probabbly needs a rewrite into functions, but I kind-of like inline code.\n\t *\n\t */\n\tpublic void run() {\n\t\tdk = ns = ip = op = false;\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server.getInputStream()));\n\t\t\tPrintStream out = new PrintStream(server.getOutputStream());\n\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\tout.println(\"BOB \" + BOBversion);\n\t\t\tout.println(\"OK\");\n\t\t\twhile((line = in.readLine()) != null) {\n\t\t\t\tStringTokenizer token = new StringTokenizer(line, \" \"); // use a space as a delimiter\n\t\t\t\tString Command = \"\";\n\t\t\t\tString Arg = \"\";\n\t\t\t\tnickname info;\n\n\t\t\t\tif(token.countTokens() != 0) {\n\t\t\t\t\tCommand = token.nextToken();\n\t\t\t\t\tCommand = Command.toLowerCase();\n\t\t\t\t\tif(token.countTokens() != 0) {\n\t\t\t\t\t\tArg = token.nextToken();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tArg = \"\";\n\t\t\t\t\t}\n\t\t\t\t\t// The rest of the tokens are considered junk,\n\t\t\t\t\t// and discarded without any warnings.\n\n\t\t\t\t\tif(Command.equals(C_help)) {\n\t\t\t\t\t\tfor(int i = 0; !C_ALL[i][0].equals(\" \"); i++) {\n\t\t\t\t\t\t\tif(C_ALL[i][0].equalsIgnoreCase(Arg)) {\n\t\t\t\t\t\t\t\tout.println(\"OK \" + C_ALL[i][1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_getdest)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(dk) {\n\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tout.println(\"OK \" + nickinfo.get(P_DEST));\n\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tout.println(\"ERROR keys not set.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_list)) {\n\t\t\t\t\t\t// Produce a formatted list of all nicknames\n\t\t\t\t\t\tdatabase.getReadLock();\n\t\t\t\t\t\tfor(int i = 0; i < database.getcount(); i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tinfo = (nickname)database.getnext(i);\n\t\t\t\t\t\t\t} catch(Exception b) {\n\t\t\t\t\t\t\t\tbreak; // something bad happened.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t\tout.print(\"DATA\");\n\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinfo.getReadLock();\n\t\t\t\t\t\t\tnickprint(out, info);\n\t\t\t\t\t\t\tinfo.releaseReadLock();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdatabase.releaseReadLock();\n\t\t\t\t\t\tout.println(\"OK Listing done\");\n\t\t\t\t\t} else if(Command.equals(C_quit)) {\n\t\t\t\t\t\t// End the command session\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if(Command.equals(C_newkeys)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t// Make a new PublicKey and PrivateKey\n\t\t\t\t\t\t\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\t\t\t\t\t\t\td = I2PClientFactory.createClient().createDestination(prikey);\n\t\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_KEYS, prikey.toByteArray());\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_DEST, d.toBase64());\n\t\t\t\t\t\t\t\t\tdk = true;\n\t\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tout.println(\"OK \" + nickinfo.get(P_DEST));\n\t\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\t} catch(IOException ioe) {\n\t\t\t\t\t\t\t\t\tBOB.error(\"Error generating keys\" + ioe);\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR generating keys\");\n\t\t\t\t\t\t\t\t} catch(I2PException ipe) {\n\t\t\t\t\t\t\t\t\tBOB.error(\"Error generating keys\" + ipe);\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR generating keys\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_getkeys)) {\n\t\t\t\t\t\t// Return public key\n\t\t\t\t\t\tif(dk) {\n\t\t\t\t\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\tprikey.write(((byte[])nickinfo.get(P_KEYS)));\n\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\tout.println(\"OK \" + net.i2p.data.Base64.encode(prikey.toByteArray()));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout.println(\"ERROR no public key has been set\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_quiet)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\tnickinfo.add(P_QUIET, new Boolean(Boolean.parseBoolean(Arg) == true));\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tout.println(\"OK Quiet set\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_setkeys)) {\n\t\t\t\t\t\t// Set the nickname to a privatekey in BASE64 format\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprikey = new ByteArrayOutputStream();\n\t\t\t\t\t\t\t\t\tprikey.write(net.i2p.data.Base64.decode(Arg));\n\t\t\t\t\t\t\t\t\td.fromBase64(Arg);\n\t\t\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\t\t\tArg = \"\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif((Arg.length() == 884) && is64ok(Arg)) {\n\t\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_KEYS, prikey.toByteArray());\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_DEST, d.toBase64());\n\t\t\t\t\t\t\t\t\tdk = true;\n\t\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tout.println(\"OK \" + nickinfo.get(P_DEST));\n\t\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR not in BASE64 format\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_setnick)) {\n\t\t\t\t\t\tns = dk = ip = op = false;\n\t\t\t\t\t\tdatabase.getReadLock();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnickinfo = (nickname)database.get(Arg);\n\t\t\t\t\t\t\tif(!tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tnickinfo = null;\n\t\t\t\t\t\t\t\tns = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(Exception b) {\n\t\t\t\t\t\t\tnickinfo = null;\n\t\t\t\t\t\t\tns = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdatabase.releaseReadLock();\n\t\t\t\t\t\t// Clears and Sets the initial nickname structure to work with\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tnickinfo = new nickname();\n\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\tdatabase.add(Arg, nickinfo);\n\t\t\t\t\t\t\tnickinfo.add(P_NICKNAME, Arg);\n\t\t\t\t\t\t\tnickinfo.add(P_STARTING, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_RUNNING, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_STOPPING, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_QUIET, Boolean.FALSE);\n\t\t\t\t\t\t\tnickinfo.add(P_INHOST, \"localhost\");\n\t\t\t\t\t\t\tnickinfo.add(P_OUTHOST, \"localhost\");\n\t\t\t\t\t\t\tProperties Q = new Properties(props);\n\t\t\t\t\t\t\tQ.setProperty(\"inbound.nickname\", Arg);\n\t\t\t\t\t\t\tQ.setProperty(\"outbound.nickname\", Arg);\n\t\t\t\t\t\t\tnickinfo.add(P_PROPERTIES, Q);\n\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\tout.println(\"OK Nickname set to \" + Arg);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_option)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tStringTokenizer otoken = new StringTokenizer(Arg, \"=\"); // use a space as a delimiter\n\t\t\t\t\t\t\t\tif(otoken.countTokens() != 2) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR to many or no options.\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString pname = otoken.nextToken();\n\t\t\t\t\t\t\t\t\tString pval = otoken.nextToken();\n\t\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\t\tProperties Q = (Properties)nickinfo.get(P_PROPERTIES);\n\t\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\t\tQ.setProperty(pname, pval);\n\t\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\t\tnickinfo.add(P_PROPERTIES, Q);\n\t\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\t\tout.println(\"OK \" + pname + \" set to \" + pval);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_getnick)) {\n\t\t\t\t\t\t// Get the nickname to work with...\n\t\t\t\t\t\tdatabase.getReadLock();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnickinfo = (nickname)database.get(Arg);\n\t\t\t\t\t\t\tns = true;\n\t\t\t\t\t\t} catch(RuntimeException b) {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdatabase.releaseReadLock();\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\tdk = nickinfo.exists(P_KEYS);\n\t\t\t\t\t\t\tip = nickinfo.exists(P_INPORT);\n\t\t\t\t\t\t\top = nickinfo.exists(P_OUTPORT);\n\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t// Finally say OK.\n\t\t\t\t\t\t\tout.println(\"OK Nickname set to \" + Arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_inport)) {\n\t\t\t\t\t\t// Set the nickname inbound TO the router port\n\t\t\t\t\t\t// app --> BOB\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tint prt;\n\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\tnickinfo.kill(P_INPORT);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprt = Integer.parseInt(Arg);\n\t\t\t\t\t\t\t\t\tif(prt > 1 && prt < 65536) {\n\t\t\t\t\t\t\t\t\t\tnickinfo.add(P_INPORT, new Integer(prt));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR not a number\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\tip = nickinfo.exists(P_INPORT);\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\tif(ip) {\n\t\t\t\t\t\t\t\t\tout.println(\"OK inbound port set\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR port out of range\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_outport)) {\n\t\t\t\t\t\t// Set the nickname outbound FROM the router port\n\t\t\t\t\t\t// BOB --> app\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tint prt;\n\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\tnickinfo.kill(P_OUTPORT);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tprt = Integer.parseInt(Arg);\n\t\t\t\t\t\t\t\t\tif(prt > 1 && prt < 65536) {\n\t\t\t\t\t\t\t\t\t\tnickinfo.add(P_OUTPORT, new Integer(prt));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch(NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR not a number\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\tip = nickinfo.exists(P_OUTPORT);\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\tif(ip) {\n\t\t\t\t\t\t\t\t\tout.println(\"OK outbound port set\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR port out of range\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_inhost)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\tnickinfo.add(P_INHOST, Arg);\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tout.println(\"OK inhost set\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_outhost)) {\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\tnickinfo.add(P_OUTHOST, Arg);\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tout.println(\"OK outhost set\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_show)) {\n\t\t\t\t\t\t// Get the current nickname properties\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tout.print(\"OK\");\n\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\tnickprint(out, nickinfo);\n\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_start)) {\n\t\t\t\t\t\t// Start the tunnel, if we have all the information\n\t\t\t\t\t\tif(ns && dk && (ip || op)) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tMUXlisten tunnel;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttunnel = new MUXlisten(database, nickinfo, _log);\n\t\t\t\t\t\t\t\t\tThread t = new Thread(tunnel);\n\t\t\t\t\t\t\t\t\tt.start();\n\t\t\t\t\t\t\t\t\tout.println(\"OK tunnel starting\");\n\t\t\t\t\t\t\t\t} catch(I2PException e) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR starting tunnel: \" + e);\n\t\t\t\t\t\t\t\t} catch(IOException e) {\n\t\t\t\t\t\t\t\t\tout.println(\"ERROR starting tunnel: \" + e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout.println(\"ERROR tunnel settings incomplete\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_stop)) {\n\t\t\t\t\t\t// Stop the tunnel, if it is running\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\tif(nickinfo.get(P_RUNNING).equals(Boolean.TRUE) && nickinfo.get(P_STOPPING).equals(Boolean.FALSE) && nickinfo.get(P_STARTING).equals(Boolean.FALSE)) {\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\t\tnickinfo.add(P_STOPPING, Boolean.TRUE);\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tout.println(\"OK tunnel stopping\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is inactive\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_clear)) {\n\t\t\t\t\t\t// Clear use of the nickname if stopped\n\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\tif(tunnelactive(nickinfo)) {\n\t\t\t\t\t\t\t\tout.println(\"ERROR tunnel is active\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdatabase.getWriteLock();\n\t\t\t\t\t\t\t\tdatabase.kill(nickinfo.get(P_NICKNAME));\n\t\t\t\t\t\t\t\tdatabase.releaseWriteLock();\n\t\t\t\t\t\t\t\tdk = ns = ip = op = false;\n\t\t\t\t\t\t\t\tout.println(\"OK cleared\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(Command.equals(C_status)) {\n\t\t\t\t\t\tif(database.exists(Arg)) {\n\t\t\t\t\t\t\t// Show status of a nickname\n\t\t\t\t\t\t\tout.print(\"OK \");\n\t\t\t\t\t\t\tttlpnt(out, Arg);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnns(out);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(\"ERROR UNKNOWN COMMAND! Try help\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Say goodbye.\n\n\t\t\tout.println(\"OK Bye!\");\n\n\t\t\tserver.close();\n\t\t} catch(IOException ioe) {\n\t\t\tBOB.warn(\"IOException on socket listen: \" + ioe);\n\t\t\tioe.printStackTrace();\n\t\t}\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Print information on a specific record, indicated by nickname\n\t * @param out\n\t * @param database\n\t * @param Arg\n\t */\n\tpublic void ttlpnt(PrintStream out, nickname database, Object Arg) {\n\t\tif(database.exists(Arg)) {\n\t\t\tout.print(\"DATA\");\n\t\t\tnickprint(out, (nickname)database.get(Arg));\n\t\t}\n\t}","id":88937,"modified_method":"/**\n\t * Print information on a specific record, indicated by nickname\n\t * @param out\n\t * @param Arg\n\t */\n\tpublic void ttlpnt(PrintStream out, Object Arg) {\n\t\tdatabase.getReadLock();\n\t\tif(database.exists(Arg)) {\n\t\t\ttry {\n\t\t\t\tout.print(\"DATA\");\n\t\t\t} catch(Exception e) {\n\t\t\t}\n\t\t\tnickprint(out, (nickname)database.get(Arg));\n\t\t}\n\t\tdatabase.releaseReadLock();\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * make initial NULL object\n\t * \n\t */\n\tpublic nickname() {\n\t\tdata = new Object[1][2];\n\t}","id":88938,"modified_method":"/**\n\t * make initial NULL object\n\t * \n\t */\n\tpublic nickname() {\n\t\tthis.data = new Object[1][2];\n\t\tthis.index = this.writersWaiting = this.readers = 0;\n\t\tthis.writingInProgress = false;\n\t}","commit_id":"224ebb16d418ebe0f89072b3cca23f6cf3c52f7d","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\r\n\tpublic void create () {\r\n\t\tByteBuffer bytebuffer = BufferUtils.newUnsafeByteBuffer(1000 * 1000);\r\n\t\tBufferUtils.disposeUnsafeByteBuffer(bytebuffer);\r\n\r\n\t\tByteBuffer bb = BufferUtils.newByteBuffer(8);\r\n\t\tCharBuffer cb = BufferUtils.newCharBuffer(8);\r\n\t\tShortBuffer sb = BufferUtils.newShortBuffer(8);\r\n\t\tIntBuffer ib = BufferUtils.newIntBuffer(8);\r\n\t\tLongBuffer lb = BufferUtils.newLongBuffer(8);\r\n\t\tFloatBuffer fb = BufferUtils.newFloatBuffer(8);\r\n\t\tDoubleBuffer db = BufferUtils.newDoubleBuffer(8);\r\n\r\n\t\tbb.position(4);\r\n\t\tBufferUtils.copy(new byte[] {1, 2, 3, 4}, 0, bb, 4);\r\n\t\tcheckInt(bb.get(), 1);\r\n\t\tcheckInt(bb.get(), 2);\r\n\t\tcheckInt(bb.get(), 3);\r\n\t\tcheckInt(bb.get(), 4);\r\n\r\n\t\tcb.position(4);\r\n\t\tBufferUtils.copy(new char[] {1, 2, 3, 4}, 0, cb, 4);\r\n\t\tcheckInt(cb.get(), 1);\r\n\t\tcheckInt(cb.get(), 2);\r\n\t\tcheckInt(cb.get(), 3);\r\n\t\tcheckInt(cb.get(), 4);\r\n\r\n\t\tsb.position(4);\r\n\t\tBufferUtils.copy(new short[] {1, 2, 3, 4}, 0, sb, 4);\r\n\t\tcheckInt(sb.get(), 1);\r\n\t\tcheckInt(sb.get(), 2);\r\n\t\tcheckInt(sb.get(), 3);\r\n\t\tcheckInt(sb.get(), 4);\r\n\r\n\t\tib.position(4);\r\n\t\tBufferUtils.copy(new int[] {1, 2, 3, 4}, 0, ib, 4);\r\n\t\tcheckInt(ib.get(), 1);\r\n\t\tcheckInt(ib.get(), 2);\r\n\t\tcheckInt(ib.get(), 3);\r\n\t\tcheckInt(ib.get(), 4);\r\n\r\n\t\tlb.position(4);\r\n\t\tBufferUtils.copy(new long[] {1, 2, 3, 4}, 0, lb, 4);\r\n\t\tcheckInt(lb.get(), 1);\r\n\t\tcheckInt(lb.get(), 2);\r\n\t\tcheckInt(lb.get(), 3);\r\n\t\tcheckInt(lb.get(), 4);\r\n\r\n\t\tfb.position(4);\r\n\t\tBufferUtils.copy(new float[] {1, 2, 3, 4}, 0, fb, 4);\r\n\t\tcheckFloat(fb.get(), 1);\r\n\t\tcheckFloat(fb.get(), 2);\r\n\t\tcheckFloat(fb.get(), 3);\r\n\t\tcheckFloat(fb.get(), 4);\r\n\r\n\t\tdb.position(4);\r\n\t\tBufferUtils.copy(new double[] {1, 2, 3, 4}, 0, db, 4);\r\n\t\tcheckFloat(db.get(), 1);\r\n\t\tcheckFloat(db.get(), 2);\r\n\t\tcheckFloat(db.get(), 3);\r\n\t\tcheckFloat(db.get(), 4);\r\n\r\n\t\tByteBuffer bb2 = BufferUtils.newByteBuffer(4);\r\n\t\tbb.position(4);\r\n\t\tBufferUtils.copy(bb, bb2, 4);\r\n\t\tcheckInt(bb2.get(), 1);\r\n\t\tcheckInt(bb2.get(), 2);\r\n\t\tcheckInt(bb2.get(), 3);\r\n\t\tcheckInt(bb2.get(), 4);\r\n\r\n\t\tbench();\r\n\t}","id":88939,"modified_method":"@Override\r\n\tpublic void create () {\r\n\t\t//Not emulated in gwt\r\n\t\t//ByteBuffer bytebuffer = BufferUtils.newUnsafeByteBuffer(1000 * 1000);\r\n\t\t//BufferUtils.disposeUnsafeByteBuffer(bytebuffer);\r\n\t\t\r\n\t\tByteBuffer bb = BufferUtils.newByteBuffer(8);\r\n\t\tCharBuffer cb = BufferUtils.newCharBuffer(8);\r\n\t\tShortBuffer sb = BufferUtils.newShortBuffer(8);\r\n\t\tIntBuffer ib = BufferUtils.newIntBuffer(8);\r\n\t\tLongBuffer lb = BufferUtils.newLongBuffer(8);\r\n\t\tFloatBuffer fb = BufferUtils.newFloatBuffer(8);\r\n\t\tDoubleBuffer db = BufferUtils.newDoubleBuffer(8);\r\n\r\n\t\tbb.position(4);\r\n\t\tBufferUtils.copy(new byte[] {1, 2, 3, 4}, 0, bb, 4);\r\n\t\tcheckInt(bb.get(), 1);\r\n\t\tcheckInt(bb.get(), 2);\r\n\t\tcheckInt(bb.get(), 3);\r\n\t\tcheckInt(bb.get(), 4);\r\n\t\t\r\n\t\tcb.position(4);\r\n\t\tBufferUtils.copy(new char[] {1, 2, 3, 4}, 0, cb, 4);\r\n\t\tcheckInt(cb.get(), 1);\r\n\t\tcheckInt(cb.get(), 2);\r\n\t\tcheckInt(cb.get(), 3);\r\n\t\tcheckInt(cb.get(), 4);\r\n\t\t\r\n\t\tsb.position(4);\r\n\t\tBufferUtils.copy(new short[] {1, 2, 3, 4}, 0, sb, 4);\r\n\t\tcheckInt(sb.get(), 1);\r\n\t\tcheckInt(sb.get(), 2);\r\n\t\tcheckInt(sb.get(), 3);\r\n\t\tcheckInt(sb.get(), 4);\r\n\r\n\t\tib.position(4);\r\n\t\tBufferUtils.copy(new int[] {1, 2, 3, 4}, 0, ib, 4);\r\n\t\tcheckInt(ib.get(), 1);\r\n\t\tcheckInt(ib.get(), 2);\r\n\t\tcheckInt(ib.get(), 3);\r\n\t\tcheckInt(ib.get(), 4);\r\n\t\t\r\n\t\tlb.position(4);\r\n\t\tBufferUtils.copy(new long[] {1, 2, 3, 4}, 0, lb, 4);\r\n\t\tcheckInt(lb.get(), 1);\r\n\t\tcheckInt(lb.get(), 2);\r\n\t\tcheckInt(lb.get(), 3);\r\n\t\tcheckInt(lb.get(), 4);\r\n\r\n\t\tfb.position(4);\r\n\t\tBufferUtils.copy(new float[] {1, 2, 3, 4}, 0, fb, 4);\r\n\t\tcheckFloat(fb.get(), 1);\r\n\t\tcheckFloat(fb.get(), 2);\r\n\t\tcheckFloat(fb.get(), 3);\r\n\t\tcheckFloat(fb.get(), 4);\r\n\r\n\t\tif (Gdx.app.getType() != ApplicationType.WebGL) { // gwt throws: NYI: Numbers.doubleToRawLongBits\r\n\t\t\tdb.position(4);\r\n\t\t\tBufferUtils.copy(new double[] {1, 2, 3, 4}, 0, db, 4);\r\n\t\t\tcheckFloat(db.get(), 1);\r\n\t\t\tcheckFloat(db.get(), 2);\r\n\t\t\tcheckFloat(db.get(), 3);\r\n\t\t\tcheckFloat(db.get(), 4);\r\n\t\t}\r\n\r\n\t\tByteBuffer bb2 = BufferUtils.newByteBuffer(4);\r\n\t\tbb.position(4);\r\n\t\tBufferUtils.copy(bb, bb2, 4);\r\n\t\tcheckInt(bb2.get(), 1);\r\n\t\tcheckInt(bb2.get(), 2);\r\n\t\tcheckInt(bb2.get(), 3);\r\n\t\tcheckInt(bb2.get(), 4);\r\n\r\n\t\tbench();\r\n\t}","commit_id":"52da4d57566020fb4f6031e1e54edd5b4812624d","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void checkFloat (double val1, double val2) {\r\n\t\tif (val1 != val2) throw new GdxRuntimeException(\"Error, val1 != val2\");\r\n\t}","id":88940,"modified_method":"private void checkFloat (double val1, double val2) {\r\n\t\tif (val1 != val2) {\r\n\t\t\tGdx.app.error(\"BufferUtilsTest\", \"checkFloat failed: \"+val1+\" != \"+val2);\r\n\t\t\tthrow new GdxRuntimeException(\"Error, val1 != val2\");\r\n\t\t}\r\n\t}","commit_id":"52da4d57566020fb4f6031e1e54edd5b4812624d","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void checkInt (long val1, long val2) {\r\n\t\tif (val1 != val2) throw new GdxRuntimeException(\"Error, val1 != val2\");\r\n\t}","id":88941,"modified_method":"private void checkInt (long val1, long val2) {\r\n\t\tif (val1 != val2) { \r\n\t\t\tGdx.app.error(\"BufferUtilsTest\", \"checkInt failed: \"+val1+\" != \"+val2);\r\n\t\t\tthrow new GdxRuntimeException(\"Error, val1 != val2\");\r\n\t\t}\r\n\t}","commit_id":"52da4d57566020fb4f6031e1e54edd5b4812624d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n  public String getLogPartition() {\n    return super.getLogPartition() + String.format(\":%s\", getSystemTag(TAG_FLOW_ID));\n  }","id":88942,"modified_method":"@Override\n  public String getLogPartition() {\n    return String.format(\"%s:%s\", super.getLogPartition(), getSystemTag(TAG_FLOW_ID));\n  }","commit_id":"7fb46a59a67d9179905435975e11dccf7c81a8e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getLogPartition() {\n    throw new UnsupportedOperationException(\"GenericLoggingContext does not support this\");\n  }","id":88943,"modified_method":"@Override\n  public String getLogPartition() {\n    return String.format(\"%s:%s\", super.getLogPartition(), getSystemTag(TAG_ENTITY_ID));\n  }","commit_id":"7fb46a59a67d9179905435975e11dccf7c81a8e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getLogPartition() {\n    return super.getLogPartition() + String.format(\":%s\", getSystemTag(TAG_MAP_REDUCE_JOB_ID));\n  }","id":88944,"modified_method":"@Override\n  public String getLogPartition() {\n    return String.format(\"%s:%s\", super.getLogPartition(), getSystemTag(TAG_MAP_REDUCE_JOB_ID));\n  }","commit_id":"7fb46a59a67d9179905435975e11dccf7c81a8e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<String> getLog(final String accountId, final String applicationId,\n                             final String flowId, int size)\n    throws MetricsServiceException, TException {\n    return getLogNext(accountId, applicationId, flowId, TEntityType.FLOW, \"\", 200).getLogEvents();\n  }","id":88945,"modified_method":"@Override\n  public List<String> getLog(final String accountId, final String applicationId,\n                             final String flowId, int size)\n    throws MetricsServiceException, TException {\n    try {\n      LoggingContext loggingContext = new GenericLoggingContext(accountId, applicationId, flowId);\n      Result result = logReader.getLogNext(loggingContext, \"\", 200);\n      return convertLogEvents(result).getLogEvents();\n    } catch (Throwable e) {\n      LOG.warn(\n        String.format(\"Failed to tail log file - %s:%s:%s\", accountId, applicationId, flowId),\n        e);\n      throw new MetricsServiceException(e.getMessage());\n    }\n  }","commit_id":"7fb46a59a67d9179905435975e11dccf7c81a8e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getLogPartition() {\n    return super.getLogPartition() + String.format(\":%s\", getSystemTag(TAG_PROCEDURE_ID));\n  }","id":88946,"modified_method":"@Override\n  public String getLogPartition() {\n    return String.format(\"%s:%s\", super.getLogPartition(), getSystemTag(TAG_PROCEDURE_ID));\n  }","commit_id":"7fb46a59a67d9179905435975e11dccf7c81a8e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n\tpublic void testUnversionedModuleOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet(\n\t\t\t\tCollections.<String, Object>singletonMap(\n\t\t\t\t\t\"applyVersioning\", Boolean.FALSE));\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test/other.es']}\",\n\t\t\tcontent);\n\t\tassertNotContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\"'test/other.es':{'dependencies':['exports']}\", content);\n\t\tassertNotContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertNotContains(\n\t\t\t\"'test@1.0.0/other.es':{'dependencies':['exports']}\", content);\n\t}","id":88947,"modified_method":"@Test\n\tpublic void testUnversionedModuleOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet(\n\t\t\t\tCollections.<String, Object>singletonMap(\n\t\t\t\t\t\"applyVersioning\", Boolean.FALSE));\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tjsLoaderModulesServlet.getJsLoaderModulesTracker();\n\n\t\tjsLoaderModulesServlet.setJsLoaderModulesTracker(\n\t\t\tjsLoaderModulesTracker);\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test/other.es']}\",\n\t\t\tcontent);\n\t\tassertNotContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\"'test/other.es':{'dependencies':['exports']}\", content);\n\t\tassertNotContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertNotContains(\n\t\t\t\"'test@1.0.0/other.es':{'dependencies':['exports']}\", content);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSingleModuleOutputIdempotent() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertOccurrences(\"'test': '/test-1.0.0'\", content, 1);\n\t\tassertOccurrences(\"'test@1.0.0': '/test-1.0.0'\", content, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test/other.es':{'dependencies':['exports']}\", content, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test@1.0.0/other.es':{'dependencies':['exports']}\", content, 1);\n\t}","id":88948,"modified_method":"@Test\n\tpublic void testSingleModuleOutputIdempotent() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tjsLoaderModulesServlet.getJsLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertOccurrences(\"'test': '/test-1.0.0'\", content, 1);\n\t\tassertOccurrences(\"'test@1.0.0': '/test-1.0.0'\", content, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test/other.es':{'dependencies':['exports']}\", content, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent, 1);\n\t\tassertOccurrences(\n\t\t\t\"'test@1.0.0/other.es':{'dependencies':['exports']}\", content, 1);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = JSONException.class)\n\tpublic void testSingleModuleOutputEmptyConfiguration() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/empty.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\t}","id":88949,"modified_method":"@Test(expected = JSONException.class)\n\tpublic void testSingleModuleOutputEmptyConfiguration() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/empty.js\"));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tjsLoaderModulesServlet.getJsLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMultipleModulesOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tserviceReference = buildServiceReference(\n\t\t\t\"foo\", new Version(\"13.2.23\"), true, 0,\n\t\t\tgetResource(\"dependencies/config2.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\"'foo': '/foo-13.2.23'\", content);\n\t\tassertContains(\"'foo@13.2.23': '/foo-13.2.23'\", content);\n\t\tassertContains(\n\t\t\t\"'foo/foo.es':{'dependencies':['exports','foo@13.2.23/fum.es',\" +\n\t\t\t\t\"'jquery@2.15.3/jquery.js']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'foo@13.2.23/foo.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'foo@13.2.23/fum.es','jquery@2.15.3/jquery.js']}\",\n\t\t\tcontent);\n\t}","id":88950,"modified_method":"@Test\n\tpublic void testMultipleModulesOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tjsLoaderModulesServlet.getJsLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tserviceReference = buildServiceReference(\n\t\t\t\"foo\", new Version(\"13.2.23\"), true, 0,\n\t\t\tgetResource(\"dependencies/config2.js\"));\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\"'foo': '/foo-13.2.23'\", content);\n\t\tassertContains(\"'foo@13.2.23': '/foo-13.2.23'\", content);\n\t\tassertContains(\n\t\t\t\"'foo/foo.es':{'dependencies':['exports','foo@13.2.23/fum.es',\" +\n\t\t\t\t\"'jquery@2.15.3/jquery.js']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'foo@13.2.23/foo.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'foo@13.2.23/fum.es','jquery@2.15.3/jquery.js']}\",\n\t\t\tcontent);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected JSLoaderModulesServlet buildJSLoaderModulesServlet(\n\t\t\tMap<String, Object> properties)\n\t\tthrows Exception {\n\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tnew JSLoaderModulesServlet();\n\n\t\tMockServletContext mockServletContext = new MockServletContext();\n\n\t\tmockServletContext.setContextPath(\"/loader\");\n\n\t\tjsLoaderModulesServlet.setDetails(\n\t\t\tConverter.cnv(Details.class, properties));\n\t\tjsLoaderModulesServlet.init(new MockServletConfig(mockServletContext));\n\n\t\treturn jsLoaderModulesServlet;\n\t}","id":88951,"modified_method":"protected JSLoaderModulesServlet buildJSLoaderModulesServlet(\n\t\t\tMap<String, Object> properties)\n\t\tthrows Exception {\n\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tnew JSLoaderModulesServlet();\n\n\t\tMockServletContext mockServletContext = new MockServletContext();\n\n\t\tmockServletContext.setContextPath(\"/loader\");\n\n\t\tjsLoaderModulesServlet.setDetails(\n\t\t\tConverter.cnv(Details.class, properties));\n\t\tjsLoaderModulesServlet.init(new MockServletConfig(mockServletContext));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tnew JSLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.setDetails(\n\t\t\tConverter.cnv(Details.class, properties));\n\n\t\tjsLoaderModulesServlet.setJsLoaderModulesTracker(\n\t\t\tjsLoaderModulesTracker);\n\n\t\tJSBundleConfigTracker jsBundleConfigTracker =\n\t\t\tnew JSBundleConfigTracker();\n\n\t\tjsBundleConfigTracker.setDetails(\n\t\t\tConverter.cnv(Details.class, properties));\n\n\t\tjsLoaderModulesServlet.setJsBundleConfigTracker(jsBundleConfigTracker);\n\n\t\treturn jsLoaderModulesServlet;\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testMultipleVersionsModuleOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tserviceReference = buildServiceReference(\n\t\t\t\"test\", new Version(\"1.2.0\"), true, 0,\n\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.2.0'\", content);\n\t\tassertContains(\"'test@1.2.0': '/test-1.2.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.2.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertNotContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.2.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.2.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t}","id":88952,"modified_method":"@Test\n\tpublic void testMultipleVersionsModuleOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tjsLoaderModulesServlet.getJsLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tserviceReference = buildServiceReference(\n\t\t\t\"test\", new Version(\"1.2.0\"), true, 0,\n\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.2.0'\", content);\n\t\tassertContains(\"'test@1.2.0': '/test-1.2.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.2.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertNotContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.2.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.2.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = JSONException.class)\n\tpublic void testSingleModuleOutputMalformedConfiguration()\n\t\tthrows Exception {\n\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/malformed.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\t}","id":88953,"modified_method":"@Test(expected = JSONException.class)\n\tpublic void testSingleModuleOutputMalformedConfiguration()\n\t\tthrows Exception {\n\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tnew JSLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.setDetails(\n\t\t\tConverter.cnv(Details.class, new HashMap<>()));\n\n\t\tjsLoaderModulesServlet.setJsLoaderModulesTracker(\n\t\t\tjsLoaderModulesTracker);\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/malformed.js\"));\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSingleModuleOutputNoConfiguration() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\"test\", new Version(\"1.0.0\"), true, 0, null);\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertNotContains(\"':{'dependencies':['\", content);\n\t}","id":88954,"modified_method":"@Test\n\tpublic void testSingleModuleOutputNoConfiguration() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tnew JSLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.setDetails(\n\t\t\tConverter.cnv(Details.class, new HashMap<>()));\n\n\t\tjsLoaderModulesServlet.setJsLoaderModulesTracker(\n\t\t\tjsLoaderModulesTracker);\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\"test\", new Version(\"1.0.0\"), true, 0, null);\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertNotContains(\"':{'dependencies':['\", content);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSingleModuleOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tjsLoaderModulesServlet.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\"'test/other.es':{'dependencies':['exports']}\", content);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/other.es':{'dependencies':['exports']}\",\n\t\t\tcontent);\n\t}","id":88955,"modified_method":"@Test\n\tpublic void testSingleModuleOutput() throws Exception {\n\t\tJSLoaderModulesServlet jsLoaderModulesServlet =\n\t\t\tbuildJSLoaderModulesServlet();\n\n\t\tServiceReference<ServletContext> serviceReference =\n\t\t\tbuildServiceReference(\n\t\t\t\t\"test\", new Version(\"1.0.0\"), true, 0,\n\t\t\t\tgetResource(\"dependencies/config1.js\"));\n\n\t\tJSLoaderModulesTracker jsLoaderModulesTracker =\n\t\t\tjsLoaderModulesServlet.getJsLoaderModulesTracker();\n\n\t\tjsLoaderModulesTracker.addingService(serviceReference);\n\n\t\tMockHttpServletRequest mockHttpServletRequest =\n\t\t\tnew MockHttpServletRequest();\n\t\tMockHttpServletResponse mockHttpServletResponse =\n\t\t\tnew MockHttpServletResponse();\n\n\t\tjsLoaderModulesServlet.service(\n\t\t\tmockHttpServletRequest, mockHttpServletResponse);\n\n\t\tString content = mockHttpServletResponse.getContentAsString();\n\n\t\tcontent = content.replace('\"', '\\'');\n\n\t\tassertContains(\"'test': '/test-1.0.0'\", content);\n\t\tassertContains(\"'test@1.0.0': '/test-1.0.0'\", content);\n\t\tassertContains(\n\t\t\t\"'test/some.es':{'dependencies':['exports','test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\"'test/other.es':{'dependencies':['exports']}\", content);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/some.es':{'dependencies':['exports',\" +\n\t\t\t\t\"'test@1.0.0/other.es']}\",\n\t\t\tcontent);\n\t\tassertContains(\n\t\t\t\"'test@1.0.0/other.es':{'dependencies':['exports']}\",\n\t\t\tcontent);\n\t}","commit_id":"02233411b10ec88828e348703b2efc1e09e98130","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Store the System to cobbler\n     * @return ValidatorError if the store failed.\n     */\n    public ValidatorError store() {\n        \n        \n        \n        String handle = (String) invokeXMLRPC(\"new_system\", xmlRpcToken);\n        log.debug(\"handle: \" + handle);\n        invokeXMLRPC(\"modify_system\", handle, \"name\", server.getName(),\n                                 xmlRpcToken);\n        \n        if (this.server.getNetworkInterfaces() == null ||\n                this.server.getNetworkInterfaces().isEmpty()) {\n            return new ValidatorError(\"kickstart.no.network.error\");\n        }\n        Iterator i = this.server.getNetworkInterfaces().iterator();\n        Map inet = new HashMap();\n        while (i.hasNext()) {\n            NetworkInterface n = (NetworkInterface) i.next();\n            inet.put(\"macaddress-\" + n.getName(), n.getHwaddr());\n        }\n        log.debug(\"Networks: \" + inet);\n        \n        Object[] args = new Object[]{handle, \"modify-interface\", \n                inet, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n\n        args = new String[]{handle, \"profile\", \n                name, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        \n        if (this.activationKeys == null || this.activationKeys.length() == 0) {\n            log.error(\"This cobbler profile does not \" +\n                \"have a redhat_management_key set \");\n        }\n        else {\n            args = new Object[]{handle, \"redhat_management_key\", \n                    this.activationKeys, xmlRpcToken};\n        }\n\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n\n        \n        \n        // Setup the kickstart metadata so the URLs and activation key are setup\n        Map ksmeta = new HashMap();\n        if (!StringUtils.isBlank(mediaPath)) {\n            ksmeta.put(KickstartUrlHelper.COBBLER_MEDIA_VARIABLE,\n                                                    this.mediaPath);            \n        }\n\n        args = new Object[]{handle, \"ksmeta\", \n                ksmeta, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        invokeXMLRPC(\"save_system\", handle, xmlRpcToken);\n        \n        Map cSystem = getSystemMap();\n        server.setCobblerId((String)cSystem.get(\"uid\"));\n        return null;\n    }","id":88956,"modified_method":"/**\n     * Store the System to cobbler\n     * @return ValidatorError if the store failed.\n     */\n    public ValidatorError store() {\n        \n        \n        \n        String handle = (String) invokeXMLRPC(\"new_system\", xmlRpcToken);\n        log.debug(\"handle: \" + handle);\n        invokeXMLRPC(\"modify_system\", handle, \"name\", server.getName(),\n                                 xmlRpcToken);\n        \n        if (this.server.getNetworkInterfaces() == null ||\n                this.server.getNetworkInterfaces().isEmpty()) {\n            return new ValidatorError(\"kickstart.no.network.error\");\n        }\n        Iterator i = this.server.getNetworkInterfaces().iterator();\n        Map inet = new HashMap();\n        while (i.hasNext()) {\n            NetworkInterface n = (NetworkInterface) i.next();\n            inet.put(\"macaddress-\" + n.getName(), n.getHwaddr());\n        }\n        log.debug(\"Networks: \" + inet);\n        \n        Object[] args = new Object[]{handle, \"modify-interface\", \n                inet, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n\n        if (name != null) {\n            args = new String[]{handle, \"profile\", \n                    name, xmlRpcToken};\n            invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        }\n        \n        if (this.activationKeys == null || this.activationKeys.length() == 0) {\n            log.error(\"This cobbler profile does not \" +\n                \"have a redhat_management_key set \");\n        }\n        else {\n            args = new Object[]{handle, \"redhat_management_key\", \n                    this.activationKeys, xmlRpcToken};\n        }\n\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n\n        \n        \n        // Setup the kickstart metadata so the URLs and activation key are setup\n        Map ksmeta = new HashMap();\n        if (!StringUtils.isBlank(mediaPath)) {\n            ksmeta.put(KickstartUrlHelper.COBBLER_MEDIA_VARIABLE,\n                                                    this.mediaPath);            \n        }\n\n        args = new Object[]{handle, \"ksmeta\", \n                ksmeta, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        invokeXMLRPC(\"save_system\", handle, xmlRpcToken);\n        \n        Map cSystem = getSystemMap();\n        server.setCobblerId((String)cSystem.get(\"uid\"));\n        return null;\n    }","commit_id":"4afc7f7b061aa85b859d74031e3f8598faea5171","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public Object invokeMethod(String procedureName, List args) {\n        methodsCalled.add(procedureName);\n        log.debug(\"invoking: \" + procedureName + \" with: \" + args);\n        \n        if (procedureName.equals(\"new_profile\") ||\n                procedureName.equals(\"new_distro\")) {\n            return new String(\"1\");\n        }\n        else if (procedureName.equals(\"modify_distro\")) {\n            if (args.get(1).equals(\"name\")) {\n                log.debug(\"ARGS: \" + args);\n                // Stick the mock name into our mockObjects map\n                // so we can add it to the return list when calling\n                // get_distros\n                log.debug(\"Putting distro_name into map: \" + args.get(2));\n                TestObjectStore.get().putObject(\"distro_name\", args.get(2));\n                log.debug(\"mockobjects111: \" + TestObjectStore.get().getObjects());\n            }\n            if (args.get(1).equals(\"ksmeta\")) {\n                log.debug(\"putting ksmeta into store: \" + args.get(2));\n                if (TestObjectStore.get().getObject(\"ksmeta\") != null) {\n                    Map ksmeta = (Map) TestObjectStore.get().getObject(\"ksmeta\");\n                    ksmeta.putAll((Map) args.get(2));\n                }\n                else {\n                    TestObjectStore.get().putObject(\"ksmeta\", args.get(2));\n                }\n            }\n            return new String(\"1\");\n        }\n        else if (procedureName.equals(\"get_distros\")) {\n            List retval = new LinkedList();\n            if (methodsCalled.contains(\"remove_distro\")) {\n                return retval;\n            }\n            else {\n                for (int i = 0; i < 10; i++) {\n                    Map distro = new HashMap();\n                    distro.put(\"name\", TestUtils.randomString());\n                    retval.add(distro);\n                }\n                // Put the mock distro we created with the call to modify_distro\n                // into the return value.  Useful if you want to test creation\n                // then a fetch.\n                Map distro = new HashMap();\n                log.debug(\"mockobjects in getdistros: \" + \n                        TestObjectStore.get().getObjects());\n                distro.put(\"name\", TestObjectStore.get().getObject(\"distro_name\"));\n                distro.put(\"ksmeta\", TestObjectStore.get().getObject(\"ksmeta\"));\n                retval.add(distro);\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"modify_profile\")) {\n            if (args.get(1).equals(\"name\")) {\n                log.debug(\"ARGS: \" + args);\n                TestObjectStore.get().putObject(\"profile_name\", args.get(2));\n            }\n            return new String(\"1\");\n        }\n        else if (procedureName.equals(\"get_profiles\")) {\n            List retval = new LinkedList();\n            if (methodsCalled.contains(\"remove_profile\")) {\n                return retval;\n            }\n            else {\n                for (int i = 0; i < 10; i++) {\n                    Map distro = new HashMap();\n                    distro.put(\"name\", TestUtils.randomString());\n                    distro.put(\"uid\", String.valueOf(RandomUtils.nextInt(5000)));\n                    retval.add(distro);\n                }\n                // Put the mock distro we created with the call to modify_distro\n                // into the return value.  Useful if you want to test creation\n                // then a fetch.\n                Map profile = new HashMap();\n                log.debug(\"mockobjects222: \" + TestObjectStore.get().getObjects());\n                profile.put(\"name\", TestObjectStore.get().getObject(\"profile_name\"));\n                profile.put(\"uid\", TestObjectStore.get().getObject(\"uid\"));\n                retval.add(profile);\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_profile\")) {\n            Map retval = new HashMap();\n            if (methodsCalled.contains(\"remove_profile\")) {\n                return retval;\n            }\n            else {\n                retval.put(\"name\", TestUtils.randomString());\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_distro\")) {\n            Map retval = new HashMap();\n            if (methodsCalled.contains(\"remove_distro\")) {\n                return retval;\n            }\n            else {\n                log.debug(\"mockobjects in getdistros: \" + \n                        TestObjectStore.get().getObjects());\n                if (TestObjectStore.get().getObjects().containsKey(\"distro_name\")) {\n                    retval.put(\"name\", TestObjectStore.get().getObject(\"distro_name\"));\n                    retval.put(\"ksmeta\", TestObjectStore.get().getObject(\"ksmeta\"));\n                }\n                else {\n                    retval.put(\"name\", TestUtils.randomString());\n                }\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_system\")) {\n            Map retval = new HashMap();\n            if (methodsCalled.contains(\"remove_system\") ||\n                    !methodsCalled.contains(\"save_system\")) {\n                return retval;\n            }\n            else {\n                retval.put(\"name\", TestUtils.randomString());\n                retval.put(\"redhat-management-key\", TestUtils.randomString());\n                retval.put(\"uid\", String.valueOf(RandomUtils.nextInt(5000)));\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_profile_handle\")) {\n            log.debug(\"get_profile_handle.ARGS: \" + args);\n            TestObjectStore.get().putObject(\"profile_name\", args.get(0));\n            return TestUtils.randomString();\n        }\n        else if (procedureName.equals(\"get_distro_handle\")) {\n            log.debug(\"get_distro_handle.ARGS: \" + args);\n            TestObjectStore.get().putObject(\"distro_name\", args.get(0));\n            return TestUtils.randomString();\n        }\n        else if (procedureName.equals(\"remove_distro\")) {\n            return new Boolean(true);\n        }\n        else if (procedureName.equals(\"remove_profile\")) {\n            return new Boolean(true);\n        }\n        else if (procedureName.equals(\"token_check\")) {\n            return new Boolean(true);\n        }\n        else if (procedureName.equals(\"login\")) {\n            return TestUtils.randomString();\n        }\n        else if (procedureName.equals(\"new_system\")) {\n            return TestUtils.randomString();\n        }\n        return new Object();\n    }","id":88957,"modified_method":"public Object invokeMethod(String procedureName, List args) {\n        methodsCalled.add(procedureName);\n        log.debug(\"invoking: \" + procedureName + \" with: \" + args);\n        \n        // Check that none of the args are null\n        // because xmlrpc doesnt allow this.\n        for (int i = 0; i < args.size(); i++) {\n            if (args.get(i) == null) {\n                throw new NullPointerException(\n                        \"One of the args is null: \" + args);\n            }\n        }\n        \n        \n        if (procedureName.equals(\"new_profile\") ||\n                procedureName.equals(\"new_distro\")) {\n            return new String(\"1\");\n        }\n        else if (procedureName.equals(\"modify_distro\")) {\n            if (args.get(1).equals(\"name\")) {\n                log.debug(\"ARGS: \" + args);\n                // Stick the mock name into our mockObjects map\n                // so we can add it to the return list when calling\n                // get_distros\n                log.debug(\"Putting distro_name into map: \" + args.get(2));\n                TestObjectStore.get().putObject(\"distro_name\", args.get(2));\n                log.debug(\"mockobjects111: \" + TestObjectStore.get().getObjects());\n            }\n            if (args.get(1).equals(\"ksmeta\")) {\n                log.debug(\"putting ksmeta into store: \" + args.get(2));\n                if (TestObjectStore.get().getObject(\"ksmeta\") != null) {\n                    Map ksmeta = (Map) TestObjectStore.get().getObject(\"ksmeta\");\n                    ksmeta.putAll((Map) args.get(2));\n                }\n                else {\n                    TestObjectStore.get().putObject(\"ksmeta\", args.get(2));\n                }\n            }\n            return new String(\"1\");\n        }\n        else if (procedureName.equals(\"get_distros\")) {\n            List retval = new LinkedList();\n            if (methodsCalled.contains(\"remove_distro\")) {\n                return retval;\n            }\n            else {\n                for (int i = 0; i < 10; i++) {\n                    Map distro = new HashMap();\n                    distro.put(\"name\", TestUtils.randomString());\n                    retval.add(distro);\n                }\n                // Put the mock distro we created with the call to modify_distro\n                // into the return value.  Useful if you want to test creation\n                // then a fetch.\n                Map distro = new HashMap();\n                log.debug(\"mockobjects in getdistros: \" + \n                        TestObjectStore.get().getObjects());\n                distro.put(\"name\", TestObjectStore.get().getObject(\"distro_name\"));\n                distro.put(\"ksmeta\", TestObjectStore.get().getObject(\"ksmeta\"));\n                retval.add(distro);\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"modify_profile\")) {\n            if (args.get(1).equals(\"name\")) {\n                log.debug(\"ARGS: \" + args);\n                TestObjectStore.get().putObject(\"profile_name\", args.get(2));\n            }\n            return new String(\"1\");\n        }\n        else if (procedureName.equals(\"get_profiles\")) {\n            List retval = new LinkedList();\n            if (methodsCalled.contains(\"remove_profile\")) {\n                return retval;\n            }\n            else {\n                for (int i = 0; i < 10; i++) {\n                    Map distro = new HashMap();\n                    distro.put(\"name\", TestUtils.randomString());\n                    distro.put(\"uid\", String.valueOf(RandomUtils.nextInt(5000)));\n                    retval.add(distro);\n                }\n                // Put the mock distro we created with the call to modify_distro\n                // into the return value.  Useful if you want to test creation\n                // then a fetch.\n                Map profile = new HashMap();\n                log.debug(\"mockobjects222: \" + TestObjectStore.get().getObjects());\n                profile.put(\"name\", TestObjectStore.get().getObject(\"profile_name\"));\n                profile.put(\"uid\", TestObjectStore.get().getObject(\"uid\"));\n                retval.add(profile);\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_profile\")) {\n            Map retval = new HashMap();\n            if (methodsCalled.contains(\"remove_profile\")) {\n                return retval;\n            }\n            else {\n                retval.put(\"name\", TestUtils.randomString());\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_distro\")) {\n            Map retval = new HashMap();\n            if (methodsCalled.contains(\"remove_distro\")) {\n                return retval;\n            }\n            else {\n                log.debug(\"mockobjects in getdistros: \" + \n                        TestObjectStore.get().getObjects());\n                if (TestObjectStore.get().getObjects().containsKey(\"distro_name\")) {\n                    retval.put(\"name\", TestObjectStore.get().getObject(\"distro_name\"));\n                    retval.put(\"ksmeta\", TestObjectStore.get().getObject(\"ksmeta\"));\n                }\n                else {\n                    retval.put(\"name\", TestUtils.randomString());\n                }\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_system\")) {\n            Map retval = new HashMap();\n            if (methodsCalled.contains(\"remove_system\") ||\n                    !methodsCalled.contains(\"save_system\")) {\n                return retval;\n            }\n            else {\n                retval.put(\"name\", TestUtils.randomString());\n                retval.put(\"redhat-management-key\", TestUtils.randomString());\n                retval.put(\"uid\", String.valueOf(RandomUtils.nextInt(5000)));\n                return retval;\n            }\n        }\n        else if (procedureName.equals(\"get_profile_handle\")) {\n            log.debug(\"get_profile_handle.ARGS: \" + args);\n            TestObjectStore.get().putObject(\"profile_name\", args.get(0));\n            return TestUtils.randomString();\n        }\n        else if (procedureName.equals(\"get_distro_handle\")) {\n            log.debug(\"get_distro_handle.ARGS: \" + args);\n            TestObjectStore.get().putObject(\"distro_name\", args.get(0));\n            return TestUtils.randomString();\n        }\n        else if (procedureName.equals(\"remove_distro\")) {\n            return new Boolean(true);\n        }\n        else if (procedureName.equals(\"remove_profile\")) {\n            return new Boolean(true);\n        }\n        else if (procedureName.equals(\"token_check\")) {\n            return new Boolean(true);\n        }\n        else if (procedureName.equals(\"login\")) {\n            return TestUtils.randomString();\n        }\n        else if (procedureName.equals(\"new_system\")) {\n            return TestUtils.randomString();\n        }\n        return new Object();\n    }","commit_id":"4afc7f7b061aa85b859d74031e3f8598faea5171","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void setUp() throws Exception {\n        super.setUp();\n        this.ksdata = KickstartDataTest.\n            createKickstartWithChannel(user.getOrg());\n        \n    }","id":88958,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void setUp() throws Exception {\n        super.setUp();\n        this.ksdata = KickstartDataTest.\n            createKickstartWithDefaultKey(user.getOrg());\n        \n    }","commit_id":"0383b09199ae89b95dcc9625104ab27e5a8d63d0","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@Override\n    public void setUp() throws Exception {\n        super.setUp();\n        \n        user = UserTestUtils.createUserInOrgOne();\n        this.ksdata = KickstartDataTest.createKickstartWithChannel(this.user.getOrg());\n        this.ksdata.getTree().setBasePath(\"/var/satellite/rhn/kickstart/ks-f9-x86_64/\");\n        user.addRole(RoleFactory.ORG_ADMIN);\n\n        // Uncomment this if you want the tests to actually talk to cobbler\n        // Config.get().setString(CobblerXMLRPCHelper.class.getName(),\n        //        CobblerXMLRPCHelper.class.getName());\n        //commitAndCloseSession();\n        \n        CobblerDistroCreateCommand dcreate = new \n            CobblerDistroCreateCommand(ksdata.getTree(), user);\n        dcreate.store();\n    }","id":88959,"modified_method":"@Override\n    public void setUp() throws Exception {\n        super.setUp();\n        \n        user = UserTestUtils.createUserInOrgOne();\n        this.ksdata = KickstartDataTest.createKickstartWithDefaultKey(this.user.getOrg());\n        this.ksdata.getTree().setBasePath(\"/var/satellite/rhn/kickstart/ks-f9-x86_64/\");\n        user.addRole(RoleFactory.ORG_ADMIN);\n\n        // Uncomment this if you want the tests to actually talk to cobbler\n        // Config.get().setString(CobblerXMLRPCHelper.class.getName(),\n        //        CobblerXMLRPCHelper.class.getName());\n        //commitAndCloseSession();\n        \n        CobblerDistroCreateCommand dcreate = new \n            CobblerDistroCreateCommand(ksdata.getTree(), user);\n        dcreate.store();\n    }","commit_id":"0383b09199ae89b95dcc9625104ab27e5a8d63d0","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected void updateCobblerFields(String handle) {\n        Object[] args = new String[]{handle, \"kickstart\", \n                this.ksData.getCobblerFileName(), xmlRpcToken};\n        invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n\n        args = new Object[]{handle, \"distro\", \n                this.ksData.getTree().getCobblerDistroName(), xmlRpcToken};\n\n        invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        \n        if (kernelOptions != null) {\n            args = new Object[]{handle, \"kernel_options\", \n                    kernelOptions, xmlRpcToken};\n            invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        }\n        \n        // redhat_management_key\n        KickstartSession ksession = \n            KickstartFactory.\n                lookupDefaultKickstartSessionForKickstartData(this.ksData); \n        ActivationKey key = ActivationKeyFactory.lookupByKickstartSession(ksession);\n\n        args = new Object[]{handle, \"redhat_management_key\", \n                key.getKey(), xmlRpcToken};\n\n        invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n\n\n        \n        if (kernelOptions != null) {\n            args = new Object[]{handle, \"kernel_options_post\", \n                    postKernelOptions, xmlRpcToken};\n            invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        }\n        Map<String, Object> meta = new HashMap<String, Object>();\n        meta.put(\"org\", user.getOrg().getId());\n        invokeXMLRPC(\"modify_profile\", handle, \"ksmeta\", meta, xmlRpcToken);        \n    }","id":88960,"modified_method":"protected void updateCobblerFields(String handle) {\n        Object[] args = new String[]{handle, \"kickstart\", \n                this.ksData.getCobblerFileName(), xmlRpcToken};\n        invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n\n        args = new Object[]{handle, \"distro\", \n                this.ksData.getTree().getCobblerDistroName(), xmlRpcToken};\n\n        invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        \n        if (kernelOptions != null) {\n            args = new Object[]{handle, \"kernel_options\", \n                    kernelOptions, xmlRpcToken};\n            invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        }\n        \n        // redhat_management_key\n        KickstartSession ksession = \n            KickstartFactory.\n                lookupDefaultKickstartSessionForKickstartData(this.ksData); \n        if (ksession != null) {\n            ActivationKey key = ActivationKeyFactory.lookupByKickstartSession(ksession);\n\n            args = new Object[]{handle, \"redhat_management_key\", \n                    key.getKey(), xmlRpcToken};\n\n            invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        }\n        else {\n            log.warn(\"We could not find a default kickstart session for this ksdata: \" + \n                    ksData.getLabel());\n        }\n        \n        if (kernelOptions != null) {\n            args = new Object[]{handle, \"kernel_options_post\", \n                    postKernelOptions, xmlRpcToken};\n            invokeXMLRPC(\"modify_profile\", Arrays.asList(args));\n        }\n        Map<String, Object> meta = new HashMap<String, Object>();\n        meta.put(\"org\", user.getOrg().getId());\n        invokeXMLRPC(\"modify_profile\", handle, \"ksmeta\", meta, xmlRpcToken);        \n    }","commit_id":"0383b09199ae89b95dcc9625104ab27e5a8d63d0","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public static KickstartData createKickstartWithChannel(Org orgIn) throws Exception {\n        KickstartData ksdata = KickstartDataTest.createTestKickstartData(orgIn); \n        KickstartDefaults d1 = KickstartDataTest.createDefaults(ksdata, \n                UserTestUtils.ensureOrgAdminExists(orgIn));\n        ksdata.setKickstartDefaults(d1);\n\n        KickstartWizardHelper cmd = new KickstartWizardHelper(\n                UserFactory.findRandomOrgAdmin(orgIn));\n        cmd.store(ksdata);\n        return ksdata;\n    }","id":88961,"modified_method":"public static KickstartData createKickstartWithChannel(Org orgIn) throws Exception {\n        KickstartData ksdata = KickstartDataTest.createTestKickstartData(orgIn); \n        KickstartDefaults d1 = KickstartDataTest.createDefaults(ksdata, \n                UserTestUtils.ensureOrgAdminExists(orgIn));\n        ksdata.setKickstartDefaults(d1);\n        \n        return ksdata;\n    }","commit_id":"0383b09199ae89b95dcc9625104ab27e5a8d63d0","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Sets the kickstart url for the passed in cobbler profiles.\n     * @param dtos the kickstart dto\n     * @param user the user object needed to connect to cobbler\n     */\n    public void setKickstartUrls(List <KickstartDto> dtos, User user) {\n        CobblerConnection conn = CobblerXMLRPCHelper.getConnection(user);\n\n        for (KickstartDto dto : dtos) {\n            Profile p = Profile.lookupById(conn, dto.getCobblerId());\n            dto.setCobblerUrl(KickstartUrlHelper.getCobblerProfileUrl(p.getName()));\n        }\n    }","id":88962,"modified_method":"/**\n     * Sets the kickstart url for the passed in cobbler profiles.\n     * @param dtos the kickstart dto\n     * @param user the user object needed to connect to cobbler\n     */\n    public void setKickstartUrls(List <KickstartDto> dtos, User user) {\n        CobblerConnection conn = CobblerXMLRPCHelper.getConnection(user);\n\n        for (KickstartDto dto : dtos) {\n            Profile p = Profile.lookupById(conn, dto.getCobblerId());\n            if (p != null) {\n                dto.setCobblerUrl(KickstartUrlHelper.getCobblerProfileUrl(p.getName()));\n            }\n        }\n    }","commit_id":"0383b09199ae89b95dcc9625104ab27e5a8d63d0","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@Override\n    public void setUp() throws Exception {\n        super.setUp();\n        \n        user = UserTestUtils.createUserInOrgOne();\n        user.addRole(RoleFactory.ORG_ADMIN);\n        this.ksdata = KickstartDataTest.createKickstartWithDefaultKey(this.user.getOrg());\n        this.ksdata.getTree().setBasePath(\"/var/satellite/rhn/kickstart/ks-f9-x86_64/\");\n\n        // Uncomment this if you want the tests to actually talk to cobbler\n        // Config.get().setString(CobblerXMLRPCHelper.class.getName(),\n        //        CobblerXMLRPCHelper.class.getName());\n        //commitAndCloseSession();\n        \n        CobblerDistroCreateCommand dcreate = new \n            CobblerDistroCreateCommand(ksdata.getTree(), user);\n        dcreate.store();\n    }","id":88963,"modified_method":"@Override\n    public void setUp() throws Exception {\n        super.setUp();\n        \n        user = UserTestUtils.createUserInOrgOne();\n        user.addRole(RoleFactory.ORG_ADMIN);\n        this.ksdata = KickstartDataTest.createKickstartWithDefaultKey(this.user.getOrg());\n        this.ksdata.getTree().setBasePath(\"/opt/repo/f9-x86_64/\");\n        \n        // Uncomment this if you want the tests to actually talk to cobbler\n        //Config.get().setString(CobblerXMLRPCHelper.class.getName(),\n        //        CobblerXMLRPCHelper.class.getName());\n        //Config.get().setString(CobblerConnection.class.getName(),\n        //        CobblerConnection.class.getName());\n        //commitAndCloseSession();\n        \n        CobblerDistroCreateCommand dcreate = new \n            CobblerDistroCreateCommand(ksdata.getTree(), user);\n        dcreate.store();\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testSystemCreate() throws Exception {\n\n        Server s = ServerTestUtils.createTestSystem(user);\n        NetworkInterface device = NetworkInterfaceTest.createTestNetworkInterface(s);\n        s.addNetworkInterface(device);\n        \n        CobblerSystemCreateCommand cmd = new CobblerSystemCreateCommand(user, s, ksdata, \n                    \"http://localhost/test/path\", TestUtils.randomString());\n        cmd.store();\n        assertNotNull(s.getCobblerId());\n        Map systemMap = cmd.getSystemMap(); \n        assertNotNull(systemMap);\n        assertTrue(systemMap.containsKey(\"name\"));\n        \n        // Ensure we can call it twice.\n        cmd = new CobblerSystemCreateCommand(user, s, ksdata, \n                \"http://localhost/test/path\", TestUtils.randomString());\n        cmd.store();\n    }","id":88964,"modified_method":"public void testSystemCreate() throws Exception {\n\n        Server s = ServerTestUtils.createTestSystem(user);\n        NetworkInterface device = NetworkInterfaceTest.createTestNetworkInterface(s);\n        s.addNetworkInterface(device);\n        \n        CobblerSystemCreateCommand cmd = new CobblerSystemCreateCommand(user, s, ksdata, \n                    \"http://localhost/test/path\", TestUtils.randomString());\n        cmd.store();\n        assertNotNull(s.getCobblerId());\n        \n        // Ensure we can call it twice.\n        cmd = new CobblerSystemCreateCommand(user, s, ksdata, \n                \"http://localhost/test/path\", TestUtils.randomString());\n        cmd.store();\n        assertNotNull(s.getCobblerId());\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Get the Cobbler map representation fo the system\n     * @return Map of system\n     */\n    public Map getSystemMap() {\n        List < String > args = new ArrayList();\n        args.add(getCobblerSystemRecordName());\n        args.add(xmlRpcToken);\n        Map retval = (Map) invokeXMLRPC(\"get_system\", args);\n        return retval;\n    }","id":88965,"modified_method":"private Map getSystemMapByMac() {\n        // Build up list of mac addrs\n        Iterator i = server.getNetworkInterfaces().iterator();\n        List macs = new LinkedList();\n        while (i.hasNext()) {\n            NetworkInterface n = (NetworkInterface) i.next();\n            macs.add(n.getHwaddr().toLowerCase());\n        }\n\n        List <String> args = new ArrayList();\n        args.add(xmlRpcToken);\n        List<Map> systems = (List) invokeXMLRPC(\"get_systems\", args);\n        for (Map row : systems) {\n            Set ifacenames = ((Map) row.get(\"interfaces\")).keySet();\n            log.debug(\"Ifacenames: \" + ifacenames);\n            Map ifaces = (Map) row.get(\"interfaces\");\n            log.debug(\"ifaces: \" + ifaces);\n            Iterator names = ifacenames.iterator();\n            while (names.hasNext()) {\n                String name = (String) names.next();\n                log.debug(\"Name: \" + name);\n                Map iface = (Map) ifaces.get(name);\n                log.debug(\"iface: \" + iface);\n                String mac = (String) iface.get(\"mac_address\");\n                log.debug(\"getSystemMapByMac.ROW: \" + row + \n                        \" looking for: \" + macs);\n                if (mac != null && \n                        macs.contains(mac.toLowerCase())) {\n                    log.debug(\"getSystemMapByMac.found match.\");\n                    return row;\n                }\n            }\n        }\n        return null;\n        \n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor\n     * @param userIn who is requesting the sync\n     * @param serverIn profile we want to create in cobbler\n     * @param ksDataIn profile to associate with with server.\n     * @param mediaPathIn mediaPath to override in the server profile.\n     * @param activationKeysIn to add to the system record.  Used when the system\n     * re-registers to Spacewalk\n     */\n    public CobblerSystemCreateCommand(User userIn, Server serverIn, \n            KickstartData ksDataIn, String mediaPathIn, String activationKeysIn) {\n        super(userIn);\n        this.server = serverIn;\n        this.mediaPath = mediaPathIn;\n        if (ksDataIn != null) {\n            name = (String)lookupCobblerProfile(ksDataIn).get(\"name\");\n        }\n        else {\n            throw new NullPointerException(\"ksDataIn cant be null\");\n        }\n        this.activationKeys = activationKeysIn;\n    }","id":88966,"modified_method":"/**\n     * Constructor\n     * @param userIn who is requesting the sync\n     * @param serverIn profile we want to create in cobbler\n     * @param ksDataIn profile to associate with with server.\n     * @param mediaPathIn mediaPath to override in the server profile.\n     * @param activationKeysIn to add to the system record.  Used when the system\n     * re-registers to Spacewalk\n     */\n    public CobblerSystemCreateCommand(User userIn, Server serverIn, \n            KickstartData ksDataIn, String mediaPathIn, String activationKeysIn) {\n        super(userIn);\n        this.server = serverIn;\n        this.mediaPath = mediaPathIn;\n        if (ksDataIn != null) {\n            profileName = (String)lookupCobblerProfile(ksDataIn).get(\"name\");\n        }\n        else {\n            throw new NullPointerException(\"ksDataIn cant be null\");\n        }\n        this.activationKeys = activationKeysIn;\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor\n     * @param userIn who is requesting the sync\n     * @param serverIn profile we want to create in cobbler\n     * @param nameIn profile nameIn to associate with with server.\n     */\n    public CobblerSystemCreateCommand(User userIn, Server serverIn, \n            String nameIn) {\n        super(userIn);\n        this.server = serverIn;\n        name = nameIn;\n    }","id":88967,"modified_method":"/**\n     * Constructor\n     * @param userIn who is requesting the sync\n     * @param serverIn profile we want to create in cobbler\n     * @param nameIn profile nameIn to associate with with server.\n     */\n    public CobblerSystemCreateCommand(User userIn, Server serverIn, \n            String nameIn) {\n        super(userIn);\n        this.server = serverIn;\n        profileName = nameIn;\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor to be used for a system outside tthe context \n     * of actually kickstarting it to a specific profile.  \n     * @param serverIn profile we want to create in cobbler\n     * @param cobblerProfileName the name of the cobbler profile \n     * to associate with system\n     */\n    public CobblerSystemCreateCommand(Server serverIn, String cobblerProfileName) {\n        super(serverIn.getCreator());\n        this.server = serverIn;\n        this.mediaPath = null;\n        this.name = cobblerProfileName;\n        String note = \"Reactivation key for \" + server.getName() + \".\";\n        ActivationKey key = ActivationKeyManager.getInstance().\n                    createNewReActivationKey(server.getCreator(), server, note);\n        log.debug(\"created reactivation key: \" + key.getKey());\n        this.activationKeys = key.getKey();\n    }","id":88968,"modified_method":"/**\n     * Constructor to be used for a system outside tthe context \n     * of actually kickstarting it to a specific profile.  \n     * @param serverIn profile we want to create in cobbler\n     * @param cobblerProfileName the name of the cobbler profile \n     * to associate with system\n     */\n    public CobblerSystemCreateCommand(Server serverIn, String cobblerProfileName) {\n        super(serverIn.getCreator());\n        this.server = serverIn;\n        this.mediaPath = null;\n        this.profileName = cobblerProfileName;\n        String note = \"Reactivation key for \" + server.getName() + \".\";\n        ActivationKey key = ActivationKeyManager.getInstance().\n                    createNewReActivationKey(server.getCreator(), server, note);\n        log.debug(\"created reactivation key: \" + key.getKey());\n        this.activationKeys = key.getKey();\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Store the System to cobbler\n     * @return ValidatorError if the store failed.\n     */\n    public ValidatorError store() {\n        String handle = null;\n        log.debug(\"Map null?: \" + (getSystemMap() != null));\n        \n        Map systemMp = getSystemMap();\n        if (systemMp != null && !systemMp.isEmpty()) {\n            handle = (String) invokeXMLRPC(\"get_system_handle\",\n                    this.getCobblerSystemRecordName(), xmlRpcToken);\n        }\n        else {\n            handle = (String) invokeXMLRPC(\"new_system\", xmlRpcToken);\n        }\n        \n        log.debug(\"handle: \" + handle);\n        invokeXMLRPC(\"modify_system\", handle, \"name\", getCobblerSystemRecordName(),\n                                 xmlRpcToken);\n        \n        if (this.server.getNetworkInterfaces() == null ||\n                this.server.getNetworkInterfaces().isEmpty()) {\n            return new ValidatorError(\"kickstart.no.network.error\");\n        }\n\n        processNetworkInterfaces(handle, xmlRpcToken, server);\n        \n        Object[] args = new String[]{handle, \"profile\", \n                name, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        if (this.activationKeys == null || this.activationKeys.length() == 0) {\n            log.error(\"This cobbler profile does not \" +\n                \"have a redhat_management_key set \");\n        }\n        else {\n            args = new Object[]{handle, \"redhat_management_key\", \n                    this.activationKeys, xmlRpcToken};\n        }\n\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        // Setup the kickstart metadata so the URLs and activation key are setup\n        Map ksmeta = new HashMap();\n        if (!StringUtils.isBlank(mediaPath)) {\n            ksmeta.put(KickstartUrlHelper.COBBLER_MEDIA_VARIABLE,\n                                                    this.mediaPath);            \n        }\n\n        args = new Object[]{handle, \"ksmeta\", \n                ksmeta, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        invokeXMLRPC(\"save_system\", handle, xmlRpcToken);\n        \n        Map cSystem = getSystemMap();\n        server.setCobblerId((String)cSystem.get(\"uid\"));\n        return null;\n    }","id":88969,"modified_method":"/**\n     * Store the System to cobbler\n     * @return ValidatorError if the store failed.\n     */\n    public ValidatorError store() {\n        String handle = null;\n        // First lookup by MAC addr\n        handle = getSystemHandleByMAC();\n        if (handle == null) {\n            // Next try by name\n            try {\n                handle = (String) invokeXMLRPC(\"get_system_handle\",\n                        getCobblerSystemRecordName(), xmlRpcToken);\n                log.debug(\"Did we find handle by name: \" + handle);\n            } \n            catch (RuntimeException e) {\n                log.debug(\"No system by that name either.  create a new one\");\n            }\n        }\n        // Else, lets make a new system\n        if (handle == null) {\n            handle = (String) invokeXMLRPC(\"new_system\", xmlRpcToken);\n            log.debug(\"handle: \" + handle);\n            invokeXMLRPC(\"modify_system\", handle, \"name\", getCobblerSystemRecordName(),\n                                     xmlRpcToken);\n        }\n        \n        if (this.server.getNetworkInterfaces() == null ||\n                this.server.getNetworkInterfaces().isEmpty()) {\n            return new ValidatorError(\"kickstart.no.network.error\");\n        }\n\n        processNetworkInterfaces(handle, xmlRpcToken, server);\n        \n        Object[] args = new String[]{handle, \"profile\", \n                profileName, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        if (this.activationKeys == null || this.activationKeys.length() == 0) {\n            log.error(\"This cobbler profile does not \" +\n                \"have a redhat_management_key set \");\n        }\n        else {\n            args = new Object[]{handle, \"redhat_management_key\", \n                    this.activationKeys, xmlRpcToken};\n        }\n\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        // Setup the kickstart metadata so the URLs and activation key are setup\n        Map ksmeta = new HashMap();\n        if (!StringUtils.isBlank(mediaPath)) {\n            ksmeta.put(KickstartUrlHelper.COBBLER_MEDIA_VARIABLE,\n                                                    this.mediaPath);            \n        }\n\n        args = new Object[]{handle, \"ksmeta\", \n                ksmeta, xmlRpcToken};\n        invokeXMLRPC(\"modify_system\", Arrays.asList(args));\n        \n        invokeXMLRPC(\"save_system\", handle, xmlRpcToken);\n        \n        Map cSystem = getSystemMapByMac();\n        server.setCobblerId((String)cSystem.get(\"uid\"));\n        return null;\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Invoke an XMLRPC method.\n     * @param procedureName to invoke\n     * @param args to pass to method\n     * @return Object returned.\n     * @throws XmlRpcFault if expected error occurs\n     */\n    public Object invokeMethod(String procedureName, List args) throws XmlRpcFault {\n        log.debug(\"procedure: \" + procedureName + \" Orig ags: \" + args);\n        Object retval;\n        try {\n            log.debug(\"args array: \" + args);\n            retval = client.invoke(procedureName, args);\n        } \n        catch (XmlRpcException e) {\n            throw new RuntimeException(\"XmlRpcException calling cobbler.\", e);\n        } \n        if (retval instanceof String) {\n            retval = retval + \"\\n\";\n        }\n        return retval;\n    }","id":88970,"modified_method":"/**\n     * Invoke an XMLRPC method.\n     * @param procedureName to invoke\n     * @param args to pass to method\n     * @return Object returned.\n     * @throws XmlRpcFault if expected error occurs\n     */\n    public Object invokeMethod(String procedureName, List args) throws XmlRpcFault {\n        log.debug(\"procedure: \" + procedureName + \" Orig ags: \" + args);\n        Object retval;\n        try {\n            retval = client.invoke(procedureName, args);\n        } \n        catch (XmlRpcException e) {\n            throw new RuntimeException(\"XmlRpcException calling cobbler.\", e);\n        } \n        if (retval instanceof String) {\n            retval = retval + \"\\n\";\n        }\n        return retval;\n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Creates a test NetworkInterface object\n     * @param server The server to associate with this network interface\n     * @return Returns a new NetworkInterface object all filled out for testing purposes.\n     * @throws Exception\n     */\n    public static NetworkInterface createTestNetworkInterface(Server server) \n    throws Exception {\n        return createTestNetworkInterface(server, TestUtils.randomString(), \n                \"AA:AA:BB:BB:CC:CC\", \"127.0.0.1\"); \n    }","id":88971,"modified_method":"/**\n     * Creates a test NetworkInterface object\n     * @param server The server to associate with this network interface\n     * @return Returns a new NetworkInterface object all filled out for testing purposes.\n     * @throws Exception\n     */\n    public static NetworkInterface createTestNetworkInterface(Server server) \n    throws Exception {\n        return createTestNetworkInterface(server, TestUtils.randomString(), \n                TEST_MAC, \"127.0.0.1\"); \n    }","commit_id":"f7e5f500832e2fc5c414d94639823234d5e36a46","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n\n        final String controlIdAttributeValue = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"control\"));\n        if (controlIdAttributeValue == null)\n            throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n\n        final XFormsControls.BindingContext bindingContext = xformsControls.getCurrentBindingContext();\n        final String resolvedControlId;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && controlIdAttributeValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedControlId = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), xformsControls, actionElement, controlIdAttributeValue);\n        }\n\n        final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(resolvedControlId);\n        final Object controlObject = containingDocument.getObjectById(pipelineContext, effectiveControlId);\n\n        if (controlObject instanceof XFormsControl) {\n            // Dispatch event to control object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isInfoEnabled())\n                XFormsServer.logger.info(\"XForms - xforms:setfocus does not refer to an existing control: \" + resolvedControlId + \". Ignoring action.\");\n        }\n    }","id":88972,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n\n        final String controlIdAttributeValue = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"control\"));\n        if (controlIdAttributeValue == null)\n            throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n\n        final XFormsControls.BindingContext bindingContext = xformsControls.getCurrentBindingContext();\n        final String resolvedControlId;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && controlIdAttributeValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedControlId = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), xformsControls, actionElement, controlIdAttributeValue);\n        }\n\n        final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(resolvedControlId);\n        final Object controlObject = (effectiveControlId != null) ? containingDocument.getObjectById(pipelineContext, effectiveControlId) : null;\n\n        if (controlObject instanceof XFormsControl) {\n            // Dispatch event to control object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isInfoEnabled())\n                XFormsServer.logger.info(\"XForms - xforms:setfocus does not refer to an existing control: \" + resolvedControlId + \". Ignoring action.\");\n        }\n    }","commit_id":"4580c010b426288412d58ed006137cf579df6adb","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        // Mandatory attributes\n        final String newEventNameAttributeValue = actionElement.attributeValue(\"name\");\n        if (newEventNameAttributeValue == null)\n            throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n        final String newEventTargetIdValue = actionElement.attributeValue(\"target\");\n        if (newEventTargetIdValue == null)\n            throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n        final XFormsContextStack.BindingContext bindingContext = actionInterpreter.getContextStack().getCurrentBindingContext();\n\n        final String resolvedNewEventName;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && newEventNameAttributeValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedNewEventName = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, newEventNameAttributeValue);\n        }\n\n        final String resolvedNewEventTargetId;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && newEventTargetIdValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedNewEventTargetId = XFormsUtils.namespaceId(containingDocument,\n                    XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, newEventTargetIdValue));\n        }\n\n        // Optional attributes\n        final boolean newEventBubbles;\n        {\n            final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n            // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n            // The event factory makes sure that those values are ignored for predefined events\n            newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n        }\n        final boolean newEventCancelable;\n        {\n            // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n            // The event factory makes sure that those values are ignored for predefined events\n            final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n            newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n        }\n\n        // Find actual target\n        final Object xformsEventTarget;\n        {\n            final Object tempXFormsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, resolvedNewEventTargetId);\n            if (tempXFormsEventTarget != null) {\n                // Object with this id exists\n                xformsEventTarget = tempXFormsEventTarget;\n            } else {\n                // Otherwise, try effective id\n                final String newEventTargetEffectiveId = xformsControls.getCurrentControlsState().findEffectiveControlId(resolvedNewEventTargetId);\n                if (newEventTargetEffectiveId != null) {\n                    xformsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetEffectiveId);\n                } else {\n                    xformsEventTarget = null;\n                }\n            }\n        }\n\n        if (xformsEventTarget instanceof XFormsEventTarget) {\n            // Dispatch the event\n            containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(resolvedNewEventName, (XFormsEventTarget) xformsEventTarget, newEventBubbles, newEventCancelable));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n\n            if (XFormsServer.logger.isInfoEnabled())\n                containingDocument.logDebug(\"xforms:dispatch\", \"cannot find target, ignoring action\",\n                        new String[] { \"target id\", resolvedNewEventTargetId } );\n        }\n    }","id":88973,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        // Mandatory attributes\n        final String newEventNameAttributeValue = actionElement.attributeValue(\"name\");\n        if (newEventNameAttributeValue == null)\n            throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n        final String newEventTargetIdValue = actionElement.attributeValue(\"target\");\n        if (newEventTargetIdValue == null)\n            throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n        final XFormsContextStack.BindingContext bindingContext = actionInterpreter.getContextStack().getCurrentBindingContext();\n\n        final String resolvedNewEventName;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && newEventNameAttributeValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedNewEventName = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, newEventNameAttributeValue);\n        }\n\n        final String resolvedNewEventTargetId;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && newEventTargetIdValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedNewEventTargetId = XFormsUtils.namespaceId(containingDocument,\n                    XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, newEventTargetIdValue));\n        }\n\n        // Optional attributes\n        final boolean newEventBubbles;\n        {\n            final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n            // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n            // The event factory makes sure that those values are ignored for predefined events\n            newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n        }\n        final boolean newEventCancelable;\n        {\n            // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n            // The event factory makes sure that those values are ignored for predefined events\n            final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n            newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n        }\n\n        // Find actual target\n        final Object xformsEventTarget;\n        {\n            final Object tempXFormsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, resolvedNewEventTargetId);\n            if (tempXFormsEventTarget != null) {\n                // Object with this id exists\n                xformsEventTarget = tempXFormsEventTarget;\n            } else {\n                // Otherwise, try effective id\n                final String newEventTargetEffectiveId = xformsControls.getCurrentControlsState().findEffectiveControlId(resolvedNewEventTargetId);\n                if (newEventTargetEffectiveId != null) {\n                    xformsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetEffectiveId);\n                } else {\n                    xformsEventTarget = null;\n                }\n            }\n        }\n\n        if (xformsEventTarget instanceof XFormsEventTarget) {\n            // Dispatch the event\n            containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(resolvedNewEventName, (XFormsEventTarget) xformsEventTarget, newEventBubbles, newEventCancelable));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:dispatch\", \"cannot find target, ignoring action\",\n                        new String[] { \"target id\", resolvedNewEventTargetId } );\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContextt) {\n\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        // Find submission object\n        final String submissionId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"submission\"));\n        if (submissionId == null)\n            throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n        final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n\n        if (submission instanceof XFormsModelSubmission) {\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n\n            if (XFormsServer.logger.isInfoEnabled())\n                containingDocument.logDebug(\"xforms:send\", \"submission does not refer to an existing xforms:submission element, ignoring action\",\n                        new String[] { \"submission id\", submissionId } );\n        }\n    }","id":88974,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContextt) {\n\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        // Find submission object\n        final String submissionId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"submission\"));\n        if (submissionId == null)\n            throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n        final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n\n        if (submission instanceof XFormsModelSubmission) {\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:send\", \"submission does not refer to an existing xforms:submission element, ignoring action\",\n                        new String[] { \"submission id\", submissionId } );\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n\n        final String controlIdAttributeValue = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"control\"));\n        if (controlIdAttributeValue == null)\n            throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n\n        final XFormsContextStack.BindingContext bindingContext = actionInterpreter.getContextStack().getCurrentBindingContext();\n        final String resolvedControlId;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && controlIdAttributeValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedControlId = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, controlIdAttributeValue);\n        }\n\n        final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(resolvedControlId);\n        final Object controlObject = (effectiveControlId != null) ? containingDocument.getObjectById(pipelineContext, effectiveControlId) : null;\n\n        if (controlObject instanceof XFormsControl) {\n            // Dispatch event to control object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isInfoEnabled())\n                containingDocument.logDebug(\"xforms:setfocus\", \"control does not refer to an existing control element, ignoring action\",\n                        new String[] { \"control id\", resolvedControlId } );\n        }\n    }","id":88975,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n\n        final String controlIdAttributeValue = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"control\"));\n        if (controlIdAttributeValue == null)\n            throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n\n        final XFormsContextStack.BindingContext bindingContext = actionInterpreter.getContextStack().getCurrentBindingContext();\n        final String resolvedControlId;\n        {\n            // NOP if there is an AVT but no context node\n            if (bindingContext.getSingleNode() == null && controlIdAttributeValue.indexOf('{') != -1)\n                return;\n\n            // Resolve AVT\n            resolvedControlId = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, controlIdAttributeValue);\n        }\n\n        final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(resolvedControlId);\n        final Object controlObject = (effectiveControlId != null) ? containingDocument.getObjectById(pipelineContext, effectiveControlId) : null;\n\n        if (controlObject instanceof XFormsControl) {\n            // Dispatch event to control object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:setfocus\", \"control does not refer to an existing control element, ignoring action\",\n                        new String[] { \"control id\", resolvedControlId } );\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void executeSetindexAction(final PipelineContext pipelineContext, final XFormsContainingDocument containingDocument, final String repeatId, final String indexString) {\n        if (\"NaN\".equals(indexString)) {\n            // \"If the index evaluates to NaN the action has no effect.\"\n            return;\n        }\n\n        final XFormsControls xformsControls = containingDocument.getXFormsControls();\n        xformsControls.rebuildCurrentControlsState(pipelineContext);\n        final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n        final int index = Integer.parseInt(indexString);\n\n        final Map repeatIdToRepeatControl = currentControlsState.getRepeatIdToRepeatXFormsControl();\n        final XFormsRepeatControl repeatControl = (XFormsRepeatControl) repeatIdToRepeatControl.get(repeatId);\n\n        if (repeatControl != null) {\n            // Found control for repeat id\n            if (index <= 0) {\n                // \"If the selected index is 0 or less, an xforms-scroll-first event is dispatched\n                // and the index is set to 1.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsScrollFirstEvent(repeatControl));\n                currentControlsState.updateRepeatIndex(repeatId, 1);\n            } else {\n                final List children = repeatControl.getChildren();\n\n                if (children != null && index > children.size()) {\n                    // \"If the selected index is greater than the index of the last repeat\n                    // item, an xforms-scroll-last event is dispatched and the index is set to\n                    // that of the last item.\"\n\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsScrollLastEvent(repeatControl));\n                    currentControlsState.updateRepeatIndex(repeatId, children.size());\n                } else {\n                    // Otherwise just set the index\n                    currentControlsState.updateRepeatIndex(repeatId, index);\n                }\n            }\n\n            // \"The indexes for inner nested repeat collections are re-initialized to startindex.\"\n            {\n                // First step: set all children indexes to 0\n                final List nestedRepeatIds = currentControlsState.getNestedRepeatIds(xformsControls, repeatId);\n                final Map nestedRepeatIdsMap = new HashMap();\n                if (nestedRepeatIds != null) {\n                    for (Iterator i = nestedRepeatIds.iterator(); i.hasNext();) {\n                        final String currentRepeatId = (String) i.next();\n                        nestedRepeatIdsMap.put(currentRepeatId, \"\");\n                        currentControlsState.updateRepeatIndex(currentRepeatId, 0);\n                    }\n                }\n\n                // Adjust controls ids that could have gone out of bounds\n                XFormsIndexUtils.adjustRepeatIndexes(pipelineContext, xformsControls, nestedRepeatIdsMap);\n            }\n\n            // TODO: \"The implementation data structures for tracking computational dependencies are\n            // rebuilt or updated as a result of this action.\"\n            for (Iterator i = containingDocument.getModels().iterator(); i.hasNext();) {\n                XFormsModel currentModel = (XFormsModel) i.next();\n                currentModel.applyComputedExpressionBinds(pipelineContext);\n            }\n\n            containingDocument.getXFormsControls().markDirtySinceLastRequest();\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isInfoEnabled())\n                containingDocument.logDebug(\"xforms:setindex\", \"index does not refer to an existing xforms:repeat element, ignoring action\",\n                        new String[] { \"repeat id\", repeatId } );\n        }\n    }","id":88976,"modified_method":"public static void executeSetindexAction(final PipelineContext pipelineContext, final XFormsContainingDocument containingDocument, final String repeatId, final String indexString) {\n        if (\"NaN\".equals(indexString)) {\n            // \"If the index evaluates to NaN the action has no effect.\"\n            return;\n        }\n\n        final XFormsControls xformsControls = containingDocument.getXFormsControls();\n        xformsControls.rebuildCurrentControlsState(pipelineContext);\n        final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n        final int index = Integer.parseInt(indexString);\n\n        final Map repeatIdToRepeatControl = currentControlsState.getRepeatIdToRepeatXFormsControl();\n        final XFormsRepeatControl repeatControl = (XFormsRepeatControl) repeatIdToRepeatControl.get(repeatId);\n\n        if (repeatControl != null) {\n            // Found control for repeat id\n            if (index <= 0) {\n                // \"If the selected index is 0 or less, an xforms-scroll-first event is dispatched\n                // and the index is set to 1.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsScrollFirstEvent(repeatControl));\n                currentControlsState.updateRepeatIndex(repeatId, 1);\n            } else {\n                final List children = repeatControl.getChildren();\n\n                if (children != null && index > children.size()) {\n                    // \"If the selected index is greater than the index of the last repeat\n                    // item, an xforms-scroll-last event is dispatched and the index is set to\n                    // that of the last item.\"\n\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsScrollLastEvent(repeatControl));\n                    currentControlsState.updateRepeatIndex(repeatId, children.size());\n                } else {\n                    // Otherwise just set the index\n                    currentControlsState.updateRepeatIndex(repeatId, index);\n                }\n            }\n\n            // \"The indexes for inner nested repeat collections are re-initialized to startindex.\"\n            {\n                // First step: set all children indexes to 0\n                final List nestedRepeatIds = currentControlsState.getNestedRepeatIds(xformsControls, repeatId);\n                final Map nestedRepeatIdsMap = new HashMap();\n                if (nestedRepeatIds != null) {\n                    for (Iterator i = nestedRepeatIds.iterator(); i.hasNext();) {\n                        final String currentRepeatId = (String) i.next();\n                        nestedRepeatIdsMap.put(currentRepeatId, \"\");\n                        currentControlsState.updateRepeatIndex(currentRepeatId, 0);\n                    }\n                }\n\n                // Adjust controls ids that could have gone out of bounds\n                XFormsIndexUtils.adjustRepeatIndexes(pipelineContext, xformsControls, nestedRepeatIdsMap);\n            }\n\n            // TODO: \"The implementation data structures for tracking computational dependencies are\n            // rebuilt or updated as a result of this action.\"\n            for (Iterator i = containingDocument.getModels().iterator(); i.hasNext();) {\n                XFormsModel currentModel = (XFormsModel) i.next();\n                currentModel.applyComputedExpressionBinds(pipelineContext);\n            }\n\n            containingDocument.getXFormsControls().markDirtySinceLastRequest();\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:setindex\", \"index does not refer to an existing xforms:repeat element, ignoring action\",\n                        new String[] { \"repeat id\", repeatId } );\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final XFormsContextStack contextStack = actionInterpreter.getContextStack();\n        final XFormsContextStack.BindingContext bindingContext = contextStack.getCurrentBindingContext();\n\n        final String caseAttribute = actionElement.attributeValue(\"case\");\n        if (caseAttribute == null)\n            throw new OXFException(\"Missing mandatory case attribute on xforms:toggle element.\");\n\n        final String caseId;\n        if (bindingContext.getSingleNode() != null) {\n            final String resolvedCaseId = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, caseAttribute);\n            caseId = XFormsUtils.namespaceId(containingDocument, resolvedCaseId);\n        } else {\n            // TODO: Presence of context is not the right way to decide whether to evaluate AVTs or not\n            caseId = caseAttribute;\n        }\n\n        final String effectiveCaseId = xformsControls.findEffectiveCaseId(caseId);\n\n        if (effectiveCaseId != null) { // can be null if the switch is not relevant\n            // Update xforms:switch info and dispatch events\n            xformsControls.activateCase(pipelineContext, effectiveCaseId);\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isInfoEnabled())\n                containingDocument.logDebug(\"xforms:toggle\", \"case does not refer to an existing xforms:case element, ignoring action\",\n                        new String[] { \"case id\", caseId } );\n        }\n    }","id":88977,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final XFormsContextStack contextStack = actionInterpreter.getContextStack();\n        final XFormsContextStack.BindingContext bindingContext = contextStack.getCurrentBindingContext();\n\n        final String caseAttribute = actionElement.attributeValue(\"case\");\n        if (caseAttribute == null)\n            throw new OXFException(\"Missing mandatory case attribute on xforms:toggle element.\");\n\n        final String caseId;\n        if (bindingContext.getSingleNode() != null) {\n            final String resolvedCaseId = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, bindingContext.getSingleNode(),\n                    null, XFormsContainingDocument.getFunctionLibrary(), actionInterpreter.getFunctionContext(), actionElement, caseAttribute);\n            caseId = XFormsUtils.namespaceId(containingDocument, resolvedCaseId);\n        } else {\n            // TODO: Presence of context is not the right way to decide whether to evaluate AVTs or not\n            caseId = caseAttribute;\n        }\n\n        final String effectiveCaseId = xformsControls.findEffectiveCaseId(caseId);\n\n        if (effectiveCaseId != null) { // can be null if the switch is not relevant\n            // Update xforms:switch info and dispatch events\n            xformsControls.activateCase(pipelineContext, effectiveCaseId);\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:toggle\", \"case does not refer to an existing xforms:case element, ignoring action\",\n                        new String[] { \"case id\", caseId } );\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n\n        if (dialogId != null) {\n            // Dispatch xxforms-dialog-close event to dialog\n            containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogCloseEvent((XFormsEventTarget) xformsControls.getObjectById(dialogId)));\n        }\n    }","id":88978,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n\n        if (dialogId != null) {\n            // Dispatch xxforms-dialog-close event to dialog\n            final Object controlObject = (dialogId != null) ? xformsControls.getObjectById(dialogId) : null;\n            if (controlObject instanceof XXFormsDialogControl) {\n                containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogCloseEvent((XFormsEventTarget) controlObject));\n            } else {\n                if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xxforms:hide\", \"dialog does not refer to an existing xxforms:dialog element, ignoring action\",\n                        new String[] { \"dialog id\", dialogId } );\n            }\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n        final String neighbor = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"neighbor\"));\n        final boolean constrainToViewport = !\"false\".equals(actionElement.attributeValue(\"constrain\"));\n\n        if (dialogId != null) {\n            // Dispatch xxforms-dialog-open event to dialog\n            containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogOpenEvent((XFormsEventTarget) xformsControls.getObjectById(dialogId), neighbor, constrainToViewport));\n        }\n    }","id":88979,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PipelineContext pipelineContext, String targetId,\n                        XFormsEventHandlerContainer eventHandlerContainer, Element actionElement,\n                        boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsControls xformsControls = actionInterpreter.getXFormsControls();\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final String dialogId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"dialog\"));\n        final String neighbor = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"neighbor\"));\n        final boolean constrainToViewport = !\"false\".equals(actionElement.attributeValue(\"constrain\"));\n\n        if (dialogId != null) {\n            // Dispatch xxforms-dialog-open event to dialog\n            final Object controlObject = (dialogId != null) ? xformsControls.getObjectById(dialogId) : null;\n            if (controlObject instanceof XXFormsDialogControl) {\n                containingDocument.dispatchEvent(pipelineContext, new XXFormsDialogOpenEvent((XFormsEventTarget) controlObject, neighbor, constrainToViewport));\n            } else {\n                if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xxforms:show\", \"dialog does not refer to an existing xxforms:dialog element, ignoring action\",\n                        new String[] { \"dialog id\", dialogId } );\n            }\n        }\n    }","commit_id":"519fa04619ec061caedc19daa739e098b5adb13a","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    //copied from IDEA's class EditorSearchComponent\n    Graphics2D g2d = (Graphics2D) g;\n    final Color GRADIENT_C1 = getBackground();\n    final Color GRADIENT_C2 = new Color(Math.max(0, GRADIENT_C1.getRed() - 0x18),\n      Math.max(0, GRADIENT_C1.getGreen() - 0x18),\n      Math.max(0, GRADIENT_C1.getBlue() - 0x18));\n    g2d.setPaint(new GradientPaint(0, 0, GRADIENT_C1, 0, getHeight(), GRADIENT_C2));\n    g2d.fillRect(1, 1, getWidth(), getHeight() - 1);\n  }","id":88980,"modified_method":"@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    //copied from IDEA's class EditorSearchComponent\n    Graphics2D g2d = (Graphics2D) g;\n    final Color BORDER_COLOR = new Color(0x87, 0x87, 0x87);\n    final Color GRADIENT_C1 = getBackground();\n    final Color GRADIENT_C2 = new Color(Math.max(0, GRADIENT_C1.getRed() - 0x18),\n      Math.max(0, GRADIENT_C1.getGreen() - 0x18),\n      Math.max(0, GRADIENT_C1.getBlue() - 0x18));\n    g2d.setPaint(new GradientPaint(0, 0, GRADIENT_C1, 0, getHeight(), GRADIENT_C2));\n    g2d.fillRect(1, 1, getWidth(), getHeight() - 1);\n    g.setColor(BORDER_COLOR);\n    g2d.setPaint(null);\n    g.drawLine(0, getHeight() - 1, getWidth(), getHeight() - 1);\n  }","commit_id":"6a2a5e980135d202d08ba1a5ba90ab58fda45d0d","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected AbstractSearchPanel() {\n\n    setLayout(new BorderLayout());\n    setPreferredSize(new Dimension((int) getPreferredSize().getWidth(),\n      (int) myText.getPreferredSize().getHeight() + 5));\n\n    JPanel mainPanel = new JPanel();\n    FlowLayout layout = new FlowLayout();\n    layout.setVgap(0);\n    mainPanel.setLayout(layout);\n    mainPanel.setOpaque(false);\n\n    mainPanel.add(new JLabel(\"Text:\"));\n    mainPanel.add(myText);\n    myText.setHideCompletionOnClick(true);\n\n    DefaultActionGroup group = new DefaultActionGroup(\"search bar\", false);\n    group.add(new ShowHistoryAction());\n    group.add(new PrevOccurenceAction());\n    group.add(new NextOccurenceAction());\n\n    final ActionToolbar tb = ActionManager.getInstance().createActionToolbar(\"SearchBar\", group, true);\n    tb.setLayoutPolicy(ActionToolbar.NOWRAP_LAYOUT_POLICY);\n    myToolbarComponent = tb.getComponent();\n    myToolbarComponent.setBorder(null);\n    myToolbarComponent.setOpaque(false);\n\n    mainPanel.add(myToolbarComponent);\n\n    mainPanel.add(myIsCaseSensitive);\n    myIsCaseSensitive.setOpaque(false);\n    myIsCaseSensitive.setMnemonic(KeyEvent.VK_C);\n    myIsCaseSensitive.setFocusable(false);\n    myIsCaseSensitive.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        search();\n      }\n    });\n\n    mainPanel.add(myIsWordsOnly);\n    myIsWordsOnly.setOpaque(false);\n    myIsWordsOnly.setMnemonic(KeyEvent.VK_M);\n    myIsWordsOnly.setFocusable(false);\n    myIsWordsOnly.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        search();\n      }\n    });\n\n    mainPanel.add(myIsRegex);\n    myIsRegex.setOpaque(false);\n    myIsRegex.setMnemonic(KeyEvent.VK_R);\n    myIsRegex.setFocusable(false);\n    myIsRegex.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        myIsWordsOnly.setEnabled(!myIsWordsOnly.isEnabled());\n      }\n    });\n\n    add(mainPanel, BorderLayout.LINE_START);\n\n    JLabel escapeLabel = new JLabel(Icons.ESCAPE_ICON);\n    JPanel eastPanel = new JPanel();\n    eastPanel.add(myFindResult);\n    eastPanel.setOpaque(false);\n    eastPanel.setLayout(new FlowLayout(FlowLayout.LEFT));\n    eastPanel.add(escapeLabel);\n    add(eastPanel, BorderLayout.LINE_END);\n\n    escapeLabel.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        deactivate();\n      }\n    });\n\n    myText.getDocument().addDocumentListener(new DocumentListener() {\n      public void insertUpdate(DocumentEvent e) {\n        search();\n      }\n\n      public void removeUpdate(DocumentEvent e) {\n        search();\n      }\n\n      public void changedUpdate(DocumentEvent e) {\n        search();\n      }\n    });\n\n    myText.setColumns(20);\n\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        goDown();\n      }\n    }, KeyStroke.getKeyStroke(\"DOWN\"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        goUp();\n      }\n    }, KeyStroke.getKeyStroke(\"UP\"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    setVisible(false);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        deactivate();\n      }\n    }, KeyStroke.getKeyStroke(\"ESCAPE\"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n  }","id":88981,"modified_method":"protected AbstractSearchPanel() {\n    super(new BorderLayout(0, 0));\n    setPreferredSize(new Dimension((int) getPreferredSize().getWidth(),\n      (int) myText.getPreferredSize().getHeight() + 5));\n\n    JPanel mainPanel = new NonOpaquePanel(new FlowLayout(FlowLayout.LEFT, 5, 0));\n    mainPanel.add(new JLabel(\"Text:\"));\n    mainPanel.add(myText);\n    myText.setHideCompletionOnClick(true);\n    setSmallerFont(myText);\n\n    DefaultActionGroup group = new DefaultActionGroup(\"search bar\", false);\n    group.add(new ShowHistoryAction());\n    group.add(new PrevOccurenceAction());\n    group.add(new NextOccurenceAction());\n\n    final ActionToolbar tb = ActionManager.getInstance().createActionToolbar(\"SearchBar\", group, true);\n    tb.setLayoutPolicy(ActionToolbar.NOWRAP_LAYOUT_POLICY);\n    myToolbarComponent = tb.getComponent();\n    myToolbarComponent.setBorder(null);\n    myToolbarComponent.setOpaque(false);\n\n    mainPanel.add(myToolbarComponent);\n\n    mainPanel.add(myIsCaseSensitive);\n    myIsCaseSensitive.setMnemonic(KeyEvent.VK_C);\n    myIsCaseSensitive.setFocusable(false);\n    myIsCaseSensitive.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        search();\n      }\n    });\n\n    mainPanel.add(myIsWordsOnly);\n    myIsWordsOnly.setMnemonic(KeyEvent.VK_M);\n    myIsWordsOnly.setFocusable(false);\n    myIsWordsOnly.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        search();\n      }\n    });\n\n    mainPanel.add(myIsRegex);\n    myIsRegex.setMnemonic(KeyEvent.VK_R);\n    myIsRegex.setFocusable(false);\n    myIsRegex.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        myIsWordsOnly.setEnabled(!myIsWordsOnly.isEnabled());\n      }\n    });\n\n    this.add(mainPanel, BorderLayout.WEST);    \n\n    JPanel tailPanel = new NonOpaquePanel(new BorderLayout(5, 0));\n    JPanel tailContainer = new NonOpaquePanel(new BorderLayout(5, 0));\n    JLabel escapeLabel = new JLabel(Icons.ESCAPE_ICON);\n\n    tailPanel.add(myFindResult, BorderLayout.CENTER);\n    tailPanel.add(escapeLabel, BorderLayout.EAST);\n\n    tailContainer.add(tailPanel, BorderLayout.EAST);\n    this.add(tailContainer, BorderLayout.CENTER);\n\n    escapeLabel.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        deactivate();\n      }\n    });\n\n    setSmallerFontAndOpaque(myIsWordsOnly);\n    setSmallerFontAndOpaque(myIsCaseSensitive);\n    setSmallerFontAndOpaque(myIsRegex);\n    setSmallerFontAndOpaque(myFindResult);\n\n    myText.getDocument().addDocumentListener(new DocumentListener() {\n      public void insertUpdate(DocumentEvent e) {\n        search();\n      }\n\n      public void removeUpdate(DocumentEvent e) {\n        search();\n      }\n\n      public void changedUpdate(DocumentEvent e) {\n        search();\n      }\n    });\n\n    myText.setColumns(20);\n\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        goDown();\n      }\n    }, KeyStroke.getKeyStroke(\"DOWN\"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        goUp();\n      }\n    }, KeyStroke.getKeyStroke(\"UP\"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n    setVisible(false);\n\n    registerKeyboardAction(new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        deactivate();\n      }\n    }, KeyStroke.getKeyStroke(\"ESCAPE\"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n  }","commit_id":"6a2a5e980135d202d08ba1a5ba90ab58fda45d0d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void testFeatures() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        Set<Container> containers = ContainerBuilder.create().withName(\"feature-camel\").withProfiles(\"feature-camel\").assertProvisioningResult().build();\n        assertProvisionedFeature(containers, \"camel-hazelcast\", \"feature-camel\", \"camel-hazelcast\");\n    }","id":88982,"modified_method":"@Test\n    public void testFeatures() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        Set<Container> containers = ContainerBuilder.create().withName(\"feature-camel\").withProfiles(\"feature-camel\").assertProvisioningResult().build();\n        assertProvisionedFeature(containers, \"camel-http\", \"feature-camel\", \"camel-http\");\n        //assertProvisionedFeature(containers, \"camel-jetty\", \"feature-camel\", \"camel-jetty\");\n        assertProvisionedFeature(containers, \"camel-jms\", \"feature-camel\", \"camel-jms\");\n        assertProvisionedFeature(containers, \"camel-ftp\", \"feature-camel\", \"camel-ftp\");\n        assertProvisionedFeature(containers, \"camel-quartz\", \"feature-camel\", \"camel-quartz\");\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testExample() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        Set<Container> containers = ContainerBuilder.create().withName(\"child\").withProfiles(\"example-camel-cxf\").assertProvisioningResult().build();\n\t\tSystem.err.println(executeCommand(\"fabric:container-list\"));\n\n        for (final Container container : containers) {\n            Provision.waitForCondition(new Callable<Boolean>() {\n                @Override\n                public Boolean call() throws Exception {\n                    String response = new AnsiString(executeCommand(\"fabric:container-connect -u admin -p admin \"+container.getId()+\" camel:route-list | grep fabric-camel-cxf\")).getPlain().toString();\n                    return response.contains(\"fabric-camel-cxf\");\n                }\n            }, 10000L);\n\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \"+container.getId()+\" osgi:list\"));\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \"+container.getId()+\" camel:route-list\"));\n        }\n    }","id":88983,"modified_method":"@Test\n    public void testExample() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        Set<Container> containers = ContainerBuilder.create().withName(\"child\").withProfiles(\"example-camel-cxf\").assertProvisioningResult().build();\n\t\tSystem.err.println(executeCommand(\"fabric:container-list\"));\n\n\n        assertTrue(Provision.waitForCondition(containers, new ContainerCondition() {\n            @Override\n            public Boolean checkConditionOnContainer(final Container c) {\n                String response = new AnsiString(executeCommand(\"fabric:container-connect -u admin -p admin \"+c.getId()+\" camel:route-list | grep fabric-camel-cxf\")).getPlain().toString();\n                return response.contains(\"fabric-camel-cxf\");\n            }\n        }, 10000L));\n\n        for (Container container : containers) {\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" osgi:list\"));\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" camel:route-list\"));\n        }\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testExample() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        CuratorFramework curator = getCurator();\n        Set<Container> containers = ContainerBuilder.create(2).withName(\"cnt\").withProfiles(\"default\").assertProvisioningResult().build();\n        Container broker = containers.iterator().next();\n        containers.remove(broker);\n\n        setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(broker.getId()), \"changing\");\n        System.err.println(executeCommand(\"fabric:container-change-profile \" + broker.getId() + \" mq-default\"));\n        Provision.provisioningSuccess(Arrays.asList(new Container[]{broker}), PROVISION_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:cluster-list\"));\n\n        for(Container c : containers) {\n            setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing\");\n            System.err.println(executeCommand(\"fabric:container-change-profile \" + c.getId() + \" example-camel\"));\n        }\n        Provision.provisioningSuccess(containers, PROVISION_TIMEOUT);\n\n        int completedCount = 0;\n        Thread.sleep(5000);\n        for (Container c : containers) {\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \"+c.getId()+\" osgi:list\"));\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \"+c.getId()+\" camel:route-list\"));\n            String completed = executeCommand(\"fabric:container-connect -u admin -p admin \"+c.getId()+\" camel:route-info route2 | grep \\\"Exchanges Completed\\\"\");\n            System.err.println(completed);\n            if (completed.contains(\"Exchanges Completed\") && !completed.contains(\"Exchanges Completed: 0\")) {\n                completedCount++;\n            }\n        }\n\n        Assert.assertTrue(\"Expected at least 1 completed exchange. Found: \"+ completedCount, completedCount > 0);\n    }","id":88984,"modified_method":"@Test\n    public void testExample() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        CuratorFramework curator = getCurator();\n        Set<Container> containers = ContainerBuilder.create(2).withName(\"cnt\").withProfiles(\"default\").assertProvisioningResult().build();\n        Container broker = containers.iterator().next();\n        containers.remove(broker);\n\n        setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(broker.getId()), \"changing\");\n        System.err.println(executeCommand(\"fabric:container-change-profile \" + broker.getId() + \" mq-default\"));\n        Provision.provisioningSuccess(Arrays.asList(new Container[]{broker}), PROVISION_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:cluster-list\"));\n\n        for(Container c : containers) {\n            setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing\");\n            System.err.println(executeCommand(\"fabric:container-change-profile \" + c.getId() + \" example-camel-mq\"));\n        }\n        Provision.provisioningSuccess(containers, PROVISION_TIMEOUT);\n\n        assertTrue(Provision.waitForCondition(containers, new ContainerCondition() {\n            @Override\n            public Boolean checkConditionOnContainer(final Container c) {\n                System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" osgi:list\"));\n                System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" camel:route-list\"));\n                String completed = executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" camel:route-info route2 | grep \\\"Exchanges Completed\\\"\");\n                System.err.println(completed);\n                if (completed.contains(\"Exchanges Completed\") && !completed.contains(\"Exchanges Completed: 0\")) {\n                    return true;\n                } else {\n                    return false;\n                }\n\n            }\n        }, 5000L));\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return fabricDistributionConfiguration();\n    }","id":88985,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                new DefaultCompositeOption(fabricDistributionConfiguration()),\n                debugConfiguration(\"5005\",false)\n        };\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testExample() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        CuratorFramework curator = getCurator();\n        Set<Container> containers = ContainerBuilder.create(2).withName(\"cnt\").withProfiles(\"default\").assertProvisioningResult().build();\n        Container broker = containers.iterator().next();\n        containers.remove(broker);\n\n        setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(broker.getId()), \"changing\");\n        System.err.println(executeCommand(\"fabric:container-change-profile \" + broker.getId() + \" mq-default\"));\n        Provision.provisioningSuccess(Arrays.asList(new Container[]{broker}), PROVISION_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:cluster-list\"));\n\n        for(Container c : containers) {\n            setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing\");\n            System.err.println(executeCommand(\"fabric:container-change-profile \" + c.getId() + \" example-mq\"));\n        }\n        Provision.provisioningSuccess(containers, PROVISION_TIMEOUT);\n\n        System.err.println(executeCommand(\"fabric:cluster-list\"));\n        System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \"+broker.getId()+\" activemq:bstat\"));\n        String output = executeCommand(\"fabric:container-connect -u admin -p admin \"+broker.getId()+\" activemq:query -QQueue=FABRIC.DEMO\");\n        Assert.assertTrue(output.contains(\"DequeueCount = \") && !output.contains(\"DequeueCount = 0\"));\n    }","id":88986,"modified_method":"@Test\n    public void testExample() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        CuratorFramework curator = getCurator();\n        Set<Container> containers = ContainerBuilder.create(2).withName(\"cnt\").withProfiles(\"default\").assertProvisioningResult().build();\n        Container broker = containers.iterator().next();\n        containers.remove(broker);\n\n        setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(broker.getId()), \"changing\");\n        System.err.println(executeCommand(\"fabric:container-change-profile \" + broker.getId() + \" mq-default\"));\n        Provision.provisioningSuccess(Arrays.asList(new Container[]{broker}), PROVISION_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:cluster-list\"));\n\n        for(Container c : containers) {\n            setData(curator, ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing\");\n            System.err.println(executeCommand(\"fabric:container-change-profile \" + c.getId() + \" example-mq\"));\n        }\n        Provision.provisioningSuccess(containers, PROVISION_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:cluster-list\"));\n\n        assertTrue(Provision.waitForCondition(Arrays.asList(new Container[]{broker}), new ContainerCondition() {\n            @Override\n            public Boolean checkConditionOnContainer(final Container c) {\n                System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \"+c.getId()+\" activemq:bstat\"));\n                String output = executeCommand(\"fabric:container-connect -u admin -p admin \"+c.getId()+\" activemq:query -QQueue=FABRIC.DEMO\");\n                return output.contains(\"DequeueCount = \") && !output.contains(\"DequeueCount = 0\");\n            }\n        }, 10000L));\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testFeatureProvisioning() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n root\"));\n        waitForFabricCommands();\n\n        Set<Container> containers = ContainerBuilder.create(2).withName(\"dosgi\").withProfiles(\"example-dosgi-camel\").assertProvisioningResult().build();\n        List<Container> containerList = new ArrayList<Container>(containers);\n        List<Container> dosgiProviderContainers = containerList.subList(0, containerList.size() / 2);\n        List<Container> dosgiCamelContainers = containerList.subList(containerList.size() / 2, containerList.size());\n\n\n\n        for (Container c : dosgiProviderContainers) {\n            setData(getCurator(), ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing profile\");\n            Profile p = c.getVersion().getProfile(\"example-dosgi-camel.provider\");\n            c.setProfiles(new Profile[]{p});\n        }\n\n        for (Container c : dosgiCamelContainers) {\n            setData(getCurator(), ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing profile\");\n            Profile p = c.getVersion().getProfile(\"example-dosgi-camel.consumer\");\n            c.setProfiles(new Profile[]{p});\n        }\n\n        Provision.provisioningSuccess(dosgiProviderContainers, PROVISION_TIMEOUT);\n        Provision.provisioningSuccess(dosgiCamelContainers, PROVISION_TIMEOUT);\n\n        Thread.sleep(20000L);\n        for (Container c : dosgiCamelContainers) {\n            String response = executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" log:display | grep \\\"Message from distributed service to\\\"\");\n            System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" camel:route-info fabric-client\"));\n            assertNotNull(response);\n            System.err.println(response);\n            String[] lines = response.split(\"\\n\");\n            assertTrue(\"At least one message is expected\", lines.length >= 1);\n        }\n    }","id":88987,"modified_method":"@Test\n    public void testFeatureProvisioning() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n root\"));\n        waitForFabricCommands();\n\n        Set<Container> containers = ContainerBuilder.create(2).withName(\"dosgi\").withProfiles(\"example-dosgi-camel\").assertProvisioningResult().build();\n        List<Container> containerList = new ArrayList<Container>(containers);\n        List<Container> dosgiProviderContainers = containerList.subList(0, containerList.size() / 2);\n        List<Container> dosgiCamelContainers = containerList.subList(containerList.size() / 2, containerList.size());\n\n\n\n        for (Container c : dosgiProviderContainers) {\n            setData(getCurator(), ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing profile\");\n            Profile p = c.getVersion().getProfile(\"example-dosgi-camel.provider\");\n            c.setProfiles(new Profile[]{p});\n        }\n\n        for (Container c : dosgiCamelContainers) {\n            setData(getCurator(), ZkPath.CONTAINER_PROVISION_RESULT.getPath(c.getId()), \"changing profile\");\n            Profile p = c.getVersion().getProfile(\"example-dosgi-camel.consumer\");\n            c.setProfiles(new Profile[]{p});\n        }\n\n        Provision.provisioningSuccess(dosgiProviderContainers, PROVISION_TIMEOUT);\n        Provision.provisioningSuccess(dosgiCamelContainers, PROVISION_TIMEOUT);\n\n        assertTrue(Provision.waitForCondition(dosgiCamelContainers, new ContainerCondition() {\n            @Override\n            public Boolean checkConditionOnContainer(final Container c) {\n                String response = executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" log:display | grep \\\"Message from distributed service to\\\"\");\n                System.err.println(executeCommand(\"fabric:container-connect -u admin -p admin \" + c.getId() + \" camel:route-info fabric-client\"));\n                assertNotNull(response);\n                System.err.println(response);\n                String[] lines = response.split(\"\\n\");\n                //TODO: This assertion is very relaxed and guarantees nothing.\n                return lines.length >= 1;\n            }\n        }, 20000L));\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public WaitForConditionTask(Long timeOut, Callable<Boolean> condition) {\n        this.timeOut = timeOut;\n        this.condition = condition;\n    }","id":88988,"modified_method":"public WaitForConditionTask(Callable<Boolean> condition, Long timeOut) {\n        this.timeOut = timeOut;\n        this.condition = condition;\n    }","commit_id":"c2f699a33469d416805b02f26bf80d1312d9de87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Set<CreateContainerChildMetadata> create(final CreateContainerChildOptions options) throws Exception {\n        final Set<CreateContainerChildMetadata> result = new LinkedHashSet<CreateContainerChildMetadata>();\n        String parentName = options.getParent();\n        final Container parent = service.getContainer(parentName);\n        ContainerTemplate containerTemplate = service.getContainerTemplate(parent);\n\n        //Retrieve the credentials from the URI if available.\n        if (options.getProviderURI() != null && options.getProviderURI().getUserInfo() != null) {\n            String ui = options.getProviderURI().getUserInfo();\n            String[] uip = ui != null ? ui.split(\":\") : null;\n            if (uip != null) {\n                containerTemplate.setLogin(uip[0]);\n                containerTemplate.setPassword(uip[1]);\n            }\n        }\n\n        containerTemplate.execute(new ContainerTemplate.AdminServiceCallback<Object>() {\n            public Object doWithAdminService(AdminServiceMBean adminService) throws Exception {\n                StringBuilder jvmOptsBuilder = new StringBuilder();\n\n                if (options.getJvmOpts() != null && !options.getJvmOpts().isEmpty()) {\n                    jvmOptsBuilder.append(options.getJvmOpts()).append(\" \");\n                }\n\n                jvmOptsBuilder.append(\"-server -Dcom.sun.management.jmxremote \")\n                        .append(options.getZookeeperUrl() != null ? \"-Dzookeeper.url=\\\"\" + options.getZookeeperUrl() + \"\\\"\" : \"\");\n\n                if (options.getJvmOpts() == null || !options.getJvmOpts().contains(\"-Xmx\")) {\n                    jvmOptsBuilder.append(\" -Xmx512m\");\n                } else if (options.getJvmOpts() != null) {\n                    jvmOptsBuilder.append(\" \").append(options.getJvmOpts());\n                }\n\n                if (options.isEnsembleServer()) {\n                    jvmOptsBuilder.append(\" \").append(ENSEMBLE_SERVER_CONTAINER);\n                }\n                String features = \"fabric-agent\";\n                String featuresUrls = \"mvn:org.fusesource.fabric/fuse-fabric/\" + FabricConstants.FABRIC_VERSION + \"/xml/features\";\n                String originalName = new String(options.getName());\n                usedPorts.addAll(getContainerUsedPorts(parent));\n\n                for (int i = 1; i <= options.getNumber(); i++) {\n                    String containerName;\n                    if (options.getNumber() > 1) {\n                        containerName = originalName + i;\n                    } else {\n                        containerName = originalName;\n                    }\n                    CreateContainerChildMetadata metadata = new CreateContainerChildMetadata();\n\n                    metadata.setCreateOptions(options);\n                    metadata.setContainerName(containerName);\n                    int minimumPort = parent.getMinimumPort();\n                    int maximumPort = parent.getMaximumPort();\n\n                    ZooKeeperUtils.set(service.getZooKeeper(), ZkPath.CONTAINER_PORT_MIN.getPath(containerName), String.valueOf(minimumPort));\n                    ZooKeeperUtils.set(service.getZooKeeper(), ZkPath.CONTAINER_PORT_MAX.getPath(containerName), String.valueOf(maximumPort));\n\n                    //This is not enough as it will not work if children has been created and then deleted.\n                    //The admin service should be responsible for allocating ports\n                    int sshPort = mapPortToRange(8101 + i, minimumPort, maximumPort);\n                    while (usedPorts.contains(sshPort)) {\n                        sshPort++;\n                    }\n                    usedPorts.add(sshPort);\n\n\n                    int rmiServerPort = mapPortToRange(44444 + i, minimumPort, maximumPort);\n                    while (usedPorts.contains(rmiServerPort)) {\n                        rmiServerPort++;\n                    }\n                    usedPorts.add(rmiServerPort);\n                    int rmiRegistryPort = mapPortToRange(1099 + i, minimumPort, maximumPort);\n                    while (usedPorts.contains(rmiRegistryPort)) {\n                        rmiRegistryPort++;\n                    }\n                    usedPorts.add(rmiRegistryPort);\n\n                    try {\n                        adminService.createInstance(containerName,\n                                sshPort,\n                                rmiServerPort,\n                                rmiRegistryPort, null, jvmOptsBuilder.toString(), features, featuresUrls);\n                        adminService.startInstance(containerName, null);\n                    } catch (Throwable t) {\n                        metadata.setFailure(t);\n                    }\n                    result.add(metadata);\n                }\n                return null;\n            }\n        });\n        return result;\n    }","id":88989,"modified_method":"@Override\n    public Set<CreateContainerChildMetadata> create(final CreateContainerChildOptions options) throws Exception {\n        final Set<CreateContainerChildMetadata> result = new LinkedHashSet<CreateContainerChildMetadata>();\n        final String parentName = options.getParent();\n        final Container parent = service.getContainer(parentName);\n        ContainerTemplate containerTemplate = service.getContainerTemplate(parent);\n\n        //Retrieve the credentials from the URI if available.\n        if (options.getProviderURI() != null && options.getProviderURI().getUserInfo() != null) {\n            String ui = options.getProviderURI().getUserInfo();\n            String[] uip = ui != null ? ui.split(\":\") : null;\n            if (uip != null) {\n                containerTemplate.setLogin(uip[0]);\n                containerTemplate.setPassword(uip[1]);\n            }\n        }\n\n        containerTemplate.execute(new ContainerTemplate.AdminServiceCallback<Object>() {\n            public Object doWithAdminService(AdminServiceMBean adminService) throws Exception {\n                StringBuilder jvmOptsBuilder = new StringBuilder();\n\n                if (options.getJvmOpts() != null && !options.getJvmOpts().isEmpty()) {\n                    jvmOptsBuilder.append(options.getJvmOpts()).append(\" \");\n                }\n\n                jvmOptsBuilder.append(\"-server -Dcom.sun.management.jmxremote \")\n                        .append(options.getZookeeperUrl() != null ? \"-Dzookeeper.url=\\\"\" + options.getZookeeperUrl() + \"\\\"\" : \"\");\n\n                if (options.getJvmOpts() == null || !options.getJvmOpts().contains(\"-Xmx\")) {\n                    jvmOptsBuilder.append(\" -Xmx512m\");\n                } else if (options.getJvmOpts() != null) {\n                    jvmOptsBuilder.append(\" \").append(options.getJvmOpts());\n                }\n\n                if (options.isEnsembleServer()) {\n                    jvmOptsBuilder.append(\" \").append(ENSEMBLE_SERVER_CONTAINER);\n                }\n                String features = \"fabric-agent\";\n                String featuresUrls = \"mvn:org.fusesource.fabric/fuse-fabric/\" + FabricConstants.FABRIC_VERSION + \"/xml/features\";\n                String originalName = new String(options.getName());\n                usedPorts.addAll(getContainerUsedPorts(parent));\n\n                for (int i = 1; i <= options.getNumber(); i++) {\n                    String containerName;\n                    if (options.getNumber() > 1) {\n                        containerName = originalName + i;\n                    } else {\n                        containerName = originalName;\n                    }\n                    CreateContainerChildMetadata metadata = new CreateContainerChildMetadata();\n\n                    metadata.setCreateOptions(options);\n                    metadata.setContainerName(containerName);\n                    int minimumPort = parent.getMinimumPort();\n                    int maximumPort = parent.getMaximumPort();\n\n                    ZooKeeperUtils.set(service.getZooKeeper(), ZkPath.CONTAINER_PORT_MIN.getPath(containerName), String.valueOf(minimumPort));\n                    ZooKeeperUtils.set(service.getZooKeeper(), ZkPath.CONTAINER_PORT_MAX.getPath(containerName), String.valueOf(maximumPort));\n\n                    inheritAddresses(service.getZooKeeper(), parentName, containerName, options);\n\n                    //This is not enough as it will not work if children has been created and then deleted.\n                    //The admin service should be responsible for allocating ports\n                    int sshPort = mapPortToRange(8101 + i, minimumPort, maximumPort);\n                    while (usedPorts.contains(sshPort)) {\n                        sshPort++;\n                    }\n                    usedPorts.add(sshPort);\n\n\n                    int rmiServerPort = mapPortToRange(44444 + i, minimumPort, maximumPort);\n                    while (usedPorts.contains(rmiServerPort)) {\n                        rmiServerPort++;\n                    }\n                    usedPorts.add(rmiServerPort);\n                    int rmiRegistryPort = mapPortToRange(1099 + i, minimumPort, maximumPort);\n                    while (usedPorts.contains(rmiRegistryPort)) {\n                        rmiRegistryPort++;\n                    }\n                    usedPorts.add(rmiRegistryPort);\n\n                    try {\n                        adminService.createInstance(containerName,\n                                sshPort,\n                                rmiServerPort,\n                                rmiRegistryPort, null, jvmOptsBuilder.toString(), features, featuresUrls);\n                        adminService.startInstance(containerName, null);\n                    } catch (Throwable t) {\n                        metadata.setFailure(t);\n                    }\n                    result.add(metadata);\n                }\n                return null;\n            }\n        });\n        return result;\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public CreateContainerMetadata[] createContainers(final CreateContainerOptions options) {\n        if (options.getZookeeperUrl() == null && !options.isEnsembleServer()) {\n            options.setZookeeperUrl(getZookeeperUrl());\n        }\n        if (options.getProxyUri() == null) {\n            options.setProxyUri(getMavenRepoURI());\n        }\n        try {\n            ContainerProvider provider = getProvider(options.getProviderType());\n            if (provider == null) {\n                throw new FabricException(\"Unable to find a container provider supporting '\" + options.getProviderType() + \"'\");\n            }\n\n            Container parent = options.getParent() != null ? getContainer(options.getParent()) : null;\n            Set<? extends CreateContainerMetadata>  metadatas = provider.create(options);\n\n            for (CreateContainerMetadata metadata : metadatas) {\n                if (metadata.isSuccess()) {\n                    //An ensemble server can be created without an existing ensemble.\n                    //In this case container config will be created by the newly created container.\n                    //TODO: We need to make sure that this entries are somehow added even to ensemble servers.\n                    if (!options.isEnsembleServer()) {\n                        createContainerConfig(parent != null ? parent.getId() : \"\", metadata.getContainerName());\n                        // Store metadata\n                        //We encode the metadata so that they are more friendly to import/export.\n                        ZooKeeperUtils.set(zooKeeper, ZkPath.CONTAINER_METADATA.getPath(metadata.getContainerName()), Base64Encoder.encode(ObjectUtils.toBytes(metadata)));\n\n                        Map<String,String> configuration = metadata.getContainerConfguration();\n                        for (Map.Entry<String, String> entry : configuration.entrySet()) {\n                            String key = entry.getKey();\n                            String value = entry.getValue();\n                            ZooKeeperUtils.set(zooKeeper, ZkPath.CONTAINER_ENTRY.getPath(metadata.getContainerName(),key),value);\n                        }\n\n                        if (options.getResolver() != null) {\n                            //use the resolver specified in the options and do nothing.\n                        }\n                        else if (zooKeeper.exists(ZkPath.POLICIES.getPath(ZkDefs.RESOLVER)) != null) {\n                            //If there is a globlal resolver specified use it.\n                            options.setResolver(zooKeeper.getStringData(ZkPath.POLICIES.getPath(ZkDefs.RESOLVER)));\n                        } else {\n                            //Fallback to the default resolver\n                            options.setResolver(ZkDefs.DEFAULT_RESOLVER);\n                        }\n                        //Set the resolver\n                        ZooKeeperUtils.set(zooKeeper, ZkPath.CONTAINER_RESOLVER.getPath(metadata.getContainerName()), options.getResolver());\n                    }\n                    metadata.setContainer(new ContainerImpl(parent, metadata.getContainerName(), FabricServiceImpl.this));\n                    ((ContainerImpl) metadata.getContainer()).setMetadata(metadata);\n                    logger.info(\"The container \" + metadata.getContainerName() + \" has been successfully created\");\n                } else {\n                    logger.info(\"The creation of the container \" + metadata.getContainerName() + \" has failed\", metadata.getFailure());\n                }\n            }\n            return metadatas.toArray(new CreateContainerMetadata[metadatas.size()]);\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","id":88990,"modified_method":"public CreateContainerMetadata[] createContainers(final CreateContainerOptions options) {\n        if (options.getZookeeperUrl() == null && !options.isEnsembleServer()) {\n            options.setZookeeperUrl(getZookeeperUrl());\n        }\n        if (options.getProxyUri() == null) {\n            options.setProxyUri(getMavenRepoURI());\n        }\n        try {\n            ContainerProvider provider = getProvider(options.getProviderType());\n            if (provider == null) {\n                throw new FabricException(\"Unable to find a container provider supporting '\" + options.getProviderType() + \"'\");\n            }\n\n            Container parent = options.getParent() != null ? getContainer(options.getParent()) : null;\n            Set<? extends CreateContainerMetadata>  metadatas = provider.create(options);\n\n            for (CreateContainerMetadata metadata : metadatas) {\n                if (metadata.isSuccess()) {\n                    //An ensemble server can be created without an existing ensemble.\n                    //In this case container config will be created by the newly created container.\n                    //TODO: We need to make sure that this entries are somehow added even to ensemble servers.\n                    if (!options.isEnsembleServer()) {\n                        createContainerConfig(parent != null ? parent.getId() : \"\", metadata.getContainerName());\n                        // Store metadata\n                        //We encode the metadata so that they are more friendly to import/export.\n                        ZooKeeperUtils.set(zooKeeper, ZkPath.CONTAINER_METADATA.getPath(metadata.getContainerName()), Base64Encoder.encode(ObjectUtils.toBytes(metadata)));\n\n                        Map<String,String> configuration = metadata.getContainerConfguration();\n                        for (Map.Entry<String, String> entry : configuration.entrySet()) {\n                            String key = entry.getKey();\n                            String value = entry.getValue();\n                            ZooKeeperUtils.set(zooKeeper, ZkPath.CONTAINER_ENTRY.getPath(metadata.getContainerName(),key),value);\n                        }\n\n                        //If no resolver specified but a resolver is already present in the registry, use the registry value\n                        if (options.getResolver() == null && zooKeeper.exists(ZkPath.CONTAINER_RESOLVER.getPath(metadata.getContainerName())) != null) {\n                             options.setResolver(zooKeeper.getStringData(ZkPath.CONTAINER_RESOLVER.getPath(metadata.getContainerName())));\n                        }\n                        else if (options.getResolver() != null) {\n                            //use the resolver specified in the options and do nothing.\n                        }\n                        else if (zooKeeper.exists(ZkPath.POLICIES.getPath(ZkDefs.RESOLVER)) != null) {\n                            //If there is a globlal resolver specified use it.\n                            options.setResolver(zooKeeper.getStringData(ZkPath.POLICIES.getPath(ZkDefs.RESOLVER)));\n                        } else {\n                            //Fallback to the default resolver\n                            options.setResolver(ZkDefs.DEFAULT_RESOLVER);\n                        }\n                        //Set the resolver if not exists\n                        ZooKeeperUtils.set(zooKeeper, ZkPath.CONTAINER_RESOLVER.getPath(metadata.getContainerName()), options.getResolver());\n                    }\n                    metadata.setContainer(new ContainerImpl(parent, metadata.getContainerName(), FabricServiceImpl.this));\n                    ((ContainerImpl) metadata.getContainer()).setMetadata(metadata);\n                    logger.info(\"The container \" + metadata.getContainerName() + \" has been successfully created\");\n                } else {\n                    logger.info(\"The creation of the container \" + metadata.getContainerName() + \" has failed\", metadata.getFailure());\n                }\n            }\n            return metadatas.toArray(new CreateContainerMetadata[metadatas.size()]);\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Returns the container specific resolution policy.\n     *\n     * @param zookeeper\n     * @return\n     * @throws InterruptedException\n     * @throws KeeperException\n     */\n    private static String getContainerResolutionPolicy(IZKClient zookeeper, String container) throws InterruptedException, KeeperException {\n        String policy = null;\n        String globalPolicy =  getGlobalResolutionPolicy(zookeeper);\n        List<String> validResoverList = Arrays.asList(ZkDefs.VALID_RESOLVERS);\n        if (zookeeper.exists(ZkPath.CONTAINER_RESOLVER.getPath(container)) != null) {\n            policy = zookeeper.getStringData(ZkPath.CONTAINER_RESOLVER.getPath(container));\n        } else if (System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY) != null && validResoverList.contains(System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY))) {\n            policy = System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY);\n        }\n\n        if (policy == null || !validResoverList.contains(policy)) {\n            policy = globalPolicy;\n        }\n\n        if (policy != null && zookeeper.exists(ZkPath.CONTAINER_RESOLVER.getPath(container)) == null) {\n            zookeeper.createOrSetWithParents(ZkPath.CONTAINER_RESOLVER.getPath(container), policy, CreateMode.PERSISTENT);\n        }\n        return policy;\n    }","id":88991,"modified_method":"/**\n     * Returns the container specific resolution policy.\n     *\n     * @param zookeeper\n     * @return\n     * @throws InterruptedException\n     * @throws KeeperException\n     */\n    private static String getContainerResolutionPolicy(IZKClient zookeeper, String container) throws InterruptedException, KeeperException {\n        String policy = null;\n        List<String> validResoverList = Arrays.asList(ZkDefs.VALID_RESOLVERS);\n        if (zookeeper.exists(ZkPath.CONTAINER_RESOLVER.getPath(container)) != null) {\n            policy = zookeeper.getStringData(ZkPath.CONTAINER_RESOLVER.getPath(container));\n        } else if (System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY) != null && validResoverList.contains(System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY))) {\n            policy = System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY);\n        }\n\n        if (policy == null) {\n            policy = getGlobalResolutionPolicy(zookeeper);\n        }\n\n        if (policy != null && zookeeper.exists(ZkPath.CONTAINER_RESOLVER.getPath(container)) == null) {\n            zookeeper.createOrSetWithParents(ZkPath.CONTAINER_RESOLVER.getPath(container), policy, CreateMode.PERSISTENT);\n        }\n        return policy;\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testChildContainerResolver() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        try {\n            createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n            Container child1 = getFabricService().getContainer(\"child1\");\n\n            Assert.assertEquals(\"localhostname\", child1.getResolver());\n            String sshUrlWithLocalhostResolver = child1.getSshUrl();\n\n            executeCommand(\"fabric:container-resolver-set --container child1 localip\");\n            Assert.assertEquals(\"localip\", child1.getResolver());\n            String sshUrlWithLocalIpResolver = child1.getSshUrl();\n            //Check that the SSH URL has been updated.\n            System.out.println(\"SSH URL with \"+sshUrlWithLocalhostResolver+\" resolver: localhostname\");\n            System.out.println(\"SSH URL with \"+ sshUrlWithLocalIpResolver+\" resolver: localip\" );\n            Assert.assertNotSame(sshUrlWithLocalhostResolver, sshUrlWithLocalIpResolver);\n\n            IZKClient zookeeper  = getOsgiService(IZKClient.class);\n            ZooKeeperUtils.set(zookeeper, ZkPath.CONTAINER_PUBLIC_IP.getPath(\"child1\"), \"my.public.ip.address\");\n            executeCommand(\"fabric:container-resolver-set --container child1 publicip\");\n            Assert.assertEquals(\"publicip\", child1.getResolver());\n            String sshUrlWithPublicIpResolver = child1.getSshUrl();\n            System.out.println(\"SSH URL with \"+ sshUrlWithPublicIpResolver+\" resolver: publicip\" );\n            Assert.assertNotNull(sshUrlWithPublicIpResolver);\n            Assert.assertTrue(sshUrlWithPublicIpResolver.startsWith(\"my.public.ip.address\"));\n\n            ZooKeeperUtils.set(zookeeper, ZkPath.CONTAINER_MANUAL_IP.getPath(\"child1\"), \"my.manual.ip.address\");\n            executeCommand(\"fabric:container-resolver-set --container child1 manualip\");\n            Assert.assertEquals(\"manualip\", child1.getResolver());\n            String sshUrlWithManualIpResolver = child1.getSshUrl();\n\n            System.out.println(\"SSH URL with \"+sshUrlWithManualIpResolver+\" resolver: manualip\" );\n            Assert.assertNotNull(sshUrlWithManualIpResolver);\n            Assert.assertTrue(sshUrlWithManualIpResolver.startsWith(\"my.manual.ip.address\"));\n\n\n        } finally {\n            destroyChildContainer(\"child1\");\n        }\n    }","id":88992,"modified_method":"@Test\n    public void testChildContainerResolver() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        IZKClient zookeeper = getOsgiService(IZKClient.class);\n        try {\n            createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n            Container child1 = getFabricService().getContainer(\"child1\");\n\n            Assert.assertEquals(\"localhostname\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            String sshUrlWithLocalhostResolver = child1.getSshUrl();\n\n            executeCommand(\"fabric:container-resolver-set --container child1 localip\");\n            Assert.assertEquals(\"localip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            String sshUrlWithLocalIpResolver = child1.getSshUrl();\n            //Check that the SSH URL has been updated.\n            System.out.println(\"SSH URL with \"+sshUrlWithLocalhostResolver+\" resolver: localhostname\");\n            System.out.println(\"SSH URL with \"+ sshUrlWithLocalIpResolver+\" resolver: localip\" );\n            Assert.assertNotSame(sshUrlWithLocalhostResolver, sshUrlWithLocalIpResolver);\n\n            ZooKeeperUtils.set(zookeeper, ZkPath.CONTAINER_PUBLIC_IP.getPath(\"child1\"), \"my.public.ip.address\");\n            executeCommand(\"fabric:container-resolver-set --container child1 publicip\");\n            Assert.assertEquals(\"publicip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            String sshUrlWithPublicIpResolver = child1.getSshUrl();\n            System.out.println(\"SSH URL with \"+ sshUrlWithPublicIpResolver+\" resolver: publicip\" );\n            Assert.assertNotNull(sshUrlWithPublicIpResolver);\n            Assert.assertTrue(sshUrlWithPublicIpResolver.startsWith(\"my.public.ip.address\"));\n\n            ZooKeeperUtils.set(zookeeper, ZkPath.CONTAINER_MANUAL_IP.getPath(\"child1\"), \"my.manual.ip.address\");\n            executeCommand(\"fabric:container-resolver-set --container child1 manualip\");\n            Assert.assertEquals(\"manualip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            String sshUrlWithManualIpResolver = child1.getSshUrl();\n\n            System.out.println(\"SSH URL with \"+sshUrlWithManualIpResolver+\" resolver: manualip\" );\n            Assert.assertNotNull(sshUrlWithManualIpResolver);\n            Assert.assertTrue(sshUrlWithManualIpResolver.startsWith(\"my.manual.ip.address\"));\n\n\n        } finally {\n            destroyChildContainer(\"child1\");\n        }\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testRootContainerResolver() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        Container current = getFabricService().getCurrentContainer();\n\n        Assert.assertEquals(\"localhostname\", current.getResolver());\n        String sshUrlWithLocalhostResolver = current.getSshUrl();\n\n        executeCommand(\"fabric:container-resolver-set localip\");\n        Assert.assertEquals(\"localip\", current.getResolver());\n        String sshUrlWithLocalIpResolver = current.getSshUrl();\n        //Check that the SSH URL has been updated.\n        System.out.println(\"SSH URL with \" + sshUrlWithLocalhostResolver + \" resolver: localhostname\");\n        System.out.println(\"SSH URL with \" + sshUrlWithLocalIpResolver + \" resolver:\");\n        Assert.assertNotSame(sshUrlWithLocalhostResolver, sshUrlWithLocalIpResolver);\n    }","id":88993,"modified_method":"@Test\n    public void testRootContainerResolver() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        Container current = getFabricService().getCurrentContainer();\n\n        Assert.assertEquals(\"localhostname\", current.getResolver());\n        String sshUrlWithLocalhostResolver = current.getSshUrl();\n\n        //We need to wait till fabric commands are available.\n        getOsgiService(BlueprintContainer.class, \"(osgi.blueprint.container.symbolicname=org.fusesource.fabric.fabric-commands)\", DEFAULT_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:container-resolver-set --container root localip\"));\n        Assert.assertEquals(\"localip\", current.getResolver());\n        String sshUrlWithLocalIpResolver = current.getSshUrl();\n        //Check that the SSH URL has been updated.\n        System.out.println(\"SSH URL with \" + sshUrlWithLocalhostResolver + \" resolver: localhostname\");\n        System.out.println(\"SSH URL with \" + sshUrlWithLocalIpResolver + \" resolver:\");\n        Assert.assertNotSame(sshUrlWithLocalhostResolver, sshUrlWithLocalIpResolver);\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testGlobalResolverInheritanceOnChild() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n -g localip -r manualip --manual-ip localhost\"));\n        try {\n            createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n            Container child1 = getFabricService().getContainer(\"child1\");\n\n            Assert.assertEquals(\"localip\", child1.getResolver());\n            Assert.assertEquals(\"manualip\", getFabricService().getCurrentContainer().getResolver());\n\n        } finally {\n            destroyChildContainer(\"child1\");\n        }\n    }","id":88994,"modified_method":"@Test\n    public void testResolverInheritanceOnChild() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n -g localip -r manualip --manual-ip localhost\"));\n        IZKClient zookeeper = getOsgiService(IZKClient.class);\n        try {\n            createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n\n            Assert.assertEquals(\"manualip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n            Assert.assertEquals(\"manualip\", getFabricService().getCurrentContainer().getResolver());\n\n            //We want to make sure that the child points to the parent, so we change the parent resolvers and assert.\n            getOsgiService(BlueprintContainer.class, \"(osgi.blueprint.container.symbolicname=org.fusesource.fabric.fabric-commands)\", DEFAULT_TIMEOUT);\n            System.err.println(executeCommand(\"fabric:container-resolver-set --container root localip\"));\n            Assert.assertEquals(\"localip\", ZooKeeperUtils.getSubstitutedPath(zookeeper, ZkPath.CONTAINER_RESOLVER.getPath(\"child1\")));\n\n        } finally {\n            destroyChildContainer(\"child1\");\n        }\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return fabricDistributionConfiguration();\n    }","id":88995,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[] {\n                new DefaultCompositeOption(fabricDistributionConfiguration()),\n                //debugConfiguration(\"5005\",true)\n        };\n    }","commit_id":"f3214aac51689e0f737dce232390beb625c25143","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return fabricDistributionConfiguration();\n    }","id":88996,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[] {new DefaultCompositeOption(fabricDistributionConfiguration()),\n               mavenBundle(\"org.apache.activemq\", \"activemq-all\", MavenUtils.getArtifactVersion(\"org.apache.activemq\", \"activemq-core\"))};\n    }","commit_id":"5ad9ffe523045418cd7d3ae032a2d169cf3405e0","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testSshPortRegistration() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n\n        FabricService fabricService = getOsgiService(FabricService.class);\n        Container child1 = fabricService.getContainer(\"child1\");\n        System.err.println(executeCommand(\"fabric:profile-edit --i org.apache.karaf.shell default\"));\n        System.err.println(executeCommand(\"fabric:profile-edit --pid org.apache.karaf.shell/sshPort=8105 default\"));\n        Thread.sleep(DEFAULT_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:container-connet child1 config:proplist --pid org.apache.karaf.shell\"));\n        String sshUrl = child1.getSshUrl();\n        Assert.assertTrue(sshUrl.endsWith(\"8105\"));\n    }","id":88997,"modified_method":"@Test\n    public void testSshPortRegistration() throws Exception {\n        System.err.println(executeCommand(\"fabric:create -n\"));\n        createAndAssertChildContainer(\"child1\", \"root\", \"default\");\n\n        FabricService fabricService = getOsgiService(FabricService.class);\n        Container child1 = fabricService.getContainer(\"child1\");\n        System.err.println(executeCommand(\"fabric:profile-edit --i org.apache.karaf.shell default\"));\n        System.err.println(executeCommand(\"fabric:profile-edit --pid org.apache.karaf.shell/sshPort=8105 default\"));\n        Thread.sleep(DEFAULT_TIMEOUT);\n        System.err.println(executeCommand(\"fabric:container-connect child1 config:proplist --pid org.apache.karaf.shell\"));\n        String sshUrl = child1.getSshUrl();\n        Assert.assertTrue(sshUrl.endsWith(\"8105\"));\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return fabricDistributionConfiguration();\n    }","id":88998,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[] {\n                new DefaultCompositeOption(fabricDistributionConfiguration()),\n                debugConfiguration(\"5005\",true)\n        };\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Create an {@link Option} for using a Fabric distribution.\n     *\n     * @return\n     */\n    protected Option[] fabricDistributionConfiguration() {\n        return new Option[] {\n                    karafDistributionConfiguration().frameworkUrl(\n                            maven().groupId(GROUP_ID).artifactId(ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                        .karafVersion(getKarafVersion()).name(\"Fabric Karaf Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\")),\n                    useOwnExamBundlesStartLevel(50),\n                    editConfigurationFilePut(\"etc/config.properties\", \"karaf.startlevel.bundle\", \"50\"),\n                    mavenBundle(\"org.fusesource.tooling.testing\",\"pax-exam-karaf\", MavenUtils.getArtifactVersion(\"org.fusesource.tooling.testing\",\"pax-exam-karaf\")),\n                    logLevel(LogLevelOption.LogLevel.ERROR),\n                    keepRuntimeFolder()\n                };\n    }","id":88999,"modified_method":"/**\n     * Create an {@link Option} for using a Fabric distribution.\n     *\n     * @return\n     */\n    protected Option[] fabricDistributionConfiguration() {\n        return new Option[] {\n                    karafDistributionConfiguration().frameworkUrl(\n                            maven().groupId(GROUP_ID).artifactId(ARTIFACT_ID).versionAsInProject().type(\"tar.gz\"))\n                        .karafVersion(getKarafVersion()).name(\"Fabric Karaf Distro\").unpackDirectory(new File(\"target/paxexam/unpack/\")),\n                    useOwnExamBundlesStartLevel(50),\n                    editConfigurationFilePut(\"etc/config.properties\", \"karaf.startlevel.bundle\", \"50\"),\n                    editConfigurationFilePut(\"etc/users.properties\", \"admin\", \"admin,admin\"),\n                    mavenBundle(\"org.fusesource.tooling.testing\",\"pax-exam-karaf\", MavenUtils.getArtifactVersion(\"org.fusesource.tooling.testing\",\"pax-exam-karaf\")),\n                    logLevel(LogLevelOption.LogLevel.ERROR),\n                    keepRuntimeFolder()\n                };\n    }","commit_id":"0884340b8648a10a392193026b242be6df5b3a3d","url":"https://github.com/fabric8io/fabric8"}]